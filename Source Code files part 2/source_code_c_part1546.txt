acmFormatTagDetails> <f acmDriverDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatDetails
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    DWORD                   fdwDetails
)
{
    PACMGARB	    pag;
    MMRESULT        mmr;
    PACMDRIVER      pad;
    HACMDRIVERID    hadid;
    DWORD           dwQuery;
    BOOL            fNone;

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatDetails: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //
    //
    V_DFLAGS(fdwDetails, ACM_FORMATDETAILSF_VALID, acmFormatDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFORMATDETAILS) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(PCMWAVEFORMAT) > pafd->cbwfx)
    {
        DebugErr(DBF_ERROR, "acmFormatDetails: cbwfx member must be at least sizeof(PCMWAVEFORMAT).");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd->pwfx, pafd->cbwfx, MMSYSERR_INVALPARAM);

    if (0L != pafd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFormatDetails: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    dwQuery = ACM_FORMATDETAILSF_QUERYMASK & fdwDetails;

    switch (dwQuery)
    {
        case ACM_FORMATDETAILSF_FORMAT:
            if (pafd->dwFormatTag != pafd->pwfx->wFormatTag)
            {
                DebugErr(DBF_ERROR, "acmFormatDetails: format tags must match.");
                return  (MMSYSERR_INVALPARAM);
            }

            // -- fall through -- //

        case ACM_FORMATDETAILSF_INDEX:
            if (WAVE_FORMAT_UNKNOWN == pafd->dwFormatTag)
            {
                DebugErr(DBF_ERROR, "acmFormatDetails: dwFormatTag cannot be WAVE_FORMAT_UNKNOWN for requested details query.");
                return (MMSYSERR_INVALPARAM);
            }

            //
            //  we don't (currently) support index based enumeration across
            //  all drivers... may never support this. so validate the
            //  handle and fail if not valid (like NULL).
            //
            if (ACM_FORMATDETAILSF_INDEX == dwQuery)
            {
                ACMFORMATTAGDETAILS aftd;

                V_HANDLE(had, TYPE_HACMOBJ, MMSYSERR_INVALHANDLE);

                _fmemset(&aftd, 0, sizeof(aftd));
                aftd.cbStruct    = sizeof(aftd);
                aftd.dwFormatTag = pafd->dwFormatTag;
                mmr = acmFormatTagDetails(had, &aftd, ACM_FORMATTAGDETAILSF_FORMATTAG);
                if (MMSYSERR_NOERROR != mmr)
                {
                    return (mmr);
                }

                if (pafd->dwFormatIndex >= aftd.cStandardFormats)
                {
                    DebugErr1(DBF_ERROR, "acmFormatTagDetails: dwFormatIndex (%lu) out of range.", pafd->dwFormatIndex);
                    return (MMSYSERR_INVALPARAM);
                }
            }
            break;

        default:
            DebugErr(DBF_ERROR, "acmFormatDetails: unknown query type specified.");
            return  (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  if we are passed a driver handle, then use it
    //
    if (NULL != had)
    {
        pafd->szFormat[0] = '\0';

        pad = (PACMDRIVER)had;

        EnterHandle(had);
        if (TYPE_HACMDRIVERID == pad->uHandleType)
        {
            V_HANDLE(had, TYPE_HACMDRIVERID, MMSYSERR_INVALHANDLE);

            //
            //
            //
            mmr = (MMRESULT)IDriverMessageId((HACMDRIVERID)had,
                                             ACMDM_FORMAT_DETAILS,
                                             (LPARAM)pafd,
                                             fdwDetails);
        }
        else
        {
            V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

            //
            //
            //
            mmr = (MMRESULT)IDriverMessage(had,
                                           ACMDM_FORMAT_DETAILS,
                                           (LPARAM)pafd,
                                           fdwDetails);
        }

        LeaveHandle(had);

        if (MMSYSERR_NOERROR == mmr)
        {
            if ('\0' == pafd->szFormat[0])
            {
                IFormatDetailsToString(pafd);
            }

            //
            //  if caller is asking for details on a specific format, then
            //  always return index equal to zero (it means nothing)
            //
            if (ACM_FORMATDETAILSF_FORMAT == dwQuery)
            {
                pafd->dwFormatIndex = 0;
            }
        }

        return (mmr);
    }


    //
    //
    //
    fNone = TRUE;
    hadid = NULL;
    mmr   = MMSYSERR_NODRIVER;

    ENTER_LIST_SHARED;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
    {
        fNone = FALSE;

        //
        //
        //
        pafd->szFormat[0] = '\0';

        EnterHandle(hadid);
        mmr = (MMRESULT)IDriverMessageId(hadid,
                                         ACMDM_FORMAT_DETAILS,
                                         (LPARAM)pafd,
                                         fdwDetails);
        LeaveHandle(hadid);

        if (MMSYSERR_NOERROR == mmr)
        {
            if ('\0' == pafd->szFormat[0])
            {
                IFormatDetailsToString(pafd);
            }

            //
            //  if caller is asking for details on a specific format, then
            //  always return index equal to zero (it means nothing)
            //
            if (ACM_FORMATDETAILSF_FORMAT == dwQuery)
            {
                pafd->dwFormatIndex = 0;
            }
            break;
        }
    }

    LEAVE_LIST_SHARED;

    if( fNone && (dwQuery == ACM_FORMATDETAILSF_FORMAT) &&
                (pafd->dwFormatTag == WAVE_FORMAT_PCM) ) {
        pafd->dwFormatIndex = 0;
        pafd->dwFormatTag   = WAVE_FORMAT_PCM;
        pafd->fdwSupport    = 0;
        pafd->cbwfx         = sizeof( PCMWAVEFORMAT );

        if ( FIELD_OFFSET(ACMFORMATDETAILS, szFormat) <
                    pafd->cbStruct ) {
            pafd->szFormat[0] = '\0';
            IFormatDetailsToString(pafd);
        }
        return( MMSYSERR_NOERROR );
    }

    return (mmr);
} // acmFormatDetails()


#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFormatDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT                mmr;
    ACMFORMATDETAILSW       afdW;

    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*pafd) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatDetails: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    afdW.cbStruct = sizeof(afdW);
    memcpy(&afdW.dwFormatIndex,
           &pafd->dwFormatIndex,
           FIELD_OFFSET(ACMFORMATDETAILSA, szFormat) -
           FIELD_OFFSET(ACMFORMATDETAILSA, dwFormatIndex));

    mmr = acmFormatDetailsW(had, &afdW, fdwDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        memcpy(&pafd->dwFormatIndex,
               &afdW.dwFormatIndex,
               FIELD_OFFSET(ACMFORMATDETAILSA, szFormat) -
               FIELD_OFFSET(ACMFORMATDETAILSA, dwFormatIndex));

        pafd->cbStruct = min(pafd->cbStruct, sizeof(*pafd));
        Iwcstombs(pafd->szFormat, afdW.szFormat, sizeof(pafd->szFormat));
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    DWORD                   fdwDetails
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif



/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api BOOL ACMFORMATTAGENUMCB | acmFormatTagEnumCallback |
 *      The <f acmFormatTagEnumCallback> function refers to the callback function used for
 *      Audio Compression Manager (ACM) wave format tag enumeration. The
 *      <f acmFormatTagEnumCallback> function is a placeholder for the application-supplied
 *      function name.
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm  LPACMFORMATTAGDETAILS | paftd | Specifies a pointer to an
 *      <t ACMFORMATTAGDETAILS> structure that contains the enumerated
 *      format tag details.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmFormatTagEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the format tag. These flags are identical to the
 *      <e ACMDRIVERDETAILS.fdwSupport> flags of the <t ACMDRIVERDETAILS>
 *      structure. This argument can be a combination of the following
 *      values and indicates which operations the driver supports with the
 *      format tag:
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags where one of
 *      the tags is the specified format tag. For example, if a driver
 *      supports compression from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM,
 *      then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      specified format tag. For example, if a driver supports resampling
 *      of WAVE_FORMAT_PCM, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes). For example, if a driver supports volume
 *      or echo operations on the specified format tag, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output of the specified format tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmFormatTagEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no format tags are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f acmFormatTagEnum> <f acmFormatTagDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatTagEnum | The <f acmFormatTagEnum> function
 *      enumerates wave format tags available from an Audio Compression
 *      Manager (ACM) driver. The <f acmFormatTagEnum> function continues
 *      enumerating until there are no more suitable format tags or the
 *      callback function returns FALSE.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave format tag details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFORMATTAGDETAILS | paftd | Specifies a pointer to the
 *      <t ACMFORMATTAGDETAILS> structure that is to receive the format
 *      tag details passed to the <p fnCallback> function. This structure
 *      must have the <e ACMFORMATTAGDETAILS.cbStruct> member of the
 *      <t ACMFORMATTAGDETAILS> structure initialized.
 *
 *  @parm ACMFORMATTAGENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function; or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit, application-defined value
 *      that is passed to the callback function along with ACM format tag
 *      details.
 *
 *  @parm DWORD | fdwEnum | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *  @comm The <f acmFormatTagEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable ACM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f acmFormatTagEnumCallback> <f acmFormatTagDetails>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatTagEnum
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    ACMFORMATTAGENUMCB      fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    PACMGARB		pag;
    PACMDRIVER          pad;
    PACMDRIVERID        padid;
    UINT                uIndex;
    UINT                uFormatTag;
    BOOL                f;
    HACMDRIVERID        hadid;
    PACMDRIVERID        padidCur;
    HACMDRIVERID        hadidCur;
    BOOL                fSent;
    BOOL                fNone;
    DWORD               cbaftd;
    DWORD               fdwSupport;
    MMRESULT		mmr;

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatTagEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //
    //
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_FORMATTAGENUMF_VALID, acmFormatTagEnum, MMSYSERR_INVALFLAG);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFORMATTAGDETAILS) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatTagEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    if (0L != paftd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFormatTagEnum: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    cbaftd = min(paftd->cbStruct, sizeof(ACMFORMATTAGDETAILS));


    //
    //
    //
    //
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

        //
        //  enum format tags for this driver only.
        //
        pad   = (PACMDRIVER)had;
        padid = (PACMDRIVERID)pad->hadid;

        //
        //  do NOT include the 'disabled' bit!
        //
        fdwSupport = padid->fdwSupport;

        //
        //  while there are Formats to enumerate and we have not been
        //  told to stop (client returns FALSE to stop enum)
        //
	mmr = MMSYSERR_NOERROR;
        for (uIndex = 0; uIndex < padid->cFormatTags; uIndex++)
        {
	    paftd->cbStruct = cbaftd;
	    paftd->dwFormatTagIndex = uIndex;
	    mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid, paftd, ACM_FORMATTAGDETAILSF_INDEX);
	    if (MMSYSERR_NOERROR != mmr) {
		break;
	    }
	
            f = (* fnCallback)(pad->hadid, paftd, dwInstance, fdwSupport);
            if (FALSE == f)
                break;
        }

        return (mmr);
    }


    //
    //
    //
    //
    hadidCur = NULL;
    fNone = TRUE;

    ENTER_LIST_SHARED;

    while (!IDriverGetNext(pag, &hadidCur, hadidCur, 0L))
    {
        padidCur = (PACMDRIVERID)hadidCur;

        for (uIndex = 0; uIndex < padidCur->cFormatTags; uIndex++)
        {
            fNone = FALSE;
            uFormatTag = (UINT)(padidCur->paFormatTagCache[uIndex].dwFormatTag);
            fSent = FALSE;
            hadid = NULL;
            while (!fSent && !IDriverGetNext(pag, &hadid, hadid, 0L))
            {
                UINT    u;

                //
                //  same driver ?
                //
                if (hadid == hadidCur)
                    break;


                //
                //  for every previous driver
                //
                padid = (PACMDRIVERID)hadid;

                for (u = 0; u < padid->cFormatTags; u++)
                {
                    //
                    //  for every FormatTag in the driver
                    //
                    if (uFormatTag == padid->paFormatTagCache[u].dwFormatTag)
                    {
                        //
                        //  we have a match, but this was already given.
                        //
                        fSent = TRUE;
                        break;
                    }
                }
            }

            if (!fSent)
            {
                //
                //  we have a format that has not been sent yet.
                //
		paftd->dwFormatTagIndex = uIndex;
		paftd->cbStruct = cbaftd;
		mmr = IFormatTagDetails(pag, (HACMDRIVERID)padidCur,
					paftd, ACM_FORMATTAGDETAILSF_INDEX);
		if (MMSYSERR_NOERROR != mmr)
		{
		    LEAVE_LIST_SHARED;
		    return mmr;
		}

                //
		//  do NOT include the 'disabled' bit!
                //
                fdwSupport = padidCur->fdwSupport;

                f = (* fnCallback)(hadidCur, paftd, dwInstance, fdwSupport);
                if (FALSE == f) {
                    LEAVE_LIST_SHARED;
                    return (MMSYSERR_NOERROR);
            }
        }
    }
    }

    LEAVE_LIST_SHARED;

    if( fNone ) {
        /* No codecs enabled */
        /* Enum PCM as default */

        fdwSupport = 0L;

        paftd->dwFormatTagIndex = 0;
        paftd->dwFormatTag      = WAVE_FORMAT_PCM;
        paftd->cbFormatSize     = sizeof(PCMWAVEFORMAT);
        paftd->fdwSupport       = fdwSupport;
        paftd->cStandardFormats = CODEC_MAX_STANDARD_FORMATS_PCM;

        //
        //  the ACM is responsible for the PCM format tag name
        //
#if defined(WIN32) && !defined(UNICODE)
	LoadStringW(pag->hinst,
		    IDS_FORMAT_TAG_PCM,
		    paftd->szFormatTag,
		    SIZEOFW(paftd->szFormatTag));
#else
	LoadString(pag->hinst,
                   IDS_FORMAT_TAG_PCM,
                   paftd->szFormatTag,
                   SIZEOF(paftd->szFormatTag));
#endif
	
        (* fnCallback)(NULL, paftd, dwInstance, fdwSupport);
    }

    return (MMSYSERR_NOERROR);
}


#ifdef WIN32
#if TRUE    // defined(UNICODE)

typedef struct tIFORMATTAGENUMCBINSTANCEW
{
    ACMFORMATTAGENUMCBA         fnCallback;
    DWORD_PTR                   dwInstance;
    LPACMFORMATTAGDETAILSA      paftd;

} IFORMATTAGENUMCBINSTANCEW, *PIFORMATTAGENUMCBINSTANCEW;

BOOL FNWCALLBACK IFormatTagEnumCallbackW
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILSW  paftdW,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    PIFORMATTAGENUMCBINSTANCEW  pfti;
    BOOL                        f;

    pfti = (PIFORMATTAGENUMCBINSTANCEW)dwInstance;

    memcpy(&pfti->paftd->dwFormatTagIndex,
           &paftdW->dwFormatTagIndex,
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, szFormatTag) -
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, dwFormatTagIndex));

    pfti->paftd->cbStruct = sizeof(*pfti->paftd);
    Iwcstombs(pfti->paftd->szFormatTag, paftdW->szFormatTag, sizeof(pfti->paftd->szFormatTag));

    f = pfti->fnCallback(hadid, pfti->paftd, pfti->dwInstance, fdwSupport);

    return (f);
}


MMRESULT ACMAPI acmFormatTagEnumA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    ACMFORMATTAGENUMCBA     fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    MMRESULT                    mmr;
    ACMFORMATTAGDETAILSW        aftdW;
    IFORMATTAGENUMCBINSTANCEW   fti;

    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_WPOINTER(paftd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*paftd) > paftd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatTagEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(paftd, paftd->cbStruct, MMSYSERR_INVALPARAM);

    aftdW.cbStruct = sizeof(aftdW);
    memcpy(&aftdW.dwFormatTagIndex,
           &paftd->dwFormatTagIndex,
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, szFormatTag) -
           FIELD_OFFSET(ACMFORMATTAGDETAILSA, dwFormatTagIndex));

    fti.fnCallback = fnCallback;
    fti.dwInstance = dwInstance;
    fti.paftd      = paftd;

    mmr = acmFormatTagEnumW(had, &aftdW, IFormatTagEnumCallbackW, (DWORD_PTR)&fti, fdwEnum);

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatTagEnumW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    ACMFORMATTAGENUMCBW     fnCallback,
    DWORD                   dwInstance,
    DWORD                   fdwEnum
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


//--------------------------------------------------------------------------;
//
//  BOOL ISupported
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvrMapper:
//
//      LPWAVEFORMATEX pwfx:
//
//      DWORD fdwEnum:
//
//  Return (BOOL):
//
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL ISupported
(
    HDRVR                   hdrvrMapper,
    LPWAVEFORMATEX          pwfx,
    DWORD                   fdwEnum
)
{
    UINT                cWaveDevs;
    MMRESULT            mmr;
    DWORD               dw;
    BOOL                fPrefOnly;
    UINT                uIdPref;
    UINT                u;


    //
    //  if the 'hardware' bit is not set, then simply test for support
    //  through the mapper..
    //
    if (0 == (ACM_FORMATENUMF_HARDWARE & fdwEnum))
    {
        if (0 != (ACM_FORMATENUMF_OUTPUT & fdwEnum))
        {
            mmr = waveOutOpen(NULL, (UINT)WAVE_MAPPER,
#ifndef _WIN32
                              (LPWAVEFORMAT)pwfx,
#else
                              pwfx,
#endif
                              0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);
            if (MMSYSERR_NOERROR == mmr)
            {
                return (TRUE);
            }
        }

        if (0 != (ACM_FORMATENUMF_INPUT & fdwEnum))
        {
            mmr = waveInOpen(NULL, (UINT)WAVE_MAPPER,
#ifndef _WIN32
                             (LPWAVEFORMAT)pwfx,
#else
                             pwfx,
#endif
                             0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);
            if (MMSYSERR_NOERROR == mmr)
            {
                return (TRUE);
            }
        }

        return (FALSE);
    }


    //
    //  output device...
    //
    if ((0 != (fdwEnum & ACM_FORMATENUMF_OUTPUT)) &&
        (0 != (cWaveDevs = waveOutGetNumDevs())))
    {
        dw = MAKELONG(LOWORD(WAVE_MAPPER), FALSE);
        if (NULL != hdrvrMapper)
        {
            SendDriverMessage(hdrvrMapper,
                              DRV_MAPPER_PREFERRED_OUTPUT_GET,
                              (LPARAM)(LPVOID)&dw, 0L);
        }

        fPrefOnly = (BOOL)(int)HIWORD(dw);

        if (fPrefOnly)
        {
            uIdPref = (UINT)(int)(short)LOWORD(dw);

            mmr = waveOutOpen(NULL, uIdPref,
#ifndef _WIN32
                              (LPWAVEFORMAT)pwfx,
#else
                              pwfx,
#endif
                              0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);

            if (MMSYSERR_NOERROR == mmr)
            {
                return (TRUE);
            }
        }
        else
        {
            for (u = 0; u < cWaveDevs; u++)
            {
                mmr = waveOutOpen(NULL, u,
#ifndef _WIN32
                                  (LPWAVEFORMAT)pwfx,
#else
                                  pwfx,
#endif
                                  0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);

                if (MMSYSERR_NOERROR == mmr)
                {
                    return (TRUE);
                }
            }
        }
    }


    //
    //  input device
    //
    if ((0 != (fdwEnum & ACM_FORMATENUMF_INPUT)) &&
        (0 != (cWaveDevs = waveInGetNumDevs())))
    {
        //
        //
        //
        dw = MAKELONG(LOWORD(WAVE_MAPPER), FALSE);
        if (NULL != hdrvrMapper)
        {
            SendDriverMessage(hdrvrMapper,
                              DRV_MAPPER_PREFERRED_INPUT_GET,
                              (LPARAM)(LPVOID)&dw, 0L);
        }

        //
        //
        //
        fPrefOnly = (BOOL)(int)HIWORD(dw);

        if (fPrefOnly)
        {
            uIdPref = (UINT)(int)(short)LOWORD(dw);

            mmr  = waveInOpen(NULL, uIdPref,
#ifndef _WIN32
                              (LPWAVEFORMAT)pwfx,
#else
                              pwfx,
#endif
                              0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);

            if (MMSYSERR_NOERROR == mmr)
            {
                return (TRUE);
            }
        }
        else
        {
            for (u = 0; u < cWaveDevs; u++)
            {
                mmr = waveInOpen(NULL, u,
#ifndef _WIN32
                                 (LPWAVEFORMAT)pwfx,
#else
                                 pwfx,
#endif
                                 0L, 0L, WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC);

                if (MMSYSERR_NOERROR == mmr)
                {
                    return (TRUE);
                }
            }
        }
    }

    return (FALSE);
} // ISupported()




//--------------------------------------------------------------------------;
//
//  MMRESULT ISuggestEnum
//
//  Description:
//
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL ISuggestEnum
(
    HDRVR                   hdrvrMapper,
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    LPWAVEFORMATEX          pwfxSrc,
    DWORD                   fdwEnum
)
{
    MMRESULT            mmr;
    BOOL                f;
    DWORD               fdwSuggest;
    DWORD               fdwSupport;
    HACMDRIVERID        hadid;

    DV_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

    hadid = ((PACMDRIVER)had)->hadid;

    fdwSupport = ((PACMDRIVERID)hadid)->fdwSupport;

    pafd->dwFormatTag       = paftd->dwFormatTag;
    pafd->fdwSupport        = 0L;
    pafd->pwfx->wFormatTag  = (WORD)(paftd->dwFormatTag);

    fdwSuggest = ACM_FORMATSUGGESTF_WFORMATTAG;
    if( fdwEnum & ACM_FORMATENUMF_NCHANNELS ) {
        fdwSuggest |= ACM_FORMATSUGGESTF_NCHANNELS;
    }
    if( fdwEnum & ACM_FORMATENUMF_NSAMPLESPERSEC ) {
        fdwSuggest |= ACM_FORMATSUGGESTF_NSAMPLESPERSEC;
    }
    if( fdwEnum & ACM_FORMATENUMF_WBITSPERSAMPLE ) {
        fdwSuggest |= ACM_FORMATSUGGESTF_WBITSPERSAMPLE;
    }

    mmr = acmFormatSuggest(had, pwfxSrc, pafd->pwfx, pafd->cbwfx, fdwSuggest);
    if( mmr != MMSYSERR_NOERROR )
    {
        return (MMSYSERR_NOERROR);
    }

    mmr = acmFormatDetails(had, pafd, ACM_FORMATDETAILSF_FORMAT);
    if (MMSYSERR_NOERROR != mmr)
    {
        return (MMSYSERR_NOERROR);
    }

    if (0 != ((ACM_FORMATENUMF_INPUT | ACM_FORMATENUMF_OUTPUT) & fdwEnum))
    {
        if (!ISupported(hdrvrMapper, pafd->pwfx, fdwEnum))
        {
            return (MMSYSERR_NOERROR);
        }
    }

    f = (* fnCallback)(hadid, pafd, dwInstance, fdwSupport);
    if (!f)
        return (MMSYSERR_ERROR);

    return (MMSYSERR_NOERROR);
} // ISuggestEnum()


//--------------------------------------------------------------------------;
//
//  MMRESULT IFormatEnum
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPACMFORMATTAGDETAILS paftd:
//
//      LPACMFORMATDETAILS pafd:
//
//      ACMFORMATENUMCB fnCallback:
//
//      DWORD_PTR dwInstance:
//
//  Return (MMRESULT):
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IFormatEnum
(
    HDRVR                   hdrvrMapper,
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    LPWAVEFORMATEX          pwfxSrc,
    DWORD                   fdwEnum
)
{
    MMRESULT            mmr;
    BOOL                f;
    DWORD               cbafd;
    LPWAVEFORMATEX      pwfx;
    DWORD               cbwfx;
    UINT                u;
    UINT                nChannels;
    DWORD               nSamplesPerSec;
    UINT                uBitsPerSample;
    LPWAVEFORMATEX      pwfxSuggest;
    DWORD               cbwfxSuggest;
    DWORD               fdwSupport;
    DWORD               fdwSuggest;
    HACMDRIVERID        hadid;

    DV_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

    //
    //
    //
    //
    pwfxSuggest = NULL;
    if (0 != (ACM_FORMATENUMF_CONVERT & fdwEnum))
    {
        mmr = IMetricsMaxSizeFormat( NULL, had, &cbwfxSuggest );
        if (MMSYSERR_NOERROR == mmr)
        {
            pwfxSuggest = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfxSuggest);

            DPF(5, "allocating %lu bytes for pwfxSuggest=%.08lXh", cbwfxSuggest, pwfxSuggest);

            if (NULL != pwfxSuggest)
            {
                fdwSuggest = ACM_FORMATSUGGESTF_WFORMATTAG;
                pwfxSuggest->wFormatTag = LOWORD(paftd->dwFormatTag);

                if (0 != (ACM_FORMATENUMF_NCHANNELS & fdwEnum))
                {
                    fdwSuggest |= ACM_FORMATSUGGESTF_NCHANNELS;
                    pwfxSuggest->nChannels = pwfxSrc->nChannels;
                }
                if (0 != (ACM_FORMATENUMF_NSAMPLESPERSEC & fdwEnum))
                {
                    fdwSuggest |= ACM_FORMATSUGGESTF_NSAMPLESPERSEC;
                    pwfxSuggest->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
                }
                if (0 != (ACM_FORMATENUMF_WBITSPERSAMPLE & fdwEnum))
                {
                    fdwSuggest |= ACM_FORMATSUGGESTF_WBITSPERSAMPLE;
                    pwfxSuggest->wBitsPerSample = pwfxSrc->wBitsPerSample;
                }

                DPF(5, "calling acmFormatSuggest pwfxSuggest=%.08lXh--fdwSuggest=%.08lXh", pwfxSuggest, fdwSuggest);

                mmr = acmFormatSuggest(had, pwfxSrc, pwfxSuggest, cbwfxSuggest, fdwSuggest);
                if (MMSYSERR_NOERROR != mmr)
                {
                    DPF(5, "FREEING pwfxSuggest=%.08lXh--no suggested format!", pwfxSuggest);
                    GlobalFreePtr(pwfxSuggest);
                    pwfxSuggest = NULL;

                    //
                    //  if no 'suggestions', there better not be any
                    //  possible conversions that we would find below...
                    //
                    return (MMSYSERR_NOERROR);
                }

                DPF(5, "******* suggestion--%u to %u", pwfxSrc->wFormatTag, pwfxSuggest->wFormatTag);
                cbwfxSuggest = SIZEOF_WAVEFORMATEX(pwfxSuggest);
            }
        }
    }


    hadid = ((PACMDRIVER)had)->hadid;

    fdwSupport = ((PACMDRIVERID)hadid)->fdwSupport;

    //
    //  be a bit paranoid and save some stuff so we can always reinit
    //  the structure between calling the driver (i just don't trust
    //  driver writers... though Media Vision is bound to find a way
    //  to cause trouble anyway)
    //
    cbafd = pafd->cbStruct;
    pwfx  = pafd->pwfx;
    cbwfx = pafd->cbwfx;
    nChannels = pwfxSrc->nChannels;
    nSamplesPerSec = pwfxSrc->nSamplesPerSec;
    uBitsPerSample = pwfxSrc->wBitsPerSample;


    //
    //
    //
    for (u = 0; u < paftd->cStandardFormats; u++)
    {
        pafd->cbStruct      = cbafd;
        pafd->dwFormatIndex = u;
        pafd->dwFormatTag   = paftd->dwFormatTag;
        pafd->fdwSupport    = 0;
        pafd->pwfx          = pwfx;
        pafd->cbwfx         = cbwfx;
        pafd->szFormat[0]   = '\0';

        mmr = acmFormatDetails(had, pafd, ACM_FORMATDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
        {
            continue;
        }

        if ((fdwEnum & ACM_FORMATENUMF_NCHANNELS) &&
            (pwfx->nChannels != nChannels))
        {
            continue;
        }
        if ((fdwEnum & ACM_FORMATENUMF_NSAMPLESPERSEC) &&
            (pwfx->nSamplesPerSec != nSamplesPerSec))
        {
            continue;
        }
        if ((fdwEnum & ACM_FORMATENUMF_WBITSPERSAMPLE) &&
            (pwfx->wBitsPerSample != uBitsPerSample))
        {
            continue;
        }

        if (0 != (fdwEnum & ACM_FORMATENUMF_CONVERT))
        {
            mmr = acmStreamOpen(NULL,
                                had,
                                pwfxSrc,
                                pwfx,
                                NULL,
                                0L,
                                0L,
                                ACM_STREAMOPENF_NONREALTIME |
                                ACM_STREAMOPENF_QUERY);

            if (MMSYSERR_NOERROR != mmr)
                continue;

            if ((NULL != pwfxSuggest) &&
                (SIZEOF_WAVEFORMATEX(pwfx) == cbwfxSuggest))
            {
                if (0 == _fmemcmp(pwfx, pwfxSuggest, (UINT)cbwfxSuggest))
                {
                    DPF(5, "FREEING pwfxSuggest=%.08lXh--DUPLICATE!", pwfxSuggest);
                    GlobalFreePtr(pwfxSuggest);
                    pwfxSuggest = NULL;
                }
            }
        }

        if (0 != ((ACM_FORMATENUMF_INPUT | ACM_FORMATENUMF_OUTPUT) & fdwEnum))
        {
            if (!ISupported(hdrvrMapper, pwfx, fdwEnum))
            {
                continue;
            }
        }

        DPF(3, "doing callback--%lu, %s", pafd->dwFormatTag, (LPSTR)pafd->szFormat);
        f = (* fnCallback)(hadid, pafd, dwInstance, fdwSupport);
        if (!f)
        {
            if (NULL != pwfxSuggest)
            {
                DPF(5, "FREEING pwfxSuggest=%.08lXh--CALLBACK CANCELED!", pwfxSuggest);
                GlobalFreePtr(pwfxSuggest);
            }
            return (MMSYSERR_ERROR);
        }
    }

    //
    //  if we have not passed back the 'suggested' format for the convert
    //  case, then do it now
    //
    //  this is a horribly gross fix, and i know it...
    //
    if (NULL != pwfxSuggest)
    {
        DPF(5, "pwfxSuggest=%.08lXh--attempting callback (%u)", pwfxSuggest, pwfxSuggest->wFormatTag);

        pafd->cbStruct      = cbafd;
        pafd->dwFormatIndex = 0;
        pafd->dwFormatTag   = pwfxSuggest->wFormatTag;
        pafd->fdwSupport    = 0;
        pafd->pwfx          = pwfxSuggest;
        pafd->cbwfx         = cbwfxSuggest;
        pafd->szFormat[0]   = '\0';

        f   = TRUE;
        mmr = acmFormatDetails(had, pafd, ACM_FORMATDETAILSF_FORMAT);
        if (MMSYSERR_NOERROR == mmr)
        {
            if (0 != ((ACM_FORMATENUMF_INPUT | ACM_FORMATENUMF_OUTPUT) & fdwEnum))
            {
                if (!ISupported(hdrvrMapper, pwfxSuggest, fdwEnum))
                {
                    DPF(5, "FREEING pwfxSuggest=%.08lXh--attempting callback NOT SUPPPORTED", pwfxSuggest);

                    GlobalFreePtr(pwfxSuggest);
                    pafd->cbwfx = cbwfx;
                    return (MMSYSERR_NOERROR);
                }
            }

            DPF(5, "doing SUGGEST callback--%lu, %s", pafd->dwFormatTag, (LPSTR)pafd->szFormat);
            f = (* fnCallback)(hadid, pafd, dwInstance, fdwSupport);
        }

        //
        //  reset these things or bad things will happen
        //
        pafd->pwfx  = pwfx;
        pafd->cbwfx = cbwfx;

        GlobalFreePtr(pwfxSuggest);

        if (!f)
        {
            return (MMSYSERR_ERROR);
        }
    }

    return (MMSYSERR_NOERROR);
} // IFormatEnum()


//--------------------------------------------------------------------------;
//
//  MMRESULT IHardwareEnum
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvrMapper:
//
//      LPACMFORMATDETAILS pafd:
//
//      ACMFORMATENUMCB fnCallback:
//
//      DWORD_PTR dwInstance:
//
//      LPWAVEFORMATEX pwfxSrc:
//
//      DWORD fdwEnum:
//
//  Return (MMRESULT):
//
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL IHardwareEnum
(
    HDRVR                   hdrvrMapper,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    LPWAVEFORMATEX          pwfxSrc,
    DWORD                   fdwEnum
)
{
    BOOL                f;
    DWORD               cbafd;
    LPWAVEFORMATEX      pwfx;
    DWORD               cbwfx;
    UINT                u1, u2;
    UINT                nChannels;
    DWORD               nSamplesPerSec;
    UINT                uBitsPerSample;


    //
    //  be a bit paranoid and save some stuff so we can always reinit
    //  the structure between calling the driver (i just don't trust
    //  driver writers... though Media Vision is bound to find a way
    //  to cause trouble anyway)
    //
    cbafd = pafd->cbStruct;
    pwfx  = pafd->pwfx;
    cbwfx = pafd->cbwfx;
    nChannels = pwfxSrc->nChannels;
    nSamplesPerSec = pwfxSrc->nSamplesPerSec;
    uBitsPerSample = pwfxSrc->wBitsPerSample;

    //
    //
    //
    for (u1 = 0; u1 < CODEC_MAX_STANDARD_FORMATS_PCM; u1++)
    {
        pafd->cbStruct      = cbafd;
        pafd->dwFormatIndex = 0;
        pafd->dwFormatTag   = WAVE_FORMAT_PCM;
        pafd->fdwSupport    = 0L;
        pafd->pwfx          = pwfx;
        pafd->cbwfx         = cbwfx;

        //
        //  now fill in the format structure
        //
        pwfx->wFormatTag      = WAVE_FORMAT_PCM;

        u2 = u1 / (CODEC_MAX_BITSPERSAMPLE_PCM * CODEC_MAX_CHANNELS);
        pwfx->nSamplesPerSec  = auFormatIndexToSampleRate[u2];

        u2 = u1 % CODEC_MAX_CHANNELS;
        pwfx->nChannels       = u2 + 1;

        u2 = (u1 / CODEC_MAX_CHANNELS) % CODEC_MAX_CHANNELS;
        pwfx->wBitsPerSample  = (WORD)auFormatIndexToBitsPerSample[u2];

        pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
        pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

        //
        //  note that the cbSize field is NOT valid for PCM formats
        //
        //  pwfx->cbSize      = 0;


        pafd->cbStruct    = min(pafd->cbStruct, sizeof(*pafd));
        IFormatDetailsToString(pafd);

        if( (fdwEnum & ACM_FORMATENUMF_NCHANNELS)
            && (pwfx->nChannels != nChannels) ) {
            continue;
        }
        if( (fdwEnum & ACM_FORMATENUMF_NSAMPLESPERSEC)
            && (pwfx->nSamplesPerSec != nSamplesPerSec) ) {
            continue;
        }
        if( (fdwEnum & ACM_FORMATENUMF_WBITSPERSAMPLE)
            && (pwfx->wBitsPerSample != uBitsPerSample) ) {
            continue;
        }

        if (0 != ((ACM_FORMATENUMF_INPUT | ACM_FORMATENUMF_OUTPUT) & fdwEnum))
        {
            if (!ISupported(hdrvrMapper, pwfx, fdwEnum))
            {
                continue;
            }
        }

        f = (* fnCallback)(NULL, pafd, dwInstance, 0L);
        if (!f)
        {
            return (MMSYSERR_ERROR);
        }
    }

    return (MMSYSERR_NOERROR);
} // IHardwareEnum()


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api BOOL ACMFORMATENUMCB | acmFormatEnumCallback |
 *      The <f acmFormatEnumCallback> function refers to the callback function used for
 *      Audio Compression Manager (ACM) wave format detail enumeration. The
 *      <f acmFormatEnumCallback> is a placeholder for the application-supplied
 *      function name.
 *
 *  @parm HACMDRIVERID | hadid | Specifies an ACM driver identifier.
 *
 *  @parm  LPACMFORMATDETAILS | pafd | Specifies a pointer to an
 *      <t ACMFORMATDETAILS> structure that contains the enumerated
 *      format details for a format tag.
 *
 *  @parm DWORD | dwInstance | Specifies the application-defined value
 *      specified in the <f acmFormatEnum> function.
 *
 *  @parm DWORD | fdwSupport | Specifies driver-support flags specific to
 *      the driver identifier <p hadid> for the specified format. These flags
 *      are identical to the <e ACMDRIVERDETAILS.fdwSupport> flags of the
 *      <t ACMDRIVERDETAILS> structure, but are specific to the format that
 *      is being enumerated. This argument can be a combination of the
 *      following values and indicates which operations the driver supports
 *      for the format tag.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CODEC | Specifies that this driver
 *      supports conversion between two different format tags for the
 *      specified format. For example, if a driver supports compression
 *      from WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM with the specifed
 *      format, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_CONVERTER | Specifies that this
 *      driver supports conversion between two different formats of the
 *      same format tag while using the specified format. For example, if a
 *      driver supports resampling of WAVE_FORMAT_PCM to the specified
 *      format, then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_FILTER | Specifies that this driver
 *      supports a filter (modification of the data without changing any
 *      of the format attributes) with the specified format. For example,
 *      if a driver supports volume or echo operations on WAVE_FORMAT_PCM,
 *      then this flag is set.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_ASYNC | Specifies that this driver
 *      supports asynchronous conversions with the specified format.
 *
 *      @flag ACMDRIVERDETAILS_SUPPORTF_HARDWARE | Specifies that this driver
 *      supports hardware input and/or output of the specified format tag
 *      through a waveform device. An application should use <f acmMetrics>
 *      with the ACM_METRIC_HARDWARE_WAVE_INPUT and
 *      ACM_METRIC_HARDWARE_WAVE_OUTPUT metric indexes to get the waveform
 *      device identifiers associated with the supporting ACM driver.
 *
 *  @rdesc The callback function must return TRUE to continue enumeration;
 *      to stop enumeration, it must return FALSE.
 *
 *  @comm The <f acmFormatEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no formats are to be enumerated. Moreover, the callback
 *      function will not be called.
 *
 *  @xref <f acmFormatEnum> <f acmFormatTagDetails> <f acmDriverOpen>
 *
 ***************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatEnum | The <f acmFormatEnum> function
 *      enumerates wave formats available for a given format tag from
 *      an Audio Compression Manager (ACM) driver. The <f acmFormatEnum>
 *      function continues enumerating until there are no more suitable
 *      formats for the format tag or the callback function returns FALSE.
 *
 *  @parm HACMDRIVER | had | Optionally specifies an ACM driver to query
 *      for wave format details. If this argument is NULL, then the
 *      ACM uses the details from the first suitable ACM driver.
 *
 *  @parm LPACMFORMATDETAILS | pafd | Specifies a pointer to the
 *      <t ACMFORMATDETAILS> structure that is to receive the format details
 *      passed to the <p fnCallback> function. This structure must have the
 *      <e ACMFORMATDETAILS.cbStruct>, <e ACMFORMATDETAILS.pwfx>, and
 *      <e ACMFORMATDETAILS.cbwfx> members of the <t ACMFORMATDETAILS>
 *      structure initialized. The <e ACMFORMATDETAILS.dwFormatTag> member
 *      must also be initialized to either WAVE_FORMAT_UNKNOWN or a
 *      valid format tag.
 *
 *  @parm ACMFORMATENUMCB | fnCallback | Specifies the procedure-instance
 *      address of the application-defined callback function. The callback
 *      address must be created by the <f MakeProcInstance> function; or
 *      the callback function must contain the proper prolog and epilog code
 *      for callbacks.
 *
 *  @parm DWORD | dwInstance | Specifies a 32-bit, application-defined value
 *      that is passed to the callback function along with ACM format details.
 *
 *  @parm DWORD | fdwEnum | Specifies flags for enumerating the formats for
 *      a given format tag.
 *
 *      @flag ACM_FORMATENUMF_WFORMATTAG | Specifies that the
 *      <e WAVEFORMATEX.wFormatTag> member of the <t WAVEFORMATEX> structure
 *      referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate a format that conforms to this attribute. Note that the
 *      <e ACMFORMATDETAILS.dwFormatTag> member of the <t ACMFORMATDETAILS>
 *      structure must be equal to the <e WAVEFORMATEX.wFormatTag> member.
 *
 *      @flag ACM_FORMATENUMF_NCHANNELS | Specifies that the
 *      <e WAVEFORMATEX.nChannels> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate a format that conforms to this attribute.
 *
 *      @flag ACM_FORMATENUMF_NSAMPLESPERSEC | Specifies that the
 *      <e WAVEFORMATEX.nSamplesPerSec> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate a format that conforms to this attribute.
 *
 *      @flag ACM_FORMATENUMF_WBITSPERSAMPLE | Specifies that the
 *      <e WAVEFORMATEX.wBitsPerSample> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate a format that conforms to this attribute.
 *
 *      @flag ACM_FORMATENUMF_CONVERT | Specifies that the <t WAVEFORMATEX>
 *      structure referenced by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will only
 *      enumerate destination formats that can be converted from the given
 *      <e ACMFORMATDETAILS.pwfx> format.
 *
 *      @flag ACM_FORMATENUMF_SUGGEST | Specifies that the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATDETAILS.pwfx> member of the
 *      <t ACMFORMATDETAILS> structure is valid. The enumerator will
 *      enumerate all suggested destination formats for the given
 *      <e ACMFORMATDETAILS.pwfx> format. This can be used instead of
 *      <f acmFormatSuggest> to allow an application to choose the best
 *      suggested format for conversion. Note that the
 *      <e ACMFORMATDETAILS.dwFormatIndex> member will always be set to
 *      zero on return.
 *
 *      @flag ACM_FORMATENUMF_HARDWARE | Specifies that the enumerator should
 *      only enumerate formats that are supported as native input or output
 *      formats on one or more of the installed wave devices. This provides
 *      a way for an application to choose only formats native to an
 *      installed wave device. This flag must be used with one or both
 *      of the ACM_FORMATENUMF_INPUT and ACM_FORMATENUMF_OUTPUT flags.
 *      Note that specifying both ACM_FORMATENUMF_INPUT and
 *      ACM_FORMATENUMF_OUTPUT will enumerate only formats that can be
 *      opened for input or output.
 *      This is true regardless of of whether the ACM_FORMATENUMF_HARDWARE
 *      flag is specified.
 *
 *      @flag ACM_FORMATENUMF_INPUT | Specifies that the enumerator should
 *      only enumerate formats that are supported for input (recording).
 *
 *      @flag ACM_FORMATENUMF_OUTPUT | Specifies that the enumerator should
 *      only enumerate formats that are supported for output (playback).
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The details for the format cannot be
 *      returned.
 *
 *  @comm The <f acmFormatEnum> function will return MMSYSERR_NOERROR
 *      (zero) if no suitable ACM drivers are installed. Moreover, the
 *      callback function will not be called.
 *
 *  @xref <f acmFormatEnumCallback> <f acmFormatDetails> <f acmFormatSuggest>
 *      <f acmFormatTagDetails> <f acmFilterEnum>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatEnum
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    PACMGARB		    pag;
    MMRESULT                mmr;
    PACMDRIVERID            padid;
    HACMDRIVERID            hadid;
    UINT                    u;
    UINT                    uIndex;
    UINT                    uFormatSize;
    UINT                    uFormatTag;
    LPWAVEFORMATEX          pwfxSrc;
    BOOL                    fNoDrivers;
    DWORD                   cbwfxRqd;
    HDRVR                   hdrvrMapper;
    BOOL                    fFormatTag;
    BOOL                    fConvert;
    BOOL                    fSuggest;
    ACMFORMATTAGDETAILS	    aftd;


    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatEnum: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(ACMFORMATDETAILS) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);
    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);
    }
    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwEnum, ACM_FORMATENUMF_VALID, acmFormatEnum, MMSYSERR_INVALFLAG);

    if (0 != (ACM_FORMATENUMF_HARDWARE & fdwEnum))
    {
        if (0 == ((ACM_FORMATENUMF_INPUT|ACM_FORMATENUMF_OUTPUT) & fdwEnum))
        {
            DebugErr(DBF_ERROR, "acmFormatEnum: ACM_FORMATENUMF_HARDWARE requires _INPUT and/or _OUTPUT flag.");
            return (MMSYSERR_INVALFLAG);
        }
    }

    //
    //
    //
    mmr = IMetricsMaxSizeFormat( pag, had, &cbwfxRqd );
    if (MMSYSERR_NOERROR != mmr)
    {
        return (mmr);
    }
    if (pafd->cbwfx < cbwfxRqd)
    {
        DebugErr1(DBF_ERROR, "acmFormatEnum: cbwfx member must be at least %lu for requested enumeration.", cbwfxRqd);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd->pwfx, pafd->cbwfx, MMSYSERR_INVALPARAM);

    if (0L != pafd->fdwSupport)
    {
        DebugErr(DBF_ERROR, "acmFormatEnum: fdwSupport member must be set to zero.");
        return (MMSYSERR_INVALPARAM);
    }


    DPF(1, "***** FORMAT ENUM fdwEnum=%.08lXh *****************************", fdwEnum);

    //
    //  Get the restrictions on the enum.
    //
    uFormatTag = WAVE_FORMAT_UNKNOWN;
    fFormatTag = (0 != (fdwEnum & ACM_FORMATENUMF_WFORMATTAG));

    if (fFormatTag)
    {
        uFormatTag = (UINT)pafd->pwfx->wFormatTag;

        if (WAVE_FORMAT_UNKNOWN == uFormatTag)
        {
            DebugErr(DBF_ERROR, "acmFormatEnum: ACM_FORMATENUMF_WFORMATTAG cannot be used with WAVE_FORMAT_UNKNOWN.");
            return (MMSYSERR_INVALPARAM);
        }

        if (pafd->dwFormatTag != uFormatTag)
        {
            DebugErr(DBF_ERROR, "acmFormatEnum: format tags must match.");
            return  (MMSYSERR_INVALPARAM);
        }
    }


    //
    //
    //
    fConvert = (0 != (fdwEnum & ACM_FORMATENUMF_CONVERT));
    fSuggest = (0 != (fdwEnum & ACM_FORMATENUMF_SUGGEST));

    // find the size of the source format for restrictions
    if (fConvert || fSuggest)
    {
        uFormatSize = SIZEOF_WAVEFORMATEX(pafd->pwfx);
        V_RWAVEFORMAT(pafd->pwfx, MMSYSERR_INVALPARAM);

        if (WAVE_FORMAT_UNKNOWN == pafd->pwfx->wFormatTag)
        {
            DebugErr(DBF_ERROR, "acmFormatEnum: _CONVERT and _SUGGEST cannot be used with WAVE_FORMAT_UNKNOWN.");
            return (MMSYSERR_INVALPARAM);
        }
    }
    else
    {
        // if we are not using the convert or suggest restrictions
        // then we do not need the full format
        uFormatSize = sizeof(PCMWAVEFORMAT);
    }

    // Alloc a copy of the source format for restrictions
    pwfxSrc = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, uFormatSize);
    if (NULL == pwfxSrc)
    {
        return (MMSYSERR_NOMEM);
    }

    // Init the copy
    _fmemcpy(pwfxSrc, pafd->pwfx, uFormatSize);


    //
    //
    //
    mmr = MMSYSERR_NOERROR;

    hdrvrMapper = NULL;
    if (0 != (fdwEnum & ACM_FORMATENUMF_HARDWARE))
    {
#ifdef WIN32
	hdrvrMapper = OpenDriver(gszWavemapper, gszSecDriversW, 0L);
#else
	hdrvrMapper = OpenDriver(gszWavemapper, gszSecDrivers, 0L);
#endif
	
    }

    //
    //  IF a driver is specified, then enum from that driver only.
    //
    //
    if (NULL != had)
    {
        fNoDrivers = FALSE;

        padid = (PACMDRIVERID)((PACMDRIVER)had)->hadid;

        //
        //  step through all format tags that the caller is interested in
        //  and enumerate the formats...
        //
        for (u = 0; u < padid->cFormatTags; u++)
        {
            if (fFormatTag)
            {
                if (uFormatTag != padid->paFormatTagCache[u].dwFormatTag)
                    continue;
            }

	    aftd.cbStruct = sizeof(aftd);
	    aftd.dwFormatTagIndex   = u;
	    mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid,
				    &aftd, ACM_FORMATTAGDETAILSF_INDEX);

	    if (MMSYSERR_NOERROR == mmr)
	    {
		
		if (fSuggest)
		{
		    mmr = ISuggestEnum(hdrvrMapper,
				       had,
				       &aftd,
				       pafd,
				       fnCallback,
				       dwInstance,
				       pwfxSrc,
				       fdwEnum);
		}
		else
		{
		    mmr = IFormatEnum(hdrvrMapper,
				      had,
				      &aftd,
				      pafd,
				      fnCallback,
				      dwInstance,
				      pwfxSrc,
				      fdwEnum);
		}
	    }

	    if ((mmr == MMSYSERR_ERROR) || fFormatTag)
	    {
		// Returned generic error to stop the enumeration.
		mmr = MMSYSERR_NOERROR;
		break;
	    }
        }
    }
    else if (fFormatTag)
    {
        PACMDRIVERID    padidBestCount;
        UINT            uBestCountFormat;
	DWORD		cBestCount;

        hadid = NULL;
        fNoDrivers = (!fConvert && !fSuggest);
        padidBestCount = NULL;
	cBestCount = 0;

        ENTER_LIST_SHARED;

        while (!IDriverGetNext(pag, &hadid, hadid, 0L))
        {
            fNoDrivers = FALSE;

            padid = (PACMDRIVERID)hadid;

            //
            //  find the format tag that caller is interested in and
            //  enumerate the formats...
            //
            for (u = 0; u < padid->cFormatTags; u++)
            {
                if (uFormatTag != padid->paFormatTagCache[u].dwFormatTag)
                    continue;

		aftd.cbStruct = sizeof(aftd);
		aftd.dwFormatTagIndex   = u;
		mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid,
					&aftd, ACM_FORMATTAGDETAILSF_INDEX);

		if (MMSYSERR_NOERROR == mmr)
		{

		    if ( !padidBestCount ||
			 (aftd.cStandardFormats > cBestCount ) )
		    {
			padidBestCount	    = padid;
			cBestCount	    = aftd.cStandardFormats;
			uBestCountFormat    = u;
		    }
		}

                break;

            }
        }

        if (NULL != padidBestCount)
        {
            HACMDRIVER  had;

	    aftd.cbStruct = sizeof(aftd);
	    aftd.dwFormatTagIndex   = uBestCountFormat;
	    mmr = IFormatTagDetails(pag, (HACMDRIVERID)padidBestCount,
				    &aftd, ACM_FORMATTAGDETAILSF_INDEX);

	    if (MMSYSERR_NOERROR == mmr) {
		mmr = acmDriverOpen(&had, (HACMDRIVERID)padidBestCount, 0L);
	    }
	
            if (MMSYSERR_NOERROR == mmr)
            {
                if (fSuggest)
                {
                    mmr = ISuggestEnum(hdrvrMapper,
                                       had,
				       &aftd,
                                       pafd,
                                       fnCallback,
                                       dwInstance,
                                       pwfxSrc,
                                       fdwEnum);
                }
                else
                {
                    mmr = IFormatEnum(hdrvrMapper,
                                      had,
                                      &aftd,
                                      pafd,
                                      fnCallback,
                                      dwInstance,
                                      pwfxSrc,
                                      fdwEnum);
                }

                acmDriverClose(had, 0L);

                if (MMSYSERR_ERROR == mmr)
                {
                    // Returned generic error to stop the enumeration.
                    mmr = MMSYSERR_NOERROR;
                }
            }
        }

        if (fNoDrivers && (WAVE_FORMAT_PCM != uFormatTag))
        {
            fNoDrivers = FALSE;
        }

        LEAVE_LIST_SHARED;
    }
    else
    {
        // Enum formats across all drivers.

        fNoDrivers = (!fConvert && !fSuggest);
        hadid = NULL;

        ENTER_LIST_SHARED;

        while (!IDriverGetNext(pag, &hadid, hadid, 0L))
        {
            HACMDRIVER  had;

            fNoDrivers = FALSE;
            padid = (PACMDRIVERID)hadid;

            if (fConvert || fSuggest)
            {
                uFormatTag = pwfxSrc->wFormatTag;

                //
                //  for every FormatTag in the driver
                //
                for (u = 0; u < padid->cFormatTags; u++)
                {
		    if (uFormatTag == padid->paFormatTagCache[u].dwFormatTag)
                    {
                        //
                        //  flag that this driver supports that tag
                        //
                        uFormatTag = WAVE_FORMAT_UNKNOWN;
                        break;
                    }
                }

                if (WAVE_FORMAT_UNKNOWN != uFormatTag)
                {
                    //
                    //  the current driver does not support the format
                    //  tag, so skip to the next driver...
                    //
                    continue;
                }
            }

            mmr = acmDriverOpen(&had, hadid, 0L);
            if (MMSYSERR_NOERROR != mmr)
            {
                continue;
            }

            for (uIndex = 0; uIndex < padid->cFormatTags; uIndex++)
            {
		aftd.cbStruct = sizeof(aftd);
		aftd.dwFormatTagIndex   = uIndex;
		mmr = IFormatTagDetails(pag, (HACMDRIVERID)padid,
					&aftd, ACM_FORMATTAGDETAILSF_INDEX);


		if (MMSYSERR_NOERROR == mmr)
		{
		    //
		    //  we have a format that has not been sent yet.
		    //
		    if (fSuggest)
		    {
			mmr = ISuggestEnum(hdrvrMapper,
					   had,
					   &aftd,
					   pafd,
					   fnCallback,
					   dwInstance,
					   pwfxSrc,
					   fdwEnum);
		    }
		    else
		    {
			mmr = IFormatEnum(hdrvrMapper,
					  had,
					  &aftd,
					  pafd,
					  fnCallback,
					  dwInstance,
					  pwfxSrc,
					  fdwEnum);
		    }
		}

                if (MMSYSERR_ERROR == mmr)
                {
                    // Returned generic error to stop the enumeration.
                    break;
                }
            }

            acmDriverClose(had, 0L);

            if (MMSYSERR_ERROR == mmr)
            {
                mmr = MMSYSERR_NOERROR;
                break;
            }
        }

        LEAVE_LIST_SHARED;

    }

    //
    //
    //
    if (fNoDrivers)
    {
        IHardwareEnum(hdrvrMapper, pafd, fnCallback, dwInstance, pwfxSrc, fdwEnum);
    }


    if (NULL != hdrvrMapper)
    {
        CloseDriver(hdrvrMapper, 0L, 0L);
    }

    // Free the copy of the source format
    GlobalFreePtr(pwfxSrc);

    //
    //
    //
    return (mmr);
}

#ifdef WIN32
#if TRUE    // defined(UNICODE)

typedef struct tIFORMATENUMCBINSTANCEW
{
    ACMFORMATENUMCBA            fnCallback;
    DWORD_PTR                   dwInstance;
    LPACMFORMATDETAILSA         pafd;

} IFORMATENUMCBINSTANCEW, *PIFORMATENUMCBINSTANCEW;

BOOL FNWCALLBACK IFormatEnumCallbackW
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILSW     pafdW,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    PIFORMATENUMCBINSTANCEW     pfi;
    BOOL                        f;

    pfi = (PIFORMATENUMCBINSTANCEW)dwInstance;

    memcpy(&pfi->pafd->dwFormatIndex,
           &pafdW->dwFormatIndex,
           FIELD_OFFSET(ACMFORMATDETAILSA, szFormat) -
           FIELD_OFFSET(ACMFORMATDETAILSA, dwFormatIndex));

    pfi->pafd->cbStruct = sizeof(*pfi->pafd);
    Iwcstombs(pfi->pafd->szFormat, pafdW->szFormat, sizeof(pfi->pafd->szFormat));

    f = pfi->fnCallback(hadid, pfi->pafd, pfi->dwInstance, fdwSupport);

    return (f);
}


MMRESULT ACMAPI acmFormatEnumA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    ACMFORMATENUMCBA        fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
)
{
    MMRESULT                    mmr;
    ACMFORMATDETAILSW           afdW;
    IFORMATENUMCBINSTANCEW      fi;

    V_CALLBACK((FARPROC)fnCallback, MMSYSERR_INVALPARAM);
    V_WPOINTER(pafd, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(*pafd) > pafd->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatEnum: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pafd, pafd->cbStruct, MMSYSERR_INVALPARAM);

    afdW.cbStruct = sizeof(afdW);
    memcpy(&afdW.dwFormatIndex,
           &pafd->dwFormatIndex,
           FIELD_OFFSET(ACMFORMATDETAILSA, szFormat) -
           FIELD_OFFSET(ACMFORMATDETAILSA, dwFormatIndex));

    fi.fnCallback = fnCallback;
    fi.dwInstance = dwInstance;
    fi.pafd       = pafd;

    mmr = acmFormatEnumW(had, &afdW, IFormatEnumCallbackW, (DWORD_PTR)&fi, fdwEnum);

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatEnumW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    ACMFORMATENUMCBW        fnCallback,
    DWORD                   dwInstance,
    DWORD                   fdwEnum
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\acmstrm.c ===
/****************************************************************************
 *
 *   acmstrm.c
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   This module provides the Buffer to Buffer API's
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>

#include "muldiv32.h"

#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "debug.h"



/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | IStreamOpenQuery | Helper fn to do a stream query.
 *
 * @parm LPWAVEFORMATEX | pwfxSrc | Source format.
 *
 * @parm LPWAVEFORMATEX | pwfxDst | Destination format.
 *
 * @parm LPWAVEFILTER  | pwfltr | Filter to apply.
 *
 * @parm DWORD | fdwOpen |
 *
 * @rdesc Returns error number.
 *
 ****************************************************************************/

MMRESULT FNLOCAL IStreamOpenQuery
(
    HACMDRIVER          had,
    LPWAVEFORMATEX      pwfxSrc,
    LPWAVEFORMATEX      pwfxDst,
    LPWAVEFILTER        pwfltr,
    DWORD               fdwOpen
)
{
    ACMDRVSTREAMINSTANCE    adsi;
    MMRESULT                mmr;


    //
    //
    //
    _fmemset(&adsi, 0, sizeof(adsi));

    adsi.cbStruct           = sizeof(adsi);
    adsi.pwfxSrc            = pwfxSrc;
    adsi.pwfxDst            = pwfxDst;
    adsi.pwfltr             = pwfltr;
////adsi.dwCallback         = 0L;
////adsi.dwInstance         = 0L;
    adsi.fdwOpen            = fdwOpen | ACM_STREAMOPENF_QUERY;
////adsi.dwDriverFlags      = 0L;
////adsi.dwDriverInstance   = 0L;
////adsi.has                = NULL;

    EnterHandle(had);
    mmr = (MMRESULT)IDriverMessage(had,
                                   ACMDM_STREAM_OPEN,
                                   (LPARAM)(LPVOID)&adsi,
                                   0L);
    LeaveHandle(had);

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatSuggest | This function asks the Audio Compression Manager
 *      (ACM) or a specified ACM driver to suggest a destination format for
 *      the supplied source format. For example, an application can use this
 *      function to determine one or more valid PCM formats to which a
 *      compressed format can be decompressed.
 *
 *  @parm HACMDRIVER | had | Identifies an optional open instance of a
 *      driver to query for a suggested destination format. If this
 *      argument is NULL, the ACM attempts to find the best driver to suggest
 *      a destination format.
 *
 *  @parm LPWAVEFORMATEX | pwfxSrc | Specifies a pointer to a <t WAVEFORMATEX>
 *      structure that identifies the source format to suggest a destination
 *      format to be used for a conversion.
 *
 *  @parm LPWAVEFORMATEX | pwfxDst | Specifies a pointer to a <t WAVEFORMATEX>
 *      data structure that will receive the suggested destination format
 *      for the <p pwfxSrc> format. Note that based on the <p fdwSuggest>
 *      argument, some members of the structure pointed to by <p pwfxDst>
 *      may require initialization.
 *
 *  @parm DWORD | cbwfxDst | Specifies the size in bytes available for
 *      the destination format. The <f acmMetrics> and <f acmFormatTagDetails>
 *      functions can be used to determine the maximum size required for any
 *      format available for the specified driver (or for all installed ACM
 *      drivers).
 *
 *  @parm DWORD | fdwSuggest | Specifies flags for matching the desired
 *      destination format.
 *
 *      @flag ACM_FORMATSUGGESTF_WFORMATTAG | Specifies that the
 *      <e WAVEFORMATEX.wFormatTag> member of the <p pwfxDst> structure is
 *      valid.  The ACM will query acceptable installed drivers that can
 *      suggest a destination format matching the <e WAVEFORMATEX.wFormatTag>
 *      member or fail.
 *
 *      @flag ACM_FORMATSUGGESTF_NCHANNELS | Specifies that the
 *      <e WAVEFORMATEX.nChannels> member of the <p pwfxDst> structure is
 *      valid.  The ACM will query acceptable installed drivers that can
 *      suggest a destination format matching the <e WAVEFORMATEX.nChannels>
 *      member or fail.
 *
 *      @flag ACM_FORMATSUGGESTF_NSAMPLESPERSEC | Specifies that the
 *      <e WAVEFORMATEX.nSamplesPerSec> member of the <p pwfxDst> structure
 *      is valid.  The ACM will query acceptable installed drivers that can
 *      suggest a destination format matching the <e WAVEFORMATEX.nSamplesPerSec>
 *      member or fail.
 *
 *      @flag ACM_FORMATSUGGESTF_WBITSPERSAMPLE | Specifies that the
 *      <e WAVEFORMATEX.wBitsPerSample> member of the <p pwfxDst> structure
 *      is valid.  The ACM will query acceptable installed drivers that can
 *      suggest a destination format matching the <e WAVEFORMATEX.wBitsPerSample>
 *      member or fail.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *  @xref <f acmDriverOpen> <f acmFormatTagDetails> <f acmMetrics>
 *      <f acmFormatEnum>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmFormatSuggest
(
    HACMDRIVER              had,
    LPWAVEFORMATEX          pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    DWORD                   cbwfxDst,
    DWORD                   fdwSuggest
)
{
    PACMGARB		pag;
    MMRESULT            mmr;
    HACMDRIVERID        hadid;
    PACMDRIVERID        padid;
    UINT                i,j;
    BOOL                fFound;
    ACMDRVFORMATSUGGEST adfs;
    DWORD               cbwfxDstRqd;
    ACMFORMATTAGDETAILS aftd;

    V_DFLAGS(fdwSuggest, ACM_FORMATSUGGESTF_VALID, acmFormatSuggest, MMSYSERR_INVALFLAG);
    V_RWAVEFORMAT(pwfxSrc, MMSYSERR_INVALPARAM);
    V_WPOINTER(pwfxDst, cbwfxDst, MMSYSERR_INVALPARAM);

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmFormatSuggest: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    //
    //	if the source format is PCM, and we aren't restricting the destination
    //	format, and we're not requesting a specific driver, then first try to
    //	suggest a PCM format.  This is kinda like giving the PCM converter
    //	priority for this case.
    //
    if ( (NULL == had) &&
	 (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag) &&
	 (0 == (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)) )
    {
	//
	//  I'll be a bit paranoid and restore pwfxDst->wFormatTag
	//  if this fails.
	//
	WORD wDstFormatTagSave;

	wDstFormatTagSave = pwfxDst->wFormatTag;
	pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
	mmr = acmFormatSuggest(NULL, pwfxSrc, pwfxDst, cbwfxDst, fdwSuggest | ACM_FORMATSUGGESTF_WFORMATTAG);
	if (MMSYSERR_NOERROR == mmr)
	{
	    return (MMSYSERR_NOERROR);
	}
	pwfxDst->wFormatTag = wDstFormatTagSave;
    }
	

    //
    //
    //
    if (0 == (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest))
    {
        mmr = IMetricsMaxSizeFormat( pag, had, &cbwfxDstRqd );
        if (MMSYSERR_NOERROR != mmr)
        {
            return (mmr);
        }
    }
    else
    {
        _fmemset(&aftd, 0, sizeof(aftd));
        aftd.cbStruct    = sizeof(aftd);
        aftd.dwFormatTag = pwfxDst->wFormatTag;

        mmr = acmFormatTagDetails(had,
                                  &aftd,
                                  ACM_FORMATTAGDETAILSF_FORMATTAG);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (mmr);
        }

        cbwfxDstRqd = aftd.cbFormatSize;
    }

    if (cbwfxDst < cbwfxDstRqd)
    {
        DebugErr1(DBF_ERROR, "acmFormatSuggest: destination buffer must be at least %lu bytes.", cbwfxDstRqd);
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    adfs.cbStruct   = sizeof(adfs);
    adfs.fdwSuggest = fdwSuggest;
    adfs.pwfxSrc    = pwfxSrc;
    adfs.cbwfxSrc   = SIZEOF_WAVEFORMATEX(pwfxSrc);
    adfs.pwfxDst    = pwfxDst;
    adfs.cbwfxDst   = cbwfxDst;

    if (NULL != had)
    {
        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

        //
        //  we were given a driver handle
        //

        EnterHandle(had);
        mmr = (MMRESULT)IDriverMessage(had,
                                       ACMDM_FORMAT_SUGGEST,
                                       (LPARAM)(LPVOID)&adfs,
                                       0L);
        LeaveHandle(had);

        return (mmr);
    }


    //
    //  if we are being asked to 'suggest anything from any driver'
    //  (that is, (0L == fdwSuggest) and (NULL == had)) AND the source format
    //  is PCM, then simply return the same format as the source... this
    //  keeps seemingly random destination suggestions for a source of PCM
    //  from popping up..
    //
    //  note that this is true even if ALL drivers are disabled!
    //
    if ((0L == fdwSuggest) && (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag))
    {
        _fmemcpy(pwfxDst, pwfxSrc, sizeof(PCMWAVEFORMAT));
        return (MMSYSERR_NOERROR);
    }



    //
    //  find a driver to match the formats
    //
    //
    mmr  = MMSYSERR_NODRIVER;
    hadid = NULL;

    ENTER_LIST_SHARED;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
    {
        padid = (PACMDRIVERID)hadid;
        fFound = FALSE;
        for(i = 0; i < padid->cFormatTags; i++ ) {
            //
            //  for every FormatTag in the driver
            //
            if (pwfxSrc->wFormatTag == padid->paFormatTagCache[i].dwFormatTag){
                //
                //  This driver supports the source format.
                //
                if( fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG ) {
                    //
                    //  See if this driver supports the desired dest format.
                    //
                    for(j = 0; j < padid->cFormatTags; j++ ) {
                        //
                        //  for every FormatTag in the driver
                        //
                        if (pwfxDst->wFormatTag ==
                                padid->paFormatTagCache[j].dwFormatTag){
                            //
                            //  This driver supports the dest format.
                            //
                            fFound = TRUE;
                            break;
                        }
                    }
                } else {
                    fFound = TRUE;
                }
                break;
            }
        }

        if( fFound ) {
            EnterHandle(hadid);
            mmr = (MMRESULT)IDriverMessageId(hadid,
                                            ACMDM_FORMAT_SUGGEST,
                                            (LPARAM)(LPVOID)&adfs,
                                            0L );
            LeaveHandle(hadid);
            if (MMSYSERR_NOERROR == mmr)
                break;
        }
    }

    LEAVE_LIST_SHARED;

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api void CALLBACK | acmStreamConvertCallback | The <f acmStreamConvertCallback>
 *      function is a placeholder for an application-supplied function name and refers to the callback
 *      function used with an asynchronous Audio  Compression Manager (ACM) conversion stream.
 *      The actual name must be exported by including it in an EXPORTS statement
 *      in the module-definition file for the DLL..
 *
 *  @parm HACMSTREAM | has | Specifies a handle to the ACM conversion stream
 *      associated with the callback.
 *
 *  @parm UINT | uMsg | Specifies an ACM conversion stream message.
 *
 *      @flag MM_ACM_OPEN | Specifies that the ACM has successfully opened
 *      the conversion stream identified by <p has>.
 *
 *      @flag MM_ACM_CLOSE | Specifies that the ACM has successfully closed
 *      the conversion stream identified by <p has>. The <t HACMSTREAM>
 *      handle (<p has>) is no longer valid after receiving this message.
 *
 *      @flag MM_ACM_DONE | Specifies that the ACM has successfully converted
 *      the buffer identified by <p lParam1> (which is a pointer to the
 *      <t ACMSTREAMHEADER> structure) for the stream handle specified by <p has>.
 *
 *  @parm DWORD | dwInstance | Specifies the user-instance data given
 *      as the <p dwInstance> argument of <f acmStreamOpen>.
 *
 *  @parm LPARAM | lParam1 | Specifies a parameter for the message.
 *
 *  @parm LPARAM | lParam2 | Specifies a parameter for the message.
 *
 *  @comm If the callback is a function (specified by the CALLBACK_FUNCTION
 *	flag in <p fdwOpen> of <f acmStreamOpen>) then the callback may be
 *	accessed at interrupt time.  Therefore the callback must reside in a
 *	DLL and its code segment must be specified as FIXED in the
 *	module-definition file for the DLL. Any data that the callback
 *      accesses must be in a FIXED data segment as well. The callback cannot
 *      make any system calls except for <f PostMessage>, <f PostAppMessage>,
 *      <f timeGetSystemTime>, <f timeGetTime>, <f timeSetEvent>,
 *      <f timeKillEvent>, <f midiOutShortMsg>, <f midiOutLongMsg>, and
 *      <f OutputDebugStr>.
 *
 *  @xref <f acmStreamOpen> <f acmStreamConvert> <f acmStreamClose>
 *
 ***************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamOpen | The acmStreamOpen function opens an Audio Compression
 *      Manager (ACM) conversion stream. Conversion streams are used to convert data from
 *      one specified audio format to another.
 *
 *  @parm LPHACMSTREAM | phas | Specifies a pointer to a <t HACMSTREAM>
 *      handle that will receive the new stream handle that can be used to
 *      perform conversions. Use this handle to identify the stream
 *      when calling other ACM stream conversion functions. This parameter
 *      should be NULL if the ACM_STREAMOPENF_QUERY flag is specified.
 *
 *  @parm HACMDRIVER | had | Specifies an optional handle to an ACM driver.
 *      If specified, this handle identifies a specific driver to be used
 *      for a conversion stream. If this argument is NULL, then all suitable
 *      installed ACM drivers are queried until a match is found.
 *
 *  @parm LPWAVEFORMATEX | pwfxSrc | Specifies a pointer to a <t WAVEFORMATEX>
 *      structure that identifies the desired source format for the
 *      conversion.
 *
 *  @parm LPWAVEFORMATEX | pwfxDst | Specifies a pointer to a <t WAVEFORMATEX>
 *      structure that identifies the desired destination format for the
 *      conversion.
 *
 *  @parm LPWAVEFILTER | pwfltr | Specifies a pointer to a <t WAVEFILTER>
 *      structure that identifies the desired filtering operation to perform
 *      on the conversion stream. This argument can be NULL if no filtering
 *      operation is desired. If a filter is specified, the source
 *      (<p pwfxSrc>) and destination (<p pwfxDst>) formats must be the same.
 *
 *  @parm DWORD | dwCallback | Specifies the address of a callback function
 *      or a handle to a window called after each buffer is converted. A
 *      callback will only be called if the conversion stream is opened with
 *      the ACM_STREAMOPENF_ASYNC flag. If the conversion stream is opened
 *	without the ACM_STREAMOPENF_ASYNC flag, then this parameter should
 *	be set to zero.
 *
 *  @parm DWORD | dwInstance | Specifies user-instance data passed on to the
 *      callback specified by <p dwCallback>. This argument is not used with
 *      window callbacks. If the conversion stream is opened without the
 *	ACM_STREAMOPENF_ASYNC flag, then this parameter should be set to zero.
 *
 *  @parm DWORD | fdwOpen | Specifies flags for opening the conversion stream.
 *
 *      @flag ACM_STREAMOPENF_QUERY | Specifies that the ACM will be queried
 *      to determine whether it supports the given conversion. A conversion
 *      stream will not be opened and no <t HACMSTREAM> handle will be
 *      returned.
 *
 *      @flag ACM_STREAMOPENF_NONREALTIME | Specifies that the ACM will not
 *      consider time constraints when converting the data. By default, the
 *      driver will attempt to convert the data in real time. Note that for
 *      some formats, specifying this flag might improve the audio quality
 *      or other characteristics.
 *
 *      @flag ACM_STREAMOPENF_ASYNC | Specifies that conversion of the stream should
 *      be performed asynchronously. If this flag is specified, the application
 *      can use a callback to be notified on open and close of the conversion
 *      stream, and after each buffer is converted. In addition to using a
 *      callback, an application can examine the <e ACMSTREAMHEADER.fdwStatus>
 *      of the <t ACMSTREAMHEADER> structure for the ACMSTREAMHEADER_STATUSF_DONE
 *      flag.
 *
 *      @flag CALLBACK_WINDOW | Specifies that <p dwCallback> is assumed to
 *      be a window handle.
 *
 *      @flag CALLBACK_FUNCTION | Specifies that <p dwCallback> is assumed to
 *      be a callback procedure address. The function prototype must conform
 *      to the <f acmStreamConvertCallback> convention.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The requested operation cannot be performed.
 *
 *  @comm Note that if an ACM driver cannot perform real-time conversions,
 *      and the ACM_STREAMOPENF_NONREALTIME flag is not specified for
 *      the <p fdwOpen> argument, the open will fail returning an
 *      ACMERR_NOTPOSSIBLE error code. An application can use the
 *      ACM_STREAMOPENF_QUERY flag to determine if real-time conversions
 *      are supported for the input arguments.
 *
 *	If a window is chosen to receive callback information, the
 *      following messages are sent to the window procedure function to
 *      indicate the progress of the conversion stream: <m MM_ACM_OPEN>,
 *      <m MM_ACM_CLOSE>, and <m MM_ACM_DONE>. The <p wParam>  parameter identifies
 *      the <t HACMSTREAM> handle. The <p lParam>  parameter identifies the
 *      <t ACMSTREAMHEADER> structure for <m MM_ACM_DONE>, but is not used
 *      for <m MM_ACM_OPEN> and <m MM_ACM_CLOSE>.
 *
 *      If a function is chosen to receive callback information, the
 *      following messages are sent to the function to indicate the progress
 *      of waveform output: <m MM_ACM_OPEN>, <m MM_ACM_CLOSE>, and
 *      <m MM_ACM_DONE>. The callback function must reside in a DLL. You do
 *      not need to use <f MakeProcInstance> to get a procedure-instance
 *      address for the callback function.
 *
 *  @xref <f acmStreamClose> <f acmStreamConvert> <f acmDriverOpen>
 *      <f acmFormatSuggest> <f acmStreamConvertCallback>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamOpen
(
    LPHACMSTREAM            phas,
    HACMDRIVER              had,
    LPWAVEFORMATEX          pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    LPWAVEFILTER            pwfltr,
    DWORD_PTR               dwCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwOpen
)
{
    PACMGARB		pag;
    PACMSTREAM          pas;
    PACMDRIVERID        padid;
    HACMDRIVERID        hadid;
    MMRESULT            mmr;
    UINT                cbas;
    DWORD               fdwSupport;
    UINT                cbwfxSrc;
    UINT                cbwfxDst;
    UINT                cbwfltr;
    DWORD               fdwStream;
    BOOL                fAsync;
    BOOL                fQuery;
    UINT                uFormatTag;
    HANDLE		hEvent;


    if (NULL != phas)
    {
        V_WPOINTER(phas, sizeof(HACMSTREAM), MMSYSERR_INVALPARAM);
        *phas = NULL;
    }

    V_DFLAGS(fdwOpen, ACM_STREAMOPENF_VALID, acmStreamOpen, MMSYSERR_INVALFLAG);

    fQuery = (0 != (fdwOpen & ACM_STREAMOPENF_QUERY));

    if (fQuery)
    {
        //
        //  ignore what caller gave us--set to NULL so we will FAULT if
        //  someone screws up this code
        //
        phas = NULL;
    }
    else
    {
        //
        //  cause a rip if NULL pointer..
        //
        if (NULL == phas)
        {
            V_WPOINTER(phas, sizeof(HACMSTREAM), MMSYSERR_INVALPARAM);
        }
    }

    V_RWAVEFORMAT(pwfxSrc, MMSYSERR_INVALPARAM);
    V_RWAVEFORMAT(pwfxDst, MMSYSERR_INVALPARAM);

    //
    //
    //
    pag = pagFindAndBoot();
    if (NULL == pag)
    {
	DPF(1, "acmStreamOpen: NULL pag!!!");
	return (MMSYSERR_ERROR);
    }

    
    //
    //
    //
    hEvent = NULL;
    fAsync = (0 != (fdwOpen & ACM_STREAMOPENF_ASYNC));
    if (!fAsync)
    {
        if ((0L != dwCallback) || (0L != dwInstance))
        {
            DebugErr(DBF_ERROR, "acmStreamOpen: dwCallback and dwInstance must be zero for sync streams.");
            return (MMSYSERR_INVALPARAM);
        }
    }

    V_DCALLBACK(dwCallback, HIWORD(fdwOpen), MMSYSERR_INVALPARAM);


    fdwSupport = fAsync ? ACMDRIVERDETAILS_SUPPORTF_ASYNC : 0;

    hadid = NULL;

    //
    //
    //
    fdwStream  = (NULL == had) ? 0L : ACMSTREAM_STREAMF_USERSUPPLIEDDRIVER;


    //
    //  if a filter is given, then check that source and destination formats
    //  are the same...
    //
    if (NULL != pwfltr)
    {
        V_RWAVEFILTER(pwfltr, MMSYSERR_INVALPARAM);

        //
        //  filters do not allow different geometries between source and
        //  destination formats--verify that they are _exactly_ the same.
        //  this includes avg bytes per second!
        //
        //  however, only validate up to wBitsPerSample (the size of a
        //  PCM format header). cbSize can be verified (if necessary) by
        //  the filter driver if it supports non-PCM filtering.
        //
        if (0 != _fmemcmp(pwfxSrc, pwfxDst, sizeof(PCMWAVEFORMAT)))
            return (ACMERR_NOTPOSSIBLE);

        fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_FILTER;

        uFormatTag = pwfxSrc->wFormatTag;
    }
    else
    {
        if (pwfxSrc->wFormatTag == pwfxDst->wFormatTag)
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_CONVERTER;

            uFormatTag = pwfxSrc->wFormatTag;
        }
        else
        {
            fdwSupport |= ACMDRIVERDETAILS_SUPPORTF_CODEC;

            //
            //  choose the most common case in an attempt to reduce the
            //  number of driver opens we do--note that even if one of
            //  the tags is not PCM everything will still work..
            //
            if (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag)
            {
                uFormatTag = pwfxDst->wFormatTag;
            }
            else
            {
                uFormatTag = pwfxSrc->wFormatTag;
            }
        }
    }



    DPF(2, "acmStreamOpen(%s): Tag=%u, %lu Hz, %u Bit, %u Channel(s)",
            fQuery ? (LPSTR)"query" : (LPSTR)"real",
            pwfxSrc->wFormatTag,
            pwfxSrc->nSamplesPerSec,
            pwfxSrc->wBitsPerSample,
            pwfxSrc->nChannels);

    DPF(2, "               To: Tag=%u, %lu Hz, %u Bit, %u Channel(s)",
            pwfxDst->wFormatTag,
            pwfxDst->nSamplesPerSec,
            pwfxDst->wBitsPerSample,
            pwfxDst->nChannels);

    //
    //
    //
    if (NULL != had)
    {
        PACMDRIVER      pad;

        V_HANDLE(had, TYPE_HACMDRIVER, MMSYSERR_INVALHANDLE);

        pad   = (PACMDRIVER)had;
        padid = (PACMDRIVERID)pad->hadid;

        if (fdwSupport != (fdwSupport & padid->fdwSupport))
        {
            return (ACMERR_NOTPOSSIBLE);
        }

        if (fQuery)
        {
            EnterHandle(had);
            mmr = IStreamOpenQuery(had, pwfxSrc, pwfxDst, pwfltr, fdwOpen);
#if defined(WIN32) && defined(WIN4)
	    //
	    //	We only support async conversion to sync conversion
	    //	on the 32-bit side.
	    //
	    if (MMSYSERR_NOERROR != mmr)
	    {
		//
		//  If this driver supports async conversions, and we're
		//  opening for sync conversion, then attempt to open
		//  async and the acm will handle making the async conversion
		//  look like a sync conversion.
		//
		if ( !fAsync &&
		     (ACMDRIVERDETAILS_SUPPORTF_ASYNC & padid->fdwSupport) )
		{
		    mmr = IStreamOpenQuery(had, pwfxSrc, pwfxDst, pwfltr, fdwOpen | ACM_STREAMOPENF_ASYNC);
		}
	    }
#endif
            LeaveHandle(had);
            if (MMSYSERR_NOERROR != mmr)
                return (mmr);
        }
    }

    //
    //  we need to find a driver to match the formats--so enumerate
    //  all drivers until we find one that works. if none can be found,
    //  then fail..
    //
    else
    {
        hadid = NULL;

        ENTER_LIST_SHARED;

        while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadid, 0L))
        {
            ACMFORMATTAGDETAILS aftd;

            //
            //  if this driver does not support the basic function we
            //  need, then don't even attempt to open it..
            //
            padid = (PACMDRIVERID)hadid;

            if (fdwSupport != (fdwSupport & padid->fdwSupport))
                continue;

            //
            //
            //
            aftd.cbStruct    = sizeof(aftd);
            aftd.dwFormatTag = uFormatTag;
            aftd.fdwSupport  = 0L;

            mmr = acmFormatTagDetails((HACMDRIVER)hadid,
                                      &aftd,
                                      ACM_FORMATTAGDETAILSF_FORMATTAG);
            if (MMSYSERR_NOERROR != mmr)
                continue;

            if (fdwSupport != (fdwSupport & aftd.fdwSupport))
                continue;


            //
            //
            //
            //
            EnterHandle(hadid);
            mmr = IDriverOpen(&had, hadid, 0L);
            LeaveHandle(hadid);
            if (MMSYSERR_NOERROR != mmr)
                continue;

            EnterHandle(had);
            mmr = IStreamOpenQuery(had, pwfxSrc, pwfxDst, pwfltr, fdwOpen);
#if defined(WIN32) && defined(WIN4)
	    //
	    //	We only support async conversion to sync conversion
	    //	on the 32-bit side.
	    //
	    if (MMSYSERR_NOERROR != mmr)
	    {
		//
		//  If this driver supports async conversions, and we're
		//  opening for sync conversion, then attempt to open
		//  async and the acm will handle making the async conversion
		//  look like a sync conversion.
		//
		if ( !fAsync &&
		     (ACMDRIVERDETAILS_SUPPORTF_ASYNC & padid->fdwSupport) )
		{
		    mmr = IStreamOpenQuery(had, pwfxSrc, pwfxDst, pwfltr, fdwOpen | ACM_STREAMOPENF_ASYNC);
		}
	    }
#endif
            LeaveHandle(had);

            if (MMSYSERR_NOERROR == mmr)
                break;

            EnterHandle(hadid);
            IDriverClose(had, 0L);
            LeaveHandle(hadid);
            had = NULL;
        }

        LEAVE_LIST_SHARED;

        if (NULL == had)
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  if just being queried, then we succeeded this far--so succeed
    //  the call...
    //
    if (fQuery)
    {
        mmr = MMSYSERR_NOERROR;
        goto Stream_Open_Exit_Error;
    }


    //
    //  alloc an ACMSTREAM structure--we need to alloc enough space for
    //  both the source and destination format headers.
    //
    //  size of one format is sizeof(WAVEFORMATEX) + size of extra format
    //  (wfx->cbSize) informatation. for PCM, the size is simply the
    //  sizeof(PCMWAVEFORMAT)
    //
    cbwfxSrc = SIZEOF_WAVEFORMATEX(pwfxSrc);
    cbwfxDst = SIZEOF_WAVEFORMATEX(pwfxDst);
    cbwfltr  = (NULL == pwfltr) ? 0 : (UINT)pwfltr->cbStruct;


    //
    //  allocate stream instance structure
    //
    cbas = sizeof(ACMSTREAM) + cbwfxSrc + cbwfxDst + (UINT)cbwfltr;
    pas  = (PACMSTREAM)NewHandle(cbas);
    if (NULL == pas)
    {
        DPF(0, "!acmStreamOpen: cannot allocate ACMSTREAM--local heap full!");

        mmr = MMSYSERR_NOMEM;
        goto Stream_Open_Exit_Error;
    }


    //
    //  initialize the ACMSTREAM structure
    //
    //
    pas->uHandleType            = TYPE_HACMSTREAM;
////pas->pasNext                = NULL;
    pas->fdwStream              = fdwStream;
    pas->had                    = had;
    pas->adsi.cbStruct          = sizeof(pas->adsi);
    pas->adsi.pwfxSrc           = (LPWAVEFORMATEX)((PBYTE)(pas + 1));
    pas->adsi.pwfxDst           = (LPWAVEFORMATEX)((PBYTE)(pas + 1) + cbwfxSrc);

    if (NULL != pwfltr)
    {
        pas->adsi.pwfltr        = (LPWAVEFILTER)((PBYTE)(pas + 1) + cbwfxSrc + cbwfxDst);
        _fmemcpy(pas->adsi.pwfltr, pwfltr, (UINT)cbwfltr);
    }

    pas->adsi.dwCallback        = dwCallback;
    pas->adsi.dwInstance        = dwInstance;
    pas->adsi.fdwOpen           = fdwOpen;
////pas->adsi.dwDriverFlags     = 0L;
////pas->adsi.dwDriverInstance  = 0L;
    pas->adsi.has               = (HACMSTREAM)pas;

    _fmemcpy(pas->adsi.pwfxSrc, pwfxSrc, cbwfxSrc);
    _fmemcpy(pas->adsi.pwfxDst, pwfxDst, cbwfxDst);


    //
    //
    //
    //
    //
    EnterHandle(had);
    mmr = (MMRESULT)IDriverMessage(had,
                                   ACMDM_STREAM_OPEN,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   0L);

#if defined(WIN32) && defined(WIN4)
    if ( (MMSYSERR_NOERROR != mmr) &&
	 (!fAsync) &&
	 (padid->fdwSupport & ACMDRIVERDETAILS_SUPPORTF_ASYNC) )
    {
	//
	//  Try making async look like sync
	//
	DPF(2, "acmStreamOpen: Trying async to sync");
	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (NULL != hEvent)
	{
	    pas->fdwStream |= ACMSTREAM_STREAMF_ASYNCTOSYNC;
	    pas->adsi.dwCallback = (DWORD)(UINT)hEvent;
	    pas->adsi.fdwOpen &= ~CALLBACK_TYPEMASK;
	    pas->adsi.fdwOpen |= CALLBACK_EVENT;
	    pas->adsi.fdwOpen |= ACM_STREAMOPENF_ASYNC;
	    mmr = (MMRESULT)IDriverMessage(had,
					   ACMDM_STREAM_OPEN,
					   (LPARAM)(LPVOID)&pas->adsi,
					   0L);
	    if (MMSYSERR_NOERROR == mmr)
	    {
		DPF(2, "acmStreamOpen: Succeeded async to sync open, waiting for CALLBACK_EVENT");
		WaitForSingleObject(hEvent, INFINITE);
	    }
	}
	else
	{
	    DPF(0, "acmStreamOpen: CreateEvent failed, can't make async codec look like sync codec");
	}
    }
#endif
    LeaveHandle(had);

    if (MMSYSERR_NOERROR == mmr)
    {
        PACMDRIVER      pad;

        pad = (PACMDRIVER)had;

        pas->pasNext  = pad->pasFirst;
        pad->pasFirst = pas;


        //
        //  succeed!
        //
        *phas = (HACMSTREAM)pas;

        return (MMSYSERR_NOERROR);
    }


    //
    //  we are failing, so free the instance data that we alloc'd!
    //
    pas->uHandleType = TYPE_HACMNOTVALID;
    DeleteHandle((HLOCAL)pas);


Stream_Open_Exit_Error:

    //
    //	Close the event handle if it was created
    //
    if (hEvent)
    {
	CloseHandle(hEvent);
    }

    //
    //  only close driver if _we_ opened it...
    //
    if (0 == (fdwStream & ACMSTREAM_STREAMF_USERSUPPLIEDDRIVER))
    {
#ifdef WIN32
        hadid = ((PACMDRIVER)had)->hadid;
#endif
        EnterHandle(hadid);
        IDriverClose(had, 0L);
        LeaveHandle(hadid);
    }

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamClose | The acmStreamClose function closes a previously opened Audio
 *      Compression Manager (ACM) conversion stream. If the function is
 *      successful, the handle is invalidated.
 *
 *  @parm HACMSTREAM | has | Identifies the open conversion stream to be
 *      closed.
 *
 *  @parm DWORD | fdwClose | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_BUSY | The conversion stream cannot be closed because
 *      an asynchronous conversion is still in progress.
 *
 *  @xref <f acmStreamOpen> <f acmStreamReset>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamClose
(
    HACMSTREAM          has,
    DWORD               fdwClose
)
{
    MMRESULT        mmr;
    PACMSTREAM      pas;
    PACMDRIVER	    pad;
    PACMDRIVERID    padid;
    PACMGARB	    pag;
    HANDLE	    hEvent;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwClose, ACM_STREAMCLOSEF_VALID, acmStreamClose, MMSYSERR_INVALFLAG);

    pas	    = (PACMSTREAM)has;
    pad	    = (PACMDRIVER)pas->had;
    padid   = (PACMDRIVERID)pad->hadid;
    pag	    = padid->pag;

    //
    //	Verify the handle is for this process
    //
    if (pag != pagFind())
    {
	DebugErr(DBF_ERROR, "acmStreamClose: handle not opened from calling process!");
	return (MMSYSERR_INVALHANDLE);
    }

    if (0 != pas->cPrepared)
    {
        if (pag->hadDestroy != pas->had)
        {
	    DebugErr1(DBF_ERROR, "acmStreamClose: stream contains %u prepared headers!", pas->cPrepared);
            return (MMSYSERR_INVALPARAM);
        }

        DebugErr1(DBF_WARNING, "acmStreamClose: stream contains %u prepared headers--forcing close", pas->cPrepared);
        pas->cPrepared = 0;
    }


    //
    //	Callback event if we are converting async conversion to sync conversion
    //
    hEvent = (pas->fdwStream & ACMSTREAM_STREAMF_ASYNCTOSYNC) ? (HANDLE)pas->adsi.dwCallback : NULL;


    //
    //  tell driver that conversion stream is terminating
    //
    //

    EnterHandle(pas->had);
#ifdef RDEBUG
    if ( (hEvent) && (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, 0)) )
    {
	//
	//  The event is already signaled!  Bad bad!
	//
	DebugErr(DBF_ERROR, "acmStreamClose: asynchronous codec called callback unexpectedly");
    }
#endif
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_CLOSE,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   fdwClose);
    if ( (hEvent) && (MMSYSERR_NOERROR == mmr) ) {
	DPF(4, "acmStreamClose: waiting for CALLBACK_EVENT");
	WaitForSingleObject(hEvent, INFINITE);
    }
    LeaveHandle(pas->had);

    if ((MMSYSERR_NOERROR == mmr) || (pag->hadDestroy == pas->had))
    {
        if (MMSYSERR_NOERROR != mmr)
        {
            DebugErr(DBF_WARNING, "acmStreamClose: forcing close of stream handle!");
        }

	//
	//  Close the event handle
	//
	if (hEvent) {
	    CloseHandle(hEvent);
	}
	
        //
        //  remove the stream handle from the linked list and free its memory
        //
        pad = (PACMDRIVER)pas->had;

        EnterHandle(pad);
        if (pas == pad->pasFirst)
        {
            pad->pasFirst = pas->pasNext;

            //
            //  if this was the last open stream on this driver, then close
            //  the driver instance also...
            //
            if (NULL == pad->pasFirst)
            {
		LeaveHandle(pad);
                if (0 == (pas->fdwStream & ACMSTREAM_STREAMF_USERSUPPLIEDDRIVER))
                {
                    IDriverClose(pas->had, 0L);
                }
            }
	    else
	    {
		LeaveHandle(pad);
	    }
        }
        else
        {
            PACMSTREAM  pasCur;

            //
            //
            //
            for (pasCur = pad->pasFirst;
                (NULL != pasCur) && (pas != pasCur->pasNext);
                pasCur = pasCur->pasNext)
                ;

            if (NULL == pasCur)
            {
                DPF(0, "!acmStreamClose(%.04Xh): stream handle not in list!!!", pas);
                LeaveHandle(pad);
                return (MMSYSERR_INVALHANDLE);
            }

            pasCur->pasNext = pas->pasNext;
	    
	    LeaveHandle(pad);
        }

        //
        //  finally free the stream handle
        //
        pas = (PACMSTREAM)has;
        pas->uHandleType = TYPE_HACMNOTVALID;
        DeleteHandle((HLOCAL)has);
    }

    return (mmr);
}




/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamMessage | This function sends a user-defined
 *      message to a given Audio Compression Manager (ACM) stream instance.
 *
 *  @parm HACMSTREAM | has | Specifies the conversion stream.
 *
 *
 *  @parm UINT | uMsg | Specifies the message that the ACM stream must
 *      process. This message must be in the <m ACMDM_USER> message range
 *      (above or equal to <m ACMDM_USER> and less than
 *      <m ACMDM_RESERVED_LOW>). The exception to this restriction is
 *      the <m ACMDM_STREAM_UPDATE> message.
 *
 *  @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 *  @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 *  @rdesc The return value is specific to the user-defined ACM driver
 *      message <p uMsg> sent. However, the following return values are
 *      possible:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | <p uMsg> is not in the ACMDM_USER range.
 *
 *      @flag MMSYSERR_NOTSUPPORTED | The ACM driver did not process the
 *      message.
 *
 ***************************************************************************/
MMRESULT ACMAPI acmStreamMessage
(
    HACMSTREAM              has,
    UINT                    uMsg, 
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    MMRESULT		mmr;
    PACMSTREAM		pas;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);

    pas = (PACMSTREAM)has;


    //
    //  do not allow non-user range messages through!
    //
    if ( ((uMsg < ACMDM_USER) || (uMsg >= ACMDM_RESERVED_LOW)) &&
	 (uMsg != ACMDM_STREAM_UPDATE) )
    {
	DebugErr(DBF_ERROR, "acmStreamMessage: non-user range messages are not allowed.");
	return (MMSYSERR_INVALPARAM);
    }
    
    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   uMsg,
				   lParam1,
				   lParam2 );
    LeaveHandle(pas);

    return (mmr);
}




/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamReset | The acmStreamReset function stops conversions
 *      for a given Audio Compression Manager (ACM) stream. All pending
 *      buffers are marked as done and returned to the application.
 *
 *  @parm HACMSTREAM | has | Specifies the conversion stream.
 *
 *  @parm DWORD | fdwReset | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *  @comm Resetting an ACM conversion stream is only necessary to reset
 *      asynchronous conversion streams. However, resetting a synchronous
 *      conversion stream will succeed, but no action will be taken.
 *
 *  @xref <f acmStreamConvert> <f acmStreamClose>
 *
 ***************************************************************************/
MMRESULT ACMAPI acmStreamReset
(
    HACMSTREAM          has,
    DWORD               fdwReset
)
{
    MMRESULT        mmr;
    PACMSTREAM      pas;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwReset, ACM_STREAMRESETF_VALID, acmStreamReset, MMSYSERR_INVALFLAG);

    pas = (PACMSTREAM)has;

    //
    //  if the stream was not opened as async, then just succeed the reset
    //  call--it only makes sense with async streams...
    //
    if (0 == (ACM_STREAMOPENF_ASYNC & pas->adsi.fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }

    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_RESET,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   fdwReset);
    LeaveHandle(pas);

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamSize | The acmStreamSize function returns a recommended size for a
 *      source or destination buffer on an Audio Compression Manager (ACM)
 *      stream.
 *
 *  @parm HACMSTREAM | has | Specifies the conversion stream.
 *
 *  @parm DWORD | cbInput | Specifies the size in bytes of either the source
 *      or destination buffer. The <p fdwSize> flags specify what the
 *      input argument defines. This argument must be non-zero.
 *
 *  @parm LPDWORD | pdwOutputBytes | Specifies a pointer to a <t DWORD>
 *      that contains the size in bytes of the source or destination buffer.
 *      The <p fdwSize> flags specify what the output argument defines.
 *      If the <f acmStreamSize> function succeeds, this location will
 *      always be filled with a non-zero value.
 *
 *  @parm DWORD | fdwSize | Specifies flags for the stream-size query.
 *
 *      @flag ACM_STREAMSIZEF_SOURCE | Indicates that <p cbInput> contains
 *      the size of the source buffer. The <p pdwOutputBytes> argument will
 *      receive the recommended destination buffer size in bytes.
 *
 *      @flag ACM_STREAMSIZEF_DESTINATION | Indicates that <p cbInput>
 *      contains the size of the destination buffer. The <p pdwOutputBytes>
 *      argument will receive the recommended source buffer size in bytes.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The requested operation cannot be performed.
 *
 *  @comm An application can use the <f acmStreamSize> function to determine
 *      suggested buffer sizes for either source or destination buffers.
 *      The buffer sizes returned might be only an estimation of the
 *      actual sizes required for conversion. Because actual conversion
 *      sizes cannot always be determined without performing the conversion,
 *      the sizes returned will usually be overestimated.
 *
 *      In the event of an error, the location pointed to by
 *      <p pdwOutputBytes> will receive zero. This assumes that the pointer
 *      specified by <p pdwOutputBytes> is valid.
 *
 *  @xref <f acmStreamPrepareHeader> <f acmStreamConvert>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamSize
(
    HACMSTREAM          has,
    DWORD               cbInput,
    LPDWORD             pdwOutputBytes,
    DWORD               fdwSize
)
{
    MMRESULT            mmr;
    PACMSTREAM          pas;
    ACMDRVSTREAMSIZE    adss;

    V_WPOINTER(pdwOutputBytes, sizeof(DWORD), MMSYSERR_INVALPARAM);

    *pdwOutputBytes = 0L;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_DFLAGS(fdwSize, ACM_STREAMSIZEF_VALID, acmStreamSize, MMSYSERR_INVALFLAG);

    if (0L == cbInput)
    {
        DebugErr(DBF_ERROR, "acmStreamSize: input size cannot be zero.");
        return (MMSYSERR_INVALPARAM);
    }

    pas = (PACMSTREAM)has;

    adss.cbStruct = sizeof(adss);
    adss.fdwSize  = fdwSize;

    switch (ACM_STREAMSIZEF_QUERYMASK & fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            adss.cbSrcLength = cbInput;
            adss.cbDstLength = 0L;
            break;

        case ACM_STREAMSIZEF_DESTINATION:
            adss.cbSrcLength = 0L;
            adss.cbDstLength = cbInput;
            break;

        default:
            DebugErr(DBF_WARNING, "acmStreamSize: unknown query type requested.");
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //
    //
    //

    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_SIZE,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   (LPARAM)(LPVOID)&adss);
    LeaveHandle(pas);
    if (MMSYSERR_NOERROR == mmr)
    {
        switch (ACM_STREAMSIZEF_QUERYMASK & fdwSize)
        {
            case ACM_STREAMSIZEF_SOURCE:
                *pdwOutputBytes  = adss.cbDstLength;
                break;

            case ACM_STREAMSIZEF_DESTINATION:
                *pdwOutputBytes  = adss.cbSrcLength;
                break;
        }


        //
        //
        //
        if (0L == *pdwOutputBytes)
        {
            DebugErr(DBF_ERROR, "acmStreamSize: buggy driver returned zero bytes for output?!?");
            return (ACMERR_NOTPOSSIBLE);
        }
    }

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamPrepareHeader | The acmStreamPrepareHeader
 *	function prepares an <t ACMSTREAMHEADER> for an Audio Compression
 *	Manager (ACM) stream conversion. This function must be called for
 *	every stream header before it can be used in a conversion stream. An
 *	application only needs to prepare a stream header once for the life of
 *	a given stream; the stream header can be reused as long as the same
 *	source and destiniation buffers are used, and the size of the source
 *	and destination buffers do not exceed the sizes used when the stream
 *	header was originally prepared.
 *
 *  @parm HACMSTREAM | has | Specifies a handle to the conversion steam.
 *
 *  @parm LPACMSTREAMHEADER | pash | Specifies a pointer to an <t ACMSTREAMHEADER>
 *      structure that identifies the source and destination data buffers to
 *      be prepared.
 *
 *  @parm DWORD | fdwPrepare | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_NOMEM | Unable to allocate resources.
 *
 *  @comm Preparing a stream header that has already been prepared has no
 *      effect, and the function returns zero. However, an application should
 *      take care to structure code so multiple prepares do not occur.
 *
 *  @xref <f acmStreamUnprepareHeader> <f acmStreamOpen>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamPrepareHeader
(
    HACMSTREAM              has,
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwPrepare
)
{
    MMRESULT                mmr;
    PACMSTREAM              pas;
    LPACMDRVSTREAMHEADER    padsh;
    DWORD                   cbDstRequired;
#if 0
    DWORD                   cbSlop;
#endif // 0
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_WPOINTER(pash, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pash, pash->cbStruct, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwPrepare, ACM_STREAMPREPAREF_VALID, acmStreamPrepareHeader, MMSYSERR_INVALFLAG);

    if (pash->cbStruct < sizeof(ACMDRVSTREAMHEADER))
    {
        DebugErr(DBF_ERROR, "acmStreamPrepareHeader: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    if (0 != (pash->fdwStatus & ~ACMSTREAMHEADER_STATUSF_VALID))
    {
        DebugErr(DBF_ERROR, "acmStreamPrepareHeader: header contains invalid status flags.");
        return (MMSYSERR_INVALFLAG);
    }


    //
    //
    //
    if (0 != (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED))
    {
        DebugErr(DBF_WARNING, "acmStreamPrepareHeader: header is already prepared.");
        return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    pas   = (PACMSTREAM)has;
    padsh = (LPACMDRVSTREAMHEADER)pash;

    //
    //	For debug builds, verify the handle is for this process
    //
#ifdef RDEBUG
    if ( ((PACMGARB)(((PACMDRIVERID)(((PACMDRIVER)pas->had)->hadid))->pag)) != pagFind() )
    {
	DebugErr(DBF_ERROR, "acmStreamPrepareHeader: handle not opened by calling process!");
	return (MMSYSERR_INVALHANDLE);
    }
#endif
    
    //
    //
    //
    //
    mmr = acmStreamSize(has, pash->cbSrcLength, &cbDstRequired, ACM_STREAMSIZEF_SOURCE);
    if (MMSYSERR_NOERROR != mmr)
    {
        return (mmr);
    }

    //
    //  Huh huh uhh huh...
    //
    //
    pwfxSrc = pas->adsi.pwfxSrc;
    pwfxDst = pas->adsi.pwfxDst;

#if 0
    if (pwfxSrc->nSamplesPerSec >= pwfxDst->nSamplesPerSec)
    {
        cbSlop = MulDivRU(pwfxSrc->nSamplesPerSec,
                          pwfxSrc->nBlockAlign,
                          pwfxDst->nSamplesPerSec);
    }
    else
    {
        cbSlop = MulDivRU(pwfxDst->nSamplesPerSec,
                          pwfxDst->nBlockAlign,
                          pwfxSrc->nSamplesPerSec);
    }

    DPF(1, "acmStreamPrepareHeader: cbSrcLength=%lu, cbDstLength=%lu, cbDstRequired=%lu, cbSlop=%lu",
        pash->cbSrcLength, pash->cbDstLength, cbDstRequired, cbSlop);

    if (cbDstRequired > cbSlop)
    {
        cbDstRequired -= cbSlop;
    }

    if (cbDstRequired > pash->cbDstLength)
    {
        DebugErr2(DBF_ERROR, "acmStreamPrepareHeader: src=%lu, dst buffer must be >= %lu bytes.",
                    pash->cbSrcLength, cbDstRequired);
        return (MMSYSERR_INVALPARAM);
    }
#endif

    //
    //  after all the size verification stuff done above, now we check
    //  the src and dst buffer pointers...
    //
    V_RPOINTER(pash->pbSrc, pash->cbSrcLength, MMSYSERR_INVALPARAM);
    V_WPOINTER(pash->pbDst, pash->cbDstLength, MMSYSERR_INVALPARAM);


    //
    //  init a couple of things for the driver
    //
    padsh->fdwConvert           = fdwPrepare;
    padsh->padshNext            = NULL;
    padsh->fdwDriver            = 0L;
    padsh->dwDriver             = 0L;

    padsh->fdwPrepared          = 0L;
    padsh->dwPrepared           = 0L;
    padsh->pbPreparedSrc        = NULL;
    padsh->cbPreparedSrcLength  = 0L;
    padsh->pbPreparedDst        = NULL;
    padsh->cbPreparedDstLength  = 0L;


    //
    //  set up driver instance info--copy over driver data that is saved
    //  in ACMSTREAM
    //
    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_PREPARE,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   (LPARAM)(LPVOID)padsh);
    LeaveHandle(pas);

    if (MMSYSERR_NOTSUPPORTED == mmr ||
        MMSYSERR_NOERROR      == mmr &&
        (((PACMDRIVERID)((PACMDRIVER)pas->had)->hadid)->fdwAdd &
         ACM_DRIVERADDF_32BIT))
    {
        //
        //  the driver doesn't seem to think it needs anything special
        //  so just succeed the call
        //
        //  note that if the ACM needs to do something special, it should
        //  do it here...
        //
#ifndef WIN32
{
        BOOL            fAsync;

        fAsync = (0 != (pas->adsi.fdwOpen & ACM_STREAMOPENF_ASYNC));
        if (fAsync)
        {
            DPF(1, "acmStreamPrepareHeader: preparing async header and buffers");

            if (!acmHugePageLock((LPBYTE)padsh, padsh->cbStruct, FALSE))
            {
                return (MMSYSERR_NOMEM);
            }

            if (!acmHugePageLock(padsh->pbSrc, pash->cbSrcLength, FALSE))
            {
                acmHugePageUnlock((LPBYTE)padsh, padsh->cbStruct, FALSE);
                return MMSYSERR_NOMEM;
            }

            if (!acmHugePageLock(padsh->pbDst, pash->cbDstLength, FALSE))
            {
                acmHugePageUnlock(padsh->pbSrc, pash->cbSrcLength, FALSE);
                acmHugePageUnlock((LPBYTE)padsh, padsh->cbStruct, FALSE);
                return (MMSYSERR_NOMEM);
            }
        }
}
#endif

        mmr = MMSYSERR_NOERROR;
    }

    //
    //
    //
    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  set the prepared bit (and also kill any invalid flags that
        //  the driver might have felt it should set--when the driver
        //  writer sees that his flags are not being preserved he will
        //  probably read the docs and use pash->fdwDriver instead).
        //
        pash->fdwStatus  = pash->fdwStatus | ACMSTREAMHEADER_STATUSF_PREPARED;
        pash->fdwStatus &= ACMSTREAMHEADER_STATUSF_VALID;


        //
        //  save the original prepared pointers and sizes so we can keep
        //  track of this stuff for the calling app..
        //
        padsh->fdwPrepared          = fdwPrepare;
        padsh->dwPrepared           = (DWORD_PTR)(UINT_PTR)has;
        padsh->pbPreparedSrc        = padsh->pbSrc;
        padsh->cbPreparedSrcLength  = padsh->cbSrcLength;
        padsh->pbPreparedDst        = padsh->pbDst;
        padsh->cbPreparedDstLength  = padsh->cbDstLength;

        pas->cPrepared++;
    }

    return (mmr);
}


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamUnprepareHeader | The acmStreamUnprepareHeader function
 *      cleans up the preparation performed by the <f acmStreamPrepareHeader>
 *      function for an Audio Compression Manager (ACM) stream. This function must
 *      be called after the ACM is finished with the given buffers. An
 *      application must call this function before freeing the source and
 *      destination buffers.
 *
 *  @parm HACMSTREAM | has | Specifies a handle to the conversion steam.
 *
 *  @parm LPACMSTREAMHEADER | pash | Specifies a pointer to an <t ACMSTREAMHEADER>
 *      structure that identifies the source and destination data buffers to
 *      be unprepared.
 *
 *  @parm DWORD | fdwUnprepare | This argument is not used and must be set to
 *      zero.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag ACMERR_BUSY | The stream header <p pash> is currently in use
 *      and cannot be unprepared.
 *
 *      @flag ACMERR_UNPREPARED | The stream header <p pash> is currently
 *      not prepared by the <f acmStreamPrepareHeader> function.
 *
 *  @comm Unpreparing a stream header that has already been unprepared is
 *      an error. An application must specify the source and destination
 *      buffer lengths (<e ACMSTREAMHEADER.cbSrcLength> and
 *      <e ACMSTREAMHEADER.cbDstLength> respectively) that were used
 *      during the corresponding <f acmStreamPrepareHeader> call. Failing
 *      to reset these member values will cause <f acmStreamUnprepareHeader>
 *      to fail with MMSYSERR_INVALPARAM.
 *
 *      Note that there are some errors that the ACM can recover from. The
 *      ACM will return a non-zero error, yet the stream header will be
 *      properly unprepared. To determine whether the stream header was
 *      actually unprepared an application can examine the
 *      ACMSTREAMHEADER_STATUSF_PREPARED flag. The header will always be
 *      unprepared if <f acmStreamUnprepareHeader> returns success.
 *
 *  @xref <f acmStreamPrepareHeader> <f acmStreamClose>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamUnprepareHeader
(
    HACMSTREAM              has,
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwUnprepare
)
{
    MMRESULT                mmr;
    PACMSTREAM              pas;
    LPACMDRVSTREAMHEADER    padsh;
    BOOL                    fStupidApp;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_WPOINTER(pash, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pash, pash->cbStruct, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwUnprepare, ACM_STREAMPREPAREF_VALID, acmStreamUnprepareHeader, MMSYSERR_INVALFLAG);

    if (pash->cbStruct < sizeof(ACMDRVSTREAMHEADER))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    if (0 != (pash->fdwStatus & ~ACMSTREAMHEADER_STATUSF_VALID))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header contains invalid status flags.");
        return (MMSYSERR_INVALFLAG);
    }

    //
    //
    //
    if (0 != (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_INQUEUE))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header is still in use.");
        return (ACMERR_BUSY);
    }


    if (0 == (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header is not prepared.");
        return (ACMERR_UNPREPARED);
    }

    //
    //
    //
    pas   = (PACMSTREAM)has;
    padsh = (LPACMDRVSTREAMHEADER)pash;

    //
    //	For debug builds, verify the handle is for this process
    //
#ifdef RDEBUG
    if ( ((PACMGARB)(((PACMDRIVERID)(((PACMDRIVER)pas->had)->hadid))->pag)) != pagFind() )
    {
	DebugErr(DBF_ERROR, "acmStreamUnprepareHandle: handle not opened by calling process!");
	return (MMSYSERR_INVALHANDLE);
    }
#endif

    //
    //
    //
    if ((UINT_PTR)has != padsh->dwPrepared)
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header prepared for different stream.");
        return (MMSYSERR_INVALHANDLE);
    }

    fStupidApp = FALSE;
    if ((padsh->pbSrc != padsh->pbPreparedSrc) ||
        (padsh->cbSrcLength != padsh->cbPreparedSrcLength))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header prepared with different source buffer/length.");

        if (padsh->pbSrc != padsh->pbPreparedSrc)
        {
            return (MMSYSERR_INVALPARAM);
        }

        padsh->cbSrcLength = padsh->cbPreparedSrcLength;
        fStupidApp = TRUE;
    }

    if ((padsh->pbDst != padsh->pbPreparedDst) ||
        (padsh->cbDstLength != padsh->cbPreparedDstLength))
    {
        DebugErr(DBF_ERROR, "acmStreamUnprepareHeader: header prepared with different destination buffer/length.");

        if (padsh->pbDst != padsh->pbPreparedDst)
        {
            return (MMSYSERR_INVALPARAM);
        }

        padsh->cbDstLength = padsh->cbPreparedDstLength;
        fStupidApp = TRUE;
    }



    //
    //  init things for the driver
    //
    padsh->fdwConvert = fdwUnprepare;

    EnterHandle(pas);
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_UNPREPARE,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   (LPARAM)(LPVOID)padsh);
    LeaveHandle(pas);

    if (MMSYSERR_NOTSUPPORTED == mmr)
    {
        //
        //  note that if the ACM needs to undo something special, it should
        //  do it here...
        //
#ifndef WIN32
{
        BOOL            fAsync;

        fAsync = (0 != (pas->adsi.fdwOpen & ACM_STREAMOPENF_ASYNC));
        if (fAsync)
        {
            DPF(1, "acmStreamUnprepareHeader: unpreparing async header and buffers");
            acmHugePageUnlock(padsh->pbDst, pash->cbDstLength, FALSE);
            acmHugePageUnlock(padsh->pbSrc, pash->cbSrcLength, FALSE);
            acmHugePageUnlock((LPBYTE)padsh, padsh->cbStruct, FALSE);
        }
}
#endif

        mmr = MMSYSERR_NOERROR;
    }

    //
    //
    //
    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  UNset the prepared bit (and also kill any invalid flags that
        //  the driver might have felt it should set--when the driver
        //  writer sees that his flags are not being preserved he will
        //  probably read the docs and use pash->fdwDriver instead).
        //
        pash->fdwStatus  = pash->fdwStatus & ~ACMSTREAMHEADER_STATUSF_PREPARED;
        pash->fdwStatus &= ACMSTREAMHEADER_STATUSF_VALID;

        padsh->fdwPrepared          = 0L;
        padsh->dwPrepared           = 0L;
        padsh->pbPreparedSrc        = NULL;
        padsh->cbPreparedSrcLength  = 0L;
        padsh->pbPreparedDst        = NULL;
        padsh->cbPreparedDstLength  = 0L;

        pas->cPrepared--;

        //
        //  if we fixed up a bug for the app, still return an error...
        //
        if (fStupidApp)
        {
            mmr = MMSYSERR_INVALPARAM;
        }
    }

    return (mmr);
}



/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMSTREAMHEADER | The <t ACMSTREAMHEADER> structure defines the
 *      header used to identify an Audio Compression Manager (ACM) conversion
 *      source and destination buffer pair for a conversion stream.
 *
 *  @field DWORD | cbStruct | Specifies the size, in bytes, of the
 *      <t ACMSTREAMHEADER> structure. This member must be initialized
 *      before calling any ACM stream functions using this structure.
 *      The size specified in this member must be large enough to contain
 *      the base <t ACMSTREAMHEADER> structure.
 *
 *  @field DWORD | fdwStatus | Specifies flags giving information about
 *      the conversion buffers. This member must be initialized to zero
 *      before calling <f acmStreamPrepareHeader> and should not be modified
 *      by the application while the stream header remains prepared.
 *
 *      @flag ACMSTREAMHEADER_STATUSF_DONE | Set by the ACM or driver to
 *      indicate that it is finished with the conversion and is returning it
 *      to the application.
 *
 *      @flag ACMSTREAMHEADER_STATUSF_PREPARED | Set by the ACM to indicate
 *      that the data buffers have been prepared with <f acmStreamPrepareHeader>.
 *
 *      @flag ACMSTREAMHEADER_STATUSF_INQUEUE | Set by the ACM or driver to
 *      indicate that the data buffers are queued for conversion.
 *
 *  @field DWORD | dwUser | Specifies 32 bits of user data. This can be any
 *      instance data specified by the application.
 *
 *  @field LPBYTE | pbSrc | Specifies a pointer to the source data buffer.
 *      This pointer must always refer to the same location while the stream
 *      header remains prepared. If an application needs to change the
 *      source location, it must unprepare the header and re-prepare it
 *      with the alternate location.
 *
 *  @field DWORD | cbSrcLength | Specifies the length, in bytes, of the source
 *      data buffer pointed to by <e ACMSTREAMHEADER.pbSrc>. When the
 *      header is prepared, this member must specify the maximum size
 *      that will be used in the source buffer. Conversions can be performed
 *      on source lengths less than or equal to the original prepared size.
 *      However, this member must be reset to the original size when
 *      unpreparing the header.
 *
 *  @field DWORD | cbSrcLengthUsed | Specifies the amount of data, in bytes,
 *      used for the conversion. This member is not valid until the
 *      conversion is complete. Note that this value can be less than or
 *      equal to <e ACMSTREAMHEADER.cbSrcLength>. An application must use
 *      the <e ACMSTREAMHEADER.cbSrcLengthUsed> member when advancing to
 *      the next piece of source data for the conversion stream.
 *
 *  @field DWORD | dwSrcUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field LPBYTE | pbDst | Specifies a pointer to the destination data
 *      buffer. This pointer must always refer to the same location while
 *      the stream header remains prepared. If an application needs to change
 *      the destination location, it must unprepare the header and re-prepare
 *      it with the alternate location.
 *
 *  @field DWORD | cbDstLength | Specifies the length, in bytes, of the
 *      destination data buffer pointed to by <e ACMSTREAMHEADER.pbDst>.
 *      When the header is prepared, this member must specify the maximum
 *      size that will be used in the destination buffer. Conversions can be
 *      performed to destination lengths less than or equal to the original
 *      prepared size. However, this member must be reset to the original
 *      size when unpreparing the header.
 *
 *  @field DWORD | cbDstLengthUsed | Specifies the amount of data, in bytes,
 *      returned by a conversion. This member is not valid until the
 *      conversion is complete. Note that this value may be less than or
 *      equal to <e ACMSTREAMHEADER.cbDstLength>. An application must use
 *      the <e ACMSTREAMHEADER.cbDstLengthUsed> member when advancing to
 *      the next destination location for the conversion stream.
 *
 *  @field DWORD | dwDstUser | Specifies 32 bits of user data. This can be
 *      any instance data specified by the application.
 *
 *  @field DWORD | dwReservedDriver[10] | This member is reserved and should not be used.
 *      This member requires no initialization by the application and should
 *      never be modified while the header remains prepared.
 *
 *  @tagname tACMSTREAMHEADER
 *
 *  @othertype ACMSTREAMHEADER FAR * | LPACMSTREAMHEADER | Pointer to a
 *      <t ACMSTREAMHEADER> structure.
 *
 *  @comm Before an <t ACMSTREAMHEADER> structure can be used for a conversion, it must
 *      be prepared with <f acmStreamPrepareHeader>. When an application
 *      is finished with an <t ACMSTREAMHEADER> structure, the <f acmStreamUnprepareHeader>
 *      function must be called before freeing the source and destination buffers.
 *
 *  @xref <f acmStreamPrepareHeader> <f acmStreamUnprepareHeader>
 *      <f acmStreamConvert>
 *
 ****************************************************************************/


/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmStreamConvert | The acmStreamConvert function requests the Audio
 *      Compression Manager (ACM) to perform a conversion on the specified conversion stream. A
 *      conversion may be synchronous or asynchronous depending on how the
 *      stream was opened.
 *
 *  @parm HACMSTREAM | has | Identifies the open conversion stream.
 *
 *  @parm LPACMSTREAMHEADER | pash | Specifies a pointer to a stream header
 *      that describes source and destination buffers for a conversion. This
 *      header must have been prepared previously using the
 *      <f acmStreamPrepareHeader> function.
 *
 *  @parm  DWORD | fdwConvert | Specifies flags for doing the conversion.
 *
 *      @flag ACM_STREAMCONVERTF_BLOCKALIGN | Specifies that only integral
 *      numbers of blocks will be converted. Converted data will end on
 *      block aligned boundaries. An application should use this flag for
 *      all conversions on a stream until there is not enough source data
 *      to convert to a block-aligned destination. In this case, the last
 *      conversion should be specified without this flag.
 *
 *      @flag ACM_STREAMCONVERTF_START | Specifies that the ACM conversion
 *      stream should reinitialize its instance data. For example, if a
 *      conversion stream holds instance data, such as delta or predictor
 *      information, this flag will restore the stream to starting defaults.
 *      Note that this flag can be specified with the ACM_STREAMCONVERTF_END
 *      flag.
 *
 *      @flag ACM_STREAMCONVERTF_END | Specifies that the ACM conversion
 *      stream should begin returning pending instance data. For example, if
 *      a conversion stream holds instance data, such as the tail end of an
 *      echo filter operation, this flag will cause the stream to start
 *      returning this remaining data with optional source data. Note that
 *      this flag can be specified with the ACM_STREAMCONVERTF_START flag.
 *
 *  @rdesc Returns zero if the function was successful. Otherwise, it returns
 *      a non-zero error number. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_BUSY | The stream header <p pash> is currently in use
 *      and cannot be reused.
 *
 *      @flag ACMERR_UNPREPARED | The stream header <p pash> is currently
 *      not prepared by the <f acmStreamPrepareHeader> function.
 *
 *  @comm The source and destination data buffers must be prepared with
 *      <f acmStreamPrepareHeader> before they are passed to <f acmStreamConvert>.
 *
 *      If an asynchronous conversion request is successfully queued by
 *      the ACM or driver, and later the conversion is determined to
 *      be impossible, then the <t ACMSTREAMHEADER> will be posted back to
 *      the application's callback with the <e ACMSTREAMHEADER.cbDstLengthUsed>
 *      member set to zero.
 *
 *  @xref <f acmStreamOpen> <f acmStreamReset> <f acmStreamPrepareHeader>
 *      <f acmStreamUnprepareHeader>
 *
 ***************************************************************************/

MMRESULT ACMAPI acmStreamConvert
(
    HACMSTREAM              has,
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwConvert
)
{
    MMRESULT                mmr;
    PACMSTREAM              pas;
    LPACMDRVSTREAMHEADER    padsh;
    HANDLE		    hEvent;

    V_HANDLE(has, TYPE_HACMSTREAM, MMSYSERR_INVALHANDLE);
    V_WPOINTER(pash, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pash, pash->cbStruct, MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwConvert, ACM_STREAMCONVERTF_VALID, acmStreamConvert, MMSYSERR_INVALFLAG);

    if (pash->cbStruct < sizeof(ACMDRVSTREAMHEADER))
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    if (0 != (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_INQUEUE))
    {
        DebugErr(DBF_WARNING,"acmStreamConvert: header is already being converted.");
        return (ACMERR_BUSY);
    }

    if (0 == (pash->fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED))
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: header is not prepared.");
        return (ACMERR_UNPREPARED);
    }

    //
    //
    //
    padsh = (LPACMDRVSTREAMHEADER)pash;
    pas   = (PACMSTREAM)has;

    //
    //	For debug builds, verify the handle is for this process
    //
#ifdef RDEBUG
    if ( ((PACMGARB)(((PACMDRIVERID)(((PACMDRIVER)pas->had)->hadid))->pag)) != pagFind() )
    {
	DebugErr(DBF_ERROR, "acmStreamConvert: handle not opened by calling process!");
	return (MMSYSERR_INVALHANDLE);
    }
#endif

    padsh->cbSrcLengthUsed = 0L;
    padsh->cbDstLengthUsed = 0L;


    //
    //  validate that the header is appropriate for conversions.
    //
    //  NOTE! do not allow a destination buffer length that is smaller than
    //  it was prepared for--this keeps drivers from having to validate
    //  whether the destination buffer is large enough for the conversion
    //  from the source. so don't break this code!!!
    //
    if ((UINT_PTR)has != padsh->dwPrepared)
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: header prepared for different stream.");
        return (MMSYSERR_INVALHANDLE);
    }

    if ((padsh->pbSrc != padsh->pbPreparedSrc) ||
        (padsh->cbSrcLength > padsh->cbPreparedSrcLength))
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: header prepared with incompatible source buffer/length.");
        return (MMSYSERR_INVALPARAM);
    }

    if ((padsh->pbDst != padsh->pbPreparedDst) ||
        (padsh->cbDstLength != padsh->cbPreparedDstLength))
    {
        DebugErr(DBF_ERROR, "acmStreamConvert: header prepared with incompatible destination buffer/length.");
        return (MMSYSERR_INVALPARAM);
    }


    //
    //	Callback event if we are converting async conversion to sync conversion.
    //
    hEvent = (ACMSTREAM_STREAMF_ASYNCTOSYNC & pas->fdwStream) ? (HANDLE)pas->adsi.dwCallback : NULL;
    
    //
    //  init things for the driver
    //
    padsh->fdwStatus  &= ~ACMSTREAMHEADER_STATUSF_DONE;
    padsh->fdwConvert  = fdwConvert;
    padsh->padshNext   = NULL;

    EnterHandle(pas);
#ifdef RDEBUG
    if ( (hEvent) && (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, 0)) )
    {
	//
	//  The event is already signaled!  Bad bad!
	//
	DebugErr(DBF_ERROR, "acmStreamConvert: asynchronous codec called callback unexpectedly");
    }
#endif
    mmr = (MMRESULT)IDriverMessage(pas->had,
                                   ACMDM_STREAM_CONVERT,
                                   (LPARAM)(LPVOID)&pas->adsi,
                                   (LPARAM)(LPVOID)padsh);
    if ( (hEvent) && (MMSYSERR_NOERROR == mmr) )
    {
	DPF(4, "acmStreamConvert: waiting for CALLBACK_EVENT");
	WaitForSingleObject(hEvent, INFINITE);
	ResetEvent(hEvent);
    }
    LeaveHandle(pas);

    if (MMSYSERR_NOERROR == mmr)
    {
        if (pash->cbSrcLength < pash->cbSrcLengthUsed)
        {
            DebugErr(DBF_ERROR, "acmStreamConvert: buggy driver returned more data used than given!?!");
            pash->cbSrcLengthUsed = pash->cbSrcLength;
        }

        if (pash->cbDstLength < pash->cbDstLengthUsed)
        {
            DebugErr(DBF_ERROR, "acmStreamConvert: buggy driver used more destination space than allowed!?!");
            pash->cbDstLengthUsed = pash->cbDstLength;
        }

        //
        //  if sync conversion succeeded, then mark done bit for the
        //  driver...
        //
        if (0 == (ACM_STREAMOPENF_ASYNC & pas->adsi.fdwOpen))
        {
            padsh->fdwStatus |= ACMSTREAMHEADER_STATUSF_DONE;
        }
    }

    //
    //  don't allow driver to set bits that we don't want them to!
    //
    pash->fdwStatus &= ACMSTREAMHEADER_STATUSF_VALID;

    return (mmr);
}



//==========================================================================;
//
//  Compatibility with Foghorn's Quick Recorder
//
//
//
//==========================================================================;

#ifndef WIN32

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Compatibility with Foghorn's Quick Recorder--internal now.
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  old convert header for buffer conversion
//
//
//
typedef struct
{
    DWORD               dwFlags;
    LPBYTE              pbSrc;
    DWORD               dwSrcLength;
    DWORD               dwSrcLengthUsed;
    LPBYTE              pbDst;
    DWORD               dwDstLength;
    DWORD               dwDstLengthUsed;
    DWORD               dwUser;
    DWORD               dwUserReserved[2];
    DWORD               dwDrvReserved[4];

} OLD_ACMCONVERTHDR, *POLD_ACMCONVERTHDR, FAR *LPOLD_ACMCONVERTHDR;


/****************************************************************************
 * @doc INTERNAL ACM_API
 *
 * @api LRESULT | acmOpenConversion | Opens a channel to convert data from
 * one specified audio format to another. Optionally specifies a particular codec to use.
 *
 * @parm LPHACMSTREAM | phas | Specifies a pointer to a stream handle that
 * identifies the open converter. Use this handle to identify the converter channel when calling
 * other ACM conversion functions.
 *
 * @parm HACMCONV | hac | Optional handle to an ACM converter.
 * This is used to specify a particular converter.
 *
 * @parm  LPWAVEFORMATEX | pwfxSrc | Specifies a pointer to a WAVEFORMATEX
 * data structure that identifies the source format.
 *
 * @parm  LPWAVEFORMATEX | pwfxDst | Specifies a pointer to a WAVEFORMATEX
 * data structure that identifies the desired destination format after conversion.
 *
 * @parm  DWORD | dwFoo | Used to be conversion parameters. Not supported.
 *
 * @parm  DWORD | dwCallback | Not supported.
 *
 * @parm  DWORD | dwInstance | Not supported.
 *
 * @parm  DWORD | dwFlags | Specifies flags for opening the
 * conversion channel. None are used by anyone calling this old API.
 *
 * @rdesc Returns Zero if the function was successful. Otherwise it
 * returns an error number.
 *
 ***************************************************************************/

EXTERN_C LRESULT ACMAPI acmOpenConversion
(
    LPHACMSTREAM    phas,
    HACMDRIVER      had,
    LPWAVEFORMATEX  pwfxSrc,
    LPWAVEFORMATEX  pwfxDst,
    DWORD           dwFoo,
    DWORD           dwCallback,
    DWORD           dwInstance,
    DWORD           dwFlags
)
{
    //
    //  NOTE! dwFoo is NOT USED by quick recorder, so we don't
    //  pass it on... dwCallback and dwInstance are also not used.
    //
    return (acmStreamOpen(phas, had, pwfxSrc, pwfxDst, NULL, 0L, 0L, 0L));
}


/****************************************************************************
 * @doc INTERNAL ACM_API
 *
 * @api LRESULT | acmCloseConversion | Closes a conversion channel.
 *
 * @parm HACMSTREAM | has | Specifies the conversion channel to close.
 * If the function is successful, the handle is no longer valid after this call.
 *
 * @parm  DWORD | dwFlags | Specifies flags for closing the
 * conversion channel.
 *
 * @rdesc Returns Zero if the function was successful. Otherwise it
 * returns an error number.
 *
 ***************************************************************************/
EXTERN_C LRESULT ACMAPI acmCloseConversion
(
    HACMSTREAM  has,
    DWORD       dwFlags
)
{
    return (acmStreamClose(has, dwFlags));
}


/*****************************************************************************
 * @doc INTERNAL ACM_API_STRUCTURE
 *
 * @types OLD_ACMCONVERTHDR | This structure contains all the information
 * required about a buffer for conversion.
 *
 * @field DWORD | dwFlags | Specifies the status of the buffer.
 *
 * @field LPBYTE | pbSrc | Specifies a pointer to the data area.
 *
 * @field DWORD | dwSrcLength | Specifies the length in bytes of the buffer.
 *
 * @field DWORD | dwSrcLengthUsed | Specifies the amout of data (in bytes)
 * used for the conversion.
 *
 * @field LPBYTE | pbDst | Specifies a pointer to the data area.
 *
 * @field DWORD | dwDstLength | Specifies the length in bytes of the buffer.
 *
 * @field DWORD | dwDstLengthUsed | Specifies the amout of data (in bytes)
 * used for the conversion.
 *
 * @field DWORD | dwUser | Specifies user information.
 *
 * @field DWORD | dwUserReserved[2] | Reserved for future use.
 *
 * @field DWORD | dwDrvReserved[4] | Reserved for the driver.
 *
 *
 ****************************************************************************/


/****************************************************************************
 * @doc INTERNAL ACM_API
 *
 * @api LRESULT | acmConvert | This function tells the ACM to convert
 * the data in one buffer to the space in the other buffer.
 *
 * @parm HACMSTREAM | has | Specifies the open conversion channel
 * to be used for the conversion.
 *
 * @parm LPOLD_ACMCONVERTHDR | pConvHdr | Specifies the buffer information.
 *
 * @parm  DWORD | dwFlags | Specifies flags for opening the
 * conversion channel. (None are defined yet.)
 *
 * @rdesc Returns Zero if the function was successful. Otherwise
 * returns an error number.
 *
 *
 ***************************************************************************/
EXTERN_C LRESULT ACMAPI acmConvert
(
    HACMSTREAM          has,
    LPOLD_ACMCONVERTHDR pConvHdr,
    DWORD               dwFlags
)
{
    MMRESULT            mmr;
    ACMSTREAMHEADER     ash;

    _fmemset(&ash, 0, sizeof(ash));

    ash.cbStruct        = sizeof(ash);
////ash.fdwStatus       = pConvHdr->dwFlags;
    ash.pbSrc           = pConvHdr->pbSrc;
    ash.cbSrcLength     = pConvHdr->dwSrcLength;
////ash.cbSrcLengthUsed = pConvHdr->dwSrcLengthUsed;
    ash.pbDst           = pConvHdr->pbDst;
    ash.cbDstLength     = pConvHdr->dwDstLength;
////ash.cbDstLengthUsed = pConvHdr->dwDstLengthUsed;

    mmr = acmStreamPrepareHeader(has, &ash, 0L);
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

    mmr = acmStreamConvert(has, &ash, 0L);

    acmStreamUnprepareHeader(has, &ash, 0L);

    return (mmr);
}

#endif // #ifndef WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\acmthunk.h ===
//==========================================================================;
//
//  acmthunk.h
//
//  Copyright (c) 1991-1995 Microsoft Corporation
//
//  Description:
//      Definitions for thunking between 16-bit (WOW) and 32-bit (WOW)
//      ACMs.
//
//  History:
//
//==========================================================================;

//
//  Function ids for calling across the thunking layer (used by both sides)
//
enum {
   acmThunkDriverMessageId32 = 1,
   acmThunkDriverMessage32,
   acmThunkDriverGetNext32,
   acmThunkDriverGetInfo32,
   acmThunkDriverPriority32,
   acmThunkDriverLoad32,
   acmThunkDriverOpen32,
   acmThunkDriverClose32,
   acmThunkFindAndBoot32
};


//
//  Thunking support
//
//

#ifdef WIN4
//
//  The thunked function prototype
//
DWORD WINAPI acmMessage32(DWORD dwThunkId, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5);

//
//  Thunk message to our thunk window
//
#define WM_ACMMESSAGETHUNK  (WM_USER)
#endif



#ifdef WIN32

//
//  Some protos
//
PVOID FNLOCAL ptrFixMap16To32(const VOID * pv);
VOID  FNLOCAL ptrUnFix16(const VOID * pv);

#ifdef WIN4
//
//	--== Chicago specific ==--
//

//
//  Thunk helper routines in Chicago kernel
//
extern PVOID WINAPI MapSL(const VOID * pv);
extern PVOID WINAPI MapSLFix(const VOID * pv);
extern VOID  WINAPI UnMapSLFixArray(DWORD dwCnt, const VOID * lpSels[]);


#else	// WIN4 else
//
//	--== NT WOW specific ==--
//

#define GET_VDM_POINTER_NAME            "WOWGetVDMPointer"
#define GET_HANDLE_MAPPER16             "WOWHandle16"
#define GET_HANDLE_MAPPER32             "WOWHandle32"
#define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")

typedef LPVOID (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
#define WOW32ResolveMemory( p ) (LPVOID)(GetVdmPointer( (DWORD)(p), 0, TRUE ))

typedef HANDLE  (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD    (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);

#endif	// !WIN4

#endif	// WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
    #define wsprintfA           wsprintf
    #define MessageBoxA         MessageBox
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

#ifndef WIN32
#pragma warning(disable:4704)
#endif

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static char     ach[300];       // debug output (avoid stack overflow)
    int	            id;
#ifndef WIN32
    int             iExitCode;
#endif

    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
#ifndef WIN32
        iExitCode = 0;
        _asm
        {
	        mov	ah, 4Ch
	        mov	al, BYTE PTR iExitCode
	        int     21h
        }
#else
        FatalAppExit(0, TEXT("Good Bye"));
#endif // WIN16
		break;

	case IDRETRY:               // Break into the debugger.
#if DBG
		DebugBreak();
#endif
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#ifndef WIN32
#pragma warning(default:4704)
#endif

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1995 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef WIN32
#define DEBUG_MODULE_NAME       "MSACM32"   // key name and prefix for output
#else
#define DEBUG_MODULE_NAME       "MSACM"     // key name and prefix for output
#endif

#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//  #pragma message(REMIND("this is a reminder"))
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define DEBUG_QUOTE(x)      #x
#define DEBUG_QQUOTE(y)     DEBUG_QUOTE(y)
#define REMIND(sz)          __FILE__ "(" DEBUG_QQUOTE(__LINE__) ") : " sz

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef RDEBUG
#ifdef WIN32
    #define DebugErr(flags, sz)		DPF(0, sz)
    #define DebugErr1(flags, sz, a)	DPF(0, sz, a)
    #define DebugErr2(flags, sz, a, b)  DPF(0, sz, a, b)
#else
    #define DebugErr(flags, sz)         {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx);}
    #define DebugErr1(flags, sz, a)     {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx, a);}
    #define DebugErr2(flags, sz, a, b)  {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx, a, b);}
#endif
#else
    #define DebugErr(flags, sz)
    #define DebugErr1(flags, sz, a)
    #define DebugErr2(flags, sz, a, b)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\chooseri.h ===
// Copyright (c) 1994-1995 Microsoft Corporation
//
//  Context-sensitive help is only available for WINVER>=0x0400
//
#if WINVER>=0x0400
#define USECONTEXTHELP
#endif


/*
 * Format storage
 */
 
/*
 *  this pragma disables the warning issued by the Microsoft C compiler
 *  when using a zero size array as place holder when compiling for
 *  C++ or with -W4.
 *
 */
#ifdef _MSC_VER
#pragma warning(disable:4200)
#endif

/* Custom Format Name Body */
typedef struct tNameStore {
    unsigned short cbSize;          // SizeOf this structure
    TCHAR       achName[];          // The name
} NameStore, *PNameStore, FAR * LPNameStore;

#ifdef _MSC_VER
#pragma warning(default:4200)
#endif

#define NAMELEN(x) (((x)->cbSize-sizeof(NameStore))/sizeof(TCHAR))
#define STRING_LEN 128

/* Custom Format Body */
typedef struct tCustomFormatStore {
    DWORD           cbSize;         // SizeOf this structure
    NameStore       ns;             // Custom name
    
//  WAVEFORMATEX    wfx;            // Custom format (concatenated)
//          or
//  WAVEFILTER      wf;             // Custom filter
    
} CustomFormatStore, *PCustomFormatStore, FAR * LPCustomFormatStore;

//
//  This structure is just CustomFormatStore without the NameStore.  It is
//  used only by GetCustomFormat() and SetCustomFormat(), and is used to
//  separate the name from the Format or Filter structure so that it can
//  be stored in a separate key in msacm.ini.  That way we don't have to
//  worry about whether the name is unicode or ansi...
//
typedef struct tCustomFormatStoreNoName {
    DWORD           cbSize;         // SizeOf this structure
//  WAVEFORMATEX    wfx;            // Custom format (concatenated)
//          or
//  WAVEFILTER      wf;             // Custom filter
} CustomFormatStoreNoName, *PCustomFormatStoreNoName, FAR * LPCustomFormatStoreNoName;

/* Custom Format Header - this is what matters */
typedef struct tCustomFormat {
    struct tCustomFormat FAR * pcfNext;
    struct tCustomFormat FAR * pcfPrev;
    LPNameStore     pns;            // Pointer to the description
    union {
        LPBYTE          pbody;          // Pointer to the stored format
        LPWAVEFORMATEX  pwfx;
        LPWAVEFILTER    pwfltr;
    };
} CustomFormat, *PCustomFormat, FAR * LPCustomFormat;

/* Extended Custom Format Header for body offset */
typedef struct tCustomFormatEx {
    struct tCustomFormat FAR * pcfNext;
    struct tCustomFormat FAR * pcfPrev;
    LPNameStore     pns;            // Pointer to the description
    union {
        LPBYTE          pbody;          // Pointer to the stored format
        LPWAVEFORMATEX  pwfx;
        LPWAVEFILTER    pwfltr;
    };
    CustomFormatStore cfs;          // The actual data
} CustomFormatEx, *PCustomFormatEx, FAR * LPCustomFormatEx;

/*
 * Custom format pool structures
 */

/* A description of the format pool */
typedef struct tCustomFormatPool {
    LPCustomFormat  pcfHead;        // Head
    LPCustomFormat  pcfTail;        // Tail
} CustomFormatPool, *PCustomFormatPool, FAR *LPCustomFormatPool;

typedef UINT (WINAPI *CHOOSEHOOKPROC)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

/*****************************************************************************
 * @doc INTERNAL
 * 
 * @types InstData | This stores global variables for a filter chooser
 * instance.  GetProp/SetProp will be used to assign this to a dialog.
 *
 * @field UINT | uType | Specifies the type of the instance data
 *
 * @field LPCustomFormat | pcf | Pointer the current custom choice
 *
 * @field HWND | hwnd | Window handle of the dialog.
 *
 * @field HWND | hFormatTags | Window handle to the FormatTags dropdown listbox
 *     
 * @field HWND | hFormats | Window handle to the Formats dropdown listbox
 *     
 * @field UINT | uiFormatTab | Tabstop for the Formats dropdown listbox
 *
 * @field HWND | hCustomFormats | Window handle to the Custom dropdown listbox
 *
 * @field HWND | hOk | Window handle to the OK button
 *
 * @field HWND | hCancel | Window handle to the Cancel button
 *
 * @field HWND | hHelp | Window handle to the Help button
 *
 * @field HWND | hSetName | Window handle to the Set Name button
 *
 * @field HWND | hDelName | Window handle to the Delete Name button
 *
 * @field HWND * | pahNotify | The array of windows that will be notified
 * when custom changes are made.
 *
 * @field HANDLE | hFileMapping | Handle to a file mapping if used (Win32 only)
 *
 * @field PNameStore | pnsTemp | Temporary string storage
 *
 * @field PNameStore | pnsStrOut | Temporary string storage
 *
 * @field CustomFormatPool | cfp | Global CustomFormat Pool
 *
 * @field UINT | uUpdateMsg | Private message to communicate CF changes.
 *
 * @field LPACMFORMATCHOOSE | pcfmtc | Initialization structure
 * @field LPACMFILTERCHOOSE | pcfltrc | Initialization structure
 *
 * @field PACMGARB | pag | Pointer to the ACMGARB structure associated
 * with this instance of the ACM.
 *
 ****************************************************************************/

typedef struct tInstData {
    UINT            uType;
    MMRESULT        mmrSubFailure;   // Failure in an acm subfunction
    LPCustomFormat  pcf;        // Current custom format
    HWND            hwnd;
    HWND            hFormatTags;
    int             iPrevFormatTagsSel; // previous selection
    
    HWND            hFormats;
    UINT            uiFormatTab;
    
    HWND            hCustomFormats;

    HWND            hOk;
    HWND            hCancel;
    HWND            hHelp;

    HWND            hSetName;
    HWND            hDelName;

    /* Instance data */
    HWND *          pahNotify;  // The array of HWND's to notify.
    
#ifdef WIN32
    HANDLE          hFileMapping;
#endif
    
    PNameStore      pnsTemp;    // Walk all over this.
    PNameStore      pnsStrOut;  // Another temporary NameStore
    CustomFormatPool cfp;       // Global CustomFormat Pool
    UINT            uUpdateMsg; // Private WM_WININICHANGE
    UINT            uHelpMsg;   // Help button to parent
#ifdef USECONTEXTHELP
    UINT            uHelpContextMenu;   // Help context menu to parent
    UINT            uHelpContextHelp;   // Help context help to parent
#endif // USECONTEXTHELP
    HKEY            hkeyFormats;    // HKEY corresponding to key name.
    CHOOSEHOOKPROC  pfnHook;        // Hook proc
    BOOL            fEnableHook;    // Hook enabled.
    LPBYTE          lpbSel;         // return data
    DWORD           dwTag;          // Generic 'Tag'

#if defined(WIN32) && !defined(UNICODE)
    LPWSTR          pszName;        // Choice name buffer
#else
    LPTSTR          pszName;        // Choice name buffer
#endif
    DWORD           cchName;         // Choice buffer length
    BOOL            fTagFilter;     // Filter for an explicit 'Tag'.

    UINT            cdwTags;          // count of tags
    DWORD *         pdwTags;        // pointer to array of tags
    UINT            cbwfxEnum;
    UINT            cbwfltrEnum;
    LPACMFORMATDETAILS  pafdSimple;

    union {
        LPACMFORMATCHOOSE pfmtc;    // Initialization structure
        LPACMFILTERCHOOSE pafltrc;  // Initialization structure
    };                              // Chooser Specific

    PACMGARB	    pag;
    
} InstData, *PInstData, FAR * LPInstData;

enum { FILTER_CHOOSE, FORMAT_CHOOSE };

#define MAX_HWND_NOTIFY             100
#define MAX_CUSTOM_FORMATS          100
#define MAX_FORMAT_KEY               64

/*
 * Save instance data in a property to give others access to the DWL_USER
 */
#ifdef WIN32
    #define SetInstData(hwnd, p) SetProp(hwnd,gszInstProp,(HANDLE)(p))
    #define GetInstData(hwnd)    (PInstData)(LPVOID)GetProp(hwnd, gszInstProp)
    #define RemoveInstData(hwnd) RemoveProp(hwnd,gszInstProp)
#else
    #define SetInstData(hwnd, p) SetProp(hwnd,gszInstProp,(HANDLE)(p))
    #define GetInstData(hwnd)    (PInstData)GetProp(hwnd, gszInstProp)
    #define RemoveInstData(hwnd) RemoveProp(hwnd,gszInstProp)
#endif


/*
 * For passing near pointers in lparams
 */
#ifdef WIN32
    #define PTR2LPARAM(x)       (LPARAM)(VOID *)(x)
    #define LPARAM2PTR(x)       (VOID *)(x)    
#else
    #define PTR2LPARAM(x)       MAKELPARAM(x,0)
    #define LPARAM2PTR(x)       (VOID *)LOWORD(x)
#endif


//
//  This routine deleted a NameStore object allocated by NewNameStore().
//
__inline void
DeleteNameStore ( PNameStore pns )
{
    LocalFree((HLOCAL)pns);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\chooser.c ===
//==========================================================================;
//
//  chooser.c
//
//  (C) Copyright (c) 1992-1999 Microsoft Corporation
//
//  Description:
//      This is the sound format chooser dialog.
//
//  History:
//      05/13/93 JYG     Created
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#ifdef WIN32
#include <wchar.h>
#else
#include <ctype.h>
#endif
#include <stdlib.h>
#include <stdarg.h>
#include <winuserp.h>

#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "msacmdlg.h"
#include "uchelp.h"
#include "chooseri.h"
#include "profile.h"
#include "debug.h"


enum { ChooseCancel = 0,
       ChooseOk,
       ChooseSubFailure,
       ChooseNoMem };
//
//
//
#if defined(WIN32) && defined(UNICODE)
#define istspace iswspace
#else
#define istspace isspace
#endif

//
//  to quickly hack around overlapping and unimaginative defines..
//
#define IDD_BTN_HELP        IDD_ACMFORMATCHOOSE_BTN_HELP
#define IDD_CMB_CUSTOM      IDD_ACMFORMATCHOOSE_CMB_CUSTOM
#define IDD_CMB_FORMATTAG   IDD_ACMFORMATCHOOSE_CMB_FORMATTAG
#define IDD_CMB_FORMAT      IDD_ACMFORMATCHOOSE_CMB_FORMAT
#define IDD_BTN_SETNAME     IDD_ACMFORMATCHOOSE_BTN_SETNAME
#define IDD_BTN_DELNAME     IDD_ACMFORMATCHOOSE_BTN_DELNAME



/* Property string */
TCHAR BCODE gszInstProp[]        = TEXT("MSACM Chooser Prop");

/* Chooser notify message */
TCHAR BCODE gszFilterRegMsg[]    = TEXT("MSACM Filter Notify");
TCHAR BCODE gszFormatRegMsg[]    = TEXT("MSACM Format Notify");

/* Registry key and value names */
TCHAR BCODE gszKeyWaveFormats[]	= TEXT("WaveFormats");
TCHAR BCODE gszKeyWaveFilters[]	= TEXT("WaveFilters");
TCHAR BCODE gszValueDefaultFormat[] = TEXT("DefaultFormat");
TCHAR BCODE gszValueSystemFormats[] = TEXT("SystemFormats");

#if 0
/* Help files and keys */
#if (WINVER >= 0x0400)
TCHAR BCODE gszFormatHelp[]      = TEXT("CHOOSER.HLP");
TCHAR BCODE gszFilterHelp[]      = TEXT("FILTER.HLP");
#else
TCHAR BCODE gszFormatHelp[]      = TEXT("CHOO_WIN.HLP");
TCHAR BCODE gszFilterHelp[]      = TEXT("FIL_WIN.HLP");
#endif
#endif

/* Arbitrary maximum on number of windows to notify. */
#ifndef WIN32
static HWND ahNotify[MAX_HWND_NOTIFY];
#else
TCHAR BCODE gszChooserFileMapping[] = TEXT("MSACM Chooser File Mapping");
#endif

/*      -       -       -       -       -       -       -       -       -   */
/*
 * Function Declarations
 */
INT_PTR FNWCALLBACK NewSndDlgProc(HWND hwnd,
				  unsigned msg,
				  WPARAM wParam,
				  LPARAM lParam);

INT_PTR FNWCALLBACK NewNameDlgProc(HWND hwnd,
				   unsigned msg,
				   WPARAM wParam,
				   LPARAM lParam);

void FNLOCAL InitCustomFormats(PInstData pInst);

LPCustomFormat FNLOCAL GetCustomFormat(PInstData pInst,
                                       LPCTSTR lpszName);

LPCustomFormat FNLOCAL NewCustomFormat(PInstData pInst,
                                       PNameStore pnsName,
                                       LPBYTE lpBuffer);

BOOL FNLOCAL AddCustomFormat(PInstData pInst,
                             LPCustomFormat pcf);

BOOL FNLOCAL RemoveCustomFormat(PInstData pInst,
                                LPCustomFormat pcf);

void FNLOCAL DeleteCustomFormat(LPCustomFormat pcf);
void FNLOCAL EmptyCustomFormats(PInstData pInst);

void FNGLOBAL AppProfileWriteBytes(HKEY hkeyFormats,
                                   LPCTSTR pszKey,
                                   LPBYTE pbStruct,
                                   UINT cbStruct);

BOOL FNGLOBAL AppProfileReadBytes(HKEY hkey,
                                  LPCTSTR pszKey,
                                  LPBYTE pbStruct,
                                  UINT cbStruct,
                                  BOOL fChecksum);

void FNLOCAL SetName(PInstData pInst);
void FNLOCAL DelName(PInstData pInst);

PNameStore FNLOCAL NewNameStore(UINT cchLen);

LRESULT FNLOCAL InitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
BOOL FNWCALLBACK FormatTagsCallback(HACMDRIVERID hadid,
                                      LPACMFORMATDETAILS paftd,
                                      DWORD_PTR dwInstance,
                                      DWORD fdwSupport);

BOOL FNWCALLBACK FormatTagsCallbackSimple
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);


BOOL FNWCALLBACK FormatsCallback(HACMDRIVERID hadid,
                                   LPACMFORMATDETAILS pafd,
                                   DWORD_PTR dwInstance,
                                   DWORD fdwSupport);

BOOL FNWCALLBACK FilterTagsCallback(HACMDRIVERID hadid,
                                      LPACMFILTERTAGDETAILS paftd,
                                      DWORD_PTR dwInstance,
                                      DWORD fdwSupport);

BOOL FNWCALLBACK FiltersCallback(HACMDRIVERID hadid,
                                   LPACMFILTERDETAILS pafd,
                                   DWORD_PTR dwInstance,
                                   DWORD fdwSupport);


void FNLOCAL RefreshCustomFormats(PInstData pInst,BOOL fCheckEnum);
MMRESULT FNLOCAL RefreshFormatTags(PInstData pInst);
void FNLOCAL RefreshFormats(PInstData pInst);
void FNLOCAL EmptyFormats(PInstData pInst);

static int FAR cdecl ErrorResBox(HWND hwnd,
				 HINSTANCE hInst,
				 WORD flags,
				 WORD idAppName,
				 WORD idErrorStr, ...);

PInstData FNLOCAL NewInstance(LPBYTE pbChoose,UINT uType);

LPBYTE FNLOCAL CopyStruct(LPBYTE lpDest,
                       LPBYTE lpByte, UINT uType);

void FNLOCAL UpdateCustomFormats(PInstData pInst);
void FNLOCAL SelectCustomFormat(PInstData pInst);
void FNLOCAL SelectFormatTag(PInstData pInst);
void FNLOCAL SelectFormat(PInstData pInst);
void FNLOCAL FindSelCustomFormat(PInstData pInst);

BOOL FNLOCAL FindFormat(PInstData pInst,LPWAVEFORMATEX lpwfx,BOOL fExact);
BOOL FNLOCAL FindFilter(PInstData pInst,LPWAVEFILTER lpwf,BOOL fExact);

void FNLOCAL MashNameWithRate(PInstData pInst,
                              PNameStore pnsDest,
                              PNameStore pnsSrc,
                              LPWAVEFORMATEX pwfx);

void FNLOCAL RegisterUpdateNotify(PInstData pInst);
void FNLOCAL UnRegisterUpdateNotify(PInstData pInst);

BOOL FNLOCAL FindInitCustomFormat(PInstData pInst);
void FNLOCAL TagUnavailable(PInstData pInst);
/*      -       -       -       -       -       -       -       -       -   */
/* Custom Format Stuff */

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | IsSystemName | Determines whether the name is
 *	system name.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPNameStore | pns | Pointer to name store
 *
 *  @parm DWORD | dwFlags | Flags
 *
 *  @flag ISSYSTEMNAMEF_DEFAULT | See if this name matches the system
 *	default name.
 *
 *  @rdesc Returns TRUE if and only if the name is a system name.
 *
 *  @comm System format names are names that are defined by the system.
 *	We should not allow users to remove these names.  The names of the
 *	system formats are stored as a string in the registry
 *	under the value named SystemFormats.  Currently, we don't have
 *	system filter names, only system format names.
 *
 ****************************************************************************/
#define ISSYSTEMNAMEF_DEFAULT 0x00000001L
BOOL FNLOCAL
IsSystemName ( PInstData pInst,
	     LPNameStore pns,
	     DWORD dwFlags)
{
    HKEY hkey;
    DWORD dwType;
    DWORD cbData;
    LPTSTR lpstrFormatNames;
    LPCTSTR lpstrValueName;
    BOOL fIsSystemName;
    LONG lError;

    //
    //	This stuff only defined for formats, not filters
    //
    if (pInst->uType != FORMAT_CHOOSE)
	return FALSE;

    //
    //
    //
    hkey = IRegOpenKeyAudio(NULL);
    if (NULL == hkey) {
	return FALSE;
    }

    //
    //
    //
    if (ISSYSTEMNAMEF_DEFAULT && dwFlags) {
	lpstrValueName = gszValueDefaultFormat;
    } else {
	lpstrValueName = gszValueSystemFormats;
    }

    //
    //	Determine size of buffer required to hold the string of
    //	system format names.
    //
    fIsSystemName = FALSE;
    lError = XRegQueryValueEx( hkey,
			      (LPTSTR)lpstrValueName,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData );

    if ( (ERROR_SUCCESS == lError) && (REG_SZ == dwType) )
    {
	//
	//  Allocate buffer to receive string of system format names plus an
	//  extra terminator.
	//
	cbData += sizeof(TCHAR);
	lpstrFormatNames = GlobalAllocPtr(GHND, cbData);
	if (NULL != lpstrFormatNames)
	{
	    lError = XRegQueryValueEx( hkey,
				      (LPTSTR)lpstrValueName,
				      NULL,
				      &dwType,
				      (LPBYTE)lpstrFormatNames,
				      &cbData );
	    if ( (ERROR_SUCCESS == lError) && (REG_SZ == dwType) )
	    {
		LPTSTR psz;

		//
		//  The string contains the system format names delimited
		//  by commas.  We walk psz through the string looking for
		//  the comma delimiter and replace the delimiter with
		//  a NULL terminator.  Then add an extra terminator at
		//  the end.  This makes the subsequent processing easier.
		//
		psz = lpstrFormatNames;
		while (*psz != TEXT('\0')) {
		    if (*psz == TEXT(',')) *psz = TEXT('\0');
		    psz++;
		}
		*(++psz) = TEXT('\0');
		

		psz = lpstrFormatNames;
		while (*psz != TEXT('\0'))
		{
		    //
		    //	See if it compares to the selected name.
		    //
		    if (!lstrcmp(psz, pns->achName)) {
			fIsSystemName = TRUE;
			break;
		    }

		    //
		    //	Bump psz to next name string
		    //
		    while (*psz++ != TEXT('\0'));
		}
	    }

	    GlobalFreePtr(lpstrFormatNames);
	}
    }

    XRegCloseKey(hkey);

	
    return fIsSystemName;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api VOID FNLOCAL | SetSystemDefaultName | Sets the user's default name
 *	to the system defined default name (ie, the default default).
 *
 *  @parm PInstData | pInst |
 *
 *  @rdesc void
 *
 *  @comm The default format name is selected via the control panel.  The
 *	selected default format name is stored as a string in the registry
 *	under the value named DefaultFormat.  Currently, we don't have
 *	default filter names, only default format names.  If the user deletes
 *	the format name that is currently selected as the default, then we
 *	call this function to set the default to the system-defined default.
 *
 ****************************************************************************/
VOID FNLOCAL
SetSystemDefaultName ( PInstData pInst )
{
    HKEY hkey;
    DWORD dwType;
    DWORD cbData;
    LPTSTR lpstrSystemFormats;
    BOOL fIsSystemName;
    LONG lError;

    //
    //	This stuff only defined for formats, not filters
    //
    if (pInst->uType != FORMAT_CHOOSE)
	return;

    //
    //
    //
    hkey = IRegOpenKeyAudio(NULL);
    if (NULL == hkey) {
	return;
    }

    //
    //	Determine size of buffer required to hold the string of
    //	system format names.
    //
    fIsSystemName = FALSE;
    lError = XRegQueryValueEx( hkey,
			      (LPTSTR)gszValueSystemFormats,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData );

    if ( (ERROR_SUCCESS == lError) && (REG_SZ == dwType) )
    {
	//
	//  Allocate buffer to receive string of system format names plus an
	//  extra terminator.
	//
	cbData += sizeof(TCHAR);
	lpstrSystemFormats = GlobalAllocPtr(GHND, cbData);
	if (NULL != lpstrSystemFormats)
	{
	    lError = XRegQueryValueEx( hkey,
				      (LPTSTR)gszValueSystemFormats,
				      NULL,
				      &dwType,
				      (LPBYTE)lpstrSystemFormats,
				      &cbData );
	    if ( (ERROR_SUCCESS == lError) && (REG_SZ == dwType) )
	    {
		LPTSTR psz;

		//
		//  The string contains the system format names delimited
		//  by commas.  We walk psz through the string looking for
		//  the comma delimiter and replace the delimiter with
		//  a NULL terminator.  Then add an extra terminator at
		//  the end.  This makes the subsequent processing easier.
		//
		psz = lpstrSystemFormats;
		while (*psz != TEXT('\0')) {
		    if (*psz == TEXT(',')) *psz = TEXT('\0');
		    psz++;
		}
		*(++psz) = TEXT('\0');
		

		psz = lpstrSystemFormats;

        IRegWriteString( hkey, gszValueDefaultFormat, psz );
	    }
	
	    GlobalFreePtr(lpstrSystemFormats);
	}
    }

    XRegCloseKey(hkey);

	
    return;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | IsCustomName | Walks the list to detect name clashes.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pns |
 *
 ****************************************************************************/
BOOL FNLOCAL
IsCustomName ( PInstData pInst,
               PNameStore pns )
{
    BOOL            fHit = FALSE;
    LPCustomFormat  pcf;

    /* search the list for hits */
    pcf = pInst->cfp.pcfHead;
    while (pcf != NULL && !fHit)
    {
        fHit = (lstrcmp(pns->achName,pcf->pns->achName) == 0);
        pcf = pcf->pcfNext;
    }
    return (fHit);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | IsValidName | Checks for particular names that we
 *	    do not want to allow.  In particular, "[untitled]".
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pns |
 *
 ****************************************************************************/
BOOL FNLOCAL
IsValidName ( PInstData pInst,
	      PNameStore pns )
{
    TCHAR   ach[STRING_LEN];

    LoadString(pInst->pag->hinst, IDS_TXT_UNTITLED, ach, STRING_LEN);

    return (0 != lstrcmp(pns->achName, ach));

}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | RemoveOutsideWhitespace | Removes leading and
 *		trailing whitespace
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pns |
 *
 *  @rdesc  Returns FALSE if blank.
 *
 ****************************************************************************/
BOOL FNLOCAL
RemoveOutsideWhitespace ( PInstData pInst,
			  PNameStore pns )
{
    LPTSTR      lpchName;


    /* eat leading white space */

    lpchName = pns->achName;
    while (*lpchName && istspace(*lpchName))
        lpchName = CharNext(lpchName);

    if (!*lpchName)
        return (FALSE);

    if (lpchName != pns->achName)
        lstrcpy (pns->achName, lpchName);


    /* eat trailing white space */

    //	Walk lpchName to last char in string
    lpchName = pns->achName;
    while (*lpchName) lpchName = CharNext(lpchName);
    lpchName = CharPrev(pns->achName, lpchName);
    //	Now back up, replacing each white space char with a NULL char, til
    //	we back up to the first non-white space char.
    while (istspace(*lpchName))
    {
	*lpchName = 0;
	lpchName = CharPrev(pns->achName, lpchName);
    }

    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api LPCustomFormat FNLOCAL | NewCustomFormat | Given a Name and a Format,
 *  create a CustomFormat that can be saved in a single data block
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pnsName |
 *
 *  @parm LPBYTE | lpBuffer |
 *
 ****************************************************************************/
LPCustomFormat FNLOCAL
NewCustomFormat ( PInstData     pInst,
                  PNameStore    pnsName,
                  LPBYTE        lpBuffer )
{
    DWORD               cbSize;
    DWORD               cbBody;
    UINT                cbName;
    LPCustomFormatEx    pcf;

    if (!pnsName || !lpBuffer)
        return (NULL);

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
        {
            LPWAVEFORMATEX pwfxFormat = (LPWAVEFORMATEX)lpBuffer;

            // sizeof WAVEFORMATEX
            cbBody = SIZEOF_WAVEFORMATEX(pwfxFormat);
            break;
        }
        case FILTER_CHOOSE:
        {
            LPWAVEFILTER pwfltr = (LPWAVEFILTER)lpBuffer;

            // sizeof WAVEFFILTER
            cbBody = pwfltr->cbStruct;
            break;
        }
    }

    // sizeof NameStore
    cbName = (lstrlen(pnsName->achName)+1)*sizeof(TCHAR) + sizeof(NameStore);
    // sizeof CustomFormatStore = sizeof(cbSize) + NAME + BODY
    cbSize = sizeof(DWORD) + cbName + cbBody;

    pcf = (LPCustomFormatEx)GlobalAllocPtr(GHND,cbSize+sizeof(CustomFormat));

    if (pcf)
    {
        /* point the CustomFormat header to the right places */
        pcf->cfs.cbSize = cbSize;
        pcf->pns = &pcf->cfs.ns;
        pcf->pbody = ((LPBYTE)pcf->pns + cbName);

        /* copy in the name and format */
        _fmemcpy((LPBYTE)pcf->pns, (LPBYTE)pnsName, cbName);
        pcf->pns->cbSize = (unsigned short)cbName;
        _fmemcpy(pcf->pbody, lpBuffer, (UINT)cbBody);

        pcf->pcfNext = NULL;
        pcf->pcfPrev = NULL;
    }
    return ((LPCustomFormat)pcf);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | DeleteCustomFormat
 *
 *  @parm LPCustomFormat | pcf |
 *
 ****************************************************************************/
void FNLOCAL
DeleteCustomFormat ( LPCustomFormat pcf )
{
    GlobalFreePtr(pcf);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | InitCustomFormats | Load all the custom formats into
 *  instance dependant data
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @comm The custom formats are found by enumerating all the value names
 *	under the registry key
 *
 ****************************************************************************/
void FNLOCAL
InitCustomFormats ( PInstData pInst )
{
    LPCustomFormat  pcf;
    DWORD	    dwIndex;
    TCHAR	    szName[STRING_LEN];
    DWORD	    cchName;
    LONG	    lr;


    //
    //  If the registry key is not open, we can't read anything...
    //
    if( NULL == pInst->hkeyFormats )
    {
        DPF(1,"InitCustomFormats: can't read registry, hkey==NULL.");
        return;
    }


    //
    //	Format names correspond to the value names in the registry.
    //	Enumerate all value names to find all the format names.
    //
    dwIndex = 0;
    cchName = STRING_LEN;
    while( ERROR_NO_MORE_ITEMS != (lr = XRegEnumValue( pInst->hkeyFormats,
	                                              dwIndex,
	                                              szName,
	                                              &cchName,
	                                              NULL, NULL, NULL, NULL) ) )
    {
	if (ERROR_SUCCESS == lr)
	{
	    pcf = GetCustomFormat(pInst, szName);
	    if (pcf)
	    {
		AddCustomFormat(pInst, pcf);
	    }
	}

	dwIndex++;
	cchName = STRING_LEN;
    }

    return;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | AddCustomFormat | Add a custom format to the format
 *  pool.  This must be a shared function that maintains a shared memory to
 *  prevent actual munging of the WIN.INI section and coordination.  Adding
 *  also causes updates to open instances.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPCustomFormat | pcf |
 *
 ****************************************************************************/
BOOL FNLOCAL
AddCustomFormat ( PInstData pInst,
                  LPCustomFormat pcf )
{
    if (pInst->cfp.pcfHead == NULL)
    {
        /* add it to the head/tail */
        pInst->cfp.pcfHead = pcf;
        pInst->cfp.pcfTail = pcf;
        pcf->pcfNext = NULL;
        pcf->pcfPrev = NULL;
    }
    else
    {
        /* add it to the tail */
        pInst->cfp.pcfTail->pcfNext = pcf;
        pcf->pcfPrev = pInst->cfp.pcfTail;
        pInst->cfp.pcfTail = pcf;
        pcf->pcfNext = NULL;
    }

    return (TRUE);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | RemoveCustomFormat | Remove a custom format element
 *  from the pool
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPCustomFormat | pcf |
 *
 ****************************************************************************/
BOOL FNLOCAL
RemoveCustomFormat ( PInstData pInst,
                     LPCustomFormat pcf )
{
    if (pInst->cfp.pcfHead == pcf)
    {
        /* we are the head */
        pInst->cfp.pcfHead = pcf->pcfNext;
    }
    if (pInst->cfp.pcfTail == pcf)
    {
        /* we are the tail */
        pInst->cfp.pcfTail = pcf->pcfPrev;
    }

    /* Unlink */
    if (pcf->pcfPrev)
        pcf->pcfPrev->pcfNext = pcf->pcfNext;
    if (pcf->pcfNext)
        pcf->pcfNext->pcfPrev = pcf->pcfPrev;

    //
    //	If we are deleting the user default name, then we should
    //	set the system-defined default name.
    //
    if (IsSystemName(pInst, pcf->pns, ISSYSTEMNAMEF_DEFAULT)) {
	SetSystemDefaultName(pInst);
    }

    //
    //	Remove name from registry
    //
    XRegDeleteValue(pInst->hkeyFormats, pcf->pns->achName);

    //
    //
    //
    DeleteCustomFormat(pcf);
    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api LPCustomFormat FNLOCAL | GetCustomFormat | Grab from the registry the
 *  binary data associated with the custom name.  Return a structure that
 *  points to right offsets in the chunk.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPCTSTR | lpstrName | The custom format name.
 *
 ****************************************************************************/
LPCustomFormat FNLOCAL
GetCustomFormat ( PInstData pInst,
                  LPCTSTR lpstrName )   // The custom format name
{
    LPCustomFormatEx            pcf;
    LPCustomFormatStore         pcfs;
    DWORD                       cbSize;
    LPCustomFormatStoreNoName   pnn;
    PNameStore                  pns;
    UINT                        cchName;
    DWORD			dwValueType;
    LPTSTR                      psz;


    //
    //  We assume that we won't be called if we can't access the registry.
    //
    ASSERT( NULL != pInst->hkeyFormats );


    //
    //  First, let's store the name of the Format or Filter.
    //
    cchName = lstrlen( lpstrName );
    pns     = NewNameStore( cchName+1 );
    if( NULL == pns )
        return NULL;

    psz     = (LPTSTR)( ((LPBYTE)pns) + sizeof(NameStore) );
    lstrcpy(psz, lpstrName);
    pns->cbSize = (unsigned short)( (cchName+1) * sizeof(TCHAR) +
                                        sizeof(NameStore) );


    //
    //  Now find out the size of the CustomFormatStoreNoName.  This would be
    //	the sizeof(CustomFormatStoreNoName) + the size of the data in
    //	the registry.
    //
    if ( (ERROR_SUCCESS != XRegQueryValueEx( pInst->hkeyFormats,
					    psz,
					    NULL,
					    &dwValueType,
					    NULL,
					    &cbSize )) ||
	 (REG_BINARY != dwValueType) )
    {
        DeleteNameStore( pns );
        return (NULL);
    }
    cbSize += sizeof(CustomFormatStoreNoName);


    //
    //  Allocate the CustomFormat structure (the one we return).
    //
    pcf = (LPCustomFormatEx)GlobalAllocPtr( GHND,
                        cbSize + pns->cbSize + sizeof(CustomFormat) );
    if (!pcf)
    {
        DeleteNameStore( pns );
        return (NULL);
    }
    pcfs = &pcf->cfs;


    //
    //  Copy the custom name into the structure.
    //
    pcf->pns = &pcfs->ns;
    _fmemcpy( (LPBYTE)pcf->pns, (LPBYTE)pns, pns->cbSize );
    DeleteNameStore( pns );


    //
    //  Now read in the full CustomFormatStoreNoName structure.  We must
    //  allocate cbSize bytes for it, as read in previously.
    //
    pnn = (LPCustomFormatStoreNoName)GlobalAllocPtr( GHND, cbSize );
    if( NULL == pnn )
    {
        GlobalFreePtr( pcf );
        return NULL;
    }
    pnn->cbSize = cbSize;
    cbSize -= sizeof(CustomFormatStoreNoName);
    if (ERROR_SUCCESS != XRegQueryValueEx( pInst->hkeyFormats,
					  pcf->pns->achName,
					  NULL,
					  &dwValueType,
					  ((LPBYTE)&pnn->cbSize) + sizeof(pnn->cbSize),
					  &cbSize))
    {
        GlobalFreePtr( pnn );
        GlobalFreePtr(pcf);
        return (NULL);
    }


    //
    //  Now copy the format data into the CustomFormatStore of pcf.
    //
    pcfs->cbSize    = pnn->cbSize + pcfs->ns.cbSize;
    pcf->pbody      = ((LPBYTE)&pcfs->ns) + pcfs->ns.cbSize;
    _fmemcpy( (LPBYTE)pcf->pbody,
              ((LPBYTE)pnn) + sizeof(pnn->cbSize),
              (int)pnn->cbSize - sizeof(pnn->cbSize) );
    GlobalFreePtr( pnn );

    return ((LPCustomFormat)pcf);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | SetCustomFormat | Write a custom format to the registry
 *
 *  @parm   HKEY | hkey | handle to registry key in which to write
 *
 *  @parm   LPCustomFormat | pcf | ptr to CustomFormat
 *
 *  @rdesc  Returns TRUE if and only if successful
 *
 ****************************************************************************/
BOOL FNLOCAL
SetCustomFormat ( HKEY hkey,
                  LPCustomFormat pcf )
{
    LPCustomFormatEx	pcfx = (LPCustomFormatEx)pcf;
    LONG		lr;


    //
    //  We assume that we won't be called if we can't access the registry.
    //
    ASSERT( NULL != hkey );

    //
    //
    //
    lr = XRegSetValueEx( hkey,
			pcfx->pns->achName,
			0L,
			REG_BINARY,
			pcfx->pbody,
			pcfx->cfs.cbSize );

    return (ERROR_SUCCESS == lr);
}


/*  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api PInstData | NewInstance |
 *
 *  @parm LPBYTE | pbChoose |
 *
 *  @parm UINT | uType |
 *
 ****************************************************************************/
PInstData FNLOCAL
NewInstance(LPBYTE pbChoose, UINT uType)
{
    PInstData   pInst;
    PACMGARB	pag;

    pag = pagFind();
    if (NULL == pag)
    {
	return (NULL);
    }

    pInst = (PInstData)LocalAlloc(LPTR,sizeof(InstData));
    if (!pInst)
        return (NULL);

    pInst->pag = pag;

    pInst->pnsTemp = NewNameStore(STRING_LEN);
    if (!pInst->pnsTemp)
        goto exitfail;

    pInst->pnsStrOut = NewNameStore(STRING_LEN);
    if (!pInst->pnsStrOut)
    {
        DeleteNameStore(pInst->pnsTemp);
        goto exitfail;
    }

    switch (uType)
    {
        case FORMAT_CHOOSE:
            pInst->pfmtc = (LPACMFORMATCHOOSE)pbChoose;
            pInst->uUpdateMsg = RegisterWindowMessage(gszFormatRegMsg);
            pInst->hkeyFormats = IRegOpenKeyAudio( gszKeyWaveFormats );
            pInst->fEnableHook = (pInst->pfmtc->fdwStyle &
                                  ACMFORMATCHOOSE_STYLEF_ENABLEHOOK) != 0;
            pInst->pfnHook = pInst->pfmtc->pfnHook;
            pInst->pszName = pInst->pfmtc->pszName;
            pInst->cchName = pInst->pfmtc->cchName;

            break;
        case FILTER_CHOOSE:
            pInst->pafltrc = (LPACMFILTERCHOOSE)pbChoose;
            pInst->uUpdateMsg = RegisterWindowMessage(gszFilterRegMsg);
            pInst->hkeyFormats = IRegOpenKeyAudio( gszKeyWaveFilters );
            pInst->fEnableHook = (pInst->pafltrc->fdwStyle &
                                  ACMFILTERCHOOSE_STYLEF_ENABLEHOOK) != 0;
            pInst->pfnHook = pInst->pafltrc->pfnHook;
            pInst->pszName = pInst->pafltrc->pszName;
            pInst->cchName = pInst->pafltrc->cchName;

            break;
    }

    pInst->mmrSubFailure = MMSYSERR_NOERROR;
    pInst->uType = uType;
    pInst->cfp.pcfHead = NULL;
    pInst->cfp.pcfTail = NULL;
    pInst->pcf = NULL;
    return (pInst);

exitfail:
    LocalFree((HLOCAL)pInst);
    return (NULL);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | DeleteInstance |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
DeleteInstance ( PInstData pInst )
{
    EmptyCustomFormats(pInst);
    DeleteNameStore(pInst->pnsTemp);
    DeleteNameStore(pInst->pnsStrOut);
    IRegCloseKey( pInst->hkeyFormats );
    LocalFree((HLOCAL)pInst);
}

/*  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | EmptyCustomFormats |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
EmptyCustomFormats ( PInstData pInst )
{
    LPCustomFormat pcf;
    LPCustomFormat pcfNext;

    pcf = pInst->cfp.pcfHead;
    while (pcf != NULL)
    {
        pcfNext = pcf->pcfNext;
        DeleteCustomFormat(pcf);
        pcf = pcfNext;
    }
    pInst->cfp.pcfHead = NULL;
    pInst->cfp.pcfTail = NULL;
    pInst->pcf = NULL;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | FlushCustomForamts | Write out all custom formats to INI
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
FlushCustomFormats ( PInstData pInst )
{
    LPCustomFormat      pcf;
    PCustomFormatPool   pcfp = &pInst->cfp;


    //
    //  We can't save anything if we can't access the registry key.
    //
    if( NULL == pInst->hkeyFormats )
    {
        DPF(1,"FlushCustomFormats: Can't access registry, hkeyFormats==NULL.");
        return;
    }

    //
    //  Write out the currently-defined formats.
    //
    pcf = pcfp->pcfHead;
    while (pcf != NULL)
    {
	SetCustomFormat(pInst->hkeyFormats,pcf);
	pcf = pcf->pcfNext;
    }

}



/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | RegisterUpdateNotify | Register this window as
 *  requesting a private notification when changes take place in our section
 *  of the INI file.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
RegisterUpdateNotify ( PInstData pInst )
{
    int         i;

#ifdef WIN32
    //a. Get or Create the memory mapping that has all the hwnd's
    HANDLE      hMap;

    hMap = CreateFileMapping(INVALID_HANDLE_VALUE,
                             NULL,
                             PAGE_READWRITE,
                             0L,
                             sizeof(HWND)*MAX_HWND_NOTIFY,
                             (LPTSTR)gszChooserFileMapping);

    pInst->hFileMapping = hMap;
    pInst->pahNotify = NULL;

    if (hMap)
    {
        pInst->pahNotify = (HWND *)MapViewOfFile(hMap,
                                                 FILE_MAP_ALL_ACCESS,
                                                 0L,
                                                 0L,
                                                 0L);
    }

    if (!pInst->pahNotify)
        return;

#else
    //a. Add this hwnd to the static array of hwnds.

    pInst->pahNotify = ahNotify;
#endif

    //NOTE: since this is shared data, it is reusable and generally
    // stepped on while MSACM is resident, which means forever.  This
    // means that we should be extra sure that there aren't duplicate
    // hwnd values in the array.

    /* Scan the array for an invalid value and reuse it */
    for (i = 0; i < MAX_HWND_NOTIFY; i++)
        if (pInst->pahNotify[i] == 0 || pInst->pahNotify[i] == pInst->hwnd ||
            !IsWindow(pInst->pahNotify[i]))
        {
            pInst->pahNotify[i] = pInst->hwnd;
            break;
        }
    for (i++; i < MAX_HWND_NOTIFY; i++)
        if (pInst->pahNotify[i] == pInst->hwnd)
        {
            pInst->pahNotify[i] = 0;
        }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void | UnRegisterUpdateNotify | Unregister this window from the
 *  global shared pool of window handles.  This removes us from further
 *  notificiations.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
UnRegisterUpdateNotify ( PInstData pInst )
{
    int         i;
    if (pInst->pahNotify)
    {
        for (i = 0; i < MAX_HWND_NOTIFY; i++)
            if (pInst->pahNotify[i] == pInst->hwnd)
            {
                pInst->pahNotify[i] = 0;
                break;
            }

#ifdef WIN32
        UnmapViewOfFile((LPVOID)pInst->pahNotify);
#endif
    }

#ifdef WIN32
    if (pInst->hFileMapping)
        CloseHandle(pInst->hFileMapping);
#endif
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | NotifyINIChange |  Notify all ACM common choosers of
 *  this "type" to update from the INI cache as a global name change has occured.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
NotifyINIChange ( PInstData pInst )
{
    int         i;

    /* Tell sibling instances */
    if (!pInst->pahNotify)
        return;

    for (i = 0; i < MAX_HWND_NOTIFY; i++)
    {
        if (pInst->pahNotify[i] == 0 || pInst->pahNotify[i] == pInst->hwnd)
            continue;

        if (IsWindow(pInst->pahNotify[i]))
        {
            PostMessage(pInst->pahNotify[i],pInst->uUpdateMsg,0,0L);
        }
        else
            pInst->pahNotify[i] = 0;
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | CopyStruct | Depending upon the "type" of structure
 *  (FORMAT|FILTER) allocate or  reallocate and copy.
 *
 *  @parm LPBYTE | lpDest |
 *
 *  @parm LPBYTE | lpSrc |
 *
 *  @parm UINT | uType |
 *
 ****************************************************************************/
LPBYTE FNLOCAL
CopyStruct ( LPBYTE     lpDest,
             LPBYTE     lpSrc,
             UINT       uType )
{
    LPBYTE      lpBuffer;
    DWORD       cbSize;

    if (!lpSrc)
        return (NULL);

    switch (uType)
    {
        case FORMAT_CHOOSE:
        {
            LPWAVEFORMATEX lpwfx = (LPWAVEFORMATEX)lpSrc;
            cbSize = SIZEOF_WAVEFORMATEX(lpwfx);
            break;
        }
        case FILTER_CHOOSE:
        {
            LPWAVEFILTER lpwf = (LPWAVEFILTER)lpSrc;
            cbSize = lpwf->cbStruct;
            break;
        }
    }

    if (lpDest)
    {
        lpBuffer = (LPBYTE)GlobalReAllocPtr(lpDest,cbSize,GHND);
    }
    else
    {
        lpBuffer = (LPBYTE)GlobalAllocPtr(GHND,cbSize);
    }

    if (!lpBuffer)
        return (NULL);

    _fmemcpy(lpBuffer, lpSrc, (UINT)cbSize);
    return (lpBuffer);
}

/*  -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -*/
/* misc. */


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api PNameStore FNLOCAL | NewNameStore | Allocates a sized string buffer
 *
 *  @parm UINT | cchLen | Maximum number of characters in string (inc. NULL)
 *
 ****************************************************************************/
PNameStore FNLOCAL
NewNameStore ( UINT cchLen )
{
    UINT        cbSize;
    PNameStore  pName;

    cbSize = cchLen*sizeof(TCHAR) + sizeof(NameStore);

    pName = (PNameStore)LocalAlloc(LPTR,cbSize);
    if (pName)
        pName->cbSize = (unsigned short)cbSize;

    return (pName);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | DeleteNameStore |
 *
 *  @parm PNameStore | pns |
 *
 ****************************************************************************/
//
//  This routine is now inlined in chooseri.h.
//


/*      -       -       -       -       -       -       -       -       -   */

/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMFILTERCHOOSE | The <t ACMFILTERCHOOSE> structure contains
 *      information the Audio Compression Manager (ACM) uses to initialize
 *      the system-defined wave filter selection dialog box. After the
 *      user closes the dialog box, the system returns information about
 *      the user's selection in this structure.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFILTERCHOOSE> structure. This member must be initialized
 *      before calling the <f acmFilterChoose> function. The size specified
 *      in this member must be large enough to contain the base
 *      <t ACMFILTERCHOOSE> structure.
 *
 *  @field DWORD | fdwStyle | Specifies optional style flags for the
 *      <f acmFilterChoose> function. This member must be initialized to
 *      a valid combination of the following flags before calling the
 *      <f acmFilterChoose> function.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_ENABLEHOOK | Enables the hook function
 *      specified in the <e ACMFILTERCHOOSE.pfnHook> member. An application
 *      can use hook functions for a variety of customizations, including
 *      answering the <f MM_ACM_FILTERCHOOSE> message.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE | Causes the ACM to
 *      create the dialog box template identified by the
 *      <e ACMFILTERCHOOSE.hInstance> and <e ACMFILTERCHOOSE.pszTemplateName>
 *      members.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE | Indicates that
 *      the <e ACMFILTERCHOOSE.hInstance> member identifies a data block that
 *      contains a preloaded dialog box template. The ACM ignores the
 *      <e ACMFILTERCHOOSE.pszTemplateName> member if this flag is specified.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT | Indicates that the
 *      buffer pointed to by <e ACMFILTERCHOOSE.pwfltr> contains a valid
 *      <t WAVEFILTER> structure that the dialog will use as the initial
 *      selection.
 *
 *      @flag ACMFILTERCHOOSE_STYLEF_SHOWHELP | Indicates that a help button
 *      will appear in the dialog box. To use a custom Help file, an application
 *      must register the <c ACMHELPMSGSTRING> constant
 *      with <f RegisterWindowMessage>.  When the user presses the help button,
 *      the registered message is posted to the owner.
 *
 *  @field HWND | hwndOwner | Identifies the window that owns the dialog
 *      box. This member can be any valid window handle, or NULL if the
 *      dialog box has no owner. This member must be initialized before
 *      calling the <f acmFilterChoose> function.
 *
 *  @field LPWAVEFILTER | pwfltr | Specifies a pointer to a <t WAVEFILTER>
 *      structure. If the ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT flag is
 *      specified in the <e ACMFILTERCHOOSE.fdwStyle> member, then this
 *      structure must be initialized to a valid filter. When the
 *      <f acmFilterChoose> function returns, this buffer contains the
 *      selected filter. If the user cancels the dialog, no changes will
 *      be made to this buffer.
 *
 *  @field DWORD | cbwfltr | Specifies the size in bytes of the buffer pointed
 *      to by the <e ACMFILTERCHOOSE.pwfltr> member. The <f acmFilterChoose>
 *      function returns ACMERR_NOTPOSSIBLE if the buffer is too small to
 *      contain the filter information; also, the ACM copies the required size
 *      into this member. An application can use the <f acmMetrics> and
 *      <f acmFilterTagDetails> functions to determine the largest size
 *      required for this buffer.
 *
 *  @field LPCSTR | pszTitle | Points to a string to be placed in the title
 *      bar of the dialog box. If this member is NULL, the ACM uses the
 *      default title (that is, "Filter Selection").
 *
 *  @field char | szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS] |
 *      When the <f acmFilterChoose> function returns, this buffer contains
 *      a NULL-terminated string describing the filter tag of the filter
 *      selection. This string is equivalent to the
 *      <e ACMFILTERTAGDETAILS.szFilterTag> member of the <t ACMFILTERTAGDETAILS>
 *      structure returned by <f acmFilterTagDetails>. If the user cancels
 *      the dialog, this member will contain a NULL string.
 *
 *  @field char | szFilter[ACMFILTERDETAILS_FILTER_CHARS] | When the
 *      <f acmFilterChoose> function returns, this buffer contains a
 *      NULL-terminated string describing the filter attributes of the
 *      filter selection. This string is equivalent to the
 *      <e ACMFILTERDETAILS.szFilter> member of the <t ACMFILTERDETAILS>
 *      structure returned by <f acmFilterDetails>. If the user cancels
 *      the dialog, this member will contain a NULL string.
 *
 *  @field LPSTR | pszName | Points to a string for a user-defined filter
 *      name. If this is a non-NULL string, then the ACM attempts to
 *      match the name with a previously saved user-defined filter name.
 *      If a match is found, then the dialog is initialized to that filter.
 *      If a match is not found or this member is a NULL string, then this
 *      member is ignored for input. When the <f acmFilterChoose> function
 *      returns, this buffer contains a NULL-terminated string describing
 *      the user-defined filter. If the filter name is untitled (that is,
 *      the user has not given a name for the filter), then this member will
 *      be a NULL string on return. If the user cancels the dialog, no
 *      changes will be made to this buffer.
 *
 *      If the ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT flag is specified in
 *      the <e ACMFILTERCHOOSE.fdwStyle> member, then the
 *      <e ACMFILTERCHOOSE.pszName> is ignored as an input parameter.
 *
 *  @field DWORD | cchName | Specifies the size, in characters, of the
 *      buffer identified by the <e ACMFILTERCHOOSE.pszName> member. This
 *      buffer should be at least 128 characters long. This parameter is
 *      ignored if the <e ACMFILTERCHOOSE.pszName> member is NULL.
 *
 *  @field DWORD | fdwEnum | Specifies optional flags for restricting the
 *      type of filters listed in the dialog. These flags are identical to
 *      the <p fdwEnum> flags for the <f acmFilterEnum> function. This
 *      member should be zero if <e ACMFILTERCHOOSE.pwfltrEnum> is NULL.
 *
 *      @flag ACM_FILTERENUMF_DWFILTERTAG | Specifies that the
 *      <e WAVEFILTER.dwFilterTag> member of the <t WAVEFILTER> structure
 *      referred to by the <e ACMFILTERCHOOSE.pwfltrEnum> member is valid. The
 *      enumerator will only enumerate a filter that conforms to this
 *      attribute.
 *
 *  @field LPWAVEFILTER | pwfltrEnum | Points to a <t WAVEFILTER> structure
 *      that will be used to restrict the filters listed in the dialog. The
 *      <e ACMFILTERCHOOSE.fdwEnum> member defines which fields from the
 *      <e ACMFILTERCHOOSE.pwfltrEnum> structure should be used for the
 *      enumeration restrictions. The <e WAVEFILTER.cbStruct> member of this
 *      <t WAVEFILTER> structure must be initialized to the size of the
 *      <t WAVEFILTER> structure. This member can be NULL if no special
 *      restrictions are desired.
 *
 *  @field HINSTANCE | hInstance | Identifies a data block that contains
 *      a dialog box template specified by the <e ACMFILTERCHOOSE.pszTemplateName>
 *      member. This member is used only if the <e ACMFILTERCHOOSE.fdwStyle>
 *      member specifies the ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE or the
 *      ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE flag; otherwise, this
 *      member should be NULL on input.
 *
 *  @field LPCSTR | pszTemplateName | Points to a NULL-terminated string that
 *      specifies the name of the resource file for the dialog box template
 *      that is to be substituted for the dialog box template in the ACM.
 *      An application can use the <f MAKEINTRESOURCE> macro for numbered
 *      dialog box resources. This member is used only if the
 *      <e ACMFILTERCHOOSE.fdwStyle> member specifies the
 *      ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE flag; otherwise, this
 *      member should be NULL on input.
 *
 *  @field LPARAM | lCustData | Specifies application-defined data that the
 *      ACM passes to the hook function identified by the
 *      <e ACMFILTERCHOOSE.pfnHook> member. The system passes the data in
 *      the <p lParam> argument of the <f WM_INITDIALOG> message.
 *
 *  @field ACMFILTERCHOOSEHOOKPROC | pfnHook | Points to a hook function that
 *      processes messages intended for the dialog box. An application must
 *      specify the ACMFILTERCHOOSE_STYLEF_ENABLEHOOK flag in the
 *      <e ACMFILTERCHOOSE.fdwStyle> member to enable the hook; otherwise,
 *      this member should be NULL. The hook function should return FALSE
 *      to pass a message to the standard dialog box procedure, or TRUE
 *      to discard the message.
 *
 *  @xref <f acmFilterChoose> <f acmFilterChooseHookProc> <f acmMetrics>
 *      <f acmFilterTagDetails> <f acmFilterDetails> <f acmFilterEnum>
 *      <f acmFormatChoose>
 *
 ****************************************************************************/

/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @msg MM_ACM_FILTERCHOOSE | This message notifies an <f acmFilterChoose> dialog hook
 *      function before adding an element to one of the three drop-down
 *      list boxes. This message allows an application to further customize
 *      the selections available through the user interface.
 *
 *  @parm WPARAM | wParam | Specifies the drop-down list box being initialized
 *      and a verify or add operation.
 *
 *      @flag FILTERCHOOSE_FILTERTAG_VERIFY | Specifies that <p lParam> is a
 *      wave filter tag to be listed in the Filter Tag drop-down list box.
 *
 *      @flag FILTERCHOOSE_FILTER_VERIFY | Specifies that <p lParam> is a
 *      pointer to a <t WAVEFILTER> structure to be added to the Filter
 *      drop-down list box.
 *
 *      @flag FILTERCHOOSE_CUSTOM_VERIFY | The <p lParam> value is a pointer
 *      to a <t WAVEFILTER> structure to be added to the custom Name
 *      drop-down list box.
 *
 *      @flag FILTERCHOOSE_FILTERTAG_ADD | Specifies that <p lParam> is a
 *      pointer to a <t DWORD> that will accept a wave filter tag to be added
 *      to the Filter Tag drop-down list box.
 *
 *      @flag FILTERCHOOSE_FILTER_ADD | Specifies that <p lParam> is a
 *      pointer to a buffer that will accept a <t WAVEFILTER> structure to be
 *      added to the Filter drop-down list box. The application must copy the
 *      filter structure to be added into this buffer.
 *
 *  @parm LPARAM | lParam | Defined by the listbox specified in the
 *      <p wParam> argument.
 *
 *  @rdesc If an application handles this message, it must return TRUE;
 *      otherwise, it must return FALSE.
 *      If processing a verify operation, the application must precede the
 *      return with
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)FALSE)> to prevent the
 *      dialog from listing this selection, or
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)TRUE)> to allow the
 *      dialog to list this selection.
 *      If processing an add operation, the application must precede the
 *      return with
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)FALSE)> to indicate that
 *      no more additions are required, or
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)TRUE)> if more additions
 *      are required.
 *
 *  @comm If processing the <m FILTERCHOOSE_FILTER_ADD> operation, the size of
 *      the memory buffer supplied in <p lParam> will be determined from
 *      <f acmMetrics>.
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api UINT ACMFILTERCHOOSEHOOKPROC | acmFilterChooseHookProc |
 *      The <f acmFilterChooseHookProc> function is a placeholder for a user-defined
 *      function to hook the <f acmFilterChoose> dialog box. Usage is
 *      equivalent to Windows Common Dialog hook functions for customizing
 *      common dialogs. See the Microsoft Windows Software Development Kit for more
 *      information about the <p uMsg>, <p wParam>, and <p lParam> parameters.
 *
 *  @parm HWND | hwnd | Specifies the window handle for the dialog box.
 *
 *  @parm UINT | uMsg | Specifies the window message.
 *
 *  @parm WPARAM | wParam | The first message parameter.
 *
 *  @parm LPARAM | lParam | The second message parameter.
 *
 *  @comm If the hook function processes the <f WM_CTLCOLOR> message, this
 *      function must return a handle of the brush that should be used to
 *      paint the control background.
 *
 *      A hook function can optionally process the <f MM_ACM_FILTERCHOOSE>
 *      message to customize the dialog selections.
 *
 *  @xref <f acmFilterChoose> <t ACMFILTERCHOOSE> <f MM_ACM_FILTERCHOOSE>
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFilterChoose | The <f acmFilterChoose> function creates
 *      an Audio Compression Manager (ACM) defined dialog box that enables
 *      the user to select a wave filter.
 *
 *  @parm LPACMFILTERCHOOSE | pafltrc | Points to an <t ACMFILTERCHOOSE>
 *      structure that contains information used to initialize the dialog
 *      box. When <f acmFilterChoose> returns, this structure contains
 *      information about the user's filter selection.
 *
 *  @rdesc Returns <c MMSYSERR_NOERROR> if the function was successful.
 *      Otherwise, it returns an error value. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_NODRIVER | A suitable driver is not available to
 *      provide valid filter selections.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The buffer identified by the
 *      <e ACMFILTERCHOOSE.pwfltr> member of the <t ACMFILTERCHOOSE> structure
 *      is too small to contain the selected filter.
 *
 *      @flag ACMERR_CANCELED | The user chose the Cancel button or the
 *      Close command on the System menu to close the dialog box.
 *
 *  @comm The <e ACMFILTERCHOOSE.pwfltr> member must be filled in with a valid
 *      pointer to a memory location that will contain the returned filter
 *      header structure. Moreover, the <e ACMFILTERCHOOSE.cbwfltr> member must
 *      be filled in with the size in bytes of this memory buffer.
 *
 *  @xref <t ACMFILTERCHOOSE> <f acmFilterChooseHookProc> <f acmFormatChoose>
 *
 ***************************************************************************/

MMRESULT ACMAPI
acmFilterChoose ( LPACMFILTERCHOOSE pafltrc )
{
    INT_PTR     iRet;
    PInstData   pInst;
#if defined(WIN32) && !defined(UNICODE)
    LPCWSTR     lpDlgTemplate = MAKEINTRESOURCEW(DLG_ACMFILTERCHOOSE_ID);
#else
    LPCTSTR     lpDlgTemplate = MAKEINTRESOURCE(DLG_ACMFILTERCHOOSE_ID);
#endif
    HINSTANCE   hInstance = NULL;
    MMRESULT    mmrResult = MMSYSERR_NOERROR;
    UINT        cbwfltrEnum;

    //
    //
    //
    if (NULL == pagFindAndBoot())
    {
	DPF(1, "acmFilterChoose: NULL pag!!!");
	return (0);
    }

    /* Begin Parameter Validation */

    V_WPOINTER(pafltrc, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pafltrc, pafltrc->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(*pafltrc) > pafltrc->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterChoose: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    V_DFLAGS(pafltrc->fdwStyle, ACMFILTERCHOOSE_STYLEF_VALID, acmFilterChoose, MMSYSERR_INVALFLAG);
    V_WPOINTER(pafltrc->pwfltr, pafltrc->cbwfltr, MMSYSERR_INVALPARAM);
#if defined(WIN32) && !defined(UNICODE)
    V_STRINGW(pafltrc->szFilter,    SIZEOFW(pafltrc->szFilter),    MMSYSERR_INVALPARAM);
    V_STRINGW(pafltrc->szFilterTag, SIZEOFW(pafltrc->szFilterTag), MMSYSERR_INVALPARAM);
#else
    V_STRING(pafltrc->szFilter,    SIZEOF(pafltrc->szFilter),    MMSYSERR_INVALPARAM);
    V_STRING(pafltrc->szFilterTag, SIZEOF(pafltrc->szFilterTag), MMSYSERR_INVALPARAM);
#endif

    // Name parm can be NULL
    if ( pafltrc->pszName )
#if defined(WIN32) && !defined(UNICODE)
	V_STRINGW(pafltrc->pszName, (UINT)pafltrc->cchName, MMSYSERR_INVALPARAM);
#else
        V_STRING(pafltrc->pszName, (UINT)pafltrc->cchName, MMSYSERR_INVALPARAM);
#endif


    V_DFLAGS(pafltrc->fdwEnum, ACM_FILTERENUMF_VALID, acmFilterChoose, MMSYSERR_INVALFLAG);


    //
    //  validate fdwEnum and pwfltrEnum so the chooser doesn't explode when
    //  an invalid combination is specified.
    //
    cbwfltrEnum = 0L;
    if (0 != (pafltrc->fdwEnum & ACM_FILTERENUMF_DWFILTERTAG))
    {
        if (NULL == pafltrc->pwfltrEnum)
        {
            DebugErr1(DBF_ERROR, "acmFilterChoose: specified fdwEnum (%.08lXh) flags require valid pwfltrEnum.", pafltrc->pwfltrEnum);
            return (MMSYSERR_INVALPARAM);
        }

        V_RWAVEFILTER(pafltrc->pwfltrEnum, MMSYSERR_INVALPARAM);
        cbwfltrEnum = (UINT)pafltrc->cbStruct;
    }
    else
    {
        if (NULL != pafltrc->pwfltrEnum)
        {
            DebugErr(DBF_ERROR, "acmFilterChoose: pwfltrEnum must be NULL for specified fdwEnum flags.");
            return (MMSYSERR_INVALPARAM);
        }
    }

    // pfnHook is valid only when ENABLEHOOK is specified
    if (pafltrc->fdwStyle & ACMFILTERCHOOSE_STYLEF_ENABLEHOOK)
        V_CALLBACK((FARPROC)pafltrc->pfnHook, MMSYSERR_INVALPARAM);

    /* End Parameter Validation */

    pInst = NewInstance((LPBYTE)pafltrc,FILTER_CHOOSE);
    if (!pInst)
    {
        mmrResult = MMSYSERR_NOMEM;
        goto afcexit;
    }

    pInst->cbwfltrEnum = cbwfltrEnum;

    hInstance = pInst->pag->hinst;
    if (pafltrc->fdwStyle & ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE)
    {
        /* ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE indicate that hInstance and
         * pszTemplateName specify a dialog template.
         */
        lpDlgTemplate = pafltrc->pszTemplateName;
        hInstance = pafltrc->hInstance;
    }


    //
    //  Restore priorities, in case another instance has modified them
    //  recently.
    //
    if( IDriverPrioritiesRestore(pInst->pag) ) {   // Something changed!
        IDriverBroadcastNotify( pInst->pag );
    }


    if (pafltrc->fdwStyle & (ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE))
    {
        /* ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE indicates that hInstance is
         * a data block containing a dialog box template.
         */
        iRet = DialogBoxIndirectParam(pInst->pag->hinst,
#ifdef WIN32
                                      (LPDLGTEMPLATE)pafltrc->hInstance,
#else
                                      pafltrc->hInstance,
#endif
                                      pafltrc->hwndOwner,
                                      NewSndDlgProc,
                                      PTR2LPARAM(pInst));

    }
    else
    {
#ifdef WIN32
	iRet = DialogBoxParamW(hInstance,
#else
        iRet = DialogBoxParam(hInstance,
#endif
                              lpDlgTemplate,
                              pafltrc->hwndOwner,
                              NewSndDlgProc,
                              PTR2LPARAM(pInst));
    }

    switch (iRet)
    {
        case -1:
            mmrResult = MMSYSERR_INVALPARAM;
            break;
        case ChooseOk:
            mmrResult = MMSYSERR_NOERROR;
            break;
        case ChooseCancel:
            mmrResult = ACMERR_CANCELED;
            break;
        case ChooseSubFailure:
            mmrResult = pInst->mmrSubFailure;
            break;
        default:
            mmrResult = MMSYSERR_NOMEM;
            break;
    }

    if (ChooseOk == iRet)
    {
        DWORD cbSize;
        LPWAVEFILTER lpwfltr = (LPWAVEFILTER)pInst->lpbSel;
        ACMFILTERDETAILS adf;
        ACMFILTERTAGDETAILS adft;

        cbSize = lpwfltr->cbStruct;

        if (pafltrc->cbwfltr > cbSize)
            pafltrc->cbwfltr = cbSize;
        else if (cbSize > pafltrc->cbwfltr)
        {
            mmrResult = ACMERR_NOTPOSSIBLE;
            goto afcexit;
        }

        if (!IsBadWritePtr((LPVOID)((LPWAVEFILTER)pafltrc->pwfltr),
                           (UINT)pafltrc->cbwfltr))
            _fmemcpy(pafltrc->pwfltr, lpwfltr, (UINT)pafltrc->cbwfltr);

        _fmemset(&adft, 0, sizeof(adft));

        adft.cbStruct = sizeof(adft);
        adft.dwFilterTag = lpwfltr->dwFilterTag;
        if (!acmFilterTagDetails(NULL,
                                 &adft,
                                 ACM_FILTERTAGDETAILSF_FILTERTAG))
#ifdef WIN32
	    lstrcpyW(pafltrc->szFilterTag,adft.szFilterTag);
#else
            lstrcpy(pafltrc->szFilterTag,adft.szFilterTag);
#endif

        adf.cbStruct      = sizeof(adf);
        adf.dwFilterIndex = 0;
        adf.dwFilterTag   = lpwfltr->dwFilterTag;
        adf.fdwSupport    = 0;
        adf.pwfltr        = lpwfltr;
        adf.cbwfltr       = cbSize;

        if (!acmFilterDetails(NULL,
                              &adf,
                              ACM_FILTERDETAILSF_FILTER))
#ifdef WIN32
	    lstrcpyW(pafltrc->szFilter,adf.szFilter);
#else
	    lstrcpy(pafltrc->szFilter,adf.szFilter);
#endif

        GlobalFreePtr(lpwfltr);
    }
afcexit:
    if (pInst)
        DeleteInstance(pInst);

    return (mmrResult);
}

#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFilterChooseA
(
    LPACMFILTERCHOOSEA      pafc
)
{
    MMRESULT            mmr;
    ACMFILTERCHOOSEW    afcW;

    V_WPOINTER(pafc, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pafc, pafc->cbStruct, MMSYSERR_INVALPARAM);
    if (sizeof(*pafc) > pafc->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFilterChoose: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    memset(&afcW, 0, sizeof(afcW));

    afcW.cbStruct       = sizeof(afcW);
    afcW.fdwStyle       = pafc->fdwStyle;
    afcW.hwndOwner      = pafc->hwndOwner;
    afcW.pwfltr         = pafc->pwfltr;
    afcW.cbwfltr        = pafc->cbwfltr;

    if (NULL != pafc->pszTitle)
    {
        UINT        cb;

        cb = (lstrlenA(pafc->pszTitle) + 1) * sizeof(WCHAR);

        afcW.pszTitle = (LPCWSTR)LocalAlloc(LPTR, cb);

        if (NULL != afcW.pszTitle)
        {
            Imbstowcs((LPWSTR)afcW.pszTitle, pafc->pszTitle, cb / sizeof(WCHAR));
        }
    }

    afcW.szFilterTag[0] = '\0';
    afcW.szFilter[0]    = '\0';

    if (NULL != pafc->pszName)
    {
        afcW.pszName    = (LPWSTR)LocalAlloc(LPTR, pafc->cchName * sizeof(WCHAR));
        afcW.cchName    = pafc->cchName;

        if (NULL != afcW.pszName)
        {
            Imbstowcs(afcW.pszName, pafc->pszName, pafc->cchName);
        }
    }

    afcW.fdwEnum        = pafc->fdwEnum;
    afcW.pwfltrEnum     = pafc->pwfltrEnum;
    afcW.hInstance      = pafc->hInstance;

    if (0 == HIWORD(pafc->pszTemplateName))
    {
        afcW.pszTemplateName = (LPCWSTR)pafc->pszTemplateName;
    }
    else
    {
        UINT        cb;

        cb = (lstrlenA(pafc->pszTemplateName) + 1) * sizeof(WCHAR);

        afcW.pszTemplateName = (LPCWSTR)LocalAlloc(LPTR, cb);

        if (NULL != afcW.pszTemplateName)
        {
            Imbstowcs((LPWSTR)afcW.pszTemplateName, pafc->pszTemplateName, cb / sizeof(WCHAR));
        }
    }

    afcW.lCustData      = pafc->lCustData;

    //
    //  !!! wrong !!! bad curt, bad bad bad !!!
    //
    afcW.pfnHook        = (ACMFILTERCHOOSEHOOKPROCW)pafc->pfnHook;

    mmr = acmFilterChooseW(&afcW);
    if (MMSYSERR_NOERROR == mmr)
    {
        if (NULL != afcW.pszName)
        {
            Iwcstombs(pafc->pszName, afcW.pszName, pafc->cchName);
        }

        Iwcstombs(pafc->szFilterTag, afcW.szFilterTag, sizeof(pafc->szFilterTag));
        Iwcstombs(pafc->szFilter,    afcW.szFilter,    sizeof(pafc->szFilter));
    }

    if (NULL != afcW.pszName)
    {
        LocalFree((HLOCAL)afcW.pszName);
    }

    if (NULL != afcW.pszTitle)
    {
        LocalFree((HLOCAL)afcW.pszTitle);
    }

    if (0 == HIWORD(afcW.pszTemplateName))
    {
        LocalFree((HLOCAL)afcW.pszTemplateName);
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFilterChooseW
(
    LPACMFILTERCHOOSEW      pafc
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @types ACMFORMATCHOOSE | The <t ACMFORMATCHOOSE> structure contains
 *      information the Audio Compression Manager (ACM) uses to initialize
 *      the system-defined wave format selection dialog box. After the
 *      user closes the dialog box, the system returns information about
 *      the user's selection in this structure.
 *
 *  @field DWORD | cbStruct | Specifies the size in bytes of the
 *      <t ACMFORMATCHOOSE> structure. This member must be initialized
 *      before calling the <f acmFormatChoose> function. The size specified
 *      in this member must be large enough to contain the base
 *      <t ACMFORMATCHOOSE> structure.
 *
 *  @field DWORD | fdwStyle | Specifies optional style flags for the
 *      <f acmFormatChoose> function. This member must be initialized to
 *      a valid combination of the following flags before calling the
 *      <f acmFormatChoose> function.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_ENABLEHOOK | Enables the hook function
 *      specified in the <e ACMFORMATCHOOSE.pfnHook> member. An application
 *      can use hook functions for a variety of customizations, including
 *      answering the <f MM_ACM_FORMATCHOOSE> message.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE | Causes the ACM to
 *      create the dialog box template identified by the
 *      <e ACMFORMATCHOOSE.hInstance> and <e ACMFORMATCHOOSE.pszTemplateName>
 *      members.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE | Indicates that
 *      the <e ACMFORMATCHOOSE.hInstance> member identifies a data block that
 *      contains a preloaded dialog box template. The ACM ignores the
 *      <e ACMFORMATCHOOSE.pszTemplateName> member if this flag is specified.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT | Indicates that the
 *      buffer pointed to by <e ACMFORMATCHOOSE.pwfx> contains a valid
 *      <t WAVEFORMATEX> structure that the dialog will use as the initial
 *      selection.
 *
 *      @flag ACMFORMATCHOOSE_STYLEF_SHOWHELP | Indicates that a help button
 *      will appear in the dialog box. To use a custom Help file, an application must
 *      register the <c ACMHELPMSGSTRING> constant
 *      with <f RegisterWindowMessage>.  When the user presses the help button,
 *      the registered message will be posted to the owner.
 *
 *  @field HWND | hwndOwner | Identifies the window that owns the dialog
 *      box. This member can be any valid window handle, or NULL if the
 *      dialog box has no owner. This member must be initialized before
 *      calling the <f acmFormatChoose> function.
 *
 *  @field LPWAVEFORMATEX | pwfx | Specifies a pointer to a <t WAVEFORMATEX>
 *      structure. If the ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT flag is
 *      specified in the <e ACMFORMATCHOOSE.fdwStyle> member, then this
 *      structure must be initialized to a valid format. When the
 *      <f acmFormatChoose> function returns, this buffer contains the
 *      selected format. If the user cancels the dialog, no changes will
 *      be made to this buffer.
 *
 *  @field DWORD | cbwfx | Specifies the size in bytes of the buffer pointed
 *      to by the <e ACMFORMATCHOOSE.pwfx> member. The <f acmFormatChoose>
 *      function returns ACMERR_NOTPOSSIBLE if the buffer is too small to
 *      contain the format information; also, the ACM copies the required size
 *      into this member. An application can use the <f acmMetrics> and
 *      <f acmFormatTagDetails> functions to determine the largest size
 *      required for this buffer.
 *
 *  @field LPCSTR | pszTitle | Points to a string to be placed in the title
 *      bar of the dialog box. If this member is NULL, the ACM uses the
 *      default title (that is, "Sound Selection").
 *
 *  @field char | szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS] |
 *      When the <f acmFormatChoose> function returns, this buffer contains
 *      a NULL-terminated string describing the format tag of the format
 *      selection. This string is equivalent to the
 *      <e ACMFORMATTAGDETAILS.szFormatTag> member of the <t ACMFORMATTAGDETAILS>
 *      structure returned by <f acmFormatTagDetails>. If the user cancels
 *      the dialog, this member will contain a NULL string.
 *
 *  @field char | szFormat[ACMFORMATDETAILS_FORMAT_CHARS] | When the
 *      <f acmFormatChoose> function returns, this buffer contains a
 *      NULL-terminated string describing the format attributes of the
 *      format selection. This string is equivalent to the
 *      <e ACMFORMATDETAILS.szFormat> member of the <t ACMFORMATDETAILS>
 *      structure returned by <f acmFormatDetails>. If the user cancels
 *      the dialog, this member will contain a NULL string.
 *
 *  @field LPSTR | pszName | Points to a string for a user-defined format
 *      name. If this is a non-NULL string, then the ACM will attempt to
 *      match the name with a previously saved user-defined format name.
 *      If a match is found, then the dialog is initialized to that format.
 *      If a match is not found or this member is a NULL string, then this
 *      member is ignored for input. When the <f acmFormatChoose> function
 *      returns, this buffer contains a NULL-terminated string describing
 *      the user-defined format. If the format name is untitled (that is,
 *      the user has not given a name for the format), then this member will
 *      be a NULL string on return. If the user cancels the dialog, no
 *      changes will be made to this buffer.
 *
 *      If the ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT flag is specified in
 *      the <e ACMFORMATCHOOSE.fdwStyle> member, then the
 *      <e ACMFORMATCHOOSE.pszName> is ignored as an input parameter.
 *
 *  @field DWORD | cchName | Specifies the size, in characters, of the
 *      buffer identified by the <e ACMFORMATCHOOSE.pszName> member. This
 *      buffer should be at least 128 characters long. This parameter is
 *      ignored if the <e ACMFORMATCHOOSE.pszName> member is NULL.
 *
 *  @field DWORD | fdwEnum | Specifies optional flags for restricting the
 *      type of formats listed in the dialog. These flags are identical to
 *      the <p fdwEnum> flags for the <f acmFormatEnum> function. This
 *      member should be zero if <e ACMFORMATCHOOSE.pwfxEnum> is NULL.
 *
 *      @flag ACM_FORMATENUMF_WFORMATTAG | Specifies that the
 *      <e WAVEFORMATEX.wFormatTag> member of the <t WAVEFORMATEX> structure
 *      referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is valid. The
 *      enumerator will only enumerate a format that conforms to this
 *      attribute.
 *
 *      @flag ACM_FORMATENUMF_NCHANNELS | Specifies that the
 *      <e WAVEFORMATEX.nChannels> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will only enumerate a format that conforms to
 *      this attribute.
 *
 *      @flag ACM_FORMATENUMF_NSAMPLESPERSEC | Specifies that the
 *      <e WAVEFORMATEX.nSamplesPerSec> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will only enumerate a format that conforms to
 *      this attribute.
 *
 *      @flag ACM_FORMATENUMF_WBITSPERSAMPLE | Specifies that the
 *      <e WAVEFORMATEX.wBitsPerSample> member of the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will only enumerate a format that conforms to
 *      this attribute.
 *
 *      @flag ACM_FORMATENUMF_CONVERT | Specifies that the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will only enumerate destination formats that
 *      can be converted from the given <e ACMFORMATCHOOSE.pwfxEnum> format.
 *
 *      @flag ACM_FORMATENUMF_SUGGEST | Specifies that the <t WAVEFORMATEX>
 *      structure referred to by the <e ACMFORMATCHOOSE.pwfxEnum> member is
 *      valid. The enumerator will enumerate all suggested destination
 *      formats for the given <e ACMFORMATCHOOSE.pwfxEnum> format.
 *
 *      @flag ACM_FORMATENUMF_HARDWARE | Specifies that the enumerator should
 *      only enumerate formats that are supported in hardware by one or
 *      more of the installed wave devices. This provides a way for an
 *      application to choose only formats native to an installed wave
 *      device.
 *
 *      @flag ACM_FORMATENUMF_INPUT | Specifies that the enumerator should
 *      only enumerate formats that are supported for input (recording).
 *
 *      @flag ACM_FORMATENUMF_OUTPUT | Specifies that the enumerator should
 *      only enumerate formats that are supported for output (playback).
 *
 *  @field LPWAVEFORMATEX | pwfxEnum | Points to a <t WAVEFORMATEX> structure
 *      that will be used to restrict the formats listed in the dialog. The
 *      <e ACMFORMATCHOOSE.fdwEnum> member defines the fields of the
 *      <e ACMFORMATCHOOSE.pwfxEnum> structure that should be used for the
 *      enumeration restrictions. This member can be NULL if no special
 *      restrictions are desired. See the description for <f acmFormatEnum>
 *      for other requirements associated with the <e ACMFORMATCHOOSE.pwfxEnum>
 *      member.
 *
 *  @field HINSTANCE | hInstance | Identifies a data block that contains
 *      a dialog box template specified by the <e ACMFORMATCHOOSE.pszTemplateName>
 *      member. This member is used only if the <e ACMFORMATCHOOSE.fdwStyle>
 *      member specifies the ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE or the
 *      ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE flag; otherwise, this
 *      member should be NULL on input.
 *
 *  @field LPCSTR | pszTemplateName | Points to a NULL-terminated string that
 *      specifies the name of the resource file for the dialog box template
 *      that is to be substituted for the dialog box template in the ACM.
 *      An application can use the <f MAKEINTRESOURCE> macro for numbered
 *      dialog box resources. This member is used only if the
 *      <e ACMFORMATCHOOSE.fdwStyle> member specifies the
 *      ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE flag; otherwise, this
 *      member should be NULL on input.
 *
 *  @field LPARAM | lCustData | Specifies application-defined data that the
 *      ACM passes to the hook function identified by the
 *      <e ACMFORMATCHOOSE.pfnHook> member. The system passes the data in
 *      the <p lParam> argument of the <f WM_INITDIALOG> message.
 *
 *  @field ACMFORMATCHOOSEHOOKPROC | pfnHook | Points to a hook function that
 *      processes messages intended for the dialog box. An application must
 *      specify the ACMFORMATCHOOSE_STYLEF_ENABLEHOOK flag in the
 *      <e ACMFORMATCHOOSE.fdwStyle> member to enable the hook; otherwise,
 *      this member should be NULL. The hook function should return FALSE
 *      to pass a message to the standard dialog box procedure, or TRUE
 *      to discard the message.
 *
 *  @xref <f acmFormatChoose> <f acmFormatChooseHookProc> <f acmMetrics>
 *      <f acmFormatTagDetails> <f acmFormatDetails> <f acmFormatEnum>
 *      <f acmFilterChoose>
 *
 ****************************************************************************/

/*****************************************************************************
 *  @doc EXTERNAL ACM_API_STRUCTURE
 *
 *  @msg MM_ACM_FORMATCHOOSE | This message notifies an <f acmFormatChoose> dialog hook
 *      function before adding an element to one of the three drop-down
 *      list boxes. This message allows an application to further customize
 *      the selections available through the user interface.
 *
 *  @parm WPARAM | wParam | Specifies the drop-down listbox being initialized
 *      and a verify or add operation.
 *
 *      @flag FORMATCHOOSE_FORMATTAG_VERIFY | Specifies that <p lParam> is a
 *      wave format tag to be listed int the Format Tag drop-down list box.
 *
 *      @flag FORMATCHOOSE_FORMAT_VERIFY | Specifies that <p lParam> is a
 *      pointer to a <t WAVEFORMATEX> structure to be added to the Format
 *      drop-down list box.
 *
 *      @flag FORMATCHOOSE_CUSTOM_VERIFY | The <p lParam> value is a pointer
 *      to a <t WAVEFORMATEX> structure to be added to the custom Name
 *      drop-down list box.
 *
 *      @flag FORMATCHOOSE_FORMATTAG_ADD | Specifies that <p lParam> is a
 *      pointer to a <t DWORD> that will accept a wave format tag to be added
 *      to the Format Tag drop-down list box.
 *
 *      @flag FORMATCHOOSE_FORMAT_ADD | Specifies that <p lParam> is a
 *      pointer to a buffer that will accept a <t WAVEFORMATEX> to be added
 *      to the Format drop-down list box. The application must copy the
 *      format structre to be added into this buffer.
 *
 *  @parm LPARAM | lParam | Defined by the listbox specified in the
 *      <p wParam> parameter.
 *
 *  @rdesc If an application handles this message, it must return TRUE;
 *      otherwise, it must return FALSE.
 *      If processing a verify operation, the application must precede the
 *      return with
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)FALSE)> to prevent the
 *      dialog from listing this selection, or
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)TRUE)> to allow the
 *      dialog to list this selection.
 *      If processing an add operation, the application must precede the
 *      return with
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)FALSE)> to indicate that
 *      no more additions are required or
 *      <f SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG)TRUE)> if more additions
 *      are required.
 *
 *  @comm If processing the <m FILTERCHOOSE_FORMAT_ADD> operation, the size
 *      of the memory buffer supplied in <p lParam> will be determined from
 *      <f acmMetrics>.
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api UINT ACMFORMATCHOOSEHOOKPROC | acmFormatChooseHookProc |
 *      The <f acmFormatChooseHookProc>  function is a placeholder for a user-defined
 *      function to hook the <f acmFormatChoose> dialog box. Usage is
 *      equivalent to the Windows Common Dialog hook functions for customizing
 *      common dialogs. See the Microsoft Windows Software Development Kit for more
 *      information about the <p uMsg>, <p wParam>, and <p lParam> parameters.
 *
 *  @parm HWND | hwnd | Specifies the window handle for the dialog box.
 *
 *  @parm UINT | uMsg | Specifies the window message.
 *
 *  @parm WPARAM | wParam | The first message parameter.
 *
 *  @parm LPARAM | lParam | The second message parameter.
 *
 *  @comm If the hook function processes the <f WM_CTLCOLOR> message, this
 *      function must return a handle of the brush that should be used to
 *      paint the control background.
 *
 *      A hook function can optionally process the <f MM_ACM_FORMATCHOOSE>
 *      message.
 *
 *  @xref <f acmFormatChoose> <t ACMFORMATCHOOSE> <f MM_ACM_FORMATCHOOSE>
 *
 ****************************************************************************/

/****************************************************************************
 *  @doc EXTERNAL ACM_API
 *
 *  @api MMRESULT | acmFormatChoose | The <f acmFormatChoose> function creates
 *      an Audio Compression Manager (ACM) defined dialog box that enables
 *      the user to select a wave format.
 *
 *  @parm LPACMFORMATCHOOSE | pfmtc | Points to an <t ACMFORMATCHOOSE>
 *      structure that contains information used to initialize the dialog
 *      box. When <f acmFormatChoose> returns, this structure contains
 *      information about the user's format selection.
 *
 *  @rdesc Returns <c MMSYSERR_NOERROR> if the function was successful.
 *      Otherwise, it returns an error value. Possible error returns are:
 *
 *      @flag MMSYSERR_INVALHANDLE | Specified handle is invalid.
 *
 *      @flag MMSYSERR_INVALFLAG | One or more flags are invalid.
 *
 *      @flag MMSYSERR_NODRIVER | A suitable driver is not available to
 *      provide valid format selections.
 *
 *      @flag MMSYSERR_INVALPARAM | One or more arguments passed are invalid.
 *
 *      @flag ACMERR_NOTPOSSIBLE | The buffer identified by the
 *      <e ACMFORMATCHOOSE.pwfx> member of the <t ACMFORMATCHOOSE> structure
 *      is too small to contain the selected format.
 *
 *      @flag ACMERR_CANCELED | The user chose the Cancel button or the
 *      Close command on the System menu to close the dialog box.
 *
 *  @comm The <e ACMFORMATCHOOSE.pwfx> member must be filled in with a valid
 *      pointer to a memory location that will contain the returned
 *      format header structure. Moreover, the <e ACMFORMATCHOOSE.cbwfx>
 *      member must be filled in with the size in bytes of this memory buffer.
 *
 *  @xref <t ACMFORMATCHOOSE> <f acmFormatChooseHookProc> <f acmFilterChoose>
 *
 ***************************************************************************/

MMRESULT ACMAPI
acmFormatChoose ( LPACMFORMATCHOOSE pfmtc )
{
    INT_PTR     iRet;
    PInstData   pInst;
#if defined(WIN32) && !defined(UNICODE)
    LPCWSTR     lpDlgTemplate = MAKEINTRESOURCEW(DLG_ACMFORMATCHOOSE_ID);
#else
    LPCTSTR     lpDlgTemplate = MAKEINTRESOURCE(DLG_ACMFORMATCHOOSE_ID);
#endif
    HINSTANCE   hInstance = NULL;
    MMRESULT    mmrResult = MMSYSERR_NOERROR;
    UINT        cbwfxEnum;

    //
    //
    //
    if (NULL == pagFindAndBoot())
    {
	DPF(1, "acmFormatChoose: NULL pag!!!");
	return (0);
    }

    /* Begin Parameter Validation */

    V_WPOINTER(pfmtc, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pfmtc, pfmtc->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(*pfmtc) > pfmtc->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatChoose: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    V_DFLAGS(pfmtc->fdwStyle, ACMFORMATCHOOSE_STYLEF_VALID, acmFormatChoose, MMSYSERR_INVALFLAG);
    V_WPOINTER(pfmtc->pwfx, pfmtc->cbwfx, MMSYSERR_INVALPARAM);
#if defined(WIN32) && !defined(UNICODE)
    V_STRINGW(pfmtc->szFormat, SIZEOFW(pfmtc->szFormat), MMSYSERR_INVALPARAM);
    V_STRINGW(pfmtc->szFormatTag, SIZEOFW(pfmtc->szFormatTag), MMSYSERR_INVALPARAM);
#else
    V_STRING(pfmtc->szFormat, SIZEOF(pfmtc->szFormat), MMSYSERR_INVALPARAM);
    V_STRING(pfmtc->szFormatTag, SIZEOF(pfmtc->szFormatTag), MMSYSERR_INVALPARAM);
#endif

    // Name parm can be NULL
    if ( pfmtc->pszName )
#if defined(WIN32) && !defined(UNICODE)
	V_STRINGW(pfmtc->pszName, (UINT)pfmtc->cchName, MMSYSERR_INVALPARAM);
#else
	V_STRING(pfmtc->pszName, (UINT)pfmtc->cchName, MMSYSERR_INVALPARAM);
#endif

    V_DFLAGS(pfmtc->fdwEnum, ACM_FORMATENUMF_VALID, acmFormatChoose, MMSYSERR_INVALFLAG);

    //
    //  validate fdwEnum and pwfxEnum so the chooser doesn't explode when
    //  an invalid combination is specified.
    //
    if (0 != (ACM_FORMATENUMF_HARDWARE & pfmtc->fdwEnum))
    {
        if (0 == ((ACM_FORMATENUMF_INPUT|ACM_FORMATENUMF_OUTPUT) & pfmtc->fdwEnum))
        {
            DebugErr(DBF_ERROR, "acmFormatChoose: ACM_FORMATENUMF_HARDWARE requires _INPUT and/or _OUTPUT flag.");
            return (MMSYSERR_INVALFLAG);
        }
    }

    cbwfxEnum = 0;
    if (0 != (pfmtc->fdwEnum & (ACM_FORMATENUMF_WFORMATTAG |
                                ACM_FORMATENUMF_NCHANNELS |
                                ACM_FORMATENUMF_NSAMPLESPERSEC |
                                ACM_FORMATENUMF_WBITSPERSAMPLE |
                                ACM_FORMATENUMF_CONVERT |
                                ACM_FORMATENUMF_SUGGEST)))
    {
        if (NULL == pfmtc->pwfxEnum)
        {
            DebugErr1(DBF_ERROR, "acmFormatChoose: specified fdwEnum (%.08lXh) flags require valid pwfxEnum.", pfmtc->fdwEnum);
            return (MMSYSERR_INVALPARAM);
        }

        if (0 == (pfmtc->fdwEnum & (ACM_FORMATENUMF_CONVERT |
                                    ACM_FORMATENUMF_SUGGEST)))
        {
            cbwfxEnum = sizeof(PCMWAVEFORMAT);
            V_RPOINTER(pfmtc->pwfxEnum, cbwfxEnum, MMSYSERR_INVALPARAM);
        }
        else
        {
            V_RWAVEFORMAT(pfmtc->pwfxEnum, MMSYSERR_INVALPARAM);
            cbwfxEnum = SIZEOF_WAVEFORMATEX(pfmtc->pwfxEnum);
        }
    }
    else
    {
        if (NULL != pfmtc->pwfxEnum)
        {
            DebugErr(DBF_ERROR, "acmFormatChoose: pwfxEnum must be NULL for specified fdwEnum flags.");
            return (MMSYSERR_INVALPARAM);
        }
    }

    // pfnHook is valid only when ENABLEHOOK is specified
    if (pfmtc->fdwStyle & ACMFORMATCHOOSE_STYLEF_ENABLEHOOK)
        V_CALLBACK((FARPROC)pfmtc->pfnHook, MMSYSERR_INVALPARAM);

    /* End Parameter Validation */

    /* Allocate a chooser Inst structure */
    pInst = NewInstance((LPBYTE)pfmtc,FORMAT_CHOOSE);
    if (!pInst)
    {
        mmrResult = MMSYSERR_NOMEM;
        goto afcexit;
    }

    pInst->cbwfxEnum = cbwfxEnum;

    hInstance = pInst->pag->hinst;
    if (pfmtc->fdwStyle & ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE)
    {
        /* ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE indicate that hInstance and
         * pszTemplateName specify a dialog template.
         */
        lpDlgTemplate = pfmtc->pszTemplateName;
        hInstance = pfmtc->hInstance;
    }


    //
    //  Restore priorities, in case another instance has modified them
    //  recently.
    //
    if( IDriverPrioritiesRestore(pInst->pag) ) {   // Something changed!
        IDriverBroadcastNotify( pInst->pag );
    }


    if (pfmtc->fdwStyle & (ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE))
    {
        /* ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE indicates that hInstance is
         * a data block containing a dialog box template.
         */
        iRet = DialogBoxIndirectParam(pInst->pag->hinst,
#ifdef WIN32
                                      (LPDLGTEMPLATE)pfmtc->hInstance,
#else
                                      pfmtc->hInstance,
#endif
                                      pfmtc->hwndOwner,
                                      NewSndDlgProc,
                                      PTR2LPARAM(pInst));

    }
    else
    {
#ifdef WIN32
	iRet = DialogBoxParamW(hInstance,
#else
        iRet = DialogBoxParam(hInstance,
#endif
                              lpDlgTemplate,
                              pfmtc->hwndOwner,
                              NewSndDlgProc,
                              PTR2LPARAM(pInst));
    }

    switch (iRet)
    {
        case -1:
            mmrResult = MMSYSERR_INVALPARAM;
            break;
        case ChooseOk:
            mmrResult = MMSYSERR_NOERROR;
            break;
        case ChooseCancel:
            mmrResult = ACMERR_CANCELED;
            break;
        case ChooseSubFailure:
            mmrResult = pInst->mmrSubFailure;
            break;
        default:
            mmrResult = MMSYSERR_NOMEM;
            break;
    }

    if (ChooseOk == iRet)
    {
        UINT                cbSize;
        LPWAVEFORMATEX      lpwfx = (LPWAVEFORMATEX)pInst->lpbSel;
        ACMFORMATDETAILS    adf;
        ACMFORMATTAGDETAILS adft;

        cbSize = SIZEOF_WAVEFORMATEX(lpwfx);

        /* pInst has a valid wave format selected */

        if (pfmtc->cbwfx > cbSize)
            pfmtc->cbwfx = cbSize;
        else if (cbSize > pfmtc->cbwfx)
        {
            mmrResult = ACMERR_NOTPOSSIBLE;
            goto afcexit;
        }

        if (!IsBadWritePtr((LPVOID)((LPWAVEFORMATEX)pfmtc->pwfx),
                           (UINT)pfmtc->cbwfx))
            _fmemcpy(pfmtc->pwfx, lpwfx, (UINT)pfmtc->cbwfx);

        _fmemset(&adft, 0, sizeof(adft));

        adft.cbStruct = sizeof(adft);
        adft.dwFormatTag = lpwfx->wFormatTag;
        if (!acmFormatTagDetails(NULL,
                                &adft,
                                ACM_FORMATTAGDETAILSF_FORMATTAG))
#ifdef WIN32
	    lstrcpyW(pfmtc->szFormatTag,adft.szFormatTag);
#else
	    lstrcpy(pfmtc->szFormatTag,adft.szFormatTag);
#endif

        adf.cbStruct      = sizeof(adf);
        adf.dwFormatIndex = 0;
        adf.dwFormatTag   = lpwfx->wFormatTag;
        adf.fdwSupport    = 0;
        adf.pwfx          = lpwfx;
        adf.cbwfx         = cbSize;

        if (!acmFormatDetails(NULL,
                              &adf,
                              ACM_FORMATDETAILSF_FORMAT))
#ifdef WIN32
	    lstrcpyW(pfmtc->szFormat,adf.szFormat);
#else
	    lstrcpy(pfmtc->szFormat,adf.szFormat);
#endif

        GlobalFreePtr(lpwfx);
    }
afcexit:
    if (pInst)
        DeleteInstance(pInst);

    return (mmrResult);
}

#ifdef WIN32
#if TRUE    // defined(UNICODE)
MMRESULT ACMAPI acmFormatChooseA
(
    LPACMFORMATCHOOSEA      pafc
)
{
    MMRESULT            mmr;
    ACMFORMATCHOOSEW    afcW;

    V_WPOINTER(pafc, sizeof(DWORD), MMSYSERR_INVALPARAM);
    V_WPOINTER(pafc, pafc->cbStruct, MMSYSERR_INVALPARAM);
    if (sizeof(*pafc) > pafc->cbStruct)
    {
        DebugErr(DBF_ERROR, "acmFormatChoose: structure size too small or cbStruct not initialized.");
        return (MMSYSERR_INVALPARAM);
    }

    memset(&afcW, 0, sizeof(afcW));

    afcW.cbStruct       = sizeof(afcW);
    afcW.fdwStyle       = pafc->fdwStyle;
    afcW.hwndOwner      = pafc->hwndOwner;
    afcW.pwfx           = pafc->pwfx;
    afcW.cbwfx          = pafc->cbwfx;

    if (NULL != pafc->pszTitle)
    {
        UINT        cb;

        cb = (lstrlenA(pafc->pszTitle) + 1) * sizeof(WCHAR);

        afcW.pszTitle = (LPCWSTR)LocalAlloc(LPTR, cb);

        if (NULL != afcW.pszTitle)
        {
            Imbstowcs((LPWSTR)afcW.pszTitle, pafc->pszTitle, cb / sizeof(WCHAR));
        }
    }

    afcW.szFormatTag[0] = '\0';
    afcW.szFormat[0]    = '\0';

    if (NULL != pafc->pszName)
    {
        afcW.pszName    = (LPWSTR)LocalAlloc(LPTR, pafc->cchName * sizeof(WCHAR));
        afcW.cchName    = pafc->cchName;

        if (NULL != afcW.pszName)
        {
            Imbstowcs(afcW.pszName, pafc->pszName, pafc->cchName);
        }
    }

    afcW.fdwEnum        = pafc->fdwEnum;
    afcW.pwfxEnum       = pafc->pwfxEnum;
    afcW.hInstance      = pafc->hInstance;

    if (0 == HIWORD(pafc->pszTemplateName))
    {
        afcW.pszTemplateName = (LPCWSTR)pafc->pszTemplateName;
    }
    else
    {
        UINT        cb;

        cb = (lstrlenA(pafc->pszTemplateName) + 1) * sizeof(WCHAR);

        afcW.pszTemplateName = (LPCWSTR)LocalAlloc(LPTR, cb);

        if (NULL != afcW.pszTemplateName)
        {
            Imbstowcs((LPWSTR)afcW.pszTemplateName, pafc->pszTemplateName, cb / sizeof(WCHAR));
        }
    }

    afcW.lCustData      = pafc->lCustData;

    //
    //  !!! wrong !!! bad curt, bad bad bad !!!
    //
    afcW.pfnHook        = (ACMFORMATCHOOSEHOOKPROCW)pafc->pfnHook;

    mmr = acmFormatChooseW(&afcW);
    if (MMSYSERR_NOERROR == mmr)
    {
        if (NULL != afcW.pszName)
        {
            Iwcstombs(pafc->pszName, afcW.pszName, pafc->cchName);
        }

        Iwcstombs(pafc->szFormatTag, afcW.szFormatTag, sizeof(pafc->szFormatTag));
        Iwcstombs(pafc->szFormat,    afcW.szFormat,    sizeof(pafc->szFormat));
    }

    if (NULL != afcW.pszName)
    {
        LocalFree((HLOCAL)afcW.pszName);
    }

    if (NULL != afcW.pszTitle)
    {
        LocalFree((HLOCAL)afcW.pszTitle);
    }

    if (0 != HIWORD(pafc->pszTemplateName))
    {
        LocalFree((HLOCAL)afcW.pszTemplateName);
    }

    return (mmr);
}
#else
MMRESULT ACMAPI acmFormatChooseW
(
    LPACMFORMATCHOOSEW      pafc
)
{
    return (MMSYSERR_ERROR);
}
#endif
#endif


/*      -       -       -       -       -       -       -       -       -   */

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | MeasureItem |
 *
 *  @parm HWND | hwnd |
 *
 *  @parm MEASUREITEMSTRUCT FAR * | lpmis |
 *
 *  @comment Do you REALLY WANT TO KNOW why this is owner draw?
 *  Because DROPDOWN LISTBOX's are bad!  You can't tell'em to use tabs!
 *
 ****************************************************************************/
BOOL FNLOCAL
MeasureItem ( HWND hwnd,
              MEASUREITEMSTRUCT FAR * lpmis )
{
    TEXTMETRIC tm;
    HDC hdc;
    HWND hwndCtrl;

    hwndCtrl = GetDlgItem(hwnd,lpmis->CtlID);

    hdc = GetWindowDC(hwndCtrl);
    
    if (NULL == hdc)
    {
        return(FALSE);
    }
    
    GetTextMetrics(hdc,(TEXTMETRIC FAR *)&tm);
    ReleaseDC(hwndCtrl,hdc);
    //Note: the "+1" is a fudge.
    lpmis->itemHeight = tm.tmAscent + tm.tmExternalLeading + 1;

    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | DrawItem |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm DRAWITEMSTRUCT FAR * | pDIS |
 *
 ****************************************************************************/
BOOL FNLOCAL
DrawItem ( PInstData pInst,
           DRAWITEMSTRUCT FAR *pDIS )
{
    HBRUSH  hbr;
    UINT    cchTextLen;
    TCHAR   szFormat[ACMFORMATDETAILS_FORMAT_CHARS];


    COLORREF crfBkPrev;         // previous HDC bkgnd color
    COLORREF crfTextPrev;       // previous HDC text color

    /* set the correct colors and draw the background */
    if (pDIS->itemState & ODS_SELECTED)
    {
        crfBkPrev = SetBkColor(pDIS->hDC,GetSysColor(COLOR_HIGHLIGHT));
        crfTextPrev = SetTextColor(pDIS->hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));
        hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
    }
    else
    {
        hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    }

    if (NULL == hbr)
    {
        return (FALSE);
    }

    switch (pDIS->itemAction)
    {
        case ODA_SELECT:
        case ODA_DRAWENTIRE:
            /* Get the text and draw it */
            FillRect(pDIS->hDC,&pDIS->rcItem,hbr);
	    cchTextLen = (UINT)ComboBox_GetLBTextLen(pDIS->hwndItem,
						     pDIS->itemID);

	    if (cchTextLen == LB_ERR || cchTextLen == 0)
                break;

	    IComboBox_GetLBText(pDIS->hwndItem,
				pDIS->itemID,
				szFormat);

            //NOTE: uiFormatTab is calculated in WM_INITDIALOG
            TabbedTextOut(pDIS->hDC,
                          pDIS->rcItem.left,
                          pDIS->rcItem.top,
                          (LPCTSTR)szFormat,
                          cchTextLen,
                          1,
                          (int FAR *)&pInst->uiFormatTab,
                          pDIS->rcItem.left);

            break;

        case ODA_FOCUS:
            DrawFocusRect(pDIS->hDC,&pDIS->rcItem);
            break;
    }

    DeleteObject(hbr);

    if (pDIS->itemState & ODS_SELECTED)
    {
        SetBkColor(pDIS->hDC, crfBkPrev);
        SetTextColor(pDIS->hDC, crfTextPrev);
    }

    return (TRUE);
} /* DrawItem() */


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | NewSndDlgProc | Dialog Procedure for the Chooser
 *
 ****************************************************************************/
INT_PTR FNWCALLBACK
NewSndDlgProc( HWND hwnd,
               unsigned msg,
               WPARAM wParam,
               LPARAM lParam )
{
    UINT        CmdCommandId;  // WM_COMMAND ID
    UINT        CmdCmd;        // WM_COMMAND Command
    PInstData   pInst;

	
    pInst = GetInstData(hwnd);

    if (pInst)
    {
        /* Pass everything to the hook function first
         */
        if (pInst->fEnableHook)
        {
            if (pInst->pfnHook)
            {
                if ((*pInst->pfnHook)(hwnd, msg, wParam, lParam))
                    return (TRUE);
            }
        }

        if (msg == pInst->uUpdateMsg)
        {
	    UpdateCustomFormats(pInst);

            return (TRUE);
        }
    }

    switch (msg)
    {

	case MM_ACM_FILTERCHOOSE: // case MM_ACM_FORMATCHOOSE:
            switch (wParam)
            {
                case FORMATCHOOSE_FORMAT_ADD:
                case FORMATCHOOSE_FORMATTAG_ADD:
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE);
                    break;

                case FORMATCHOOSE_FORMAT_VERIFY:
                case FORMATCHOOSE_FORMATTAG_VERIFY:
                case FORMATCHOOSE_CUSTOM_VERIFY:
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
                    break;
            }
            return (TRUE);

        case WM_INITDIALOG:
            /* Stuff our instance data pointer into the right place */
            if (SetInstData(hwnd,lParam))
            {
                LRESULT     lr;
#ifdef DEBUG
                DWORD       dw;

                dw = timeGetTime();
#endif

                lr = HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, InitDialog);

		//
		//  Note:  Unfortunately, I can't think of the right way
		//  to do this.  It seems as though the IDD_CMB_FORMAT control
		//  does not receive WM_SETFONT before we get WM_MEASUREITEM,
		//  so the WM_MEASUREITEM handler ends up computing a height
		//  that may not be correct.  So, I'll just make height of
		//  our owner draw format combobox the same as the height of
		//  the formattag combobox.
		//
		{
		    int i;
		
		    i = (int)SendMessage(GetDlgItem(hwnd, IDD_CMB_FORMATTAG), CB_GETITEMHEIGHT, 0, (LPARAM)0);
		    SendMessage(GetDlgItem(hwnd, IDD_CMB_FORMAT), CB_SETITEMHEIGHT, 0, (LPARAM)i);

		    i = (int)SendMessage(GetDlgItem(hwnd, IDD_CMB_FORMATTAG), CB_GETITEMHEIGHT, (WPARAM)(-1), (LPARAM)0);
		    SendMessage(GetDlgItem(hwnd, IDD_CMB_FORMAT), CB_SETITEMHEIGHT, (WPARAM)(-1), (LPARAM)i);
		}

#ifdef DEBUG
                dw = timeGetTime() - dw;
                DPF(0, "CHOOSER TIME: took %lu milliseconds to init", dw);
#endif

                return (0L != lr);
            }
            else
                EndDialog(hwnd,ChooseNoMem);
            return (TRUE);

        case WM_DESTROY:
            if (pInst)
            {
                EmptyFormats(pInst);
                UnRegisterUpdateNotify(pInst);
                RemoveInstData(hwnd);
            }
            /* We don't post quit */
            return (FALSE);

        case WM_MEASUREITEM:
            if ((int)wParam != IDD_CMB_FORMAT)
                return (FALSE);

            MeasureItem(hwnd,(MEASUREITEMSTRUCT FAR *)lParam);
            return (TRUE);

        case WM_DRAWITEM:
            if ((int)wParam != IDD_CMB_FORMAT)
                return (FALSE);

            DrawItem(pInst,(DRAWITEMSTRUCT FAR *)lParam);
            return (TRUE);


#ifdef USECONTEXTHELP

        //
        //  Notify caller of context-sensitive help messages.
        //
        case WM_CONTEXTMENU:
        case WM_HELP:
            {
                HWND hOwner;
                switch (pInst->uType)
                {
                    case FORMAT_CHOOSE:
                        hOwner = pInst->pfmtc->hwndOwner;
                        break;
                    case FILTER_CHOOSE:
                        hOwner = pInst->pafltrc->hwndOwner;
                        break;
                }
                PostMessage( hOwner,
                             (msg==WM_HELP) ? pInst->uHelpContextHelp :
                                              pInst->uHelpContextMenu,
                             wParam,
                             lParam );
                return (TRUE);
            }

#endif // USECONTEXTHELP


        case WM_COMMAND:
            CmdCommandId = GET_WM_COMMAND_ID(wParam,lParam);
            CmdCmd       = GET_WM_COMMAND_CMD(wParam,lParam);

            switch (CmdCommandId)
            {
                case IDD_BTN_HELP:
                    /* launch the default help */
                {
                    HWND hOwner;
                    switch (pInst->uType)
                    {
                        case FORMAT_CHOOSE:
                            hOwner = pInst->pfmtc->hwndOwner;
                            break;
                        case FILTER_CHOOSE:
                            hOwner = pInst->pafltrc->hwndOwner;
                            break;
                    }
                    PostMessage(hOwner,pInst->uHelpMsg,0,0L);
                    return (TRUE);
                }
                case IDOK:
                {
                    BOOL fOk;
                    fOk = pInst->lpbSel != NULL;

                    if (fOk && pInst->cchName != 0 && pInst->pszName != NULL)
                    {
                        int index;
                        index = ComboBox_GetCurSel(pInst->hCustomFormats);
                        if (index != 0 )
                        {
                            int cchBuf;
                            cchBuf = ComboBox_GetLBTextLen(pInst->hCustomFormats, index);
                            cchBuf ++;
                            if (cchBuf * sizeof(TCHAR) < pInst->cchName)
				IComboBox_GetLBTextW32(pInst->hCustomFormats,
				                       index,
				                       pInst->pszName);
                            else
                            {
                                TCHAR *pchBuf = (TCHAR*)LocalAlloc(LPTR,
                                                                   cchBuf*sizeof(TCHAR));
                                if (!pchBuf)
                                    *pInst->pszName = '\0';
                                else
                                {
				    IComboBox_GetLBText(pInst->hCustomFormats,
					                index,
                                                        pchBuf);

                                    _fmemcpy(pInst->pszName,
                                             pchBuf,
                                             (UINT)pInst->cchName);

                                    pInst->pszName[(pInst->cchName/sizeof(TCHAR))-1] = '\0';

                                    LocalFree((HLOCAL)pchBuf);
                                }
                            }
                        }
                        else
                            *pInst->pszName = '\0';
                    }
                    if (!fOk)
                    {
                        pInst->mmrSubFailure = MMSYSERR_ERROR;
                        EndDialog(hwnd,ChooseSubFailure);
                    }
                    else
                        EndDialog(hwnd,ChooseOk);
                    return (TRUE);
                }
                case IDCANCEL:
                    if (pInst->lpbSel)
                    {
                        GlobalFreePtr(pInst->lpbSel);
                        pInst->lpbSel = NULL;
                    }
                    EndDialog(hwnd,ChooseCancel);
                    return (TRUE);

                case IDD_BTN_SETNAME:
                    /* Attempt to set a new format */
                    SetName(pInst);
                    return (TRUE);

                case IDD_BTN_DELNAME:
                    /* Attempt to remove the custom format */
                    DelName(pInst);
                    return (TRUE);

                case IDD_CMB_CUSTOM:
                    if (CmdCmd == CBN_SELCHANGE)
                    {
                        int index;
                        /* CBN_SELCHANGE only comes from the user! */
                        SelectCustomFormat(pInst);
                        FindSelCustomFormat(pInst);

                        index = ComboBox_GetCurSel(pInst->hFormatTags);
                        if (ComboBox_GetItemData(pInst->hFormatTags,0) == 0)
                        {
                            int     cTags;

                            cTags = ComboBox_GetCount(pInst->hFormatTags);
                            if (cTags > 1)
                            {
                                /* We've inserted an "[unavailable]" so make
                                 * sure we remove it and reset the current
                                 * selection.
                                 */
                                if (0 != index)
                                {
                                    ComboBox_DeleteString(pInst->hFormatTags,0);
                                    ComboBox_SetCurSel(pInst->hFormatTags,index-1);
                                }
                            }
                        }
                        return (TRUE);
                    }
                    return (FALSE);

                case IDD_CMB_FORMATTAG:
                    if (CmdCmd == CBN_SELCHANGE)
                    {
                        int index;
                        index = ComboBox_GetCurSel(pInst->hFormatTags);

                        if (index == pInst->iPrevFormatTagsSel)
                            return (FALSE);

                        if (ComboBox_GetItemData(pInst->hFormatTags,0) == 0)
                        {
                            /* We've inserted an "[unavailable]" so make
                             * sure we remove it and reset the current
                             * selection.
                             */
                            ComboBox_DeleteString(pInst->hFormatTags,0);
                            ComboBox_SetCurSel(pInst->hFormatTags,index-1);
                        }

                        /* CBN_SELCHANGE only comes from the user! */
                        SelectFormatTag(pInst);

                        /* Custom Format == "<none>" */
                        ComboBox_SetCurSel(pInst->hCustomFormats,0);
                        SelectCustomFormat(pInst);

                        /* Format == first choice */
                        RefreshFormats(pInst);
                        ComboBox_SetCurSel(pInst->hFormats,0);
                        SelectFormat(pInst);

                        return (TRUE);
                    }
                    return (FALSE);

                case IDD_CMB_FORMAT:
                    if (CmdCmd == CBN_SELCHANGE)
                    {
			int index;
			
                        /* CBN_SELCHANGE only comes from the user! */
                        SelectFormat(pInst);

			/* If we have "unavailable" in list, remove it */
                        index = ComboBox_GetCurSel(pInst->hFormats);
                        if (ComboBox_GetItemData(pInst->hFormats,0) == 0)
                        {
                            int     cFormats;

                            cFormats = ComboBox_GetCount(pInst->hFormats);
                            if (cFormats > 1)
                            {
                                /* We've inserted an "[unavailable]" so make
                                 * sure we remove it and reset the current
                                 * selection.
                                 */
                                if (0 != index)
                                {
                                    ComboBox_DeleteString(pInst->hFormats,0);
                                    ComboBox_SetCurSel(pInst->hFormats,index-1);
                                }
                            }
                        }

			/* Custom Format == "<none>" */
                        ComboBox_SetCurSel(pInst->hCustomFormats,0);
                        SelectCustomFormat(pInst);

                        return (TRUE);
                    }
                    return (FALSE);
	    }
    }
    return (FALSE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SetTitle | Set the title of the dialog box if the
 *  pszTitle field is non-NULL.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SetTitle ( PInstData pInst )
{
#if defined(WIN32) && !defined(UNICODE)
    LPCWSTR  pszTitle;
#else
    LPCTSTR  pszTitle;
#endif

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
            pszTitle = (pInst->pfmtc->pszTitle);
            break;
        case FILTER_CHOOSE:
            pszTitle = (pInst->pafltrc->pszTitle);
            break;
    }

    if (pszTitle)
    {
#if defined(WIN32) && !defined(UNICODE)
	LPSTR	pstrTitle;
	UINT	cchTitle;

	cchTitle = lstrlenW(pszTitle)+1;
	pstrTitle = (LPSTR)GlobalAlloc(GPTR, cchTitle);
	if (NULL == pstrTitle)
	    return;
	Iwcstombs(pstrTitle, pszTitle, cchTitle);
        SendMessage(pInst->hwnd,WM_SETTEXT,0,(LPARAM)pstrTitle);
	GlobalFree((HGLOBAL)pstrTitle);
#else
        SendMessage(pInst->hwnd,WM_SETTEXT,0,(LPARAM)pszTitle);
#endif
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SetHelp | Hide/Show the help.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SetHelp ( PInstData pInst )
{
    BOOL        fHideHelp;
    BOOL        fCenterButtons;


#ifdef USECONTEXTHELP
    //
    //  Set the messages to send back to caller.
    //
    {
        BOOL    fContextHelp = FALSE;

        switch (pInst->uType)
        {
            case FORMAT_CHOOSE:
                if( pInst->pfmtc->fdwStyle & ACMFORMATCHOOSE_STYLEF_CONTEXTHELP )
                    fContextHelp = TRUE;
                break;

            case FILTER_CHOOSE:
                if( pInst->pafltrc->fdwStyle & ACMFILTERCHOOSE_STYLEF_CONTEXTHELP )
                    fContextHelp = TRUE;
                break;
        }

        if( fContextHelp )
        {
#if defined(WIN32) && !defined(UNICODE)
            pInst->uHelpContextMenu = RegisterWindowMessage(ACMHELPMSGCONTEXTMENUA);
            pInst->uHelpContextHelp = RegisterWindowMessage(ACMHELPMSGCONTEXTHELPA);
#else
            pInst->uHelpContextMenu = RegisterWindowMessage(ACMHELPMSGCONTEXTMENU);
            pInst->uHelpContextHelp = RegisterWindowMessage(ACMHELPMSGCONTEXTHELP);
#endif
        }
    }
#endif // USECONTEXTHELP


    //
    //  The rest of this stuff is for the STYLEF_SHOWHELP selection.
    //
    if (!pInst->hHelp)
        return;

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
            fHideHelp = !(pInst->pfmtc->fdwStyle &
                          ACMFORMATCHOOSE_STYLEF_SHOWHELP);
            fCenterButtons = fHideHelp &&
                             !(pInst->pfmtc->fdwStyle &
                               ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE);
            break;
        case FILTER_CHOOSE:
            fHideHelp = !(pInst->pafltrc->fdwStyle &
                          ACMFILTERCHOOSE_STYLEF_SHOWHELP);
            fCenterButtons = fHideHelp &&
                             !(pInst->pafltrc->fdwStyle &
                               ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE);
            break;
    }

    if (fHideHelp)
    {
        ShowWindow(pInst->hHelp,SW_HIDE);
    }
    else
    {
#if defined(WIN32) && !defined(UNICODE)
        pInst->uHelpMsg = RegisterWindowMessage(ACMHELPMSGSTRINGA);
#else
        pInst->uHelpMsg = RegisterWindowMessage(ACMHELPMSGSTRING);
#endif
    }

    /* Center OK and Cancel buttons if the default dialog template is used. */
    if (fCenterButtons)
    {
        RECT rc,rcOk,rcCancel;
        POINT pt;
#ifdef WIN32
        LONG iDlgWidth,iBtnsWidth,iRightShift;
#else
        int iDlgWidth,iBtnsWidth,iRightShift;
#endif

        GetWindowRect(pInst->hwnd,&rc);
        GetWindowRect(pInst->hOk,&rcOk);
        GetWindowRect(pInst->hCancel,&rcCancel);

        /* note: we expect Cancel to be right of Ok */

        iDlgWidth = rc.right - rc.left;
        iBtnsWidth = rcCancel.right - rcOk.left;

        iRightShift = (iDlgWidth - iBtnsWidth)/2;

        pt.x = rc.left + iRightShift;
        pt.y = rcOk.top;
        ScreenToClient(pInst->hwnd,&pt);

        MoveWindow(pInst->hOk,
                   pt.x,
                   pt.y,
                   rcOk.right-rcOk.left,
                   rcOk.bottom-rcOk.top,
                   FALSE);

        pt.x = rc.left + (rcCancel.left - rcOk.left) + iRightShift;
        pt.y = rcCancel.top;
        ScreenToClient(pInst->hwnd,&pt);

        MoveWindow(pInst->hCancel,
                   pt.x,
                   pt.y,
                   rcCancel.right-rcCancel.left,
                   rcCancel.bottom-rcCancel.top,
                   FALSE);
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | InitDialog | Initialize everything
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm HWND | hwnd |
 *
 ****************************************************************************/

LRESULT FNLOCAL InitDialog
(
    HWND                    hwnd,
    HWND                    hwndFocus,
    LPARAM                  lParam
)
{
    RECT                rc;
    BOOL                fReturn;
    PInstData           pInst;
    MMRESULT            mmrEnumStatus;
#ifdef DEBUG
    DWORD               dw;
#endif

    pInst = GetInstData(hwnd);

    pInst->hwnd = hwnd;

    pInst->hCustomFormats = GetDlgItem(hwnd,IDD_CMB_CUSTOM);
    pInst->hFormatTags = GetDlgItem(hwnd,IDD_CMB_FORMATTAG);
    pInst->hFormats = GetDlgItem(hwnd,IDD_CMB_FORMAT);

    GetWindowRect(pInst->hFormats,(RECT FAR *)&rc);
    pInst->uiFormatTab = ((rc.right - rc.left)*2)/3;

    pInst->hOk = GetDlgItem(hwnd,IDOK);
    pInst->hCancel = GetDlgItem(hwnd,IDCANCEL);
    pInst->hHelp = GetDlgItem(hwnd,IDD_BTN_HELP);
    pInst->hSetName = GetDlgItem(hwnd,IDD_BTN_SETNAME);
    pInst->hDelName = GetDlgItem(hwnd,IDD_BTN_DELNAME);

    SetTitle(pInst);
    SetHelp(pInst);

    fReturn = TRUE;

    /* give to the hook function */
    if (pInst->fEnableHook)
    {
        if (pInst->pfnHook)
        {
            switch (pInst->uType)
            {
                case FORMAT_CHOOSE:
                    lParam = pInst->pfmtc->lCustData;
                    break;

                case FILTER_CHOOSE:
                    lParam = pInst->pafltrc->lCustData;
                    break;

                default:
                    lParam = 0L;
                    break;
            }

            fReturn = FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, pInst->pfnHook);
        }
    }


#ifdef USECONTEXTHELP
    //
    //  We need to specify the DS_CONTEXTHELP dialog style in our template
    //  to get the little "?" to show up on the title bar.
    //
    {
        BOOL    fInsertContextMenu = FALSE;
        LONG    lWindowStyle;

        switch (pInst->uType)
        {
            case FORMAT_CHOOSE:
                if( pInst->pfmtc->fdwStyle & ACMFORMATCHOOSE_STYLEF_CONTEXTHELP )
                    fInsertContextMenu = TRUE;
                break;

            case FILTER_CHOOSE:
                if( pInst->pafltrc->fdwStyle & ACMFILTERCHOOSE_STYLEF_CONTEXTHELP )
                    fInsertContextMenu = TRUE;
                break;
        }

        if( fInsertContextMenu )
        {
            //
            //  Get current style, insert DS_CONTEXTHELP, set style.
            //
            lWindowStyle = GetWindowLong( pInst->hwnd, GWL_EXSTYLE );
            lWindowStyle |= WS_EX_CONTEXTHELP;
            SetWindowLong( pInst->hwnd, GWL_EXSTYLE, lWindowStyle );
        }
    }
#endif // USECONTEXTHELP


    /*
     * RefreshFormatTags is the first real call to acmFormatEnum, so we
     * need to get out fast if this fails, also pass back the error
     * we got so the user can figure out what went wrong.
     */
#ifdef DEBUG
    dw = timeGetTime();
#endif
    mmrEnumStatus = RefreshFormatTags(pInst);
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: RefreshFormatTags took %lu milliseconds", dw);
#endif

    if (mmrEnumStatus != MMSYSERR_NOERROR)
    {
        pInst->mmrSubFailure = mmrEnumStatus;
        EndDialog (hwnd,ChooseSubFailure);
        return (fReturn);
    }

#ifdef DEBUG
    dw = timeGetTime();
#endif
    RefreshFormats(pInst);
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: RefreshFormats took %lu milliseconds", dw);
#endif

#ifdef DEBUG
    dw = timeGetTime();
#endif
    InitCustomFormats(pInst);
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: InitCustomFormats took %lu milliseconds", dw);
#endif

#ifdef DEBUG
    dw = timeGetTime();
#endif
    RefreshCustomFormats(pInst,FALSE);
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: RefreshCustomFormats took %lu milliseconds", dw);
#endif

    if (pInst->hDelName)
        EnableWindow(pInst->hDelName,FALSE);

    /* Make a selection */

#ifdef DEBUG
    dw = timeGetTime();
#endif
    if (!FindInitCustomFormat(pInst))
    {
        int         cTags;
        int         n;

        ComboBox_SetCurSel(pInst->hCustomFormats,0);
        SelectCustomFormat(pInst);

        cTags = ComboBox_GetCount(pInst->hFormatTags);
        if (0 == cTags)
        {
            TagUnavailable(pInst);
        }

        //
        //  try to default to tag 1 (PCM for format, Volume for filter)
        //
        for (n = cTags; (0 != n); n--)
        {
	    INT_PTR Tag;
            Tag = ComboBox_GetItemData(pInst->hFormatTags, n);
            if (1 == Tag)
            {
                break;
            }
        }

        ComboBox_SetCurSel(pInst->hFormatTags, n);
        SelectFormatTag(pInst);

        RefreshFormats(pInst);
        ComboBox_SetCurSel(pInst->hFormats,0);
        SelectFormat(pInst);
    }
#ifdef DEBUG
    dw = timeGetTime() - dw;
    DPF(0, "    InitDialog: FindInitCustomFormat took %lu milliseconds", dw);
#endif

    RegisterUpdateNotify(pInst);

#if 0
    //
    //  why are you doing this john?? we have to allow templates to set
    //  the focus where they want it (and by the way, this is NOT how
    //  you set the initial focus during WM_INITDIALOG).
    //
    if (pInst->hOk)
        SetFocus(pInst->hOk);
#endif

    return (fReturn);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SelectCustomFormat | Process a selection from custom
 *  format combo
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SelectCustomFormat ( PInstData pInst )
{
    int             index;
    LPCustomFormat  pcf;
    LPBYTE          lpSet;

    index = ComboBox_GetCurSel(pInst->hCustomFormats);
    pcf = (LPCustomFormat)ComboBox_GetItemData(pInst->hCustomFormats,index);

    ASSERT( NULL != pcf );
    
    /* Disable delete button if [untitled] selected or
     *  a system name is selected
     */
    if (pInst->hDelName)
    {
	BOOL fDisable;

	fDisable = (index == 0) || IsSystemName(pInst, pcf->pns, 0L);
	
        if (fDisable && IsWindowEnabled(pInst->hDelName))
        {
            DWORD dwStyle;
            dwStyle = GetWindowLong(pInst->hDelName, GWL_STYLE);
            if (dwStyle & BS_DEFPUSHBUTTON)
            {
                HWND hNewDef;
                hNewDef = (IsWindowEnabled(pInst->hOk))?pInst->hOk:pInst->hCancel;
                SendMessage(pInst->hwnd, DM_SETDEFID, GetDlgCtrlID(hNewDef), 0L);
                dwStyle ^= BS_DEFPUSHBUTTON;
                Button_SetStyle(pInst->hDelName, dwStyle, TRUE);
                dwStyle = GetWindowLong(hNewDef, GWL_STYLE);
                Button_SetStyle(hNewDef, dwStyle|BS_DEFPUSHBUTTON, TRUE);
            }
            if (GetFocus() == pInst->hDelName)
                SendMessage(pInst->hwnd, WM_NEXTDLGCTL, 0, FALSE);
        }
        EnableWindow(pInst->hDelName, !fDisable);
    }


    if (pcf == pInst->pcf)
        return;

    pInst->pcf = pcf;

    if (pInst->pcf)
    {
        lpSet = CopyStruct(pInst->lpbSel,pcf->pbody,pInst->uType);
        if (lpSet)
            pInst->lpbSel = lpSet;
    }
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SelectFormatTag | Process a selection from format tag combo.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SelectFormatTag ( PInstData pInst )
{
    int         index;

    index = ComboBox_GetCurSel(pInst->hFormatTags);
    if (CB_ERR == index)
    {
        pInst->dwTag = 0L;
        return;
    }

    pInst->dwTag = (DWORD)ComboBox_GetItemData(pInst->hFormatTags,index);
    pInst->iPrevFormatTagsSel = index;
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SelectFormat | Process a selection from format combo.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SelectFormat ( PInstData pInst )
{
    int         index;
    LPBYTE      lpbytes;
    LPBYTE      lpSet;

    index = ComboBox_GetCurSel(pInst->hFormats);
    if (CB_ERR == index)
    {
        if (pInst->lpbSel)
            GlobalFreePtr(pInst->lpbSel);
        pInst->lpbSel = NULL;
        return;
    }
    lpbytes = (LPBYTE)ComboBox_GetItemData(pInst->hFormats,
                                           index);

    lpSet = CopyStruct(pInst->lpbSel,lpbytes,pInst->uType);
    if (lpSet)
    {
        pInst->lpbSel = lpSet;
    }

    EnableWindow(pInst->hOk,(NULL!=lpSet));
    EnableWindow(pInst->hSetName,(NULL!=lpSet));
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | UpdateCustomFormats | Update everything we know about
 *  custom formats.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
UpdateCustomFormats ( PInstData pInst )
{
    int index;
    PNameStore pns;

    /* 1. Empty our pool.
     * 2. Reinitialize our pool.
     * 3. Reinitialize our combobox.
     * 4. Try and reselect the same name as selected before update was called.
     */
    pns = NewNameStore(STRING_LEN);

    if (pns)
    {
        index = ComboBox_GetCurSel(pInst->hCustomFormats);
        IComboBox_GetLBText(pInst->hCustomFormats, index, pns->achName);
    }

    EmptyCustomFormats(pInst);
    InitCustomFormats(pInst);
    RefreshCustomFormats(pInst,FALSE);

    if (pns)
    {
        index = IComboBox_FindStringExact(pInst->hCustomFormats, -1,
					  pns->achName);
        if (index == CB_ERR)
            index = 0;

        DeleteNameStore(pns);
    }
    else
        index = 0;

    ComboBox_SetCurSel(pInst->hCustomFormats,index);
    SelectCustomFormat(pInst);
    FindSelCustomFormat(pInst);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | MashNameWithRate |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm PNameStore | pnsDest |
 *
 *  @parm PNameStore | pnsSrc |
 *
 *  @parm LPWAVEFORMATEX | pwfx |
 *
 ****************************************************************************/
void FNLOCAL
MashNameWithRate ( PInstData        pInst,
                   PNameStore       pnsDest,
                   PNameStore       pnsSrc,
                   LPWAVEFORMATEX   pwfx )
{
    TCHAR   szMashFmt[30];

    pnsDest->achName[0] = TEXT('\0');

    ASSERT( NULL != pInst->pag );
    if( LoadString( pInst->pag->hinst,
                    IDS_FORMAT_MASH,
                    szMashFmt,
                    SIZEOF(szMashFmt)) )
    {
        wsprintf((LPTSTR)pnsDest->achName,
                (LPTSTR)szMashFmt,
                (LPTSTR)pnsSrc->achName,
                pwfx->nAvgBytesPerSec / 1024L);
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | FindSelCustomFormat | Find the custom format based
 *  upon the current selection.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
FindSelCustomFormat ( PInstData pInst )
{
    if (pInst->pcf)
    {
        switch (pInst->uType)
        {
            case FORMAT_CHOOSE:
                FindFormat(pInst,pInst->pcf->pwfx,TRUE);
                break;
            case FILTER_CHOOSE:
                FindFilter(pInst,pInst->pcf->pwfltr,TRUE);
                break;
        }
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | FindInitCustomFormat | Initializing to a format.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @rdesc Called once, during WM_INITDIALOG, this function will set the
 *  current selections IFF the init struct has the proper flags set.
 *  Else it will return FALSE.
 *
 ****************************************************************************/
BOOL FNLOCAL
FindInitCustomFormat ( PInstData pInst )
{
    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
            if (pInst->pfmtc->fdwStyle
                & ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT)
            {
                FindFormat(pInst,pInst->pfmtc->pwfx,FALSE);
                ComboBox_SetCurSel(pInst->hCustomFormats,0);
                return (TRUE);
            }
            break;

        case FILTER_CHOOSE:
            if (pInst->pafltrc->fdwStyle
                & ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT)
            {
                FindFilter(pInst,pInst->pafltrc->pwfltr,FALSE);
                ComboBox_SetCurSel(pInst->hCustomFormats,0);
                return (TRUE);
            }
            break;
    }

    /* init to pszName */
#ifdef WIN32
    if (pInst->pszName != NULL && lstrlenW(pInst->pszName) != 0 && pInst->cchName != 0)
#else
    if (pInst->pszName != NULL && lstrlen(pInst->pszName) != 0 && pInst->cchName != 0)
#endif
    {
        int index;
        index = IComboBox_FindStringExactW32(pInst->hCustomFormats,
					     -1,
					     pInst->pszName);
         if (index == CB_ERR)
            return (FALSE);

        ComboBox_SetCurSel(pInst->hCustomFormats,index);
        SelectCustomFormat(pInst);
        FindSelCustomFormat(pInst);
        return (TRUE);
    }
    return (FALSE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | TagUnavailable | Inserts the Tag failure message.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
TagUnavailable ( PInstData pInst )
{
    int index;
    /* Select [not available] for format tag */
    LoadString(pInst->pag->hinst,
               IDS_TXT_UNAVAILABLE,
               (LPTSTR)pInst->pnsTemp->achName,
               NAMELEN(pInst->pnsTemp));
    index = IComboBox_InsertString(pInst->hFormatTags,
				   0,
				   pInst->pnsTemp->achName);
    ComboBox_SetItemData(pInst->hFormatTags,index,NULL);
}

void FNLOCAL
FormatUnavailable ( PInstData pInst)
{
    int index;
    LoadString(pInst->pag->hinst,
               IDS_TXT_UNAVAILABLE,
               (LPTSTR)pInst->pnsTemp->achName,
               NAMELEN(pInst->pnsTemp));
    index = IComboBox_InsertString(pInst->hFormats,
				   0,
				   pInst->pnsTemp->achName);
    ComboBox_SetItemData(pInst->hFormats,index,NULL);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNLOCAL | FindFormat | Finds the format string that matches a
 *  format in the comboboxes. Defaults to the first element in the comboboxes.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPWAVEFORMATEX | pwfx |
 *
 *  @parm BOOL | fExact |
 *
 ****************************************************************************/
BOOL FNLOCAL
FindFormat( PInstData       pInst,
            LPWAVEFORMATEX  pwfx,
            BOOL            fExact )
{
    int                 index;
    BOOL                fOk;
    ACMFORMATTAGDETAILS adft;
    MMRESULT            mmr;
    ACMFORMATDETAILS    adf;

    PNameStore pns = pInst->pnsTemp;

    /* Adjust the Format and FormatTag comboboxes to correspond to the
     * Custom Format selection
     */
    _fmemset(&adft, 0, sizeof(adft));

    adft.cbStruct = sizeof(adft);
    adft.dwFormatTag = pwfx->wFormatTag;
    mmr = acmFormatTagDetails(NULL, &adft, ACM_FORMATTAGDETAILSF_FORMATTAG);
    fOk = (MMSYSERR_NOERROR == mmr);
    if (fOk)
    {
        index = IComboBox_FindStringExactW32(pInst->hFormatTags,
					     -1,
					     adft.szFormatTag);
        fOk = (CB_ERR != index);
    }

    index = fOk?index:0;

    if (!fOk && fExact && ComboBox_GetItemData(pInst->hFormatTags,0))
        TagUnavailable(pInst);

    ComboBox_SetCurSel(pInst->hFormatTags,index);
    SelectFormatTag((PInstData)pInst);

    RefreshFormats((PInstData)pInst);

    if (fOk)
    {
        //
        //
        //
        adf.cbStruct      = sizeof(adf);
        adf.dwFormatIndex = 0;
        adf.dwFormatTag   = pwfx->wFormatTag;
        adf.fdwSupport    = 0;
        adf.pwfx          = pwfx;
        adf.cbwfx         = SIZEOF_WAVEFORMATEX(pwfx);

        mmr = acmFormatDetails(NULL, &adf, ACM_FORMATDETAILSF_FORMAT);

        fOk = (MMSYSERR_NOERROR == mmr);
        if (fOk)
        {
#if defined(WIN32) && !defined(UNICODE)
	    Iwcstombs(pns->achName, adf.szFormat, pns->cbSize);
#else
            lstrcpy(pns->achName, adf.szFormat);
#endif
            MashNameWithRate(pInst,pInst->pnsStrOut,pns,pwfx);
            index = IComboBox_FindStringExact(pInst->hFormats,-1,
					      pInst->pnsStrOut->achName);

            fOk = (CB_ERR != index);
        }
        index = fOk?index:0;
    }
    if (!fOk && fExact && ComboBox_GetItemData(pInst->hFormats,0))
    {
        FormatUnavailable(pInst);
    }

    ComboBox_SetCurSel(pInst->hFormats,index);
    SelectFormat((PInstData)pInst);

    return (fOk);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void | FindFilter | Finds the format string that matches a format in
 *  the comboboxes. Defaults to the first element in the comboboxes
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 *  @parm LPWAVEFILTER | pwf |
 *
 *  @parm BOOL | fExact |
 *
 ****************************************************************************/
BOOL FNLOCAL
FindFilter ( PInstData      pInst,
             LPWAVEFILTER   pwf,
             BOOL           fExact )
{
    int                 index;
    BOOL                fOk;
    ACMFILTERTAGDETAILS adft;
    MMRESULT            mmr;
    ACMFILTERDETAILS    adf;

    /* Adjust the Filter and FilterTag comboboxes to correspond to the
     * Custom Filter selection
     */
    _fmemset(&adft, 0, sizeof(adft));

    adft.cbStruct = sizeof(adft);
    adft.dwFilterTag = pwf->dwFilterTag;
    mmr = acmFilterTagDetails(NULL,
                               &adft,
                               ACM_FILTERTAGDETAILSF_FILTERTAG);
    fOk = (MMSYSERR_NOERROR == mmr);
    if (fOk)
    {
        index = IComboBox_FindStringExactW32(pInst->hFormatTags,
					     -1,
					     adft.szFilterTag);
        fOk = (CB_ERR != index);
    }

    index = fOk?index:0;

    if (!fOk && fExact && ComboBox_GetItemData(pInst->hFormatTags,0))
        TagUnavailable(pInst);

    ComboBox_SetCurSel(pInst->hFormatTags,index);
    SelectFormatTag((PInstData)pInst);

    RefreshFormats((PInstData)pInst);

    if (fOk)
    {
        //
        //
        //
        adf.cbStruct      = sizeof(adf);
        adf.dwFilterIndex = 0;
        adf.dwFilterTag   = pwf->dwFilterTag;
        adf.fdwSupport    = 0;
        adf.pwfltr        = pwf;
        adf.cbwfltr       = pwf->cbStruct;

        mmr = acmFilterDetails(NULL, &adf, ACM_FILTERDETAILSF_FILTER);
        fOk = (MMSYSERR_NOERROR == mmr);
        if (fOk)
        {
	    index = IComboBox_FindStringExactW32(pInst->hFormats, -1, adf.szFilter);

            fOk = (CB_ERR != index);
        }
        index = fOk?index:0;
    }

    ComboBox_SetCurSel(pInst->hFormats,index);
    SelectFormat((PInstData)pInst);
    return (TRUE);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | RefreshCustomFormats | Fills the CustomFormat combo
 *  with custom formats.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
BOOL FNLOCAL
InEnumSet (PInstData pInst, LPWAVEFORMATEX pwfxCustom, LPWAVEFORMATEX pwfxBuf, DWORD cbSize);

void FNLOCAL
RefreshCustomFormats ( PInstData pInst , BOOL fCheckEnum )
{
    LPCustomFormat  pcf;
    int             index;

    MMRESULT        mmr;

    ASSERT( NULL != pInst->pag);

    SetWindowRedraw(pInst->hCustomFormats,FALSE);

    ComboBox_ResetContent(pInst->hCustomFormats);

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
        {
            DWORD           cbwfx;
            DWORD           cbwfxCustom;
            LPWAVEFORMATEX  pwfx;

            mmr = IMetricsMaxSizeFormat( pInst->pag, NULL, &cbwfx );
            if (MMSYSERR_NOERROR != mmr)
                goto fexit;

            pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)cbwfx);
            if (!pwfx)
                goto fexit;

//#pragma message(REMIND("Speed up InEnumSet or Yield"))
            for (pcf = pInst->cfp.pcfHead; pcf != NULL; pcf = pcf->pcfNext )
            {
                cbwfxCustom = SIZEOF_WAVEFORMATEX(pcf->pwfx);
                if (cbwfx < cbwfxCustom)
                {
                    LPWAVEFORMATEX  pwfxCustom;

                    pwfxCustom = GlobalReAllocPtr(pwfx, cbwfxCustom, GHND);
                    if (NULL == pwfxCustom)
                        break;

                    pwfx  = pwfxCustom;
                    cbwfx = cbwfxCustom;
                }

                if (fCheckEnum && !InEnumSet(pInst, pcf->pwfx, pwfx, cbwfx))
                    continue;

                if (pInst->fEnableHook &&
                    !SendMessage(pInst->hwnd,
                                 MM_ACM_FORMATCHOOSE,
                                 FORMATCHOOSE_CUSTOM_VERIFY,
                                 (LPARAM)pcf->pbody))
                    continue;

                index = IComboBox_AddString(pInst->hCustomFormats,
					    pcf->pns->achName);
                ComboBox_SetItemData(pInst->hCustomFormats,index, (LPARAM)pcf);
            }
            GlobalFreePtr(pwfx);
            break;
        }
        case FILTER_CHOOSE:
        {
            for (pcf = pInst->cfp.pcfHead; pcf != NULL; pcf = pcf->pcfNext )
            {
                if (fCheckEnum &&
                    (pInst->pafltrc->fdwEnum & ACM_FILTERENUMF_DWFILTERTAG))
                {
                    /* considerably easier than the format stuff.
                     * just check to see if the filter tag matches.
                     */
                    if (pInst->pafltrc->pwfltrEnum->dwFilterTag !=
                        pcf->pwfltr->dwFilterTag)
                        continue;
                }

                if (pInst->fEnableHook &&
                    !SendMessage(pInst->hwnd,
                                 MM_ACM_FILTERCHOOSE,
                                 FILTERCHOOSE_CUSTOM_VERIFY,
                                 (LPARAM)pcf->pbody))
                    continue;

                index = IComboBox_AddString(pInst->hCustomFormats,
					    pcf->pns->achName);
                ComboBox_SetItemData(pInst->hCustomFormats,index,(LPARAM)pcf);
            }
            break;
        }
    }

    /* Insert the "[untitled]" selection at the top.
     */
    LoadString(pInst->pag->hinst, IDS_TXT_UNTITLED, (LPTSTR)pInst->pnsTemp->achName,
               NAMELEN(pInst->pnsTemp));

    index = IComboBox_InsertString(pInst->hCustomFormats,0,
				   pInst->pnsTemp->achName);

    ComboBox_SetItemData(pInst->hCustomFormats,index,0L);

fexit:
    SetWindowRedraw(pInst->hCustomFormats,TRUE);
}
/*
 * N = number of custom formats.
 * K = number of formats in the enumeration.
 */

/* slow method.
 * FOREACH format, is there a matching format in the enumeration?
 * cost? - Many calls to enumeration apis as N increases (linear search).
 * O(N)*O(K)
 * Best case:   All formats hit early in the enumeration. < O(K) multiplier
 * Worst case:  All formats hit late in the enumeration.  Hard O(K)*O(N)
 */
/* alternate method.
 * FOREACH enumerated format, is there a hit in the custom formats?
 * cost? - Call to lookup function for all enumerated types.
 * O(K)*O(N)
 * Best case:   A cheap lookup will mean < O(N) multiplier
 * Worst case:  Hard O(K)*O(N)
 */
typedef struct tResponse {
    LPWAVEFORMATEX pwfx;
    BOOL fHit;
} Response ;

BOOL FNWCALLBACK
CustomCallback ( HACMDRIVERID           hadid,
                 LPACMFORMATDETAILS     pafd,
                 DWORD_PTR              dwInstance,
                 DWORD                  fdwSupport )
{
    Response FAR * presp = (Response FAR *)dwInstance;
    if (_fmemcmp(presp->pwfx,pafd->pwfx,SIZEOF_WAVEFORMATEX(presp->pwfx)) == 0)
    {
        presp->fHit = TRUE;
        return (FALSE);
    }
    return (TRUE);
}

BOOL FNLOCAL
InEnumSet (PInstData        pInst,
           LPWAVEFORMATEX   pwfxCustom,
           LPWAVEFORMATEX   pwfxBuf,
           DWORD            cbwfx )
{
    ACMFORMATDETAILS    afd;
    DWORD               cbSize;
    DWORD               dwEnumFlags;
    BOOL                fOk;
    Response            resp;
    Response FAR *     presp;

    _fmemset(&afd, 0, sizeof(afd));

    afd.cbStruct    = sizeof(afd);
    afd.pwfx        = pwfxBuf;
    afd.cbwfx       = cbwfx;
    dwEnumFlags     = pInst->pfmtc->fdwEnum;

    /* optional filtering for a waveformat template */
    if ( pInst->pfmtc->pwfxEnum )
    {
        cbSize = min (pInst->cbwfxEnum, afd.cbwfx );
        _fmemcpy(afd.pwfx, pInst->pfmtc->pwfxEnum, (UINT)cbSize);
    }

    if (dwEnumFlags & (ACM_FORMATENUMF_CONVERT | ACM_FORMATENUMF_SUGGEST))
    {
        ;
    }
    else
    {
        /* if we don't really need this information, we can use
         * it to restrict the enumeration and hopefully speed things
         * up.
         */
        dwEnumFlags |= ACM_FORMATENUMF_WFORMATTAG;
        afd.pwfx->wFormatTag = pwfxCustom->wFormatTag;
        dwEnumFlags |= ACM_FORMATENUMF_NCHANNELS;
        afd.pwfx->nChannels = pwfxCustom->nChannels;
        dwEnumFlags |= ACM_FORMATENUMF_NSAMPLESPERSEC;
        afd.pwfx->nSamplesPerSec = pwfxCustom->nSamplesPerSec;
        dwEnumFlags |= ACM_FORMATENUMF_WBITSPERSAMPLE;
        afd.pwfx->wBitsPerSample = pwfxCustom->wBitsPerSample;
    }

    resp.fHit = FALSE;
    resp.pwfx = pwfxCustom;

    afd.dwFormatTag = afd.pwfx->wFormatTag;

    presp = &resp;
    fOk = (acmFormatEnum(NULL,
                         &afd,
                         CustomCallback,
                         (LPARAM)presp,
                         dwEnumFlags)== 0L);

    return (resp.fHit);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | RefreshFormatTags |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
MMRESULT FNLOCAL
RefreshFormatTags ( PInstData pInst )
{
    MMRESULT    mmr;
    DWORD       dwEnumFlags = 0L;
    MMRESULT    mmrEnumStatus = MMSYSERR_NOERROR;

    ASSERT( NULL != pInst->pag );

    SetWindowRedraw(pInst->hFormatTags,FALSE);

    ComboBox_ResetContent(pInst->hFormatTags);

    switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
        {
            ACMFORMATDETAILS    afd;
            LPWAVEFORMATEX      pwfx;
            DWORD               cbSize;

            /*
             * Enumerate the format tags for the FormatTag combobox.
             * This might seem weird, to call acmFormatEnum, but we have
             * to because it has the functionality to restrict formats and
             * acmFormatTagEnum doesn't.
             */

            _fmemset(&afd, 0, sizeof(afd));

            mmr = IMetricsMaxSizeFormat( pInst->pag, NULL, &afd.cbwfx );
            if (MMSYSERR_NOERROR == mmr)
            {
                afd.cbwfx = max(afd.cbwfx, pInst->cbwfxEnum);

                pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)afd.cbwfx);
                if (!pwfx)
                    break;

                afd.cbStruct    = sizeof(afd);
                afd.pwfx        = pwfx;

                /* optional filtering for a waveformat template */
                if ( pInst->pfmtc->pwfxEnum )
                {
                    cbSize = min (pInst->cbwfxEnum, afd.cbwfx);
                    _fmemcpy(pwfx, pInst->pfmtc->pwfxEnum, (UINT)cbSize);
                    afd.dwFormatTag = pwfx->wFormatTag;
                }

                dwEnumFlags = pInst->pfmtc->fdwEnum;

                if (0 == (dwEnumFlags & (ACM_FORMATENUMF_CONVERT |
                                         ACM_FORMATENUMF_SUGGEST)))
                {
                    ACMFORMATTAGDETAILS aftd;

                    _fmemset(&aftd, 0, sizeof(aftd));

                    /* Enumerate the format tags */
                    aftd.cbStruct = sizeof(aftd);

                    /* Was a format tag specified?
                    * This means they only want one format tag.
                    */
                    pInst->fTagFilter = (pInst->pfmtc->pwfxEnum &&
                                        (pInst->pfmtc->fdwEnum & ACM_FORMATENUMF_WFORMATTAG));

                    pInst->pafdSimple = &afd;

                    mmrEnumStatus = acmFormatTagEnum(NULL,
                                                     &aftd,
                                                     FormatTagsCallbackSimple,
                                                     PTR2LPARAM(pInst),
                                                     0L);
                    pInst->pafdSimple = NULL;
                }
                else
                {
                    mmrEnumStatus = acmFormatEnum(NULL,
                                                  &afd,
                                                  FormatTagsCallback,
                                                  PTR2LPARAM(pInst),
                                                  dwEnumFlags);
                }

                if (MMSYSERR_NOERROR == mmrEnumStatus)
                {
                    //
                    //  add format that we are asked to init to (this has every
                    //  chance of being a 'non-standard' format, so we have to do
                    //  this in the following way..)
                    //
                    if (0 != (ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT & pInst->pfmtc->fdwStyle))
                    {
                        afd.cbStruct    = sizeof(afd);
                        afd.dwFormatTag = pInst->pfmtc->pwfx->wFormatTag;
                        afd.pwfx        = pInst->pfmtc->pwfx;
                        afd.cbwfx       = SIZEOF_WAVEFORMATEX(pInst->pfmtc->pwfx);
                        afd.fdwSupport  = 0L;

                        mmr = acmFormatDetails(NULL, &afd, ACM_FORMATDETAILSF_FORMAT);
                        if (MMSYSERR_NOERROR == mmr)
                        {
                            FormatTagsCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                        }
                    }

                    //
                    //
                    //
                    if (0 != (pInst->pfmtc->fdwEnum & (ACM_FORMATENUMF_CONVERT |
                                                       ACM_FORMATENUMF_SUGGEST)))
                    {
                        afd.cbStruct    = sizeof(afd);
                        afd.dwFormatTag = pInst->pfmtc->pwfxEnum->wFormatTag;
                        afd.pwfx        = pInst->pfmtc->pwfxEnum;
                        afd.cbwfx       = SIZEOF_WAVEFORMATEX(pInst->pfmtc->pwfxEnum);
                        afd.fdwSupport  = 0L;

                        mmr = acmFormatDetails(NULL, &afd, ACM_FORMATDETAILSF_FORMAT);
                        if (MMSYSERR_NOERROR == mmr)
                        {
                            FormatTagsCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                        }
                    }
                }
                GlobalFreePtr(pwfx);
            }
            break;
        }
        case FILTER_CHOOSE:
        {
            ACMFILTERTAGDETAILS aftd;

            _fmemset(&aftd, 0, sizeof(aftd));

            /* Enumerate the filter tags */
            aftd.cbStruct = sizeof(aftd);

            /* Was a filter tag specified?
             * This means they only want one filter tag.
             */
            pInst->fTagFilter = (pInst->pafltrc->pwfltrEnum &&
                                 (pInst->pafltrc->fdwEnum & ACM_FILTERENUMF_DWFILTERTAG));

            mmrEnumStatus = acmFilterTagEnum(NULL,
                                              &aftd,
                                              FilterTagsCallback,
                                              PTR2LPARAM(pInst),
                                              dwEnumFlags);
            if (MMSYSERR_NOERROR == mmrEnumStatus)
            {
                //
                //  add filter that we are asked to init to (this has every
                //  chance of being a 'non-standard' filter, so we have to do
                //  this in the following way..)
                //
                if (0 != (ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT & pInst->pafltrc->fdwStyle))
                {
                    _fmemset(&aftd, 0, sizeof(aftd));

                    aftd.cbStruct    = sizeof(aftd);
                    aftd.dwFilterTag = pInst->pafltrc->pwfltr->dwFilterTag;

                    mmr = acmFilterTagDetails(NULL, &aftd, ACM_FILTERTAGDETAILSF_FILTERTAG);
                    if (MMSYSERR_NOERROR == mmr)
                    {
                        FilterTagsCallback(NULL, &aftd, PTR2LPARAM(pInst), aftd.fdwSupport);
                    }
                }
            }
            break;
        }
    }

    if (MMSYSERR_NOERROR == mmrEnumStatus)
    {
        /*
         * perhaps we made it through but, darn it, we just didn't find
         * any suitable tags!  Well there must not have been an acceptable
         * driver configuration.  We just quit and tell the caller.
         */
        if (ComboBox_GetCount(pInst->hFormatTags) == 0)
            mmrEnumStatus = MMSYSERR_NODRIVER;
    }

    SetWindowRedraw(pInst->hFormatTags,TRUE);
    return (mmrEnumStatus);
}


//--------------------------------------------------------------------------;
//
//  BOOL FormatTagsCallbackSimpleOnlyOne
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPACMFORMATDETAILS pafd:
//
//      DWORD_PTR dwInstance:
//
//      DWORD fdwSupport:
//
//  Return (BOOL):
//
//
//--------------------------------------------------------------------------;

BOOL FNWCALLBACK FormatTagsCallbackSimpleOnlyOne
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILS      pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    //
    //  only need ONE callback!
    //
    *((LPDWORD)dwInstance) = 1;

    DPF(1, "FormatTagsCallbackSimpleOnlyOne: %lu, %s", pafd->dwFormatTag, pafd->szFormat);

    return (FALSE);
} // FormatTagsCallbackSimpleOnlyOne()


//--------------------------------------------------------------------------;
//
//  BOOL FormatTagsCallbackSimple
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      LPACMFILTERTAGDETAILS paftd:
//
//      DWORD_PTR dwInstance:
//
//      DWORD fdwSupport:
//
//  Return (BOOL):
//
//
//--------------------------------------------------------------------------;

BOOL FNWCALLBACK FormatTagsCallbackSimple
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    MMRESULT            mmr;
    int                 n;
    PInstData           pInst;
    LPWAVEFORMATEX	pwfxSave;
    DWORD		cbwfxSave;
    BOOL                f;
    DWORD               dw;

    //
    //
    //
    pInst = (PInstData)LPARAM2PTR(dwInstance);

    /* Explicitly filtering for a tag?
     */
    if (pInst->fTagFilter && (paftd->dwFormatTag != pInst->pfmtc->pwfxEnum->wFormatTag))
        return (TRUE);

    n = IComboBox_FindStringExactW32(pInst->hFormatTags, -1, paftd->szFormatTag);
    if (CB_ERR != n)
    {
        return (TRUE);
    }

    dw = 0;
    pInst->pafdSimple->dwFormatTag = paftd->dwFormatTag;
    pInst->pafdSimple->fdwSupport  = 0L;
    pInst->pafdSimple->pwfx->wFormatTag = (UINT)paftd->dwFormatTag;

    //
    //
    //
    cbwfxSave = pInst->pafdSimple->cbwfx;
    pwfxSave = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfxSave);
    if (NULL == pwfxSave) {
	return (TRUE);
    }
    _fmemcpy(pwfxSave, pInst->pafdSimple->pwfx, (int)cbwfxSave);

    mmr = acmFormatEnum(NULL,
                        pInst->pafdSimple,
                        FormatTagsCallbackSimpleOnlyOne,
                        (DWORD_PTR)(LPDWORD)&dw,
                        pInst->pfmtc->fdwEnum | ACM_FORMATENUMF_WFORMATTAG);

    _fmemcpy(pInst->pafdSimple->pwfx, pwfxSave, (int)cbwfxSave);
    GlobalFreePtr(pwfxSave);

    //
    //
    //
    if (0 == dw)
    {
        return (TRUE);
    }

    //
    //
    //
    if (pInst->fEnableHook)
    {
        f = (BOOL)SendMessage(pInst->hwnd,
                              MM_ACM_FORMATCHOOSE,
                              FORMATCHOOSE_FORMATTAG_VERIFY,
                              (LPARAM)paftd->dwFormatTag);
        if (!f)
        {
            return (TRUE);
        }
    }

    n = IComboBox_AddStringW32(pInst->hFormatTags, paftd->szFormatTag);
    ComboBox_SetItemData(pInst->hFormatTags, n, paftd->dwFormatTag);

    // Keep going
    return (TRUE);
} // FormatTagsCallbackSimple()



/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | FormatTagsCallback | Callback entry point for
 *  format tags.  We only enumerate formats upon refresh.
 *
 ****************************************************************************/

BOOL FNWCALLBACK
FormatTagsCallback ( HACMDRIVERID           hadid,
                     LPACMFORMATDETAILS     pafd,
                     DWORD_PTR              dwInstance,
                     DWORD                  fdwSupport )
{
    int                 index;
    PInstData           pInst = (PInstData)LPARAM2PTR(dwInstance);
    ACMFORMATTAGDETAILS aftd;
    MMRESULT            mmr;

    /* We are being called by acmFormatEnum.  Why not acmFormatTagEnum?
     * because we can't enumerate tags based upon the same restrictions
     * as acmFormatEnum.  So we use the pwfx->wFormatTag and lookup
     * the combobox to determine if we've had a hit.  This is slow, but
     * it only happens once during initialization.
     */

    _fmemset(&aftd, 0, sizeof(aftd));
    aftd.cbStruct = sizeof(aftd);
    aftd.dwFormatTag = pafd->pwfx->wFormatTag;

    mmr = acmFormatTagDetails(NULL,
                              &aftd,
                              ACM_FORMATTAGDETAILSF_FORMATTAG);
    if (MMSYSERR_NOERROR != mmr)
        return (TRUE);

    index = IComboBox_FindStringExactW32(pInst->hFormatTags,
					 -1,
					 aftd.szFormatTag);

    /*
     * if this isn't there try to add it.
     */
    if (CB_ERR == index)
    {
        /*
         * Ask any hook proc's to verify this tag.
         */
        if (pInst->fEnableHook &&
            !SendMessage(pInst->hwnd,
                         MM_ACM_FORMATCHOOSE,
                         FORMATCHOOSE_FORMATTAG_VERIFY,
                         (LPARAM)aftd.dwFormatTag))
            return (TRUE);

	index = IComboBox_AddStringW32(pInst->hFormatTags, aftd.szFormatTag);
        ComboBox_SetItemData(pInst->hFormatTags,index, aftd.dwFormatTag);

    }

    /* Keep going
     */
    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void | FilterTagsCallback | Callback entry point for filter tags.
 *  We only enumerate formats upon refresh.
 *
 ****************************************************************************/
BOOL FNWCALLBACK
FilterTagsCallback ( HACMDRIVERID           hadid,
                     LPACMFILTERTAGDETAILS  paftd,
                     DWORD_PTR              dwInstance,
                     DWORD                  fdwSupport )
{
    int             index;
    PInstData       pInst = (PInstData)LPARAM2PTR(dwInstance);

    /* Explicitly filtering for a tag?
     */
    if (pInst->fTagFilter &&
        paftd->dwFilterTag != pInst->pafltrc->pwfltrEnum->dwFilterTag)
        return (TRUE);

    index = IComboBox_FindStringExactW32(pInst->hFormatTags, -1, paftd->szFilterTag);

    /*
     * if this isn't there try to add it.
     */
    if (CB_ERR == index)
    {
        if (pInst->fEnableHook &&
            !SendMessage(pInst->hwnd,
                        MM_ACM_FILTERCHOOSE,
                        FILTERCHOOSE_FILTERTAG_VERIFY,
                        (LPARAM)paftd->dwFilterTag))
            return (TRUE);

	index = IComboBox_AddStringW32(pInst->hFormatTags, paftd->szFilterTag);
        ComboBox_SetItemData(pInst->hFormatTags,index, paftd->dwFilterTag);
    }

    // Keep going
    return (TRUE);
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | RefreshFormats |
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
RefreshFormats ( PInstData pInst )
{
    BOOL            fOk;
    HCURSOR         hCur;
    MMRESULT        mmr;
    DWORD           dwEnumFlags;
    DWORD           cbSize;

    ASSERT( NULL != pInst->pag );

    hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));

    SetWindowRedraw(pInst->hFormats,FALSE);

    /* Remove all wave formats */
    EmptyFormats(pInst);

    ComboBox_ResetContent(pInst->hFormats);

    /* Brief explanation:
     *  RefreshFormats() updates the Format/Filter combobox.  This
     *  combobox is *THE* selection for the dialog.  This is where we
     *  call the enumeration API's to limit the user's selection.
     *
     *  IF the user has passed in fdwEnum flags to "match", we just copy
     *  the p*Enum add our current tag and OR the ACM_*ENUMF_*TAG flag
     *  to their fdwEnum flags.
     *
     *  IF the user has passed in fdwEnum flags to convert or suggest,
     *  we just let it go untouched through the acmFormatEnum API.
     */

    fOk = (pInst->dwTag != 0L);
    /* If there's an evil tag selected.  Just skip this junk
     */

    if (fOk)
        switch (pInst->uType)
    {
        case FORMAT_CHOOSE:
        {
            ACMFORMATDETAILS    afd;
            LPWAVEFORMATEX      pwfx;

            fOk = FALSE;

            mmr = IMetricsMaxSizeFormat( pInst->pag, NULL, &afd.cbwfx );
            if (MMSYSERR_NOERROR == mmr)
            {
                afd.cbwfx = max(afd.cbwfx, pInst->cbwfxEnum);

                pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)afd.cbwfx);
                if (NULL == pwfx)
                    break;

                afd.cbStruct    = sizeof(afd);
                afd.pwfx        = pwfx;
                afd.fdwSupport  = 0L;

                /* optional filtering for a waveformat template */
                if ( pInst->pfmtc->pwfxEnum )
                {
                    cbSize = min(pInst->cbwfxEnum, afd.cbwfx);
                    _fmemcpy(pwfx, pInst->pfmtc->pwfxEnum, (UINT)cbSize);
                }

                dwEnumFlags = pInst->pfmtc->fdwEnum;

                fOk = TRUE;

                if ( pInst->pfmtc->fdwEnum &
                     (ACM_FORMATENUMF_CONVERT | ACM_FORMATENUMF_SUGGEST))
                {
                    /* enumerate over all formats and exclude
                     * undesireable ones in the callback.
                     */
                    ;
                }
                else
                {
                    /* enumerate over only ONE format
                     */
                    dwEnumFlags |= ACM_FORMATENUMF_WFORMATTAG;
                    afd.pwfx->wFormatTag = (WORD)pInst->dwTag;
                }

                afd.dwFormatTag = pwfx->wFormatTag;

                fOk = (acmFormatEnum(NULL,
                                    &afd,
                                    FormatsCallback,
                                    PTR2LPARAM(pInst),
                                    dwEnumFlags)== 0L);

                GlobalFreePtr(pwfx);
            }

            //
            //  add format that we are asked to init to (this has every
            //  chance of being a 'non-standard' format, so we have to do
            //  this in the following way..)
            //
            if (0 != (ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT & pInst->pfmtc->fdwStyle))
            {
                if (pInst->pfmtc->pwfx->wFormatTag == (WORD)pInst->dwTag)
                {
                    afd.cbStruct    = sizeof(afd);
                    afd.dwFormatTag = pInst->dwTag;
                    afd.pwfx        = pInst->pfmtc->pwfx;
                    afd.cbwfx       = SIZEOF_WAVEFORMATEX(pInst->pfmtc->pwfx);
                    afd.fdwSupport  = 0L;

                    mmr = acmFormatDetails(NULL, &afd, ACM_FORMATDETAILSF_FORMAT);
                    if (MMSYSERR_NOERROR == mmr)
                    {
                        FormatsCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                    }
                }
            }

            //
            //
            //
            if (0 != (pInst->pfmtc->fdwEnum & (ACM_FORMATENUMF_CONVERT |
                                               ACM_FORMATENUMF_SUGGEST)))
            {
                if (pInst->pfmtc->pwfxEnum->wFormatTag == (WORD)pInst->dwTag)
                {
                    afd.cbStruct    = sizeof(afd);
                    afd.dwFormatTag = pInst->dwTag;
                    afd.pwfx        = pInst->pfmtc->pwfxEnum;
                    afd.cbwfx       = SIZEOF_WAVEFORMATEX(pInst->pfmtc->pwfxEnum);
                    afd.fdwSupport  = 0L;

                    mmr = acmFormatDetails(NULL, &afd, ACM_FORMATDETAILSF_FORMAT);
                    if (MMSYSERR_NOERROR == mmr)
                    {
                        FormatsCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                    }
                }
            }
            break;
        }
        case FILTER_CHOOSE:
        {
            ACMFILTERDETAILS    afd;
            LPWAVEFILTER         pwfltr;

            fOk = FALSE;

            mmr = IMetricsMaxSizeFilter( pInst->pag, NULL, &afd.cbwfltr );
            if (MMSYSERR_NOERROR == mmr)
            {
                afd.cbwfltr = max(afd.cbwfltr, pInst->cbwfltrEnum);

                pwfltr = (LPWAVEFILTER)GlobalAllocPtr(GHND, (UINT)afd.cbwfltr);
                if (NULL != pwfltr)
                {
                    afd.cbStruct   = sizeof(afd);
                    afd.pwfltr     = pwfltr;
                    afd.fdwSupport = 0L;

                    /* optional filtering for a wavefilter template */
                    if ( pInst->pafltrc->pwfltrEnum )
                    {
                        cbSize = pInst->pafltrc->pwfltrEnum->cbStruct;
                        cbSize = min (cbSize, afd.cbwfltr);
                        _fmemcpy(pwfltr, pInst->pafltrc->pwfltrEnum, (UINT)cbSize);
                    }

                    dwEnumFlags = ACM_FILTERENUMF_DWFILTERTAG;
                    afd.pwfltr->dwFilterTag = pInst->dwTag;

                    fOk = (acmFilterEnum(NULL,
                                         &afd,
                                         FiltersCallback,
                                         PTR2LPARAM(pInst),
                                         dwEnumFlags) == 0L);
                    GlobalFreePtr(pwfltr);
                }
            }

            //
            //  add filter that we are asked to init to (this has every
            //  chance of being a 'non-standard' filter, so we have to do
            //  this in the following way..)
            //
            if (0 != (ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT & pInst->pafltrc->fdwStyle))
            {
                if (pInst->pafltrc->pwfltr->dwFilterTag == pInst->dwTag)
                {
                    afd.cbStruct    = sizeof(afd);
                    afd.dwFilterTag = pInst->dwTag;
                    afd.pwfltr      = pInst->pafltrc->pwfltr;
                    afd.cbwfltr     = pInst->pafltrc->pwfltr->cbStruct;
                    afd.fdwSupport  = 0L;

                    mmr = acmFilterDetails(NULL, &afd, ACM_FILTERDETAILSF_FILTER);
                    if (MMSYSERR_NOERROR == mmr)
                    {
                        FiltersCallback(NULL, &afd, PTR2LPARAM(pInst), afd.fdwSupport);
                    }
                }
            }
            break;
        }
    }
    if (fOk)
        fOk = (ComboBox_GetCount(pInst->hFormats) > 0);

    if (!fOk)
    {
        int index;

        // The codec has probably been disabled or there are no supported
        // formats.
        LoadString(pInst->pag->hinst,
                   IDS_TXT_NONE,
                   (LPTSTR)pInst->pnsTemp->achName,
                   NAMELEN(pInst->pnsTemp));
        index = IComboBox_InsertString(pInst->hFormats,0,
				       pInst->pnsTemp->achName);
        ComboBox_SetItemData(pInst->hFormats,index,0L);
    }

    // Don't let the user OK or assign name, only cancel

    EnableWindow(pInst->hOk,fOk);
    EnableWindow(pInst->hSetName,fOk);

    SetWindowRedraw(pInst->hFormats,TRUE);

    SetCursor(hCur);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | EmptyFormats | Remove all formats
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
EmptyFormats ( PInstData pInst )
{
    int index;
    LPWAVEFORMATEX lpwfx;
    for (index = ComboBox_GetCount(pInst->hFormats);
        index > 0;
        index--)
    {
        lpwfx = (LPWAVEFORMATEX)ComboBox_GetItemData(pInst->hFormats,index-1);
        if (lpwfx)
            GlobalFreePtr(lpwfx);
    }
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | FormatsCallback | Callback entry point for formats.
 *  We only enumerate formats upon refresh.
 *
 *
 ****************************************************************************/
BOOL FNWCALLBACK
FormatsCallback ( HACMDRIVERID hadid,
                  LPACMFORMATDETAILS pafd,
                  DWORD_PTR dwInstance,
                  DWORD fdwSupport )
{
    PInstData       pInst = (PInstData)LPARAM2PTR(dwInstance);
    PNameStore      pns = pInst->pnsTemp;
    LPWAVEFORMATEX  lpwfx;
    UINT            index;

    /* Check for the case when something like CONVERT or SUGGEST
     * is used and we get called back for non matching tags.
     */
    if ((WORD)pInst->dwTag != pafd->pwfx->wFormatTag)
        return (TRUE);

    // we get the details from the callback
#if defined(WIN32) && !defined(UNICODE)
    Iwcstombs(pns->achName, pafd->szFormat, pns->cbSize);
#else
    lstrcpy(pns->achName, pafd->szFormat);
#endif

    MashNameWithRate(pInst,pInst->pnsStrOut,pns,(pafd->pwfx));
    index = IComboBox_FindStringExact(pInst->hFormats,-1,
				      pInst->pnsStrOut->achName);

    //
    //  if already in combobox, don't add another instance
    //
    if (CB_ERR != index)
        return (TRUE);


    if (pInst->fEnableHook && !SendMessage(pInst->hwnd,
                                           MM_ACM_FORMATCHOOSE,
                                           FORMATCHOOSE_FORMAT_VERIFY,
                                           (LPARAM)pafd->pwfx))
        return (TRUE);

    lpwfx = (LPWAVEFORMATEX)CopyStruct(NULL,(LPBYTE)(pafd->pwfx),FORMAT_CHOOSE);

    if (!lpwfx)
        return (TRUE);

    index = IComboBox_AddString(pInst->hFormats,
				pInst->pnsStrOut->achName);

    ComboBox_SetItemData(pInst->hFormats,index,(LPARAM)lpwfx);

    // Keep going
    return (TRUE);
}

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | FiltersCallback() | Callback entry point for
 *  formats.  We only enumerate formats upon refresh.
 *
 *
 ****************************************************************************/
BOOL FNWCALLBACK
FiltersCallback ( HACMDRIVERID          hadid,
                  LPACMFILTERDETAILS    pafd,
                  DWORD_PTR             dwInstance,
                  DWORD                 fdwSupport )
{
    PInstData       pInst = (PInstData)LPARAM2PTR(dwInstance);
    PNameStore      pns = pInst->pnsTemp;
    UINT            index;
    LPWAVEFILTER    lpwf;

    if (pInst->dwTag != pafd->pwfltr->dwFilterTag)
        return (TRUE);

    index = IComboBox_FindStringExactW32(pInst->hFormats, -1, pafd->szFilter);

    //
    //  if already in combobox, don't add another instance
    //
    if (CB_ERR != index)
        return (TRUE);

    if (pInst->fEnableHook && !SendMessage(pInst->hwnd,
                                           MM_ACM_FILTERCHOOSE,
                                           FILTERCHOOSE_FILTER_VERIFY,
                                           (LPARAM)pafd->pwfltr))
        return (TRUE);

    /*
     * Filter depending upon the flags.
     */
    lpwf = (LPWAVEFILTER)CopyStruct(NULL,(LPBYTE)(pafd->pwfltr),FILTER_CHOOSE);

    if (!lpwf)
        return (TRUE);

    // we get the details from the callback
#if defined(WIN32) && !defined(UNICODE)
    Iwcstombs(pns->achName, pafd->szFilter, pns->cbSize);
#else
    lstrcpy(pns->achName, pafd->szFilter);
#endif

    index = IComboBox_AddString(pInst->hFormats, pns->achName);
    ComboBox_SetItemData(pInst->hFormats,index,(LPARAM)lpwf);

    // Keep going
    return (TRUE);
}

/*      -       -       -       -       -       -       -       -       -   */
/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | DelName | Delete the currently selected name.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
DelName ( PInstData pInst )
{
    if (!pInst->pcf)
        return;

    if (!RemoveCustomFormat(pInst,pInst->pcf))
    {
        /* This format is selected elsewhere in another
         * instance.
         */
        ErrorResBox(pInst->hwnd,pInst->pag->hinst,MB_ICONEXCLAMATION|
                    MB_OK, IDS_CHOOSEFMT_APPTITLE, IDS_ERR_FMTSELECTED);
    }
    else
    {
        FlushCustomFormats(pInst);
        NotifyINIChange(pInst);
        RefreshCustomFormats(pInst,FALSE);
        ComboBox_SetCurSel(pInst->hCustomFormats,0);
        SelectCustomFormat(pInst);
    }
}


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void FNLOCAL | SetName | Launch the set name dialog box
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
void FNLOCAL
SetName ( PInstData pInst )
{
    LPCustomFormat  pcf;
    INT_PTR         iRet;
    int             index;

    HFONT	    hfont;
    HRSRC	    hrsrcDlgO;
    HGLOBAL	    hglbDlgO;
    LPVOID	    lpDlgO;
    LPBYTE	    lpO;
    DWORD	    cbDlgO;
    LPVOID	    lpDlgN;
    LPBYTE	    lpN;
    DWORD	    cbDlgN;
    UINT	    uLogPixelsPerInch;
    WORD	    wPoint;
    LOGFONT	    lf;
    HDC		    hdc;
    UINT	    cb;

    hglbDlgO = NULL;
    lpDlgO = NULL;
    lpDlgN = NULL;

    //
    //	--== Build a dialog resource ==--
    //
    //	This will be a modified version of an existing resource.  We do
    //	this for the sole purpose of using the same font as the owner
    //	window.  A lot of work, just for this!!!
    //
    //	Note: The "O" and "N" suffixes on some of the variables are for
    //	Old and New.
    //

    hrsrcDlgO = FindResource( pInst->pag->hinst, DLG_CHOOSE_SAVE_NAME, RT_DIALOG );
    if (NULL == hrsrcDlgO) goto Destruct;

    cbDlgO = SizeofResource( pInst->pag->hinst, hrsrcDlgO );
    if (0 == cbDlgO) goto Destruct;

    hglbDlgO = LoadResource( pInst->pag->hinst, hrsrcDlgO );
    if (NULL == hglbDlgO) goto Destruct;

    lpDlgO = LockResource( hglbDlgO );
    if (NULL == lpDlgO) goto Destruct;

    if ( ((LPDLGTEMPLATE2)lpDlgO)->wSignature != 0xFFFF) { // Dialog Template

    //
    //	Obtain font of owner window.  Get logical height of the font, then
    //	convert it to a point size based on the DC's logical pixels per inch.
    //
    hfont = (HFONT)SendMessage(pInst->hwnd, WM_GETFONT, 0, 0L);
    if (NULL == hfont) goto Destruct;

    if (0 == GetObject( hfont, sizeof(lf), &lf )) goto Destruct;

    hdc = GetDC(pInst->hwnd);
    uLogPixelsPerInch = GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(pInst->hwnd, hdc);

    ASSERT( 0 != uLogPixelsPerInch );			// I'm scared!
    if (0 == uLogPixelsPerInch) goto Destruct;		// I'm scared!

    wPoint = (WORD)((-lf.lfHeight) * 72 / uLogPixelsPerInch);

    //
    //	Allocate memory for new resource.  We'll make it the size of the
    //	existing resource plus room for the new font information (this may
    //	be overkill since there may already be font information in the
    //	existing resource.
    //
#ifdef WIN32
    cbDlgN = cbDlgO + (lstrlen(lf.lfFaceName)+1)*sizeof(WCHAR);
#else
    cbDlgN = cbDlgO + (lstrlen(lf.lfFaceName)+1)*sizeof(TCHAR);
#endif

    lpDlgN = GlobalAllocPtr(GMEM_FIXED, cbDlgN);
    if (NULL == lpDlgN) goto Destruct;

    //
    //	lpO and lpN walk through the resources
    //
    lpO = lpDlgO;
    lpN = lpDlgN;

    //
    //	Copy the initial DLGTEMPLATE structure
    //
#ifdef WIN32
    _fmemcpy(lpN, lpO, 18);	// 18 bytes in win32
    lpN += 18;
    lpO += 18;
#else
    _fmemcpy(lpN, lpO, 13);	// 13 bytes in win16
    lpN += 13;
    lpO += 13;
#endif

    //
    //	menu array
    //
#ifdef WIN32
    if (0xFFFF == *(LPWORD)lpO) {
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
    } else {
	cb = (lstrlenW((LPCWSTR)lpO)+1) * sizeof(WCHAR);
	_fmemcpy(lpN, lpO, cb);
	lpN += cb;
	lpO += cb;
    }
#else
    if (0xFF == *lpO) {
	*lpN++ = *lpO++;
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
    } else {
	cb = (lstrlen(lpO)+1) * sizeof(char);
	_fmemcpy(lpN, lpO, cb);
	lpN += cb;
	lpO += cb;
    }
#endif
	
    //
    //	class array
    //
#ifdef WIN32
    if (0xFFFF == *(LPWORD)lpO) {
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
    } else {
	cb = (lstrlenW((LPCWSTR)lpO)+1) * sizeof(WCHAR);
	_fmemcpy(lpN, lpO, cb);
	lpN += cb;
	lpO += cb;
    }
#else
    if (0xFF == *lpO) {
	*lpN++ = *lpO++;
	*(((LPWORD)lpN)++) = *(((LPWORD)lpO)++);
    } else {
	cb = (lstrlen(lpO)+1) * sizeof(char);
	_fmemcpy(lpN, lpO, cb);
	lpN += cb;
	lpO += cb;
    }
#endif
	
    //
    //	title array
    //
#ifdef WIN32
    cb = (lstrlenW((LPCWSTR)lpO)+1) * sizeof(WCHAR);
#else
    cb = (lstrlen(lpO)+1) * sizeof(char);
#endif
    _fmemcpy(lpN, lpO, cb);
    lpN += cb;
    lpO += cb;

    //
    //	point size and font face name - skip original
    //	information _if_ it's there (ie DS_SETFONT style flag is set).
    //
    if (*(LPDWORD)lpDlgO & DS_SETFONT) {
	lpO += 2;
#ifdef WIN32
	cb = (lstrlenW((LPCWSTR)lpO)+1) * sizeof(WCHAR);
#else
	cb = (lstrlen(lpO)+1) * sizeof(char);
#endif
	lpO += cb;
    }

    //
    //	point size
    //
    *(LPWORD)lpN = wPoint;
    lpN += 2;

    //
    //	font face name
    //
#if defined(WIN32) && !defined(UNICODE)
    Imbstowcs((LPWSTR)lpN, lf.lfFaceName, lstrlen(lf.lfFaceName));
    lpN += (lstrlen(lf.lfFaceName)+1)*sizeof(WCHAR);
#else
    lstrcpy( (LPTSTR)lpN, lf.lfFaceName);
    lpN += (lstrlen(lf.lfFaceName)+1)*sizeof(TCHAR);
#endif

    //
    //	all remaining data
    //
#ifdef WIN32
    //	remaining data is dword aligned.
    lpN = (LPBYTE)(((((UINT_PTR)lpN)+3) >> 2) << 2);
    lpO = (LPBYTE)(((((UINT_PTR)lpO)+3) >> 2) << 2);
#endif
    _fmemcpy(lpN, lpO, (UINT)(cbDlgO-(lpO-(LPBYTE)lpDlgO)));

    } // End of Dialog template
    else { // DialogEx template
         lpDlgN = lpDlgO;  // Nothing to do with dialogEx template.
    } // End of DialogEx template

    //
    //	--== Finally!! Done building the new resource ==--
    //

    iRet = DialogBoxIndirectParam( pInst->pag->hinst,
#ifdef WIN32
				   lpDlgN,
#else
				   GlobalPtrHandle(lpDlgN),
#endif
				   pInst->hwnd,
				   NewNameDlgProc,
				   PTR2LPARAM(pInst) );

    if (iRet <= 0) goto Destruct;

    /* A name has been selected.  The result is in pInst->pnsTemp
     * Create a CustomFormat for the selection and add it to the Global
     * FormatPool.
     */

    pcf = NewCustomFormat(pInst,pInst->pnsTemp,pInst->lpbSel);
    if (pcf)
        AddCustomFormat(pInst, pcf);

    FlushCustomFormats(pInst);
    NotifyINIChange(pInst);
    RefreshCustomFormats(pInst,FALSE);
    if (pcf)
    {
        index = IComboBox_FindStringExact(pInst->hCustomFormats,
				        -1,
				        pcf->pns->achName);
    }
    else
    {
        index = CB_ERR;
    }
    index = (index == CB_ERR)?0:index;
    ComboBox_SetCurSel(pInst->hCustomFormats,index);
    SelectCustomFormat(pInst);

    //
    //
    //
Destruct:
    if (NULL != lpDlgN) {
	GlobalFreePtr(lpDlgN);
    }
    if (NULL != lpDlgO) {
	UnlockResource( hglbDlgO );
    }
    if (NULL != hglbDlgO) {
	FreeResource( hglbDlgO );
    }

    return;

}


/*      -       -       -       -       -       -       -       -       -   */


/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api BOOL FNWCALLBACK | NewNameDlgProc | Dialog proc to let the user type in
 *  a format name
 *
 ****************************************************************************/
INT_PTR FNWCALLBACK
NewNameDlgProc ( HWND       hwnd,
                 unsigned   msg,
                 WPARAM     wParam,
                 LPARAM     lParam)
{
    UINT        CmdCommandId;  // WM_COMMAND ID
    UINT        CmdCmd;        // WM_COMMAND Command
    HWND        CmdHwnd;
    HWND        hctrlEdit;
    PInstData   pInst;
    PNameStore  pName;

    pInst = GetInstData(hwnd);

    switch (msg)
    {
        case WM_INITDIALOG:
            if (!pInst)
            {
                if (SetInstData(hwnd,lParam))
                {
                    TCHAR ach[128];

                    pInst = (PInstData)lParam;
                    pName = pInst->pnsTemp;

                    EnableWindow(GetDlgItem(hwnd,IDOK),FALSE);
                    hctrlEdit = GetDlgItem(hwnd,IDD_EDT_NAME);
                    Edit_LimitText(hctrlEdit,NAMELEN(pName));
                    LoadString(pInst->pag->hinst,
                               (pInst->uType==FORMAT_CHOOSE)?
                                IDS_CHOOSE_FORMAT_DESC:
                                IDS_CHOOSE_FILTER_DESC,
                               ach, SIZEOF(ach));
                    SetDlgItemText(hwnd, IDD_STATIC_DESC,(LPTSTR)ach);
                    return (FALSE);
                }
            }
            EndDialog(hwnd,FALSE);
            return (TRUE);

        case WM_COMMAND:
            CmdCommandId = GET_WM_COMMAND_ID(wParam,lParam);
            CmdCmd       = GET_WM_COMMAND_CMD(wParam,lParam);
            CmdHwnd      = GET_WM_COMMAND_HWND(wParam,lParam);
            switch (CmdCommandId)
            {
                case IDD_EDT_NAME:
                    if (EN_CHANGE == CmdCmd)
                        EnableWindow(GetDlgItem(hwnd,IDOK),
                                     (Edit_GetTextLength(CmdHwnd)?TRUE:FALSE));
                    return (FALSE);

                case IDOK:
                {
                    pName = pInst->pnsTemp;
                    hctrlEdit = GetDlgItem(hwnd,IDD_EDT_NAME);
                    Edit_GetText(hctrlEdit, pName->achName, NAMELEN(pName));

                    if (!RemoveOutsideWhitespace(pInst,pName))
                    {
                        ErrorResBox(hwnd,
                                    pInst->pag->hinst,
                                    MB_ICONEXCLAMATION | MB_OK,
                                    IDS_CHOOSEFMT_APPTITLE,
                                    IDS_ERR_BLANKNAME);
                    }
                    else if (IsCustomName(pInst,pName))
                    {
                        /* This custom name exists */
                        ErrorResBox(hwnd,
                                    pInst->pag->hinst,
                                    MB_ICONEXCLAMATION | MB_OK,
                                    IDS_CHOOSEFMT_APPTITLE,
                                    IDS_ERR_FMTEXISTS);
                    }
		    else if (!IsValidName(pInst, pName))
		    {
			/* This is not a valid name */
			ErrorResBox(hwnd,
				    pInst->pag->hinst,
				    MB_ICONEXCLAMATION | MB_OK,
				    IDS_CHOOSEFMT_APPTITLE,
				    IDS_ERR_INVALIDNAME);
		    }
                    else
                        EndDialog(hwnd,TRUE);

                    return (TRUE);
                }
                case IDCANCEL:
                    EndDialog(hwnd,FALSE);
                    return (TRUE);
            }
            break;

        case WM_DESTROY:
            if (pInst)
                RemoveInstData(hwnd);
            return (FALSE);
    }
    return (FALSE);
}


/*      -       -       -       -       -       -       -       -       -   */


/*
 * @doc INTERNAL
 *
 * @func short | ErrorResBox | This function displays a message box using
 * program resource error strings.
 *
 * @parm HWND | hwnd | Specifies the message box parent window.
 *
 * @parm HANDLE | hInst | Specifies the instance handle of the module
 * that contains the resource strings specified by <p idAppName> and
 * <p idErrorStr>.  If this value is NULL, the instance handle is
 * obtained from <p hwnd> (in which case <p hwnd> may not be NULL).
 *
 * @parm WORD | flags | Specifies message box types controlling the
 * message box appearance.  All message box types valid for <f MessageBox> are
 * valid.
 *
 * @parm WORD | idAppName | Specifies the resource ID of a string that
 * is to be used as the message box caption.
 *
 * @parm WORD | idErrorStr | Specifies the resource ID of a error
 * message format string.  This string is of the style passed to
 * <f wsprintf>, containing the standard C argument formatting
 * TCHARacters.  Any procedure parameters following <p idErrorStr> will
 * be taken as arguments for this format string.
 *
 * @parm arguments | [ arguments, ... ] | Specifies additional
 * arguments corresponding to the format specification given by
 * <p idErrorStr>.  All string arguments must be FAR pointers.
 *
 * @rdesc Returns the result of the call to <f MessageBox>.  If an
 * error occurs, returns zero.
 *
 * @comm This is a variable arguments function, the parameters after
 * <p idErrorStr> being taken for arguments to the <f printf> format
 * string specified by <p idErrorStr>.  The string resources specified
 * by <p idAppName> and <p idErrorStr> must be loadable using the
 * instance handle <p hInst>.  If the strings cannot be
 * loaded, or <p hwnd> is not valid, the function will fail and return
 * zero.
 *
 */

#define STRING_SIZE 256

static int FAR cdecl ErrorResBox(HWND hwnd,
				 HINSTANCE    hInst,
				 WORD flags,
				 WORD idAppName,
				 WORD idErrorStr, ...)
{
    PSTR    sz = NULL;
    PSTR    szFmt = NULL;
    int     i;
    va_list va;

    if (hInst == NULL)
    {
        if (hwnd == NULL)
        {
            MessageBeep(0);
            return FALSE;
        }

        hInst = GetWindowInstance(hwnd);
    }

    i = 0;

    sz = (PSTR) LocalAlloc(LPTR, STRING_SIZE * sizeof(TCHAR));
    szFmt = (PSTR) LocalAlloc(LPTR, STRING_SIZE * sizeof(TCHAR));
    if (!sz || !szFmt)
    goto ExitError; // no mem, get out

    if (!LoadString(hInst, idErrorStr, (LPTSTR)szFmt, STRING_SIZE))
    goto ExitError;

    va_start(va, idErrorStr);
    wvsprintf((LPTSTR)sz, (LPTSTR)szFmt, va);
    va_end(va);

    if (!LoadString(hInst, idAppName, (LPTSTR)szFmt, STRING_SIZE))
        goto ExitError;

    i = MessageBox(hwnd, (LPTSTR)sz, (LPTSTR)szFmt,
#ifdef BIDI
                   MB_RTL_READING |
#endif
                   flags);

ExitError:
    if (sz) LocalFree((HANDLE) sz);
    if (szFmt) LocalFree((HANDLE) szFmt);

    return i;
}

/*      -       -       -       -       -       -       -       -       -   */

#if 0

//--------------------------------------------------------------------------;
//
//  void AppProfileWriteBytes
//
//  Description:
//      This function writes a raw structure of bytes to the application's
//      ini section that can later be retrieved using AppProfileReadBytes.
//      This gives an application the ability to write any structure to
//      the ini file and restore it later--very useful.
//
//  Arguments:
//      PCTSTR pszKey: Pointer to key name for the stored data.
//
//      LPBYTE pbStruct: Pointer to the data to be saved.
//
//      UINT cbStruct: Count in bytes of the data to store.
//
//  History:
//       3/10/93   cjp     [curtisp]
//
//--------------------------------------------------------------------------;
#define APP_MAX_STRING_RC_CHARS 256
void FNGLOBAL AppProfileWriteBytes
(
    HKEY                hkey,
    LPCTSTR             pszKey,
    LPBYTE              pbStruct,
    UINT                cbStruct
)
{
    static TCHAR achNibbleToChar[] =
    {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
    };
    #define     NIBBLE2CHAR(x)      (achNibbleToChar[x])

    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    LPTSTR      psz;
    LPTSTR      pch;
    BOOL        fAllocated;
    UINT        cchTemp;
    BYTE        b;
    BYTE        bChecksum;

    ASSERT( NULL != hkey );
    ASSERT( NULL != pszKey );
    ASSERT( NULL != pbStruct );
    ASSERT( cbStruct > 0 );


    fAllocated = FALSE;

    //
    //  check if the quick buffer can be used for formatting the output
    //  text--if it cannot, then alloc space for it. note that space
    //  must be available for an ending checksum byte (2 bytes for high
    //  and low nibble) as well as a null terminator.
    //
    psz     = (LPTSTR)ach;
    cchTemp = cbStruct * 2 + 3;
    if (cchTemp > SIZEOF(ach))
    {
        psz = (LPTSTR)GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR));
        if (NULL == psz)
            return;

        fAllocated = TRUE;
    }

    //
    //  step through all bytes in the structure and convert it to
    //  a string of hex numbers...
    //
    bChecksum = 0;
    for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
    {
        //
        //  grab the next byte and add into checksum...
        //
        bChecksum += (b = *pbStruct);

        *pch++ = NIBBLE2CHAR((b >> (BYTE)4) & (BYTE)0x0F);
        *pch++ = NIBBLE2CHAR(b & (BYTE)0x0F);
    }

    //
    //  add the checksum byte to the end and null terminate the hex
    //  dumped string...
    //
    *pch++ = NIBBLE2CHAR((bChecksum >> (BYTE)4) & (BYTE)0x0F);
    *pch++ = NIBBLE2CHAR(bChecksum & (BYTE)0x0F);
    *pch   = '\0';


    //
    //  write the string of hex bytes out to the ini file...
    //
    IRegWriteString( hkey, pszKey, psz );

    //
    //  free the temporary buffer if one was allocated (lots of bytes!)
    //
    if (fAllocated)
        GlobalFreePtr(psz);
}


//--------------------------------------------------------------------------;
//
//  BOOL AppProfileReadBytes
//
//  Description:
//      This function reads a previously stored structure of bytes from
//      the application's ini file. This data must have been written with
//      the AppProfileWriteBytes function--it is checksumed to keep bad
//      data from blowing up the application.
//
//  Arguments:
//      PCTSTR pszKey: Pointer to key that contains the data.
//
//      LPBYTE pbStruct: Pointer to buffer to receive the data.
//
//      UINT cbStruct: Number of bytes expected.
//
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if the function fails (bad checksum, missing key, etc).
//
//  History:
//       3/10/93   cjp     [curtisp]
//       5/06/93   jyg     Flag to disable CHECKSUM on read
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppProfileReadBytes
(
    HKEY                hkey,
    LPCTSTR             pszKey,
    LPBYTE              pbStruct,
    UINT                cbStruct,
    BOOL                fChecksum
)
{
    //
    //  note that the following works for both upper and lower case, and
    //  will return valid values for garbage chars
    //
    #define CHAR2NIBBLE(ch) (BYTE)( ((ch) >= '0' && (ch) <= '9') ?  \
                                (BYTE)((ch) - '0') :                \
                                ((BYTE)(10 + (ch) - 'A') & (BYTE)0x0F) )

    LPTSTR      psz;
    LPTSTR      pch;
    DWORD       cbValue;
    DWORD       dwType;
    BOOL        fReturn;
    BYTE        b;
    BYTE        bChecksum;
    TCHAR       ch;

    ASSERT( NULL != hkey );
    ASSERT( NULL != pszKey );
    ASSERT( NULL != pbStruct );
    ASSERT( cbStruct > 0 );


    //
    //  add one the the number of bytes needed to accomodate the checksum
    //  byte placed at the end by AppProfileWriteBytes...
    //
    cbStruct++;

    //
    //  Find out how big the data value is, then allocate a buffer for it.
    //
    dwType = REG_SZ;
    if( ERROR_SUCCESS != XRegQueryValueEx( hkey, (LPTSTR)pszKey, NULL,
                                            &dwType, NULL, &cbValue ) )
    {
        return FALSE;
    }

    psz = (LPTSTR)GlobalAllocPtr( GPTR, cbValue );
    if( NULL == psz )
        return FALSE;


    //
    //  read the hex string
    //
    fReturn = FALSE;

    dwType = REG_SZ;
    if( ERROR_SUCCESS == XRegQueryValueEx( hkey, (LPTSTR)pszKey,
                                            NULL, &dwType,
                                            (LPBYTE)psz, &cbValue ) )
    {
        //
        //  We read it successfully.  Check that we have enough data to
        //  fill the return structure.
        //
        if( cbStruct <= (UINT)lstrlen(psz)/2 )
        {
            //
            //  We have enough.  Decode the data and calculate checksum.
            //
            bChecksum = 0;
            for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
            {
                ch = *pch++;
                b  = CHAR2NIBBLE(ch) << (BYTE)4;
                ch = *pch++;
                b |= CHAR2NIBBLE(ch);

                //
                //  if this is not the final byte (the checksum byte), then
                //  store it and accumulate checksum..
                //
                if (cbStruct != 1)
                    bChecksum += (*pbStruct = b);
            }

            //
            //  check the last byte read against the checksum that we calculated
            //  if they are not equal then return error...
            //
            if (fChecksum)
                fReturn = (bChecksum == b);
            else
                fReturn = TRUE;
        }
    }


    GlobalFreePtr(psz);

    return (fReturn);
}

#endif // 0

//==========================================================================;
//
//
//
//
//==========================================================================;

#ifndef WIN32

/****************************************************************************
 *  @doc INTERNAL ACM_API
 *
 *  @api void | SelectFormat | Process a selection from format combo.
 *
 *  @parm PInstData | pInst | Pointer to this instance
 *
 ****************************************************************************/
//--------------------------------------------------------------------------;
//
//  LRESULT acmChooseFormat
//
//  Description:
//      This function simply thunks to the new acmFormatChoose() API for
//      Sound Recorder that ships with Bombay.
//
//  Arguments:
//      LPACMFORMATCHOOSE pfmtc:
//
//  Return (LRESULT):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT ACMAPI acmChooseFormat
(
    LPACMFORMATCHOOSE pfmtc
)
{
    ACMFORMATCHOOSE afc;
    //
    //  thunk to the new acmFormatChoose api
    //
    //  The v1.x chooser used the following structure:
    //
    //
//
//struct tACMCHOOSEWAVEFORMAT
//{
//    DWORD           cbStruct;       // sizeof(ACMCHOOSEWAVEFORMAT)
//    DWORD           dwFlags;        // various flags
//
//    HWND            hwndOwner;      // caller's window handle
//
//    LPWAVEFORMATEX  lpwfx;          // ptr to wfx buf to receive choice
//    DWORD           cbwfx;          // size of mem buf for lpwfx
///////////////////////////////////////////////////////////////////////////////
//    //
//    //  the following members are used for custom templates only--which
//    //  are enabled by specifying CWF_ENABLEHOOK in the dwFlags member.
//    //
//    //  these members are IGNORED if CWF_ENABLEHOOK is not specified.
//    //
//    HINSTANCE       hInstance;      // .EXE containing cust. dlg. template
//    LPSTR           lpTemplateName; // custom template name
//    LPARAM          lCustData;      // data passed to hook fn.
//    LPCWFHOOKPROC   lpfnHook;       // ptr to hook function
//
//    char            ach[100];       // padding for expansion
//
//}
//
//Lucky us, only Soundreck used used this and really only the members above
//cbwfx.
//
    _fmemset(&afc,0,sizeof(ACMFORMATCHOOSE));
    afc.cbStruct = sizeof(ACMFORMATCHOOSE);

    // The behavior of the style stuff seems to have changed a bit.
    // The low word is safe, though the old soundrec hooks things and
    // the help behavior might get funny (f1 gives old help, Help gives
    // real help).
#pragma message("No help for old acmchoose")
    afc.fdwStyle = LOWORD(pfmtc->fdwStyle);
    afc.hwndOwner = pfmtc->hwndOwner;
    afc.pwfx = pfmtc->pwfx;
    afc.cbwfx = pfmtc->cbwfx;
    afc.fdwEnum = ACM_FORMATENUMF_INPUT;

    return ((LRESULT)acmFormatChoose(&afc));
} // acmChooseFormat()

#endif // #ifndef WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\locks.c ===
//==========================================================================;
//
//  locks.c
//
//  Copyright (c) 1994-1998 Microsoft Corporation
//
//  Description:
//      Implement lock objects for win32
//
//  History:
//
//==========================================================================;


/*
    Implementation notes

    The scheme here rests on the handling of the Lock event.
    This event is non-autoreset.

    It is RESET whenever a thread can't proceed :

        - Want shared access and Lock is in use non-shared

        - Want non-shared access and the Lock is in use and we're not the
          owner

    and this is ALWAYS inside the Lock critical section.

    It is SET whenever NumberOfActive goes to 0.

    The key question is :  If it gets reset can we guarantee it will get
    set again (provided all threads eventually release their Locks

    To ensure this we make sure the following are always true when the
    Lock critical section is not held.

        (a) NumberOfActive == 0 => Nonshared event set
        (b) NumberOfActive >= 0 => Shared event set

    So it is guaranteed that nobody waits if they can proceed.

*/

#include <windows.h>
#include "locks.h"

#include "debug.h"

BOOL InitializeLock(PLOCK_INFO plock)
{

    //
    //  Everyone waiting for something interesting to happen gets
    //  dispatched every time something interesting happens
    //

    plock->SharedEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    if (plock->SharedEvent == NULL) {
        return FALSE;
    }


    plock->ExclusiveEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    if (plock->ExclusiveEvent == NULL) {
        CloseHandle(plock->SharedEvent);
        return FALSE;
    }

    try {
	InitializeCriticalSection(&plock->CriticalSection);
    } except(EXCEPTION_EXECUTE_HANDLER) {
	CloseHandle(plock->ExclusiveEvent);
	CloseHandle(plock->SharedEvent);
	return FALSE;
    }

    plock->ExclusiveOwnerThread = 0;
    plock->NumberOfActive       = 0;
    plock->SharedEventSet       = TRUE;
    plock->ExclusiveEventSet    = TRUE;

    return (TRUE);
}

VOID AcquireLockShared(PLOCK_INFO plock)
{
    while (1) {
        //
        //  Go into the critical section and see if conditions are right
        //
        EnterCriticalSection(&plock->CriticalSection);

        //
        //  NumberOfActive >= 0 means it's not held exclusive
        //

        if (plock->NumberOfActive >= 0) {
            plock->NumberOfActive++;
            LeaveCriticalSection(&plock->CriticalSection);
            return;
        }

        //
        //  We might be the non-shared owner in which case just add one
        //  to the count (ie subtract one since we've got it exclusive).
        //

        if (plock->ExclusiveOwnerThread == GetCurrentThreadId()) {
            plock->NumberOfActive--;
            LeaveCriticalSection(&plock->CriticalSection);
            return;
        }

        //
        //  Otherwise we've got to wait lazily.  Note that the event is
        //  ALWAYS set (see prologue) if the count if NumberOfActive >= 0.
        //

        plock->SharedEventSet = FALSE;
        ResetEvent(plock->SharedEvent);

        LeaveCriticalSection(&plock->CriticalSection);

        //
        //  Wait for the count to reach 0.
        //

        WaitForSingleObject(plock->SharedEvent, INFINITE);
    }
}

VOID AcquireLockExclusive(PLOCK_INFO plock)
{
    while (1) {
        //
        //  Go into the critical section and see if conditions are right
        //
        EnterCriticalSection(&plock->CriticalSection);

        //
        //  It's OK if NumberOfActive is 0 or we're the owner
        //

        if (plock->NumberOfActive == 0 ||
            GetCurrentThreadId() == plock->ExclusiveOwnerThread) {
            plock->ExclusiveOwnerThread = GetCurrentThreadId();
            plock->NumberOfActive--;
            LeaveCriticalSection(&plock->CriticalSection);
            return;
        }

        plock->ExclusiveEventSet = FALSE;
        ResetEvent(plock->ExclusiveEvent);
        LeaveCriticalSection(&plock->CriticalSection);

        //
        //  Wait for something interesting to happen
        //

        WaitForSingleObject(plock->ExclusiveEvent, INFINITE);
    }
}

VOID ReleaseLock(PLOCK_INFO plock)
{
    EnterCriticalSection(&plock->CriticalSection);
    if (plock->NumberOfActive < 0) {
        plock->NumberOfActive++;
        //
        //  Actually only need to set the Shared event if the count was < 0
        //  and since this is a common case we will do this.  Note we
        //  proved in the preamble that this even can only be reset if
        //  NumberOfActive is < 0.
        //
        if (plock->NumberOfActive == 0) {
            plock->ExclusiveOwnerThread = 0;

            if (!plock->SharedEventSet) {
                plock->SharedEventSet = TRUE;
                SetEvent(plock->SharedEvent);
            }
        }
    } else {
        plock->NumberOfActive--;
    }

    if (plock->NumberOfActive == 0 && !plock->ExclusiveEventSet) {
        plock->ExclusiveEventSet = TRUE;
        SetEvent(plock->ExclusiveEvent);
    }
    LeaveCriticalSection(&plock->CriticalSection);
}

VOID DeleteLock(PLOCK_INFO plock)
{
    CloseHandle(plock->SharedEvent);
    CloseHandle(plock->ExclusiveEvent);
    DeleteCriticalSection(&plock->CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\init.c ===
//==========================================================================;
//
//  init.c
//
//  Copyright (c) 1991-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//==========================================================================;

//
//  If we're in Daytona, manually initialize friendly name stuff into
//  HKCU.
//
#if defined(WIN32) && !defined(WIN4)
#define USEINITFRIENDLYNAMES
#endif

#ifdef USEINITFRIENDLYNAMES
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#endif


#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#ifdef WIN4
#include <mmdevldr.h>
#endif
#include <memory.h>
#include <process.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "chooseri.h"
#include "uchelp.h"
#include "pcm.h"
#include "profile.h"

#include "debug.h"



#ifdef WIN4
//
//  Chicago thunk connect function protos
//
#ifdef WIN32
BOOL PASCAL acmt32c_ThunkConnect32(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
#else
BOOL FAR PASCAL acmt32c_ThunkConnect16(LPCSTR pszDll16, LPCSTR pszDll32, HINSTANCE hinst, DWORD dwReason);
#endif
#endif

//
//
//
//
PACMGARB            gplag = NULL;
TCHAR   CONST       gszNull[]   = TEXT("");

//
//
//
//
#ifdef WIN4
char  BCODE   gmbszMsacm[]	      = "msacm.dll";
char  BCODE   gmbszMsacm32[]	      = "msacm32.dll";
#endif

TCHAR BCODE   gszAllowThunks[]	      = TEXT("AllowThunks");
TCHAR BCODE   gszSecACM[]             = TEXT("MSACM");
TCHAR BCODE   gszKeyNoPCMConverter[]  = TEXT("NoPCMConverter");

TCHAR BCODE   gszSecPriority[]        = TEXT("Priority v4.00");
TCHAR BCODE   gszKeyPriority[]        = TEXT("Priority%u");

#if defined(WIN32) && !defined(UNICODE)
TCHAR BCODE   gszPriorityFormat[]     = TEXT("%u, %ls");
#else
TCHAR BCODE   gszPriorityFormat[]     = TEXT("%u, %s");
#endif

CONST TCHAR   gszIniSystem[]          = TEXT("SYSTEM.INI");
#ifdef WIN32
TCHAR BCODE   gszWinMM[]	      = TEXT("WINMM");
CONST WCHAR   gszSecDriversW[]	      = L"Drivers32";
CONST TCHAR   gszSecDrivers[]	      = DRIVERS_SECTION;
#else
CONST TCHAR   gszSecDrivers[]         = TEXT("Drivers");
CONST TCHAR   gszSecDrivers32[]       = TEXT("Drivers32");
TCHAR BCODE   gszKernel[]             = TEXT("KERNEL");
TCHAR BCODE   gszLoadLibraryEx32W[]   = TEXT("LoadLibraryEx32W");
TCHAR BCODE   gszGetProcAddress32W[]  = TEXT("GetProcAddress32W");
TCHAR BCODE   gszCallproc32W[]        = TEXT("CallProc32W");
TCHAR BCODE   gszFreeLibrary32W[]     = TEXT("FreeLibrary32W");
TCHAR BCODE   gszAcmThunkEntry[]      = TEXT("acmMessage32");
TCHAR BCODE   gszXRegThunkEntry[]     = TEXT("XRegThunkEntry");
TCHAR BCODE   gszMsacm32[]            = TEXT("msacm32.dll");
#endif
TCHAR BCODE   gszTagDrivers[]         = TEXT("msacm.");
#ifdef WIN32
WCHAR BCODE   gszPCMAliasName[]       = L"Internal PCM Converter";
#else
char  BCODE   gszPCMAliasName[]       = "Internal PCM Converter";
#endif

#ifdef USEINITFRIENDLYNAMES
TCHAR BCODE gszFriendlyAudioKey[] = TEXT("Software\\Microsoft\\Multimedia\\Audio");
TCHAR BCODE gszFriendlySystemFormatsValue[] = TEXT("SystemFormats");
TCHAR BCODE gszFriendlyDefaultFormatValue[] = TEXT("DefaultFormat");
TCHAR BCODE gszFriendlyWaveFormatsKey[] = TEXT("WaveFormats");
const PCMWAVEFORMAT gwfFriendlyCDQualityData = {{WAVE_FORMAT_PCM,2,44100,176400,4},16};
const PCMWAVEFORMAT gwfFriendlyRadioQualityData = {{WAVE_FORMAT_PCM,1,22050,22050,1},8};
const PCMWAVEFORMAT gwfFriendlyTelephoneQualityData = {{WAVE_FORMAT_PCM,1,11025,11025,1},8};
#endif // USEINITFRIENDLYNAMES




//--------------------------------------------------------------------------;
//
//  VOID IDriverPrioritiesWriteHadid
//
//  Description:
//      This routine writes an entry for the given driver into the given
//      key.  The section is in gszSecPriority.
//
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPTSTR szKey:       The key name.
//      HACMDRIVERID hadid: The driver's hadid.
//
//--------------------------------------------------------------------------;

VOID IDriverPrioritiesWriteHadid
(
    HKEY                    hkey,
    LPTSTR                  szKey,
    HACMDRIVERID            hadid
)
{
    PACMDRIVERID            padid;
    BOOL                    fEnabled;
    TCHAR                   ach[ 16 + ACMDRIVERDETAILS_SHORTNAME_CHARS +
                                      ACMDRIVERDETAILS_LONGNAME_CHARS   ];

    ASSERT( NULL != szKey );
    ASSERT( NULL != hadid );

    padid = (PACMDRIVERID)hadid;


    fEnabled = (0 == (padid->fdwDriver & ACMDRIVERID_DRIVERF_DISABLED));

    wsprintf( ach,
	      gszPriorityFormat,
	      fEnabled ? 1 : 0,
	      (LPTSTR)padid->szAlias );

    IRegWriteString( hkey, szKey, ach );
}


//--------------------------------------------------------------------------;
//
//  BOOL IDriverPrioritiesIsMatch
//
//  Description:
//      This routine determines whether a priorities string (read from
//      the INI file, as written by IDriverPrioritiesWriteHadid) matches
//      a currently installed driver.
//
//  Arguments:
//      HACMDRIVERID hadid: Handle to installed driver.
//      LPTSTR szPrioText:  Text read from INI file.
//
//  Return (BOOL):  TRUE if hadid matches szPrioText.
//
//--------------------------------------------------------------------------;

BOOL IDriverPrioritiesIsMatch
(
    HACMDRIVERID            hadid,
    LPTSTR                  szPrioText
)
{
    PACMDRIVERID            padid;
    TCHAR                   ach[ 16 + ACMDRIVERDETAILS_SHORTNAME_CHARS +
                                      ACMDRIVERDETAILS_LONGNAME_CHARS   ];

    ASSERT( NULL != hadid );
    ASSERT( NULL != szPrioText );

    padid           = (PACMDRIVERID)hadid;


    //
    //  Create a priorities string and compare it to the one we read in.
    //
    wsprintf( ach,
              gszPriorityFormat,
              0,                // We ignore this value in the comparison.
              (LPTSTR)padid->szAlias );

    if( ( szPrioText[0]==TEXT('0') || szPrioText[0]==TEXT('1') ) &&
        0 == lstrcmp( &szPrioText[1], &ach[1] ) )
    {
        return TRUE;
    }

    return FALSE;
}


#ifdef USETHUNKLIST

//--------------------------------------------------------------------------;
//
//  VOID IPrioritiesThunklistFree
//
//  Description:
//      This routine frees the elements of the thunklist, including any
//      strings which have been allocated.
//
//  Arguments:
//      PPRIORITIESTHUNKLIST ppt:       The first element to free.
//
//--------------------------------------------------------------------------;

VOID IPrioritiesThunklistFree
(
    PPRIORITIESTHUNKLIST    ppt         // NULL is OK.
)
{
    PPRIORITIESTHUNKLIST    pptKill;

    while( NULL != ppt )
    {
        pptKill     = ppt;
        ppt         = ppt->pptNext;

        if( pptKill->fFakeDriver )
        {
            ASSERT( NULL != pptKill->pszPrioritiesText );
            LocalFree( (HLOCAL)pptKill->pszPrioritiesText );
        }
        LocalFree( (HLOCAL)pptKill );
    }
} // IPrioritiesThunklistFree()


//--------------------------------------------------------------------------;
//
//  VOID IPrioritiesThunklistCreate
//
//  Description:
//      This routine creates the thunklist by reading the [Priority]
//      section, and matching up the entries with installed drivers.  If
//      any entries don't match, then it is assumed to be the entry for
//      a 16-bit driver.
//
//      Note that if we can't allocate memory at any point, we simply
//      return pptRoot with as much of the list as we could allocate.
//
//  Arguments:
//      PACMGARB pag
//      PPRIORITIESTHUNKLIST pptRoot:  Pointer to the dummy root element.
//
//  Return:  None.
//
//--------------------------------------------------------------------------;

VOID IPrioritiesThunklistCreate
(
    PACMGARB                pag,
    PPRIORITIESTHUNKLIST    pptRoot
)
{
    PPRIORITIESTHUNKLIST    ppt;
    UINT                    uPriority;
    DWORD                   fdwEnum;
    TCHAR                   szKey[MAXPNAMELEN];
    TCHAR                   ach[16 + ACMDRIVERDETAILS_SHORTNAME_CHARS + ACMDRIVERDETAILS_LONGNAME_CHARS];
    BOOL                    fFakeDriver;
    HACMDRIVERID            hadid;
    HKEY                    hkeyPriority;

    ASSERT( NULL != pptRoot );
    ASSERT( NULL == pptRoot->pptNext );  // We're gonna over-write this!


    ppt     = pptRoot;
    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;

    hkeyPriority = IRegOpenKeyAcm( gszSecPriority );

    //
    //  Loop through the PriorityX values.
    //
    for( uPriority=1; ; uPriority++ )
    {
        wsprintf(szKey, gszKeyPriority, uPriority);
        if( !IRegReadString(hkeyPriority, szKey, ach, SIZEOF(ach) ) )
        {
            //
            //  No more values - time to quit.
            //

            break;
        }

        //
        //  Determine whether the value corresponds to an installed driver.
        //
        fFakeDriver = TRUE;
        hadid = NULL;

        while (!IDriverGetNext(pag, &hadid, hadid, fdwEnum))
        {
            if( IDriverPrioritiesIsMatch( hadid, ach ) )
            {
                fFakeDriver = FALSE;
                break;
            }
        }


        //
        //  Create a new entry in the thunklist for this driver.  Save the
        //  string if we didn't match it with an installed driver.
        //
        ASSERT( NULL == ppt->pptNext );
        ppt->pptNext = (PPRIORITIESTHUNKLIST)LocalAlloc( LPTR,
                                        sizeof(PRIORITIESTHUNKLIST) );
        if( NULL == ppt->pptNext )
        {
            IRegCloseKey( hkeyPriority );
            return;
        }

        ppt->pptNext->pptNext       = NULL;
        ppt->pptNext->fFakeDriver   = fFakeDriver;

        if( !fFakeDriver )
        {
            ppt->pptNext->hadid     = hadid;
        }
        else
        {
            ppt->pptNext->pszPrioritiesText = (LPTSTR)LocalAlloc( LPTR,
                                        (1+lstrlen(ach)) * sizeof(TCHAR) );
            if( NULL == ppt->pptNext->pszPrioritiesText )
            {
                //
                //  Remove the new entry, exit.
                //
                LocalFree( (HLOCAL)ppt->pptNext );
                ppt->pptNext = NULL;
                IRegCloseKey( hkeyPriority );
                return;
            }

            lstrcpy( ppt->pptNext->pszPrioritiesText, ach );
        }


        //
        //  Advance ppt to the end of the list.
        //
        ppt = ppt->pptNext;
    }

    IRegCloseKey( hkeyPriority );

} // IPrioritiesThunklistCreate()


//--------------------------------------------------------------------------;
//
//  VOID IPrioritiesThunklistRemoveHadid
//
//  Description:
//      This routine removes an installed driver from the priorities
//      thunklist.  If an entry does not exist with the specified hadid,
//      the thunklist remains unchanged.
//
//  Arguments:
//      PPRIORITIESTHUNKLIST pptRoot:   The root of the list.
//      HACMDRIVERID hadid:             The hadid of the driver to remove.
//
//  Return:
//
//--------------------------------------------------------------------------;

VOID IPrioritiesThunklistRemoveHadid
(
    PPRIORITIESTHUNKLIST    pptRoot,
    HACMDRIVERID            hadid
)
{
    PPRIORITIESTHUNKLIST    ppt;
    PPRIORITIESTHUNKLIST    pptRemove;

    ASSERT( NULL != pptRoot );
    ASSERT( NULL != hadid );


    //
    //  Find the right driver.
    //
    ppt = pptRoot;
    while( NULL != ppt->pptNext )
    {
        if( hadid == ppt->pptNext->hadid )
            break;
        ppt = ppt->pptNext;
    }

    if( NULL != ppt->pptNext )
    {
        //
        //  We found it.
        //
        pptRemove       = ppt->pptNext;
        ppt->pptNext    = pptRemove->pptNext;

        ASSERT( NULL != pptRemove );
        LocalFree( (HLOCAL)pptRemove );
    }
}


//--------------------------------------------------------------------------;
//
//  HACMDRIVERID IPrioritiesThunklistGetNextHadid
//
//  Description:
//      This routine returns the next hadid in the thunklist (skipping all
//      fake drivers), or NULL if we get to the end of the list without
//      finding a real driver.
//
//  Arguments:
//      PPRIORITIESTHUNKLIST pptRoot:   The root of the list.
//
//  Return:
//
//--------------------------------------------------------------------------;

HACMDRIVERID IPrioritiesThunklistGetNextHadid
(
    PPRIORITIESTHUNKLIST    pptRoot
)
{
    HACMDRIVERID            hadid = NULL;

    ASSERT( NULL != pptRoot );


    while( NULL != pptRoot->pptNext )
    {
        pptRoot = pptRoot->pptNext;
        if( !pptRoot->fFakeDriver )
            return pptRoot->hadid;
    }

    //
    //  We didn't find a real driver.
    //
    return NULL;
}


//--------------------------------------------------------------------------;
//
//  BOOL IDriverPrioritiesSave
//
//  Description:
//
//      This routine saves the priorities by comparing the list of
//      installed drivers to the list of priorities currently written
//      out.  The two lists are then merged according to the following
//      algorithm.
//
//          List1 = the current list of priorities - may include some drivers
//                      which aren't installed, ie. 16-bit drivers.
//          List2 = the list of currently-installed global drivers.
//
//      Algorithm:  repeat the following until List1 and List2 are empty:
//
//          1.  If *p1 is an installed driver and *p2 is the same driver,
//                  then write out the priority and advance p1 and p2.
//          2.  If *p1 is an installed driver and *p2 is a different driver,
//                  then write out *p2, remove *p2 from List1 (if it's
//                  there) so that we won't be tempted to write it later,
//                  and advance p2.
//          3.  If *p1 is a fake driver and the next real driver after
//                  *p1 is the same as *p2, then write out *p1 and advance p1.
//          4.  If *p1 is a fake driver and the next real driver after
//                  *p1 is different from *p2, then write out *p2 and
//                  advance p2.
//
//  Arguments:
//      PACMGARB pag:
//
//  Return (BOOL):
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IDriverPrioritiesSave
(
    PACMGARB pag
)
{
    PRIORITIESTHUNKLIST     ptRoot;
    PPRIORITIESTHUNKLIST    ppt;
    TCHAR                   szKey[MAXPNAMELEN];
    UINT                    uPriority;
    HACMDRIVERID            hadid;
    DWORD                   fdwEnum;
    HKEY                    hkeyPriority;

    DPF(1, "IDriverPrioritiesSave: saving priorities...");

    hkeyPriority = IRegOpenKeyAcm( gszSecPriority );

    if( NULL == hkeyPriority )
    {
        DPF(1,"IDriverPrioritiesSave: Priorities hkey is NULL - can't save priorities.");
        return FALSE;
    }


    ptRoot.pptNext  = NULL;
    fdwEnum         = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;


    //
    //  Create a thunklist out of the old priorities.
    //
    IPrioritiesThunklistCreate( pag, &ptRoot );


    //
    //  Initialize the two lists: ppt and hadid.
    //
    ppt = ptRoot.pptNext;
    IDriverGetNext( pag, &hadid, NULL, fdwEnum );

    if( NULL == hadid )
        DPF(1,"IDriverPrioritiesSave:  No drivers installed?!");


    //
    //  Merge the lists.  Each iteration writes a single PriorityX value.
    //
    for( uPriority=1; ; uPriority++ )
    {
        //
        //  Ending condition:  both hadid and ppt are NULL.
        //
        if( NULL == ppt  &&  NULL == hadid )
            break;

        //
        //  Generate the "PriorityX" string.
        //
        wsprintf(szKey, gszKeyPriority, uPriority);


        //
        //  Figure out which entry to write out next.
        //
        if( NULL == ppt  ||  !ppt->fFakeDriver )
        {
            ASSERT( NULL != hadid );
            IDriverPrioritiesWriteHadid( hkeyPriority, szKey, hadid );

            //
            //  Advance the list pointers.
            //
            if( NULL != ppt )
            {
                if( hadid == ppt->hadid )
                {
                    ppt = ppt->pptNext;
                }
                else
                {
                    IPrioritiesThunklistRemoveHadid( ppt, hadid );
                }
            }
            IDriverGetNext( pag, &hadid, hadid, fdwEnum );
        }
        else
        {
            if( NULL != hadid  &&
                hadid != IPrioritiesThunklistGetNextHadid( ppt ) )
            {
                IDriverPrioritiesWriteHadid( hkeyPriority, szKey, hadid );
                IPrioritiesThunklistRemoveHadid( ppt, hadid );
                IDriverGetNext( pag, &hadid, hadid, fdwEnum );
            }
            else
            {
                //
                //  Write out the thunklist string.
                //
                ASSERT( NULL != ppt->pszPrioritiesText );
                IRegWriteString( hkeyPriority,
                                    szKey,
                                    ppt->pszPrioritiesText );
                ppt = ppt->pptNext;
            }
        }
    }


    //
    //  If there are any "PriorityX" strings hanging around from a
    //  previous save, delete them.
    //
    for( ; ; uPriority++ )
    {
        //
        //  If we can open the value, then delete it and continue on
        //  to the next value.  If we can't open it, then we assume
        //  that we have deleted them all and we exit the loop.
        //
        wsprintf(szKey, gszKeyPriority, uPriority);
        if( !IRegValueExists( hkeyPriority, szKey ) )
        {
            break;
        }

        XRegDeleteValue( hkeyPriority, szKey );
    }

    IRegCloseKey( hkeyPriority );


    //
    //  Free the thunklist that we allocated.
    //
    IPrioritiesThunklistFree( ptRoot.pptNext );

    return TRUE;
} // IDriverPrioritiesSave()



#else // !USETHUNKLIST


//--------------------------------------------------------------------------;
//
//  BOOL IDriverPrioritiesSave
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IDriverPrioritiesSave
(
    PACMGARB pag
)
{
    TCHAR               szKey[MAXPNAMELEN];
    UINT                uPriority;
    HACMDRIVERID        hadid;
    DWORD               fdwEnum;
    HKEY                hkeyPriority;

    DPF(1, "IDriverPrioritiesSave: saving priorities...");

    hkeyPriority   = IRegOpenKeyAcm( gszSecPriority );

    if( NULL == hkeyPriority )
    {
        DPF(1,"IDriverPrioritiesSave: Priorities hkey is NULL - can't save priorities.");
        return FALSE;
    }


    uPriority = 1;

    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;
    hadid     = NULL;
    while (!IDriverGetNext(pag, &hadid, hadid, fdwEnum))
    {
        //
        //  We should always have padid->uPriority correctly set.  Let's
        //  just check that we do.  If we don't, then there is someplace
        //  where we shoulda called IDriverRefreshPriority but didn't.
        //
        ASSERT( uPriority == ((PACMDRIVERID)hadid)->uPriority );

        wsprintf(szKey, gszKeyPriority, uPriority);
        IDriverPrioritiesWriteHadid( hkeyPriority, szKey, hadid );

        uPriority++;
    }


    //
    //  If there are any "PriorityX" strings hanging around from a
    //  previous save, delete them.
    //
    for( ; ; uPriority++ )
    {
        //
        //  If we can open the value, then delete it and continue on
        //  to the next value.  If we can't open it, then we assume
        //  that we have deleted them all and we exit the loop.
        //
        wsprintf(szKey, gszKeyPriority, uPriority);
        if( !IRegValueExists( hkeyPriority, szKey ) )
        {
            break;
        }

        XRegDeleteValue( hkeyPriority, szKey );
    }

    IRegCloseKey( hkeyPriority );

    return (TRUE);
} // IDriverPrioritiesSave()


#endif // !USETHUNKLIST



//--------------------------------------------------------------------------;
//
//  BOOL IDriverPrioritiesRestore
//
//  Description:
//
//
//  Arguments:
//      PACMGARB pag:
//
//  Return (BOOL):  If TRUE, then the priorities actually changed.
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//  Note:  This routine is NOT re-entrant.  We rely on the calling routine
//          to surround us with a critical section.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IDriverPrioritiesRestore
(
    PACMGARB pag
)
{
    TCHAR               ach[16 + ACMDRIVERDETAILS_SHORTNAME_CHARS + ACMDRIVERDETAILS_LONGNAME_CHARS];
    MMRESULT            mmr;
    TCHAR               szKey[MAXPNAMELEN];
    UINT                uPriority;
    UINT                u;
    BOOL                fEnabled;
    HACMDRIVERID        hadid;
    PACMDRIVERID        padid;
    DWORD               fdwEnum;
    DWORD               fdwPriority;
    HKEY                hkeyPriority;

    BOOL                fReturn = FALSE;


    DPF(1, "IDriverPrioritiesRestore: restoring priorities...");

    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_NOLOCAL;

    hkeyPriority = IRegOpenKeyAcm( gszSecPriority );
    uPriority = 1;
    for (u = 1; ; u++)
    {
        wsprintf(szKey, gszKeyPriority, u);

        if( !IRegReadString( hkeyPriority, szKey, ach, SIZEOF(ach) ) )
        {
            //
            //  No more values - time to quit.
            //
            break;
        }


        hadid = NULL;
        while (!IDriverGetNext(pag, &hadid, hadid, fdwEnum))
        {
            if( IDriverPrioritiesIsMatch( hadid, ach ) )
            {
                //
                //  We found a match - set the priority.
                //
                fEnabled    = ('1' == ach[0]);
                fdwPriority = fEnabled ? ACM_DRIVERPRIORITYF_ENABLE :
                                         ACM_DRIVERPRIORITYF_DISABLE;

                ASSERT( NULL != hadid );
                padid = (PACMDRIVERID)hadid;
                if( uPriority != padid->uPriority ) {
                    fReturn = TRUE;                     // Changed one!
                }

                //
                //  Note:  This call is NOT re-entrant.  We rely on having
                //  this whole routine surrounded by a critical section!
                //
                mmr = IDriverPriority( pag,
                                    (PACMDRIVERID)hadid,
                                    (DWORD)uPriority,
                                    fdwPriority );
                if (MMSYSERR_NOERROR != mmr)
                {
                    DPF(0, "!IDriverPrioritiesRestore: IDriverPriority(%u) failed! mmr=%u", uPriority, mmr);
                    continue;
                }

                uPriority++;
                break;
            }
        }
    }

    IRegCloseKey( hkeyPriority );

    //
    //  Update the priority value themselves; the previous code only
    //  re-arranged the drivers in the list.
    //
    IDriverRefreshPriority( pag );

    return fReturn;
} // IDriverPrioritiesRestore()


//--------------------------------------------------------------------------;
//
//  VOID acmFindDrivers
//
//  Description:
//
//
//  Arguments:
//	PACMGARB    pag:
//      LPTSTR	    pszSection: Section (drivers)
//
//  Return nothing:
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;
MMRESULT FNLOCAL acmFindDrivers
(
    PACMGARB pag,
    LPCTSTR  pszSection
)
{
    UINT            cchBuffer;
    HACMDRIVERID    hadid;
    UINT            cbBuffer;
    LPTSTR          pszBuf;
    LPTSTR	    pszBufOrig;
    TCHAR           szValue[2];

    //
    //  read all the keys. from [Drivers] (or [Drivers32] for NT)
    //
    cbBuffer = 256 * sizeof(TCHAR);
    for (;;)
    {
        //
        //  don't use realloc because handling error case is too much
        //  code.. besides, for small objects it's really no faster
        //
        pszBufOrig = pszBuf = (LPTSTR)GlobalAlloc(GMEM_FIXED, cbBuffer);
        if (NULL == pszBuf)
            return (MMSYSERR_NOMEM);

        //
        //
        //
        pszBuf[0] = '\0';
        cchBuffer = (UINT)GetPrivateProfileString(pszSection,
                                                  NULL,
                                                  gszNull,
                                                  pszBuf,
                                                  cbBuffer / sizeof(TCHAR),
                                                  gszIniSystem);
        if (cchBuffer < ((cbBuffer / sizeof(TCHAR)) - 5))
            break;

        DPF(3, "acmBootDrivers: increase buffer profile buffer.");

        GlobalFree(pszBufOrig);
        pszBufOrig = pszBuf = NULL;


        //
        //  if cannot fit drivers section in 32k, then something is horked
        //  with the section... so let's bail.
        //
        if (cbBuffer >= 0x8000)
            return (MMSYSERR_NOMEM);

        cbBuffer *= 2;
    }

    //
    //  look for any 'msacm.xxxx' keys
    //
    if ('\0' != *pszBuf)
    {
#ifdef WIN32
        CharLowerBuff(pszBuf, cchBuffer);
#else
        AnsiLowerBuff(pszBuf, cchBuffer);
#endif
        for ( ; '\0' != *pszBuf; pszBuf += lstrlen(pszBuf) + 1)
        {
	    // check for "msacm."
            if (_fmemcmp(pszBuf, gszTagDrivers, sizeof(gszTagDrivers) - sizeof(TCHAR)))
                continue;

	    // skip dummy driver lines (value starts with '*')
	    GetPrivateProfileString(pszSection, pszBuf, gszNull, szValue, sizeof(szValue)/sizeof(szValue[0]), gszIniSystem);
	    if (TEXT('*') == szValue[0]) continue;

            //
            //  this key is for the ACM
            //
            IDriverAdd(pag,
		       &hadid,
                       NULL,
                       (LPARAM)(LPTSTR)pszBuf,
                       0L,
                       ACM_DRIVERADDF_NAME | ACM_DRIVERADDF_GLOBAL);
        }
    }

    GlobalFree(pszBufOrig);

    return MMSYSERR_NOERROR;

} // acmFindDrivers

#if !defined(WIN32)
//--------------------------------------------------------------------------;
//
//  BOOL acmThunkTerminate
//
//  Description:
//	Thunk termination under NT WOW or Chicago
//
//  Arguments:
//	HINSTANCE hinst:
//	DWORD dwReason:
//
//  Return (BOOL):
//
//  History:
//
//--------------------------------------------------------------------------;
BOOL FNLOCAL acmThunkTerminate(HINSTANCE hinst, DWORD dwReason)
{
    BOOL    f = TRUE;

#ifdef WIN4
    //
    //	Do final thunk disconnect after 16-bit msacm termination.
    //
    f = (acmt32c_ThunkConnect16(gmbszMsacm, gmbszMsacm32, hinst, dwReason));

    if (f)
	DPF(1, "acmt32c_ThunkConnect16 disconnect successful");
    else
	DPF(1, "acmt32c_ThunkConnect16 disconnect failure");
#endif

    return (f);
}

//--------------------------------------------------------------------------;
//
//  BOOL acmThunkInit
//
//  Description:
//	Thunk initialization under NT WOW or Chicago
//
//  Arguments:
//	PACMGARB pag:
//	HINSTANCE hinst:
//	DWORD dwReason:
//
//  Return (BOOL):
//
//  History:
//
//--------------------------------------------------------------------------;
BOOL FNLOCAL acmThunkInit
(
    PACMGARB	pag,
    HINSTANCE	hinst,
    DWORD	dwReason
)
{
#ifdef WIN4
    BOOL    f;

    //
    //	Do chicago thunk connect
    //
    f = (0 != acmt32c_ThunkConnect16(gmbszMsacm, gmbszMsacm32, hinst, dwReason));

    if (f)
	DPF(1, "acmt32c_ThunkConnect16 connect successful");
    else
	DPF(1, "acmt32c_ThunkConnect16 connect failure");

    return(f);

#else
    HMODULE   hmodKernel;
    DWORD     (FAR PASCAL *lpfnLoadLibraryEx32W)(LPCSTR, DWORD, DWORD);
    LPVOID    (FAR PASCAL *lpfnGetProcAddress32W)(DWORD, LPCSTR);

    //
    //  Check if we're WOW
    //

    if (!(GetWinFlags() & WF_WINNT)) {
        return FALSE;
    }

    //
    //  See if we can find the thunking routine entry points in KERNEL
    //

    hmodKernel = GetModuleHandle(gszKernel);

    if (hmodKernel == NULL)
    {
        return FALSE;   // !!!!
    }

    *(FARPROC *)&lpfnLoadLibraryEx32W =
        GetProcAddress(hmodKernel, gszLoadLibraryEx32W);

    if (lpfnLoadLibraryEx32W == NULL)
    {
        return FALSE;
    }

    *(FARPROC *)&lpfnGetProcAddress32W = GetProcAddress(hmodKernel, gszGetProcAddress32W);

    if (lpfnGetProcAddress32W == NULL)
    {
        return FALSE;
    }

    *(FARPROC *)&pag->lpfnCallproc32W_6 = GetProcAddress(hmodKernel, gszCallproc32W);

    if (pag->lpfnCallproc32W_6 == NULL)
    {
        return FALSE;
    }

    *(FARPROC *)&pag->lpfnCallproc32W_9 = GetProcAddress(hmodKernel, gszCallproc32W);

    if (pag->lpfnCallproc32W_9 == NULL)
    {
        return FALSE;
    }

    //
    //  See if we can get a pointer to our thunking entry points
    //

    pag->dwMsacm32Handle = (*lpfnLoadLibraryEx32W)(gszMsacm32, 0L, 0L);

    if (pag->dwMsacm32Handle == 0)
    {
        return FALSE;
    }

    pag->lpvAcmThunkEntry = (*lpfnGetProcAddress32W)(pag->dwMsacm32Handle, gszAcmThunkEntry);

    if (pag->lpvAcmThunkEntry == NULL)
    {
        // acmFreeLibrary32();
        return FALSE;
    }

    pag->lpvXRegThunkEntry = (*lpfnGetProcAddress32W)(pag->dwMsacm32Handle, gszXRegThunkEntry);

    if (pag->lpvXRegThunkEntry == NULL)
    {
        // acmFreeLibrary32();
	ASSERT( FALSE );
        return FALSE;
    }

    return TRUE;
#endif
}
#endif // !WIN32


//==========================================================================;
//
//  Driver boot routines.  There are three type of drivers we need to boot.
//
//	acmBootPnpDrivers:	Called to boot pnp drivers.  Doesn't do
//				anything in 16-bit compiles.
//
//	acmBoot32BitDrivers:	Called by 16-bit ACM to boot all the
//				32-bit drivers in the 32-bit ACM.
//
//	acmBootDrivers:		Called by all compilations of the ACM
//				to boot non-pnp native bitness drivers.
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  MMRESULT acmBootPnpDrivers
//
//  Description:
//	[re]boots Chicago plug and play drivers.
//	Parses the SYSTEM\CurrentControlSet\Control\MediaResources\acm
//	registry key to see if there are any Pnp drivers to add or remove.
//
//  Arguments:
//      PACMGARB pag:
//	    Pointer to the ACMGARB structure for this process.
//
//  Return (MMRESULT):
//
//  History:
//      06/24/94    fdy	    [frankye]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL acmBootPnpDrivers
(
    PACMGARB pag
)
{
#ifdef WIN32
    LONG	    lr;
    HKEY	    hkeyAcm;
    TCHAR	    achDriverKey[MAX_DRIVER_NAME_CHARS];
    TCHAR	    szAlias[MAX_DRIVER_NAME_CHARS];
    DWORD	    cchDriverKey;
    HACMDRIVERID    hadid;
    HACMDRIVERID    hadidPrev;
    PACMDRIVERID    padid;
    DWORD	    fdwEnum;
    UINT	    i;
    MMRESULT	    mmr;
	
    BOOL	    fSomethingChanged;

    DPF(0, "acmBootPnpDrivers: begin");

    //
    //	This flag indicates whether we have removed or added a driver.  After
    //	doing any adds or removes, we check this flag to determine whether
    //	we should do IDriverBroadcastNotify.
    //
    fSomethingChanged = FALSE;

    //
    //	Open the SYSTEM\CurrentControlSet\Control\MediaResources\acm key
    //
    //
    lr = XRegOpenKeyEx(HKEY_LOCAL_MACHINE,
		      gszKeyDrivers,
		      0L,
		      KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
		      &hkeyAcm);

    if (ERROR_SUCCESS != lr)
    {
	//
	//  If we can't open the registry, I guess we better scrap any
	//  pnp drivers that might be around.  Flag this by setting
	//  hkeyAcm = NULL;
	//
	DPF(0, "acmBootPnpDrivers: could not open MediaResources\\acm key");
	hkeyAcm = NULL;
    }


    //
    //	--== Remove drivers that have disappeared ==--
    //

    //
    //	Walk the driver list and make sure any pnp drivers in the list
    //	are still in the registry.  If not in the registry then we need
    //	to remove the driver from the list.
    //
    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_REMOVED;
    hadidPrev = NULL;
	
    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadidPrev, fdwEnum))
    {
	HKEY		hkeyDriver;

	padid = (PACMDRIVERID)hadid;
	if (ACM_DRIVERADDF_PNP & padid->fdwAdd)
	{
	    //
	    //  This is a Pnp driver, make sure the alias is still in
	    //  the registry.
	    //
#ifdef UNICODE
	    lstrcpy(szAlias, padid->szAlias);
#else
	    Iwcstombs(szAlias, padid->szAlias, SIZEOF(szAlias));
#endif
	    DPF(2, "acmBootPnpDrivers: found pnp driver %s in driver list", szAlias);

	    if ( (padid->fRemove) ||
		 (NULL == hkeyAcm) ||
		 (ERROR_SUCCESS != XRegOpenKeyEx(hkeyAcm, szAlias, 0L, KEY_QUERY_VALUE, &hkeyDriver)) )
	    {
		//
		//  Couldn't open the registry key for this pnp driver (or
		//  it was already flagged to be removed). Let's try to
		//  remove it...
		//
		DPF(1, "acmBootPnpDrivers: removing pnp driver %s", szAlias);
		mmr = IDriverRemove(hadid, 0L);
		if (MMSYSERR_NOERROR == mmr)
		{
		    //
		    //
		    //
		    fSomethingChanged = fSomethingChanged ||
					(0 == (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));
		
		    //
		    //  Since we've removed hadid, let's continue on to get
		    //  the next hadid after the same hadidPrev.
		    //
		    continue;
		}

		//
		//  We couldn't remove the driver, so let's flag it to
		//  be removed next chance.
		//
		padid->fRemove = TRUE;

		//
		// Backup so we try again on next API call
		//
		pag->dwPnpLastChangeNotify--;
	    }

	    if (FALSE == padid->fRemove)
	    {
		//
		//  We must have opened the key.  Confusing, but that's the
		//  way it is.
		//
		XRegCloseKey(hkeyDriver);
	    }
	
	}
	
	hadidPrev = hadid;
    }


    //
    //	--== Add any new drivers that have arrived ==--
    //

    //
    //	Enumerate all keys and make sure all the pnp drivers in the registry
    //	are in the driver list.  If not in the driver list, then we need to
    //	add the driver to the list.
    //
    for (i=0; ; i++)
    {
	HKEY	hkeyDriver;
	
	cchDriverKey = SIZEOF(achDriverKey);

	lr = XRegEnumKeyEx(hkeyAcm,
			  i,
			  achDriverKey,
			  &cchDriverKey,
			  NULL,
			  NULL,
			  NULL,
			  NULL);

	if (ERROR_SUCCESS != lr)
	{
	    //
	    //	Couldn't open ...\MediaResources\acm, bail out
	    //
	    break;
	}

	lr = XRegOpenKeyEx(hkeyAcm, achDriverKey, 0L, KEY_QUERY_VALUE, &hkeyDriver);
	if (ERROR_SUCCESS == lr)
	{
	    lr = XRegQueryValueEx(hkeyDriver, (LPTSTR)gszDevNode, NULL, NULL, NULL, NULL);
	    XRegCloseKey(hkeyDriver);
	}

	if (ERROR_SUCCESS != lr) {
	    continue;
	}

	DPF(2, "acmBootPnpDrivers: found driver %s in registry", achDriverKey);

	//
	//  We use the subkey name as the alias for pnp drivers.  Attempt to
	//  add this driver.
	//
	mmr = IDriverAdd(pag,
			 &hadid,
			 NULL,
			 (LPARAM)(LPTSTR)achDriverKey,
			 0L,
			 ACM_DRIVERADDF_PNP | ACM_DRIVERADDF_NAME | ACM_DRIVERADDF_GLOBAL);
	if (MMSYSERR_NOERROR == mmr)
	{
	    fSomethingChanged = TRUE;
	}
    }
			
    //
    //	--==  ==--
    //
    XRegCloseKey(hkeyAcm);

    //
    //	--== Change broadcast ==--
    //
    if( fSomethingChanged )
    {
	if ( IDriverPrioritiesRestore( pag ) )
	{
	    if( !IDriverLockPriority( pag,
				      GetCurrentTask(),
				      ACMPRIOLOCK_ISLOCKED ) )
	    {
		IDriverBroadcastNotify( pag );
	    }
	}
    }

    DPF(0, "acmBootPnpDrivers: end");

#endif	// WIN32

    //
    //	--== Outta here ==--
    //
    return MMSYSERR_NOERROR;
}

#ifndef WIN32
//--------------------------------------------------------------------------;
//
//  MMRESULT acmBoot32BitDrivers
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//  Return (MMRESULT):
//
//  History:
//      06/26/94    fdy	    [frankye]
//
//  NOTE:  This code assumes that there is a critical section around
//          this routine!  Since it plays with the driver list, it is not
//          re-entrant.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL acmBoot32BitDrivers
(
    PACMGARB    pag
)
{
    HACMDRIVERID    hadid;
    HACMDRIVERID    hadidPrev;
    PACMDRIVERID    padid;
    DWORD	    hadid32;
    DWORD	    fdwEnum;
    MMRESULT	    mmr;

    BOOL	    fSomethingChanged;


    if (!pag->fWOW)
    {
	return MMSYSERR_NOERROR;
    }

    //
    //	This flag indicates whether we have removed or added a driver.  After
    //	doing any adds or removes, we check this flag to determine whether
    //	we should do IDriverBroadcastNotify.
    //
    fSomethingChanged = FALSE;

    //
    //	--== Remove drivers that have disappeared ==--
    //

    //
    //	Walk the driver list and make sure any 32-bit drivers in the list
    //	are still in the 32-bit ACM.  If not in the 32-bit ACM then we need
    //	to remove the driver from the list.
    //
    fdwEnum = ACM_DRIVERENUMF_DISABLED | ACM_DRIVERENUMF_REMOVED;
    hadidPrev = NULL;

    while (MMSYSERR_NOERROR == IDriverGetNext(pag, &hadid, hadidPrev, fdwEnum))
    {
	TCHAR		szAlias[MAX_DRIVER_NAME_CHARS];
	ACMDRIVERPROC	fnDriverProc;
	DWORD		dnDevNode;
	DWORD		fdwAdd32;
	DWORD		fdwAddType;

	padid = (PACMDRIVERID)hadid;
	if (ACM_DRIVERADDF_32BIT & padid->fdwAdd)
	{
	    //
	    //  This is a 32-bit driver, make sure the hadid32 is still
	    //  valid in our 32-bit partner.
	    //
	    fdwAddType = ACM_DRIVERADDF_TYPEMASK & padid->fdwAdd;
	    if (ACM_DRIVERADDF_FUNCTION == fdwAddType)
	    {
		DPF(2, "acmBoot32BitDrivers: found 32-bit driver function %08lx in list", padid->fnDriverProc);
	    }
	    else
	    {
		DPF(2, "acmBoot32BDrivers: found 32-bit driver name %s in list", (LPCTSTR)padid->szAlias);
	    }

	    if ( (padid->fRemove) ||
		 (MMSYSERR_NOERROR != IDriverGetInfo32(pag, padid->hadid32, szAlias, &fnDriverProc, &dnDevNode, &fdwAdd32)) ||
		 (fdwAddType != (ACM_DRIVERADDF_TYPEMASK & fdwAdd32)) ||
		 (dnDevNode  != padid->dnDevNode) ||
		 ( (ACM_DRIVERADDF_FUNCTION == fdwAddType) &&
		   (padid->fnDriverProc != fnDriverProc) ) ||
		 ( (ACM_DRIVERADDF_NAME == fdwAddType) &&
		   (lstrcmp(padid->szAlias, szAlias)) ) )
	    {
		//
		//  Let's try to remove it...
		//
		DPF(1, "acmBoot32BitDrivers: removing 32-bit driver.");
		
		mmr = IDriverRemove(hadid, 0L);
		if (MMSYSERR_NOERROR == mmr)
		{
		    //
		    //
		    //
		    fSomethingChanged = fSomethingChanged ||
					(0 == (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));
		
		    //
		    //  Since we've removed hadid, let's continue on to get
		    //  the next hadid after the same hadidPrev.
		    //
		    continue;
		}

		//
		//  We couldn't remove the driver, so let's flag it to
		//  be removed next chance.
		//
		padid->fRemove = TRUE;

		//
		// Backup so we try again on next API call
		//
		pag->dw32BitLastChangeNotify--;
	    }

	}

	hadidPrev = hadid;

    }


    //
    //	--== Add any new drivers that have arrived ==--
    //

    //
    //	Enumerate and add all 32-bit drivers.
    //
    fdwEnum = ACM_DRIVERENUMF_DISABLED;
    hadid32 = NULL;

    while (MMSYSERR_NOERROR == IDriverGetNext32(pag, &hadid32, hadid32, fdwEnum))
    {
	DPF(2, "acmBoot32BitDrivers: IDriverAdd(hadid32=%08lx)", hadid32);

	mmr = IDriverAdd(pag,
			 &hadid,
			 NULL,
			 (LPARAM)hadid32,
			 0L,
			 ACM_DRIVERADDF_32BIT);

	padid = (PACMDRIVERID)hadid;

	if (MMSYSERR_NOERROR == mmr)
	{
	    fSomethingChanged = fSomethingChanged ||
				(0 == (ACMDRIVERID_DRIVERF_LOCAL & padid->fdwDriver));
	}
		
    }


    //
    //	--== Change broadcast ==--
    //
    if( fSomethingChanged )
    {
	if ( IDriverPrioritiesRestore( pag ) )
	{
	    if( !IDriverLockPriority( pag,
				      GetCurrentTask(),
				      ACMPRIOLOCK_ISLOCKED ) )
	    {
		IDriverBroadcastNotify( pag );
	    }
	}
    }


    //
    //	--== Outta here ==--
    //
    return MMSYSERR_NOERROR;

}
#endif // !WIN32


//--------------------------------------------------------------------------;
//
//  MMRESULT acmBootDrivers
//
//  Description:
//
//
//  Arguments:
//	PACMGARB pag:
//
//  Return (MMRESULT):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//  NOTE:  This code assumes that there is a critical section around
//          this routine!  Since it plays with the driver list, it is not
//          re-entrant.
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL acmBootDrivers
(
    PACMGARB    pag
)
{
    MMRESULT	mmr;

    DPF(1, "acmBootDrivers: begin");


    //
    //  Pull out the drivers
    //
    mmr = acmFindDrivers(pag, gszSecDrivers);

    if (mmr != MMSYSERR_NOERROR)
    {
        return mmr;
    }

    //
    //	-= Load PCM converter =-
    //

    //
    //
    //	16-bit Chicago:
    //	    We don't even compile in the 16-bit PCM converter, so we don't
    //	    try to load it.
    //
    //	16-bit Daytona:
    //	    if thunks aren't working, then we try to load the 16-bit PCM
    //	    converter.
    //
    //	32-bit Chicago and Daytona:
    //	    Load it.
    //
#if defined(WIN32) || defined(NTWOW)
    {
        BOOL            fLoadPCM;
        HKEY            hkeyACM;

        hkeyACM = IRegOpenKeyAcm(gszSecACM);
        fLoadPCM = (FALSE == (BOOL)IRegReadDwordDefault( hkeyACM, gszKeyNoPCMConverter, FALSE ) );
        IRegCloseKey(hkeyACM);

#if !defined(WIN32) && defined(NTWOW)
	fLoadPCM = ( fLoadPCM && !pag->fWOW );
#endif

	if( fLoadPCM )
	{
	    HACMDRIVERID hadid;   // Dummy - return value not used

	    //
	    //  load the 'internal' PCM converter
	    //
	    mmr = IDriverAdd(pag,
		       &hadid,
		       pag->hinst,
		       (LPARAM)pcmDriverProc,
		       0L,
		       ACM_DRIVERADDF_FUNCTION | ACM_DRIVERADDF_GLOBAL);

            if( MMSYSERR_NOERROR == mmr )
            {
                //
                //  This is a bit of a hack - manually set the PCM
                //  converter's alias name.  If we don't do this, then the
                //  priorities won't get saved correctly because the alias
                //  name will be different for the 16 and 32-bit ACMs.
                //
                PACMDRIVERID padid = (PACMDRIVERID)hadid;

                ASSERT( NULL != padid );
#ifdef WIN32
                lstrcpyW( padid->szAlias, gszPCMAliasName );
#else
                lstrcpy( padid->szAlias, gszPCMAliasName );
#endif
            }
	}
    }
#endif	// WIN32 || NTWOW


    //
    //  Set the driver priorities according to the INI file.
    //
    IDriverPrioritiesRestore(pag);

    DPF(1, "acmBootDrivers: end");

    return (MMSYSERR_NOERROR);
} // acmBootDrivers()


//--------------------------------------------------------------------------;
//
//  BOOL acmTerminate
//
//  Description:
//      Termination routine for ACM interface
//
//  Arguments:
//      HINSTANCE hinst:
//	DWORD dwReason:
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL acmTerminate
(
    HINSTANCE               hinst,
    DWORD		    dwReason
)
{
    PACMDRIVERID        padid;
    PACMGARB		pag;
    UINT                uGonzo;

    DPF(1, "acmTerminate: termination begin");
    DPF(5, "!*** break for debugging ***");


    //
    //
    //
    pag = pagFind();
    if (NULL == pag)
    {
	DPF(1, "acmTerminate: NULL pag!!!");
	return (FALSE);
    }

    if (--pag->cUsage > 0)
    {
#if !defined(WIN32) && defined(WIN4)
	//
	//  On Chicago, still call thunk terminate code even when usage > 0.
	//
	acmThunkTerminate(hinst, dwReason);
#endif
	return (TRUE);
    }

    //
    //	If we've booted the drivers...
    //
    if (pag->fDriversBooted)
    {

#ifndef WIN32
	acmApplicationExit(NULL, DRVEA_NORMALEXIT);
#endif


    //
    //  Free the drivers, one by one.  This code is NOT re-entrant, since
    //  it messes with the drivers list.
    //
    ENTER_LIST_EXCLUSIVE;
	uGonzo = 666;
	while (NULL != pag->padidFirst)
	{
	    padid = pag->padidFirst;

	    padid->htask = NULL;

	    pag->hadidDestroy = (HACMDRIVERID)padid;

	    IDriverRemove(pag->hadidDestroy, 0L);

	    uGonzo--;
	    if (0 == uGonzo)
	    {
		DPF(0, "!acmTerminate: PROBLEMS REMOVING DRIVERS--TERMINATION UNORTHODOX!");
		pag->padidFirst = NULL;
	    }
	}
    LEAVE_LIST_EXCLUSIVE;


	//
	//
	//
	pag->fDriversBooted = FALSE;

    }


    //
    //
    //
#ifndef WIN32
    if (pag->fWOW)
    {
	acmThunkTerminate(hinst, dwReason);
    }
#endif

#ifdef WIN32
    DeleteLock(&pag->lockDriverIds);
#endif // WIN32

    //
    //
    //
    threadTerminate(pag);	    // this-thread termination of tls stuff
    threadTerminateProcess(pag);    // per-process termination of tls stuff


    //
    //  blow away all previous garbage
    //
#if defined(WIN32) && defined(WIN4)
    DeleteCriticalSection(&pag->csBoot);
#endif
    pagDelete(pag);

    DPF(1, "acmTerminate: termination end");
    return (TRUE);
} // acmTerminate()


//--------------------------------------------------------------------------;
//
//  BOOL acmInitialize
//
//  Description:
//      Initialization routine for ACM interface.
//
//  Arguments:
//      HINSTANCE hinst: Module instance handle of ACM.
//	DWORD dwReason:
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL acmInitialize
(
    HINSTANCE   hinst,
    DWORD	dwReason
)
{
#ifndef WIN4
    MMRESULT    mmr;
#endif
#if defined(WIN32) && defined(WIN4)
    HANDLE	hMMDevLdr;
#endif
    PACMGARB	pag;

    DPF(1, "acmInitialize: initialization begin");
    DPF(5, "!*** break for debugging ***");


#ifdef USEINITFRIENDLYNAMES
    //
    //  If the friendly names aren't in the registry, stick them there.
    //  We have to do this for NT, because we can't dink with the
    //  user profiles at setup time.
    //
    {
        HANDLE CurrentUserKey;
        HKEY hkeyAudio;
        HKEY hkeyWaveFormats;
        LONG lRet;

        if (NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &CurrentUserKey)))
        {
            lRet = RegCreateKeyEx( CurrentUserKey, gszFriendlyAudioKey, 0,
                NULL, 0, KEY_QUERY_VALUE|KEY_WRITE, NULL, &hkeyAudio, NULL );
            if( lRet == ERROR_SUCCESS )
            {
                //
                //  Check to see if "SystemFormats" value is there.
                //
                if( !IRegValueExists( hkeyAudio, gszFriendlySystemFormatsValue ) )
                {
                    DPF(1,"acmInitialize: Detected lack of friendly name stuff in HKCU, attempting to write out default values.");
                    lRet = RegCreateKeyEx( hkeyAudio,
                                gszFriendlyWaveFormatsKey, 0, NULL, 0,
                                KEY_WRITE, NULL, &hkeyWaveFormats, NULL );
                    if( lRet == ERROR_SUCCESS )
                    {
			TCHAR achFriendlyName[STRING_LEN];
			TCHAR achFriendlySystemNames[STRING_LEN*3+3];
			int   cch;

			achFriendlySystemNames[0] = '\0';

			//
			//  We will write out wave format structures into the
			//  registry for each of the friendly format names.
			//  Simultaneously, we'll create a string having the
			//  form "CD Quality,Radio Quality,Telephone Quality"
			//
			
			if (LoadString(hinst, IDS_CHOOSE_QUALITY_CD, achFriendlyName, SIZEOF(achFriendlyName))) {
			    if (!RegSetValueEx( hkeyWaveFormats,
						achFriendlyName,
						0, REG_BINARY,
						(LPBYTE)&gwfFriendlyCDQualityData,
						sizeof(PCMWAVEFORMAT) )) {
				lstrcat(achFriendlySystemNames, achFriendlyName);
				lstrcat(achFriendlySystemNames, TEXT(","));
			    }
			}

			if (LoadString(hinst, IDS_CHOOSE_QUALITY_RADIO, achFriendlyName, SIZEOF(achFriendlyName))) {
			    if (!RegSetValueEx( hkeyWaveFormats,
						achFriendlyName,
						0, REG_BINARY,
						(LPBYTE)&gwfFriendlyRadioQualityData,
						sizeof(PCMWAVEFORMAT) )) {
				lstrcat(achFriendlySystemNames, achFriendlyName);
				lstrcat(achFriendlySystemNames, TEXT(","));
			    }
			}
			
			if (LoadString(hinst, IDS_CHOOSE_QUALITY_TELEPHONE, achFriendlyName, SIZEOF(achFriendlyName))) {
			    if (!RegSetValueEx( hkeyWaveFormats,
						achFriendlyName,
						0, REG_BINARY,
						(LPBYTE)&gwfFriendlyTelephoneQualityData,
						sizeof(PCMWAVEFORMAT) )) {
				lstrcat(achFriendlySystemNames, achFriendlyName);
				lstrcat(achFriendlySystemNames, TEXT(","));
			    }
			}

                        RegCloseKey( hkeyWaveFormats );

			cch = lstrlen(achFriendlySystemNames);
			if ( (0 != cch) && (TEXT(',') == achFriendlySystemNames[cch-1]) ) {
			    achFriendlySystemNames[cch-1] = TEXT('\0');
			}
			
			//
			//
			//
			if (LoadString(hinst, IDS_CHOOSE_QUALITY_DEFAULT, achFriendlyName, SIZEOF(achFriendlyName))) {
			    IRegWriteString( hkeyAudio,
					     gszFriendlyDefaultFormatValue,
					     achFriendlyName );
			}

			if (lstrlen(achFriendlySystemNames) != 0) {
			    IRegWriteString( hkeyAudio,
					     gszFriendlySystemFormatsValue,
					     achFriendlySystemNames );
			}
                    }
#ifdef DEBUG
                    else
                    {
                        DWORD dw = GetLastError();
                        DPF(1,"!acmInitialize: Unable to open WaveFormats key (last error=%u) - not writing friendly names stuff.",dw);
                    }
#endif
                }
                else
                {
                    DPF(3,"acmInitialize:  Friendly name stuff is already set up.");
                }

                RegCloseKey( hkeyAudio );
            }
#ifdef DEBUG
            else
            {
                DWORD dw = GetLastError();
                DPF(1,"!acmInitialize: Unable to open Audio key (last error=%u) - not checking friendly names stuff.",dw);
            }
#endif
            NtClose(CurrentUserKey);
        }
#ifdef DEBUG
        else
        {
            DWORD dw = GetLastError();
            DPF(1,"!acmInitialize: Unable to open current user key (last error=%u) - not checking friendly names stuff.",dw);
        }
#endif
    }
#endif  //  USEINITFRIENDLYNAMES



    //
    //
    //
    pag = pagFind();
    if (NULL != pag)
    {
	//
	//  we've already initialized (or are in the middle of initializing)
	//  in this process.  Just bump usage (and call thunk init for Chicago)
	//
	pag->cUsage++;
#if !defined(WIN32) && defined(WIN4)
	acmThunkInit(pag, hinst, dwReason);
#endif
	return (TRUE);
    }


    //
    // Still no side effects to undo, so it's safe to return here if failure.
    //
    pag = pagNew();
    if (NULL == pag) {
	return FALSE;
    }


    //
    //
    //
    pag->cUsage		    = 1;
    pag->hinst		    = hinst;
    pag->fDriversBooted	    = FALSE;
#ifdef DEBUG
    pag->fDriversBooting    = FALSE;
#endif
#if defined(WIN32) && defined(WIN4)
    try {
	InitializeCriticalSection(&pag->csBoot);
    } except (EXCEPTION_EXECUTE_HANDLER) {
	// The only side effect to undo is the allocation of the pag
	pagDelete(pag);
	pag = NULL;
	return FALSE;
    }
#endif

    //
    //
    //
    threadInitializeProcess(pag);	// Per-process init of tls stuff
    threadInitialize(pag);		// This-thread init of tls stuff

    //
    //
    //
#ifdef WIN32
    //
    //
    //
    if (!InitializeLock(&pag->lockDriverIds))
    {
        return FALSE;
    }

#ifndef WIN4
    //	NOTE: Not compiling pnp support
#else
    //
    //	Obtain pointer to MMDevLdr's driver change notify counter.
    //
    hMMDevLdr = CreateFile(TEXT("\\\\.\\MMDEVLDR"), // magic name to attach to an already loaded vxd
			   GENERIC_WRITE,
			   FILE_SHARE_WRITE,
			   NULL,
			   OPEN_EXISTING,
			   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
			   NULL);
    if (INVALID_HANDLE_VALUE == hMMDevLdr)
    {
	DPF(0, "acmInitialize: Could not CreateFile(MMDevLdr)");
    }
    else
    {
	DWORD	cbRet;
	BOOL	f;

	cbRet = 0;
	f = DeviceIoControl (hMMDevLdr,
			     MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR,
			     NULL,
			     0,
			     &pag->lpdwPnpChangeNotify,
			     sizeof(pag->lpdwPnpChangeNotify),
			     &cbRet,
			     NULL);
	
	if ( (!f) ||
	     (sizeof(pag->lpdwPnpChangeNotify)!=cbRet) ||
	     (NULL==pag->lpdwPnpChangeNotify) )
	{
	    //
	    //	Failed to get ptr to mmdevldr change notify counter
	    //
	    if (!f)
	    {
		DPF(0, "acmInitialize: DeviceIoControl to MMDevLdr failed!");
	    }
	    else if (sizeof(pag->lpdwPnpChangeNotify)!=cbRet)
	    {
		DPF(0, "acmInitialize: MMDEVLDR_IOCTL_GETCHANENOTIFYPTR returned wrong cbRet!");
	    }
	    else
	    {
		DPF(0, "acmInitialize: MMDEVLDR_IOCTL_GETCHANGENOTIFYPTR returned NULL ptr");
	    }

	    //
	    //	Point back to a safe, innocuous place
	    //
	    pag->lpdwPnpChangeNotify = &pag->dwPnpLastChangeNotify;
	}

	CloseHandle(hMMDevLdr);
    }
#endif	// WIN4
#endif	// WIN32

#ifndef WIN32
    pag->fWOW = acmThunkInit(pag, hinst, dwReason);
#endif

#ifndef WIN4
#ifndef WIN32
    //
    //  For 16-bit find any 32-bit drivers if we're on WOW
    //
    if (pag->fWOW)
    {
	acmBoot32BitDrivers(pag);
    }
#endif
    mmr = acmBootDrivers(pag);
    if (MMSYSERR_NOERROR == mmr)
    {
	mmr = acmBootPnpDrivers(pag);
    }
    pag->fDriversBooted = TRUE;
    
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!acmInitialize: acmBootDrivers failed! mrr=%.04Xh", mmr);
#ifdef WIN32
        DeleteLock(&pag->lockDriverIds);
#endif // WIN32
	pagDelete(pag);
        return (FALSE);
    }
#endif

    DPF(1, "acmInitialize: initialization end");

    //
    //  success!
    //
    return (TRUE);
} // acmInitialize()


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef WIN32

#ifdef WIN4
//--------------------------------------------------------------------------;
//
//
//
//
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  BOOL DllEntryPoint
//
//  Description:
//	This is a special 16-bit entry point called by the Chicago kernel
//	for thunk initialization and cleanup.  It is called on each usage
//	increment or decrement.  Do not call GetModuleUsage within this
//	function as it is undefined whether the usage is updated before
//	or after this DllEntryPoint is called.
//
//  Arguments:
//	DWORD dwReason:
//		1 - attach (usage increment)
//		0 - detach (usage decrement)
//
//	HINSTANCE hinst:
//
//	WORD wDS:
//
//	WORD wHeapSize:
//
//	DWORD dwReserved1:
//
//	WORD wReserved2:
//
//  Return (BOOL):
//
//  Notes:
//	!!! WARNING !!! This code may be reentered due to thunk connections.
//
//  History:
//      02/02/94    [frankye]
//
//--------------------------------------------------------------------------;
#pragma message ("--- Remove secret MSACM.INI AllowThunks ini switch")

BOOL FNEXPORT DllEntryPoint
(
 DWORD	    dwReason,
 HINSTANCE  hinst,
 WORD	    wDS,
 WORD	    wHeapSize,
 DWORD	    dwReserved1,
 WORD	    wReserved2
)
{
    BOOL fSuccess	    = TRUE;


    DPF(1,"DllEntryPoint(dwReason=%08lxh, hinst=%04xh, wDS=%04xh, wHeapSize=%04xh, dwReserved1=%08lxh, wReserved2=%04xh", dwReason, hinst, wDS, wHeapSize, dwReserved1, wReserved2);
    DPF(5, "!*** break for debugging ***");


    //
    //	Initialize or terminate 16-bit msacm
    //
    switch (dwReason)
    {
	case 0:
	    fSuccess = acmTerminate(hinst, dwReason);
	    break;

	case 1:
	    fSuccess = acmInitialize(hinst, dwReason);
	    break;

	default:
	    fSuccess = TRUE;
	    break;
    }

    DPF(1,"DllEntryPoint exiting");

    return (fSuccess);
}
#endif

//--------------------------------------------------------------------------;
//
//
//
//
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  int WEP
//
//  Description:
//      The infamous useless WEP(). Note that this procedure needs to be
//      in a FIXED segment under Windows 3.0. Under Windows 3.1 this is
//      not necessary.
//
//  Arguments:
//      BOOL fWindowsExiting: Should tell whether Windows is exiting or not.
//
//  Return (int):
//      Always return non-zero.
//
//  History:
//      04/29/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    BOOL                    fWindowsExiting
)
{
    DPF(1, "WEP(fWindowsExiting=%u)", fWindowsExiting);

    //
    //  we RIP on exit if we are not loaded by the mapper because
    //  davidds decided to free our drivers for us instead of leaving
    //  them alone like we tried to tell him.. i have no idea what
    //  chicago will do. note that this RIP is ONLY if an app that
    //  is linked to us is running during the shutdown of windows.
    //
    if (!fWindowsExiting)
    {
#ifndef WIN4
	PACMGARB    pag;

	pag = pagFind();
	acmTerminate(pag->hinst, 0);
#endif
    }

    _cexit();

    //
    //  always return non-zero
    //
    return (1);
} // WEP()


//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//      This routine must guarantee the following things so CODEC's don't
//      have to special case code everywhere:
//
//          o   will only run in Windows 3.10 or greater (our exehdr is
//              marked appropriately).
//
//          o   will only run on >= 386 processor. only need to check
//              on Win 3.1.
//
//  Arguments:
//      HINSTANCE hinst: Our module instance handle.
//
//      WORD wDataSeg: Our data segment selector.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst,
    WORD                    wDataSeg,
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    BOOL                f;

    //
    //  we ONLY work on >= 386. if we are on a wimpy processor, scream in
    //  pain and die a horrible death!
    //
    //  NOTE! do this check first thing and get out if on a 286. we are
    //  compiling with -G3 and C8's libentry garbage does not check for
    //  >= 386 processor. the following code does not execute any 386
    //  instructions (not complex enough)..
    //

    //
    // This binary now runs on NT.  The software emulator on MIPS
    // and Alpha machines only support 286 chips !!
    //
    if (!(GetWinFlags() & WF_WINNT)) {

        //
        // We are not running on NT so fail for 286 machines
        //
        if (GetWinFlags() & WF_CPU286) {
            return (FALSE);
        }
    }


    //
    //
    //
    DbgInitialize(TRUE);

    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);
    DPF(5, "!*** break for debugging ***");

#ifndef WIN4
    f = acmInitialize(hinst, 1);
#endif

    return (f);
} // LibMain()

#else // WIN32

//==========================================================================;
//
//  WIN 32 SPECIFIC SUPPORT
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL DllMain
//
//  Description:
//      This is the standard DLL entry point for Win 32.
//
//  Arguments:
//      HINSTANCE hinst: Our instance handle.
//
//      DWORD dwReason: The reason we've been called--process/thread attach
//      and detach.
//
//      LPVOID lpReserved: Reserved. Should be NULL--so ignore it.
//
//  Return (BOOL):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp]
//	    initial
//	04/18/94    fdy	    [frankye]
//	    major mods for Chicago.  Yes, it looks real ugly now cuz of all
//	    the conditional compilation for chicago, daytona, etc.  Don't
//	    have time to think of good way to structure all this right now.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT DllMain
(
    HINSTANCE               hinst,
    DWORD                   dwReason,
    LPVOID                  lpReserved
)
{
    BOOL		f = TRUE;
#ifdef WIN4
    static HINSTANCE	hWinMM = NULL;
#endif // WIN4


    //
    //
    //
    switch (dwReason)
    {
	//
	//
	//
	case DLL_PROCESS_ATTACH:
	{
	    DbgInitialize(TRUE);
#ifdef DEBUG
	    {
		char strModuleFilename[80];
		GetModuleFileNameA(NULL, (LPSTR) strModuleFilename, 80);
		DPF(1, "DllMain: DLL_PROCESS_ATTACH: HINSTANCE=%08lx ModuleFilename=%s", hinst, strModuleFilename);
	    }
#endif
	
#ifdef WIN4
	    //
	    //  Even though we are implicitly linked to winmm.dll (via static
	    //	link to winmm.lib), doing explicit LoadLibrary on winmm helps
	    //	make sure its around all the way through our DllMain on
	    //	DLL_PROCESS_DETACH.
	    //
	    hWinMM = LoadLibrary(gszWinMM);
#endif

	    f = acmInitialize(hinst, dwReason);

#ifdef WIN4
	    //
	    //  thunk connect
	    //
	    if (f)
	    {
		acmt32c_ThunkConnect32(gmbszMsacm, gmbszMsacm32, hinst, dwReason);
	    }
#endif
	    break;
	}


	//
	//
	//
	case DLL_THREAD_ATTACH:
	{
	    threadInitialize(pagFind());
	    break;
	}


	//
	//
	//
	case DLL_THREAD_DETACH:
	{
	    threadTerminate(pagFind());
	    break;
	}

	
	//
	//
	//
	case DLL_PROCESS_DETACH:
	{
	    DPF(1, "DllMain: DLL_PROCESS_DETACH");
	
	    f = acmTerminate(hinst, dwReason);

#ifdef WIN4
	    //
	    //  thunk disconnect
	    //
	    acmt32c_ThunkConnect32(gmbszMsacm, gmbszMsacm32, hinst, dwReason);

	    FreeLibrary(hWinMM);
#endif
	    break;
	}


	//
	//
	//
	default:
	{
	    break;
	}

    }
	return (f);
	
} // DllMain()

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\locks.h ===
//==========================================================================;
//
//  locks.h
//
//  Copyright (c) 1994-1999 Microsoft Corporation
//
//  Description:
//      Implement simplified lock objects for win32
//
//  History:
//
//==========================================================================;

#pragma pack(push, 8)

typedef struct {
    CRITICAL_SECTION CriticalSection;      // Protects these fields
    HANDLE           SharedEvent;          // Wait on this for shared
    BOOL             SharedEventSet;       // State of shared event (optimize)
    HANDLE           ExclusiveEvent;       // Wait on this for exclusive
    BOOL             ExclusiveEventSet;    // State of non-shared event (optimize)
    LONG             NumberOfActive;       // > 0 if shared, < 0 if exclusive
    DWORD            ExclusiveOwnerThread; // Whose got it exclusive
} LOCK_INFO, *PLOCK_INFO;

#pragma pack(pop)

BOOL InitializeLock		(PLOCK_INFO);
VOID AcquireLockShared		(PLOCK_INFO);
VOID AcquireLockExclusive	(PLOCK_INFO);
VOID ReleaseLock		(PLOCK_INFO);
VOID DeleteLock			(PLOCK_INFO);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\msacmdlg.h ===
/***************************************************************************
 *
 *  msacmdlg.h
 *
 *  Copyright (c) 1991-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  Description:
 *      Audio Compression Manager Common Dialogs Identifiers
 *
 ***************************************************************************/


#define DLG_ACMFORMATCHOOSE_ID              70
#define IDD_ACMFORMATCHOOSE_BTN_HELP        9
#define IDD_ACMFORMATCHOOSE_CMB_CUSTOM      100
#define IDD_ACMFORMATCHOOSE_CMB_FORMATTAG   101
#define IDD_ACMFORMATCHOOSE_CMB_FORMAT      102
#define IDD_ACMFORMATCHOOSE_BTN_SETNAME     103
#define IDD_ACMFORMATCHOOSE_BTN_DELNAME     104


#define DLG_ACMFILTERCHOOSE_ID              71
#define IDD_ACMFILTERCHOOSE_BTN_HELP        9
#define IDD_ACMFILTERCHOOSE_CMB_CUSTOM      100
#define IDD_ACMFILTERCHOOSE_CMB_FILTERTAG   101
#define IDD_ACMFILTERCHOOSE_CMB_FILTER      102
#define IDD_ACMFILTERCHOOSE_BTN_SETNAME     103
#define IDD_ACMFILTERCHOOSE_BTN_DELNAME     104
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\pcm.h ===
//==========================================================================;
//
//  pcm.h
//
//  Description:
//
//
//  History:
//      11/15/92    cjp     [curtisp] 
//
//==========================================================================;


//
//  misc. defines
//
//
#define VERSION_CODEC_MAJOR     MMVERSION
#define VERSION_CODEC_MINOR     MMREVISION
#define VERSION_CODEC_BUILD	0

#define VERSION_CODEC       MAKE_ACM_VERSION(VERSION_CODEC_MAJOR,   \
                                             VERSION_CODEC_MINOR,   \
                                             VERSION_CODEC_BUILD)

#define ICON_CODEC              RCID(12)

#define MSPCM_MAX_CHANNELS          2           // max channels we deal with


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a PCMWAVEFORMAT structure.
//
#define PCM_BLOCKALIGNMENT(pwf)     (UINT)(((pwf)->wBitsPerSample >> 3) << ((pwf)->wf.nChannels >> 1))
#define PCM_BYTESTOSAMPLES(pwf, dw) (DWORD)(dw / PCM_BLOCKALIGNMENT(pwf))
#define PCM_SAMPLESTOBYTES(pwf, dw) (DWORD)(dw * PCM_BLOCKALIGNMENT(pwf))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef IDS_MSPCM_TAG
    #define IDS_MSPCM_TAG           0
#endif

#define IDS_CODEC_SHORTNAME         (IDS_MSPCM_TAG+0)
#define IDS_CODEC_LONGNAME          (IDS_MSPCM_TAG+1)
#define IDS_CODEC_COPYRIGHT         (IDS_MSPCM_TAG+2)
#define IDS_CODEC_LICENSING         (IDS_MSPCM_TAG+3)
#define IDS_CODEC_FEATURES          (IDS_MSPCM_TAG+5)


//
//
//
EXTERN_C LRESULT FNWCALLBACK pcmDriverProc
(
    DWORD_PTR               dwID,
    HACMDRIVERID            hadid,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\msacm.h ===
//==========================================================================;
//
//  msacm.h
//
//  Copyright (c) 1992-1998 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      Audio Compression Manager Public Header File
//
//  History:
//
//==========================================================================;

#ifndef _INC_ACM
#define _INC_ACM        /* #defined if msacm.h has been included */

#if !defined(_INC_MMREG) || (_INC_MMREG < 142)
#ifndef RC_INVOKED
#error MMREG.H version 142 or greater to be included first
#endif
#endif

#if defined(WIN32) && !defined(_WIN32)
#ifndef RC_INVOKED
#pragma message("MSACM.H: defining _WIN32 because application defined WIN32")
#endif
#define _WIN32
#endif

#if defined(UNICODE) && !defined(_UNICODE)
#ifndef RC_INVOKED
#pragma message("MSACM.H: defining _UNICODE because application defined UNICODE")
#endif
#define _UNICODE
#endif

#include "pshpack1.h"   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef DRV_MAPPER_PREFERRED_INPUT_GET
#define DRV_MAPPER_PREFERRED_INPUT_GET  (DRV_USER + 0)
#endif

#ifndef DRV_MAPPER_PREFERRED_OUTPUT_GET
#define DRV_MAPPER_PREFERRED_OUTPUT_GET (DRV_USER + 2)
#endif


#ifndef DRVM_MAPPER_STATUS
#define DRVM_MAPPER_STATUS              (0x2000)
#endif

#ifndef WIDM_MAPPER_STATUS
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
#endif

#ifndef WODM_MAPPER_STATUS
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
    #define ACMAPI              WINAPI
#else
#ifdef _WINDLL
    #define ACMAPI              _far _pascal _loadds
#else
    #define ACMAPI              _far _pascal
#endif
#endif


//--------------------------------------------------------------------------;
//
//  ACM General API's and Defines
//
//
//
//
//--------------------------------------------------------------------------;

//
//  there are four types of 'handles' used by the ACM. the first three
//  are unique types that define specific objects:
//
//  HACMDRIVERID: used to _identify_ an ACM driver. this identifier can be
//  used to _open_ the driver for querying details, etc about the driver.
//
//  HACMDRIVER: used to manage a driver (codec, filter, etc). this handle
//  is much like a handle to other media drivers--you use it to send
//  messages to the converter, query for capabilities, etc.
//
//  HACMSTREAM: used to manage a 'stream' (conversion channel) with the
//  ACM. you use a stream handle to convert data from one format/type
//  to another--much like dealing with a file handle.
//
//
//  the fourth handle type is a generic type used on ACM functions that
//  can accept two or more of the above handle types (for example the
//  acmMetrics and acmDriverID functions).
//
//  HACMOBJ: used to identify ACM objects. this handle is used on functions
//  that can accept two or more ACM handle types.
//
DECLARE_HANDLE(HACMDRIVERID);
typedef HACMDRIVERID       *PHACMDRIVERID;
typedef HACMDRIVERID   FAR *LPHACMDRIVERID;

DECLARE_HANDLE(HACMDRIVER);
typedef HACMDRIVER         *PHACMDRIVER;
typedef HACMDRIVER     FAR *LPHACMDRIVER;

DECLARE_HANDLE(HACMSTREAM);
typedef HACMSTREAM         *PHACMSTREAM;
typedef HACMSTREAM     FAR *LPHACMSTREAM;

DECLARE_HANDLE(HACMOBJ);
typedef HACMOBJ            *PHACMOBJ;
typedef HACMOBJ        FAR *LPHACMOBJ;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Error Codes
//
//  Note that these error codes are specific errors that apply to the ACM
//  directly--general errors are defined as MMSYSERR_*.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef _MMRESULT_
#define _MMRESULT_
typedef UINT                MMRESULT;
#endif

#define ACMERR_BASE         (512)
#define ACMERR_NOTPOSSIBLE  (ACMERR_BASE + 0)
#define ACMERR_BUSY         (ACMERR_BASE + 1)
#define ACMERR_UNPREPARED   (ACMERR_BASE + 2)
#define ACMERR_CANCELED     (ACMERR_BASE + 3)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Window Messages
//
//  These window messages are sent by the ACM or ACM drivers to notify
//  applications of events.
//
//  Note that these window message numbers will also be defined in
//  mmsystem.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define MM_ACM_OPEN         (MM_STREAM_OPEN)  // conversion callback messages
#define MM_ACM_CLOSE        (MM_STREAM_CLOSE)
#define MM_ACM_DONE         (MM_STREAM_DONE)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmGetVersion()
//
//  the ACM version is a 32 bit number that is broken into three parts as 
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows:
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) & 
//      wBuild = LOWORD(dwVersion)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

DWORD ACMAPI acmGetVersion
(
    void
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmMetrics()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmMetrics
(
    HACMOBJ                 hao,
    UINT                    uMetric,
    LPVOID                  pMetric
);

#define ACM_METRIC_COUNT_DRIVERS            1
#define ACM_METRIC_COUNT_CODECS             2
#define ACM_METRIC_COUNT_CONVERTERS         3
#define ACM_METRIC_COUNT_FILTERS            4
#define ACM_METRIC_COUNT_DISABLED           5
#define ACM_METRIC_COUNT_HARDWARE           6
#define ACM_METRIC_COUNT_LOCAL_DRIVERS      20
#define ACM_METRIC_COUNT_LOCAL_CODECS       21
#define ACM_METRIC_COUNT_LOCAL_CONVERTERS   22
#define ACM_METRIC_COUNT_LOCAL_FILTERS      23
#define ACM_METRIC_COUNT_LOCAL_DISABLED     24
#define ACM_METRIC_HARDWARE_WAVE_INPUT      30
#define ACM_METRIC_HARDWARE_WAVE_OUTPUT     31
#define ACM_METRIC_MAX_SIZE_FORMAT          50
#define ACM_METRIC_MAX_SIZE_FILTER          51
#define ACM_METRIC_DRIVER_SUPPORT           100
#define ACM_METRIC_DRIVER_PRIORITY          101


//--------------------------------------------------------------------------;
//
//  ACM Drivers
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef BOOL (CALLBACK *ACMDRIVERENUMCB)
(
    HACMDRIVERID            hadid,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmDriverEnum
(
    ACMDRIVERENUMCB         fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
);

#define ACM_DRIVERENUMF_NOTIFY      0x10000000L     // ;Internal
#define ACM_DRIVERENUMF_REMOVED	    0x20000000L	    // ;Internal
#define ACM_DRIVERENUMF_NOLOCAL     0x40000000L
#define ACM_DRIVERENUMF_DISABLED    0x80000000L
#define ACM_DRIVERENUMF_VALID       0xF0000000L     // ;Internal




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverID()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverID
(
    HACMOBJ                 hao,
    LPHACMDRIVERID          phadid,
    DWORD                   fdwDriverID
);

#define ACM_DRIVERIDF_VALID         (0L)        /* ;Internal */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverAdd()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
MMRESULT ACMAPI acmDriverAddA
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);

MMRESULT ACMAPI acmDriverAddW
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);

#ifdef _UNICODE
#define acmDriverAdd        acmDriverAddW
#else
#define acmDriverAdd        acmDriverAddA
#endif
#else
MMRESULT ACMAPI acmDriverAdd
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
);
#endif

#define ACM_DRIVERADDF_NAME         0x00000001L
#define ACM_DRIVERADDF_NOTIFY       0x00000002L  // ;Internal
#define ACM_DRIVERADDF_FUNCTION     0x00000003L  // lParam is a procedure
#define ACM_DRIVERADDF_NOTIFYHWND   0x00000004L  // lParam is notify hwnd
#define ACM_DRIVERADDF_TYPEMASK     0x00000007L  // driver type mask
#define ACM_DRIVERADDF_LOCAL        0x00000000L  // is local to current task
#define ACM_DRIVERADDF_GLOBAL       0x00000008L  // is global
#define ACM_DRIVERADDF_32BIT        0x80000000L  // ;Internal
#define ACM_DRIVERADDF_PNP	    0x40000000L	//  ;Internal
#define ACM_DRIVERADDF_VALID        (ACM_DRIVERADDF_TYPEMASK | /* ;Internal */ \
                                     ACM_DRIVERADDF_GLOBAL) /* ;Internal */ 



//
//  prototype for ACM driver procedures that are installed as _functions_
//  or _notifations_ instead of as a standalone installable driver.
//
typedef LRESULT (CALLBACK *ACMDRIVERPROC)(DWORD_PTR, HACMDRIVERID, UINT, LPARAM, LPARAM);
typedef ACMDRIVERPROC FAR *LPACMDRIVERPROC;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverRemove()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
);

#define ACM_DRIVERREMOVEF_UNINSTALL 0x00000001L	    // ;Internal
#define ACM_DRIVERREMOVEF_VALID     (1L)	    // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverOpen()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverOpen
(
    LPHACMDRIVER            phad, 
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
);

#define ACM_DRIVEROPENF_VALID       (0L)        // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverClose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
);

#define ACM_DRIVERCLOSEF_VALID      (0L)        // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverMessage()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LRESULT ACMAPI acmDriverMessage
(
    HACMDRIVER              had,
    UINT                    uMsg, 
    LPARAM                  lParam1,
    LPARAM                  lParam2
);


//
//
//
//
#define ACMDM_USER                  (DRV_USER + 0x0000)
#define ACMDM_RESERVED_LOW          (DRV_USER + 0x2000)
#define ACMDM_RESERVED_HIGH         (DRV_USER + 0x2FFF)

#define ACMDM_BASE                  ACMDM_RESERVED_LOW

#define ACMDM_DRIVER_ABOUT          (ACMDM_BASE + 11)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverPriority
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmDriverPriority
(
    HACMDRIVERID            hadid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
);


#define ACM_DRIVERPRIORITYF_ENABLE      0x00000001L
#define ACM_DRIVERPRIORITYF_DISABLE     0x00000002L
#define ACM_DRIVERPRIORITYF_ABLEMASK    0x00000003L
#define ACM_DRIVERPRIORITYF_BEGIN       0x00010000L
#define ACM_DRIVERPRIORITYF_END         0x00020000L
#define ACM_DRIVERPRIORITYF_DEFERMASK   0x00030000L

#define ACM_DRIVERPRIORITYF_VALID       0x00030003L     // ;Internal




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmDriverDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  ACMDRIVERDETAILS
//
//  the ACMDRIVERDETAILS structure is used to get various capabilities from
//  an ACM driver (codec, converter, filter).
//
#define ACMDRIVERDETAILS_SHORTNAME_CHARS    32
#define ACMDRIVERDETAILS_LONGNAME_CHARS     128
#define ACMDRIVERDETAILS_COPYRIGHT_CHARS    80
#define ACMDRIVERDETAILS_LICENSING_CHARS    128
#define ACMDRIVERDETAILS_FEATURES_CHARS     512

#ifdef _WIN32
typedef struct tACMDRIVERDETAILSA
{
    DWORD           cbStruct;           // number of valid bytes in structure

    FOURCC          fccType;            // compressor type 'audc'
    FOURCC          fccComp;            // sub-type (not used; reserved)

    WORD            wMid;               // manufacturer id
    WORD            wPid;               // product id

    DWORD           vdwACM;             // version of the ACM *compiled* for
    DWORD           vdwDriver;          // version of the driver

    DWORD           fdwSupport;         // misc. support flags
    DWORD           cFormatTags;        // total unique format tags supported
    DWORD           cFilterTags;        // total unique filter tags supported

    HICON           hicon;              // handle to custom icon

    char            szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS];
    char            szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS];
    char            szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS];
    char            szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS];
    char            szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS];

} ACMDRIVERDETAILSA, *PACMDRIVERDETAILSA, FAR *LPACMDRIVERDETAILSA;

typedef struct tACMDRIVERDETAILSW
{
    DWORD           cbStruct;           // number of valid bytes in structure

    FOURCC          fccType;            // compressor type 'audc'
    FOURCC          fccComp;            // sub-type (not used; reserved)

    WORD            wMid;               // manufacturer id
    WORD            wPid;               // product id

    DWORD           vdwACM;             // version of the ACM *compiled* for
    DWORD           vdwDriver;          // version of the driver

    DWORD           fdwSupport;         // misc. support flags
    DWORD           cFormatTags;        // total unique format tags supported
    DWORD           cFilterTags;        // total unique filter tags supported

    HICON           hicon;              // handle to custom icon

    WCHAR           szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS];
    WCHAR           szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS];
    WCHAR           szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS];
    WCHAR           szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS];
    WCHAR           szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS];

} ACMDRIVERDETAILSW, *PACMDRIVERDETAILSW, FAR *LPACMDRIVERDETAILSW;

#ifdef _UNICODE
#define ACMDRIVERDETAILS        ACMDRIVERDETAILSW
#define PACMDRIVERDETAILS       PACMDRIVERDETAILSW
#define LPACMDRIVERDETAILS      LPACMDRIVERDETAILSW
#else
#define ACMDRIVERDETAILS        ACMDRIVERDETAILSA
#define PACMDRIVERDETAILS       PACMDRIVERDETAILSA
#define LPACMDRIVERDETAILS      LPACMDRIVERDETAILSA
#endif
#else
typedef struct tACMDRIVERDETAILS
{
    DWORD           cbStruct;           // number of valid bytes in structure

    FOURCC          fccType;            // compressor type 'audc'
    FOURCC          fccComp;            // sub-type (not used; reserved)

    WORD            wMid;               // manufacturer id
    WORD            wPid;               // product id

    DWORD           vdwACM;             // version of the ACM *compiled* for
    DWORD           vdwDriver;          // version of the driver

    DWORD           fdwSupport;         // misc. support flags
    DWORD           cFormatTags;        // total unique format tags supported
    DWORD           cFilterTags;        // total unique filter tags supported

    HICON           hicon;              // handle to custom icon

    char            szShortName[ACMDRIVERDETAILS_SHORTNAME_CHARS];
    char            szLongName[ACMDRIVERDETAILS_LONGNAME_CHARS];
    char            szCopyright[ACMDRIVERDETAILS_COPYRIGHT_CHARS];
    char            szLicensing[ACMDRIVERDETAILS_LICENSING_CHARS];
    char            szFeatures[ACMDRIVERDETAILS_FEATURES_CHARS];

} ACMDRIVERDETAILS, *PACMDRIVERDETAILS, FAR *LPACMDRIVERDETAILS;
#endif

//
//  ACMDRIVERDETAILS.fccType
//
//  ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC: the FOURCC used in the fccType
//  field of the ACMDRIVERDETAILS structure to specify that this is an ACM
//  codec designed for audio.
//
//
//  ACMDRIVERDETAILS.fccComp
//
//  ACMDRIVERDETAILS_FCCCOMP_UNDEFINED: the FOURCC used in the fccComp
//  field of the ACMDRIVERDETAILS structure. this is currently an unused
//  field.
//
#define ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC mmioFOURCC('a', 'u', 'd', 'c')
#define ACMDRIVERDETAILS_FCCCOMP_UNDEFINED  mmioFOURCC('\0', '\0', '\0', '\0')


//
//  the following flags are used to specify the type of conversion(s) that
//  the converter/codec/filter supports. these are placed in the fdwSupport
//  field of the ACMDRIVERDETAILS structure. note that a converter can
//  support one or more of these flags in any combination.
//
//  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver supports
//  conversions from one format tag to another format tag. for example, if a
//  converter compresses WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, then this bit
//  should be set.
//
//  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the driver
//  supports conversions on the same format tag. as an example, the PCM
//  converter that is built into the ACM sets this bit (and only this bit)
//  because it converts only PCM formats (bits, sample rate).
//
//  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver supports
//  transformations on a single format. for example, a converter that changed
//  the 'volume' of PCM data would set this bit. 'echo' and 'reverb' are
//  also filter types.
//
//  ACMDRIVERDETAILS_SUPPORTF_HARDWARE: this flag is set if the driver supports
//  hardware input and/or output through a waveform device.
//
//  ACMDRIVERDETAILS_SUPPORTF_ASYNC: this flag is set if the driver supports
//  async conversions.
//
//
//  ACMDRIVERDETAILS_SUPPORTF_LOCAL: this flag is set _by the ACM_ if a
//  driver has been installed local to the current task. this flag is also
//  set in the fdwSupport argument to the enumeration callback function
//  for drivers.
//
//  ACMDRIVERDETAILS_SUPPORTF_DISABLED: this flag is set _by the ACM_ if a
//  driver has been disabled. this flag is also passed set in the fdwSupport
//  argument to the enumeration callback function for drivers.
//
#define ACMDRIVERDETAILS_SUPPORTF_CODEC     0x00000001L
#define ACMDRIVERDETAILS_SUPPORTF_CONVERTER 0x00000002L
#define ACMDRIVERDETAILS_SUPPORTF_FILTER    0x00000004L
#define ACMDRIVERDETAILS_SUPPORTF_HARDWARE  0x00000008L
#define ACMDRIVERDETAILS_SUPPORTF_ASYNC     0x00000010L
#define ACMDRIVERDETAILS_SUPPORTF_NOTIFY    0x10000000L     // ;Internal
#define ACMDRIVERDETAILS_SUPPORTF_LOCAL     0x40000000L
#define ACMDRIVERDETAILS_SUPPORTF_DISABLED  0x80000000L


#ifdef _WIN32
MMRESULT ACMAPI acmDriverDetailsA
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSA     padd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmDriverDetailsW
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSW     padd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmDriverDetails    acmDriverDetailsW
#else
#define acmDriverDetails    acmDriverDetailsA
#endif
#else
MMRESULT ACMAPI acmDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
);
#endif

#define ACM_DRIVERDETAILSF_VALID    (0L)        // ;Internal


 
//--------------------------------------------------------------------------;
//
//  ACM Format Tags
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatTagDetails()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFORMATTAGDETAILS_FORMATTAG_CHARS 48

#ifdef _WIN32
typedef struct tACMFORMATTAGDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

} ACMFORMATTAGDETAILSA, *PACMFORMATTAGDETAILSA, FAR *LPACMFORMATTAGDETAILSA;

typedef struct tACMFORMATTAGDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    WCHAR           szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

} ACMFORMATTAGDETAILSW, *PACMFORMATTAGDETAILSW, FAR *LPACMFORMATTAGDETAILSW;

#ifdef _UNICODE
#define ACMFORMATTAGDETAILS     ACMFORMATTAGDETAILSW
#define PACMFORMATTAGDETAILS    PACMFORMATTAGDETAILSW
#define LPACMFORMATTAGDETAILS   LPACMFORMATTAGDETAILSW
#else
#define ACMFORMATTAGDETAILS     ACMFORMATTAGDETAILSA
#define PACMFORMATTAGDETAILS    PACMFORMATTAGDETAILSA
#define LPACMFORMATTAGDETAILS   LPACMFORMATTAGDETAILSA
#endif
#else
typedef struct tACMFORMATTAGDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFormatTagIndex;
    DWORD           dwFormatTag;
    DWORD           cbFormatSize;
    DWORD           fdwSupport;
    DWORD           cStandardFormats;
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];

} ACMFORMATTAGDETAILS, *PACMFORMATTAGDETAILS, FAR *LPACMFORMATTAGDETAILS;
#endif

#ifdef _WIN32
MMRESULT ACMAPI acmFormatTagDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFormatTagDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmFormatTagDetails     acmFormatTagDetailsW
#else
#define acmFormatTagDetails     acmFormatTagDetailsA
#endif
#else
MMRESULT ACMAPI acmFormatTagDetails
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FORMATTAGDETAILSF_INDEX         0x00000000L
#define ACM_FORMATTAGDETAILSF_FORMATTAG     0x00000001L
#define ACM_FORMATTAGDETAILSF_LARGESTSIZE   0x00000002L
#define ACM_FORMATTAGDETAILSF_QUERYMASK     0x0000000FL

#define ACM_FORMATTAGDETAILSF_VALID         (ACM_FORMATTAGDETAILSF_QUERYMASK)   /* ;Internal */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatTagEnum()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFORMATTAGENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatTagEnumA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    ACMFORMATTAGENUMCBA     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
typedef BOOL (CALLBACK *ACMFORMATTAGENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILSW  paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatTagEnumW
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSW  paftd,
    ACMFORMATTAGENUMCBW     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFORMATTAGENUMCB      ACMFORMATTAGENUMCBW
#define acmFormatTagEnum        acmFormatTagEnumW
#else
#define ACMFORMATTAGENUMCB      ACMFORMATTAGENUMCBA
#define acmFormatTagEnum        acmFormatTagEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFORMATTAGENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatTagEnum
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    ACMFORMATTAGENUMCB      fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FORMATTAGENUMF_VALID    (0L)        // ;Internal


//--------------------------------------------------------------------------;
//
//  ACM Formats
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFORMATDETAILS_FORMAT_CHARS   128

#ifdef _WIN32
typedef struct tACMFORMATDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFormatIndex;
    DWORD           dwFormatTag;
    DWORD           fdwSupport;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];

} ACMFORMATDETAILSA, *PACMFORMATDETAILSA, FAR *LPACMFORMATDETAILSA;

typedef struct tACMFORMATDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFormatIndex;
    DWORD           dwFormatTag;
    DWORD           fdwSupport;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    WCHAR           szFormat[ACMFORMATDETAILS_FORMAT_CHARS];

} ACMFORMATDETAILSW, *PACMFORMATDETAILSW, FAR *LPACMFORMATDETAILSW;

#ifdef _UNICODE
#define ACMFORMATDETAILS    ACMFORMATDETAILSW
#define PACMFORMATDETAILS   PACMFORMATDETAILSW
#define LPACMFORMATDETAILS  LPACMFORMATDETAILSW
#else
#define ACMFORMATDETAILS    ACMFORMATDETAILSA
#define PACMFORMATDETAILS   PACMFORMATDETAILSA
#define LPACMFORMATDETAILS  LPACMFORMATDETAILSA
#endif
#else
typedef struct tACMFORMATDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFormatIndex;
    DWORD           dwFormatTag;
    DWORD           fdwSupport;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];

} ACMFORMATDETAILS, *PACMFORMATDETAILS, FAR *LPACMFORMATDETAILS;
#endif


#ifdef _WIN32
MMRESULT ACMAPI acmFormatDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFormatDetailsW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmFormatDetails    acmFormatDetailsW
#else
#define acmFormatDetails    acmFormatDetailsA
#endif
#else
MMRESULT ACMAPI acmFormatDetails
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FORMATDETAILSF_INDEX        0x00000000L
#define ACM_FORMATDETAILSF_FORMAT       0x00000001L
#define ACM_FORMATDETAILSF_QUERYMASK    0x0000000FL

#define ACM_FORMATDETAILSF_VALID        (ACM_FORMATDETAILSF_QUERYMASK)  // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFORMATENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILSA     pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatEnumA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    ACMFORMATENUMCBA        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

typedef BOOL (CALLBACK *ACMFORMATENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILSW     pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatEnumW
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    ACMFORMATENUMCBW        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFORMATENUMCB     ACMFORMATENUMCBW
#define acmFormatEnum       acmFormatEnumW
#else
#define ACMFORMATENUMCB     ACMFORMATENUMCBA
#define acmFormatEnum       acmFormatEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFORMATENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILS      pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFormatEnum
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FORMATENUMF_WFORMATTAG       0x00010000L
#define ACM_FORMATENUMF_NCHANNELS        0x00020000L
#define ACM_FORMATENUMF_NSAMPLESPERSEC   0x00040000L
#define ACM_FORMATENUMF_WBITSPERSAMPLE   0x00080000L
#define ACM_FORMATENUMF_CONVERT          0x00100000L
#define ACM_FORMATENUMF_SUGGEST          0x00200000L
#define ACM_FORMATENUMF_HARDWARE         0x00400000L
#define ACM_FORMATENUMF_INPUT            0x00800000L
#define ACM_FORMATENUMF_OUTPUT           0x01000000L

#define ACM_FORMATENUMF_VALID           (0x01FF0000L)    // ;Internal

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatSuggest()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmFormatSuggest
(
    HACMDRIVER          had,
    LPWAVEFORMATEX      pwfxSrc,
    LPWAVEFORMATEX      pwfxDst,
    DWORD               cbwfxDst,
    DWORD               fdwSuggest
);

#define ACM_FORMATSUGGESTF_WFORMATTAG       0x00010000L
#define ACM_FORMATSUGGESTF_NCHANNELS        0x00020000L
#define ACM_FORMATSUGGESTF_NSAMPLESPERSEC   0x00040000L
#define ACM_FORMATSUGGESTF_WBITSPERSAMPLE   0x00080000L

#define ACM_FORMATSUGGESTF_TYPEMASK         0x00FF0000L
#define ACM_FORMATSUGGESTF_VALID            (ACM_FORMATSUGGESTF_TYPEMASK) // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFormatChoose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
#define ACMHELPMSGSTRINGA       "acmchoose_help"
#define ACMHELPMSGSTRINGW       L"acmchoose_help"
#define ACMHELPMSGCONTEXTMENUA  "acmchoose_contextmenu"
#define ACMHELPMSGCONTEXTMENUW  L"acmchoose_contextmenu"
#define ACMHELPMSGCONTEXTHELPA  "acmchoose_contexthelp"
#define ACMHELPMSGCONTEXTHELPW  L"acmchoose_contexthelp"
#ifdef _UNICODE
#define ACMHELPMSGSTRING        ACMHELPMSGSTRINGW
#define ACMHELPMSGCONTEXTMENU   ACMHELPMSGCONTEXTMENUW
#define ACMHELPMSGCONTEXTHELP   ACMHELPMSGCONTEXTHELPW
#else
#define ACMHELPMSGSTRING        ACMHELPMSGSTRINGA
#define ACMHELPMSGCONTEXTMENU   ACMHELPMSGCONTEXTMENUA
#define ACMHELPMSGCONTEXTHELP   ACMHELPMSGCONTEXTHELPA
#endif
#else
#define ACMHELPMSGSTRING        "acmchoose_help"
#define ACMHELPMSGCONTEXTMENU   "acmchoose_contextmenu"
#define ACMHELPMSGCONTEXTHELP   "acmchoose_contexthelp"
#endif

//
//  MM_ACM_FORMATCHOOSE is sent to hook callbacks by the Format Chooser
//  Dialog...
//
#define MM_ACM_FORMATCHOOSE             (0x8000)

#define FORMATCHOOSE_MESSAGE            0
#define FORMATCHOOSE_FORMATTAG_VERIFY   (FORMATCHOOSE_MESSAGE+0)
#define FORMATCHOOSE_FORMAT_VERIFY      (FORMATCHOOSE_MESSAGE+1)
#define FORMATCHOOSE_CUSTOM_VERIFY      (FORMATCHOOSE_MESSAGE+2)

#define FORMATCHOOSE_FORMATTAG_ADD      (FORMATCHOOSE_MESSAGE+3)    // ;Internal
#define FORMATCHOOSE_FORMAT_ADD         (FORMATCHOOSE_MESSAGE+4)    // ;Internal

#ifdef _WIN32
typedef UINT (CALLBACK *ACMFORMATCHOOSEHOOKPROCA)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

typedef UINT (CALLBACK *ACMFORMATCHOOSEHOOKPROCW)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

#ifdef _UNICODE
#define ACMFORMATCHOOSEHOOKPROC     ACMFORMATCHOOSEHOOKPROCW
#else
#define ACMFORMATCHOOSEHOOKPROC     ACMFORMATCHOOSEHOOKPROCA
#endif
#else
typedef UINT (CALLBACK *ACMFORMATCHOOSEHOOKPROC)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);
#endif

//
//
//
//
#ifdef _WIN32
typedef struct tACMFORMATCHOOSEA
{
    DWORD           cbStruct;           // sizeof(ACMFORMATCHOOSE)
    DWORD           fdwStyle;           // chooser style flags
    
    HWND            hwndOwner;          // caller's window handle

    LPWAVEFORMATEX  pwfx;               // ptr to wfx buf to receive choice
    DWORD           cbwfx;              // size of mem buf for pwfx
    LPCSTR          pszTitle;           // dialog box title bar
    
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];    

    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // format enumeration restrictions
    LPWAVEFORMATEX  pwfxEnum;           // format describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFORMATCHOOSEHOOKPROCA pfnHook;   // ptr to hook function

} ACMFORMATCHOOSEA, *PACMFORMATCHOOSEA, FAR *LPACMFORMATCHOOSEA;

typedef struct tACMFORMATCHOOSEW
{
    DWORD           cbStruct;           // sizeof(ACMFORMATCHOOSE)
    DWORD           fdwStyle;           // chooser style flags
    
    HWND            hwndOwner;          // caller's window handle

    LPWAVEFORMATEX  pwfx;               // ptr to wfx buf to receive choice
    DWORD           cbwfx;              // size of mem buf for pwfx
    LPCWSTR         pszTitle;           // dialog box title bar
    
    WCHAR           szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    WCHAR           szFormat[ACMFORMATDETAILS_FORMAT_CHARS];    

    LPWSTR          pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // format enumeration restrictions
    LPWAVEFORMATEX  pwfxEnum;           // format describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCWSTR         pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFORMATCHOOSEHOOKPROCW pfnHook;   // ptr to hook function

} ACMFORMATCHOOSEW, *PACMFORMATCHOOSEW, FAR *LPACMFORMATCHOOSEW;

#ifdef _UNICODE
#define ACMFORMATCHOOSE     ACMFORMATCHOOSEW
#define PACMFORMATCHOOSE    PACMFORMATCHOOSEW
#define LPACMFORMATCHOOSE   LPACMFORMATCHOOSEW
#else
#define ACMFORMATCHOOSE     ACMFORMATCHOOSEA
#define PACMFORMATCHOOSE    PACMFORMATCHOOSEA
#define LPACMFORMATCHOOSE   LPACMFORMATCHOOSEA
#endif
#else
typedef struct tACMFORMATCHOOSE
{
    DWORD           cbStruct;           // sizeof(ACMFORMATCHOOSE)
    DWORD           fdwStyle;           // chooser style flags
    
    HWND            hwndOwner;          // caller's window handle

    LPWAVEFORMATEX  pwfx;               // ptr to wfx buf to receive choice
    DWORD           cbwfx;              // size of mem buf for pwfx
    LPCSTR          pszTitle;           // dialog box title bar
    
    char            szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    char            szFormat[ACMFORMATDETAILS_FORMAT_CHARS];    

    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // format enumeration restrictions
    LPWAVEFORMATEX  pwfxEnum;           // format describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFORMATCHOOSEHOOKPROC pfnHook;    // ptr to hook function

} ACMFORMATCHOOSE, *PACMFORMATCHOOSE, FAR *LPACMFORMATCHOOSE;
#endif

//
//  ACMFORMATCHOOSE.fdwStyle
//
//
//
#define ACMFORMATCHOOSE_STYLEF_SHOWHELP              0x00000004L
#define ACMFORMATCHOOSE_STYLEF_ENABLEHOOK            0x00000008L
#define ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE        0x00000010L
#define ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE  0x00000020L
#define ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT       0x00000040L
#define ACMFORMATCHOOSE_STYLEF_CONTEXTHELP           0x00000080L
#define ACMFORMATCHOOSE_STYLEF_VALID                (0x000000FCL) // ;Internal

#ifdef _WIN32
MMRESULT ACMAPI acmFormatChooseA
(
    LPACMFORMATCHOOSEA      pafmtc
);

MMRESULT ACMAPI acmFormatChooseW
(
    LPACMFORMATCHOOSEW      pafmtc
);

#ifdef _UNICODE
#define acmFormatChoose     acmFormatChooseW
#else
#define acmFormatChoose     acmFormatChooseA
#endif
#else
MMRESULT ACMAPI acmFormatChoose
(
    LPACMFORMATCHOOSE       pafmtc
);
#endif


//--------------------------------------------------------------------------;
//
//  ACM Filter Tags
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterTagDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFILTERTAGDETAILS_FILTERTAG_CHARS 48

#ifdef _WIN32
typedef struct tACMFILTERTAGDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFilterTagIndex;
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
    DWORD           fdwSupport;
    DWORD           cStandardFilters;
    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];

} ACMFILTERTAGDETAILSA, *PACMFILTERTAGDETAILSA, FAR *LPACMFILTERTAGDETAILSA;

typedef struct tACMFILTERTAGDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFilterTagIndex;
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
    DWORD           fdwSupport;
    DWORD           cStandardFilters;
    WCHAR           szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];

} ACMFILTERTAGDETAILSW, *PACMFILTERTAGDETAILSW, FAR *LPACMFILTERTAGDETAILSW;

#ifdef _UNICODE
#define ACMFILTERTAGDETAILS     ACMFILTERTAGDETAILSW
#define PACMFILTERTAGDETAILS    PACMFILTERTAGDETAILSW
#define LPACMFILTERTAGDETAILS   LPACMFILTERTAGDETAILSW
#else
#define ACMFILTERTAGDETAILS     ACMFILTERTAGDETAILSA
#define PACMFILTERTAGDETAILS    PACMFILTERTAGDETAILSA
#define LPACMFILTERTAGDETAILS   LPACMFILTERTAGDETAILSA
#endif
#else
typedef struct tACMFILTERTAGDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFilterTagIndex;
    DWORD           dwFilterTag;
    DWORD           cbFilterSize;
    DWORD           fdwSupport;
    DWORD           cStandardFilters;
    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];

} ACMFILTERTAGDETAILS, *PACMFILTERTAGDETAILS, FAR *LPACMFILTERTAGDETAILS;
#endif

#ifdef _WIN32
MMRESULT ACMAPI acmFilterTagDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFilterTagDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    DWORD                   fdwDetails
);

#ifdef _UNICODE
#define acmFilterTagDetails     acmFilterTagDetailsW
#else
#define acmFilterTagDetails     acmFilterTagDetailsA
#endif
#else
MMRESULT ACMAPI acmFilterTagDetails
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FILTERTAGDETAILSF_INDEX         0x00000000L
#define ACM_FILTERTAGDETAILSF_FILTERTAG     0x00000001L
#define ACM_FILTERTAGDETAILSF_LARGESTSIZE   0x00000002L
#define ACM_FILTERTAGDETAILSF_QUERYMASK     0x0000000FL

#define ACM_FILTERTAGDETAILSF_VALID         (ACM_FILTERTAGDETAILSF_QUERYMASK)  // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterTagEnum()
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFILTERTAGENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterTagEnumA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    ACMFILTERTAGENUMCBA     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

typedef BOOL (CALLBACK *ACMFILTERTAGENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILSW  paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterTagEnumW
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSW  paftd,
    ACMFILTERTAGENUMCBW     fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFILTERTAGENUMCB  ACMFILTERTAGENUMCBW
#define acmFilterTagEnum    acmFilterTagEnumW
#else
#define ACMFILTERTAGENUMCB  ACMFILTERTAGENUMCBA
#define acmFilterTagEnum    acmFilterTagEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFILTERTAGENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterTagEnum
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    ACMFILTERTAGENUMCB      fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FILTERTAGENUMF_VALID        (0L)        // ;Internal


//--------------------------------------------------------------------------;
//
//  ACM Filters
//
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterDetails()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMFILTERDETAILS_FILTER_CHARS   128

#ifdef _WIN32
typedef struct tACMFILTERDETAILSA
{
    DWORD           cbStruct;
    DWORD           dwFilterIndex;
    DWORD           dwFilterTag;
    DWORD           fdwSupport;
    LPWAVEFILTER    pwfltr;
    DWORD           cbwfltr;
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];

} ACMFILTERDETAILSA, *PACMFILTERDETAILSA, FAR *LPACMFILTERDETAILSA;

typedef struct tACMFILTERDETAILSW
{
    DWORD           cbStruct;
    DWORD           dwFilterIndex;
    DWORD           dwFilterTag;
    DWORD           fdwSupport;
    LPWAVEFILTER    pwfltr;
    DWORD           cbwfltr;
    WCHAR           szFilter[ACMFILTERDETAILS_FILTER_CHARS];

} ACMFILTERDETAILSW, *PACMFILTERDETAILSW, FAR *LPACMFILTERDETAILSW;

#ifdef _UNICODE
#define ACMFILTERDETAILS    ACMFILTERDETAILSW
#define PACMFILTERDETAILS   PACMFILTERDETAILSW
#define LPACMFILTERDETAILS  LPACMFILTERDETAILSW
#else
#define ACMFILTERDETAILS    ACMFILTERDETAILSA
#define PACMFILTERDETAILS   PACMFILTERDETAILSA
#define LPACMFILTERDETAILS  LPACMFILTERDETAILSA
#endif
#else
typedef struct tACMFILTERDETAILS
{
    DWORD           cbStruct;
    DWORD           dwFilterIndex;
    DWORD           dwFilterTag;
    DWORD           fdwSupport;
    LPWAVEFILTER    pwfltr;
    DWORD           cbwfltr;
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];

} ACMFILTERDETAILS, *PACMFILTERDETAILS, FAR *LPACMFILTERDETAILS;
#endif

#ifdef _WIN32
MMRESULT ACMAPI acmFilterDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    DWORD                   fdwDetails
);

MMRESULT ACMAPI acmFilterDetailsW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    DWORD                   fdwDetails
);
#ifdef _UNICODE
#define acmFilterDetails    acmFilterDetailsW
#else
#define acmFilterDetails    acmFilterDetailsA
#endif
#else
MMRESULT ACMAPI acmFilterDetails
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    DWORD                   fdwDetails
);
#endif

#define ACM_FILTERDETAILSF_INDEX        0x00000000L
#define ACM_FILTERDETAILSF_FILTER       0x00000001L
#define ACM_FILTERDETAILSF_QUERYMASK    0x0000000FL

#define ACM_FILTERDETAILSF_VALID        (ACM_FILTERDETAILSF_QUERYMASK)  // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterEnum()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
typedef BOOL (CALLBACK *ACMFILTERENUMCBA)
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILSA     pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterEnumA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    ACMFILTERENUMCBA        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

typedef BOOL (CALLBACK *ACMFILTERENUMCBW)
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILSW     pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterEnumW
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSW     pafd,
    ACMFILTERENUMCBW        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

#ifdef _UNICODE
#define ACMFILTERENUMCB     ACMFILTERENUMCBW
#define acmFilterEnum       acmFilterEnumW
#else
#define ACMFILTERENUMCB     ACMFILTERENUMCBA
#define acmFilterEnum       acmFilterEnumA
#endif
#else
typedef BOOL (CALLBACK *ACMFILTERENUMCB)
(
    HACMDRIVERID            hadid,
    LPACMFILTERDETAILS      pafd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
);

MMRESULT ACMAPI acmFilterEnum
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    ACMFILTERENUMCB         fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);
#endif

#define ACM_FILTERENUMF_DWFILTERTAG         0x00010000L

#define ACM_FILTERENUMF_VALID               0x00010000L     // ;Internal



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmFilterChoose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  MM_ACM_FILTERCHOOSE is sent to hook callbacks by the Filter Chooser
//  Dialog...
//
#define MM_ACM_FILTERCHOOSE             (0x8000)

#define FILTERCHOOSE_MESSAGE            0
#define FILTERCHOOSE_FILTERTAG_VERIFY   (FILTERCHOOSE_MESSAGE+0)
#define FILTERCHOOSE_FILTER_VERIFY      (FILTERCHOOSE_MESSAGE+1)
#define FILTERCHOOSE_CUSTOM_VERIFY      (FILTERCHOOSE_MESSAGE+2)

#define FILTERCHOOSE_FILTERTAG_ADD      (FILTERCHOOSE_MESSAGE+3)    // ;Internal
#define FILTERCHOOSE_FILTER_ADD         (FILTERCHOOSE_MESSAGE+4)    // ;Internal

#ifdef _WIN32
typedef UINT (CALLBACK *ACMFILTERCHOOSEHOOKPROCA)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

typedef UINT (CALLBACK *ACMFILTERCHOOSEHOOKPROCW)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

#ifdef _UNICODE
#define ACMFILTERCHOOSEHOOKPROC     ACMFILTERCHOOSEHOOKPROCW
#else
#define ACMFILTERCHOOSEHOOKPROC     ACMFILTERCHOOSEHOOKPROCA
#endif
#else
typedef UINT (CALLBACK *ACMFILTERCHOOSEHOOKPROC)
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);
#endif

//
//  ACMFILTERCHOOSE
//
//
#ifdef _WIN32
typedef struct tACMFILTERCHOOSEA
{
    DWORD           cbStruct;           // sizeof(ACMFILTERCHOOSE)
    DWORD           fdwStyle;           // chooser style flags

    HWND            hwndOwner;          // caller's window handle

    LPWAVEFILTER    pwfltr;             // ptr to wfltr buf to receive choice
    DWORD           cbwfltr;            // size of mem buf for pwfltr

    LPCSTR          pszTitle;

    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // filter enumeration restrictions
    LPWAVEFILTER    pwfltrEnum;         // filter describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFILTERCHOOSEHOOKPROCA pfnHook;    // ptr to hook function

} ACMFILTERCHOOSEA, *PACMFILTERCHOOSEA, FAR *LPACMFILTERCHOOSEA;

typedef struct tACMFILTERCHOOSEW
{
    DWORD           cbStruct;           // sizeof(ACMFILTERCHOOSE)
    DWORD           fdwStyle;           // chooser style flags

    HWND            hwndOwner;          // caller's window handle

    LPWAVEFILTER    pwfltr;             // ptr to wfltr buf to receive choice
    DWORD           cbwfltr;            // size of mem buf for pwfltr

    LPCWSTR         pszTitle;

    WCHAR           szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    WCHAR           szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    LPWSTR          pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // filter enumeration restrictions
    LPWAVEFILTER    pwfltrEnum;         // filter describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCWSTR         pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFILTERCHOOSEHOOKPROCW pfnHook;    // ptr to hook function

} ACMFILTERCHOOSEW, *PACMFILTERCHOOSEW, FAR *LPACMFILTERCHOOSEW;

#ifdef _UNICODE
#define ACMFILTERCHOOSE     ACMFILTERCHOOSEW
#define PACMFILTERCHOOSE    PACMFILTERCHOOSEW
#define LPACMFILTERCHOOSE   LPACMFILTERCHOOSEW
#else
#define ACMFILTERCHOOSE     ACMFILTERCHOOSEA
#define PACMFILTERCHOOSE    PACMFILTERCHOOSEA
#define LPACMFILTERCHOOSE   LPACMFILTERCHOOSEA
#endif
#else
typedef struct tACMFILTERCHOOSE
{
    DWORD           cbStruct;           // sizeof(ACMFILTERCHOOSE)
    DWORD           fdwStyle;           // chooser style flags

    HWND            hwndOwner;          // caller's window handle

    LPWAVEFILTER    pwfltr;             // ptr to wfltr buf to receive choice
    DWORD           cbwfltr;            // size of mem buf for pwfltr

    LPCSTR          pszTitle;

    char            szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    char            szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    LPSTR           pszName;            // custom name selection
    DWORD           cchName;            // size in chars of mem buf for pszName

    DWORD           fdwEnum;            // filter enumeration restrictions
    LPWAVEFILTER    pwfltrEnum;         // filter describing restrictions
    
    HINSTANCE       hInstance;          // app instance containing dlg template
    LPCSTR          pszTemplateName;    // custom template name
    LPARAM          lCustData;          // data passed to hook fn.
    ACMFILTERCHOOSEHOOKPROC pfnHook;    // ptr to hook function

} ACMFILTERCHOOSE, *PACMFILTERCHOOSE, FAR *LPACMFILTERCHOOSE;
#endif

//
//  ACMFILTERCHOOSE.fdwStyle
//
//
#define ACMFILTERCHOOSE_STYLEF_SHOWHELP              0x00000004L
#define ACMFILTERCHOOSE_STYLEF_ENABLEHOOK            0x00000008L
#define ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE        0x00000010L
#define ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE  0x00000020L
#define ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT    0x00000040L
#define ACMFILTERCHOOSE_STYLEF_CONTEXTHELP           0x00000080L
#define ACMFILTERCHOOSE_STYLEF_VALID                (0x000000FCL) // ;Internal

#ifdef _WIN32
MMRESULT ACMAPI acmFilterChooseA
(
    LPACMFILTERCHOOSEA      pafltrc
);

MMRESULT ACMAPI acmFilterChooseW
(
    LPACMFILTERCHOOSEW      pafltrc
);

#ifdef _UNICODE
#define acmFilterChoose     acmFilterChooseW
#else
#define acmFilterChoose     acmFilterChooseA
#endif
#else
MMRESULT ACMAPI acmFilterChoose
(
    LPACMFILTERCHOOSE       pafltrc
);
#endif


//--------------------------------------------------------------------------;
//
//  ACM Stream API's
//
//
//
//--------------------------------------------------------------------------;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamOpen()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
#ifdef  _WIN64
#define _DRVRESERVED    15
#else
#define _DRVRESERVED    10
#endif  // _WIN64

typedef struct tACMSTREAMHEADER
{
    DWORD           cbStruct;               // sizeof(ACMSTREAMHEADER)
    DWORD           fdwStatus;              // ACMSTREAMHEADER_STATUSF_*
    DWORD_PTR       dwUser;                 // user instance data for hdr
    LPBYTE          pbSrc;
    DWORD           cbSrcLength;
    DWORD           cbSrcLengthUsed;
    DWORD_PTR       dwSrcUser;              // user instance data for src
    LPBYTE          pbDst;
    DWORD           cbDstLength;
    DWORD           cbDstLengthUsed;
    DWORD_PTR       dwDstUser;              // user instance data for dst
    DWORD           dwReservedDriver[_DRVRESERVED];   // driver reserved work space

} ACMSTREAMHEADER, *PACMSTREAMHEADER, FAR *LPACMSTREAMHEADER;

//
//  ACMSTREAMHEADER.fdwStatus
//
//  ACMSTREAMHEADER_STATUSF_DONE: done bit for async conversions.
//
#define ACMSTREAMHEADER_STATUSF_DONE        0x00010000L
#define ACMSTREAMHEADER_STATUSF_PREPARED    0x00020000L
#define ACMSTREAMHEADER_STATUSF_INQUEUE     0x00100000L

#define ACMSTREAMHEADER_STATUSF_VALID       0x00130000L     // ;Internal


MMRESULT ACMAPI acmStreamOpen
(
    LPHACMSTREAM            phas,       // pointer to stream handle
    HACMDRIVER              had,        // optional driver handle
    LPWAVEFORMATEX          pwfxSrc,    // source format to convert
    LPWAVEFORMATEX          pwfxDst,    // required destination format
    LPWAVEFILTER            pwfltr,     // optional filter
    DWORD_PTR               dwCallback, // callback
    DWORD_PTR               dwInstance, // callback instance data
    DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
);

#define ACM_STREAMOPENF_QUERY           0x00000001
#define ACM_STREAMOPENF_ASYNC           0x00000002
#define ACM_STREAMOPENF_NONREALTIME     0x00000004
#define ACM_STREAMOPENF_VALID           (CALLBACK_TYPEMASK | 0x00000007L) // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamClose()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamClose
(
    HACMSTREAM              has,
    DWORD                   fdwClose
);

#define ACM_STREAMCLOSEF_VALID          (0L)        // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamSize()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamSize
(
    HACMSTREAM              has,
    DWORD                   cbInput,
    LPDWORD                 pdwOutputBytes,
    DWORD                   fdwSize
);

#define ACM_STREAMSIZEF_SOURCE          0x00000000L
#define ACM_STREAMSIZEF_DESTINATION     0x00000001L
#define ACM_STREAMSIZEF_QUERYMASK       0x0000000FL

#define ACM_STREAMSIZEF_VALID           (ACM_STREAMSIZEF_QUERYMASK) // ;Internal


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamReset()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamReset
(
    HACMSTREAM              has,
    DWORD                   fdwReset
);

#define ACM_STREAMRESETF_VALID          (0L)        // ;Internal




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamMessage()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamMessage
(
    HACMSTREAM              has,
    UINT                    uMsg, 
    LPARAM                  lParam1,
    LPARAM                  lParam2
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamConvert()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamConvert
(
    HACMSTREAM              has, 
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwConvert
);

#define ACM_STREAMCONVERTF_BLOCKALIGN   0x00000004
#define ACM_STREAMCONVERTF_START        0x00000010
#define ACM_STREAMCONVERTF_END          0x00000020
#define ACM_STREAMCONVERTF_VALID        (ACM_STREAMCONVERTF_BLOCKALIGN | /* ;Internal */ \
                                         ACM_STREAMCONVERTF_END | /* ;Internal */ \
                                         ACM_STREAMCONVERTF_START) /* ;Internal */ 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamPrepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamPrepareHeader
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwPrepare
);

#define ACM_STREAMPREPAREF_VALID        (0L)        // ;Internal



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  acmStreamUnprepareHeader()
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

MMRESULT ACMAPI acmStreamUnprepareHeader
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwUnprepare
);
                                       
#define ACM_STREAMUNPREPAREF_VALID      (0L)        // ;Internal


#include "poppack.h"    /* Revert to default packing */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_ACM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\pcmconv.c ===
/* Copyright (c) 1994 Microsoft Corporation */
//==========================================================================;
//
//  pcmconv.c
//
//  Description:
//      This module contains conversion routines for PCM data.
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "pcm.h"
#include "debug.h"

#ifdef WIN32
#define HUGE_T  UNALIGNED
#else
#define HUGE_T  _huge
#endif

//
//
//
//
#if defined(WIN32) || defined(DEBUG)


//--------------------------------------------------------------------------;
//
//  LPBYTE pcmReadSample_dddsss
//
//  Description:
//      These functions read a sample from the source stream in the format
//      specified by 'sss' and return the data in the destination 'ddd'
//      format in *pdw.
//
//      For example, the pcmReadSample_M16S08 function reads source data
//      that is in Stereo 8 Bit format and returns an appropriate sample
//      for the destination as Mono 16 Bit.
//
//  Arguments:
//      LPBYTE pb:
//
//      LPDWORD pdw:
//
//  Return (LPBYTE):
//
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LPBYTE FNLOCAL pcmReadSample_M08M08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *(LPBYTE)pdw = ((BYTE HUGE *)pb)[0];

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmReadSample_M08M08()

LPBYTE FNLOCAL pcmReadSample_S08M08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = (WORD)((BYTE HUGE *)pb)[0];

    *(LPWORD)pdw = (w << 8) | w;

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmReadSample_S08M08()

LPBYTE FNLOCAL pcmReadSample_M16M08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *(LPWORD)pdw = (WORD)(((BYTE HUGE *)pb)[0] ^ (BYTE)0x80) << 8;

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmReadSample_M16M08()

LPBYTE FNLOCAL pcmReadSample_S16M08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = (WORD)(((BYTE HUGE *)pb)[0] ^ (BYTE)0x80) << 8;

    *pdw = MAKELONG(w, w);

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmReadSample_S16M08()


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LPBYTE FNLOCAL pcmReadSample_M08S08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD            w;
    int             n;

    w = ((WORD HUGE_T *)pb)[0] ^ 0x8080;

    n = (int)(char)w + (int)(char)(w >> 8);

    if (n > 127)
    {
        *(LPBYTE)pdw = 255;
    }
    else if (n < -128)
    {
        *(LPBYTE)pdw = 0;
    }
    else
    {
        *(LPBYTE)pdw = (BYTE)n ^ (BYTE)0x80;
    }

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_M08S08()

LPBYTE FNLOCAL pcmReadSample_S08S08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *(LPWORD)pdw = ((WORD HUGE_T *)pb)[0];

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_S08S08()

LPBYTE FNLOCAL pcmReadSample_M16S08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    LONG            l;
    WORD            w;

    w = ((WORD HUGE_T *)pb)[0] ^ 0x8080;

    l = (long)(short)(w << 8) + (long)(short)(w & 0xFF00);

    if (l > 32767)
    {
        *(LPWORD)pdw = 32767;
    }
    else if (l < -32768)
    {
        *(LPWORD)pdw = (WORD)-32768;
    }
    else
    {
        *(LPWORD)pdw = LOWORD(l);
    }

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_M16S08()

LPBYTE FNLOCAL pcmReadSample_S16S08
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = ((WORD HUGE_T *)pb)[0] ^ 0x8080;

    *pdw = MAKELONG(w << 8, w & 0xFF00);

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_S16S08()


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LPBYTE FNLOCAL pcmReadSample_M08M16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    BYTE            b;

    b = (BYTE)(((WORD HUGE_T *)pb)[0] >> 8);

    *(LPBYTE)pdw = b ^ (BYTE)0x80;

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_M08M16()

LPBYTE FNLOCAL pcmReadSample_S08M16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = ((WORD HUGE_T *)pb)[0] & 0xFF00;

    *(LPWORD)pdw = (w | (w >> 8)) ^ 0x8080;

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_S08M16()

LPBYTE FNLOCAL pcmReadSample_M16M16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *(LPWORD)pdw = ((WORD HUGE_T *)pb)[0];

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_M16M16()

LPBYTE FNLOCAL pcmReadSample_S16M16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    WORD    w;

    w = ((WORD HUGE_T *)pb)[0];

    *pdw = MAKELONG(w, w);

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmReadSample_S16M16()


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LPBYTE FNLOCAL pcmReadSample_M08S16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    DWORD           dw;
    LONG            l;

    dw = ((DWORD HUGE_T *)pb)[0];

    l = (long)(short)LOWORD(dw) + (long)(short)HIWORD(dw);

    if (l > 32767)
    {
        *(LPBYTE)pdw = 255;
    }
    else if (l < -32768)
    {
        *(LPBYTE)pdw = 0;
    }
    else
    {
        *(LPBYTE)pdw = (BYTE)(l >> 8) ^ (BYTE)0x80;
    }

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmReadSample_M08S16()

LPBYTE FNLOCAL pcmReadSample_S08S16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    DWORD   dw;
    WORD    w1;
    WORD    w2;

    dw = ((DWORD HUGE_T *)pb)[0];

    w1 = LOWORD(dw) >> 8;
    w2 = HIWORD(dw) & 0xFF00;

    *(LPWORD)pdw = (w1 | w2) ^ 0x8080;

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmReadSample_S08S16()

LPBYTE FNLOCAL pcmReadSample_M16S16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    DWORD           dw;
    LONG            l;


    dw = ((DWORD HUGE_T *)pb)[0];

    l = (long)(short)LOWORD(dw) + (long)(short)HIWORD(dw);

    if (l > 32767)
    {
        *(LPWORD)pdw = 32767;
    }
    else if (l < -32768)
    {
        *(LPWORD)pdw = (WORD)-32768;
    }
    else
    {
        *(LPWORD)pdw = LOWORD(l);
    }

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmReadSample_M16M16()

LPBYTE FNLOCAL pcmReadSample_S16S16
(
    LPBYTE              pb,
    LPDWORD             pdw
)
{
    *pdw = ((DWORD HUGE_T *)pb)[0];

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmReadSample_S16S16()


//--------------------------------------------------------------------------;
//
//  LPBYTE pcmWriteSample_ddd
//
//  Description:
//
//
//  Arguments:
//      LPBYTE pb:
//
//      DWORD dw:
//
//  Return (LPBYTE):
//
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LPBYTE FNLOCAL pcmWriteSample_M08
(
    LPBYTE              pb,
    DWORD               dw
)
{
    ((BYTE HUGE *)pb)[0] = (BYTE)dw;

    return ((LPBYTE)&((BYTE HUGE *)pb)[1]);
} // pcmWriteSample_M08()

LPBYTE FNLOCAL pcmWriteSample_S08
(
    LPBYTE              pb,
    DWORD               dw
)
{
    ((WORD HUGE_T *)pb)[0] = LOWORD(dw);

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmWriteSample_S08()

LPBYTE FNLOCAL pcmWriteSample_M16
(
    LPBYTE              pb,
    DWORD               dw
)
{
    ((WORD HUGE_T *)pb)[0] = LOWORD(dw);

    return ((LPBYTE)&((WORD HUGE_T *)pb)[1]);
} // pcmWriteSample_M16()

LPBYTE FNLOCAL pcmWriteSample_S16
(
    LPBYTE              pb,
    DWORD               dw
)
{
    ((DWORD HUGE_T *)pb)[0] = dw;

    return ((LPBYTE)&((DWORD HUGE_T *)pb)[1]);
} // pcmWriteSample_S16()



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//  the following table is indexed by the wave format flags
//
//      x x x x
//      | | | |
//      | | | +------------ output is 1=stereo, 0=mono
//      | | +-------------- output is 1=16 bit, 0=8bit
//      | +---------------- input  is 1=stereo, 0=mono
//      +------------------ input  is 1=16 bit, 0=8bit
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef LPBYTE (FNLOCAL *PCMREADSAMPLE)(LPBYTE pb, LPDWORD pdw);

static PCMREADSAMPLE pcmReadSample_Table[] =
{
    pcmReadSample_M08M08,
    pcmReadSample_S08M08,
    pcmReadSample_M16M08,
    pcmReadSample_S16M08,

    pcmReadSample_M08S08,
    pcmReadSample_S08S08,
    pcmReadSample_M16S08,
    pcmReadSample_S16S08,

    pcmReadSample_M08M16,
    pcmReadSample_S08M16,
    pcmReadSample_M16M16,
    pcmReadSample_S16M16,

    pcmReadSample_M08S16,
    pcmReadSample_S08S16,
    pcmReadSample_M16S16,
    pcmReadSample_S16S16,
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//  the following table is indexed by the wave format flags
//
//      x x
//      | |
//      | +------------ output is 1=stereo, 0=mono
//      +-------------- output is 1=16 bit, 0=8bit
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef LPBYTE (FNLOCAL *PCMWRITESAMPLE)(LPBYTE pb, DWORD dw);

static PCMWRITESAMPLE pcmWriteSample_Table[] =
{
    pcmWriteSample_M08,
    pcmWriteSample_S08,
    pcmWriteSample_M16,
    pcmWriteSample_S16,
};



//--------------------------------------------------------------------------;
//
//  DWORD pcmConvert_C
//
//  Description:
//
//      The wave data must be PCM format with the following:
//          nSamplesPerSecond   :   1 - 0FFFFFFFFh
//          wBitsPerSample      :   8 or 16
//          nChannels           :   1 or 2
//
//  Arguments:
//      LPPCMWAVEFORMAT pwfSrc: Source PCM format.
//
//      LPBYTE pbSrc: Pointer to source bytes to convert.
//
//      LPPCMWAVEFORMAT pwfDst: Destination PCM format.
//
//      LPBYTE pbDst: Pointer to destination buffer.
//
//      DWORD dwSrcSamples: Source number of samples to convert.
//
//  Return (DWORD):
//      The return value is the total number of converted BYTES that were
//      placed in the destination buffer (pbDst).
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

#define PCM_WF_STEREO       0x0001
#define PCM_WF_16BIT        0x0002

EXTERN_C DWORD FNGLOBAL pcmConvert_C
(
    LPPCMWAVEFORMAT     pwfSrc,
    LPBYTE              pbSrc,
    LPPCMWAVEFORMAT     pwfDst,
    LPBYTE              pbDst,
    DWORD               dwSrcSamples,
    BOOL                fPartialSampleAtTheEnd,
    LPBYTE              pbDstEnd
)
{
    DWORD           dwSpsSrc;           // samples per second
    DWORD           dwSpsDst;           //
    LONG            lCurSample;
    LONG            lDecSample;
    UINT            wfSrc;              // wave format flags
    UINT            wfDst;              //
    PCMREADSAMPLE   fnReadSample;       // function to read a sample
    PCMWRITESAMPLE  fnWriteSample;      // function to write a sample
    DWORD           dwSample;
    LPBYTE          pbDstStart;


    //
    //  check for an easy out...
    //
    if (0L == dwSrcSamples)
        return (0L);

    //
    //  initialize a couple of things...
    //
    dwSpsSrc = pwfSrc->wf.nSamplesPerSec;
    dwSpsDst = pwfDst->wf.nSamplesPerSec;

    wfDst = (pwfDst->wf.nChannels >> 1);
    if (16 == pwfDst->wBitsPerSample)
        wfDst |= PCM_WF_16BIT;

    fnWriteSample = pcmWriteSample_Table[wfDst];

    wfSrc = (pwfSrc->wf.nChannels >> 1);
    if (16 == pwfSrc->wBitsPerSample)
        wfSrc |= PCM_WF_16BIT;

    fnReadSample = pcmReadSample_Table[(wfSrc << 2) | wfDst];


    //
    //
    //
    if( fPartialSampleAtTheEnd ) {
        //
        //  We'll convert the partial one individually.
        //
        dwSrcSamples--;
    }


    //
    //
    //
    pbDstStart   = pbDst;


    //
    //  all set to convert the wave data, either do a major or minor DDA
    //
    //      if (dwSpsSrc < dwSpsDst) --> DDA Major
    //      if (dwSpsSrc > dwSpsDst) --> DDA Minor
    //
    if (dwSpsSrc <= dwSpsDst)
    {
        //
        //  DDA major (dwSpsSrc < dwSpsDst)
        //
        //      start at dwSpsDst / 2
        //      decrement by dwSpsSrc
        //
        lCurSample = (dwSpsDst >> 1);
        lDecSample = dwSpsSrc;

        while (dwSrcSamples--)
        {
            pbSrc = fnReadSample(pbSrc, &dwSample);

            do
            {
                pbDst = fnWriteSample(pbDst, dwSample);
                lCurSample -= lDecSample;
            } while (lCurSample >= 0);

            lCurSample += dwSpsDst;
        }
    }
    else
    {
        //
        //  DDA minor (dwSpsSrc > dwSpsDst)
        //
        //      start at dwSpsSrc / 2
        //      decrement by dwSpsDst
        //
        lCurSample = (dwSpsSrc >> 1);
        lDecSample = dwSpsDst;

        while (dwSrcSamples--)
        {
            pbSrc = fnReadSample(pbSrc, &dwSample);

            lCurSample -= lDecSample;
            if (lCurSample >= 0)
                continue;

            pbDst = fnWriteSample(pbDst, dwSample);
            lCurSample += dwSpsSrc;
        }

    }


    //
    //
    //
    if( fPartialSampleAtTheEnd )
    {
        //
        //  Convert the partial sample.
        //
        pbSrc = fnReadSample( pbSrc, &dwSample );

        while( pbDst < pbDstEnd ) {
            pbDst = fnWriteSample( pbDst, dwSample );
        }

        ASSERT( pbDst == pbDstEnd );
    }


    //
    //
    //
    return ((DWORD)((BYTE HUGE *)pbDst - (BYTE HUGE *)pbDstStart));
} // pcmConvert_C()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\prmval32.c ===
/****************************************************************************
    prmval32.c

    msacm

    Copyright (c) 1993-1998 Microsoft Corporation

****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "acmi.h"
#include "debug.h"


void FAR _cdecl DebugOutput
(
    UINT                    flags,
    LPCSTR                  lpsz,
    ...
)
{

    //
    //  what should we do???
    //

}




/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateReadPointer | validates that a pointer is valid to
 *  read from.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/

BOOL FNGLOBAL ValidateReadPointer(const void FAR* pPoint, DWORD Len)
{
    // For now just check access to first and last byte

    try {
        volatile BYTE b;
        b = ((PBYTE)pPoint)[0];
        b = ((PBYTE)pPoint)[Len - 1];
    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_PTR, 0, pPoint);
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateWritePointer | validates that a pointer is valid to
 *  write to.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/
BOOL FNGLOBAL ValidateWritePointer(const void FAR* pPoint, DWORD Len)
{
    // For now just check read and write access to first and last byte

    try {
           volatile BYTE b;
           b = ((PBYTE)pPoint)[0];
           ((PBYTE)pPoint)[0] = b;
           b = ((PBYTE)pPoint)[Len - 1];
           ((PBYTE)pPoint)[Len - 1] = b;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_PTR, 0, pPoint);
        return FALSE;
    }
    return TRUE;
}


BOOL FNGLOBAL ValidateReadWaveFormat(LPWAVEFORMATEX pwfx)
{
    //
    //
    //
    if (!ValidateReadPointer(pwfx, sizeof(PCMWAVEFORMAT)))
    {
	return (FALSE);
    }

    if (WAVE_FORMAT_PCM == pwfx->wFormatTag)
    {
	return (TRUE);
    }

    if (!ValidateReadPointer(&(pwfx->cbSize), sizeof(pwfx->cbSize)))
    {
	return (FALSE);
    }

    if (0 == pwfx->cbSize)
    {
	return (TRUE);
    }

    if (!ValidateReadPointer(&(pwfx->cbSize), pwfx->cbSize + sizeof(pwfx->cbSize)))
    {
	return (FALSE);
    }

    return (TRUE);
}


BOOL FNGLOBAL ValidateReadWaveFilter(LPWAVEFILTER pwf)
{
    //
    //
    //
    if (!ValidateReadPointer(&(pwf->cbStruct), sizeof(pwf->cbStruct)))
    {
	return (FALSE);
    }

    if (pwf->cbStruct < sizeof(WAVEFILTER))
    {
	return (FALSE);
    }

    if (!ValidateReadPointer(pwf, pwf->cbStruct))
    {
	return (FALSE);
    }

    return (TRUE);
}


BOOL FNGLOBAL ValidateCallback(FARPROC lpfnCallback)
{
    if (IsBadCodePtr(lpfnCallback))
    {
        LogParamError(ERR_BAD_CALLBACK, 0, lpfnCallback);
        return FALSE;
    }

    return (TRUE);
}

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidDriverCallback |
 *
 *  validates that a driver callback is valid, to be valid a driver
 *  callback must be a valid window, task, or a function in a FIXED DLL
 *  code segment.
 *
 * @parm DWORD  | dwCallback | callback to validate
 * @parm DWORD  | wFlags     | driver callback flags
 *
 * @rdesc Returns 0  if <dwCallback> is a valid callback
 *        Returns error condition if <dwCallback> is not a valid callback
 ***************************************************************************/

BOOL FNGLOBAL ValidateDriverCallback(DWORD_PTR hCallback, UINT dwFlags)
{
    switch (dwFlags & DCB_TYPEMASK) {
    case DCB_WINDOW:
        if (!IsWindow((HWND)hCallback)) {
            LogParamError(ERR_BAD_HWND, 0, hCallback);
            return FALSE;
        }
        break;

    case DCB_TASK:
        //if (IsBadCodePtr((FARPROC)hCallback)) {
        //    LogParamError(ERR_BAD_CALLBACK, 0, hCallback);
        //    return FALSE;
        //}
        break;

    case DCB_FUNCTION:
        if (IsBadCodePtr((FARPROC)hCallback)) {
            LogParamError(ERR_BAD_CALLBACK, 0, hCallback);
            return FALSE;
        }
        break;
    }

    return TRUE;
}

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateString |
 *
 **************************************************************************/
BOOL FNGLOBAL ValidateStringA(LPCSTR pPoint, UINT Len)
{
    // For now just check access - do a 'strnlen'

    try {
           volatile BYTE b;
           LPCSTR p = pPoint;

           while (Len--) {
               b = *p;
               if (!b) {
                   break;
               }
               p++;
           }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_STRING_PTR, 0, pPoint);
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateStringW |
 *
 **************************************************************************/
BOOL FNGLOBAL ValidateStringW(LPCWSTR pPoint, UINT Len)
{
    // For now just check access - do a 'strnlen'

    try {
           volatile WCHAR b;
           LPCWSTR p = pPoint;

           while (Len--) {
               b = *p;
               if (!b) {
                   break;
               }
               p++;
           }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_STRING_PTR, 0, pPoint);
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateHandle | validates a handle created with NewHandle
 *
 * @parm PHNDL | hLocal | handle returned from NewHandle
 * @parm UINT  | wType  | unique id describing handle type
 *
 * @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
 *        Returns FALSE if <h> is not a valid handle
 *
 * @comm  if the handle is invalid an error will be generated.
 *
 **************************************************************************/
BOOL FNGLOBAL ValidateHandle(HANDLE hLocal, UINT uType)
{
   BOOL OK;

   try {
#if 0
       OK = HtoPH(hLocal)->uHandleType == uType;
#else
        if (TYPE_HACMOBJ == uType)
        {
            switch (((PACMDRIVERID)hLocal)->uHandleType)
            {
                case TYPE_HACMDRIVERID:
                case TYPE_HACMDRIVER:
                case TYPE_HACMSTREAM:
                    OK = TRUE;
                    break;

                default:
                    OK = FALSE;
                    break;
            }
        }
        else
        {
            OK = (uType == ((PACMDRIVERID)hLocal)->uHandleType);
        }
#endif

    } except(EXCEPTION_EXECUTE_HANDLER) {
      LogParamError(ERR_BAD_HANDLE, 0, hLocal);
      return FALSE;
   }

   return OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\pcm.c ===
//==========================================================================;
//
//  pcm.c
//
//  Description:
//      This is the 'PCM' converter.  it is just like any other 'real'
//      audio converter.  It has a standard ConverterProc.
//
//      the ACM calls
//
//      acmDriverAdd(pcmDriverProc,
//                   ACM_DRIVERADDF_FUNCTION | ACM_DRIVERADDF_GLOBAL);
//
//      when it is loaded.
//
//  History:
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include "muldiv32.h"
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "uchelp.h"
#include "pcm.h"
#include "debug.h"

//
//  We don't want to include the 16-bit PCM converter in Chicago msacm.dll.
//
#if defined(WIN32) || defined(NTWOW)


//
//  we use this dwId to determine when we where opened as an audio codec
//  by the ACM or from the control panel, etc. see acmdDriverOpen for more
//  information.
//
#define BOGUS_DRIVER_ID     1L


#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))

//
//  array of WAVE format tags supported.
//
//  NOTE! if you change anything in this structure (order, addition, removal)
//  you must also fix acmdFormatTagDetails!
//
static const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM
};

#define CODEC_MAX_FORMAT_TAGS   SIZEOF_ARRAY(gauFormatTagIndexToTag)


//
//  array of _standard_ sample rates supported
//
//
static const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#define CODEC_MAX_SAMPLE_RATES  SIZEOF_ARRAY(gauFormatIndexToSampleRate)

//
//
//
//
#define CODEC_MAX_CHANNELS      (MSPCM_MAX_CHANNELS)

//
//  array of bits per sample supported
//
//
static const UINT gauFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define CODEC_MAX_BITSPERSAMPLE_PCM SIZEOF_ARRAY(gauFormatIndexToBitsPerSample)




//
//  number of formats we enumerate per channels is number of sample rates
//  times number of channels times number of
//  (bits per sample) types.
//
#define CODEC_MAX_STANDARD_FORMATS_PCM  (CODEC_MAX_SAMPLE_RATES *   \
                                         CODEC_MAX_CHANNELS *       \
                                         CODEC_MAX_BITSPERSAMPLE_PCM)



//
//  array of WAVE filter tags supported.
//
//static DWORD gauFilterIndexToTag[] =
//{
//};
#define CODEC_MAX_FILTER_TAGS   0


//
//
//
//
typedef struct tCODECINST
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the codec will be easier to combine
    //  with other types of codecs (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of codec: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your codec requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           dwFlags;        // flags from open description

} CODECINST, *PCODECINST, FAR *LPCODECINST;



//
//
//
#if defined(WIN32) || defined(DEBUG)
    EXTERN_C DWORD FNGLOBAL pcmConvert_C
    (
        LPPCMWAVEFORMAT pwfSrc,
        LPBYTE          pbSrc,
        LPPCMWAVEFORMAT pwfDst,
        LPBYTE          pbDst,
        DWORD           dwSrcSamples,
        BOOL            fPartialSampleAtTheEnd,
        LPBYTE          pbDstEnd
    );

#if defined(WIN32)
    #define pcmConvert          pcmConvert_C
#endif
#endif

#if !defined(WIN32)
#error Somebody's got to add a fPartialSampleAtTheEnd thingy to the 386-assembly PCM converter!
    EXTERN_C DWORD FNGLOBAL pcmConvert_386
    (
        LPPCMWAVEFORMAT pwfSrc,
        LPBYTE          pbSrc,
        LPPCMWAVEFORMAT pwfDst,
        LPBYTE          pbDst,
        DWORD           dwSrcSamples
    );

    #define pcmConvert          pcmConvert_386
#endif


typedef DWORD (FNGLOBAL *CONVERTPROC)
(
    LPPCMWAVEFORMAT,
    LPBYTE,
    LPPCMWAVEFORMAT,
    LPBYTE,
    DWORD,
    BOOL,
    LPBYTE
);


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX  pwfx
)
{
    UINT    uBlockAlign;

    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > MSPCM_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if ((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    uBlockAlign = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
    if (uBlockAlign != (UINT)pwfx->nBlockAlign)
        return (FALSE);

    if ((0L == pwfx->nSamplesPerSec) || (0x3FFFFFFF < pwfx->nSamplesPerSec))
    {
        return (FALSE);
    }


    //
    //  finally, verify that avg bytes per second is correct
    //
    if ((pwfx->nSamplesPerSec * uBlockAlign) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//==========================================================================;
//
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can and will be opened on a single
//      open _driver instance_. Do not store create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR               hdrvr,
    LPACMDRVOPENDESC    paod
)
{
    PCODECINST      pci;

    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  return a special non-zero value (it will be passed back as dwId
    //  to the DriverProc on following messages).
    //
    if (NULL == paod)
        return (BOGUS_DRIVER_ID);

    //
    //  the open description that is passed to this driver can be from
    //  multiple 'managers.' for example, AVI looks for installable drivers
    //  that are tagged with 'vidc' and 'vcap'. we need to verify that we
    //  are being opened as an Audio Compression Manager driver.
    //
    //  refuse to open if we are not being opened as an ACM driver. note
    //  that we do NOT modify the value of paod->dwError in this case.
    //
    if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        return (0L);


    //
    //  we are being opened as an ACM driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure.
    //
    pci = (PCODECINST)LocalAlloc(LPTR, sizeof(*pci));

    //
    //  if we cannot allocate our instance structure, then we must fail
    //  the open request. however, we also want to give the reason why
    //  we are failing the open--so we fill in the dwError member of
    //  the ACMDRVOPENDESC structure...
    //
    if (NULL == pci)
    {
        paod->dwError = MMSYSERR_NOMEM;
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pci->fccType      = paod->fccType;
    pci->fnDriverProc = (DRIVERPROC)NULL;

    pci->hdrvr        = hdrvr;              // driver handle to our driver
    pci->vdwACM       = paod->dwVersion;    // version of ACM opening us
    pci->dwFlags      = paod->dwFlags;      // flags opened with


    //
    //  finally, succeed the open... return our instance data pointer.
    //  this pointer will be passed as the dwId argument of our driver
    //  procedure on all following messages for this open instance.
    //
    paod->dwError = MMSYSERR_NOERROR;


    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)(UINT_PTR)pci);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PCODECINST              pci
)
{
    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pci)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pci);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      some configuration information was changed. however, the driver
//      does not require Windows to be restarted--the changes have already
//      been applied.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PCODECINST              pci,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a configuration dialog box, so
        //  return zero...
        //
        return (0L);
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  some configuration information was changed. however, the driver
    //  does not require Windows to be restarted--the changes have already
    //  been applied.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
    //
    //  return DRVCNF_CANCEL--this ACM driver does not support configuration
    //
    return (DRVCNF_CANCEL);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PCODECINST              pci,
    LPACMDRIVERDETAILS      paddOut
)
{
    LPACMDRIVERDETAILS  padd;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.  we allocate this dynamically instead of automatically
    //  because it is a very large structure.
    //
    padd = (LPACMDRIVERDETAILS)LocalAlloc(LPTR, sizeof(*padd));
    if (NULL == padd) return MMSYSERR_NOMEM;

    cbStruct              = min(paddOut->cbStruct, sizeof(ACMDRIVERDETAILS));
    padd->cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    padd->fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    padd->fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    padd->wMid            = MM_MICROSOFT;
    padd->wPid            = MM_MSFT_ACM_PCM;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    padd->vdwACM          = VERSION_MSACM_REQ; // required level, not the actual level
    padd->vdwDriver       = VERSION_CODEC;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    padd->fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    padd->cFormatTags     = CODEC_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    padd->cFilterTags     = CODEC_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
	PACMGARB pag;
	
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        padd->hicon = NULL;

	pag = pagFind();
	if (NULL == pag)
	{
	    DPF(1, "acmdDriverDetails: NULL pag!!!");
	}
	else
	{
	    //
	    //  the short name and long name are used to represent the driver
	    //  in a unique description. the short name is intended for small
	    //  display areas (for example, in a menu or combo box). the long
	    //  name is intended for more descriptive displays (for example,
	    //  in an 'about box').
	    //
	    //  NOTE! an ACM driver should never place formatting characters
	    //  of any sort in these strings (for example CR/LF's, etc). it
	    //  is up to the application to format the text.
	    //
#ifdef WIN32
	    LoadStringW(pag->hinst, IDS_CODEC_SHORTNAME, padd->szShortName, SIZEOFW(padd->szShortName));
	    LoadStringW(pag->hinst, IDS_CODEC_LONGNAME,  padd->szLongName,  SIZEOFW(padd->szLongName));
#else
	    LoadString(pag->hinst, IDS_CODEC_SHORTNAME, padd->szShortName, SIZEOF(padd->szShortName));
	    LoadString(pag->hinst, IDS_CODEC_LONGNAME,  padd->szLongName,  SIZEOF(padd->szLongName));
#endif

	    //
	    //  the last three members are intended for 'about box' information.
	    //  these members are optional and may be zero length strings if
	    //  the driver wishes.
	    //
	    //  NOTE! an ACM driver should never place formatting characters
	    //  of any sort in these strings (for example CR/LF's, etc). it
	    //  is up to the application to format the text.
	    //
	    if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
	    {
#ifdef WIN32
		LoadStringW(pag->hinst, IDS_CODEC_COPYRIGHT, padd->szCopyright, SIZEOFW(padd->szCopyright));
		LoadStringW(pag->hinst, IDS_CODEC_LICENSING, padd->szLicensing, SIZEOFW(padd->szLicensing));
		LoadStringW(pag->hinst, IDS_CODEC_FEATURES,  padd->szFeatures,  SIZEOFW(padd->szFeatures));
#else
		LoadString(pag->hinst, IDS_CODEC_COPYRIGHT, padd->szCopyright, SIZEOF(padd->szCopyright));
		LoadString(pag->hinst, IDS_CODEC_LICENSING, padd->szLicensing, SIZEOF(padd->szLicensing));
		LoadString(pag->hinst, IDS_CODEC_FEATURES,  padd->szFeatures,  SIZEOF(padd->szFeatures));
#endif
	    }
	}
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(paddOut, padd, (UINT)padd->cbStruct);

    //
    //  free our temporary structure
    //
    LocalFree((HLOCAL)padd);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PCODECINST              pci,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does NOT support a custom about box, so
        //  return MMSYSERR_NOTSUPPORTED...
        //
        return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  this driver does not support a custom dialog, so tell the ACM or
    //  calling application to display one for us. note that this is the
    //  _recommended_ method for consistency and simplicity of ACM drivers.
    //  why write code when you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PCODECINST              pci,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    DWORD                   fdwSuggest;


    //
    //  grab the suggestion restriction bits and verify that we support
    //  the ones that are specified... an ACM driver must return the
    //  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
    //  are not supported.
    //
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


    //
    //  get the source and destination formats in more convenient variables
    //
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;


    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  strictly verify that the source format is acceptable for
            //  this driver
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            //  if the destination format tag is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is only able to convert PCM
            //
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_PCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
            }


            //
            //  if the destination channel count is restricted, verify that
            //  it is within our capabilities...
            //
            //  this driver is only able to deal with 1 and 2 channels.
            //
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if ((pwfxDst->nChannels < 1) ||
                    (pwfxDst->nChannels > MSPCM_MAX_CHANNELS))
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = pwfxSrc->nChannels;
            }


            //
            //  if the destination samples per second is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver does any sample rate conversions...
            //
            if (0 == (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest))
            {
                pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }


            //
            //  if the destination bits per sample is restricted, verify
            //  that it is within our capabilities...
            //
            //  this driver is only able to convert to 16 or 8 bit
            //
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if ((16 != pwfxDst->wBitsPerSample) &&
                    (8  != pwfxDst->wBitsPerSample))
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = pwfxSrc->wBitsPerSample;
            }


            //
            //  at this point, we have filled in all fields except the
            //  following for our 'suggested' destination format:
            //
            //      nAvgBytesPerSec
            //      nBlockAlign
            //      cbSize              !!! not used for PCM !!!
            //
            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfxDst);
            pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                       pwfxDst->nBlockAlign;

            // pwfxDst->cbSize       = not used;

            return (MMSYSERR_NOERROR);
    }


    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this ACM driver
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PCODECINST              pci,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (CODEC_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            if (WAVE_FORMAT_PCM != padft->dwFormatTag)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = WAVE_FORMAT_PCM;
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;
            padft->cStandardFormats = CODEC_MAX_STANDARD_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0]   =  '\0';
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PCODECINST              pci,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    UINT                uFormatIndex;
    UINT                u;


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  verify that the format tag is something we know about
            //
            if (WAVE_FORMAT_PCM != padf->dwFormatTag)
                return (ACMERR_NOTPOSSIBLE);

            if (CODEC_MAX_STANDARD_FORMATS_PCM <= padf->dwFormatIndex)
                return (ACMERR_NOTPOSSIBLE);

            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;
            uFormatIndex = (UINT)padf->dwFormatIndex;

            //
            //  now fill in the format structure
            //
            pwfx->wFormatTag      = WAVE_FORMAT_PCM;

            u = uFormatIndex / (CODEC_MAX_BITSPERSAMPLE_PCM * CODEC_MAX_CHANNELS);
            pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

            u = uFormatIndex % CODEC_MAX_CHANNELS;
            pwfx->nChannels       = u + 1;

            u = (uFormatIndex / CODEC_MAX_CHANNELS) % CODEC_MAX_CHANNELS;
            pwfx->wBitsPerSample  = (WORD)gauFormatIndexToBitsPerSample[u];

            pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT((LPPCMWAVEFORMAT)pwfx);
            pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

            //
            //  note that the cbSize field is NOT valid for PCM formats
            //
            //  pwfx->cbSize      = 0;
            break;


        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            if (!pcmIsValidFormat(padf->pwfx))
                return (ACMERR_NOTPOSSIBLE);

            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    BOOL                fRealTime;


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    if (!pcmIsValidFormat(pwfxSrc) || !pcmIsValidFormat(pwfxDst))
    {
        //
        //  either the source or destination format is illegal for this
        //  codec--or the conversion between the formats can not be
        //  performed by this codec.
        //
        return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (ACM_STREAMOPENF_QUERY & padsi->fdwOpen)
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //



    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure.
    //
    padsi->dwDriver = (DWORD_PTR)pcmConvert;

#if !defined(WIN32) && defined(DEBUG)
    if (0 != GetProfileInt("mspcm", "useccode", 0))
    {
        padsi->dwDriver = (DWORD)pcmConvert_C;
    }
#endif

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    DWORD               cbSrc;
    DWORD               cbDst;

    //
    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;


    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            cbSrc = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxSrc, padss->cbSrcLength);

            if (0L == cbSrc)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            //
            //  Check for overflow condition.
            //
            if (pwfxDst->nAvgBytesPerSec >= pwfxSrc->nAvgBytesPerSec)
            {
                cbDst = (0xFFFFFFFFL / pwfxDst->nAvgBytesPerSec) - pwfxDst->nBlockAlign;

                if ((padss->cbSrcLength / pwfxSrc->nAvgBytesPerSec) > cbDst)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }

            cbDst = MulDivRU(cbSrc,
                             pwfxDst->nSamplesPerSec,
                             pwfxSrc->nSamplesPerSec);

            cbDst = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxDst, cbDst);

            if (0L == cbDst)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            padss->cbDstLength = cbDst;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            cbDst = PCM_BYTESTOSAMPLES((LPPCMWAVEFORMAT)pwfxDst, padss->cbDstLength);

            if (0L == cbDst)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            //
            //  Check for overflow condition.
            //
            if (pwfxSrc->nAvgBytesPerSec >= pwfxDst->nAvgBytesPerSec)
            {
                cbSrc = (0xFFFFFFFFL / pwfxSrc->nAvgBytesPerSec) - pwfxSrc->nBlockAlign;

                if ((padss->cbDstLength / pwfxDst->nAvgBytesPerSec) > cbSrc)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }

            //
            //  Usually, we round down when calculating the size of the
            //  source buffer.  Unfortunately, this leads to a difficult
            //  problem with PCM conversion.  Normally, the calling app
            //  should be able to allocate a block-aligned dest buffer,
            //  call acmStreamSize to find out the required source buffer
            //  size, use that size, and always receive a full dest buffer.
            //  However, suppose that the app wants to record 22kHz data
            //  from a 11kHz card and provides a dest buffer with an odd
            //  number of samples.  If we round down in figuring out the
            //  source size, then the output will be one sample less than
            //  the size of the dest buffer.  BAD NEWS!  So here we round
            //  up, and then check for this case in the acmdStreamConvert
            //  function.
            //
            cbSrc = MulDivRU(cbDst,
                             pwfxSrc->nSamplesPerSec,
                             pwfxDst->nSamplesPerSec);

            cbSrc = PCM_SAMPLESTOBYTES((LPPCMWAVEFORMAT)pwfxSrc, cbSrc);

            if (0L == cbSrc)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            padss->cbSrcLength = cbSrc;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamConvert
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamConvert
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    LPPCMWAVEFORMAT     pwfSrc;
    LPPCMWAVEFORMAT     pwfDst;
    CONVERTPROC         fnConvert;
    DWORD               cb;
    DWORD               cbDst;
    DWORD               dwSrcSamples;

    BOOL                fPartialSampleAtTheEnd;
    BOOL                fDstIsBlockAligned;
    DWORD               dwDstSamples;


    //
    //  our instance data is a pointer to the conversion procedure
    //  needed to convert the pwfxSrc data to pwfxDst. the correct
    //  procedure to use was decided in acmdStreamOpen..
    //
    fnConvert = (CONVERTPROC)padsi->dwDriver;

    pwfSrc    = (LPPCMWAVEFORMAT)padsi->pwfxSrc;
    pwfDst    = (LPPCMWAVEFORMAT)padsi->pwfxDst;


    //
    //  Check if we have to hack the destination buffer to make it full -
    //  see the big comment near the end of acmdStreamSize() for more
    //  details.
    //
    dwSrcSamples    = PCM_BYTESTOSAMPLES( pwfSrc, padsh->cbSrcLength );
    dwDstSamples    = PCM_BYTESTOSAMPLES( pwfDst, padsh->cbDstLength );
    fDstIsBlockAligned = ( padsh->cbDstLength ==
                            PCM_SAMPLESTOBYTES( pwfDst, dwDstSamples )  );

    if( fDstIsBlockAligned  &&
        (dwSrcSamples == MulDivRU( dwDstSamples, pwfSrc->wf.nSamplesPerSec,
                                            pwfDst->wf.nSamplesPerSec ) )  &&
        (dwSrcSamples >  MulDivRD( dwDstSamples, pwfSrc->wf.nSamplesPerSec,
                                            pwfDst->wf.nSamplesPerSec ) )  )
    {
        fPartialSampleAtTheEnd = TRUE;
    }
    else
    {
        fPartialSampleAtTheEnd = FALSE;

        //
        //  we will only use complete samples, so drop unused partial samples
        //  
        //
        dwSrcSamples = PCM_BYTESTOSAMPLES(pwfSrc, padsh->cbSrcLength);

        DPF(4, "adjust source samples: BEGIN %lu", dwSrcSamples);
        for (;;)
        {
            cbDst = MulDivRU(dwSrcSamples,
                            pwfDst->wf.nSamplesPerSec,
                            pwfSrc->wf.nSamplesPerSec);

            cbDst = PCM_SAMPLESTOBYTES(pwfDst, cbDst);

            if (padsh->cbDstLength >= cbDst)
            {
                break;
            }

            DPF(4, "adjusting source samples");
            dwSrcSamples--;
        }
        DPF(4, "adjust source samples: END %lu", dwSrcSamples);
    }

    cb = PCM_SAMPLESTOBYTES(pwfSrc, dwSrcSamples);

    padsh->cbSrcLengthUsed = cb;

    cb = (* fnConvert)( pwfSrc,
                        padsh->pbSrc,
                        pwfDst,
                        padsh->pbDst,
                        dwSrcSamples,
                        fPartialSampleAtTheEnd,
                        padsh->pbDst + padsh->cbDstLength );


    //
    //  If we used the fPartialSampleAtTheEnd flag, then we should have
    //  completely filled the destination block.
    //
    ASSERT( (!fPartialSampleAtTheEnd) || (cb==padsh->cbDstLength) );


    //
    //  because the actual length of the converted data may not be the
    //  exact same amount as the estimate we gave in acmdStreamSize,
    //  we need to fill in the actual length we used for the destination
    //  buffer.
    //
    padsh->cbDstLengthUsed = cb;

    return (MMSYSERR_NOERROR);
} // acmdStreamConvert()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT pcmDriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNWCALLBACK pcmDriverProc
(
    DWORD_PTR               dwId,
    HACMDRIVERID            hadid,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PCODECINST          pci;

    //
    //  make pci either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on BOGUS_DRIVER_ID.
    //
    pci = (dwId == BOGUS_DRIVER_ID) ? NULL : (PCODECINST)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
        case DRV_FREE:
            return (1L);


        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(NULL, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            lr = acmdDriverClose(pci);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pci, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pci, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pci, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
            lr = acmdFormatSuggest(pci, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pci, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pci, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pci, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose(pci, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            lr = acmdStreamSize(pci, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
            lr = acmdStreamConvert(pci, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);
            return (lr);
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);

#if 0
    return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
#else
    //
    //  if installed as a _function_ instead of as an installable driver,
    //  just return 0L for non-ACM messages we don't handle
    //
    return (0L);
#endif
} // pcmDriverProc()


#endif // WIN32 || NTWOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\profile.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1994-1995 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  profile.h
//
//  Description:
//
//      This file contains definitions supporting the code in profile.c
//      which accesses the registry directly.
//
//==========================================================================;

#ifndef _PROFILE_H_
#define _PROFILE_H_

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifndef INLINE
    #define INLINE __inline
#endif

//--------------------------------------------------------------------------;
//
//  We really need to clean up all these #defines and typdefs!!!
//
    
//
//  The Chicago Win16 header files are messed up somehow, so we have to
//  define this stuff ourselves.
//
#ifndef REG_DWORD
#pragma message("profile.h: Manually defining REG_DWORD!!!")
#define REG_DWORD  ( 4 )
#endif

#ifndef REG_BINARY
#pragma message("profile.h: Manually defining REG_BINARY!!!")
#define REG_BINARY  ( 3 )
#endif

#ifndef HKEY_LOCAL_MACHINE
#pragma message("profile.h: Manually defining HKEY_LOCAL_MACHINE!!!")
#define HKEY_LOCAL_MACHINE (( HKEY ) 0x80000002 )
#endif

#ifndef HKEY_CURRENT_USER
#pragma message("profile.h: Manually defining HKEY_CURRENT_USER!!!")
#define HKEY_CURRENT_USER (( HKEY ) 0x80000001 )
#endif

#ifndef KEY_QUERY_VALUE
#pragma message("profile.h: Manually defining KEY_*!!!")
     
#define KEY_QUERY_VALUE         (0x0001)
#define KEY_SET_VALUE           (0x0002)
#define KEY_CREATE_SUB_KEY      (0x0004)
#define KEY_ENUMERATE_SUB_KEYS  (0x0008)
#define KEY_NOTIFY              (0x0010)
#define KEY_CREATE_LINK         (0x0020)

#define KEY_READ                ( KEY_QUERY_VALUE            |\
                                  KEY_ENUMERATE_SUB_KEYS     |\
                                  KEY_NOTIFY )

#define KEY_WRITE               ( KEY_SET_VALUE              |\
                                  KEY_CREATE_SUB_KEY )
#endif

#ifndef ERROR_SUCCESS
#pragma message("profile.h: Manually defining ERROR_SUCCESS!!!")
#define ERROR_SUCCESS  0L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#pragma message("profile.h: Manually defining ERROR_NO_MORE_ITEMS!!!")
#define ERROR_NO_MORE_ITEMS 259L
#endif


//--------------------------------------------------------------------------;
//
//  Ghost registry APIs.  Since NTWOW doesn't support most of the registry
//  APIs, we use XRegBlahBlahBlah instead of RegBlahBlahBlah in all the ACM
//  source code.  For NTWOW, these XReg calls are thunked to the 32-bit
//  side; for other builds, they are simply #define-d to the normal
//  registry calls.
//
//  If you define XREGTHUNK, the thunks get compiled in.
//  
//--------------------------------------------------------------------------;

#ifdef NTWOW
#define XREGTHUNK
#endif


#ifdef XREGTHUNK

#if (WINVER < 0x0400)
typedef HKEY FAR* PHKEY;
typedef struct tFILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR* PFILETIME;
#endif
typedef ULONG ACCESS_MASK;
typedef ACCESS_MASK REGSAM;

LONG FNGLOBAL XRegCloseKey( HKEY hkey );
LONG FNGLOBAL XRegCreateKey( HKEY hkey, LPCTSTR lpszSubKey, PHKEY phkResult );
LONG FNGLOBAL XRegDeleteKey( HKEY hkey, LPCTSTR lpszSubKey );
LONG FNGLOBAL XRegDeleteValue( HKEY hkey, LPTSTR lpszValue );
LONG FNGLOBAL XRegEnumKeyEx( HKEY hkey, DWORD iSubKey, LPTSTR lpszName, LPDWORD lpcchName, LPDWORD lpdwReserved, LPTSTR lpszClass, LPDWORD lpcchClass, PFILETIME lpftLastWrite );
LONG FNGLOBAL XRegEnumValue( HKEY hkey, DWORD iValue, LPTSTR lpszValue, LPDWORD lpcchValue, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData );
LONG FNGLOBAL XRegOpenKey( HKEY hkey, LPCTSTR lpszSubKey, PHKEY phkResult );
LONG FNGLOBAL XRegOpenKeyEx( HKEY hkey, LPCTSTR lpszSubKey, DWORD dwReserved, REGSAM samDesired, PHKEY phkResult );
LONG FNGLOBAL XRegQueryValueEx( HKEY hkey, LPTSTR lpszValueName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData );
LONG FNGLOBAL XRegSetValueEx( HKEY hkey, LPCTSTR lpszValueName, DWORD dwReserved, DWORD fdwType, CONST LPBYTE lpbData, DWORD cbData );

//  This way we don't have to thunk RegCreateKeyEx.
#define XRegCreateKeyEx( hkey, lpszSubKey, a, b, c, d, e, phkResult, f ) XRegCreateKey( hkey, lpszSubKey, phkResult )


#else // !XREGTHUNK


#define XRegCloseKey        RegCloseKey
#define XRegCreateKey       RegCreateKey
#define XRegDeleteKey       RegDeleteKey
#define XRegDeleteValue     RegDeleteValue
#define XRegEnumKeyEx       RegEnumKeyEx
#define XRegEnumValue       RegEnumValue
#define XRegOpenKey         RegOpenKey
#define XRegOpenKeyEx       RegOpenKeyEx
#define XRegQueryValueEx    RegQueryValueEx
#define XRegSetValueEx      RegSetValueEx

#ifndef WIN32   // Chicago Win16 doesn't support RegCreateKeyEx.
#define XRegCreateKeyEx( hkey, lpszSubKey, a, b, c, d, e, phkResult, f ) RegCreateKey( hkey, lpszSubKey, phkResult )
#else
#define XRegCreateKeyEx     RegCreateKeyEx
#endif


#endif // !XREGTHUNK




//--------------------------------------------------------------------------;
//
//  Function Prototypes from profile.c
//  
//--------------------------------------------------------------------------;

HKEY FNGLOBAL IRegOpenKeyAcm
(
    LPCTSTR pszKeyName
);

HKEY FNGLOBAL IRegOpenKeyAudio
(
    LPCTSTR pszKeyName
);

BOOL FNGLOBAL IRegReadString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPTSTR              pszData,
    DWORD               cchData
);

DWORD FNGLOBAL IRegReadDwordDefault
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwDefault
);



//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteString
//  
//  Description:
//      This routine writes a value to an opened registry key.  If the key
//      is NULL, we return without doing anything.
//  
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPCTSTR pszValue:   Name of the value.
//      LPCTSTR pszData:    The data to write.
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegWriteString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPCTSTR             pszData
)
{
    XRegSetValueEx( hkey, pszValue, 0L, REG_SZ, (LPBYTE)pszData,
                    sizeof(TCHAR) * (1+lstrlen(pszData)) );
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteDword
//  
//  Description:
//      This routine writes a DWORD to the given value an open key.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPCTSTR  pszValue:
//      DWORD   dwData:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegWriteDword
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwData
)
{
    XRegSetValueEx( hkey, pszValue, 0, REG_DWORD,
                    (LPBYTE)&dwData, sizeof(DWORD) );
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteBinary
//  
//  Description:
//      This routine writes a binary data to the given value in an open key.
//  
//  Arguments:
//      HKEY hkey:               Registry key to read from.
//      LPCTSTR pszValue:
//      LPBYTE lpData:
//	DWORD cbSize:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegWriteBinary
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPBYTE		lpData,
    DWORD		cbSize
)
{
    XRegSetValueEx( hkey, pszValue, 0, REG_BINARY, lpData, cbSize );
}


//--------------------------------------------------------------------------;
//  
//  BOOL IRegValueExists
//  
//  Description:
//      This routine returns TRUE if the specified value exists in the
//      key; otherwise FALSE is returned.
//  
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPCTSTR pszValue:   Name of the value.
//
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

INLINE BOOL IRegValueExists
(
    HKEY                hkey,
    LPCTSTR             pszValue
)
{
    return ( ERROR_SUCCESS == XRegQueryValueEx( hkey, (LPTSTR)pszValue,
                                               NULL, NULL, NULL, NULL ) );
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegCloseKey
//  
//  Description:
//      Closes an open key (but only if it's non-NULL).
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegCloseKey
(
    HKEY                hkey
)
{
    if( NULL != hkey )
    {
        XRegCloseKey( hkey );
    }
}


#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\profile.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1994-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  profile.c
//
//  Description:
//      This file contains routines to access the registry directly.  You
//      must include profile.h to use these routines.
//
//      All keys are opened under the following key:
//
//          HKEY_CURRENT_USER\Software\Microsoft\Multimedia\Audio
//                                                  Compression Manager
//
//      Keys should be opened at boot time, and closed at shutdown.
//
//==========================================================================;

#if defined(WIN32) && !defined(WIN4)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#endif

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <process.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "uchelp.h"
#include "pcm.h"
#include "profile.h"

#include "debug.h"


const TCHAR gszAcmProfileKey[] =
        TEXT("Software\\Microsoft\\Multimedia\\Audio Compression Manager\\");

const TCHAR gszAudioProfileKey[] =
	TEXT("Software\\Microsoft\\Multimedia\\Audio\\");



//--------------------------------------------------------------------------;
//
//  HKEY IRegOpenKeyAcm
//
//  Description:
//      This routine opens a sub key under the default ACM key.  We allow
//      all access to the key.
//
//  Arguments:
//      LPCTSTR pszKeyName:  Name of the sub key.
//
//  Return (HKEY):  Handle to the opened key, or NULL if the request failed.
//
//--------------------------------------------------------------------------;

DWORD MsacmError = 0;
LPSTR MsacmErrorDesc = NULL;

HKEY FNGLOBAL IRegOpenKeyAcm
(
    LPCTSTR             pszKeyName
)
{
    LONG    lReturn;
    HKEY    hkeyAcm = NULL;
    HKEY    hkeyRet = NULL;

    ASSERT( NULL != pszKeyName );


#if defined(WIN32) && !defined(WIN4)
    {
        HANDLE  hRoot;

        if(!NT_SUCCESS(RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hRoot)))
        {
            DPF(1,"IRegOpenKeyAcm: Unable to open current user profile.");
	    MsacmError = GetLastError();
	    MsacmErrorDesc = "IRegOpenKeyAcm: Unable to open current user profile.";
	    ASSERT(FALSE);
            return NULL;
        }

	lReturn = RegCreateKeyEx( hRoot, gszAcmProfileKey, 0, NULL, 0,
				  KEY_WRITE, NULL, &hkeyAcm, NULL );
	if (lReturn)
	{
	    MsacmError = lReturn;
	    MsacmErrorDesc = "IRegOpenKeyAcm: Unable to create gszAcmProfileKey";
	    ASSERT(FALSE);
	}
	
        NtClose(hRoot);
    }
#else
    XRegCreateKeyEx( HKEY_CURRENT_USER, gszAcmProfileKey, 0, NULL, 0,
                       KEY_WRITE, NULL, &hkeyAcm, NULL );
#endif


    if( NULL != hkeyAcm )
    {
        if (XRegCreateKeyEx( hkeyAcm, pszKeyName, 0, NULL, 0,
			      KEY_WRITE | KEY_READ, NULL, &hkeyRet, NULL ))
	{
	    MsacmError = GetLastError();
	    MsacmErrorDesc = "IRegOpenKeyAcm: Unable to create pszKeyName";
	    ASSERT(FALSE);
	}

        XRegCloseKey( hkeyAcm );
    }

    return hkeyRet;
}


//--------------------------------------------------------------------------;
//
//  HKEY IRegOpenKeyAudio
//
//  Description:
//      This routine opens the multimedia Audio key or one of its subkeys.
//	We allow all access to the key.
//
//  Arguments:
//      LPCTSTR pszKeyName:  Name of the sub key.  NULL to open the audio key.
//
//  Return (HKEY):  Handle to the opened key, or NULL if the request failed.
//
//--------------------------------------------------------------------------;

HKEY FNGLOBAL IRegOpenKeyAudio
(
    LPCTSTR             pszKeyName
)
{
    HKEY    hkeyAudio	= NULL;
    HKEY    hkeyRet	= NULL;

    XRegCreateKeyEx( HKEY_CURRENT_USER, gszAudioProfileKey, 0, NULL, 0,
                       KEY_WRITE, NULL, &hkeyAudio, NULL );

    if (NULL == pszKeyName) {
	return hkeyAudio;
    }

    if( NULL != hkeyAudio )
    {
        XRegCreateKeyEx( hkeyAudio, pszKeyName, 0, NULL, 0,
                    KEY_WRITE | KEY_READ, NULL, &hkeyRet, NULL );

        XRegCloseKey( hkeyAudio );
    }

    return hkeyRet;
}


//--------------------------------------------------------------------------;
//
//  BOOL IRegReadString
//
//  Description:
//      This routine reads a value from an opened registry key.  The return
//      value indicates success or failure.  If the HKEY is NULL, we return
//      a failure.  Note that there is no default string...
//
//  Arguments:
//      HKEY hkey:          An open registry key.  If NULL, we fail.
//      LPCTSTR pszValue:   Name of the value.
//      LPTSTR pszData:     Buffer to store the data in.
//      DWORD cchData:      Size (in chars) of the buffer.
//
//  Return (BOOL):  TRUE indicates success.  If the return is FALSE, you
//      can't count on the data in pszData - it might be something weird.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IRegReadString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPTSTR              pszData,
    DWORD               cchData
)
{

    DWORD   dwType = (DWORD)~REG_SZ;  // Init to anything but REG_SZ.
    DWORD   cbData;
    LONG    lError;

    ASSERT( NULL != hkey );
    ASSERT( NULL != pszValue );
    ASSERT( NULL != pszData );
    ASSERT( cchData > 0 );


    cbData = sizeof(TCHAR) * cchData;

    lError = XRegQueryValueEx( hkey,
                              (LPTSTR)pszValue,
                              NULL,
                              &dwType,
                              (LPBYTE)pszData,
                              &cbData );

    return ( ERROR_SUCCESS == lError  &&  REG_SZ == dwType );
}


//--------------------------------------------------------------------------;
//
//  DWORD IRegReadDwordDefault
//
//  Description:
//      This routine reads a given value from the registry, and returns a
//      default value if the read is not successful.
//
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPCTSTR  pszValue:
//      DWORD   dwDefault:
//
//  Return (DWORD):
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL IRegReadDwordDefault
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwDefault
)
{
    DWORD   dwType = (DWORD)~REG_DWORD;  // Init to anything but REG_DWORD.
    DWORD   cbSize = sizeof(DWORD);
    DWORD   dwRet  = 0;
    LONG    lError;

    ASSERT( NULL != hkey );
    ASSERT( NULL != pszValue );


    lError = XRegQueryValueEx( hkey,
                              (LPTSTR)pszValue,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwRet,
                              &cbSize );

    //
    //  Really we should have a test like this:
    //
    //      if( ERROR_SUCCESS != lError  ||  REG_DWORD != dwType )
    //
    //  But, the Chicago RegEdit will not let you enter REG_DWORD values,
    //  it will only let you enter REG_BINARY values, so that test is
    //  too strict.  Just test for no error instead.
    //
    if( ERROR_SUCCESS != lError )
        dwRet = dwDefault;

    return dwRet;
}

#ifndef _WIN64
//==========================================================================;
//
//  XReg... thunks
//
//--------------------------------------------------------------------------;
//
//  The 16-bit code calls XRegCloseKey, XRegCreateKey, etc, functions to
//  access the registry.  These functions are implemented below.
//
//  We have one function on the 32-bit side that we call from the 16-bit
//  side.  This function is XRegThunkEntry.  All of the 16-bit XRegXXX
//  call the 32-bit XRegThunkEntry.  When calling XRegThunkEntry we
//  pass a value which identifies the real 32-bit registry API we wish to
//  call along with all the associated parameters for the API.
//
//==========================================================================;

//
//  These identify which registry API we want to call via
//  the thunked function.
//

enum {
    XREGTHUNKCLOSEKEY,
    XREGTHUNKCREATEKEY,
    XREGTHUNKDELETEKEY,
    XREGTHUNKDELETEVALUE,
    XREGTHUNKENUMKEYEX,
    XREGTHUNKENUMVALUE,
    XREGTHUNKOPENKEY,
    XREGTHUNKOPENKEYEX,
    XREGTHUNKQUERYVALUEEX,
    XREGTHUNKSETVALUEEX
};


#ifdef WIN32
//--------------------------------------------------------------------------;
//
//  32-bit
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
//  XRegThunkEntry
//
//  This function is called from the 16-bit side.  All calls from 16-bit to
//  registry APIs pass thru this function.
//
//  Arguments:
//	DWORD iThunk : identifies which registry API to call.
//
//	DWORD dw1, ..., dwN : parameters to pass to the registry API
//	    identified by iThunk.  Any necessary translation of the
//	    parameters (eg, segmented to linear pointer) has already
//	    been done.
//
//  Return value(DWORD) :
//	Return code from the called registry API
//
//---------------------------------------------------------------------------;
DWORD XRegThunkEntry(DWORD iThunk, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5, DWORD dw6, DWORD dw7, DWORD dw8)
{
    DWORD Rc;

    switch (iThunk)
    {
	case XREGTHUNKCLOSEKEY:
	    return (DWORD)RegCloseKey( (HKEY)dw1 );
	case XREGTHUNKCREATEKEY:
        {
            HKEY hKey;
	    Rc = (DWORD)RegCreateKeyA( (HKEY)dw1, (LPCSTR)dw2, &hKey );

            if ( Rc == ERROR_SUCCESS ) {
              *((UNALIGNED HKEY *)dw3) = hKey;
            }
            return Rc;
        }
	case XREGTHUNKDELETEKEY:
	    return (DWORD)RegDeleteKeyA( (HKEY)dw1, (LPCSTR)dw2 );
	case XREGTHUNKDELETEVALUE:
	    return (DWORD)RegDeleteValueA( (HKEY)dw1, (LPSTR)dw2 );
	case XREGTHUNKENUMKEYEX:
        {
            DWORD    dwTemp4 ;
            DWORD    dwTemp7 ;
            FILETIME FileTime;
	    Rc = (DWORD)RegEnumKeyExA( (HKEY)dw1,
                                       (DWORD)dw2,
                                       (LPSTR)dw3,
                                       dw4 == 0 ? NULL : &dwTemp4,
                                       (LPDWORD)dw5,
                                       (LPSTR)dw6,
                                       dw7 == 0 ? NULL : &dwTemp7,
                                       dw8 == 0 ? NULL : &FileTime );
            if ( Rc == ERROR_SUCCESS ) {
                if ( dw4 != 0 )
                    *((UNALIGNED DWORD *) dw4) = dwTemp4 ;
                if ( dw7 != 0 )
                    *((UNALIGNED DWORD *) dw7) = dwTemp7 ;
                if ( dw8 != 0 )
                    *((UNALIGNED FILETIME *)dw8) = FileTime ;
            }

            return Rc ;
        }
	case XREGTHUNKENUMVALUE:
        {
            DWORD dwTemp4, dwTemp6, dwTemp8;
	    Rc = (DWORD) RegEnumValueA( (HKEY)dw1,
                                        (DWORD)dw2,
                                        (LPSTR)dw3,
                                        dw4 == 0 ? NULL : &dwTemp4,
                                        (LPDWORD)dw5,
                                        dw6 == 0 ? NULL : &dwTemp6,
                                        (LPBYTE)dw7,
                                        dw8 == 0 ? NULL : &dwTemp8 );
            if ( Rc == ERROR_SUCCESS ) {
                if ( dw4 != 0 )
                    *((UNALIGNED DWORD *) dw4) = dwTemp4 ;
                if ( dw6 != 0 )
                    *((UNALIGNED DWORD *) dw6) = dwTemp6 ;
                if ( dw8 != 0 )
                    *((UNALIGNED DWORD *) dw8) = dwTemp8 ;
            }

            return Rc ;
        }
	case XREGTHUNKOPENKEY:
        {
            HKEY hKey;
	    Rc = (DWORD)RegOpenKeyA( (HKEY)dw1, (LPCSTR)dw2, &hKey );

            if ( Rc == ERROR_SUCCESS ) {
              *((UNALIGNED HKEY *)dw3) = hKey;
            }
            return Rc ;
        }
	case XREGTHUNKOPENKEYEX:
        {
            HKEY hKey;
	    Rc = (DWORD)RegOpenKeyExA( (HKEY)dw1, (LPCSTR)dw2, dw3, (REGSAM)dw4, &hKey );

            if ( Rc == ERROR_SUCCESS ) {
              *((UNALIGNED HKEY *) dw5) = hKey;
            }
            return Rc ;
        }
	case XREGTHUNKQUERYVALUEEX:
        {
            DWORD dwTemp4, dwTemp6 ;
	    Rc = (DWORD) RegQueryValueExA( (HKEY)dw1,
                                           (LPSTR)dw2,
                                           (LPDWORD)dw3,
                                           dw4 == 0 ? NULL : &dwTemp4,
                                           (LPBYTE)dw5,
                                           dw6 == 0 ? NULL : &dwTemp6);

            if ( Rc == ERROR_SUCCESS  || Rc == ERROR_MORE_DATA ) {
                if ( dw4 != 0 )
                    *((UNALIGNED DWORD *) dw4) = dwTemp4 ;
                if ( dw6 != 0 )
                    *((UNALIGNED DWORD *) dw6) = dwTemp6 ;
            }

            return Rc ;
        }
	case XREGTHUNKSETVALUEEX:
	    return (DWORD)RegSetValueExA( (HKEY)dw1,
                                          (LPCSTR)dw2,
                                          (DWORD)dw3,
                                          (DWORD)dw4,
                                          (CONST BYTE *)dw5,
                                          (DWORD)dw6 );
	default:
	    ASSERT( FALSE );
	    return (DWORD)ERROR_BADDB;
    }
}

#else	// WIN32
//---------------------------------------------------------------------------;
//
//  16-bit
//
//---------------------------------------------------------------------------;

#ifdef XREGTHUNK

//
//  If we want to use this code for Windows 95 then we'll probably need
//  to GlobalFix all the pointers before they are thunked.  So, just to set
//  off an alarm, let's generate an error when this code gets compiled not
//  for NTWOW
//
#ifndef NTWOW
#error REGISTRY THUNKS WON'T WORK IN WINDOWS 95
#endif

//---------------------------------------------------------------------------;
//
//  XReg funcions
//
//  These are analogous to the 32-bit registry APIs.  Each of these simply
//  thnks to the corresponding 32-bit registry API.
//
//---------------------------------------------------------------------------;

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegCloseKey( HKEY hkey )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKCLOSEKEY,
                                          (DWORD)hkey,
					  0, 0, 0, 0, 0, 0, 0,
					  pag->lpvXRegThunkEntry,
					  0, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegCreateKey( HKEY hkey, LPCTSTR lpszSubKey, PHKEY phkResult )
{
    PACMGARB pag;
    LONG     lr;

    DPF(4, "XRegCreateKey()");

    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKCREATEKEY,
                                         (DWORD)hkey,
					 (DWORD)lpszSubKey,
					 (DWORD)phkResult,
					 0, 0, 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000060L, 9 );

    return (lr);

}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegDeleteKey( HKEY hkey, LPCTSTR lpszSubKey )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKDELETEKEY,
                                         (DWORD)hkey,
					 (DWORD)lpszSubKey,
					 0, 0, 0, 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000040, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegDeleteValue( HKEY hkey, LPTSTR lpszValue )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKDELETEVALUE,
                                         (DWORD)hkey,
					 (DWORD)lpszValue,
					 0, 0, 0, 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000040, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegEnumKeyEx( HKEY hkey, DWORD iSubKey, LPTSTR lpszName, LPDWORD lpcchName, LPDWORD lpdwReserved, LPTSTR lpszClass, LPDWORD lpcchClass, PFILETIME lpftLastWrite )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKENUMKEYEX,
                                         (DWORD)hkey,
					 (DWORD)iSubKey,
					 (DWORD)lpszName,
					 (DWORD)lpcchName,
					 (DWORD)lpdwReserved,
					 (DWORD)lpszClass,
					 (DWORD)lpcchClass,
					 (DWORD)lpftLastWrite,
					 pag->lpvXRegThunkEntry,
					 0x0000003F, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegEnumValue( HKEY hkey, DWORD iValue, LPTSTR lpszValue, LPDWORD lpcchValue, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKENUMVALUE,
                                         (DWORD)hkey,
					 (DWORD)iValue,
					 (DWORD)lpszValue,
					 (DWORD)lpcchValue,
					 (DWORD)lpdwReserved,
					 (DWORD)lpdwType,
					 (DWORD)lpbData,
					 (DWORD)lpcbData,
					 pag->lpvXRegThunkEntry,
					 0x0000003F, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegOpenKey( HKEY hkey, LPCTSTR lpszSubKey, PHKEY phkResult )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKOPENKEY,
                                         (DWORD)hkey,
					 (DWORD)lpszSubKey,
					 (DWORD)phkResult,
					 0, 0, 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000060, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegOpenKeyEx( HKEY hkey, LPCTSTR lpszSubKey, DWORD dwReserved, REGSAM samDesired, PHKEY phkResult )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKOPENKEYEX,
                                         (DWORD)hkey,
					 (DWORD)lpszSubKey,
					 (DWORD)dwReserved,
					 (DWORD)samDesired,
					 (DWORD)phkResult,
					 0, 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000048, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegQueryValueEx( HKEY hkey, LPTSTR lpszValueName, LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKQUERYVALUEEX,
                                         (DWORD)hkey,
					 (DWORD)lpszValueName,
					 (DWORD)lpdwReserved,
					 (DWORD)lpdwType,
					 (DWORD)lpbData,
					 (DWORD)lpcbData,
					 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x0000007C, 9 );

    return (lr);
}

//---------------------------------------------------------------------------;
//
//
//
//---------------------------------------------------------------------------;
LONG FNGLOBAL XRegSetValueEx
(
 HKEY hkey,
 LPCTSTR lpszValueName,
 DWORD dwReserved, DWORD fdwType, CONST LPBYTE lpbData, DWORD cbData )
{
    PACMGARB pag;
    LONG     lr;


    pag = pagFind();
    ASSERT( NULL != pag );

    lr = (LONG)(*pag->lpfnCallproc32W_9)( XREGTHUNKSETVALUEEX,
                                         (DWORD)hkey,
					 (DWORD)lpszValueName,
					 (DWORD)dwReserved,
					 (DWORD)fdwType,
					 (DWORD)lpbData,
					 (DWORD)cbData,
					 0, 0,
					 pag->lpvXRegThunkEntry,
					 0x00000048, 9 );

    return (lr);
}

#endif // XREGTHUNK

#endif // !_WIN32
#endif // !_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\uchelp.h ===
//==========================================================================;
//
//  uchelp.h
//
//  Copyright (c) 1994 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//	This module provides the prototypes for various unicode helper
//	functions that can be used when similar APIs are not available
//	from the OS.
//
//  History:
//	02/24/94    [frankye]
//
//==========================================================================;

#ifndef _INC_UCHELP
#define _INC_UCHELP     /* #defined if ucapi.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */


#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#ifdef WIN32
//==========================================================================;
//
//
//
//
//==========================================================================;


#ifndef UNICODE
int FNGLOBAL IlstrcmpW(LPCWSTR lpwstr1, LPCWSTR lpwstr2);

LPWSTR FNGLOBAL IlstrcpyW(LPWSTR lpDst, LPCWSTR lpSrc);

int FNGLOBAL IlstrlenW(LPCWSTR lpwstr);

int FNGLOBAL IDialogBoxParamW(HANDLE hinst, LPCWSTR lpwstrTemplate, HWND hwndOwner, DLGPROC dlgprc, LPARAM lParamInit);

int FNGLOBAL ILoadStringW(HINSTANCE hinst, UINT uID, LPWSTR lpwstr, int cch);

int FNGLOBAL IComboBox_GetLBText_mbstowcs(HWND hwndCtl, int index, LPWSTR lpwszBuffer);

int FNGLOBAL IComboBox_FindStringExact_wcstombs(HWND hwndCtl, int indexStart, LPCWSTR lpwszFind);

int FNGLOBAL IComboBox_AddString_wcstombs(HWND hwndCtl, LPCWSTR lpwsz);
#endif

int FNGLOBAL Iwcstombs(LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr, int cch);

int FNGLOBAL Imbstowcs(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cch);

int          Iwsprintfmbstowcs(int cch, LPWSTR lpwstrDst, LPSTR lpstrFmt, ...);

int FNGLOBAL Ilstrcmpwcstombs(LPCSTR lpstr1, LPCWSTR lpwstr2);

//==========================================================================;
//
//
//
//
//==========================================================================;
#endif	// WIN32


#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_UCHELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "MSACMMAP"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\init.c ===
//==========================================================================;
//
//  init.c
//
//  Copyright (c) 1991-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#ifdef USE_ACMTHUNK
#include "acmthunk.h"
#endif
#include "msacmmap.h"
#include "profile.h"

#include "debug.h"


//
//
//
//

ACMGLOBALINFO       acmglobalinfo;
ACMGARB             acmgarb;
PACMGARB            gpag;


//--------------------------------------------------------------------------;
//
//  LRESULT mapWaveGetDevCaps
//
//  Description:
//
//
//  Arguments:
//      BOOL fInput: TRUE if input.
//
//      LPWAVEOUTCAPS pwc: Pointer to a WAVEOUTCAPS structure to receive
//      the information. Used for both input and output. Output structure
//      contains input structure plus extras....
//
//      UINT cbSize: Size of the WAVEOUTCAPS structure.
//
//  Return (MMRESULT):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNGLOBAL mapWaveGetDevCaps
(
    BOOL                    fInput,
    LPWAVEOUTCAPS           pwc,
    UINT                    cbSize
)
{
    MMRESULT        mmr;
    WAVEOUTCAPS     woc;
    UINT            cWaveDevs;
    BOOL            fFoundOnlyOneMappableDeviceID;
    UINT            uMappableDeviceID;
    UINT            i;

    if (fInput)
    {
        cbSize = min(sizeof(WAVEINCAPS), cbSize);
        cWaveDevs = gpag->cWaveInDevs;
    }
    else
    {
        cbSize = min(sizeof(WAVEOUTCAPS), cbSize);
        cWaveDevs = gpag->cWaveOutDevs;
    }

    //
    //  Determine if there is only one mappable device ID.  If there is only
    //  one, then set fFoundOnlyOneMappableID=TRUE and put the device ID
    //  in uMappableDeviceID.
    //
    fFoundOnlyOneMappableDeviceID = FALSE;
    for (i=0; i < cWaveDevs; i++)
    {
            if (fInput)
            {
                mmr = (MMRESULT)waveInMessage((HWAVEIN)LongToHandle(i), DRV_QUERYMAPPABLE, 0L, 0L);
            }
            else
            {
            mmr = (MMRESULT)waveOutMessage((HWAVEOUT)LongToHandle(i), DRV_QUERYMAPPABLE, 0L, 0L);
            }

            if (MMSYSERR_NOERROR == mmr)
            {
                if (fFoundOnlyOneMappableDeviceID)
                {
                    fFoundOnlyOneMappableDeviceID = FALSE;
                    break;
                }
                uMappableDeviceID = i;
                fFoundOnlyOneMappableDeviceID = TRUE;
            }
    }


    //
    //  If there is only one mappable device ID, then get the caps from it to
    //  fill in the dwSupport fields.  Otherwise, let's hardcode the dwSupport
    //  field.
    //
    if (fFoundOnlyOneMappableDeviceID)
    {
        if (fInput)
        {
            mmr = waveInGetDevCaps(uMappableDeviceID, (LPWAVEINCAPS)&woc, cbSize);
        }
        else
        {
            mmr = waveOutGetDevCaps(uMappableDeviceID, &woc, cbSize);
        }
    }
    else
    {
        woc.dwSupport = WAVECAPS_VOLUME | WAVECAPS_LRVOLUME;
        mmr           = MMSYSERR_NOERROR;
    }

    //
    //  Bail on error
    //
    if (MMSYSERR_NOERROR != mmr)
    {
        return (mmr);
    }

    //
    //
    //
    woc.wMid           = MM_MICROSOFT;
    woc.wPid           = MM_WAVE_MAPPER;
    woc.vDriverVersion = VERSION_MSACMMAP;
    woc.wChannels      = 2;

    LoadString(gpag->hinst, IDS_ACM_CAPS_DESCRIPTION, woc.szPname, SIZEOF(woc.szPname));

    //
    //
    //
    woc.dwFormats      = WAVE_FORMAT_1M08 |
                         WAVE_FORMAT_1S08 |
                         WAVE_FORMAT_1M16 |
                         WAVE_FORMAT_1S16 |
                         WAVE_FORMAT_2M08 |
                         WAVE_FORMAT_2S08 |
                         WAVE_FORMAT_2M16 |
                         WAVE_FORMAT_2S16 |
                         WAVE_FORMAT_4M08 |
                         WAVE_FORMAT_4S08 |
                         WAVE_FORMAT_4M16 |
                         WAVE_FORMAT_4S16;

    _fmemcpy(pwc, &woc, cbSize);

    return (MMSYSERR_NOERROR);
} // waveGetDevCaps()


//--------------------------------------------------------------------------;
//
//  UINT GetPCMSupportFlags
//
//  Description:
//
//
//  Arguments:
//      PZYZPCMFORMATS pzpf
//      UINT iaPCMFormats:
//
//  Return (VOID):
//
//  History:
//      06/14/93    cjp     [curtisp]
//      03/13/94    fdy     [frankye]
//          Modifed the interface to take pzpf and an index into it.
//          Modifed the function to set flags to indicate which wave
//          devices support the format in question.
//
//--------------------------------------------------------------------------;

VOID FNLOCAL GetPCMSupportFlags
(
    PZYZPCMFORMAT       pzpf,
    UINT                iaPCMFormats
)
{
    PCMWAVEFORMAT       wfPCM;
    UINT                uSamplesPerSec;
    UINT                u, n, i;

    #define WFQFLAGS  (WAVE_FORMAT_QUERY | WAVE_ALLOWSYNC)

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    //
    //  set all supported formats to 'not supported'
    //
    for (i = gpag->cWaveInDevs; i; i--)
        pzpf[iaPCMFormats].uFlagsInput[i-1]  = 0;
    for (i = gpag->cWaveOutDevs; i; i--)
        pzpf[iaPCMFormats].uFlagsOutput[i-1] = 0;

    //
    //  we need to try 4 different format types:
    //      Mono 8 Bit
    //      Stereo 8 Bit
    //      Mono 16 Bit
    //      Stereo 16 Bit
    //
    for (u = 0; u < 4; u++)
    {
        //
        //  set the stuff that is constant for all 4 formats
        //
        uSamplesPerSec = pzpf[iaPCMFormats].uSamplesPerSec;

        wfPCM.wf.wFormatTag     = WAVE_FORMAT_PCM;
        wfPCM.wf.nSamplesPerSec = uSamplesPerSec;

        switch (u)
        {
            case 0:
                wfPCM.wf.nChannels      = 1;
                wfPCM.wf.nAvgBytesPerSec= uSamplesPerSec;
                wfPCM.wf.nBlockAlign    = 1;
                wfPCM.wBitsPerSample    = 8;
                break;

            case 1:
                wfPCM.wf.nChannels      = 2;
                wfPCM.wf.nAvgBytesPerSec= uSamplesPerSec * 2;
                wfPCM.wf.nBlockAlign    = 2;
                wfPCM.wBitsPerSample    = 8;
                break;

            case 2:
                wfPCM.wf.nChannels      = 1;
                wfPCM.wf.nAvgBytesPerSec= uSamplesPerSec * 2;
                wfPCM.wf.nBlockAlign    = 2;
                wfPCM.wBitsPerSample    = 16;
                break;

            case 3:
                wfPCM.wf.nChannels      = 2;
                wfPCM.wf.nAvgBytesPerSec= uSamplesPerSec * 4;
                wfPCM.wf.nBlockAlign    = 4;
                wfPCM.wBitsPerSample    = 16;
                break;
        }

        //
        //  first query ALL ENABLED INPUT devices for the wfPCM format
        //
        if (gpag->pSettings->fPreferredOnly &&
           (gpag->pSettings->uIdPreferredIn != -1))
        {
            i = gpag->pSettings->uIdPreferredIn;
            n = gpag->pSettings->uIdPreferredIn + 1;
        }
        else
        {
            i = 0;
            n = gpag->cWaveInDevs;
        }

        for (; i < n; i++)
        {
#ifndef _WIN32
            if (!waveInOpen(NULL, i, (LPWAVEFORMAT)&wfPCM, 0L, 0L, WFQFLAGS))
#else
            if (!waveInOpen(NULL, i, (LPWAVEFORMATEX)&wfPCM, 0L, 0L, WFQFLAGS))
#endif
            {
                pzpf[iaPCMFormats].uFlagsInput[i] |= (ZYZPCMF_IN_M08 << u);
            }
        }

        //
        //  now query ALL ENABLED OUTPUT devices for the wfPCM format
        //
        if (gpag->pSettings->fPreferredOnly &&
           (gpag->pSettings->uIdPreferredOut != -1))
        {
            i = gpag->pSettings->uIdPreferredOut;
            n = gpag->pSettings->uIdPreferredOut + 1;
        }
        else
        {
            i = 0;
            n = gpag->cWaveOutDevs;
        }

        for (; i < n; i++)
        {
#ifndef _WIN32
            if (!waveOutOpen(NULL, i, (LPWAVEFORMAT)&wfPCM, 0L, 0L, WFQFLAGS))
#else
            if (!waveOutOpen(NULL, i, (LPWAVEFORMATEX)&wfPCM, 0L, 0L, WFQFLAGS))
#endif
            {
                pzpf[iaPCMFormats].uFlagsOutput[i] |= (ZYZPCMF_OUT_M08 << u);
            }
        }
    }

    //
    //  finally return
    //
#if 0    // def DEBUG
    DPF(3, "PCM Support: %uHz, In[%d]=%04xh, Out[%d]=%04xh",
        pzpf[iaPCMFormats].uSamplesPerSec,
        iaPCMFormats,
        *pzpf[iaPCMFormats].uFlagsInput,
        iaPCMFormats,
        *pzpf[iaPCMFormats].uFlagsOutput);
#endif

    RELEASE_MUTEX(gpag->hMutexSettings);

    return;
} // GetPCMSupportFlags()


//--------------------------------------------------------------------------;
//
//  BOOL GetWaveFormats
//
//  Description:
//
//
//  Arguments:
//      PZYZPCMFORMAT pzpf:
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//      03/13/94    fdy     [frankye]
//          Expanded the ZYZPCMFORMAT structure to include flags which
//          indicate which wave device supports a given format.  This
//          function will now set these flags.  Note that
//          the code that is #if 0'd WILL NOT WORK given these changes, so
//          if anybody ever resuscitates that code, you better modify it!
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL GetWaveFormats
(
    PZYZPCMFORMAT           pzpf
)
{
    UINT                u;

#if 0
    WAVEOUTCAPS         woc;
    WAVEINCAPS          wic;
    UINT                n;
    DWORD               dwInFormats;
    DWORD               dwOutFormats;

    //
    //  first things first: get all 'standard' supported formats from the
    //  current selected devices for input and output...
    //
    dwInFormats = 0L;
    if (gpag->fPreferredOnly && (gpag->uIdPreferredIn != -1))
    {
        if (!waveInGetDevCaps(gpag->uIdPreferredIn, &wic, sizeof(wic)))
            dwInFormats = wic.dwFormats;
    }
    else
    {
        n = gpag->cWaveInDevs;
        for (i = 0; i < n; i++)
        {
            if (!waveInGetDevCaps(i, &wic, sizeof(wic)))
                dwInFormats |= wic.dwFormats;
        }
    }

    dwOutFormats = 0L;
    if (gpag->fPreferredOnly && (gpag->uIdPreferredOut != -1))
    {
        if (!waveOutGetDevCaps(gpag->uIdPreferredOut, &woc, sizeof(woc)))
            dwOutFormats = woc.dwFormats;
    }
    else
    {
        n = gpag->cWaveOutDevs;
        for (i = 0; i < n; i++)
        {
            if (!waveOutGetDevCaps(i, &woc, sizeof(woc)))
                dwOutFormats |= woc.dwFormats;
        }
    }
#endif


    //
    //  now step through each sample rate in the pzpf structure and set all
    //  the appropriate bits for whether it is supported, etc..
    //
    for (u = 0; pzpf[u].uSamplesPerSec; u++)
    {
        //
        //  we need to special case a few of the sample rates, etc to get
        //  this whole thing working--once the grunt work is done here
        //  (and only once during initialization), then the data is easily
        //  accessible/used...
        //

        switch (pzpf[u].uSamplesPerSec)
        {
            //
            //  NOTE! it would be nice if we could rely on the caps
            //  structure being correct on drivers.... but alas, Media Vision
            //  found a way to mess that up also (on some of their hundreds
            //  of releases of their drivers). so ALWAYS query for the
            //  format support.
            //
            //  by the way, the reason they ship their drivers with this
            //  bug (and possibly other OEM's) is due to Sound Recorder
            //  (apparently their only test app?!?) only doing queries
            //  and never looking at the caps bits.
            //
#if 0
            case 11025:
                pzpf[u].uFlags  = (WORD)(dwInFormats  & WAVE_FORMAT_11k) << 8;
                pzpf[u].uFlags |= (WORD)(dwOutFormats & WAVE_FORMAT_11k);
                break;

            case 22050:
                pzpf[u].uFlags  =
                        (WORD)(dwInFormats  & WAVE_FORMAT_22k) >> 4 << 8;
                pzpf[u].uFlags |= (WORD)(dwOutFormats & WAVE_FORMAT_22k) >> 4;
                break;

            case 44100:
                pzpf[u].uFlags  =
                        (WORD)(dwInFormats  & WAVE_FORMAT_44k) >> 8 << 8;
                pzpf[u].uFlags |= (WORD)(dwOutFormats & WAVE_FORMAT_44k) >> 8;
                break;
#else
            case 11025:
            case 22050:
            case 44100:
#endif
            case 5510:
            case 6620:
            case 8000:
            case 9600:
            case 16000:
            case 18900:
            case 27420:
            case 32000:
            case 33075:
            case 37800:
            case 48000:
                GetPCMSupportFlags(pzpf, u);
                break;
        }
    }

    //
    //  reset these--they are auto determined while the mapper is being
    //  used...
    //

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    gpag->pSettings->fSyncOnlyOut = FALSE;
    gpag->pSettings->fSyncOnlyIn  = FALSE;

    RELEASE_MUTEX(gpag->hMutexSettings);

    return (TRUE);
} // GetWaveFormats()


//--------------------------------------------------------------------------;
//
//  BOOL mapSettingsRestore
//
//  Description:
//
//
//  Arguments:
//      None.
//
//  Return (BOOL):
//
//  History:
//      06/14/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL mapSettingsRestore
(
    void
)
{
    DWORD   dwFlags;
    UINT    ii;
    DWORD   cbSize;
    PUINT   pFlags;

    DPF(1, "mapSettingsRestore:");

    //
    //
    //

    gpag->cWaveOutDevs = waveOutGetNumDevs();
    gpag->cWaveInDevs  = waveInGetNumDevs();

    //  Number of devices per sampling rate...
    cbSize  = gpag->cWaveOutDevs + gpag->cWaveInDevs;

    //  Number of total flags...
//    cbSize *= (sizeof(gaPCMFormats)/sizeof(gaPCMFormats[0]));
    cbSize *= 15;   //  It's fifteen; Trust Me - Fwong.

    //  Size in bytes...
    cbSize *= sizeof(UINT);

    pFlags = (PUINT)GlobalAllocPtr(GHND, cbSize);

    if (NULL == pFlags)
    {
        //
        //  Hmm... How do we cope.
        //

        return FALSE;
    }

    ZeroMemory(pFlags, cbSize);

    if (NULL != gaPCMFormats[0].uFlagsInput)
    {
        GlobalFreePtr(gaPCMFormats[0].uFlagsInput);
    }

    for (ii = 0; ;ii++)
    {
        if (0 == gaPCMFormats[ii].uSamplesPerSec)
        {
            break;
        }

        gaPCMFormats[ii].uFlagsInput  = pFlags;
        pFlags += gpag->cWaveInDevs;

        gaPCMFormats[ii].uFlagsOutput = pFlags;
        pFlags += gpag->cWaveOutDevs;
    }

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    // gpag->fPrestoSyncAsync = (BOOL)IRegReadDwordDefault( hkeyMapper, gszKeyPrestoSyncAsync, 0 );
    gpag->fPrestoSyncAsync = FALSE;


    //
    //  find the waveOut device that is selected as preferred
    //
    if (!waveOutMessage((HWAVEOUT)LongToHandle(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&gpag->pSettings->uIdPreferredOut, (DWORD_PTR)&dwFlags)) {
	gpag->pSettings->fPreferredOnly = (0 != (DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
    } else {
	gpag->pSettings->uIdPreferredOut = (UINT)(-1);
	gpag->pSettings->fPreferredOnly = TRUE;
    }
    
    //
    //  find the waveIn device that is selected as preferred
    //
    if (!waveInMessage((HWAVEIN)LongToHandle(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&gpag->pSettings->uIdPreferredIn, (DWORD_PTR)&dwFlags)) {
	gpag->pSettings->fPreferredOnly = (0 != (DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY));
    } else {
	gpag->pSettings->uIdPreferredOut = (UINT)(-1);
	gpag->pSettings->fPreferredOnly = TRUE;
    }

    //
    //  reread/cache all the PCM format info from the devices selected, etc.
    //
    GetWaveFormats(gaPCMFormats);

    RELEASE_MUTEX(gpag->hMutexSettings);

    return (TRUE);
} // mapSettingsRestore()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT mapDriverEnable
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvr:
//
//  Return (LRESULT):
//
//  History:
//      09/18/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL mapDriverEnable
(
    HDRVR                   hdrvr
)
{
#ifdef USE_ACMTHUNK
    BOOL                f;
#endif
    DWORD               dw;

    DPF(1, "mapDriverEnable(hdrvr=%.04Xh)", hdrvr);


#ifdef USE_ACMTHUNK
    f = acmThunkInitialize();
    if (!f)
    {
        DPF(0, "!ACM thunk cannot be initialized!");
        return (0L);
    }
#endif

    dw = acmGetVersion();
    if (VERSION_MSACMMAP > HIWORD(dw))
    {
        DPF(0, "!requires version %u.%.02u of the ACM!",
            VERSION_MSACMMAP_MAJOR, VERSION_MSACMMAP_MINOR);

#ifdef USE_ACMTHUNK
        acmThunkTerminate();
#endif

        return (0L);
    }

    mapSettingsRestore();
    gpag->fEnabled = TRUE;

    //
    //  the return value is ignored, but return non-zero anyway
    //
    return (1L);
} // mapDriverEnable()


//--------------------------------------------------------------------------;
//
//  LRESULT mapDriverDisable
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvr:
//
//  Return (LRESULT):
//
//  History:
//      09/18/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL mapDriverDisable
(
    HDRVR           hdrvr
)
{
    DPF(1, "mapDriverDisable(hdrvr=%.04Xh)", hdrvr);

    if (gpag->fEnabled)
    {
        gpag->fEnabled = FALSE;
    }

#ifdef USE_ACMTHUNK
    acmThunkTerminate();
#endif

    //
    //  the return value is ignored, but return non-zero anyway
    //
    return (1L);
} // mapDriverDisable()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT mapDriverInstall
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvr:
//
//  Return (LRESULT):
//
//  History:
//      09/25/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL mapDriverInstall
(
    HDRVR           hdrvr
)
{
    DPF(1, "mapDriverInstall(hdrvr=%.04Xh)", hdrvr);


    //
    //
    //
    return (DRVCNF_RESTART);
} // mapDriverInstall()


//--------------------------------------------------------------------------;
//
//  LRESULT mapDriverRemove
//
//  Description:
//
//
//  Arguments:
//      HDRVR hdrvr:
//
//  Return (LRESULT):
//
//  History:
//      09/25/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL mapDriverRemove
(
    HDRVR           hdrvr
)
{
    DPF(1, "mapDriverRemove(hdrvr=%.04Xh)", hdrvr);


    //
    //
    //
    return (DRVCNF_RESTART);
} // mapDriverRemove()


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef WIN32

//--------------------------------------------------------------------------;
//
//  int WEP
//
//  Description:
//      The infamous useless WEP(). Note that this procedure needs to be
//      in a FIXED segment under Windows 3.0. Under Windows 3.1 this is
//      not necessary.
//
//  Arguments:
//      WORD wUseless: Should tell whether Windows is exiting or not.
//
//  Return (int):
//      Always return non-zero.
//
//  History:
//      04/29/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    WORD    wUseless
)
{
    DPF(1, "WEP(wUseless=%u)", wUseless);

    //
    //  always return non-zero
    //
    return (1);
} // WEP()


//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//      This routine must guarantee the following things so CODEC's don't
//      have to special case code everywhere:
//
//          o   will only run in Windows 3.10 or greater (our exehdr is
//              marked appropriately).
//
//          o   will only run on >= 386 processor. only need to check
//              on Win 3.1.
//
//  Arguments:
//      HINSTANCE hinst: Our module instance handle.
//
//      WORD wDataSeg: Our data segment selector.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst,
    WORD                    wDataSeg,
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    //
    //  we ONLY work on >= 386. if we are on a wimpy processor, scream in
    //  pain and die a horrible death!
    //
    //  NOTE! do this check first thing and get out if on a 286. we are
    //  compiling with -G3 and C8's libentry garbage does not check for
    //  >= 386 processor. the following code does not execute any 386
    //  instructions (not complex enough)..
    //
#if (WINVER < 0x0400)
    if (GetWinFlags() & WF_CPU286)
    {
        return (FALSE);
    }
#endif

    DbgInitialize(TRUE);

    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);

    DPF(5, "!*** break for debugging ***");


    //
    //  everything looks good to go in Win 16 land.
    //
    gpag = &acmgarb;
    gpag->hinst = hinst;

    //  Note: in Win16 there's only one instance of the mapper
    gpag->pSettings = &(acmglobalinfo);

    return (TRUE);
} // LibMain()

#else // WIN32

//==========================================================================;
//
//  WIN 32 SPECIFIC SUPPORT
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  PACMGLOBALINFO mapAllocateGlobalInfo
//
//  Description:
//      Either creates the common buffer among all instances of the mapper
//      or it finds the common buffer.
//
//  Arguments:
//      None.
//
//  Return (PACMGLOBALINFO):
//      Returns a pointer to global info structure.
//
//  History:
//      01/21/98    Fwong   Adding multi-instance support.
//      01/24/99    FrankYe Back to simple single process support, since
//                          since winmm has been modified to hold the
//                          preferred device settings.
//
//--------------------------------------------------------------------------;

PACMGLOBALINFO mapAllocateGlobalInfo
(
    void
)
{
    // We could actually use a critical section instead of a mutex here.
    gpag->hMutexSettings = CreateMutex(NULL, FALSE, NULL);
    return &(acmglobalinfo);
} // mapAllocateGlobalInfo()


//--------------------------------------------------------------------------;
//
//  void mapFreeGlobalInfo
//
//  Description:
//      Cleans up the objects associated with the global memory buffer.
//
//  Arguments:
//      PACMGLOBALINFO pagi: Base buffer for global info.
//
//  Return (void):
//
//  History:
//      01/21/98    Fwong   Adding multi-instance support.
//      01/24/99    FrankYe Back to simple single process support, since
//                          since winmm has been modified to hold the
//                          preferred device settings.
//
//--------------------------------------------------------------------------;

void mapFreeGlobalInfo
(
    PACMGLOBALINFO  pagi
)
{
    if(NULL != gpag->hMutexSettings) CloseHandle(gpag->hMutexSettings);
} // mapFreeGlobalInfo()


//--------------------------------------------------------------------------;
//
//  BOOL DllEntryPoint
//
//  Description:
//      This is the standard DLL entry point for Win 32.
//
//  Arguments:
//      HINSTANCE hinst: Our instance handle.
//
//      DWORD dwReason: The reason we've been called--process/thread attach
//      and detach.
//
//      LPVOID lpReserved: Reserved. Should be NULL--so ignore it.
//
//  Return (BOOL):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT DllEntryPoint
(
    HINSTANCE       hinst,
    DWORD           dwReason,
    LPVOID          lpReserved
)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DbgInitialize(TRUE);

            gpag = &acmgarb;
            gpag->hinst = hinst;
            gpag->pSettings = mapAllocateGlobalInfo();

            DisableThreadLibraryCalls(hinst);

            DPF(1, "DllEntryPoint(hinst=%.08lXh, DLL_PROCESS_ATTACH)", hinst);
            return (TRUE);

        case DLL_PROCESS_DETACH:
            mapFreeGlobalInfo(gpag->pSettings);

            DPF(1, "DllEntryPoint(hinst=%.08lXh, DLL_PROCESS_DETACH)", hinst);
            return (TRUE);
    }

    return (TRUE);
} // DllEntryPoint()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacm\uchelp.c ===
//==========================================================================;
//
//  uchelp.c
//
//  Copyright (c) 1994-1995 Microsoft Corporation
//
//  Description:
//	This module provides various unicode helper functions that can
//	be used when similar APIs are not available from the OS.
//
//  Notes:
//	Intended for win32 only
//
//  History:
//	02/24/94    [frankye]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <stdlib.h>
#include "msacm.h"
#include "msacmdrv.h"
#include "acmi.h"
#include "uchelp.h"
#include "debug.h"

#ifdef WIN32


#ifndef UNICODE
//--------------------------------------------------------------------------;
//
//  int IlstrcmpW
//
//  Description:
//	Internal implementaion of the Win32 lstrmpW API.
//
//  Arguments:
//	LPCWSTR lpwstr1:
//
//	LPCWSTR lpwstr2:
//
//  Return (int):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL IlstrcmpW(LPCWSTR lpwstr1, LPCWSTR lpwstr2)
{
    int iReturn;
    
    do
    {
	iReturn = *lpwstr1 - *lpwstr2;
    }
    while (iReturn==0 && 0!=*(lpwstr1++) && 0!=*(lpwstr2++));

    return iReturn;
}


//--------------------------------------------------------------------------;
//
//  LPWSTR IlstrcpyW
//
//  Description:
//	Internal implementaion of the Win32 lstrcpyW API.
//
//  Arguments:
//	LPWSTR lpDst:
//
//	LPCWSTR lpSrc:
//
//  Return (LPWSTR):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

LPWSTR FNGLOBAL IlstrcpyW(LPWSTR lpDst, LPCWSTR lpSrc)
{
    LPWSTR lpOrgDst = lpDst;
    
    while (*lpSrc != 0)
    {
	*lpDst = *lpSrc;
	lpSrc++;
	lpDst++;
    }
    *lpDst = *lpSrc;

    return lpOrgDst;
}


//--------------------------------------------------------------------------;
//
//  int IlstrlenW
//
//  Description:
//	Internal implementaion of the Win32 lstrlenW API.
//
//  Arguments:
//	LPCWSTR lpWideCharStr:
//
//  Return (int):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL IlstrlenW(LPCWSTR lpwstr)
{
    int i=0;
    while (*lpwstr != 0)
	{
	    i++;
	    lpwstr++;
	}
    return i;
}


//--------------------------------------------------------------------------;
//
//  int ILoadStringW
//
//  Description:
//	Internal implementation of Win32 LoadStringW API.  Calls
//	LoadStringA and converts ansi to wide.
//
//  Arguments:
//	HINSTANCE hinst:
//
//	UINT uID:
//
//	LPWSTR lpwstr:
//
//	int cch:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL ILoadStringW
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
	Imbstowcs(lpwstr, lpstr, cch);
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}


//--------------------------------------------------------------------------;
//
//  int IDialogBoxParamW
//
//  Description:
//	Unicode version of DialogBoxParam.
//
//  Arguments:
//	HANDLE hinst:
//
//	LPCWSTR lpwstrTemplate:
//
//	HWND hwndOwner:
//
//	DLGPROC dlgprc:
//
//	LPARAM lParamInit:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL IDialogBoxParamW
(
 HANDLE hinst,
 LPCWSTR lpwstrTemplate,
 HWND hwndOwner,
 DLGPROC dlgprc,
 LPARAM lParamInit)
{
    LPSTR   lpstrTemplate;
    UINT    cchTemplate;
    int	    iReturn;

    if (0 == HIWORD(lpwstrTemplate))
    {
	return DialogBoxParamA(hinst, (LPCSTR)lpwstrTemplate, hwndOwner, dlgprc, lParamInit);
    }

    cchTemplate = lstrlenW(lpwstrTemplate)+1;
    lpstrTemplate = (LPSTR)GlobalAlloc(GPTR, cchTemplate);
    if (NULL == lpstrTemplate)
    {
	return (-1);
    }
    Iwcstombs(lpstrTemplate, lpwstrTemplate, cchTemplate);
    iReturn = DialogBoxParamA(hinst, lpstrTemplate, hwndOwner, dlgprc, lParamInit);
    GlobalFree((HGLOBAL)lpstrTemplate);
    return iReturn;
}

//--------------------------------------------------------------------------;
//
//  int IComboBox_GetLBText_mbstowcs
//
//  Description:
//
//  Arguments:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;
int FNGLOBAL IComboBox_GetLBText_mbstowcs(HWND hwndCtl, int index, LPWSTR lpwszBuffer)
{
    int	    cch;
    LPSTR   lpstr;
    
    cch = ComboBox_GetLBTextLen(hwndCtl, index);
    if (CB_ERR != cch)
    {
	lpstr = (LPSTR)GlobalAlloc(GPTR, cch+1);
	if (NULL == lpstr)
	{
	    return (CB_ERR);
	}
	
	cch = IComboBox_GetLBText(hwndCtl, index, lpstr);
	if (CB_ERR != cch)
	{
	    Imbstowcs(lpwszBuffer, lpstr, cch+1);
	}

	GlobalFree((HGLOBAL)lpstr);
    }

    return (cch);
}

//--------------------------------------------------------------------------;
//
//  int IComboBox_FindStringExact_wcstombs
//
//  Description:
//
//  Arguments:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;
int FNGLOBAL IComboBox_FindStringExact_wcstombs(HWND hwndCtl, int indexStart, LPCWSTR lpwszFind)
{
    int	    cch;
    int	    index;
    LPSTR   lpszFind;
    
    cch = IlstrlenW(lpwszFind);
    lpszFind = (LPSTR)GlobalAlloc(GPTR, cch+1);
    if (NULL == lpszFind)
    {
	return (CB_ERR);
    }
    Iwcstombs(lpszFind, lpwszFind, cch+1);
    index = IComboBox_FindStringExact(hwndCtl, indexStart, lpszFind);
    GlobalFree((HGLOBAL)lpszFind);
    return(index);
}

//--------------------------------------------------------------------------;
//
//  int IComboBox_AddString_wcstombs
//
//  Description:
//
//  Arguments:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;
int FNGLOBAL IComboBox_AddString_wcstombs(HWND hwndCtl, LPCWSTR lpwsz)
{
    int	    cch;
    int	    index;
    LPSTR   lpsz;

    cch = IlstrlenW(lpwsz);
    lpsz = GlobalAlloc(GPTR, cch+1);
    if (NULL == lpsz)
    {
	return (CB_ERR);
    }
    Iwcstombs(lpsz, lpwsz, cch+1);
    index = IComboBox_AddString(hwndCtl, lpsz);
    GlobalFree((HGLOBAL)lpsz);
    return(index);
}

#endif	// !UNICODE


//--------------------------------------------------------------------------;
//
//  int Imbstowcs
//
//  Description:
//	Internal implementation of the C runtime function mbstowcs.
//	Calls the Win32 MultiByteToWideChar API.
//
//  Arguments:
//	LPWSTR lpWideCharStr:
//
//	LPCSTR lpMultiByteStr:
//
//	int cch:
//
//  Return (int):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL Imbstowcs(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cch)
{
    return MultiByteToWideChar(GetACP(), 0, lpMultiByteStr, -1, lpWideCharStr, cch);
}


//--------------------------------------------------------------------------;
//
//  int Iwcstombs
//
//  Description:
//	Internal implementation of C runtime function mbstowcs.
//	Calls the Win32 WideCharTMultiByte API.
//
//  Arguments:
//	LPSTR lpMultiByteStr:
//
//	LPCWSTR lpWideCharStr:
//
//	int cch:
//
//  Return (int):
//
//  History:
//	03/09/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL Iwcstombs(LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr, int cch)
{
    return WideCharToMultiByte(GetACP(), 0, lpWideCharStr, -1, lpMultiByteStr, cch, NULL, NULL);
}


//--------------------------------------------------------------------------;
//
//  int Iwsprintfmbstowcs
//
//  Description:
//	Like wsprintfA, except the destination buffer receives
//	a unicode string.  Also requires an argument describing the
//	size of the desitination buffer.
//
//  Arguments:
//	int cch:
//
//	LPWSTR lpwstrDst:
//
//	LPSTR lpstrFmt:
//
//	...:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;

int Iwsprintfmbstowcs(int cch, LPWSTR lpwstrDst, LPSTR lpstrFmt, ...)
{
    LPSTR   lpstrDst;
    int	    iReturn;
    va_list vargs;

    va_start(vargs, lpstrFmt);

    lpstrDst = (LPSTR)GlobalAlloc(GPTR, cch);
    
    if (NULL != lpstrDst)
    {
        iReturn = wvsprintfA(lpstrDst, lpstrFmt, vargs);
        if (iReturn > 0)
	    Imbstowcs(lpwstrDst, lpstrDst, cch);
        GlobalFree((HGLOBAL)lpstrDst);
    }
    else
    {
        iReturn = 0;
    }

    return iReturn;
}


//--------------------------------------------------------------------------;
//
//  int Ilstrcmpwcstombs
//
//  Description:
//	Similar to lstrcmp except compares a wide character string
//	to a multibyte string by first converting the wide character
//	string to a multibyte string.
//
//  Arguments:
//	LPCSTR lpstr1:
//
//	LPCWSTR lpwstr2:
//
//  Return (int):
//
//  History:
//	02/24/94    [frankye]
//
//--------------------------------------------------------------------------;

int FNGLOBAL Ilstrcmpwcstombs(LPCSTR lpstr1, LPCWSTR lpwstr2)
{
    LPSTR   lpstr2;
    UINT    cch;
    int	    iReturn;

    cch = lstrlenW(lpwstr2)+1;
    lpstr2 = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr2)
	return 1;
    
    Iwcstombs(lpstr2, lpwstr2, cch);
    iReturn = lstrcmpA(lpstr1, lpstr2);
    
    GlobalFree((HGLOBAL)lpstr2);
    
    return iReturn;
}


#endif	// WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\msacmcpl.c ===
//==========================================================================;
//
//  cpl.c
//
//  Copyright (c) 1991-1998 Microsoft Corporation
//
//  Description:
//
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#if (WINVER >= 0x0400)
#define NOSTATUSBAR
#endif
#include <cpl.h>
#include <stdlib.h>


#define WM_ACMMAP_ACM_NOTIFY        (WM_USER + 100)



#if (WINVER >= 0x0400)
    #pragma message("----when chicago fixes their header files, remove this stuff")
    #include <memory.h>

    #ifdef __cplusplus
    extern "C"                  // assume C declarations for C++
    {
    #endif // __cplusplus

        #pragma message("----Using Chicago Interface!")
        #define BEGIN_INTERFACE
////////#include <shellapi.h>
        #include <shell.h>
#ifdef WIN32
        #include <shlobj.h>
#else
	#include <ole2.h>
	#include <prsht.h>
#endif
        #include <setupx.h>

    #ifdef __cplusplus
    }                           // end of extern "C" {
    #endif // __cplusplus */

    #include "msacmhlp.h"

    LRESULT PASCAL CPLSendNotify(HWND hDlg, int idFrom, int code);
#endif

#include "msacmmap.h"
#include "debug.h"




//
//
//
//
typedef struct tACMDRIVERSETTINGS
{
    HACMDRIVERID        hadid;
    DWORD               fdwSupport;
    DWORD               dwPriority;

} ACMDRIVERSETTINGS, FAR *LPACMDRIVERSETTINGS;

//  A global structure for keeping out cancel variables.
struct
{
    BOOL                fPreferredOnly;
    UINT                uIdPreferredIn;
    UINT                uIdPreferredOut;

    LPACMDRIVERSETTINGS pads;
} CPLSettings;


#if (WINVER >= 0x0400)
TCHAR BCODE gszCPLHelp[]            = TEXT("MAPPER.HLP");

int BCODE   ganKeywordIds[] =
{
    IDD_CPL_LIST_DRIVERS,       IDH_AUDIOCOMP_DRIVER,
    IDD_CPL_COMBO_PLAYBACK,     IDH_AUDIOCOMP_PLAYBACK,
    IDD_CPL_COMBO_RECORD,       IDH_AUDIOCOMP_RECORDING,
    IDD_CPL_CHECK_PREFERRED,    IDH_AUDIOCOMP_PREFERRED,
    IDD_CPL_BTN_CONFIGURE,      IDH_PRIORITY_CHANGE,
    IDD_CPL_BTN_PRIORITY,       IDH_PRIORITY_DISABLE,

    0, 0
};

TCHAR BCODE gszClass[]              = TEXT("Media");
TCHAR BCODE gszClassStr[]              = TEXT("Class");
TCHAR BCODE gszACMClass[]              = TEXT("ACM");

#else

#if defined(WIN32) && !defined(WIN4)
    //
    //  Daytona help.  The number 5123 is taken from
    //  \nt\private\windows\shell\control\main\cphelp.h.  If you change this
    //  value, you gotta change it here, there, and also in the appropriate
    //  .hpj file (control.hpj?) in the Daytona help project.
    //
    #define USE_DAYTONA_HELP
    #define IDH_CHILD_MSACM             5123
    const TCHAR gszCPLHelp[]            = TEXT("CONTROL.HLP");

#else
TCHAR BCODE gszCPLHelp[]            = TEXT("MAP_WIN.HLP");
#endif
#endif

TCHAR BCODE gszFormatDriverDesc[]   = TEXT("%lu\t%s\t%s");
TCHAR BCODE gszFormatNumber[]       = TEXT("%lu");


//
//  this string variable must be large enough to hold the IDS_TXT_DISABLED
//  resource string.. for USA, this is '(disabled)'--which is 11 bytes
//  including the NULL terminator.
//
TCHAR           gszDisabled[32];
HACMDRIVERID    ghadidNotify;


//
//
//
#define CONTROL_MAX_ITEM_CHARS  (10 + 1 + 32 + 1 + ACMDRIVERDETAILS_LONGNAME_CHARS)


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  void ControlApplySettings
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//  Return (void):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

void FNLOCAL ControlApplySettings
(
    HWND                hwnd
)
{
    MMRESULT            mmr;
    HWND                hlb;
    HWND                hcb;
    UINT                cDrivers;
    LPACMDRIVERSETTINGS pads;
    UINT                u;
    BOOL                fDisabled;
    DWORD               fdwPriority;


    //
    //  Flush priority changes.
    //
    hlb = GetDlgItem(hwnd, IDD_CPL_LIST_DRIVERS);

    cDrivers = (UINT)ListBox_GetCount(hlb);
    if (LB_ERR == cDrivers)
        return;

    //
    //
    //
    mmr = acmDriverPriority(NULL, 0L, ACM_DRIVERPRIORITYF_BEGIN);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlApplySettings: acmDriverPriority(end) failed! mmr=%u", mmr);
        return;
    }

    for (u = 0; u < cDrivers; u++)
    {
        pads = (LPACMDRIVERSETTINGS)ListBox_GetItemData(hlb, u);
        if (NULL == pads)
        {
            DPF(0, "!ControlApplySettings: NULL item data for driver index=%u!", u);
            continue;
        }

        fDisabled = (0 != (ACMDRIVERDETAILS_SUPPORTF_DISABLED & pads->fdwSupport));

        fdwPriority = fDisabled ? ACM_DRIVERPRIORITYF_DISABLE : ACM_DRIVERPRIORITYF_ENABLE;

        mmr = acmDriverPriority(pads->hadid, pads->dwPriority, fdwPriority);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(0, "!ControlApplySettings: acmDriverPriority(%.04Xh, %lu, %.08lXh) failed! mmr=%u",
                pads->hadid, pads->dwPriority, fdwPriority, mmr);
        }
    }

    mmr = acmDriverPriority(NULL, 0L, ACM_DRIVERPRIORITYF_END);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlApplySettings: acmDriverPriority(end) failed! mmr=%u", mmr);
    }


    //
    //  update mapper preference changes
    //

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    gpag->pSettings->fPreferredOnly  = CPLSettings.fPreferredOnly;
    gpag->pSettings->uIdPreferredIn  = CPLSettings.uIdPreferredIn;
    gpag->pSettings->uIdPreferredOut = CPLSettings.uIdPreferredOut;

    hcb = GetDlgItem(hwnd, IDD_CPL_COMBO_RECORD);
    u = (UINT)ComboBox_GetCurSel(hcb);
    ComboBox_GetLBText(hcb, u, (LPARAM)(LPVOID)gpag->pSettings->szPreferredWaveIn);

    hcb = GetDlgItem(hwnd, IDD_CPL_COMBO_PLAYBACK);
    u = (UINT)ComboBox_GetCurSel(hcb);
    ComboBox_GetLBText(hcb, u, (LPARAM)(LPVOID)gpag->pSettings->szPreferredWaveOut);

    RELEASE_MUTEX(gpag->hMutexSettings);


    //
    //
    //
    mapSettingsSave();
} // ControlApplySettings()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL DlgProcACMRestart
//
//  Description:
//
//
//  Arguments:
//
//  Return (BOOL):
//
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNCALLBACK DlgProcACMRestart
(
    HWND                hwnd,
    UINT                uMsg,
    WPARAM              wParam,
    LPARAM              lParam
)
{
    UINT    uCmdId;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (TRUE);

        case WM_COMMAND:
            uCmdId = GET_WM_COMMAND_ID(wParam, lParam);

            if ((uCmdId == IDOK) || (uCmdId == IDCANCEL))
                EndDialog(hwnd, uCmdId == IDOK);
            return (TRUE);
    }

    return (FALSE);
} // DlgProcACMRestart()


//--------------------------------------------------------------------------;
//
//  BOOL DlgProcACMAboutBox
//
//  Description:
//
//
//  Arguments:
//
//  Return (BOOL):
//
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNCALLBACK DlgProcACMAboutBox
(
    HWND                hwnd,
    UINT                uMsg,
    WPARAM              wParam,
    LPARAM              lParam
)
{
    TCHAR               ach[80];
    TCHAR               szFormat[80];
    LPACMDRIVERDETAILS  padd;
    DWORD               dw1;
    DWORD               dw2;
    UINT                uCmdId;
    HFONT               hfont;
    HWND                htxt;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            padd = (LPACMDRIVERDETAILS)lParam;
            if (NULL == padd)
            {
                DPF(0, "!DlgProcACMAboutBox: NULL driver details passed!");
                return (TRUE);
            }

#ifdef JAPAN
            hfont = GetStockFont(SYSTEM_FIXED_FONT);
#else
            hfont = GetStockFont(ANSI_VAR_FONT);
#endif


            //
            //  fill in all the static text controls with the long info
            //  returned from the driver
            //
            LoadString(gpag->hinst, IDS_ABOUT_TITLE, szFormat, SIZEOF(szFormat));
            wsprintf(ach, szFormat, (LPTSTR)padd->szShortName);
            SetWindowText(hwnd, ach);

            //
            //  if the driver supplies an icon, then use it..
            //
            if (NULL != padd->hicon)
            {
                Static_SetIcon(GetDlgItem(hwnd, IDD_ABOUT_ICON_DRIVER), padd->hicon);
            }

            htxt = GetDlgItem(hwnd, IDD_ABOUT_TXT_DESCRIPTION);
            SetWindowFont(htxt, hfont, FALSE);
            SetWindowText(htxt, padd->szLongName);

            dw1 = padd->vdwACM;
            dw2 = padd->vdwDriver;
            LoadString(gpag->hinst, IDS_ABOUT_VERSION, szFormat, SIZEOF(szFormat));
#ifdef DEBUG
            wsprintf(ach, szFormat, HIWORD(dw2) >> 8, (BYTE)HIWORD(dw2), LOWORD(dw2),
                                    HIWORD(dw1) >> 8, (BYTE)HIWORD(dw1), LOWORD(dw1));
#else
            wsprintf(ach, szFormat, HIWORD(dw2) >> 8, (BYTE)HIWORD(dw2),
                                    HIWORD(dw1) >> 8, (BYTE)HIWORD(dw1));
#endif
            htxt = GetDlgItem(hwnd, IDD_ABOUT_TXT_VERSION);
            SetWindowFont(htxt, hfont, FALSE);
            SetWindowText(htxt, ach);

            htxt = GetDlgItem(hwnd, IDD_ABOUT_TXT_COPYRIGHT);
            SetWindowFont(htxt, hfont, FALSE);
            SetWindowText(htxt, padd->szCopyright);

            htxt = GetDlgItem(hwnd, IDD_ABOUT_TXT_LICENSING);
            SetWindowFont(htxt, hfont, FALSE);
            SetWindowText(htxt, padd->szLicensing);

            htxt = GetDlgItem(hwnd, IDD_ABOUT_TXT_FEATURES);
            SetWindowFont(htxt, hfont, FALSE);
            SetWindowText(htxt, padd->szFeatures);
            return (TRUE);


        case WM_COMMAND:
            uCmdId = GET_WM_COMMAND_ID(wParam,lParam);

            if ((uCmdId == IDOK) || (uCmdId == IDCANCEL))
                EndDialog(hwnd, wParam == uCmdId);
            return (TRUE);
    }

    return (FALSE);
} // DlgProcACMAboutBox()


//--------------------------------------------------------------------------;
//
//  void ControlAboutDriver
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      LPACMDRIVERSETTINGS pads:
//
//  Return (void):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

void FNLOCAL ControlAboutDriver
(
    HWND                    hwnd,
    LPACMDRIVERSETTINGS     pads
)
{
    PACMDRIVERDETAILS   padd;
    MMRESULT            mmr;

    if (NULL == pads)
        return;

    //
    //  if the driver returns MMSYSERR_NOTSUPPORTED, then we need to
    //  display the info--otherwise, it supposedly displayed a dialog
    //  (or had a critical error?)
    //
    mmr = (MMRESULT)acmDriverMessage((HACMDRIVER)pads->hadid,
                                     ACMDM_DRIVER_ABOUT,
                                     (LPARAM)(UINT)hwnd,
                                     0L);

    if (MMSYSERR_NOTSUPPORTED != mmr)
        return;


    //
    //  alloc some zero-init'd memory to hold the about box info
    //
    padd = (PACMDRIVERDETAILS)LocalAlloc(LPTR, sizeof(*padd));
    if (NULL == padd)
        return;

    //
    //  get info and bring up a generic about box...
    //
    padd->cbStruct = sizeof(*padd);
    mmr = acmDriverDetails(pads->hadid, padd, 0L);
    if (MMSYSERR_NOERROR == mmr)
    {
        DialogBoxParam(gpag->hinst,
                       DLG_ABOUT_MSACM,
                       hwnd,
                       DlgProcACMAboutBox,
                       (LPARAM)(LPVOID)padd);
    }

    LocalFree((HLOCAL)padd);
} // ControlAboutDriver()


//--------------------------------------------------------------------------;
//
//  BOOL ControlConfigureDriver
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      LPACMDRIVERSETTINGS pads:
//
//  Return (BOOL):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL ControlConfigureDriver
(
    HWND                    hwnd,
    LPACMDRIVERSETTINGS     pads
)
{
    int                 n;
    LRESULT             lr;

    if (NULL == pads)
        return (FALSE);

    //
    //
    //
    lr = acmDriverMessage((HACMDRIVER)pads->hadid,
                          DRV_CONFIGURE,
                          (UINT)hwnd,
                          0L);
    if (DRVCNF_CANCEL == lr)
        return (FALSE);

    if (DRVCNF_RESTART != lr)
        return (FALSE);

    //
    //
    //
    n = DialogBox(gpag->hinst, DLG_RESTART_MSACM, hwnd, DlgProcACMRestart);
    if (IDOK == n)
    {
        ControlApplySettings(hwnd);
        ExitWindows(EW_RESTARTWINDOWS, 0);
    }

    //
    //  something apparently changed with config..
    //
    return (TRUE);
} // ControlConfigureDriver()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL DlgProcPriority
//
//  Description:
//
//
//  Arguments:
//
//  Return (BOOL):
//
//
//  History:
//      5/31/93    jyg
//
//--------------------------------------------------------------------------;

typedef struct tPRIORITYDLGPARAM {
    int iPriority;                      // in/out priority
    int iPriorityMax;                   // maximum priority value
    BOOL fDisabled;                     // is disabled
    TCHAR ach[CONTROL_MAX_ITEM_CHARS];    // name of driver
} PRIORITYDLGPARAM, *PPRIORITYDLGPARAM, FAR *LPPRIORITYDLGPARAM;

BOOL FNCALLBACK DlgProcPriority
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    TCHAR               achFromTo[80];
    TCHAR               ach[80];
    UINT                u;
    LPPRIORITYDLGPARAM  pdlgparam;
    UINT                uCmdId;
    HWND                hcb;
    HFONT               hfont;
    HWND                htxt;

    //
    //
    //
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SetWindowLong(hwnd, DWL_USER, lParam);

            pdlgparam = (LPPRIORITYDLGPARAM)lParam;

#ifdef JAPAN
            hfont = GetStockFont(SYSTEM_FIXED_FONT);
#else
            hfont = GetStockFont(ANSI_VAR_FONT);
#endif

            htxt = GetDlgItem(hwnd, IDD_PRIORITY_TXT_DRIVER);
            SetWindowFont(htxt, hfont, FALSE);
            SetWindowText(htxt, pdlgparam->ach);

            LoadString(gpag->hinst, IDS_PRIORITY_FROMTO, achFromTo, SIZEOF(achFromTo));

            wsprintf(ach, achFromTo, pdlgparam->iPriority);
            SetDlgItemText(hwnd, IDD_PRIORITY_TXT_FROMTO, ach);

            //
            //  the priority selection is fixed in a dropdownlist box.
            //
            hcb = GetDlgItem(hwnd, IDD_PRIORITY_COMBO_PRIORITY);
            SetWindowFont(hcb, hfont, FALSE);

            for (u = 1; u <= (UINT)pdlgparam->iPriorityMax; u++)
            {
                wsprintf(ach, gszFormatNumber, (DWORD)u);
                ComboBox_AddString(hcb, ach);
            }

            ComboBox_SetCurSel(hcb, pdlgparam->iPriority - 1);

            CheckDlgButton(hwnd, IDD_PRIORITY_CHECK_DISABLE, pdlgparam->fDisabled);
            return (TRUE);

        case WM_COMMAND:
            uCmdId = GET_WM_COMMAND_ID(wParam,lParam);

            switch (uCmdId)
            {
                case IDOK:
                    pdlgparam = (LPPRIORITYDLGPARAM)GetWindowLong(hwnd, DWL_USER);

                    hcb = GetDlgItem(hwnd, IDD_PRIORITY_COMBO_PRIORITY);

                    pdlgparam->iPriority = ComboBox_GetCurSel(hcb);
                    pdlgparam->iPriority++;
                    pdlgparam->fDisabled = IsDlgButtonChecked(hwnd, IDD_PRIORITY_CHECK_DISABLE);

                case IDCANCEL:
                    EndDialog(hwnd, (TRUE == uCmdId));
                    break;

            }
            return (TRUE);
    }

    return (FALSE);
} // DlgProcPriority()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LPACMDRIVERSETTINGS ControlGetSelectedDriver
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//  Return (LPACMDRIVERSETTINGS):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LPACMDRIVERSETTINGS FNLOCAL ControlGetSelectedDriver
(
    HWND                    hwnd
)
{
    HWND                hlb;
    UINT                u;
    LPACMDRIVERSETTINGS pads;

    hlb = GetDlgItem(hwnd, IDD_CPL_LIST_DRIVERS);

    u = (UINT)ListBox_GetCurSel(hlb);
    if (LB_ERR == u)
    {
        DPF(0, "!ControlGetSelectedDriver: apparently there is no selected driver?");
        return (NULL);
    }

    pads = (LPACMDRIVERSETTINGS)ListBox_GetItemData(hlb, u);
    if (NULL == pads)
    {
        DPF(0, "!ControlGetSelectedDriver: NULL item data for selected driver!!?");
        return (NULL);
    }

    return (pads);
} // ControlGetSelectedDriver()


//--------------------------------------------------------------------------;
//
//  void ControlRefreshList
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//  Return (void):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

void FNLOCAL ControlRefreshList
(
    HWND                    hwnd,
    BOOL                    fNotify
)
{
    UINT                cItems;
    UINT                uSelection;
    ACMDRIVERDETAILS    add;
    LPACMDRIVERSETTINGS pads;
    UINT                u;
    HWND                hlb;
    TCHAR               ach[CONTROL_MAX_ITEM_CHARS];
    BOOL                f;


    //
    //
    //
    hlb = GetDlgItem(hwnd, IDD_CPL_LIST_DRIVERS);
    SetWindowRedraw(hlb, FALSE);

    //
    //
    //
    cItems     = ListBox_GetCount(hlb);
    uSelection = ListBox_GetCurSel(hlb);

    for (u = 0; u < cItems; u++)
    {
        pads = (LPACMDRIVERSETTINGS)ListBox_GetItemData(hlb, u);

        ListBox_DeleteString(hlb, u);

        add.cbStruct = sizeof(add);
        if (MMSYSERR_NOERROR != acmDriverDetails(pads->hadid, &add, 0L))
        {
            add.szLongName[0] = '\0';
        }

        f = (0 != (pads->fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED));

        wsprintf(ach, gszFormatDriverDesc,
                 pads->dwPriority,
                 (f ? (LPTSTR)gszDisabled : (LPTSTR)gszNull),
                 (LPTSTR)add.szLongName);

        ListBox_InsertString(hlb, u, ach);
        ListBox_SetItemData(hlb, u, (LPARAM)(LPVOID)pads);
    }

    ListBox_SetCurSel(hlb, uSelection);
    SetWindowRedraw(hlb, TRUE);
} // ControlRefreshList()


//--------------------------------------------------------------------------;
//
//  void ControlChangePriority
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//  Return (void):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

void FNLOCAL ControlChangePriority
(
    HWND                    hwnd
)
{
    PRIORITYDLGPARAM    dlgparam;
    ACMDRIVERDETAILS    add;
    LPACMDRIVERSETTINGS pads;
    UINT                u;
    int                 iPrevPriority;      // previous priority
    BOOL                fPrevDisabled;      // previous disabled state
    HWND                hlb;
    TCHAR               ach[CONTROL_MAX_ITEM_CHARS];
    BOOL                f;

    pads = ControlGetSelectedDriver(hwnd);
    if (NULL == pads)
        return;

    add.cbStruct = sizeof(add);
    if (MMSYSERR_NOERROR != acmDriverDetails(pads->hadid, &add, 0L))
        return;

    iPrevPriority = (int)pads->dwPriority;
    fPrevDisabled = (0 != (pads->fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED));

    dlgparam.iPriority = iPrevPriority;
    dlgparam.fDisabled = fPrevDisabled;

    hlb = GetDlgItem(hwnd, IDD_CPL_LIST_DRIVERS);
    dlgparam.iPriorityMax = ListBox_GetCount(hlb);

    lstrcpy(dlgparam.ach, add.szLongName);

    f = (BOOL)DialogBoxParam(gpag->hinst,
                             DLG_PRIORITY_SET,
                             hwnd,
                             DlgProcPriority,
                             (LPARAM)(LPVOID)&dlgparam);

    if (!f)
        return;

    if ((dlgparam.fDisabled == fPrevDisabled) &&
        (dlgparam.iPriority == iPrevPriority))
        return;


    //
    //
    //
    SetWindowRedraw(hlb, FALSE);


    //
    //  change the disabled state.
    //
    if (dlgparam.fDisabled != fPrevDisabled)
    {
        pads->fdwSupport ^= ACMDRIVERDETAILS_SUPPORTF_DISABLED;
    }


    //
    //  has there been a priority change?
    //
    if (dlgparam.iPriority != iPrevPriority)
    {
        //
        //  remove old entry and add a placeholder
        //
        ListBox_DeleteString(hlb, iPrevPriority - 1);

        ListBox_InsertString(hlb, dlgparam.iPriority - 1, gszNull);
        ListBox_SetItemData(hlb, dlgparam.iPriority - 1, (LPARAM)(LPVOID)pads);
    }


    //
    //
    //
    for (u = 0; u < (UINT)dlgparam.iPriorityMax; u++)
    {
        pads = (LPACMDRIVERSETTINGS)ListBox_GetItemData(hlb, u);

        ListBox_DeleteString(hlb, u);

        add.cbStruct = sizeof(add);
        if (MMSYSERR_NOERROR != acmDriverDetails(pads->hadid, &add, 0L))
            continue;

        f = (0 != (pads->fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED));

        pads->dwPriority = u + 1;

        wsprintf(ach, gszFormatDriverDesc,
                 pads->dwPriority,
                 (f ? (LPTSTR)gszDisabled : (LPTSTR)gszNull),
                 (LPTSTR)add.szLongName);

        ListBox_InsertString(hlb, u, ach);
        ListBox_SetItemData(hlb, u, (LPARAM)(LPVOID)pads);
    }

    ListBox_SetCurSel(hlb, dlgparam.iPriority - 1);

    SetWindowRedraw(hlb, TRUE);
} // ControlChangePriority()


//--------------------------------------------------------------------------;
//
//  void ControlNewDriverSelected
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//  Return (void):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

void FNLOCAL ControlNewDriverSelected
(
    HWND                    hwnd
)
{
    LRESULT             lr;
    LPACMDRIVERSETTINGS pads;

    pads = ControlGetSelectedDriver(hwnd);
    if (NULL == pads)
        return;

    lr = acmDriverMessage((HACMDRIVER)pads->hadid,
                          DRV_QUERYCONFIGURE,
                          0L,
                          0L);

    EnableWindow(GetDlgItem(hwnd, IDD_CPL_BTN_CONFIGURE), (0 != lr));
} // ControlNewDriverSelected()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  UINT ControlWaveDeviceChanged
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      HWND hcb:
//
//      UINT uId:
//
//  Return (UINT):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

UINT FNLOCAL ControlWaveDeviceChanged
(
    HWND            hwnd,
    HWND            hcb,
    UINT            uId
)
{
    UINT        uDevId;
    UINT        u;

    uDevId = (UINT)-1;

    u = (UINT)ComboBox_GetCurSel(hcb);
    if (LB_ERR != u)
    {
        uDevId = (UINT)ComboBox_GetItemData(hcb, u);
        switch (uId)
        {
            case IDD_CPL_COMBO_RECORD:
                CPLSettings.uIdPreferredIn = uDevId;
                break;

            case IDD_CPL_COMBO_PLAYBACK:
                CPLSettings.uIdPreferredOut = uDevId;
                break;
        }
    }

    return (uDevId);
} // ControlWaveDeviceChanged()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  void ControlCleanupDialog
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//  Return (void):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

void FNLOCAL ControlCleanupDialog
(
    HWND            hwnd
)
{
    //
    //
    //
    if (NULL != ghadidNotify)
    {
        acmDriverRemove(ghadidNotify, 0L);
        ghadidNotify = NULL;
    }


    //
    //
    //
    if (NULL != CPLSettings.pads)
    {
        GlobalFreePtr(CPLSettings.pads);
        CPLSettings.pads = NULL;
    }
} // ControlCleanupDialog()




//--------------------------------------------------------------------------;
//
//  BOOL ControlDriverEnumCallback
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD dwInstance:
//
//      DWORD fdwSupport:
//
//  Return (BOOL):
//
//  History:
//      09/18/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNCALLBACK ControlDriverEnumCallback
(
    HACMDRIVERID            hadid,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
)
{
    MMRESULT            mmr;
    HWND                hlb;
    ACMDRIVERDETAILS    add;
    TCHAR               ach[CONTROL_MAX_ITEM_CHARS];
    DWORD               dwPriority;
    LPACMDRIVERSETTINGS pads;
    BOOL                f;
    UINT                u;


    add.cbStruct = sizeof(add);
    mmr = acmDriverDetails(hadid, &add, 0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlDriverEnumCallback: acmDriverDetails failed! hadid=%.04Xh, mmr=%u", hadid, mmr);
        return (TRUE);
    }

    mmr = acmMetrics((HACMOBJ)hadid, ACM_METRIC_DRIVER_PRIORITY, &dwPriority);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlDriverEnumCallback: acmMetrics(priority) failed! hadid=%.04Xh, mmr=%u", hadid, mmr);
        return (TRUE);
    }

    f = (0 != (fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED));

    wsprintf(ach, gszFormatDriverDesc,
             dwPriority,
             (f ? (LPTSTR)gszDisabled : (LPTSTR)gszNull),
             (LPTSTR)add.szLongName);


    hlb = (HWND)(UINT)dwInstance;
    u   = ListBox_GetCount(hlb);

    pads = &CPLSettings.pads[u];

    pads->hadid        = hadid;
    pads->fdwSupport   = fdwSupport;
    pads->dwPriority   = dwPriority;

    u = ListBox_AddString(hlb, ach);
    ListBox_SetItemData(hlb, u, (LPARAM)(LPVOID)pads);

    return (TRUE);
} // ControlDriverEnumCallback()


//--------------------------------------------------------------------------;
//
//  BOOL ControlInitDialog
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//  Return (BOOL):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL ControlInitDialog
(
    HWND                    hwnd
)
{
    MMRESULT            mmr;
    UINT                u;
    UINT                cInDevs;
    UINT                cOutDevs;
    HWND                hlb;
    HWND                hcb;
    int                 aiTabs[2];
    RECT                rc;
    RECT                rcText;
    POINT               ptUpperLeft;
    HDC                 hdc;
    LPACMDRIVERSETTINGS pads;
    DWORD               cb;
    UINT                cTotalInstalledDrivers;
    TCHAR               ach[10];
    HFONT               hfont;
    SIZE                sSize;

    CPLSettings.pads = NULL;

    //
    //  For the tabbed listbox, we are defining 3 columns
    //  Priority, State, Name.  To be flexible, we need to know
    //  the max length of the text for the numeric, and the disabled strings
    //
    //  ->|        ->|
    //  1  (disabled) Long Name
    //
    //  The aiTabs array contains the tabstops where:
    //          aiTabs[0]
    //
    mmr = acmMetrics(NULL, ACM_METRIC_COUNT_DRIVERS, &cb);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlInitDialog: acmMetrics(count_drivers) failed! mmr=%u", mmr);
        cb = 0;
    }
    cTotalInstalledDrivers  = (UINT)cb;

    mmr = acmMetrics(NULL, ACM_METRIC_COUNT_DISABLED, &cb);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlInitDialog: acmMetrics(count_disabled) failed! mmr=%u", mmr);
        cb = 0;
    }
    cTotalInstalledDrivers += (UINT)cb;

    if (0 == cTotalInstalledDrivers)
    {
        // No drivers, MSACM was not initialized correctly.
        EndDialog(hwnd, FALSE);
        return (TRUE);
    }

    //
    //
    //
    cb   = sizeof(*pads) * cTotalInstalledDrivers;
    pads = (LPACMDRIVERSETTINGS)GlobalAllocPtr(GHND, cb);
    if (NULL == pads)
    {
        EndDialog(hwnd, FALSE);
        return (TRUE);
    }

    CPLSettings.pads = pads;

    //
    //
    //
    LoadString(gpag->hinst, IDS_TXT_DISABLED, gszDisabled, SIZEOF(gszDisabled));


    //
    //
    //
    hlb = GetDlgItem(hwnd, IDD_CPL_LIST_DRIVERS);

#ifdef JAPAN
    hfont = GetStockFont(SYSTEM_FIXED_FONT);
#else
    hfont = GetStockFont(ANSI_VAR_FONT);
#endif

    SetWindowFont(hlb, hfont, FALSE);

    SetWindowRedraw(hlb, FALSE);
    ListBox_ResetContent(hlb);

    mmr = acmDriverEnum(ControlDriverEnumCallback,
                        (DWORD)(UINT)hlb,
                        ACM_DRIVERENUMF_NOLOCAL |
                        ACM_DRIVERENUMF_DISABLED);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlInitDialog: acmDriverEnum failed! mmr=%u", mmr);
        EndDialog(hwnd, FALSE);
        return (TRUE);
    }


    //
    //
    //
    mmr = acmDriverAdd(&ghadidNotify,
                        gpag->hinst,
                        (LPARAM)(UINT)hwnd,
                        WM_ACMMAP_ACM_NOTIFY,
                        ACM_DRIVERADDF_NOTIFYHWND);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!ControlInitDialog: acmDriverAdd failed to add notify window! mmr=%u", mmr);
    }


    //
    //
    //
    hdc = GetDC(hlb);

    u = ListBox_GetCount(hlb);
    wsprintf(ach, gszFormatNumber, (DWORD)u);

    GetTextExtentPoint(hdc, ach, lstrlen(ach), &sSize);
    aiTabs[0] = sSize.cx;

#ifdef JAPAN
//fix kksuzuka: #2206
//Since the charcter number of Japanese localized Disabled string is less
// than localized priority string, sSize.cx is not enough to disp Priority
//string.
    GetTextExtentPoint(hdc, TEXT("xxxxxxxxxx"), 10, &sSize);
#else
    GetTextExtentPoint(hdc, gszDisabled, lstrlen(gszDisabled), &sSize);
#endif

    aiTabs[1] = sSize.cx;

    ReleaseDC(hlb, hdc);

    //
    //  one dialog base cell
    //
    rc.left   = 0;
    rc.right  = 4;
    rc.top    = 0;
    rc.bottom = 8;

    MapDialogRect(hwnd,&rc);

    // rc.right now contains the width of dialog base unit in pixels

    aiTabs[0] = (aiTabs[0] * 4) / rc.right;
    aiTabs[1] = (aiTabs[1] * 4) / rc.right;

    // Now add separation between columns.

    aiTabs[0] += 4;
    aiTabs[1] += aiTabs[0] + 4;

    ListBox_SetTabStops(hlb, 2, (LPARAM)(LPVOID)aiTabs);


    //
    //  Note: Translation back to logical units.
    //      Tabs[0] = (aiTabs[0] * rc.right) / 4;
    //      Tabs[1] = (aiTabs[1] * rc.right) / 4;
    //

    //
    //  Ok, what's going on in the next chunk of code is the column
    //  description "Driver" is being moved on top of it's tabbed
    //  column.  Since we keep the dialog coordinates of the second
    //  tab around, we just convert back to logical coordinates and
    //  shift the static control over (relative to the origin where
    //  the static "Priority" control sits.
    //
    //  Move window positions relative to the parent client area, so we
    //  need to translate to client coordinates after we've gotten the
    //  position of the control in screen coordinates.
    //
    //
    //  Use "Priority" as a reference, since it never moves and
    //  this function might be called more than once.
    //
    GetWindowRect(GetDlgItem(hwnd,IDD_CPL_STATIC_PRIORITY), &rcText);

    ptUpperLeft.x = rcText.left;
    ptUpperLeft.y = rcText.top;

    ScreenToClient(hwnd, &ptUpperLeft);

    rcText.right  -= rcText.left;
    rcText.bottom -= rcText.top;

    rcText.left = ptUpperLeft.x;
    rcText.top  = ptUpperLeft.y;

    //
    //  move relative 2 dialog tabs translated to logical units.
    //
#if (WINVER < 0x0400)
    rcText.left += (aiTabs[1] * (rc.right - 1)) / 4;
#else
    rcText.left += (aiTabs[1] * rc.right) / 4;
#endif

    MoveWindow(GetDlgItem(hwnd, IDD_CPL_STATIC_DRIVERS),
               rcText.left,
               rcText.top,
               rcText.right,
               rcText.bottom,
               FALSE);

    //
    //  set up the initial selection to be the first driver--i wonder
    //  what we should do if NO drivers are installed? but since we
    //  will ALWAYS have the PCM converter installed (regardless of whether
    //  it is enabled or disabled), i'm not going to worry about it...
    //
    ListBox_SetCurSel(hlb, 0);
    ControlNewDriverSelected(hwnd);

    SetWindowRedraw(hlb, TRUE);
    InvalidateRect(hlb, NULL, FALSE);



    //
    //  !!!
    //
    //
    cInDevs  = gpag->cWaveInDevs;
    cOutDevs = gpag->cWaveOutDevs;

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    //
    //  fill the output devices combo box
    //
    hcb = GetDlgItem(hwnd, IDD_CPL_COMBO_PLAYBACK);
    SetWindowFont(hcb, hfont, FALSE);
    ComboBox_ResetContent(hcb);

    if (0 == cOutDevs)
    {
        EnableWindow(hcb, FALSE);
    }
    else
    {
        for (u = 0; u < cOutDevs; u++)
        {
            WAVEOUTCAPS     woc;

            waveOutGetDevCaps(u, &woc, sizeof(woc));
            woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

            ComboBox_AddString(hcb, woc.szPname);
            ComboBox_SetItemData(hcb, u + 1, (LPARAM)u);
        }

        u = (UINT)ComboBox_SelectString(hcb, 0, gpag->pSettings->szPreferredWaveOut);
        if (CB_ERR == u)
        {
            ComboBox_SetCurSel(hcb, 0);
        }
    }

    //
    //  fill the input devices combo box
    //
    hcb = GetDlgItem(hwnd, IDD_CPL_COMBO_RECORD);
    SetWindowFont(hcb, hfont, FALSE);
    ComboBox_ResetContent(hcb);

    if (0 == cInDevs)
    {
        EnableWindow(hcb, FALSE);
    }
    else
    {
        for (u = 0; u < cInDevs; u++)
        {
            WAVEINCAPS      wic;

            waveInGetDevCaps(u, &wic, sizeof(wic));
            wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

            ComboBox_AddString(hcb, wic.szPname);
            ComboBox_SetItemData(hcb, u + 1, (LPARAM)u);
        }

        u = (UINT)ComboBox_SelectString(hcb, 0, gpag->pSettings->szPreferredWaveIn);
        if (CB_ERR == u)
        {
            ComboBox_SetCurSel(hcb, 0);
        }
    }

    //
    //
    //
    CPLSettings.fPreferredOnly = gpag->pSettings->fPreferredOnly;
    CheckDlgButton(hwnd, IDD_CPL_CHECK_PREFERRED, gpag->pSettings->fPreferredOnly);

    RELEASE_MUTEX(gpag->hMutexSettings);

#if (WINVER >= 0x0400)
	EnableWindow(GetDlgItem(hwnd, IDD_CPL_BTN_INSTALL), TRUE); //VIJR: disable install
    //CPLSendNotify(hwnd, LOWORD((DWORD)DLG_CPL_MSACM), PSN_CHANGED);
    PropSheet_Changed(GetParent(hwnd),hwnd);
#endif

    return (TRUE);
} // ControlInitDialog()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  void ControlCommand
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      WPARAM wParam:
//
//      LPARAM lParam:
//
//  Return (void):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

void FNLOCAL ControlCommand
(
    HWND                    hwnd,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    UINT                uCmdId;
    UINT                uCmd;
    HWND                hwndCmd;
    LPACMDRIVERSETTINGS pads;

    //
    //
    //
    uCmdId  = GET_WM_COMMAND_ID(wParam, lParam);
    uCmd    = GET_WM_COMMAND_CMD(wParam, lParam);
    hwndCmd = GET_WM_COMMAND_HWND(wParam, lParam);

    switch (uCmdId)
    {
        case IDD_CPL_BTN_APPLY:
            ControlApplySettings(hwnd);
            break;

        case IDOK:
#if (WINVER < 0x0400)
            ControlApplySettings(hwnd);
            if (GetKeyState(VK_CONTROL) < 0)
                break;
#endif

        case IDCANCEL:
            WinHelp(hwnd, gszCPLHelp, HELP_QUIT, 0L);
            EndDialog(hwnd, (TRUE == uCmdId));
            break;


        case IDD_CPL_BTN_CONFIGURE:
            pads = ControlGetSelectedDriver(hwnd);
            ControlConfigureDriver(hwnd, pads);
            break;

        case IDD_CPL_BTN_ABOUT:
            pads = ControlGetSelectedDriver(hwnd);
            ControlAboutDriver(hwnd, pads);
            break;

        case IDD_CPL_BTN_PRIORITY:
            ControlChangePriority(hwnd);
            break;

        case IDD_CPL_BTN_HELP:
#ifdef USE_DAYTONA_HELP
            WinHelp(hwnd, gszCPLHelp, HELP_CONTEXT, IDH_CHILD_MSACM );
#else
            WinHelp(hwnd, gszCPLHelp, HELP_CONTENTS, 0L);
#endif
            break;

        case IDD_CPL_BTN_BUMPTOTOP:
            break;

        case IDD_CPL_BTN_ABLE:
            pads = ControlGetSelectedDriver(hwnd);
            if (NULL != pads)
            {
                pads->fdwSupport ^= ACMDRIVERDETAILS_SUPPORTF_DISABLED;
                ControlRefreshList(hwnd, FALSE);
            }
            break;

#if (WINVER >= 0x0400)
        case IDD_CPL_BTN_INSTALL:
        {
            typedef RETERR (WINAPI pfnDICREATEDEVICEINFO)(LPLPDEVICE_INFO lplpdi, LPCSTR lpszDescription, DWORD hDevnode, HKEY hkey, LPCSTR lpszRegsubkey, LPCSTR lpszClassName, HWND hwndParent);
            typedef RETERR (WINAPI pfnDIDESTROYDEVICEINFOLIST)(LPDEVICE_INFO lpdi);
            typedef RETERR (WINAPI pfnDICALLCLASSINSTALLER)(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

            static TCHAR BCODE gszSetupX[] = TEXT("SETUPX.DLL");
            static TCHAR BCODE gszDiCreateDeviceInfo[] = TEXT("DiCreateDeviceInfo");
            static TCHAR BCODE gszDiDestroyDeviceInfoList[] = TEXT("DiDestroyDeviceInfoList");
            static TCHAR BCODE gszDiCallClassInstaller[] = TEXT("DiCallClassInstaller");

            pfnDICREATEDEVICEINFO FAR*       pfnDiCreateDeviceInfo;
            pfnDIDESTROYDEVICEINFOLIST FAR*  pfnDiDestroyDeviceInfoList;
            pfnDICALLCLASSINSTALLER FAR*     pfnDiCallClassInstaller;
            LPDEVICE_INFO       lpdi;
            HINSTANCE           hiSetupX;

            hiSetupX = LoadLibrary(gszSetupX);
            if (hiSetupX <= HINSTANCE_ERROR)
                break;
            pfnDiCreateDeviceInfo = (pfnDICREATEDEVICEINFO FAR*)GetProcAddress(hiSetupX, gszDiCreateDeviceInfo);
            pfnDiDestroyDeviceInfoList = (pfnDIDESTROYDEVICEINFOLIST FAR*)GetProcAddress(hiSetupX, gszDiDestroyDeviceInfoList);
            pfnDiCallClassInstaller = (pfnDICALLCLASSINSTALLER FAR*)GetProcAddress(hiSetupX, gszDiCallClassInstaller);

            pfnDiCreateDeviceInfo(&lpdi, NULL, NULL, NULL, NULL, "media",
                               GetParent(hwnd));

            lpdi->Flags |= DI_SHOWOEM;
            if (pfnDiCallClassInstaller(DIF_SELECTDEVICE, lpdi) == OK)
            {
                pfnDiCallClassInstaller(DIF_INSTALLDEVICE, lpdi);
            }
            pfnDiDestroyDeviceInfoList(lpdi);
            FreeLibrary(hiSetupX);

            break;
        }
#endif

        case IDD_CPL_CHECK_PREFERRED:
            CPLSettings.fPreferredOnly = IsDlgButtonChecked(hwnd, IDD_CPL_CHECK_PREFERRED);
            break;

        case IDD_CPL_COMBO_RECORD:
        case IDD_CPL_COMBO_PLAYBACK:
            if (CBN_SELCHANGE == uCmd)
            {
                ControlWaveDeviceChanged(hwnd, hwndCmd, uCmdId);
            }
            break;

        case IDD_CPL_LIST_DRIVERS:
            switch (uCmd)
            {
                case LBN_SELCHANGE:
                    ControlNewDriverSelected(hwnd);
                    break;

                case LBN_DBLCLK:
                    if (GetKeyState(VK_CONTROL) < 0)
                    {
                        uCmd = IDD_CPL_BTN_ABLE;
                    }
                    else if (GetKeyState(VK_SHIFT) < 0)
                    {
                        uCmd = IDD_CPL_BTN_BUMPTOTOP;
                    }
                    else
                    {
                        uCmd = IDD_CPL_BTN_ABOUT;
                    }

                    ControlCommand(hwnd, uCmd, 0L);
                    break;
            }
            break;
    }
} // ControlCommand()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL ACMDlg
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      UINT uMsg:
//
//      WPARAM wParam:
//
//      LPARAM lParam:
//
//  Return (BOOL):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNCALLBACK ACMDlg
(
    HWND                hwnd,
    UINT                uMsg,
    WPARAM              wParam,
    LPARAM              lParam
)
{
#if (WINVER >= 0x0400)
    LPNMHDR         pnm;
#endif

    switch (uMsg)
    {
        case WM_INITDIALOG:
            ControlInitDialog(hwnd);
            return (TRUE);

        case WM_COMMAND:
            ControlCommand(hwnd, wParam, lParam);
            return (TRUE);

        case WM_DESTROY:
            ControlCleanupDialog(hwnd);
            return (TRUE);

        case WM_ACMMAP_ACM_NOTIFY:
            ControlRefreshList(hwnd, TRUE);
            return (TRUE);


#if (WINVER >= 0x0400)
        //
        //  right mouse click (and F1)
        //
        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, gszCPLHelp, HELP_CONTEXTMENU, (DWORD)(LPSTR)ganKeywordIds);
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, gszCPLHelp, WM_HELP, (DWORD)(LPSTR)ganKeywordIds);
            break;

        case WM_NOTIFY:
            pnm = (NMHDR FAR *)lParam;
            switch(pnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hwnd, IDOK, 0, 0, SendMessage);
                    break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hwnd, IDD_CPL_BTN_APPLY, 0, 0, SendMessage);
                    return TRUE;

                case PSN_SETACTIVE:
//                  FORWARD_WM_COMMAND(hwnd, ID_INIT, 0, 0, SendMessage);
                    return TRUE;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hwnd, IDCANCEL, 0, 0, SendMessage);
                    return  TRUE;
            }
            break;
#endif
    }

    return (FALSE);
} // ACMDlg()


//==========================================================================;
//
//
//
//
//==========================================================================;

#if (WINVER < 0x0400)

//--------------------------------------------------------------------------;
//
//  LRESULT CPLApplet
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd:
//
//      UINT uMsg:
//
//      LPARAM lParam1:
//
//      LPARAM lParam2:
//
//  Return (LRESULT):
//
//  History:
//      09/08/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT CPlApplet
(
    HWND            hwnd,
    UINT            uMsg,
    LPARAM          lParam1,
    LPARAM          lParam2
)
{
    static BOOL     fAppletEntered = FALSE;
    LPNEWCPLINFO    pcpli;

    switch (uMsg)
    {
        case CPL_INIT:
#ifdef WIN32
            //
            //  Is it a bug that we rely on ENABLE being called?
            //

            mapSettingsRestore();
#endif
            //
            //  For snowball program managment.  They don't want to document
            //  the CPL.
            //
            if (!gpag->fEnableControl)
                return (FALSE);

            return (TRUE);

        case CPL_GETCOUNT:
            return (1L);

        case CPL_NEWINQUIRE:
            pcpli = (LPNEWCPLINFO)lParam2;

            pcpli->dwSize = sizeof(*pcpli);
            pcpli->hIcon  = LoadIcon(gpag->hinst, ICON_MSACM);

            LoadString(gpag->hinst, IDS_CPL_NAME, pcpli->szName, SIZEOF(pcpli->szName));
            LoadString(gpag->hinst, IDS_CPL_INFO, pcpli->szInfo, SIZEOF(pcpli->szInfo));
            lstrcpy(pcpli->szHelpFile, gszCPLHelp);

            pcpli->lData         = 0;
            pcpli->dwHelpContext = 0;

            return (TRUE);


        case CPL_DBLCLK:
            if (!fAppletEntered)
            {
                fAppletEntered = TRUE;
                DialogBox(gpag->hinst, DLG_CPL_MSACM, hwnd, ACMDlg);
                fAppletEntered = FALSE;
            }
            break;

        case CPL_SELECT:
        case CPL_STOP:
        case CPL_EXIT:
            break;
    }

    return (0L);
} // CPLApplet()

#else // WINVER


//
// Function:    ReleasePage, private
//
// Descriptions:
//   This function performs any needed cleanup on the property sheet which
//   was previously created.
//
// Arguments:
//  ppsp    -- the page which is being deleted.
//
// Returns:
//  void
//

EXTERN_C void FNEXPORT ReleasePage
(
    LPPROPSHEETPAGE    ppsp
)
{
    LocalFree((HLOCAL)ppsp->lParam);
}

//
// Function:    AddAcmPages, private
//
// Descriptions:
//   This function creates a property sheet object for the resource page
//  which shows resource information.
//
// Arguments:
//  lpszResource    -- the class for which the page is to be added
//  lpfnAddPage     -- the callback function.
//  lParam          -- the lParam to be passed to the callback.
//
// Returns:
//  TRUE, if no error FALSE, otherwise.
//

EXTERN_C BOOL FNEXPORT AddAcmPages
(
    LPVOID                  pszTitle,
    LPFNADDPROPSHEETPAGE    lpfnAddPropSheetPage,
    LPARAM                  lParam
)
{
    PROPSHEETPAGE    psp;
    PSTR             szTitle;

    if (szTitle = (PSTR)LocalAlloc(LPTR, lstrlen(pszTitle) + 1)) {
        HPROPSHEETPAGE    hpsp;

        lstrcpy(szTitle, pszTitle);
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = PSP_USETITLE | PSP_USERELEASEFUNC;
        psp.hInstance = gpag->hinst;
        psp.pszTemplate = DLG_CPL_MSACM;
        psp.pszIcon = NULL;
        psp.pszTitle = szTitle;
        psp.pfnDlgProc = ACMDlg;
        psp.lParam = (LPARAM)(LPSTR)szTitle;
        psp.pfnRelease = ReleasePage;
        psp.pcRefParent = NULL;
        if (hpsp = CreatePropertySheetPage(&psp)) {
            if (lpfnAddPropSheetPage(hpsp, lParam))
                return TRUE;
            DestroyPropertySheetPage(hpsp);
        } else
            LocalFree((HLOCAL)szTitle);
    }
    return FALSE;
}


LRESULT PASCAL CPLSendNotify(HWND hwnd, int idFrom, int code)
{
    LRESULT     lr;
    NMHDR       nm;

    nm.hwndFrom = hwnd;
    nm.idFrom   = idFrom;
    nm.code     = code;

    lr = SendMessage(GetParent(hwnd), WM_NOTIFY, 0, (LPARAM)(LPVOID)&nm);
    return (lr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\msacmhlp.h ===
//==========================================================================;
//
//  msacmhlp.h
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       9/29/93    cjp     [curtisp] 
//
//==========================================================================;

//
//
//
//
//
#define IDH_AUDIOCOMP_DRIVER	2417
#define IDH_AUDIOCOMP_PLAYBACK	2418
#define IDH_AUDIOCOMP_RECORDING 2419
#define IDH_AUDIOCOMP_PREFERRED 2420
#define IDH_PRIORITY_CHANGE	2421
#define IDH_PRIORITY_DISABLE	2422
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\msacmmap.h ===
//==========================================================================;
//
//  msacmmap.h
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       8/ 2/93    cjp     [curtisp]
//
//==========================================================================;


#ifndef _INC_MSACMMAP
#define _INC_MSACMMAP            // #defined if msacmmap.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                 // assume byte packing throughout
#endif  // RC_INVOKED


#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif


#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif  // __cplusplus


#ifndef MMVERSION
#include <verinfo.h>
#endif

#define VERSION_MSACMMAP_MAJOR  MMVERSION
#define VERSION_MSACMMAP_MINOR  MMREVISION

#define VERSION_MSACMMAP        ((VERSION_MSACMMAP_MAJOR << 8) | VERSION_MSACMMAP_MINOR)


//
//
//
#ifndef SIZEOF_WAVEFORMATEX
#define SIZEOF_WAVEFORMATEX(pwfx)   ((WAVE_FORMAT_PCM==(pwfx)->wFormatTag)?sizeof(PCMWAVEFORMAT):(sizeof(WAVEFORMATEX)+(pwfx)->cbSize))
#endif



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#ifdef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNCALLBACK  CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE
    #define BDATA
    #define BSTACK

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
        ((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
        #define DEVFMT_STR  "%ls"
    #else
        #define SIZEOF(x)   sizeof(x)
        #define DEVFMT_STR  "%s"
    #endif

    #define GetCurrentTask  (HTASK)GetCurrentThreadId

#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNCALLBACK  FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _loadds _export
    #else
        #define FNCALLBACK  FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif


    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))
    #define BDATA           _based(_segname("_DATA"))
    #define BSTACK          _based(_segname("_STACK"))

    #define HUGE            _huge


    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif


    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef const PTSTR     PCTSTR;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define DEVFMT_STR      "%s"

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
        DWORD   dw;                                                 \
        dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
        *pnE = (int)HIWORD(dw);                                     \
        *pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32
#endif // #ifndef RC_INVOKED


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Resource defines
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  Be compatible with multimed.cpl in Windows NT
//
#define ICON_MSACM                  RCID(3004)
#else
#define ICON_MSACM                  RCID(10)
#endif
#define ICON_INPUT                  RCID(11)
#define ICON_OUTPUT                 RCID(12)
#define ICON_MSACMMAP               RCID(13)


#define DLG_CPL_MSACM               RCID(50)
#define IDD_CPL_STATIC_DRIVERS      100
#define IDD_CPL_LIST_DRIVERS        101
#define IDD_CPL_BTN_CONFIGURE       102
#define IDD_CPL_BTN_ABOUT           103
#define IDD_CPL_BTN_PRIORITY        104
#define IDD_CPL_BTN_HELP            105
#define IDD_CPL_BTN_RESTART         106
#define IDD_CPL_BTN_ABLE            107
#define IDD_CPL_BTN_BUMPTOTOP       108
#define IDD_CPL_BTN_INSTALL         109
#define IDD_CPL_BTN_APPLY           110
#define IDD_CPL_STATIC_PRIORITY     111
#define IDD_CPL_COMBO_PLAYBACK      120
#define IDD_CPL_COMBO_RECORD        121
#define IDD_CPL_CHECK_PREFERRED     122

#define DLG_RESTART_MSACM           RCID(55)

#define DLG_ABOUT_MSACM             RCID(60)
#define IDD_ABOUT_ICON_DRIVER       100
#define IDD_ABOUT_TXT_DESCRIPTION   101
#define IDD_ABOUT_TXT_VERSION       102
#define IDD_ABOUT_TXT_COPYRIGHT     103
#define IDD_ABOUT_TXT_LICENSING     104
#define IDD_ABOUT_TXT_FEATURES      105

#define IDS_ABOUT_TAG               200
#define IDS_ABOUT_TITLE             (IDS_ABOUT_TAG + 0)
#define IDS_ABOUT_VERSION           (IDS_ABOUT_TAG + 1)



//
//  string resource defines, etc.
//
#define IDS_ACM_CAPS_TAG            50
#define IDS_ACM_CAPS_DESCRIPTION    (IDS_ACM_CAPS_TAG+0)

#ifdef WIN32
//
//  Be compatible with NT's multimed.cpl
//
#define IDS_CPL_TAG                 3001
#define IDS_CPL_HELPFILE            3003
#else
#define IDS_CPL_TAG                 100
#endif
#define IDS_CPL_NAME                (IDS_CPL_TAG+0)
#define IDS_CPL_INFO                (IDS_CPL_TAG+1)

#define IDS_TXT_TAG                 150
#define IDS_TXT_NONE                (IDS_TXT_TAG+0)
#define IDS_TXT_DISABLED            (IDS_TXT_TAG+1)


#define DLG_PRIORITY_SET            RCID(80)
#define IDD_PRIORITY_TXT_DRIVER     100
#define IDD_PRIORITY_TXT_FROMTO     101
#define IDD_PRIORITY_COMBO_PRIORITY 102
#define IDD_PRIORITY_CHECK_DISABLE  103

#define IDS_PRIORITY_FROMTO         (IDS_CPL_TAG+6)






//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  Note: These fields were taken out of ACMGARB b/c they are common to all
//        instances of the mapper and change in one instance should reflect
//        change in all instances.
//

typedef struct tACMGLOBALINFO
{
    BOOL            fPreferredOnly;
    BOOL            fSyncOnlyOut;
    UINT            uIdPreferredOut;
    BOOL            fSyncOnlyIn;
    UINT            uIdPreferredIn;
} ACMGLOBALINFO, *PACMGLOBALINFO;

// To simplify Win16/Win32 code

#ifndef WIN32

    #define WAIT_FOR_MUTEX(a)
    #define RELEASE_MUTEX(a)

#else   //  WIN32

    #define WAIT_FOR_MUTEX(a)   if(NULL != a) WaitForSingleObject(a, INFINITE)
    #define RELEASE_MUTEX(a)    if(NULL != a) ReleaseMutex(a)

#endif  //  WIN32

typedef struct tACMGARB
{
    HINSTANCE       hinst;              // hinst of ACM module

    BOOL            fEnabled;           // whether mapper driver is enabled

    BOOL            fPrestoSyncAsync;   // allow async opens on sync devs

    UINT            cInputStreams;      // ref count for input mapping task
#ifndef WIN32
    HTASK           htaskInput;         // input mapping task
#else
    HANDLE          hMutexSettings;     // handle to mutex for settings
#endif
#ifdef DEBUG
    BOOL            fFaultAndDie;
#endif

    UINT            cWaveOutDevs;       // value from waveOutGetNumDevs
    UINT            cWaveInDevs;        // value from waveInGetNumDevs

    PACMGLOBALINFO  pSettings;

//    BOOL            fPreferredOnly;
//    BOOL            fSyncOnlyOut;
//    UINT            uIdPreferredOut;
//    BOOL            fSyncOnlyIn;
//    UINT            uIdPreferredIn;
//
//    TCHAR           szPreferredWaveOut[MAXPNAMELEN];
//    TCHAR           szPreferredWaveIn[MAXPNAMELEN];

} ACMGARB, *PACMGARB, FAR *LPACMGARB;


typedef MMRESULT FAR * LPMMRESULT;

//
//
//
extern PACMGARB         gpag;
extern TCHAR            gszNull[];






//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  structure/flag definitions used for GetWaveFormats and FindBestPCMFormat
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tZYZPCMFORMAT
{
    PUINT   uFlagsInput;
    PUINT   uFlagsOutput;
    UINT    uSamplesPerSec;

} ZYZPCMFORMAT, *PZYZPCMFORMAT, FAR LPZYZPCMFORMAT;

//
//  note that the _order_ of these bits is very important--they map 1 to 1
//  with the format bits in dwFormats of the waveformat structure
//
#define ZYZPCMF_OUT_M08     0x0001
#define ZYZPCMF_OUT_S08     0x0002
#define ZYZPCMF_OUT_M16     0x0004
#define ZYZPCMF_OUT_S16     0x0008
#define ZYZPCMF_IN_M08      0x0100
#define ZYZPCMF_IN_S08      0x0200
#define ZYZPCMF_IN_M16      0x0400
#define ZYZPCMF_IN_S16      0x0800

#define ZYZPCMF_OUT_FORMATS (ZYZPCMF_OUT_M08 | ZYZPCMF_OUT_S08 | ZYZPCMF_OUT_M16 | ZYZPCMF_OUT_S16)
#define ZYZPCMF_OUT_STEREO  (ZYZPCMF_OUT_S08 | ZYZPCMF_OUT_S16)
#define ZYZPCMF_OUT_MONO    (ZYZPCMF_OUT_M08 | ZYZPCMF_OUT_M16)
#define ZYZPCMF_OUT_8BIT    (ZYZPCMF_OUT_M08 | ZYZPCMF_OUT_S08)
#define ZYZPCMF_OUT_16BIT   (ZYZPCMF_OUT_M16 | ZYZPCMF_OUT_S16)

#define ZYZPCMF_IN_FORMATS  (ZYZPCMF_IN_M08 | ZYZPCMF_IN_S08 | ZYZPCMF_IN_M16 | ZYZPCMF_IN_S16)
#define ZYZPCMF_IN_STEREO   (ZYZPCMF_IN_S08 | ZYZPCMF_IN_S16)
#define ZYZPCMF_IN_MONO     (ZYZPCMF_IN_M08 | ZYZPCMF_IN_M16)
#define ZYZPCMF_IN_8BIT     (ZYZPCMF_IN_M08 | ZYZPCMF_IN_S08)
#define ZYZPCMF_IN_16BIT    (ZYZPCMF_IN_M16 | ZYZPCMF_IN_S16)


extern ZYZPCMFORMAT gaPCMFormats[];



//
//
//
//
//
typedef MMRESULT (WINAPI *MAPPEDWAVEOPEN)
(
    HWAVE              FAR *phw,
    UINT                    uId,
    LPWAVEFORMATEX          pwfx,
    DWORD_PTR               dwCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwOpen
);

typedef MMRESULT (WINAPI *MAPPEDWAVECLOSE)
(
    HWAVE                   hw
);

typedef MMRESULT (WINAPI *MAPPEDWAVEPREPAREHEADER)
(
    HWAVE                   hw,
    LPWAVEHDR               pwh,
    UINT                    cbwh
);

typedef MMRESULT (WINAPI *MAPPEDWAVEUNPREPAREHEADER)
(
    HWAVE                   hw,
    LPWAVEHDR               pwh,
    UINT                    cbwh
);

typedef MMRESULT (WINAPI *MAPPEDWAVEWRITE)
(
    HWAVE                   hw,
    LPWAVEHDR               pwh,
    UINT                    cbwh
);

typedef MMRESULT (WINAPI *MAPPEDWAVEGETPOSITION)
(
    HWAVE                   hw,
    LPMMTIME                pmmt,
    UINT                    cbmmt
);

typedef MMRESULT (WINAPI *MAPPEDWAVEMESSAGE)
(
    HWAVE                   hw,
    UINT                    msg,
    DWORD_PTR               dw1,
    DWORD_PTR               dw2
);

//
//
//
//
//
typedef struct tMAPSTREAM      FAR *LPMAPSTREAM;
typedef struct tMAPSTREAM
{
////LPMAPSTREAM         pmsNext;        // next stream for mapper

    MMRESULT            mmrClient;

    UINT                uHeuristic;

    HACMDRIVER          had;            // handle to ACM driver we chose
    HACMSTREAM          has;            // handle to ACM conversion stream
    LPWAVEFORMATEX      pwfxSrc;        // source format when mapping
    LPWAVEFORMATEX      pwfxDst;        // destination format when mapping
    DWORD               fdwSupport;     // support required for conversion

    BOOL                fInput;         // TRUE if input
#ifdef WIN32
    DWORD               htaskInput;	// Thread id of input
    HANDLE              hInput;         // Thread handle of input
    HANDLE              hStoppedEvent;  // Input stopped
    volatile LONG       nOutstanding;   // Input buffers outstanding
#else
    HTASK               htaskInput;     // for input mapping....
#endif
    DWORD               fdwOpen;        // client's allocation flags

    UINT                uMappedDeviceID;// device to map to if WAVE_MAPPED flag
    DWORD_PTR           dwCallback;     // client callback
    DWORD_PTR           dwInstance;     // client callback instance data

    LPWAVEFORMATEX      pwfxClient;     // format of client wave data
    union
    {
        HWAVE           hwClient;       // client's handle to ACM
        HWAVEOUT        hwoClient;
        HWAVEIN         hwiClient;
    };


    LPWAVEFORMATEX      pwfxReal;       // format of device wave data
    DWORD               cbwfxReal;
    UINT                uIdReal;
    union
    {
        HWAVE           hwReal;         // device wave handle
        HWAVEOUT        hwoReal;
        HWAVEIN         hwiReal;
    };

    MAPPEDWAVEOPEN              fnWaveOpen;
    MAPPEDWAVECLOSE             fnWaveClose;
    MAPPEDWAVEPREPAREHEADER     fnWavePrepareHeader;
    MAPPEDWAVEUNPREPAREHEADER   fnWaveUnprepareHeader;
    MAPPEDWAVEWRITE             fnWaveWrite;
    MAPPEDWAVEGETPOSITION       fnWaveGetPosition;
    MAPPEDWAVEMESSAGE           fnWaveMessage;

} MAPSTREAM;



BOOL FNGLOBAL GetWaveFormats(PZYZPCMFORMAT pzpf);

MMRESULT FNGLOBAL mapWaveGetDevCaps(BOOL fInput, LPWAVEOUTCAPS pwc, UINT cbSize);


//
//
//
//
MMRESULT FNLOCAL FindConverterMatch(LPMAPSTREAM pms);

MMRESULT FNLOCAL mapWaveGetPosition(LPMAPSTREAM pms,LPMMTIME pmmt,UINT cbmmt);

DWORD FNLOCAL mapWaveOpen(BOOL fInput, UINT uId, DWORD_PTR dwUser, LPWAVEOPENDESC pwod, DWORD fdwOpen);
DWORD FNLOCAL mapWaveClose(LPMAPSTREAM pms);
DWORD FNLOCAL mapWavePrepareHeader(LPMAPSTREAM pms, LPWAVEHDR pwh);
DWORD FNLOCAL mapWaveUnprepareHeader(LPMAPSTREAM pms, LPWAVEHDR pwh);
DWORD FNLOCAL mapWaveWriteBuffer(LPMAPSTREAM pms, LPWAVEHDR pwh);

EXTERN_C BOOL FNGLOBAL mapWaveDriverCallback
(
    LPMAPSTREAM         pms,
    UINT                uMsg,
    DWORD_PTR           dw1,
    DWORD_PTR           dw2
);


// Task proc for hidden input mapping window
EXTERN_C LRESULT FNCALLBACK mapWaveInputConvertProc
(
    DWORD               dwInst
);


EXTERN_C void FNCALLBACK mapWaveCallback
(
    HWAVE               hw,
    UINT                uMsg,
    DWORD_PTR           dwUser,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2
);


//
//
//
//
BOOL FNGLOBAL mapSettingsRestore(void);
BOOL FNGLOBAL mapSettingsSave(void);

LRESULT FNGLOBAL mapDriverEnable(HDRVR hdrvr);
LRESULT FNGLOBAL mapDriverDisable(HDRVR hdrvr);
LRESULT FNGLOBAL mapDriverInstall(HDRVR hdrvr);
LRESULT FNGLOBAL mapDriverRemove(HDRVR hdrvr);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Misc defines and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define MAX_HEURISTIC           6

//
//
//
//
#define WAVE_FORMAT_STEREO8     (WAVE_FORMAT_1S08 | WAVE_FORMAT_2S08 | WAVE_FORMAT_4S08)
#define WAVE_FORMAT_STEREO16    (WAVE_FORMAT_1S16 | WAVE_FORMAT_2S16 | WAVE_FORMAT_4S16)

#define WAVE_FORMAT_MONO8       (WAVE_FORMAT_1M08 | WAVE_FORMAT_2M08 | WAVE_FORMAT_4M08)
#define WAVE_FORMAT_MONO16      (WAVE_FORMAT_1M16 | WAVE_FORMAT_2M16 | WAVE_FORMAT_4M16)

#define WAVE_FORMAT_44k         (WAVE_FORMAT_4M16 | WAVE_FORMAT_4S16 | WAVE_FORMAT_4M08 | WAVE_FORMAT_4S08)
#define WAVE_FORMAT_22k         (WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16 | WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08)
#define WAVE_FORMAT_11k         (WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16 | WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08)

#define WAVE_FORMAT_MONO_44k    (WAVE_FORMAT_4M16 | WAVE_FORMAT_4M08)
#define WAVE_FORMAT_MONO_22k    (WAVE_FORMAT_2M16 | WAVE_FORMAT_2M08)
#define WAVE_FORMAT_MONO_11k    (WAVE_FORMAT_1M16 | WAVE_FORMAT_1M08)

#define WAVE_FORMAT_STEREO_44k  (WAVE_FORMAT_4S16 | WAVE_FORMAT_4S08)
#define WAVE_FORMAT_STEREO_22k  (WAVE_FORMAT_2S16 | WAVE_FORMAT_2S08)
#define WAVE_FORMAT_STEREO_11k  (WAVE_FORMAT_1S16 | WAVE_FORMAT_1S08)

#define WAVE_FORMAT_STEREO      (WAVE_FORMAT_STEREO16 | WAVE_FORMAT_STEREO8)
#define WAVE_FORMAT_MONO        (WAVE_FORMAT_MONO16   | WAVE_FORMAT_MONO8)
#define WAVE_FORMAT_16BIT       (WAVE_FORMAT_STEREO16 | WAVE_FORMAT_MONO16)
#define WAVE_FORMAT_8BIT        (WAVE_FORMAT_STEREO8  | WAVE_FORMAT_MONO8)


#ifndef RC_INVOKED
#pragma pack()                  // revert to default packing
#endif  // RC_INVOKED

#ifdef __cplusplus
}                               // end of extern "C" {
#endif  // __cplusplus

#endif  // _INC_MSACMMAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\msacmmap.c ===
//==========================================================================;
//
//  msacmmap.c
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       9/18/93    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <memory.h>

#include "muldiv32.h"
#include "msacmmap.h"

#include "debug.h"

extern ACMGARB acmgarb;

//
//
//
ZYZPCMFORMAT gaPCMFormats[] =
{
    { NULL, NULL,   5510},
    { NULL, NULL,   6620},
    { NULL, NULL,   8000},
    { NULL, NULL,   9600},
    { NULL, NULL,  11025},
    { NULL, NULL,  16000},
    { NULL, NULL,  18900},
    { NULL, NULL,  22050},
    { NULL, NULL,  27420},
    { NULL, NULL,  32000},
    { NULL, NULL,  33075},
    { NULL, NULL,  37800},
    { NULL, NULL,  44100},
    { NULL, NULL,  48000},
    { NULL, NULL,      0}   // terminator

    //  WARNING!!!  WARNING!!!
    //  If you change this array size update the size in:
    //      init.c:mapSettingsRestore
};


//==========================================================================;
//
//                 -= INTERRUPT TIME CODE FOR WIN 16 =-
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL mapWaveDriverCallback
//
//  Description:
//      This calls DriverCallback for a WAVEHDR.
//
//      NOTE! this routine must be in a FIXED segment in Win 16.
//
//  Arguments:
//      LPMAPSTREAM pms: Pointer to instance data.
//
//      UINT uMsg: The message.
//
//      DWORD dw1: Message DWORD (dw2 is always set to 0).
//
//  Return (BOOL):
//      The result is non-zero if the function was able to do the callback.
//      Zero is returned if no callback was made.
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#pragma alloc_text(FIX_TEXT, mapWaveDriverCallback)

//
//  NOTE! we *DO NOT* turn off optimization for Win 3.1 builds to keep the
//  compiler from using extended registers (we compile with -G3). this
//  function causes no extended registers to be used (like mapWaveCallback
//  does).
//
//  !!! IF YOU TOUCH ANY OF THIS CODE, YOU MUST VERIFY THAT NO EXTENDED
//  !!! REGISTERS GET USED IN WIN 3.1 OR YOU WILL BREAK EVERYTHING !!!
//
//  #if (WINVER <= 0x030A)
//  #pragma optimize("", off)
//  #endif
//
#endif

EXTERN_C BOOL FNGLOBAL mapWaveDriverCallback
(
    LPMAPSTREAM         pms,
    UINT                uMsg,
    DWORD_PTR           dw1,
    DWORD_PTR           dw2
)
{
    BOOL    f;

    //
    //  invoke the callback function, if it exists.  dwFlags contains
    //  wave driver specific flags in the LOWORD and generic driver
    //  flags in the HIWORD
    //
    if (0L == pms->dwCallback)
        return (FALSE);

    f = DriverCallback(pms->dwCallback,         // user's callback DWORD
                       HIWORD(pms->fdwOpen),    // callback flags
                       (HDRVR)pms->hwClient,    // handle to the wave device
                       uMsg,                    // the message
                       pms->dwInstance,         // user's instance data
                       dw1,                     // first DWORD
                       dw2);                    // second DWORD

    return (f);
} // mapWaveDriverCallback()

//
//  #ifndef WIN32
//  #if (WINVER <= 0x030A)
//  #pragma optimize("", on)
//  #endif
//  #endif
//


//--------------------------------------------------------------------------;
//
//  void mapWaveCallback
//
//  Description:
//
//
//  Arguments:
//      HWAVE hw:
//
//      UINT uMsg:
//
//      DWORD dwUser:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (void):
//
//  History:
//      08/02/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#pragma alloc_text(FIX_TEXT, mapWaveCallback)

//
//  NOTE! we turn off optimization for Win 3.1 builds to keep the compiler
//  from using extended registers (we compile with -G3). it is not safe
//  in Win 3.1 to use extended registers at DriverCallback time unless we
//  save them ourselves. i don't feel like writing the assembler code for
//  that when it buys us almost nothing..
//
//  everything is cool under Win 4.0 since DriverCallback is 386 aware.
//
#if (WINVER <= 0x030A)
#pragma optimize("", off)
#endif
#endif

EXTERN_C void FNCALLBACK mapWaveCallback
(
    HWAVE               hw,
    UINT                uMsg,
    DWORD_PTR           dwUser,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2
)
{
    LPWAVEHDR       pwh;
    LPMAPSTREAM     pms;

#if !defined(WIN32) && (WINVER <= 0x030A)
    _asm _emit 0x66  ; pushad
    _asm _emit 0x60
#endif

    //
    //  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING
    //
    //       THIS IS AT INTERRUPT TIME--DO NOT CALL ANY FUNCTIONS THAT
    //      YOU ARE NOT ABSOLUTELY SURE YOU CAN CALL AT INTERRUPT TIME!
    //
    //      out debugging 'DPF' stuff is NOT interrupt safe
    //
    //  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING
    //
    pms = (LPMAPSTREAM)dwUser;


    //
    //
    //
    switch (uMsg)
    {
        //
        //  eat the WIM_OPEN and WIM_CLOSE messages for 'mapped' input
        //  since we must deal with them specially (due to our background
        //  task).
        //
        case WIM_OPEN:
        case WIM_CLOSE:
	    if (NULL != pms->has)
		break;
            mapWaveDriverCallback(pms, uMsg, 0L, 0L);
            break;

	//
	//  eat the WOM_OPEN and WOM_CLOSE messages for 'mapped' output
	//  because we deal with them specially in mapWaveOpen and
	//  mapWaveClose.  See comments in those functions.
	//
	//  note that we're checking pms->had, not pms->has, cuz this message
	//  may come thru on the physical device open after we've decidec that
	//  we wish to map (using the acm driver represented by had) but
	//  before we've opened a stream (which would be represented by has).
	//
        case WOM_OPEN:
        case WOM_CLOSE:
	    if (NULL != pms->had)
		break;
	    mapWaveDriverCallback(pms, uMsg, 0L, 0L);
	    break;

        //
        //  dwParam1 is the 'shadow' LPWAVEHDR that is done.
        //
        case WOM_DONE:
            //
            //  get the shadow header
            //
            pwh = (LPWAVEHDR)dwParam1;

            //
            //  passthrough mode?
            //
            if (NULL != pms->has)
            {
                //
                //  get the client's header and set done bit
                //
                pwh = (LPWAVEHDR)pwh->dwUser;

                pwh->dwFlags |= WHDR_DONE;
                pwh->dwFlags &= ~WHDR_INQUEUE;
            }

            //
            //  nofify the client that the block is done
            //
            mapWaveDriverCallback(pms, WOM_DONE, (DWORD_PTR)pwh, 0);
            break;


        //
        //  dwParam1 is the 'shadow' LPWAVEHDR that is done.
        //
        case WIM_DATA:
            //DPF(2, "WIM_DATA: callback");
            if (NULL == pms->has)
            {
                //
                //  passthrough mode--notify the client that the block is
                //  done
                //
                mapWaveDriverCallback(pms, WIM_DATA, dwParam1, 0L);
                break;
            }

            //
            //  convert mode--convert data then callback user.
            //
            if (!PostAppMessage(pms->htaskInput, WIM_DATA, 0, dwParam1))
            {
                //
                //  !!! ERROR what can we do....?
                //
                //DPF(0, "!WIM_DATA: XXXXXXXXXXX ERROR Post message failed XXXXXX");
            } else {
#ifdef WIN32
                InterlockedIncrement((LPLONG)&pms->nOutstanding);
#endif // WIN32
            }
            break;

        default:
            mapWaveDriverCallback(pms, uMsg, dwParam1, dwParam2);
            break;

    }

#if !defined(WIN32) && (WINVER <= 0x030A)
    _asm _emit 0x66  ; popad
    _asm _emit 0x61
#endif

} // mapWaveCallback()

#if !defined(WIN32) && (WINVER <= 0x030A)
#pragma optimize("", on)
#endif


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT mapWaveGetPosition
//
//  Description:
//      Get the stream position in samples or bytes.
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPMMTIME pmmt: Pointer to an MMTIME structure.
//
//      UINT uSize: Size of the MMTIME structure.
//
//  Return (DWORD):
//
//  History:
//      07/19/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapWaveGetPosition
(
    LPMAPSTREAM         pms,
    LPMMTIME            pmmt,
    UINT                cbmmt
)
{
    MMRESULT    mmr;
    DWORD       dw;

    if (cbmmt < sizeof(MMTIME))
    {
        DPF(0, "!mapWaveGetPosition: bad size passed for MMTIME (%u)", cbmmt);
        return (MMSYSERR_ERROR);
    }

    if ((TIME_SAMPLES != pmmt->wType) && (TIME_BYTES != pmmt->wType))
    {
        DPF(1, "mapWaveGetPosition: time format %u?!? forcing TIME_BYTES!", pmmt->wType);
        pmmt->wType = TIME_BYTES;
    }


    //
    //  get the position in samples or bytes..
    //
    //  if an error occured .OR. we are passthrough mode (has is NULL)
    //  then just return result--otherwise we need to convert the real
    //  time to the client's time...
    //
    mmr = pms->fnWaveGetPosition(pms->hwReal, pmmt, cbmmt);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWaveGetPosition: physical get position failed? mmr=%u", mmr);
        return (mmr);
    }

    //
    //  in passthrough mode?
    //
    if (NULL == pms->has)
    {
        return (mmr);
    }

    //
    //  convert real time to client's time
    //
    switch (pmmt->wType)
    {
        case TIME_SAMPLES:
            dw = pmmt->u.sample;
            pmmt->u.sample = MulDivRN(dw,
                                      pms->pwfxClient->nSamplesPerSec,
                                      pms->pwfxReal->nSamplesPerSec);

            DPF(4, "GetPos(SAMPLES) real=%lu, client=%lu", dw, pmmt->u.sample);
            break;

        case TIME_BYTES:
            dw = pmmt->u.cb;
            pmmt->u.cb = MulDivRN(dw,
                                  pms->pwfxClient->nAvgBytesPerSec,
                                  pms->pwfxReal->nAvgBytesPerSec);
            DPF(4, "GetPos(BYTES) real=%lu, client=%lu", dw, pmmt->u.cb);
            break;

        default:
            DPF(0, "!mapWaveGetPosition() received unrecognized return format!");
            return (MMSYSERR_ERROR);
    }

    return (MMSYSERR_NOERROR);
} // mapWaveGetPosition()


//==========================================================================;
//
//  Notes on error code priorities	FrankYe	    09/28/94
//
//  The error code that is returned to the client and the error code
//  that is returned by internal functions are not always the same.  The
//  primary reason for this is the way we handle MMSYSERR_ALLOCATED and
//  WAVERR_BADFORMAT in multiple device situations.
//
//  For example, suppose we have two devices.  If one returns ALLOCATED and
//  the other returns BADFORMAT then we prefer to return ALLOCATED to the
//  client because BADFORMAT implies no devices understand the format.  So,
//  for the client, we prefer to return ALLOCATED over BADFORMAT.
//
//  On the other hand, we want the mapper to be able to take advantage of
//  situations where all the devices are allocated.  If all devices are
//  allocated then there is no need to continue trying to find a workable
//  map stream.  So, for internal use, we prefer BADFORMAT over ALLOCATED.
//  That way if we see ALLOCATED then we know _all_ devices are allocated
//  and we can abort trying to create a map stream.  (If the client sees
//  ALLOCATED, it only means that at least one device is allocated.)
//
//  Client return codes are usually stored in the mmrClient member of the
//  MAPSTREAM structure.  Internal return codes are returned via
//  function return values.
//
//  Below are functions that prioritize error codes and update error codes
//  given the last err, the current err, and the priorities of the errs.
//  Notice that the prioritization of the err codes for the client is very
//  similar to for internal use.  The only difference is the ordering of
//  MMSYSERR_ALLOCATED and WAVERR_BADFORMAT for reasons stated above.
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  UINT mapErrGetClientPriority
//
//  Description:
//
//  Arguments:
//      MMRESULT mmr :
//
//  Return (VOID):
//
//  History:
//	09/29/94    Frankye	Created
//
//--------------------------------------------------------------------------;
UINT FNLOCAL mapErrGetClientPriority( MMRESULT mmr )
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return 6;
    case MMSYSERR_ALLOCATED:
        return 5;
    case WAVERR_BADFORMAT:
        return 4;
    case WAVERR_SYNC:
        return 3;
    case MMSYSERR_NOMEM:
        return 2;
    default:
        return 1;
    case MMSYSERR_ERROR:
        return 0;
    }
}

//--------------------------------------------------------------------------;
//
//  VOID mapErrSetClientError
//
//  Description:
//
//  Arguments:
//      LPMMRESULT lpmmr :
//
//	MMRESULT mmr :
//
//  Return (VOID):
//
//  History:
//	09/29/94    Frankye	Created
//
//--------------------------------------------------------------------------;
VOID FNLOCAL mapErrSetClientError( LPMMRESULT lpmmr, MMRESULT mmr )
{
    if (mapErrGetClientPriority(mmr) > mapErrGetClientPriority(*lpmmr))
    {
        *lpmmr = mmr;
    }
}

//--------------------------------------------------------------------------;
//
//  UINT mapErrGetPriority
//
//  Description:
//
//  Arguments:
//      MMRESULT mmr :
//
//  Return (VOID):
//
//  History:
//	09/29/94    Frankye	Created
//
//--------------------------------------------------------------------------;
UINT FNLOCAL mapErrGetPriority( MMRESULT mmr )
{
    switch (mmr)
    {
    case MMSYSERR_NOERROR:
        return 6;
    case WAVERR_BADFORMAT:
        return 5;
    case MMSYSERR_ALLOCATED:
        return 4;
    case WAVERR_SYNC:
        return 3;
    case MMSYSERR_NOMEM:
        return 2;
    default:
        return 1;
    case MMSYSERR_ERROR:
        return 0;
    }
}

//--------------------------------------------------------------------------;
//
//  VOID mapErrSetError
//
//  Description:
//
//  Arguments:
//      LPMMRESULT lpmmr :
//
//	MMRESULT mmr :
//
//  Return (VOID):
//
//  History:
//	09/29/94    Frankye	Created
//
//--------------------------------------------------------------------------;
VOID FNLOCAL mapErrSetError( LPMMRESULT lpmmr, MMRESULT mmr )
{
    if (mapErrGetPriority(mmr) > mapErrGetPriority(*lpmmr))
    {
        *lpmmr = mmr;
    }
}


//--------------------------------------------------------------------------;
//
//  UINT mapDriverOpenWave
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPWAVEFORMATEX pwfx:
//
//  Return (UINT):
//
//
//--------------------------------------------------------------------------;

UINT FNLOCAL mapDriverOpenWave
(
    LPMAPSTREAM         pms,
    LPWAVEFORMATEX      pwfx
)
{
    MMRESULT        mmr;
    MMRESULT        mmrReturn;
    BOOL            fPrefOnly;
    BOOL            fQuery;
    UINT            uPrefDevId;
    UINT            uDevId;
    UINT            cNumDevs;
    BOOL            fTriedMappableId;
    BOOL            fFoundNonmappableId;


    fQuery = (0 != (WAVE_FORMAT_QUERY & pms->fdwOpen));

    //
    //  there are four different cases we need to handle when trying
    //  to open a compatible wave device (for either input or output):
    //
    //  1.  the normal case is 'no preference'--which means that
    //      the user has selected '[none]' in the combo box for
    //      the preferred wave device. in this case, gpag->uIdPreferredXXX
    //      will be -1 (and gpag->fPreferredOnly is ignored).
    //
    //  2.  the next two cases are when a device has been chosen as the
    //      'preferred device'--so gpag->uIdPreferredXXX will be the device
    //      id of this preferred device. so the two cases are then:
    //
    //      a.  if gpag->pSettings->fPreferredOnly is FALSE, then try the
    //          'preferred' device first, and if that fails, try all
    //          remaining devices.
    //
    //      b.  if gpag->pSettings->fPreferredOnly is TRUE, then we will
    //          ONLY try the preferred device--if that fails, we do NOT
    //          continue.
    //
    //	3.  a device ID to which the mapper should map may have been
    //	    specified using the WAVE_MAPPED flag.
    //

    //
    //
    //	--== See if we are supposed to map to a specified device ==--
    //
    //
    if (pms->fdwOpen & WAVE_MAPPED)
    {
        DWORD   fdwOpen;

        DPF(3, "mapDriverOpenWave: WAVE_MAPPED flag specified");

        //
        //  The device ID to which to map was specified by MMSYSTEM in the
        //  uMappedDeviceID member of the WAVEOPENDESC structure passed in
        //  the WODM_OPEN message.  It was saved in pms->uMappedDeviceID by
        //  mapWaveOpen().
        //
        uDevId = pms->uMappedDeviceID;
        fdwOpen = CALLBACK_FUNCTION | LOWORD(pms->fdwOpen);
        fdwOpen &= ~WAVE_MAPPED;

        mmrReturn = pms->fnWaveOpen(&pms->hwReal,
                                    uDevId,
                                    pwfx,
                                    (DWORD_PTR)mapWaveCallback,
                                    (DWORD_PTR)pms,
                                    fdwOpen);

        DPF(3, "--->opening device %d--mmr=%u", uDevId, mmrReturn);

        if (MMSYSERR_NOERROR == mmrReturn)
        {
            pms->uIdReal = uDevId;
        }

        mapErrSetClientError(&pms->mmrClient, mmrReturn);
        return (mmrReturn);
    }

    //
    //	--==	==--
    //

    //
    //	Init some local vars
    //

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    if (pms->fInput)
    {
        uPrefDevId = gpag->pSettings->uIdPreferredIn;
        cNumDevs   = gpag->cWaveInDevs;
    }
    else
    {
        uPrefDevId = gpag->pSettings->uIdPreferredOut;
        cNumDevs   = gpag->cWaveOutDevs;
    }

    fTriedMappableId = FALSE;
    fFoundNonmappableId = FALSE;

    fPrefOnly = (WAVE_MAPPER == uPrefDevId) ? FALSE : gpag->pSettings->fPreferredOnly;

    mmrReturn = MMSYSERR_ERROR;

    RELEASE_MUTEX(gpag->hMutexSettings);

    //
    //	--== If we have a prefered device Id, then try opening it ==--
    //
    if (WAVE_MAPPER != uPrefDevId)
    {
        mmr = MMSYSERR_NOERROR;
        if (!fQuery)
        {
            mmr = pms->fnWaveOpen(&pms->hwReal,
        	                      uPrefDevId,
        	                      pwfx,
        	                      0L,
        	                      0L,
        	                      WAVE_FORMAT_QUERY | LOWORD(pms->fdwOpen));
            DPF(4, "---> querying preferred device %d--mmr=%u", uPrefDevId, mmr);
            DPF(4, "---> opened with flags = %08lx", WAVE_FORMAT_QUERY | LOWORD(pms->fdwOpen));

        }

        if (MMSYSERR_NOERROR == mmr)
        {
            mmr = pms->fnWaveOpen(&pms->hwReal,
                                  uPrefDevId,
                                  pwfx,
                                  (DWORD_PTR)mapWaveCallback,
                                  (DWORD_PTR)pms,
                                  CALLBACK_FUNCTION | LOWORD(pms->fdwOpen));
        }

        DPF(3, "---> opening preferred device %d--mmr=%u", uPrefDevId, mmr);
        DPF(3, "---> opened with flags = %08lx", CALLBACK_FUNCTION | LOWORD(pms->fdwOpen));

        mapErrSetClientError(&pms->mmrClient, mmr);
        mapErrSetError(&mmrReturn, mmr);

        if ((WAVERR_SYNC == mmr) && (fPrefOnly || (1 == cNumDevs)))
        {
            WAIT_FOR_MUTEX(gpag->hMutexSettings);

            if (pms->fInput)
            {
                DPF(1, "--->preferred only INPUT device is SYNCRONOUS!");
                gpag->pSettings->fSyncOnlyIn  = TRUE;
            }
            else
            {
                DPF(1, "--->preferred only OUTPUT device is SYNCRONOUS!");
                gpag->pSettings->fSyncOnlyOut = TRUE;
            }

            RELEASE_MUTEX(gpag->hMutexSettings);

            return (mmrReturn);
        }

        if ((MMSYSERR_NOERROR == mmr) || fPrefOnly)
        {
            if (MMSYSERR_NOERROR == mmr)
            {
                pms->uIdReal = uPrefDevId;
            }

            return (mmrReturn);
        }

        fTriedMappableId = TRUE;
    }

    //
    //	The prefered ID didn't work.  Now we will step through each device
    //	ID and try to open it.  We'll skip the uPrefDevId since we already
    //	tried it above.  We will also skip device IDs that are not mappable
    //	devices (determined by sending DRV_QUERYMAPPABLE to the ID).
    //
    for (uDevId = 0; uDevId < cNumDevs; uDevId++)
    {

        if (uDevId == uPrefDevId)
            continue;

        mmr = pms->fnWaveMessage((HWAVE)LongToHandle(uDevId), DRV_QUERYMAPPABLE, 0L, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(3, "--->skipping non-mappable device %d", uDevId);
            fFoundNonmappableId = TRUE;
            continue;
        }

        if (!fQuery)
        {
            mmr = pms->fnWaveOpen(&pms->hwReal,
                                  uDevId,
                                  pwfx,
                                  0L,
                                  0L,
                                  WAVE_FORMAT_QUERY | LOWORD(pms->fdwOpen));
            DPF(4, "---> querying device %d--mmr=%u", uDevId, mmr);
        }

        if (MMSYSERR_NOERROR == mmr)
        {
            mmr = pms->fnWaveOpen(&pms->hwReal,
        	                      uDevId,
        	                      pwfx,
        	                      (DWORD_PTR)mapWaveCallback,
        	                      (DWORD_PTR)pms,
        	                      CALLBACK_FUNCTION | LOWORD(pms->fdwOpen));

            DPF(3, "---> opening device %d--mmr=%u", uDevId, mmr);
        }

        mapErrSetClientError(&pms->mmrClient, mmr);
        mapErrSetError( &mmrReturn, mmr );

        if (MMSYSERR_NOERROR == mmr)
        {
            pms->uIdReal = uDevId;
            return (mmrReturn);
        }

        fTriedMappableId = TRUE;

    }

    if (fFoundNonmappableId && !fTriedMappableId)
    {
        mapErrSetClientError(&pms->mmrClient, MMSYSERR_ALLOCATED);
        mapErrSetError(&mmrReturn, MMSYSERR_ALLOCATED);
    }

    return (mmrReturn);

} // mapDriverOpenWave()


//--------------------------------------------------------------------------;
//
//  BOOL FindBestPCMFormat
//
//  Description:
//
//
//  Arguments:
//      LPWAVEFORMATEX pwfx:
//
//      LPWAVEFORMATEX pwfPCM:
//
//      BOOL fInput:
//
//	UINT uDeviceId:
//
//
//  Return (BOOL):
//
//  History:
//	03/13/94    fdy	    [frankye]
//	    Expanded interface and function to take uDeviceId which specifies
//	    the wave device for which we want to FindBestPCMFormat.  fInput
//	    specifies whether this device is an input or output device.
//
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL FindBestPCMFormat
(
    LPWAVEFORMATEX      pwfx,
    LPWAVEFORMATEX      pwfxPCM,
    BOOL                fInput,
    UINT		uDeviceId
)
{
    BYTE            bChannels;
    BYTE            bBitsPerSample;
    UINT            uBlockAlign;
    UINT            i, j;
    UINT            w;
    UINT            uNeededBits;
    DWORD           dwPrevError;
    DWORD           dwError;
    DWORD           dwSamplesPerSec;
    UINT	    uFlags;

    //
    //  -= the PCM mis-mapper =-
    //
    //  i'm sure this will generate all sorts of neat bug reports and
    //  complaints, but this is the algorithm we use to choose a PCM
    //  format:
    //
    //  o   we regard stereo as very important to maintain. the reason
    //      for this is that if a file was authored as stereo, there
    //      was probably a good reason for doing so...
    //
    //  o   the next most important component is the sample frequency;
    //      we try to find the closest supported sample frequency
    //
    //  o   finally, we don't care about bits per sample
    //      so we'll try to maintain the input size and change it if
    //      we need to
    //
    dwSamplesPerSec = pwfx->nSamplesPerSec;
    bChannels       = (BYTE)pwfx->nChannels;


    //
    //  build a bit pattern that we can look for..
    //
findbest_Loop:

    uNeededBits = ZYZPCMF_OUT_M08 | ZYZPCMF_OUT_M16;
    if (bChannels == 2)
        uNeededBits <<= 1;

    if (fInput)
        uNeededBits <<= 8;

    dwPrevError = (DWORD)-1;

    //
    //  first find the closest sample rate that supports the current number
    //  of channels
    //
    for (j = (UINT)-1, i = 0; gaPCMFormats[i].uSamplesPerSec; i++)
    {
        //
        //  if no bits that we are looking for are set, then continue
        //  searching--if any of our bits are set, then check if this
        //  sample rate is better than our previous choice...
        //
	uFlags = fInput ? gaPCMFormats[i].uFlagsInput[uDeviceId] : gaPCMFormats[i].uFlagsOutput[uDeviceId];
        if (uFlags & uNeededBits)
        {
            if (dwSamplesPerSec > (DWORD)gaPCMFormats[i].uSamplesPerSec)
                dwError = dwSamplesPerSec - gaPCMFormats[i].uSamplesPerSec;
            else
                dwError = (DWORD)gaPCMFormats[i].uSamplesPerSec - dwSamplesPerSec;

            if (dwError < dwPrevError)
            {
                j = i;
                dwPrevError = dwError;
            }
        }
    }


    //
    //  if we didn't find a format that will work, then shift the channels
    //  around and try again...
    //
    if (j == (UINT)-1)
    {
        //
        //  if we already tried channel shifting, then we're hosed... this
        //  would probably mean that no wave devices are installed that
        //  can go in fInput... like if the person only has the PC
        //  Squeaker--you cannot record...
        //
        if ((BYTE)pwfx->nChannels != bChannels)
        {
            DPF(0, "!FindBestPCMFormat: failed to find suitable format!");
            return (FALSE);
        }

        //
        //  shift the channels and try again
        //
        bChannels = (bChannels == (BYTE)2) ? (BYTE)1 : (BYTE)2;
        goto findbest_Loop;
    }


    //
    //  j           = the index to the format that we should be using
    //  uNeededBits = the bits used to find 'j'
    //  fInput      = the direction we are trying to go with the data
    //  bChannels   = the number of channels that we need to use
    //
    uFlags = fInput ? gaPCMFormats[j].uFlagsInput[uDeviceId] : gaPCMFormats[j].uFlagsOutput[uDeviceId];
    w = uFlags & uNeededBits;

    //
    //  normalize our bits to Mono Output--relative bit positions are the
    //  same for input/output stereo/mono
    //
    if (fInput)
        w >>= 8;

    if (bChannels == 2)
        w >>= 1;

    //
    //  if both 8 and 16 bit are supported by the out device AND the source
    //  format is PCM, then use the one that matches the source format
    //
    if ((pwfx->wFormatTag == WAVE_FORMAT_PCM) && ((w & ZYZPCMF_OUT_MONO) == ZYZPCMF_OUT_MONO))
    {
        bBitsPerSample = (BYTE)pwfx->wBitsPerSample;
    }

    //
    //  either not PCM source or device does not support both 8 and 16 bit;
    //  so choose whatever is available for the destination
    //
    else
    {
        bBitsPerSample  = (w & ZYZPCMF_OUT_M16) ? (BYTE)16 : (BYTE)8;
    }

    dwSamplesPerSec = gaPCMFormats[j].uSamplesPerSec;
    uBlockAlign     = ((bBitsPerSample >> 3) << (bChannels >> 1));


    //
    //  finally fill in the PCM destination format structure with the PCM
    //  format we decided is 'best'
    //
    pwfxPCM->wFormatTag      = WAVE_FORMAT_PCM;
    pwfxPCM->nChannels       = bChannels;
    pwfxPCM->nBlockAlign     = (WORD)uBlockAlign;
    pwfxPCM->nSamplesPerSec  = dwSamplesPerSec;
    pwfxPCM->nAvgBytesPerSec = dwSamplesPerSec * uBlockAlign;
    pwfxPCM->wBitsPerSample  = bBitsPerSample;

    return (TRUE);
} // FindBestPCMFormat()



//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod0
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod0
(
    LPMAPSTREAM         pms
)
{
    MMRESULT        mmr;

    //
    //  suggest anything!
    //
    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           0L);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod0()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod1
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod1
(
    LPMAPSTREAM         pms
)
{
    MMRESULT    mmr;

    //
    //  suggest PCM format for the Client
    //
    pms->pwfxReal->wFormatTag = WAVE_FORMAT_PCM;

    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           ACM_FORMATSUGGESTF_WFORMATTAG);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod1()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod2
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod2
(
    LPMAPSTREAM         pms
)
{
    MMRESULT    mmr;

    //
    //  suggest MONO PCM format for the Client
    //
    pms->pwfxReal->wFormatTag = WAVE_FORMAT_PCM;
    pms->pwfxReal->nChannels  = 1;

    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           ACM_FORMATSUGGESTF_WFORMATTAG |
                           ACM_FORMATSUGGESTF_NCHANNELS);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod2()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod3
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod3
(
    LPMAPSTREAM         pms
)
{
    MMRESULT    mmr;

    //
    //  suggest 8 bit PCM format for the Client
    //
    pms->pwfxReal->wFormatTag     = WAVE_FORMAT_PCM;
    pms->pwfxReal->wBitsPerSample = 8;

    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           ACM_FORMATSUGGESTF_WFORMATTAG |
                           ACM_FORMATSUGGESTF_WBITSPERSAMPLE);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod3()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod4
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod4
(
    LPMAPSTREAM         pms
)
{
    MMRESULT    mmr;

    //
    //  suggest 8 bit MONO PCM format for the Client
    //
    pms->pwfxReal->wFormatTag     = WAVE_FORMAT_PCM;
    pms->pwfxReal->nChannels      = 1;
    pms->pwfxReal->wBitsPerSample = 8;

    mmr = acmFormatSuggest(pms->had,
                           pms->pwfxClient,
                           pms->pwfxReal,
                           pms->cbwfxReal,
                           ACM_FORMATSUGGESTF_WFORMATTAG |
                           ACM_FORMATSUGGESTF_NCHANNELS |
                           ACM_FORMATSUGGESTF_WBITSPERSAMPLE);

    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  can it open real time?
        //
        mmr = acmStreamOpen(NULL,
                            pms->had,
                            pms->pwfxSrc,
                            pms->pwfxDst,
                            NULL,
                            0L,
                            0L,
                            ACM_STREAMOPENF_QUERY);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (WAVERR_BADFORMAT);
        }

        mmr = mapDriverOpenWave(pms, pms->pwfxReal);
    }
    else
    {
        mmr = WAVERR_BADFORMAT;
    }

    return (mmr);
} // mapDriverFindMethod4()


//--------------------------------------------------------------------------;
//
//  MMRESULT mapDriverFindMethod5
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      08/04/93    cjp     [curtisp]
//	03/13/94    fdy	    [frankye]
//	    Modified function to first try to find the best pcm format for
//	    the prefered device, and if that fails, then try for each wave
//	    device that exists in the system.
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL mapDriverFindMethod5
(
    LPMAPSTREAM             pms
)
{
    MMRESULT            mmr;
    BOOL                f;
    UINT		uPrefDevId;
    UINT		cNumDevs;
    BOOL		fPrefOnly;
    UINT		i;

    //
    //
    //

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    if (pms->fInput)
    {
        uPrefDevId = gpag->pSettings->uIdPreferredIn;
        cNumDevs   = gpag->cWaveInDevs;
    }
    else
    {
        uPrefDevId = gpag->pSettings->uIdPreferredOut;
        cNumDevs   = gpag->cWaveOutDevs;
    }
    fPrefOnly = (WAVE_MAPPER == uPrefDevId) ? FALSE : gpag->pSettings->fPreferredOnly;

    //
    //
    //
    mmr = WAVERR_BADFORMAT;
    if ((-1) != uPrefDevId)
    {
	f = FindBestPCMFormat(pms->pwfxClient, pms->pwfxReal, pms->fInput, uPrefDevId);
	if (f)
	{
	    mmr = acmStreamOpen(NULL,
				pms->had,
				pms->pwfxSrc,
				pms->pwfxDst,
				NULL,
				0L,
				0L,
				ACM_STREAMOPENF_QUERY);
	    if (MMSYSERR_NOERROR == mmr)
	    {
		mmr = mapDriverOpenWave(pms, pms->pwfxReal);
	    }
	    else
	    {
		mmr = WAVERR_BADFORMAT;
	    }
	}
    }

    if ( (MMSYSERR_NOERROR != mmr) && (!fPrefOnly) )
    {
	for (i=0; i < cNumDevs; i++)
	{
	    if (i == uPrefDevId)
	    {
		//
		//  Already tried this one.
		//
		continue;
	    }
	
	    f = FindBestPCMFormat(pms->pwfxClient, pms->pwfxReal, pms->fInput, i);
	    if (f)
	    {
		mmr = acmStreamOpen(NULL,
				    pms->had,
				    pms->pwfxSrc,
				    pms->pwfxDst,
				    NULL,
				    0L,
				    0L,
				    ACM_STREAMOPENF_QUERY);
		if (MMSYSERR_NOERROR == mmr)
		{
		    mmr = mapDriverOpenWave(pms, pms->pwfxReal);
		}
		else
		{
		    mmr = WAVERR_BADFORMAT;
		}
	    }
	
	    if (MMSYSERR_NOERROR == mmr)
	    {
		break;
	    }
	}
    }

    RELEASE_MUTEX(gpag->hMutexSettings);

    return (mmr);
} // mapDriverFindMethod5()


//--------------------------------------------------------------------------;
//
//  BOOL mapDriverEnumCallback
//
//  Description:
//
//
//  Arguments:
//      HACMDRIVERID hadid:
//
//      DWORD_PTR dwInstance:
//
//      DWORD fdwSupport:
//
//  Return (BOOL):
//
//  History:
//      09/18/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNCALLBACK mapDriverEnumCallback
(
    HACMDRIVERID            hadid,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    LPMAPSTREAM         pms;
    MMRESULT            mmr;
    ACMFORMATTAGDETAILS aftd;


    pms = (LPMAPSTREAM)dwInstance;

    //
    //  check if support required
    //
    if (0 == (pms->fdwSupport & fdwSupport))
    {
        //
        //  skip to next driver..
        //
        return (TRUE);
    }

    aftd.cbStruct    = sizeof(aftd);
    aftd.dwFormatTag = pms->pwfxClient->wFormatTag;
    aftd.fdwSupport  = 0L;

    mmr = acmFormatTagDetails((HACMDRIVER)hadid,
                              &aftd,
                              ACM_FORMATTAGDETAILSF_FORMATTAG);
    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    if (0 == (pms->fdwSupport & aftd.fdwSupport))
    {
        return (TRUE);
    }

    mmr = acmDriverOpen(&pms->had, hadid, 0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    switch (pms->uHeuristic)
    {
        case 0:
            //
            //  try 'any' suggested destination
            //
            mmr = mapDriverFindMethod0(pms);
            break;

        case 1:
            //
            //  try 'any PCM' suggested destination
            //
            mmr = mapDriverFindMethod1(pms);
            break;

        case 2:
            //
            //  try 'any mono PCM' suggested destination
            //
            mmr = mapDriverFindMethod2(pms);
            break;

        case 3:
            //
            //  try 'any 8 bit PCM' suggested destination
            //
            mmr = mapDriverFindMethod3(pms);
            break;

        case 4:
            //
            //  try 'any mono 8 bit PCM' suggested destination
            //
            mmr = mapDriverFindMethod4(pms);
            break;

        case 5:
            //
            //  search for best PCM format available by wave hardware
            //
            mmr = mapDriverFindMethod5(pms);
            break;
    }

    pms->mmrClient = mmr;

    if (MMSYSERR_NOERROR == mmr)
    {
        return (FALSE);
    }

    acmDriverClose(pms->had, 0L);
    pms->had = NULL;

    return (TRUE);
} // mapDriverEnumCallback()


//--------------------------------------------------------------------------;
//
//  MMRESULT FindConverterMatch
//
//  Description:
//      Test all drivers to see if one can convert the requested format
//      into a format supported by an available wave device
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (MMRESULT):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL FindConverterMatch
(
    LPMAPSTREAM      pms
)
{
    MMRESULT        mmr;
    int             iHeuristic;
    DWORD           fdwSupport;


    //
    //  for the 'suggest PCM ' passes, allow what is needed
    //
    if (WAVE_FORMAT_PCM == pms->pwfxClient->wFormatTag)
    {
        fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CONVERTER;
    }
    else
    {
        fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    }


    //
    //
    //
    //
    //
    pms->mmrClient = WAVERR_BADFORMAT;

    pms->had  = NULL;
    for (iHeuristic = 0; iHeuristic < MAX_HEURISTIC; iHeuristic++)
    {
        pms->uHeuristic = iHeuristic;

        if (0 == iHeuristic)
        {
            //
            //  for the 'suggest anything' pass, allow converters and codecs
            //
            pms->fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CONVERTER |
                              ACMDRIVERDETAILS_SUPPORTF_CODEC;
        }
        else
        {
            //
            //  for the 'suggest PCM ' passes, allow what is needed
            //
            pms->fdwSupport = fdwSupport;
        }

        mmr = acmDriverEnum(mapDriverEnumCallback, (DWORD_PTR)pms, 0L);
        if (MMSYSERR_NOERROR == mmr)
        {
            if (NULL != pms->had)
            {
                return (MMSYSERR_NOERROR);
            }
        }
    }

    return (pms->mmrClient);
} // FindConverterMatch()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD mapWaveClose
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//  Return (DWORD):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWaveClose
(
    LPMAPSTREAM             pms
)
{
    MMRESULT            mmr;

    //
    //
    //
    mmr = pms->fnWaveClose(pms->hwReal);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWaveClose: physical device failed close! mmr=%u", mmr);
        return (mmr);
    }

    //
    //  if this is input and its background task is alive, kill it
    //
    if (pms->fInput && (0 != pms->htaskInput))
    {
#ifdef WIN32
        PostAppMessage(pms->htaskInput, WM_QUIT, 0, 0L);
        WaitForSingleObject(pms->hInput, INFINITE);
        CloseHandle(pms->hInput);
        CloseHandle(pms->hStoppedEvent);
#else
        if ((0 == gpag->cInputStreams) || (NULL == gpag->htaskInput))
        {
            DPF(0, "!input mapping htask=%.04Xh, reference count=%u?!?",
                gpag->htaskInput, gpag->cInputStreams);

            //
            //  should NEVER happen, but if it does make sure we don't blow
            //
            gpag->cInputStreams = 0;
            gpag->htaskInput    = NULL;

            pms->htaskInput     = NULL;
        }
        else
        {
#ifdef DEBUG
            if (pms->htaskInput != gpag->htaskInput)
            {
                DPF(0, "!pms->htaskInput=%.04Xh != gpag->htaskInput%.04Xh!",
                    pms->htaskInput, gpag->htaskInput);
            }
#endif

            gpag->cInputStreams--;

            if (0 != gpag->cInputStreams)
            {
                //
                //  yield to input mapping task--this will allow all
                //  unserviced messages to be processed. this could be made
                //  better and will have to be for win 32...
                //
                DPF(1, "YIELDING to background input mapping task=%.04Xh", gpag->htaskInput);
                if (IsTask(gpag->htaskInput))
                {
                    DirectedYield(gpag->htaskInput);
                }
                else
                {
                    DPF(0, "!gpag->taskInput=%.04Xh is dead!", gpag->htaskInput);

                    gpag->cInputStreams = 0;
                    gpag->htaskInput    = NULL;
                }
                DPF(1, "done YIELDING to background input mapping task=%.04Xh", gpag->htaskInput);
            }
            else
            {
                //
                //  destroy converter task and yield to it until all
                //  messages get pumped through...
                //
                DPF(1, "KILLING background input mapping task=%.04Xh", gpag->htaskInput);

                if (gpag->htaskInput != NULL) {
                    PostAppMessage(gpag->htaskInput, WM_QUIT, 0, 0L);
                    while (IsTask(gpag->htaskInput))
                    {
                        DirectedYield(gpag->htaskInput);
                    }
                }

                DPF(1, "done killing background input mapping task=%.04Xh", gpag->htaskInput);
                gpag->htaskInput = NULL;
            }

            pms->htaskInput = NULL;
        }
#endif // !WIN32
    }

    //
    //  done with stream (and driver)...
    //
    if (NULL != pms->has)
    {
        acmStreamClose(pms->has, 0L);
        acmDriverClose(pms->had, 0L);

        if (pms->fInput)
        {
            //
            //  this must be done _AFTER_ destroying our background input
            //  mapping task
            //
            mapWaveDriverCallback(pms, WIM_CLOSE, 0L, 0L);
        }
	else
	{
	    //
	    //	this must be done _AFTER_ the calls the ACM APIs since
	    //	some versions of the ACM will yield within its APIs.
	    //	Otherwise, for MCIWAVE, the signal to the MCIWAVE background
	    //	task would occur prematurely.
	    //
	    mapWaveDriverCallback(pms, WOM_CLOSE, 0L, 0L);
	}
    }

    //
    //  free the allocated memory for our mapping stream instance
    //
    GlobalFreePtr(pms);

    return (MMSYSERR_NOERROR);
} // mapWaveClose()


//--------------------------------------------------------------------------;
//
//  DWORD mapWaveOpen
//
//  Description:
//
//
//  Arguments:
//      BOOL fInput:
//
//      UINT uId:
//
//      DWORD dwUser:
//
//      LPWAVEOPENDESC pwod:
//
//      DWORD fdwOpen:
//
//  Return (DWORD):
//
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWaveOpen
(
    BOOL                    fInput,
    UINT                    uId,
    DWORD_PTR               dwUser,
    LPWAVEOPENDESC          pwod,
    DWORD                   fdwOpen
)
{
    MMRESULT            mmr;
    LPMAPSTREAM         pms;        // pointer to per-instance info struct
    LPMAPSTREAM         pmsT;       // temp stream pointer
    DWORD               cbms;
    LPWAVEFORMATEX      pwfx;       // pointer to passed format
    UINT                cbwfxSrc;
    DWORD               cbwfxDst;
    BOOL                fQuery;
    BOOL                fAsync;


    //
    //
    //
    fQuery = (0 != (WAVE_FORMAT_QUERY & fdwOpen));
    fAsync = (0 == (WAVE_ALLOWSYNC & fdwOpen));
    pwfx   = (LPWAVEFORMATEX)pwod->lpFormat;

    DPF(2, "mapWaveOpen(%s,%s,%s): Tag=%u, %lu Hz, %u Bit, %u Channel(s)",
            fInput ? (LPSTR)"in" : (LPSTR)"out",
            fQuery ? (LPSTR)"query" : (LPSTR)"real",
            fAsync ? (LPSTR)"async" : (LPSTR)"SYNC",
            pwfx->wFormatTag,
            pwfx->nSamplesPerSec,
            pwfx->wBitsPerSample,
            pwfx->nChannels);

    if (gpag->fPrestoSyncAsync)
    {
        fdwOpen |= WAVE_ALLOWSYNC;
        fAsync   = FALSE;
    }

    WAIT_FOR_MUTEX(gpag->hMutexSettings);

    if (fAsync)
    {
        if (fInput)
        {
            if (gpag->pSettings->fSyncOnlyIn)
            {
                DPF(1, "--->failing because input device is syncronous!");
                RELEASE_MUTEX(gpag->hMutexSettings);
                return (WAVERR_SYNC);
            }
        }
        else
        {
            if (gpag->pSettings->fSyncOnlyOut)
            {
                DPF(1, "--->failing because output device is syncronous!");
                RELEASE_MUTEX(gpag->hMutexSettings);
                return (WAVERR_SYNC);
            }
        }
    }

    RELEASE_MUTEX(gpag->hMutexSettings);


    //
    //  determine how big the complete wave format header is--this is the
    //  size of the extended waveformat structure plus the cbSize field.
    //  note that for PCM, this is only sizeof(PCMWAVEFORMAT)
    //
    if (WAVE_FORMAT_PCM == pwfx->wFormatTag)
    {
        cbwfxSrc = sizeof(PCMWAVEFORMAT);
    }
    else
    {
        //
        //  because MMSYSTEM does not (currently) validate for the extended
        //  format information, we validate this pointer--this will keep
        //  noelc and davidmay from crashing Windows with corrupt files.
        //
        cbwfxSrc = sizeof(WAVEFORMATEX) + pwfx->cbSize;
        if (IsBadReadPtr(pwfx, cbwfxSrc))
        {
            return (MMSYSERR_INVALPARAM);
        }
    }


    //
    //  allocate mapping stream instance structure
    //
    //  for Win 16, this structure must be _page locked in global space_
    //  so our low level interrupt time callbacks can munge the headers
    //  without exploding
    //
    //  size is the struct size + size of one known format + largest
    //  possible mapped destination format size.  We don't determine
    //	the size of the largest possible mapped destination format until
    //	we know we do in fact have to map this format.  When we make this
    //	determination, we will realloc this.
	//
    cbms = sizeof(*pms) + cbwfxSrc;
    pms  = (LPMAPSTREAM)GlobalAllocPtr(GMEM_FIXED|GMEM_SHARE|GMEM_ZEROINIT, cbms);
    if (NULL == pms)
    {
        DPF(0, "!mapWaveOpen(): could not alloc %lu bytes for map stream!", cbms);
        return (MMSYSERR_NOMEM);
    }


    //
    //  now fill it with info
    //
    pms->fInput      = fInput;
    pms->fdwOpen     = fdwOpen;
    pms->dwCallback  = pwod->dwCallback;
    pms->dwInstance  = pwod->dwInstance;
    pms->hwClient    = pwod->hWave;
    if (fdwOpen & WAVE_MAPPED)
    {
	    pms->uMappedDeviceID = pwod->uMappedDeviceID;
    }
    pms->pwfxClient  = (LPWAVEFORMATEX)(pms + 1);
    pms->pwfxReal    = NULL;	// filled in later if needed
    pms->cbwfxReal   = 0;	// filled in later if needed
    pms->uIdReal     = (UINT)-1;

    _fmemcpy(pms->pwfxClient, pwfx, cbwfxSrc);


    //
    //  set up our function jump table so we don't have to constantly
    //  check for input vs output--makes for smaller and faster code.
    //
    if (fInput)
    {
        pms->fnWaveOpen            = (MAPPEDWAVEOPEN)waveInOpen;
        pms->fnWaveClose           = (MAPPEDWAVECLOSE)waveInClose;
        pms->fnWavePrepareHeader   = (MAPPEDWAVEPREPAREHEADER)waveInPrepareHeader;
        pms->fnWaveUnprepareHeader = (MAPPEDWAVEUNPREPAREHEADER)waveInUnprepareHeader;
        pms->fnWaveWrite           = (MAPPEDWAVEWRITE)waveInAddBuffer;
        pms->fnWaveGetPosition     = (MAPPEDWAVEGETPOSITION)waveInGetPosition;
        pms->fnWaveMessage         = (MAPPEDWAVEMESSAGE)waveInMessage;
    }
    else
    {
        pms->fnWaveOpen            = (MAPPEDWAVEOPEN)waveOutOpen;
        pms->fnWaveClose           = (MAPPEDWAVECLOSE)waveOutClose;
        pms->fnWavePrepareHeader   = (MAPPEDWAVEPREPAREHEADER)waveOutPrepareHeader;
        pms->fnWaveUnprepareHeader = (MAPPEDWAVEUNPREPAREHEADER)waveOutUnprepareHeader;
        pms->fnWaveWrite           = (MAPPEDWAVEWRITE)waveOutWrite;
        pms->fnWaveGetPosition     = (MAPPEDWAVEGETPOSITION)waveOutGetPosition;
        pms->fnWaveMessage         = (MAPPEDWAVEMESSAGE)waveOutMessage;
    }


    //
    //  give mmsystem an instance dword that will be passed back to the
    //  mapper on all subsequent calls..
    //
    *((PDWORD_PTR)dwUser) = (DWORD_PTR)pms;


    //
    //  try to open another *real* wave device with this format
    //  if another device can deal with the format we will do
    //  nothing but act as a pass through
    //
    //  if someone could open the format, go into passthrough mode.
    //
    pms->mmrClient = MMSYSERR_ERROR;
    mmr = mapDriverOpenWave(pms, pwfx);
    if (MMSYSERR_NOERROR == mmr)
    {
#ifdef DEBUG
{
        if (DbgGetLevel() > 2)
        {
            if (fInput)
            {
                WAVEINCAPS      wic;

                waveInGetDevCaps(pms->uIdReal, &wic, sizeof(wic));
                wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

                DPF(3, "--->'" DEVFMT_STR "' native support succeeded.", (LPTSTR)wic.szPname);
            }
            else
            {
                WAVEOUTCAPS     woc;

                waveOutGetDevCaps(pms->uIdReal, &woc, sizeof(woc));
                woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

                DPF(3, "--->'" DEVFMT_STR "' native support succeeded.", (LPTSTR)woc.szPname);
            }
        }
}
#endif

        if (fQuery)
        {
            GlobalFreePtr(pms);
        }
        return (MMSYSERR_NOERROR);
    }

    //
    //	If this was a WAVE_FORMAT_DIRECT then don't bother
    //	trying to setup a conversion stream.  Note WAVE_FORMAT_DIRECT is
    //	new for Win95.
    //
    if (0 != (WAVE_FORMAT_DIRECT & pms->fdwOpen))
    {
	    mmr = pms->mmrClient;
	    GlobalFreePtr(pms);
	    return mmr;
    }

    //
    //	If all devices are allocated, don't go on to try to create
    //	a conversion stream.
    //
    if (MMSYSERR_ALLOCATED == mmr)
    {
        mmr = pms->mmrClient;
        GlobalFreePtr(pms);
        return mmr;
    }

    //
    //	There was at least one unallocated device that could not open
    //	the format.
    //
    //  determine size of largest possible mapped destination format and
    //	fill in all the necessary remaining pms information required
    //	for mapping.
    //

    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &cbwfxDst);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWaveOpen() FAILING BECAUSE MAX FORMAT SIZE UNKNOWN?");
		GlobalFreePtr(pms);
        return (MMSYSERR_ERROR);
    }

    cbms = sizeof(*pms) + cbwfxSrc + cbwfxDst;
    pmsT = pms;
    pms  = (LPMAPSTREAM)GlobalReAllocPtr(pmsT, cbms, GMEM_MOVEABLE|GMEM_ZEROINIT);
    if (NULL == pms)
    {
        DPF(0, "!mapWaveOpen(): could not realloc %lu bytes for map stream!", cbms);
		GlobalFreePtr(pmsT);
        return (MMSYSERR_NOMEM);
    }

    //
    //  now fill in remaining info necessary for mapping.
    //
    pms->pwfxClient  = (LPWAVEFORMATEX)(pms + 1);
    pms->pwfxReal    = (LPWAVEFORMATEX)((LPBYTE)(pms + 1) + cbwfxSrc);
    pms->cbwfxReal   = cbwfxDst;
    if (fInput)
    {
        pms->pwfxSrc = pms->pwfxReal;
        pms->pwfxDst = pms->pwfxClient;
    }
    else
    {
        pms->pwfxSrc = pms->pwfxClient;
        pms->pwfxDst = pms->pwfxReal;
    }


    //
    //  give mmsystem an instance dword that will be passed back to the
    //  mapper on all subsequent calls.  this was done earlier but pms
    //	may have changed since we've done a GlobalReAllocPtr.
    //
    *((PDWORD_PTR)dwUser) = (DWORD_PTR)pms;

    //
    //  no one could open the format
    //
    mmr = FindConverterMatch(pms);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(2, "--->failing open, unable to find supporting ACM driver!");

        //
        //  return the error we got when attempting to open a
        //  converter /  wave driver...
        //
        GlobalFreePtr(pms);
        return (mmr);
    }


    //
    //
    //
    DPF(2, "--->MAPPING TO: Tag=%u, %lu Hz, %u Bit, %u Channel(s)",
            pms->pwfxReal->wFormatTag,
            pms->pwfxReal->nSamplesPerSec,
            pms->pwfxReal->wBitsPerSample,
            pms->pwfxReal->nChannels);

    if (fQuery)
    {
        acmDriverClose(pms->had, 0L);
        GlobalFreePtr(pms);

        return (MMSYSERR_NOERROR);
    }


    //
    //
    //
    mmr = acmStreamOpen(&pms->has,
                        pms->had,
                        pms->pwfxSrc,
                        pms->pwfxDst,
                        NULL,
                        0L,
                        0L,
                        0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWaveOpen: opening stream failed! mmr=%u", mmr);

        pms->fnWaveClose(pms->hwReal);

        acmDriverClose(pms->had, 0L);
        GlobalFreePtr(pms);

        if (mmr < WAVERR_BASE)
        {
            return (mmr);
        }

        return (WAVERR_BADFORMAT);
    }

    //
    //
    //
    if (fInput)
    {
#ifndef WIN32
        if ((NULL == gpag->htaskInput) || !IsTask(gpag->htaskInput))
#endif
	{
#ifndef WIN32
	    if (0 != gpag->cInputStreams)
	    {
                DPF(0, "!cInputStreams=%u and should be zero! (gpag->htaskInput=%.04Xh)",
                    gpag->cInputStreams, gpag->htaskInput);

                gpag->cInputStreams = 0;
            }
#endif

#ifdef DEBUG
            gpag->fFaultAndDie = (BOOL)GetPrivateProfileInt(TEXT("msacm.drv"), TEXT("FaultAndDie"), 0, TEXT("system.ini"));
#endif

            //
            //  create the task to do the conversion in..
            //
#ifdef WIN32
            pms->nOutstanding = 0;
            if ((pms->hStoppedEvent = CreateEvent(NULL, FALSE, FALSE, NULL))
                == NULL ||
                (pms->hInput =
                   CreateThread(NULL,
                                300,
                                (LPTHREAD_START_ROUTINE)
                                   mapWaveInputConvertProc,
                                (LPVOID)pms->hStoppedEvent,
                                0,
                                (LPDWORD)&pms->htaskInput)) == NULL)
	    {
		if (pms->hStoppedEvent != NULL)
		{
		    CloseHandle(pms->hStoppedEvent);
                }
#else
	    gpag->htaskInput = NULL;
            if (mmTaskCreate((LPTASKCALLBACK)mapWaveInputConvertProc,
                             (HTASK FAR *)&gpag->htaskInput,
                             0L))
	    {
#endif
		DPF(0, "!mapWaveOpen: unable to create task for input mapping!");

		pms->fnWaveClose(pms->hwReal);

		acmStreamClose(pms->has, 0L);
		acmDriverClose(pms->had, 0L);

                GlobalFreePtr(pms);

                return (MMSYSERR_NOMEM);
	    }

            //
            //  make sure _at least one_ message is present in the background
            //  task's queue--this will keep DirectedYield from hanging
            //  in GetMessage if an app opens input with no callback and
            //  immediately closes the handle (like testing if the device
            //  is available--ACMAPP and WaveTst do this!).
            //
#ifndef WIN32
            PostAppMessage(gpag->htaskInput, WM_NULL, 0, 0L);
            DirectedYield(gpag->htaskInput);
#else
            //
            //  Make sure the thread has started - otherwise PostAppMessage
            //  won't work because the thread won't have a message queue.
            //

            WaitForSingleObject(pms->hStoppedEvent, INFINITE);
#endif // !WIN32
	}

	gpag->cInputStreams++;

#ifndef WIN32
	pms->htaskInput = gpag->htaskInput;
#endif


        //
        //  NOTE! we *MUST* send the WIM_OPEN callback _AFTER_ creating the
        //  input mapping task. our function callback (mapWaveCallback)
        //  simply eats the physical WIM_OPEN message. if this is not done
        //  this way, we get into a task lock with MCIWAVE's background
        //  task...
        //
        mapWaveDriverCallback(pms, WIM_OPEN, 0L, 0L);
    }
    else
    {
	//
	//  We send the WOM_OPEN callback here after opening the stream
	//  instead of in our function callback (mapWaveCallback).  Some
	//  versions of the acm cause a yield to occur within its APIs, and
	//  this would allow a signal to reach the MCIWAVE background task
	//  prematurely (it would get to the MCIWAVE background task before
	//  its state had changed from TASKIDLE to TASKBUSY).
	//
	mapWaveDriverCallback(pms, WOM_OPEN, 0L, 0L);
    }


    //
    //  made it! succeed the open
    //
    return (MMSYSERR_NOERROR);
} // mapWaveOpen()


//--------------------------------------------------------------------------;
//
//  DWORD mapWavePrepareHeader
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPWAVEHDR pwh:
//
//  Return (DWORD):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWavePrepareHeader
(
    LPMAPSTREAM             pms,
    LPWAVEHDR               pwh
)
{
    MMRESULT            mmr;
    LPWAVEHDR           pwhShadow;
    LPACMSTREAMHEADER   pash;
    DWORD               cbShadow;
    DWORD               dwLen;
    DWORD               fdwSize;

    //
    //  if we are in convert mode, allocate a 'shadow' wave header
    //  and buffer to hold the converted wave bits
    //
    //  we need to pagelock the callers header but *not* his buffer
    //  because we touch it in wXdWaveMapCallback (to set the DONE bit)
    //
    //  here is the state of the dwUser and reserved fields in
    //  both buffers.
    //
    //      client's header (sent to the wavemapper by the 'user')
    //
    //          reserved        points to the stream header used for
    //                          conversions with the ACM. the wavemapper
    //                          is the driver so we can use this.
    //          dwUser          for use by the 'user' (client)
    //
    //      shadow header (sent to the real device by the wavemapper)
    //
    //          reserved        for use by the real device
    //          dwUser          points to the client's header. (the
    //                          wavemapper is the user in this case)
    //
    //      acm stream header (created by us for conversion work)
    //
    //          dwUser          points to mapper stream instance (pms)
    //          dwSrcUser       points to shadow header
    //          dwDstUser       original source buffer size (prepared with)
    //
    if (NULL == pms->has)
    {
        //
        //  no conversion required just pass through
        //
        mmr = pms->fnWavePrepareHeader(pms->hwReal, pwh, sizeof(WAVEHDR));

        return (mmr);
    }


    //
    //
    //
    //
    dwLen = pwh->dwBufferLength;
    if (pms->fInput)
    {
        UINT        u;

#ifndef WIN32
        if (!IsTask(pms->htaskInput))
        {
            DPF(0, "mapWavePrepareHeader: background task died! pms->htaskInput=%.04Xh", pms->htaskInput);

            pms->htaskInput = NULL;
            return (MMSYSERR_NOMEM);
        }
#endif // !WIN32

        //
        //  block align the destination buffer if the caller didn't read
        //  our documentation...
        //
        u = pms->pwfxClient->nBlockAlign;
        dwLen = (dwLen / u) * u;

#ifdef DEBUG
        if (dwLen != pwh->dwBufferLength)
        {
            DPF(1, "mapWavePrepareHeader: caller passed _unaligned_ buffer for recording (%lu->%lu)!",
                    pwh->dwBufferLength, dwLen);
        }
#endif

        //
        //  determine size for shadow buffer (the buffer that we will give
        //  to the _real_ device). give a _block aligned_ destination buffer
        //
        fdwSize = ACM_STREAMSIZEF_DESTINATION;
    }
    else
    {
        //
        //  determine size for the shadow buffer (this will be the buffer
        //  that we convert to before writing the data to the underlying
        //  device).
        //
        fdwSize = ACM_STREAMSIZEF_SOURCE;
    }

    mmr = acmStreamSize(pms->has, dwLen, &dwLen, fdwSize);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!mapWavePrepareHeader: failed to get conversion size! mmr=%u", mmr);
        return (MMSYSERR_NOMEM);
    }



    //
    //
    //
    DPF(2, "mapWavePrepareHeader(%s): Client=%lu Bytes, Shadow=%lu Bytes",
            pms->fInput ? (LPSTR)"in" : (LPSTR)"out",
            pwh->dwBufferLength,
            dwLen);


    //
    //  allocate the shadow WAVEHDR
    //
    //  NOTE: add four bytes to guard against GP faulting with stos/lods
    //  code that accesses the last byte/word/dword in a segment--very
    //  easy to do...
    //
    cbShadow  = sizeof(WAVEHDR) + sizeof(ACMSTREAMHEADER) + dwLen + 4;
    pwhShadow = (LPWAVEHDR)GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, cbShadow);
    if (NULL == pwhShadow)
    {
        DPF(0, "!mapWavePrepareHeader(): could not alloc %lu bytes for shadow!", cbShadow);
        return (MMSYSERR_NOMEM);
    }

    //
    //
    //
    pash = (LPACMSTREAMHEADER)(pwhShadow + 1);

    pash->cbStruct  = sizeof(*pash);
    pash->fdwStatus = 0L;
    pash->dwUser    = (DWORD_PTR)pms;


    //
    //  fill in the shadow wave header, the dwUser field will point
    //  back to the original header, so we can get back to it
    //
    pwhShadow->lpData          = (LPBYTE)(pash + 1);
    pwhShadow->dwBufferLength  = dwLen;
    pwhShadow->dwBytesRecorded = 0;
    pwhShadow->dwUser          = (DWORD_PTR)pwh;


    //
    //  now prepare the shadow wavehdr
    //
    if (pms->fInput)
    {
        pwhShadow->dwFlags = 0L;
        pwhShadow->dwLoops = 0L;

        //
        //  input: our source is the shadow (we get data from the
        //  physical device and convert it into the clients buffer)
        //
        pash->pbSrc         = pwhShadow->lpData;
        pash->cbSrcLength   = pwhShadow->dwBufferLength;
        pash->dwSrcUser     = (DWORD_PTR)pwhShadow;
        pash->pbDst         = pwh->lpData;
        pash->cbDstLength   = pwh->dwBufferLength;
        pash->dwDstUser     = pwhShadow->dwBufferLength;
    }
    else
    {
        pwhShadow->dwFlags = pwh->dwFlags & (WHDR_BEGINLOOP|WHDR_ENDLOOP);
        pwhShadow->dwLoops = pwh->dwLoops;

        //
        //  output: our source is the client (we get data from the
        //  client and convert it into something for the physical
        //  device)
        //
        pash->pbSrc         = pwh->lpData;
        pash->cbSrcLength   = pwh->dwBufferLength;
        pash->dwSrcUser     = (DWORD_PTR)pwhShadow;
        pash->pbDst         = pwhShadow->lpData;
        pash->cbDstLength   = pwhShadow->dwBufferLength;
        pash->dwDstUser     = pwh->dwBufferLength;
    }

    mmr = pms->fnWavePrepareHeader(pms->hwReal, pwhShadow, sizeof(WAVEHDR));
    if (MMSYSERR_NOERROR == mmr)
    {
        mmr = acmStreamPrepareHeader(pms->has, pash, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            pms->fnWaveUnprepareHeader(pms->hwReal, pwhShadow, sizeof(WAVEHDR));
        }
    }

    //
    //
    //
    if (MMSYSERR_NOERROR != mmr)
    {
        GlobalFreePtr(pwhShadow);
        return (mmr);
    }


    //
    //  now pagelock the callers header, only the header!!!
    //
    //  globalpagelock will pagelock the complete object--and this could
    //  be bad if the caller allocated the header as the first part
    //  of a large memory block. also globalpagelock only works on the
    //  _first_ selector of the tile...
    //
    //  not necessary in win 32.
    //
#ifndef WIN32
    acmHugePageLock((LPBYTE)pwh, sizeof(*pwh));
#endif

    //
    //  the reserved field of the callers WAVEHDR will contain the
    //  shadow LPWAVEHDR
    //
    pwh->reserved = (DWORD_PTR)pash;
    pwh->dwFlags |= WHDR_PREPARED;

    return (MMSYSERR_NOERROR);
} // mapWavePrepareHeader()


//--------------------------------------------------------------------------;
//
//  DWORD mapWaveUnprepareHeader
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPWAVEHDR pwh:
//
//  Return (DWORD):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWaveUnprepareHeader
(
    LPMAPSTREAM         pms,
    LPWAVEHDR           pwh
)
{
    MMRESULT            mmr;
    LPWAVEHDR           pwhShadow;
    LPACMSTREAMHEADER   pash;
    DWORD               cbShadowData;

    //
    //  if we are not in convert mode, then passthrough to physical device
    //  otherwise, free the 'shadow' wave header and buffer, etc
    //
    if (NULL == pms->has)
    {
        //
        //  no conversion required just pass through
        //
        mmr = pms->fnWaveUnprepareHeader(pms->hwReal, pwh, sizeof(WAVEHDR));

        return (mmr);
    }

    //
    //
    //
    //
    //
    pash      = (LPACMSTREAMHEADER)pwh->reserved;
    pwhShadow = (LPWAVEHDR)pash->dwSrcUser;

    if (pms->fInput)
    {
        cbShadowData = (DWORD)pash->dwDstUser;

        pash->cbSrcLength = (DWORD)pash->dwDstUser;
////////pash->cbDstLength = xxx;        !!! don't touch this !!!
    }
    else
    {
        cbShadowData = pash->cbDstLength;

        pash->cbSrcLength = (DWORD)pash->dwDstUser;
////////pash->cbDstLength = xxx;        !!! don't touch this !!!
    }

    acmStreamUnprepareHeader(pms->has, pash, 0L);

    pwhShadow->dwBufferLength = cbShadowData;
    pms->fnWaveUnprepareHeader(pms->hwReal, pwhShadow, sizeof(WAVEHDR));


    //
    //  unprepare the shadow and caller's buffers (for the caller, this
    //  just means un-page lock the WAVEHDR)
    //
    //  we only page lock stuff in Win 16--not Win 32.
    //
#ifndef WIN32
    acmHugePageUnlock((LPBYTE)pwh, sizeof(*pwh));
#endif

    //
    //  free the shadow buffer--mark caller's wave header as unprepared
    //  and succeed the call
    //
    GlobalFreePtr(pwhShadow);

    pwh->reserved = 0L;
    pwh->dwFlags &= ~WHDR_PREPARED;

    return (MMSYSERR_NOERROR);
} // mapWaveUnprepareHeader()


//--------------------------------------------------------------------------;
//
//  DWORD mapWaveWriteBuffer
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      LPWAVEHDR pwh:
//
//  Return (DWORD):
//
//  History:
//      06/15/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL mapWaveWriteBuffer
(
    LPMAPSTREAM         pms,
    LPWAVEHDR           pwh
)
{
    MMRESULT            mmr;
    LPWAVEHDR           pwhShadow;
    LPACMSTREAMHEADER   pash;
    DWORD               cbShadowData;

    //
    //  no conversion required just pass through
    //
    if (NULL == pms->has)
    {
        mmr = pms->fnWaveWrite(pms->hwReal, pwh, sizeof(WAVEHDR));
        return (mmr);
    }

    //
    //
    //
    DPF(2, "mapWaveWriteBuffer(%s): Flags=%.08lXh, %lu Bytes, %lu Loops",
            pms->fInput ? (LPSTR)"in" : (LPSTR)"out",
            pwh->dwFlags,
            pwh->dwBufferLength,
            pwh->dwLoops);

    //
    //  get the conversion stream header...
    //
    pash = (LPACMSTREAMHEADER)pwh->reserved;
    if (NULL == pash)
    {
        DPF(0, "!mapWaveWriteBuffer: very strange--reserved field is 0???");
        return (WAVERR_UNPREPARED);
    }

    pwhShadow = (LPWAVEHDR)pash->dwSrcUser;

    if (pms->fInput)
    {
        UINT        u;

#ifndef WIN32
        if (!IsTask(pms->htaskInput))
        {
            DPF(0, "mapWaveWriteBuffer: background task died! pms->htaskInput=%.04Xh", pms->htaskInput);

            pms->htaskInput = NULL;
            return (MMSYSERR_NOMEM);
        }
#endif // !WIN32

        //
        //  again, we must block align the input buffer
        //
        //
        u = pms->pwfxClient->nBlockAlign;
        cbShadowData = (pwh->dwBufferLength / u) * u;

#ifdef DEBUG
        if (cbShadowData != pwh->dwBufferLength)
        {
            DPF(1, "mapWaveWriteBuffer: caller passed _unaligned_ buffer for recording (%lu->%lu)!",
                    pwh->dwBufferLength, cbShadowData);
        }
#endif

        //
        //  determine amount of data we need from the _real_ device. give a
        //  _block aligned_ destination buffer...
        //
        mmr = acmStreamSize(pms->has,
                            cbShadowData,
                            &cbShadowData,
                            ACM_STREAMSIZEF_DESTINATION);

        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(0, "!mapWaveWriteBuffer: failed to get conversion size! mmr=%u", mmr);
            return (MMSYSERR_NOMEM);
        }

        pwhShadow->dwBufferLength  = cbShadowData;
        pwhShadow->dwBytesRecorded = 0L;

        //
        //  clear the done bit of the caller's wave header (not done) and
        //  add the shadow buffer to the real (maybe) device's queue...
        //
        //  note that mmsystem _should_ be doing this for us, but alas
        //  it does not in win 3.1... i might fix this for chicago.
        //
        pwh->dwFlags &= ~WHDR_DONE;
    }
    else
    {
        //
        //  do the conversion
        //
        pash->cbDstLengthUsed = 0L;
        if (0L != pwh->dwBufferLength)
        {
            pash->pbSrc       = pwh->lpData;
            pash->cbSrcLength = pwh->dwBufferLength;
            pash->pbDst       = pwhShadow->lpData;
////////////pash->cbDstLength = xxx;        !!! leave as is !!!

            mmr = acmStreamConvert(pms->has, pash, 0L);
            if (MMSYSERR_NOERROR != mmr)
            {
                DPF(0, "!waveOutWrite: conversion failed! mmr=%.04Xh", mmr);
                pash->cbDstLengthUsed = 0L;
            }
        }

        if (0L == pash->cbDstLengthUsed)
        {
            DPF(1, "waveOutWrite: nothing converted--no data in output buffer.");
        }

        pwhShadow->dwFlags = pwh->dwFlags;
        pwhShadow->dwLoops = pwh->dwLoops;

        pwhShadow->dwBufferLength = pash->cbDstLengthUsed;
    }

    pwh->dwFlags |= WHDR_INQUEUE;
    mmr = pms->fnWaveWrite(pms->hwReal, pwhShadow, sizeof(WAVEHDR));
    if (MMSYSERR_NOERROR != mmr)
    {
        pwh->dwFlags &= ~WHDR_INQUEUE;
        DPF(0, "!pms->fnWaveWrite failed!, pms=%.08lXh, mmr=%u!", pms, mmr);
    }

    return (mmr);
} // mapWaveWriteBuffer()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      that the driver is opened, through the DrvOpen API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR           dwId,
    HDRVR               hdrvr,
    UINT                uMsg,
    LPARAM              lParam1,
    LPARAM              lParam2
)
{
    LRESULT         lr;
    LPDWORD         pdw;

    switch (uMsg)
    {
        case DRV_INSTALL:
            lr = mapDriverInstall(hdrvr);
            return (lr);

        case DRV_REMOVE:
            lr = mapDriverRemove(hdrvr);
            return (lr);

        case DRV_LOAD:
        case DRV_FREE:
            return (1L);

        case DRV_OPEN:
        case DRV_CLOSE:
            return (1L);

        case DRV_CONFIGURE:
        case DRV_QUERYCONFIGURE:
            return (0L);

        case DRV_ENABLE:
            lr = mapDriverEnable(hdrvr);
            return (lr);

        case DRV_DISABLE:
            lr = mapDriverDisable(hdrvr);
            return (lr);

#ifndef WIN32
        case DRV_EXITAPPLICATION:
            lr = acmApplicationExit(GetCurrentTask(), lParam1);
            return (lr);
#endif

        case DRV_MAPPER_PREFERRED_INPUT_GET:
            pdw  = (LPDWORD)lParam1;
            if (NULL != pdw)
            {
                WAIT_FOR_MUTEX(gpag->hMutexSettings);

                *pdw = MAKELONG(LOWORD(gpag->pSettings->uIdPreferredIn),
				LOWORD(gpag->pSettings->fPreferredOnly));

                RELEASE_MUTEX(gpag->hMutexSettings);

                return (MMSYSERR_NOERROR);
            }
            return (MMSYSERR_INVALPARAM);

        case DRV_MAPPER_PREFERRED_OUTPUT_GET:
            pdw  = (LPDWORD)lParam1;
            if (NULL != pdw)
            {
                WAIT_FOR_MUTEX(gpag->hMutexSettings);

                *pdw = MAKELONG(LOWORD(gpag->pSettings->uIdPreferredOut),
				LOWORD(gpag->pSettings->fPreferredOnly));

                RELEASE_MUTEX(gpag->hMutexSettings);

                return (MMSYSERR_NOERROR);
            }
            return (MMSYSERR_INVALPARAM);
    }

    if (uMsg >= DRV_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\profile.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1994-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  profile.h
//
//  Description:
//
//      This file contains definitions supporting the code in profile.c
//      which accesses the registry directly.
//
//==========================================================================;

#ifndef _PROFILE_H_
#define _PROFILE_H_

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifndef INLINE
    #define INLINE __inline
#endif


//
//  The Chicago Win16 header files are messed up somehow, so we have to
//  define this stuff ourselves.
//
#ifndef REG_DWORD
#pragma message("profile.h: Manually defining REG_DWORD!!!")
#define REG_DWORD  ( 4 )
#endif

#ifndef ERROR_SUCCESS
#pragma message("profile.h: Manually defining ERROR_SUCCESS!!!")
#define ERROR_SUCCESS  0L
#endif



//--------------------------------------------------------------------------;
//
//  Function Prototypes from profile.c
//  
//--------------------------------------------------------------------------;

HKEY FNGLOBAL IRegOpenKey
(
    LPCTSTR pszKeyName
);

BOOL FNGLOBAL IRegReadString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPTSTR              pszData,
    DWORD               cchData
);

DWORD FNGLOBAL IRegReadDwordDefault
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwDefault
);



//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteString
//  
//  Description:
//      This routine writes a value to an opened registry key.  If the key
//      is NULL, we return without doing anything.
//  
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPCTSTR pszValue:   Name of the value.
//      LPCTSTR pszData:    The data to write.
//
//  Return (BOOL): TRUE indicates success. FALSE otherwise.
//  
//--------------------------------------------------------------------------;

INLINE BOOL IRegWriteString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPCTSTR             pszData
)
{
    LONG lResult;
    
    lResult = RegSetValueEx( hkey, pszValue, 0L, REG_SZ, (LPBYTE)pszData,
			     sizeof(TCHAR) * (1+lstrlen(pszData)) );

    return (ERROR_SUCCESS == lResult);
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegWriteDword
//  
//  Description:
//      This routine writes a DWORD to the given value an open key.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPCTSTR  pszValue:
//      DWORD   dwData:
//  
//  Return (BOOL): TRUE if successfull.  FALSE otherwise
//  
//--------------------------------------------------------------------------;

INLINE BOOL IRegWriteDword
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwData
)
{
    LONG lResult;
    
    lResult = RegSetValueEx( hkey, pszValue, 0, REG_DWORD,
			     (LPBYTE)&dwData, sizeof(DWORD) );

    return (ERROR_SUCCESS == lResult);
}


//--------------------------------------------------------------------------;
//  
//  BOOL IRegValueExists
//  
//  Description:
//      This routine returns TRUE if the specified value exists in the
//      key; otherwise FALSE is returned.
//  
//  Arguments:
//      HKEY hkey:          An open registry key.
//      LPCTSTR pszValue:   Name of the value.
//
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

INLINE BOOL IRegValueExists
(
    HKEY                hkey,
    LPCTSTR             pszValue
)
{
    return ( ERROR_SUCCESS == RegQueryValueEx( hkey, (LPTSTR)pszValue,
                                               NULL, NULL, NULL, NULL ) );
}


//--------------------------------------------------------------------------;
//  
//  VOID IRegCloseKey
//  
//  Description:
//      Closes an open key (but only if it's non-NULL).
//  
//--------------------------------------------------------------------------;

INLINE VOID IRegCloseKey
(
    HKEY                hkey
)
{
    if( NULL != hkey )
    {
        RegCloseKey( hkey );
    }
}


#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\profile.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1994-1996 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  profile.c
//
//  Description:
//      This file contains routines to access the registry directly.  You
//      must include profile.h to use these routines. 
//
//      All keys are opened under the following key:
//
//          HKEY_CURRENT_USER\Software\Microsoft\Multimedia\Audio
//                                                  Compression Manager
//
//      Keys should be opened at boot time, and closed at shutdown.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "msacmmap.h"
#include "profile.h"

#include "debug.h"


#define ACM_PROFILE_ROOTKEY     HKEY_CURRENT_USER

const TCHAR gszAcmProfileKey[] =
        TEXT("Software\\Microsoft\\Multimedia");


//
//  Chicago Win16 does not appear to support RegCreateKeyEx, so we implement
//  it using this define.
//
#ifndef _WIN32

#define RegCreateKeyEx( hkey, lpszSubKey, a, b, c, d, e, phkResult, f ) \
        RegCreateKey( hkey, lpszSubKey, phkResult )

#endif



//--------------------------------------------------------------------------;
//  
//  HKEY IRegOpenKey
//  
//  Description:
//      This routine opens a sub key under the default ACM key.  We allow
//      all access to the key.
//  
//  Arguments:
//      LPCTSTR pszKeyName:  Name of the sub key.
//  
//  Return (HKEY):  Handle to the opened key, or NULL if the request failed.
//  
//--------------------------------------------------------------------------;

HKEY FNGLOBAL IRegOpenKey
(
    LPCTSTR             pszKeyName
)
{
    HKEY    hkeyAcm = NULL;
    HKEY    hkeyRet = NULL;


    RegCreateKeyEx( ACM_PROFILE_ROOTKEY, gszAcmProfileKey, 0, NULL, 0,
                       KEY_WRITE, NULL, &hkeyAcm, NULL );

    if( NULL != hkeyAcm )
    {
        RegCreateKeyEx( hkeyAcm, pszKeyName, 0, NULL, 0,
                    KEY_WRITE | KEY_READ, NULL, &hkeyRet, NULL );

        RegCloseKey( hkeyAcm );
    }

    return hkeyRet;
}


//--------------------------------------------------------------------------;
//  
//  BOOL IRegReadString
//  
//  Description:
//      This routine reads a value from an opened registry key.  The return
//      value indicates success or failure.  If the HKEY is NULL, we return
//      a failure.  Note that there is no default string...
//  
//  Arguments:
//      HKEY hkey:          An open registry key.  If NULL, we fail.
//      LPCTSTR pszValue:   Name of the value.
//      LPTSTR pszData:     Buffer to store the data in.
//      DWORD cchData:      Size (in chars) of the buffer.
//
//  Return (BOOL):  TRUE indicates success.  If the return is FALSE, you
//      can't count on the data in pszData - it might be something weird.
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL IRegReadString
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    LPTSTR              pszData,
    DWORD               cchData
)
{

    DWORD   dwType = (DWORD)~REG_SZ;  // Init to anything but REG_SZ.
    DWORD   cbData;
    LONG    lError;

    cbData = sizeof(TCHAR) * cchData;

    lError = RegQueryValueEx( hkey,
                              (LPTSTR)pszValue,
                              NULL,
                              &dwType,
                              (LPBYTE)pszData,
                              &cbData );

    return ( ERROR_SUCCESS == lError  &&  REG_SZ == dwType );
}


//--------------------------------------------------------------------------;
//  
//  DWORD IRegReadDwordDefault
//  
//  Description:
//      This routine reads a given value from the registry, and returns a
//      default value if the read is not successful.
//  
//  Arguments:
//      HKEY    hkey:               Registry key to read from.
//      LPCTSTR  pszValue:
//      DWORD   dwDefault:
//  
//  Return (DWORD):
//  
//--------------------------------------------------------------------------;

DWORD FNGLOBAL IRegReadDwordDefault
(
    HKEY                hkey,
    LPCTSTR             pszValue,
    DWORD               dwDefault
)
{
    DWORD   dwType = (DWORD)~REG_DWORD;  // Init to anything but REG_DWORD.
    DWORD   cbSize = sizeof(DWORD);
    DWORD   dwRet  = 0;
    LONG    lError;


    lError = RegQueryValueEx( hkey,
                              (LPTSTR)pszValue,
                              NULL,
                              &dwType,
                              (LPBYTE)&dwRet,
                              &cbSize );

    //
    //  Really we should have a test like this:
    //
    //      if( ERROR_SUCCESS != lError  ||  REG_DWORD != dwType )
    //
    //  But, the Chicago RegEdit will not let you enter REG_DWORD values,
    //  it will only let you enter REG_BINARY values, so that test is
    //  too strict.  Just test for no error instead.
    //
    if( ERROR_SUCCESS != lError )
        dwRet = dwDefault;

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\wavein.c ===
//==========================================================================;
//
//  wavein.c
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       9/18/93    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <memory.h>
#ifdef DEBUG
#include <stdlib.h>
#endif

#include "msacmmap.h"

#include "debug.h"


//--------------------------------------------------------------------------;
//
//  LRESULT mapWaveInputConvertProc
//
//  Description:
//      Window Proc for hidden window...
//
//      It should just recieve WIM_DATA messages from mapWaveDriverCallback
//
//      Real driver has filled the shadow buffer
//      Now convert it and call back the app/client.
//
//  Arguments:
//      DWORD dwInstance:
//
//  Return (LONG):
//
//  History:
//      11/15/92    gpd     [geoffd]
//      08/02/93    cjp     [curtisp] rewrote for new mapper
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNCALLBACK mapWaveInputConvertProc
(
    DWORD                   dwInstance
)
{
    MMRESULT            mmr;
    MSG                 msg;
    LPACMSTREAMHEADER   pash;
    LPWAVEHDR           pwh;
    LPWAVEHDR           pwhShadow;
    LPMAPSTREAM         pms;


#ifndef WIN32
    DPF(1, "mapWaveInputConvertProc: creating htask=%.04Xh, dwInstance=%.08lXh",
	    gpag->htaskInput, dwInstance);
#endif // !WIN32

    if (!SetMessageQueue(64))
    {
	DPF(0, "!mapWaveInputConvertProc: SetMessageQueue() failed!");
	return (0L);
    }

#ifdef WIN32
    //
    //  Make sure we have a message queue for this thread and signal the
    //  caller when we're ready to go
    //
    GetDesktopWindow();       // Makes sure we've got a message queue
    SetEvent(LongToHandle(dwInstance));
#endif
    //
    //
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
#ifdef DEBUG
	if (gpag->fFaultAndDie)
	{
	    if ((rand() & 0x7) == 0)
	    {
		gpag->fFaultAndDie = (BOOL)*((LPBYTE)0);

		DPF(1, "mapWaveInputConvertProc: fault was ignored...");

		gpag->fFaultAndDie = TRUE;
	    }
	}
#endif
	//
	//  if not a 'data' message, then translate and dispatch it...
	//
	if (msg.message != WIM_DATA)
	{
	    DPF(1, "mapWaveInputConvertProc: ignoring message [%.04Xh]", msg.message);

	    TranslateMessage(&msg);
	    DispatchMessage(&msg);

	    continue;
	}

	//
	//  lParam is the waveheader of the shadow buffer
	//
	pwhShadow = (LPWAVEHDR)msg.lParam;

	//
	//  client wave header is user data of shadow wave header
	//  the stream header for this client/shadow pair is in the client's
	//  'reserved' member
	//
	//  and finally, our stream header's dwUser member contains a
	//  reference to our mapping stream instance data.
	//
	pwh  = (LPWAVEHDR)pwhShadow->dwUser;
	pash = (LPACMSTREAMHEADER)pwh->reserved;
	pms  = (LPMAPSTREAM)pash->dwUser;

	DPF(4, "mapWaveInputConvertProc: WIM_DATA htask=%.04Xh, pms=%.08lXh, pwh=%.08lXh, pwhShadow=%.08lXh",
		pms->htaskInput, pms, pwh, pwhShadow);


	//
	//  do the conversion (if there is data in the input buffer)
	//
	pash->cbDstLengthUsed = 0L;
	if (0L != pwhShadow->dwBytesRecorded)
	{
	    pash->pbSrc       = pwhShadow->lpData;
	    pash->cbSrcLength = pwhShadow->dwBytesRecorded;
	    pash->pbDst       = pwh->lpData;
////////////pash->cbDstLength = pwh->dwBufferLength;

	    mmr = acmStreamConvert(pms->has, pash, ACM_STREAMCONVERTF_BLOCKALIGN);
	    if (MMSYSERR_NOERROR != mmr)
	    {
		DPF(0, "!mapWaveInputConvertProc: conversion failed! mmr=%.04Xh, pms=%.08lXh", mmr, pms);

		pash->cbDstLengthUsed = 0L;
	    }
	    else if (pash->cbSrcLength != pash->cbSrcLengthUsed)
	    {
		DPF(1, "mapWaveInputConvertProc: discarding %lu bytes of input! pms=%.08lXh",
			pash->cbSrcLength - pash->cbSrcLengthUsed, pms);
	    }
	}

	if (0L == pash->cbDstLengthUsed)
	{
	    DPF(1, "mapWaveInputConvertProc: nothing converted--no data in input buffer. pms=%.08lXh", pms);
	}

	//
	//  update the 'real' header and send the WIM_DATA callback
	//
	//
	pwh->dwBytesRecorded = pash->cbDstLengthUsed;
	pwh->dwFlags        |= WHDR_DONE;
	pwh->dwFlags        &= ~WHDR_INQUEUE;

	mapWaveDriverCallback(pms, WIM_DATA, (DWORD_PTR)pwh, 0L);
#ifdef WIN32
	if (InterlockedDecrement((PLONG)&pms->nOutstanding) == 0) {
	    SetEvent(pms->hStoppedEvent);
	}
#endif // WIN32
    }

#ifndef WIN32
    DPF(1, "mapWaveInputConvertProc: being KILLED htask=%.04Xh", gpag->htaskInput);
#endif // !WIN32

    return (0L);
} // mapWaveInputConvertProc()


//--------------------------------------------------------------------------;
//
//  DWORD widmMapperStatus
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      DWORD dwStatus:
//
//      LPDWORD pdw:
//
//  Return (DWORD):
//
//  History:
//      08/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL widmMapperStatus
(
    LPMAPSTREAM             pms,
    DWORD                   dwStatus,
    LPDWORD                 pdw
)
{
    MMRESULT            mmr;

//  V_WPOINTER(pdw, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if ((NULL == pms) || (NULL == pdw))
    {
	return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    switch (dwStatus)
    {
	case WAVEIN_MAPPER_STATUS_DEVICE:
	{
	    UINT        uId = (UINT)(-1);       // Invalid value

	    mmr = waveInGetID(pms->hwiReal, &uId);
	    if (MMSYSERR_NOERROR != mmr)
	    {
		return (mmr);
	    }

	    *pdw = uId;
	    return (MMSYSERR_NOERROR);
	}

	case WAVEIN_MAPPER_STATUS_MAPPED:
	    *pdw = (NULL != pms->has);
	    return (MMSYSERR_NOERROR);

	case WAVEIN_MAPPER_STATUS_FORMAT:
	    if (NULL != pms->has)
		_fmemcpy(pdw, pms->pwfxReal, sizeof(PCMWAVEFORMAT));
	    else
		_fmemcpy(pdw, pms->pwfxClient, sizeof(PCMWAVEFORMAT));

	    ((LPWAVEFORMATEX)pdw)->cbSize = 0;
	    return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // widmMapperStatus()


//--------------------------------------------------------------------------;
//
//  DWORD widMessage
//
//  Description:
//      This function conforms to the standard Wave Input driver message
//      procedure (widMessage), which is documented in mmddk.d.
//
//  Arguments:
//      UINT uId:
//
//      UINT uMsg:
//
//      DWORD dwUser:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (DWORD):
//
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C DWORD FNEXPORT widMessage
(
    UINT                uId,
    UINT                uMsg,
    DWORD_PTR           dwUser,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2
)
{
#ifndef WIN32 // Doesn't work for multithread
    static short    fSem = 0;
#endif // !WIN32
    LPMAPSTREAM     pms;        // pointer to per-instance info structure
    DWORD           dw;

    if (!gpag->fEnabled)
    {
	DPF(1, "widMessage: called while disabled!");
	return ((WIDM_GETNUMDEVS == uMsg) ? 0L : MMSYSERR_NOTENABLED);
    }

#ifndef WIN32
    //
    //  we call back into the mmsystem wave APIs so protect ourself
    //  from being re-entered!
    //
    if (fSem)
    {
	DPF(0, "!widMessage(uMsg=%u, dwUser=%.08lXh) being reentered! fSem=%d", uMsg, dwUser, fSem);
//      return (MMSYSERR_NOTSUPPORTED);
    }
#endif // !WIN32

    pms = (LPMAPSTREAM)dwUser;

    switch (uMsg)
    {
	case WIDM_GETNUMDEVS:
	    return (1L);

	case WIDM_GETDEVCAPS:
	    return mapWaveGetDevCaps(TRUE, (LPWAVEOUTCAPS)dwParam1, (UINT)dwParam2);

	case WIDM_OPEN:
#ifndef WIN32
	    fSem++;

	    DPF(1, "**** >> WIDM_OPEN(uMsg=%u, dwUser=%.08lXh, fSem=%d)", uMsg, dwUser, fSem);

#endif // !WIN32
	    //
	    //  dwParam1 contains a pointer to a WAVEOPENDESC
	    //  dwParam2 contains wave driver specific flags in the LOWORD
	    //  and generic driver flags in the HIWORD
	    //
	    dw = mapWaveOpen(TRUE, uId, dwUser, (LPWAVEOPENDESC)dwParam1, (DWORD)(PtrToLong((PVOID)dwParam2)) );

#ifndef WIN32
	    fSem--;

	    DPF(1, "**** << WIDM_OPEN(uMsg=%u, dwUser=%.08lXh, *dwUser=%.08lXh, fSem=%d)", uMsg, dwUser, *(LPDWORD)dwUser, fSem);
#endif // !WIN32
	    return (dw);

	case WIDM_CLOSE:
	    return (mapWaveClose(pms));

	case WIDM_PREPARE:
	    return (mapWavePrepareHeader(pms, (LPWAVEHDR)dwParam1));

	case WIDM_UNPREPARE:
	    return (mapWaveUnprepareHeader(pms, (LPWAVEHDR)dwParam1));

	case WIDM_ADDBUFFER:
	    return (mapWaveWriteBuffer(pms, (LPWAVEHDR)dwParam1));

	case WIDM_START:
	    DPF(4, "WIDM_START received...");
	    return waveInStart(pms->hwiReal);

	case WIDM_STOP:
	    DPF(4, "WIDM_STOP received..");
	    dw = waveInStop(pms->hwiReal);

#pragma message("----try to kill DirectedYield..")

	    //
	    //  yield enough to get all input messages processed
	    //
	    if (pms->htaskInput)
	    {
#ifdef WIN32
		ResetEvent(pms->hStoppedEvent);
		if (pms->nOutstanding != 0) {
		    WaitForSingleObject(pms->hStoppedEvent, INFINITE);
		}
#else
		if (IsTask(pms->htaskInput))
		{
		    DirectedYield(pms->htaskInput);
		}
		else
		{
		    DPF(0, "!WIDM_STOP: pms=%.08lXh, htask=%.04Xh is not valid!",
			pms, pms->htaskInput);
		    pms->htaskInput = NULL;
		}
#endif // !WIN32
	    }
	    return (dw);

	case WIDM_RESET:
	    DPF(4, "WIDM_RESET received...");
	    dw = waveInReset(pms->hwiReal);

	    //
	    //  yield enough to get all input messages processed
	    //
	    if (pms->htaskInput)
	    {
#ifdef WIN32
		ResetEvent(pms->hStoppedEvent);
		if (pms->nOutstanding != 0) {
		    WaitForSingleObject(pms->hStoppedEvent, INFINITE);
		}
#else
		if (IsTask(pms->htaskInput))
		{
		    DirectedYield(pms->htaskInput);
		}
		else
		{
		    DPF(0, "!WIDM_RESET: pms=%.08lXh, htask=%.04Xh is not valid!",
			pms, pms->htaskInput);
		    pms->htaskInput = NULL;
		}
#endif // !WIN32
	    }
	    return (dw);

	case WIDM_GETPOS:
	    return mapWaveGetPosition(pms, (LPMMTIME)dwParam1, (UINT)dwParam2);

	case WIDM_MAPPER_STATUS:
	    dw = widmMapperStatus(pms, (DWORD)(PtrToLong((PVOID)dwParam1)), (LPDWORD)dwParam2);
	    return (dw);

#if (WINVER >= 0x0400)
	case DRVM_MAPPER_RECONFIGURE:
	    mapDriverDisable(NULL);
	    mapDriverEnable(NULL);
	    return (0);
#endif
    }

    if (!pms || !pms->hwiReal)
	return (MMSYSERR_NOTSUPPORTED);

    return waveInMessage(pms->hwiReal, uMsg, dwParam1, dwParam2);
} // widMessage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msadpcm\codec.c ===
//==========================================================================;
//
//  codec.c
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//  Description:
//
//
//  History:
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <ctype.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"
#include "msadpcm.h"

#include "debug.h"


#define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))


const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_ADPCM
};

#define CODEC_MAX_FORMAT_TAGS   SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define CODEC_MAX_FILTER_TAGS   0


//
//  array of sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#define CODEC_MAX_SAMPLE_RATES  SIZEOF_ARRAY(gauFormatIndexToSampleRate)


//
//  array of bits per sample supported
//
//
const UINT gauFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define CODEC_MAX_BITSPERSAMPLE_PCM     SIZEOF_ARRAY(gauFormatIndexToBitsPerSample)
#define CODEC_MAX_BITSPERSAMPLE_ADPCM   1


#define CODEC_MAX_CHANNELS      MSADPCM_MAX_CHANNELS


//
//  number of formats we enumerate per channels is number of sample rates
//  times number of channels times number of
//  (bits per sample) types.
//
#define CODEC_MAX_FORMATS_PCM   (CODEC_MAX_SAMPLE_RATES *   \
                                 CODEC_MAX_CHANNELS *       \
                                 CODEC_MAX_BITSPERSAMPLE_PCM)

#define CODEC_MAX_FORMATS_ADPCM (CODEC_MAX_SAMPLE_RATES *   \
                                 CODEC_MAX_CHANNELS *       \
                                 CODEC_MAX_BITSPERSAMPLE_ADPCM)


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that our PCM converter can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//  History:
//      11/21/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX  pwfx
)
{
    UINT    uBlockAlign;

    if (!pwfx)
        return (FALSE);

    if (pwfx->wFormatTag != WAVE_FORMAT_PCM)
        return (FALSE);

    if ((pwfx->wBitsPerSample != 8) && (pwfx->wBitsPerSample != 16))
        return (FALSE);

    if ((pwfx->nChannels < 1) || (pwfx->nChannels > MSADPCM_MAX_CHANNELS))
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    uBlockAlign = PCM_BLOCKALIGNMENT(pwfx);
    if (uBlockAlign != (UINT)pwfx->nBlockAlign)
        return (FALSE);

    //
    //  finally, verify that avg bytes per second is correct
    //
    if ((pwfx->nSamplesPerSec * uBlockAlign) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  WORD adpcmBlockAlign
//
//  Description:
//      This function computes the standard block alignment that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid MS-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels
//          nSamplesPerSec
//
//  Arguments:
//      LPWAVEFORMATEX pwfx:
//
//  Return (WORD):
//      The return value is the block alignment that should be placed in
//      the pwfx->nBlockAlign field.
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

WORD FNLOCAL adpcmBlockAlign
(
    LPWAVEFORMATEX      pwfx
)
{
    UINT        uBlockAlign;
    UINT        uChannelShift;

    //
    //
    //
    uChannelShift  = pwfx->nChannels >> 1;
    uBlockAlign    = 256 << uChannelShift;

    //
    //  choose a block alignment that makes sense for the sample rate
    //  that the original PCM data is. basically, this needs to be
    //  some reasonable number to allow efficient streaming, etc.
    //
    //  don't let block alignment get too small...
    //
    if (pwfx->nSamplesPerSec > 11025)
    {
        uBlockAlign *= (UINT)(pwfx->nSamplesPerSec / 11000);
    }

    return (WORD)(uBlockAlign);
} // adpcmBlockAlign()



//--------------------------------------------------------------------------;
//
//  WORD adpcmSamplesPerBlock
//
//  Description:
//      This function computes the Samples Per Block that should be used
//      given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid MS-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels       = must be 1 or 2!
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx:
//
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

WORD FNLOCAL adpcmSamplesPerBlock
(
    LPWAVEFORMATEX      pwfx
)
{
    UINT        uSamplesPerBlock;
    UINT        uChannelShift;
    UINT        uHeaderBytes;
    UINT        uBitsPerSample;

    //
    //
    //
    uChannelShift  = pwfx->nChannels >> 1;
    uHeaderBytes   = 7 << uChannelShift;
    uBitsPerSample = MSADPCM_BITS_PER_SAMPLE << uChannelShift;

    //
    //
    //
    uSamplesPerBlock  = (pwfx->nBlockAlign - uHeaderBytes) * 8;
    uSamplesPerBlock /= uBitsPerSample;
    uSamplesPerBlock += 2;

    return (WORD)(uSamplesPerBlock);
} // adpcmSamplesPerBlock()


//--------------------------------------------------------------------------;
//
//  UINT adpcmAvgBytesPerSec
//
//  Description:
//      This function computes the Average Bytes Per Second that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid MS-ADPCM format
//      and that the following fields in the format structure are valid:
//
//          nChannels       = must be 1 or 2!
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx:
//
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL adpcmAvgBytesPerSec
(
    LPWAVEFORMATEX      pwfx
)
{
    DWORD       dwAvgBytesPerSec;
    UINT	uSamplesPerBlock;

    //
    //
    //
    uSamplesPerBlock	= adpcmSamplesPerBlock(pwfx);


    //
    //  compute bytes per second including header bytes
    //
    dwAvgBytesPerSec	= (pwfx->nSamplesPerSec * pwfx->nBlockAlign) /
			    uSamplesPerBlock;
    return (dwAvgBytesPerSec);
} // adpcmAvgBytesPerSec()



//--------------------------------------------------------------------------;
//
//  BOOL adpcmIsValidFormat
//
//  Description:
//
//
//  Arguments:
//
//
//  Return (BOOL FNLOCAL):
//
//
//  History:
//       1/26/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL adpcmIsValidFormat
(
    LPWAVEFORMATEX  pwfx
)
{
	LPADPCMWAVEFORMAT   pwfADPCM = (LPADPCMWAVEFORMAT)pwfx;

	if (!pwfx)
        return (FALSE);

    if (pwfx->wFormatTag != WAVE_FORMAT_ADPCM)
        return (FALSE);

    //
    //  check wBitsPerSample
    //
    if (pwfx->wBitsPerSample != MSADPCM_BITS_PER_SAMPLE)
        return (FALSE);

    //
    //  check channels
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > MSADPCM_MAX_CHANNELS))
        return (FALSE);

    //
    //  verify that there is at least enough space specified in cbSize
    //  for the extra info for the ADPCM header...
    //
    if (pwfx->cbSize < MSADPCM_WFX_EXTRA_BYTES)
        return (FALSE);

	//
    //  Verifying nBlockAlign and wSamplesPerBlock are consistent.
    //
    if ( (pwfADPCM->wSamplesPerBlock != adpcmSamplesPerBlock(pwfx)) )
        return FALSE;



    return (TRUE);
} // adpcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL adpcmIsMagicFormat
//
//  Description:
//
//
//  Arguments:
//
//
//  Return (BOOL FNLOCAL):
//
//
//  History:
//       1/27/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL adpcmIsMagicFormat
(
    LPADPCMWAVEFORMAT   pwfADPCM
)
{
    UINT        u;

    //
    //  verify that there is at least enough space specified in cbSize
    //  for the extra info for the ADPCM header...
    //
    if (pwfADPCM->wfx.cbSize < MSADPCM_WFX_EXTRA_BYTES)
        return (FALSE);

    //
    //  check coef's to see if it is Microsoft's standard ADPCM
    //
    if (pwfADPCM->wNumCoef != MSADPCM_MAX_COEFFICIENTS)
        return (FALSE);

    for (u = 0; u < MSADPCM_MAX_COEFFICIENTS; u++)
    {
        if (pwfADPCM->aCoef[u].iCoef1 != gaiCoef1[u])
            return (FALSE);

        if (pwfADPCM->aCoef[u].iCoef2 != gaiCoef2[u])
            return (FALSE);
    }

    return (TRUE);
} // adpcmIsMagicFormat()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL adpcmCopyCoefficients
//
//  Description:
//
//
//  Arguments:
//      LPADPCMWAVEFORMAT pwfadpcm:
//
//  Return (BOOL):
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL adpcmCopyCoefficients
(
    LPADPCMWAVEFORMAT   pwfadpcm
)
{
    UINT        u;

    pwfadpcm->wNumCoef = MSADPCM_MAX_COEFFICIENTS;

    for (u = 0; u < MSADPCM_MAX_COEFFICIENTS; u++)
    {
        pwfadpcm->aCoef[u].iCoef1 = (short)gaiCoef1[u];
        pwfadpcm->aCoef[u].iCoef2 = (short)gaiCoef2[u];
    }

    return (TRUE);
} // adpcmCopyCoefficients()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PCODECINST  pci;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pci = (PCODECINST)LocalAlloc(LPTR, sizeof(*pci));
    if (NULL == pci)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pci->hdrvr          = hdrvr;
    pci->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pci->DriverProc   = NULL;
        pci->fccType      = paod->fccType;
        pci->vdwACM       = paod->dwVersion;
        pci->dwFlags      = paod->dwFlags;

        paod->dwError     = MMSYSERR_NOERROR;
    }


    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)pci);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the codec. The
//      codec receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen).
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the codec instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the codec never fail to
//      close.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PCODECINST      pci
)
{
    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (pci != NULL)
    {
        //
        //  close down the conversion instance. this codec simply needs
        //  to free the instance data structure...
        //
        LocalFree((HLOCAL)pci);
    }

    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'hardware configuration' support of the
//      codec. That is, a dialog should be displayed to configure ports,
//      IRQ's, memory mappings, etc if it needs to.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      HWND hwnd: Handle to parent window to use when displaying hardware
//      configuration dialog box. A codec is _required_ to display a modal
//      dialog box using this hwnd argument as the parent. This argument
//      may be (HWND)-1 which tells the codec that it is only being
//      queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the codec should invent its own
//      storage location.
//
//  Return (LRESULT):
//      A non-zero return values specifies that either configuration is
//      supported or that the dialog was successfully displayed and
//      dismissed. A zero return indicates either configuration is not
//      supported or some other failure.
//
//  History:
//       1/25/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PCODECINST      pci,
    HWND            hwnd,
    LPDRVCONFIGINFO pdci
)
{
    //
    //  first check to see if we are only being queried for hardware
    //  configuration support. if hwnd == (HWND)-1 then we are being
    //  queried and should return zero for 'not supported' and non-zero
    //  for 'supported'.
    //
    if (hwnd == (HWND)-1)
    {
        //
        //  this codec does not support hardware configuration so return
        //  zero...
        //
        return (0L);
    }

    //
    //  we are being asked to bring up our hardware configuration dialog.
    //  if this codec can bring up a dialog box, then after the dialog
    //  is dismissed we return non-zero. if we are not able to display a
    //  dialog, then return zero.
    //
    return (0L);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The codec
//      is responsible for filling in the ACMDRIVERDETAILS structure with
//      various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your codec is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the codec with acmConverterOpen.
//
//          o   check for the proper uMid and uPid using acmConverterInfo
//
//          o   send the 'user defined' message with acmConverterMessage
//              to retrieve additional information, etc.
//
//          o   close the codec with acmConverterClose.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to fill in
//      for caller. This structure may be larger or smaller than the
//      current definition of ACMDRIVERDETAILS--cbStruct specifies the valid
//      size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. A non-zero
//      return signifies an error which is either an MMSYSERR_* or an
//      ACMERR_*.
//
//      Note that this function should never fail. There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The codec does not need to check for these
//      conditions.
//
//  History:
//       1/23/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PCODECINST          pci,
    LPACMDRIVERDETAILS  padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;

    //
    //  for the current implementation of an ACM codec, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC ('audc')
    //  and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;

    //
    //  the manufacturer id (uMid) and product id (uPid) must be filled
    //  in with your company's _registered_ id's. for more information
    //  on these id's and how to get them registered contact Microsoft
    //  and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Systems Group
    //      Product Marketing
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Phone: 800-227-4679 x11771
    //
    //  note that during the development phase or your codec, you may
    //  use the reserved value of '0' for both uMid and uPid.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_MSADPCM;

    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM must contain the version of the *ACM* that the codec was
    //  designed for.
    //
    //  vdwDriver is the version of the driver.
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_CODEC;

    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the converter/codec/filter supports. these are placed in the
    //  fdwSupport field of the ACMDRIVERDETAILS structure. note that a converter
    //  can support one or more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the converter supports
    //  conversions from one format tag to another format tag. for example,
    //  if a converter compresses WAVE_FORMAT_PCM to WAVE_FORMAT_ADPCM, then
    //  this bit should be set.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the converter
    //  supports conversions on the same format tag. as an example, the PCM
    //  converter that is built into the ACM sets this bit (and only this
    //  bit) because it converts only PCM formats (bits, sample rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the converter supports
    //  'in place' transformations on a single format tag without changing
    //  the size of the resulting data. for example, a converter that changed
    //  the 'volume' of PCM data would set this bit. note that this is a
    //  _destructive_ action--but it saves memory, etc.
    //
    //  this converter only supports compression and decompression.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;


    //
    //  Return the number of format tags this converter supports
    //  (In the case of PCM only this is 1)
    //
    add.cFormatTags     = CODEC_MAX_FORMAT_TAGS;

    //
    //  Return the number of filter tags this converter supports
    //  (In the case of a codec (only) it is 0)
    //
    add.cFilterTags     = CODEC_MAX_FILTER_TAGS;



    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  this codec has no custom icon
        //
        add.hicon = NULL;

        LoadStringCodec(pci->hinst, IDS_CODEC_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pci->hinst, IDS_CODEC_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pci->hinst, IDS_CODEC_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pci->hinst, IDS_CODEC_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pci->hinst, IDS_CODEC_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }

    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);

    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      A codec has the option of displaying its own 'about box' or letting
//      the ACM display one for it.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      HWND hwnd: Handle to parent window to use when displaying custom
//      about box. If a codec displays its own dialog, it is _required_
//      to display a modal dialog box using this hwnd argument as the
//      parent.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM should display
//      a generic about box using the information contained in the codec
//      capabilities structure.
//
//      If the codec chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//  History:
//       1/24/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PCODECINST      pci,
    HWND            hwnd
)
{
    //
    //  this codec does not need any special dialog, so tell the ACM to
    //  display one for us. note that this is the _recommended_ method
    //  for consistency and simplicity of codecs. why write code when
    //  you don't have to?
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM (wave mapper) or
//      an application to quickly get a destination format that this codec
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible.
//
//      Another way to think about this message is: what format would this
//      codec like to convert the source format to?
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to ACMDRVFORMATSUGGEST structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PCODECINST              pci,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    LPWAVEFORMATEX  pwfxSrc;
    LPWAVEFORMATEX  pwfxDst;
    LPADPCMWAVEFORMAT   pwfadpcm;
    LPPCMWAVEFORMAT     pwfpcm;

    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;

    //
    //
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            //
            //  verify source format is acceptable for this driver
            //
            if (!pcmIsValidFormat(pwfxSrc))
                break;


            //
            // Verify that you are not asking for a particular dest format
            //  that is not ADPCM.
            //
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG) &&
                (pwfxDst->wFormatTag != WAVE_FORMAT_ADPCM) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            // Verify that if other restrictions are given, they
            // match to the source.  (Since we do not convert
            // the nChannels or nSamplesPerSec
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_NCHANNELS) &&
                (pwfxSrc->nChannels != pwfxDst->nChannels) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_NSAMPLESPERSEC) &&
                (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            // Verify that if we are asking for a specific number of bits
            // per sample, that it is the correct #
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_WBITSPERSAMPLE) &&
                (pwfxDst->wBitsPerSample != 4) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            //
            //  suggest an ADPCM format that has most of the same details
            //  as the source PCM format
            //
            pwfxDst->wFormatTag      = WAVE_FORMAT_ADPCM;
            pwfxDst->nSamplesPerSec  = pwfxSrc->nSamplesPerSec;
            pwfxDst->nChannels       = pwfxSrc->nChannels;
            pwfxDst->wBitsPerSample  = MSADPCM_BITS_PER_SAMPLE;

            pwfxDst->nBlockAlign     = adpcmBlockAlign(pwfxDst);
            pwfxDst->nAvgBytesPerSec = adpcmAvgBytesPerSec(pwfxDst);
            pwfxDst->cbSize          = MSADPCM_WFX_EXTRA_BYTES;

            pwfadpcm = (LPADPCMWAVEFORMAT)pwfxDst;
            pwfadpcm->wSamplesPerBlock = adpcmSamplesPerBlock(pwfxDst);

            adpcmCopyCoefficients(pwfadpcm);
            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_ADPCM:
            //
            //  verify source format is acceptable for this driver
            //
            if (!adpcmIsValidFormat(pwfxSrc) ||
                !adpcmIsMagicFormat((LPADPCMWAVEFORMAT)pwfxSrc))
                break;

            //
            // Verify that you are not asking for a particular dest format
            //  that is not PCM.
            //
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG) &&
                (pwfxDst->wFormatTag != WAVE_FORMAT_PCM) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            // Verify that if other restrictions are given, they
            // match to the source.  (Since we do not convert
            // the nChannels or nSamplesPerSec
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_NCHANNELS) &&
                (pwfxSrc->nChannels != pwfxDst->nChannels) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }
            if( (padfs->fdwSuggest & ACM_FORMATSUGGESTF_NSAMPLESPERSEC) &&
                (pwfxSrc->nSamplesPerSec != pwfxDst->nSamplesPerSec) ) {
                    return (ACMERR_NOTPOSSIBLE);
            }

            //
            //  suggest a PCM format that has most of the same details
            //  as the source ADPCM format
            //
            pwfxDst->wFormatTag      = WAVE_FORMAT_PCM;
            pwfxDst->nSamplesPerSec  = pwfxSrc->nSamplesPerSec;
            pwfxDst->nChannels       = pwfxSrc->nChannels;

            // Verify that if we are asking for a specific number of bits
            // per sample, that it is the correct #
            if( padfs->fdwSuggest & ACM_FORMATSUGGESTF_WBITSPERSAMPLE ) {
                if( (pwfxDst->wBitsPerSample != 8) &&
                    (pwfxDst->wBitsPerSample != 16) ) {
                    return (ACMERR_NOTPOSSIBLE);
                }
            } else {
                // Default to 16 bit decode
                pwfxDst->wBitsPerSample  = 16;
            }

            pwfpcm = (LPPCMWAVEFORMAT)pwfxDst;

            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                       pwfxDst->nBlockAlign;
            return (MMSYSERR_NOERROR);
    }

    //
    //  can't suggest anything because either the source format is foreign
    //  or the destination format has restrictions that this converter
    //  cannot deal with.
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdFormatSuggest()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//
//
//  Arguments:
//      PCODECINST pci:
//
//      LPACMFORMATTAGDETAILS padft:
//
//      DWORD fdwDetails:
//
//  Return (LRESULT):
//
//  History:
//      08/01/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PCODECINST              pci,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (CODEC_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_ADPCM:
                    uFormatTag = WAVE_FORMAT_ADPCM;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_ADPCM:
                    uFormatTag = WAVE_FORMAT_ADPCM;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this converter does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = CODEC_MAX_FORMATS_PCM;


            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0] = '\0';
            break;

        case WAVE_FORMAT_ADPCM:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_ADPCM;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      MSADPCM_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = CODEC_MAX_FORMATS_ADPCM;

            LoadStringCodec(pci->hinst, IDS_CODEC_NAME, padft->szFormatTag, SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//
//
//  Arguments:
//      PCODECINST pci:
//
//      LPACMFORMATDETAILS padf:
//
//      DWORD fdwDetails:
//
//  Return (LRESULT):
//
//  History:
//      06/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PCODECINST              pci,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    LPADPCMWAVEFORMAT   pwfadpcm;
    UINT                uFormatIndex;
    UINT                u;

    pwfx = padf->pwfx;

    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  enumerate by index
            //
            //  for this converter, this is more code than necessary... just
            //  verify that the format tag is something we know about
            //
            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (CODEC_MAX_FORMATS_PCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  put some stuff in more accessible variables--note
                    //  that we bring variable sizes down to a reasonable
                    //  size for 16 bit code...
                    //
                    uFormatIndex = (UINT)padf->dwFormatIndex;
                    pwfx         = padf->pwfx;

                    //
                    //  now fill in the format structure
                    //
                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

                    u = uFormatIndex / (CODEC_MAX_BITSPERSAMPLE_PCM * CODEC_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % CODEC_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;

                    u = (uFormatIndex / CODEC_MAX_CHANNELS) % CODEC_MAX_CHANNELS;
                    pwfx->wBitsPerSample  = (WORD)gauFormatIndexToBitsPerSample[u];

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;
                    break;


                case WAVE_FORMAT_ADPCM:
                    if (CODEC_MAX_FORMATS_ADPCM <= padf->dwFormatIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    //
                    //  put some stuff in more accessible variables--note that we
                    //  bring variable sizes down to a reasonable size for 16 bit
                    //  code...
                    //
                    uFormatIndex = (UINT)padf->dwFormatIndex;
                    pwfx         = padf->pwfx;
                    pwfadpcm     = (LPADPCMWAVEFORMAT)pwfx;

                    //
                    //
                    //
                    pwfx->wFormatTag      = WAVE_FORMAT_ADPCM;

                    u = uFormatIndex / (CODEC_MAX_BITSPERSAMPLE_ADPCM * CODEC_MAX_CHANNELS);
                    pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

                    u = uFormatIndex % CODEC_MAX_CHANNELS;
                    pwfx->nChannels       = u + 1;
                    pwfx->wBitsPerSample  = MSADPCM_BITS_PER_SAMPLE;

                    pwfx->nBlockAlign     = adpcmBlockAlign(pwfx);
                    pwfx->nAvgBytesPerSec = adpcmAvgBytesPerSec(pwfx);
                    pwfx->cbSize          = MSADPCM_WFX_EXTRA_BYTES;

                    pwfadpcm->wSamplesPerBlock = adpcmSamplesPerBlock(pwfx);

                    adpcmCopyCoefficients(pwfadpcm);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        case ACM_FORMATDETAILSF_FORMAT:
            //
            //  must want to verify that the format passed in is supported
            //  and return a string description...
            //
            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                case WAVE_FORMAT_ADPCM:
                    if (!adpcmIsValidFormat(pwfx) ||
                        !adpcmIsMagicFormat((LPADPCMWAVEFORMAT)pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc)
    //
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    padf->szFormat[0] = '\0';
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamQuery
//
//  Description:
//      This is an internal helper used by the ACMDM_STREM_OPEN
//      and ACMDM_STREAM_SIZE messages.
//      The purpose of this function is to tell the caller if the proposed
//      conversion can be handled by this codec.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPWAVEFORMATEX pwfxSrc:
//
//      LPWAVEFORMATEX pwfxDst:
//
//      LPWAVEFILTER   pwfltr:
//
//      DWORD fdwOpen:
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//      A return value of ACMERR_NOTPOSSIBLE must be returned if the conversion
//      cannot be performed by this codec.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamQuery
(
    PCODECINST      pci,
    LPWAVEFORMATEX  pwfxSrc,
    LPWAVEFORMATEX  pwfxDst,
    LPWAVEFILTER    pwfltr,
    DWORD           fdwOpen
)
{
    LPADPCMWAVEFORMAT   pwfADPCM;
    LPPCMWAVEFORMAT     pwfPCM;

    //
    //  check to see if this
    //  codec can convert from the source to the destination.
    //
    //  first check if source is ADPCM so destination must be PCM..
    //
    if (adpcmIsValidFormat(pwfxSrc))
    {
        if (!pcmIsValidFormat(pwfxDst))
            return (ACMERR_NOTPOSSIBLE);

        //
        //  converting from ADPCM to PCM...
        //
        pwfADPCM = (LPADPCMWAVEFORMAT)pwfxSrc;
        pwfPCM   = (LPPCMWAVEFORMAT)pwfxDst;

        if (pwfADPCM->wfx.nChannels != pwfPCM->wf.nChannels)
            return (ACMERR_NOTPOSSIBLE);

        if (pwfADPCM->wfx.nSamplesPerSec != pwfPCM->wf.nSamplesPerSec)
            return (ACMERR_NOTPOSSIBLE);

        if (!adpcmIsMagicFormat(pwfADPCM))
            return (ACMERR_NOTPOSSIBLE);

        return (MMSYSERR_NOERROR);
    }

    //
    //  now try source as PCM so destination must be ADPCM..
    //
    else if (pcmIsValidFormat(pwfxSrc))
    {
        if (!adpcmIsValidFormat(pwfxDst))
            return (ACMERR_NOTPOSSIBLE);

        //
        //  converting from PCM to ADPCM...
        //
        pwfPCM   = (LPPCMWAVEFORMAT)pwfxSrc;
        pwfADPCM = (LPADPCMWAVEFORMAT)pwfxDst;

        if (pwfADPCM->wfx.nChannels != pwfPCM->wf.nChannels)
            return (ACMERR_NOTPOSSIBLE);

        if (pwfADPCM->wfx.nSamplesPerSec != pwfPCM->wf.nSamplesPerSec)
            return (ACMERR_NOTPOSSIBLE);

        if (!adpcmIsMagicFormat(pwfADPCM))
            return (ACMERR_NOTPOSSIBLE);

        return (MMSYSERR_NOERROR);
    }

    //
    //  we are unable to perform the conversion we are being queried for
    //  so return ACMERR_NOTPOSSIBLE to signify this...
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdStreamQuery()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmOpenConversion. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRVINSTANCE padi: Pointer to instance data for the conversion
//      stream. This structure was allocated by the ACM and filled with
//      the most common instance data needed for conversions.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    //
    //  the most important condition to check before doing anything else
    //  is that this codec can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this codec.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a codec that is suitable for the conversion. also note that
    //  the ACM may call this codec several times with slightly different
    //  format specifications before giving up.
    //
    //  this codec first verifies that the src and dst formats are
    //  acceptable...
    //
    if (acmdStreamQuery(pci,
                         pwfxSrc,
                         pwfxDst,
                         padsi->pwfltr,
                         padsi->fdwOpen))
    {
        //
        //  either the source or destination format is illegal for this
        //  codec--or the conversion between the formats can not be
        //  performed by this codec.
        //
        return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  we have decided that this codec can handle the conversion stream.
    //  so we want to do _as much work as possible_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this codec is very simple, so we only figure out what conversion
    //  function that should be used for converting from the src format
    //  to the dst format and place this in the dwDrvInstance member
    //  of the ACMDRVINSTANCE structure. we then only need to 'call'
    //  this function during the ACMDM_STREAM_CONVERT message.
    //
    if (pwfxSrc->wFormatTag == WAVE_FORMAT_ADPCM)
    {
#ifdef WIN32
        switch (pwfxDst->nChannels)
        {
            case 1:
                if (8 == pwfxDst->wBitsPerSample)
                    padsi->dwDriver = (DWORD_PTR)adpcmDecode4Bit_M08;
                else
                    padsi->dwDriver = (DWORD_PTR)adpcmDecode4Bit_M16;
                break;

            case 2:
                if (8 == pwfxDst->wBitsPerSample)
                    padsi->dwDriver = (DWORD_PTR)adpcmDecode4Bit_S08;
                else
                    padsi->dwDriver = (DWORD_PTR)adpcmDecode4Bit_S16;
                break;

            default:
                return ACMERR_NOTPOSSIBLE;
        }
#else
        padsi->dwDriver = (DWORD_PTR)DecodeADPCM_4Bit_386;
#endif
        return (MMSYSERR_NOERROR);
    }
    else if (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM)
    {
        //
        //  Check to see if we will be doing this conversion in realtime.
        //  (The default is yes)
        //
        if (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME)
        {
            switch (pwfxSrc->nChannels)
            {
                case 1:
                    if (8 == pwfxSrc->wBitsPerSample)
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_M08_FullPass;
                    else
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_M16_FullPass;
                    break;

                case 2:
                    if (8 == pwfxSrc->wBitsPerSample)
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_S08_FullPass;
                    else
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_S16_FullPass;
                    break;

                default:
                    return ACMERR_NOTPOSSIBLE;
            }
        }
        else
        {
#ifdef WIN32
            switch (pwfxSrc->nChannels)
            {
                case 1:
                    if (8 == pwfxSrc->wBitsPerSample)
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_M08_OnePass;
                    else
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_M16_OnePass;
                    break;

                case 2:
                    if (8 == pwfxSrc->wBitsPerSample)
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_S08_OnePass;
                    else
                        padsi->dwDriver = (DWORD_PTR)adpcmEncode4Bit_S16_OnePass;
                    break;

                default:
                    return ACMERR_NOTPOSSIBLE;
            }
#else
            padsi->dwDriver = (DWORD_PTR)EncodeADPCM_4Bit_386;
#endif
        }

        return (MMSYSERR_NOERROR);
    }

    //
    //  fail--we cannot perform the conversion
    //
    return (ACMERR_NOTPOSSIBLE);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmCloseConversion). The codec should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRVINSTANCE padi: Pointer to instance data for the conversion
//      stream.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//      NOTE! It is _strongly_ recommended that a codec not fail to close
//      a conversion stream.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    //
    //  the codec should clean up all resources that were allocated for
    //  the stream instance.
    //
    //  this codec did not allocate any resources, so we succeed immediately
    //
    return (MMSYSERR_NOERROR);
} // acmdStreamClose()




//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      PCODECINST pci: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    LPADPCMWAVEFORMAT       pwfadpcm;
    DWORD                   cb;
    DWORD                   cBlocks;
    DWORD                   cbBytesPerBlock;


    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;


    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            cb = padss->cbSrcLength;

            if (WAVE_FORMAT_ADPCM == pwfxSrc->wFormatTag)
            {
                //
                //  how many destination PCM bytes are needed to hold
                //  the decoded ADPCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                cBlocks = cb / pwfxSrc->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfadpcm = (LPADPCMWAVEFORMAT)pwfxSrc;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxDst->nBlockAlign;

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                if (0 == (cb % pwfxSrc->nBlockAlign))
                {
                    cb = cBlocks * cbBytesPerBlock;
                }
                else
                {
                    cb = (cBlocks + 1) * cbBytesPerBlock;
                }
            }
            else
            {
                //
                //  how many destination ADPCM bytes are needed to hold
                //  the encoded PCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                pwfadpcm = (LPADPCMWAVEFORMAT)pwfxDst;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxSrc->nBlockAlign;

                cBlocks = cb / cbBytesPerBlock;

                if (0 == (cb % cbBytesPerBlock))
                {
                    cb = cBlocks * pwfxDst->nBlockAlign;
                }
                else
                {
                    cb = (cBlocks + 1) * pwfxDst->nBlockAlign;
                }

                if (0L == cb)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }

            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            cb = padss->cbDstLength;

            if (WAVE_FORMAT_ADPCM == pwfxDst->wFormatTag)
            {
                //
                //  how many source PCM bytes can be encoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                cBlocks = cb / pwfxDst->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfadpcm = (LPADPCMWAVEFORMAT)pwfxDst;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxSrc->nBlockAlign;

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * cbBytesPerBlock;
            }
            else
            {
                //
                //  how many source ADPCM bytes can be decoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                pwfadpcm = (LPADPCMWAVEFORMAT)pwfxSrc;

                cbBytesPerBlock = pwfadpcm->wSamplesPerBlock * pwfxDst->nBlockAlign;

                cBlocks = cb / cbBytesPerBlock;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * pwfxSrc->nBlockAlign;
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamConvert
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing a codec--to convert data. This message is
//      sent after a stream has been opened (the codec receives and succeeds
//      the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      PCODECINST pci: Pointer to private codec instance structure.
//
//      LPACMDRVSTREAMHEADER pdsh: Pointer to a conversion stream instance
//      structure.
//
//      DWORD fdwConvert: Misc. flags for how conversion should be done.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero ACMERR_*
//      or MMSYSERR_* if the function fails.
//
//  History:
//      11/28/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamConvert
(
    PCODECINST              pci,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    CONVERTPROC_C       fpConvertC;
#ifndef WIN32
    CONVERTPROC_ASM     fpConvertAsm;
    BOOL                fRealTime;
#endif
    BOOL                fBlockAlign;
    BOOL                fDecode;
    LPWAVEFORMATEX      pwfpcm;
    LPADPCMWAVEFORMAT   pwfadpcm;
    DWORD               dw;

    fBlockAlign = (0 != (ACM_STREAMCONVERTF_BLOCKALIGN & padsh->fdwConvert));
    fDecode     = ( WAVE_FORMAT_PCM == padsi->pwfxDst->wFormatTag );

    if( !fDecode )
    {
        //
        //  encode
        //
        pwfpcm   = padsi->pwfxSrc;
        pwfadpcm = (LPADPCMWAVEFORMAT)padsi->pwfxDst;

        dw = PCM_BYTESTOSAMPLES(pwfpcm, padsh->cbSrcLength);

        if (fBlockAlign)
        {
            dw = (dw / pwfadpcm->wSamplesPerBlock) * pwfadpcm->wSamplesPerBlock;
        }

        //
        //  Look for an easy exit.  We can only handle an even number of
        //  samples.
        //
        if( dw < 2 )
        {
            padsh->cbDstLengthUsed = 0;

            if( fBlockAlign )
                padsh->cbSrcLengthUsed = 0;
            else
                padsh->cbSrcLengthUsed = padsh->cbSrcLength;

            return MMSYSERR_NOERROR;
        }

        //
        //  Make sure we have an even number of samples.
        //
        dw &= ~1;


        dw  = PCM_SAMPLESTOBYTES(pwfpcm, dw);

        padsh->cbSrcLengthUsed = dw;
    }
    else
    {
        //
        //  Decode.
        //

        pwfadpcm = (LPADPCMWAVEFORMAT)padsi->pwfxSrc;
        pwfpcm   = padsi->pwfxDst;

        //
        // Determine the number of samples to convert.
        //
        dw = padsh->cbSrcLength;
        if (fBlockAlign) {
            dw = (dw / pwfadpcm->wfx.nBlockAlign) * pwfadpcm->wfx.nBlockAlign;
        }
        padsh->cbSrcLengthUsed = dw;
    }

    //
    //  Call the conversion routine.
    //
#ifdef WIN32

    fpConvertC = (CONVERTPROC_C)padsi->dwDriver;
    padsh->cbDstLengthUsed = (*fpConvertC)(
                (HPBYTE)padsh->pbSrc,
                padsh->cbSrcLengthUsed,
                (HPBYTE)padsh->pbDst,
                (UINT)pwfadpcm->wfx.nBlockAlign,
                (UINT)pwfadpcm->wSamplesPerBlock,
                (UINT)pwfadpcm->wNumCoef,
                (LPADPCMCOEFSET)&(pwfadpcm->aCoef[0])
    );

#else

    fRealTime = (0L == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME) );
    if( fDecode || fRealTime ) {
        fpConvertAsm = (CONVERTPROC_ASM)padsi->dwDriver;
        padsh->cbDstLengthUsed = (*fpConvertAsm)(
                padsi->pwfxSrc,
                padsh->pbSrc,
                padsi->pwfxDst,
                padsh->pbDst,
                padsh->cbSrcLengthUsed
        );
    } else {
        fpConvertC = (CONVERTPROC_C)padsi->dwDriver;
        padsh->cbDstLengthUsed = (*fpConvertC)(
                (HPBYTE)padsh->pbSrc,
                padsh->cbSrcLengthUsed,
                (HPBYTE)padsh->pbDst,
                (UINT)pwfadpcm->wfx.nBlockAlign,
                (UINT)pwfadpcm->wSamplesPerBlock,
                (UINT)pwfadpcm->wNumCoef,
                (LPADPCMCOEFSET)&(pwfadpcm->aCoef[0])
        );
    }

#endif

    return (MMSYSERR_NOERROR);
} // acmdStreamConvert()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD_PTR dwId: For most messages, dwId is the DWORD_PTR value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      that the driver is opened, through the DrvOpen API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message.  Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message.  Defined separately for
//      each message.
//
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

LRESULT FNEXPORT DriverProc
(
    DWORD_PTR   dwId,
    HDRVR       hdrvr,
    UINT        uMsg,
    LPARAM      lParam1,
    LPARAM      lParam2
)
{
    LRESULT             lr;
    PCODECINST          pci;

    //
    //  make pci either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
    pci = (PCODECINST)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef WIN32
            DbgInitialize(TRUE);
#endif
            DPF(4, "DRV_LOAD");
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            DPF(4, "DRV_FREE");
            return (1L);

        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            DPF(4, "DRV_OPEN");
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            DPF(4, "DRV_CLOSE");
            lr = acmdDriverClose(pci);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            DPF(4, "DRV_INSTALL");
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            DPF(4, "DRV_REMOVE");
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            DPF(4, "DRV_QUERYCONFIGURE");
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for hardware configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            DPF(4, "DRV_CONFIGURE");
            lr = acmdDriverConfigure(pci, (HWND)lParam1,
                    (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            DPF(4, "ACMDM_DRIVER_DETAILS");
            lr = acmdDriverDetails(pci, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            DPF(4, "ACMDM_DRIVER_ABOUT");
            lr = acmdDriverAbout(pci, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_FORMAT_SUGGEST:
            DPF(4, "ACMDM_FORMAT_SUGGEST");
            lr = acmdFormatSuggest(pci, (LPACMDRVFORMATSUGGEST)lParam1 );
            return (lr);


        //
        //  lParam1: FORMATTAGDETAILS
        //
        //  lParam2: Not used.
        //
        case ACMDM_FORMATTAG_DETAILS:
            DPF(4, "ACMDM_FORMATTAG_DETAILS");
            lr = acmdFormatTagDetails(pci, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

        //
        //  lParam1: FORMATDETAILS
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            DPF(4, "ACMDM_FORMAT_DETAILS");
            lr = acmdFormatDetails(pci, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            DPF(4, "ACMDM_STREAM_OPEN");
            lr = acmdStreamOpen(pci, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            DPF(4, "ACMDM_STREAM_CLOSE");
            lr = acmdStreamClose(pci, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            DPF(4, "ACMDM_STREAM_SIZE");
            lr = acmdStreamSize(pci, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
            DPF(4, "ACMDM_STREAM_CONVERT");
            lr = acmdStreamConvert(pci, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);
            return (lr);
    }

    //
    //  if we are executing the following code, then this codec does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if a codec does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   Other installable driver messages: if a codec does not answer
    //      a message that is NOT in the ACM driver message range, then
    //      it must call DefDriverProc and return that result.
    //
    DPF(4, "OTHER MESSAGE RECEIVED BY DRIVERPROC");
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msadpcm\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//  History:
//      11/16/92    cjp     [curtisp]
//
//==========================================================================;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_CODEC is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_CODEC	    MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_CODEC	    MAKE_ACM_VERSION(3, 51, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_CODEC	    MAKE_ACM_VERSION(2, 1, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a WAVEFORMATEX structure.
//
#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))


//
//
//
#define MAX_ERR_STRING      250     // used in various places for errors



//
//
//
//
typedef struct tCODECINST
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the codec will be easier to combine
    //  with other types of codecs (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of codec: 'audc'
    DRIVERPROC      DriverProc;     // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your codec requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           dwFlags;        // flags from open description

} CODECINST, *PCODECINST, FAR *LPCODECINST;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  typedefs
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  This define deals with unaligned data for Win32, and huge data for Win16.
//  Basically, any time you cast an HPBYTE to a non-byte variable (ie long or
//  short), you should cast it to ( {short,long} HUGE_T *).  This will cast
//  it to _huge for Win16, and make sure that there are no alignment problems
//  for Win32 on MIPS and Alpha machines.
//

typedef BYTE HUGE *HPBYTE;

#ifdef WIN32
    #define HUGE_T  UNALIGNED
#else
    #define HUGE_T  _huge
#endif


typedef DWORD (FNGLOBAL *CONVERTPROC_ASM)(LPWAVEFORMATEX, LPBYTE, LPWAVEFORMATEX, LPBYTE, DWORD);
typedef DWORD (FNGLOBAL *CONVERTPROC_C)
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);



//
//  resource id's
//
//
#define ICON_CODEC                  RCID(10)

#define IDS_CODEC_SHORTNAME         (1)     // ACMCONVINFO.szShortName
#define IDS_CODEC_LONGNAME          (2)     // ACMCONVINFO.szLongName
#define IDS_CODEC_COPYRIGHT         (3)     // ACMCONVINFO.szCopyright
#define IDS_CODEC_LICENSING         (4)     // ACMCONVINFO.szLicensing
#define IDS_CODEC_FEATURES          (5)     // ACMCONVINFO.szFeatures

#define IDS_CODEC_NAME              (10)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msacmmap\waveout.c ===
//==========================================================================;
//
//  waveout.c
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//  Description:
//
//
//  History:
//       9/18/93    cjp     [curtisp]
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "msacmmap.h"

#include "debug.h"


//--------------------------------------------------------------------------;
//
//  DWORD wodmMapperStatus
//
//  Description:
//
//
//  Arguments:
//      LPMAPSTREAM pms:
//
//      DWORD dwStatus:
//
//      LPDWORD pdw:
//
//  Return (DWORD):
//
//  History:
//      08/13/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL wodmMapperStatus
(
    LPMAPSTREAM     pms,
    DWORD           dwStatus,
    LPDWORD         pdw
)
{
    MMRESULT        mmr;

//  V_WPOINTER(pdw, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if ((NULL == pms) || (NULL == pdw))
    {
	return (MMSYSERR_INVALPARAM);
    }

    //
    //
    //
    switch (dwStatus)
    {
	case WAVEOUT_MAPPER_STATUS_DEVICE:
	{
	    UINT        uId = (UINT)(-1);   // Invalid value

	    mmr = waveOutGetID(pms->hwoReal, &uId);
	    if (MMSYSERR_NOERROR != mmr)
	    {
		return (mmr);
	    }

	    *pdw = uId;
	    return (MMSYSERR_NOERROR);
	}

	case WAVEOUT_MAPPER_STATUS_MAPPED:
	    *pdw = (NULL != pms->has);
	    return (MMSYSERR_NOERROR);

	case WAVEOUT_MAPPER_STATUS_FORMAT:
	    if (NULL != pms->has)
		_fmemcpy(pdw, pms->pwfxReal, sizeof(PCMWAVEFORMAT));
	    else
		_fmemcpy(pdw, pms->pwfxClient, sizeof(PCMWAVEFORMAT));

	    ((LPWAVEFORMATEX)pdw)->cbSize = 0;
	    return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // wodmMapperStatus()


//--------------------------------------------------------------------------;
//
//  DWORD wodMessage
//
//  Description:
//      This function conforms to the standard Wave output driver message
//      procedure (wodMessage), which is documented in mmddk.d.
//
//  Arguments:
//      UINT uId:
//
//      UINT uMsg:
//
//      DWORD dwUser:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (DWORD):
//
//
//  History:
//      11/15/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

EXTERN_C DWORD FNEXPORT wodMessage
(
    UINT                    uId,
    UINT                    uMsg,
    DWORD_PTR               dwUser,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2
)
{
#ifndef WIN32  // Mechanism doesn't work for multithread
    static int          fSem = 0;
#endif // !WIN32
    DWORD               dw;
    LPMAPSTREAM         pms;    // pointer to per-instance info structure

    if (!gpag->fEnabled)
    {
	DPF(1, "wodMessage: called while disabled!");
	return ((WODM_GETNUMDEVS == uMsg) ? 0L : MMSYSERR_NOTENABLED);
    }

#ifndef WIN32
    //
    //  we call back into the mmsystem wave APIs so protect ourself
    //  from being re-entered!
    //
    if (fSem)
    {
	DPF(0, "!wodMessage() being reentered! fSem=%d", fSem);
	return (MMSYSERR_NOTSUPPORTED);
    }
#endif

    pms = (LPMAPSTREAM)dwUser;

    switch (uMsg)
    {
	case WODM_GETNUMDEVS:
	    return (1L);

	case WODM_GETDEVCAPS:
	    return mapWaveGetDevCaps(FALSE, (LPWAVEOUTCAPS)dwParam1, (UINT)dwParam2);

	case WODM_OPEN:
#ifndef WIN32
	    fSem++;
#endif // !WIN32

	    //
	    //  dwParam1 contains a pointer to a WAVEOPENDESC
	    //  dwParam2 contains wave driver specific flags in the LOWORD
	    //  and generic driver flags in the HIWORD
	    //
	    dw = mapWaveOpen(FALSE, uId, dwUser, (LPWAVEOPENDESC)dwParam1, (DWORD)(PtrToLong((PVOID)dwParam2)));

#ifndef WIN32
	    fSem--;
#endif // !WIN32
	    return (dw);

	case WODM_CLOSE:
	    return (mapWaveClose(pms));

	case WODM_PREPARE:
	    return (mapWavePrepareHeader(pms, (LPWAVEHDR)dwParam1));

	case WODM_UNPREPARE:
	    return (mapWaveUnprepareHeader(pms, (LPWAVEHDR)dwParam1));

	case WODM_WRITE:
	    return (mapWaveWriteBuffer(pms, (LPWAVEHDR)dwParam1));

	case WODM_PAUSE:
	    return waveOutPause(pms->hwoReal);

	case WODM_RESTART:
	    return waveOutRestart(pms->hwoReal);

	case WODM_RESET:
	    return waveOutReset(pms->hwoReal);

	case WODM_BREAKLOOP:
	    return waveOutBreakLoop(pms->hwoReal);

	case WODM_GETPOS:
	    return mapWaveGetPosition(pms, (LPMMTIME)dwParam1, (UINT)dwParam2);

	case WODM_GETVOLUME:
	    if (NULL != pms)
	    {
#if (WINVER < 0x0400)
		UINT    uDevId;

		waveOutGetID(pms->hwoReal, &uDevId);
		return waveOutGetVolume(uDevId, (LPDWORD)dwParam1);
#else
		return waveOutGetVolume(pms->hwoReal, (LPDWORD)dwParam1);
#endif
	    }
	    else
        {
        UINT    uDevId;

        WAIT_FOR_MUTEX(gpag->hMutexSettings);
        uDevId = gpag->pSettings->uIdPreferredOut;
        RELEASE_MUTEX(gpag->hMutexSettings);

        if ((UINT)WAVE_MAPPER != uDevId)
	    {
#if (WINVER < 0x0400)
		return waveOutGetVolume(uDevId, (LPDWORD)dwParam1);
#else
		return waveOutGetVolume((HWAVEOUT)LongToHandle(uDevId), (LPDWORD)dwParam1);
#endif
        }
	    }

	    return (MMSYSERR_NOTSUPPORTED);

	case WODM_SETVOLUME:
	    if (NULL != pms)
	    {
#if (WINVER < 0x0400)
		UINT    uDevId;

		waveOutGetID(pms->hwoReal, &uDevId);
		return waveOutSetVolume(uDevId, (DWORD)(PtrToLong((PVOID)dwParam1)) );
#else
		return waveOutSetVolume(pms->hwoReal, (DWORD)(PtrToLong((PVOID)dwParam1)) );
#endif
	    }
	    else
        {
        UINT    uDevId;

        WAIT_FOR_MUTEX(gpag->hMutexSettings);
        uDevId = gpag->pSettings->uIdPreferredOut;
        RELEASE_MUTEX(gpag->hMutexSettings);

        if ((UINT)WAVE_MAPPER != uDevId)
    	{
#if (WINVER < 0x0400)
    	return waveOutSetVolume(uDevId, (DWORD)(PtrToLong((PVOID)dwParam1)) );
#else
    	return waveOutSetVolume((HWAVEOUT)(UINT_PTR)uDevId, (DWORD)(PtrToLong((PVOID)dwParam1)) );
#endif
    	}
        }

	    return (MMSYSERR_NOTSUPPORTED);

	case WODM_GETPITCH:
	    return waveOutGetPitch(pms->hwoReal, (LPDWORD)dwParam1);
	    
	case WODM_SETPITCH:
	    return waveOutSetPitch(pms->hwoReal, (DWORD)(PtrToLong((PVOID)dwParam1)) );
	    
	case WODM_GETPLAYBACKRATE:
	    return waveOutGetPlaybackRate(pms->hwoReal, (LPDWORD)dwParam1);
	    
	case WODM_SETPLAYBACKRATE:
	    return waveOutSetPlaybackRate(pms->hwoReal, (DWORD)(PtrToLong((PVOID)dwParam1)) );

	case WODM_MAPPER_STATUS:
	    dw = wodmMapperStatus(pms, (DWORD)(PtrToLong((PVOID)dwParam1)), (LPDWORD)dwParam2);
	    return (dw);

#if (WINVER >= 0x0400)
	case DRVM_MAPPER_RECONFIGURE:
	    mapDriverDisable(NULL);
	    mapDriverEnable(NULL);
	    return (0);
#endif
    }

    if (!pms || !pms->hwoReal)
	return (MMSYSERR_NOTSUPPORTED);

    return waveOutMessage(pms->hwoReal, uMsg, dwParam1, dwParam2);
} // wodMessage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msadpcm\debug.h ===
// Copyright (c) 1994 Microsoft Corporation
//==========================================================================;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define DEBUG_SECTION       "Debug"         // section name for 
#define DEBUG_MODULE_NAME   "MSADPCM"       // key name and prefix for output
#define DEBUG_MAX_LINE_LEN  255             // max line length (bytes)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define DPF      dprintf
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #pragma warning(disable:4002)
    #define DPF()
    #define ASSERT(x)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msadpcm\init.c ===
//==========================================================================;
//
//  init.c
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//  Description:
//
//
//  History:
//      11/16/92    cjp     [curtisp] 
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"

#include "debug.h"


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef WIN32

//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//  Arguments:
//      HINSTANCE hinst: Our module handle.
//
//      WORD wDataSeg: Specifies the DS value for this DLL.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    cjp     [curtisp] 
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE   hinst, 
    WORD        wDataSeg, 
    WORD        cbHeapSize,
    LPSTR       pszCmdLine
)
{
    DbgInitialize(TRUE);

    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);

    return (TRUE);
} // LibMain()


//--------------------------------------------------------------------------;
//  
//  int WEP
//  
//  Description:
//  
//  
//  Arguments:
//      WORD wUselessParam:
//  
//  Return (int):
//  
//  History:
//      03/28/93    cjp     [curtisp]
//  
//--------------------------------------------------------------------------;

int FNEXPORT WEP
(
    WORD    wUselessParam
)
{
    DPF(1, "WEP(wUselessParam=%u)", wUselessParam);

    //
    //  always return 1.
    //
    return (1);
} // WEP()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msadpcm\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static CHAR     ach[300];       // debug output (avoid stack overflow)
    int	            id;


    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
        FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:               // Break into the debugger.
#if DBG
                DebugBreak();
#endif
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msadpcm\msadpcm.h ===
//==========================================================================;
//
//  msadpcm.h
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//  Description:
//
//
//  History:
//
//==========================================================================;


//
//
//

#define MSADPCM_MAX_CHANNELS        2
#define MSADPCM_MAX_COEFFICIENTS    7
#define MSADPCM_BITS_PER_SAMPLE     4
#define MSADPCM_WFX_EXTRA_BYTES     32
#define MSADPCM_HEADER_LENGTH       7       // in Bytes, per channel.

#define CSCALE_NUM                  256
#define PSCALE_NUM                  256
#define CSCALE                      8
#define PSCALE                      8

#define DELTA4START                 128
#define DELTA8START                 16

#define DELTA4MIN                   16
#define DELTA8MIN                   1

#define OUTPUT4MASK                 (0x0F)
#define OUTPUT4MAX                  7
#define OUTPUT4MIN                  (-8)
#define OUTPUT8MAX                  127
#define OUTPUT8MIN                  (-128)


//
//  note that these constants are used for encoding only. decode must take
//  all info from the file. note that then number of samples/bytes must be
//  small enough to let all stored arrays be DS ??? !!!
//
#define BPS4_COMPRESSED         4
#define BPS8_COMPRESSED         8
#define BLOCK4_SAMPLES          500
#define BLOCK4_STREAM_SAMPLES   498
#define BLOCK4_BYTES            256


//
//  These are defined as integers (even though they will fit in shorts)
//  because they are accessed so often - this will speed stuff up.
//
#ifdef WIN32
extern const int gaiCoef1[];
extern const int gaiCoef2[];
extern const int gaiP4[];
#else
extern short gaiCoef1[];
extern short gaiCoef2[];
extern short gaiP4[];
#endif


//
//  Function Prototypes.
//

DWORD FNGLOBAL adpcmEncode4Bit_M08_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_M16_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_S08_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_S16_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);


#ifdef WIN32

DWORD FNGLOBAL adpcmEncode4Bit_M08_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_M16_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_S08_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmEncode4Bit_S16_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);


DWORD FNGLOBAL adpcmDecode4Bit_M08
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmDecode4Bit_M16
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmDecode4Bit_S08
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);

DWORD FNGLOBAL adpcmDecode4Bit_S16
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
);


#else

//
//  These prototypes are for assembler routines in dec386.asm and enc386.asm
//

DWORD FNGLOBAL DecodeADPCM_4Bit_386
(
    LPADPCMWAVEFORMAT   pwfADPCM,
    LPBYTE              pbSrc,
    LPPCMWAVEFORMAT     pwfPCM,
    LPBYTE              pbDst,
    DWORD               cbSrcLen
);

DWORD FNGLOBAL EncodeADPCM_4Bit_386
(
    LPPCMWAVEFORMAT     pwfPCM,
    LPBYTE              pbSrc,
    LPADPCMWAVEFORMAT   pwfADPCM,
    LPBYTE              pbDst,
    DWORD               cbSrcLen
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msadpcm\msadpcm.c ===
//==========================================================================;
//
//  msadpcm.c
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//  Description:
//
//
//  History:
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"
#include "msadpcm.h"

#include "debug.h"


//
//  these are in dec386.asm for Win 16
//
//  _gaiCoef1   dw  256,  512,  0, 192, 240,  460,  392
//  _gaiCoef2   dw    0, -256,  0,  64,   0, -208, -232
//
//  _gaiP4      dw  230, 230, 230, 230, 307, 409, 512, 614
//              dw  768, 614, 512, 409, 307, 230, 230, 230
//
#ifdef WIN32
    const int gaiCoef1[]= {256,  512, 0, 192, 240,  460,  392};
    const int gaiCoef2[]= {  0, -256, 0,  64,   0, -208, -232};

    const int gaiP4[]   = {230, 230, 230, 230, 307, 409, 512, 614,
                           768, 614, 512, 409, 307, 230, 230, 230};
#endif


#ifndef INLINE
#define INLINE __inline
#endif


                    
//--------------------------------------------------------------------------;
//  
//  DWORD pcmM08BytesToSamples
//  DWORD pcmM16BytesToSamples
//  DWORD pcmS08BytesToSamples
//  DWORD pcmS16BytesToSamples
//  
//  Description:
//      These functions return the number of samples in a buffer of PCM
//      of the specified format.  For efficiency, it is declared INLINE.
//      Note that, depending on the optimization flags, it may not
//      actually be implemented as INLINE.  Optimizing for speed (-Oxwt)
//      will generally obey the INLINE specification.
//  
//  Arguments:
//      DWORD cb: The length of the buffer, in bytes.
//  
//  Return (DWORD):  The length of the buffer in samples.
//  
//--------------------------------------------------------------------------;

INLINE DWORD pcmM08BytesToSamples( DWORD cb )
{
    return cb;
}

INLINE DWORD pcmM16BytesToSamples( DWORD cb )
{
    return cb / ((DWORD)2);
}

INLINE DWORD pcmS08BytesToSamples( DWORD cb )
{
    return cb / ((DWORD)2);
}

INLINE DWORD pcmS16BytesToSamples( DWORD cb )
{
    return cb / ((DWORD)4);
}



//--------------------------------------------------------------------------;
//  
//  int     pcmRead08
//  int     pcmRead16
//  int     pcmRead16Unaligned
//  
//  Description:
//      These functions read an 8 or 16 bit PCM value from the specified
//      buffer.  Note that the buffers are either HUGE or UNALIGNED in all
//      cases.  However, if a single 16-bit value crosses a segment boundary
//      in Win16, then pcmRead16 will wrap around; use pcmRead16Unaligned
//      instead.
//  
//  Arguments:
//      HPBYTE pb:  Pointer to the input buffer.
//  
//  Return (int):  The PCM value converted to 16-bit format.
//  
//--------------------------------------------------------------------------;

INLINE int pcmRead08( HPBYTE pb )
{
    return ( (int)*pb - 128 ) << 8;
}

INLINE int pcmRead16( HPBYTE pb )
{
    return (int)*(short HUGE_T *)pb;
}

#ifdef WIN32

#define pcmRead16Unaligned pcmRead16

#else

INLINE int pcmRead16Unaligned( HPBYTE pb )
{
    return (int)(short)( ((WORD)*pb) | (((WORD)*(pb+1))<<8) );
}

#endif



//--------------------------------------------------------------------------;
//  
//  void    pcmWrite08
//  void    pcmWrite16
//  void    pcmWrite16Unaligned
//
//  Description:
//      These functions write a PCM sample (a 16-bit integer) into the
//      specified buffer in the appropriate format.  Note that the buffers
//      are either HUGE or UNALIGNED.  However, if a single 16-bit value is
//      written across a segment boundary, then pcmWrite16 will not handle
//      it correctly; us pcmWrite16Unaligned instead.
//  
//  Arguments:
//      HPBYTE  pb:     Pointer to the output buffer.
//      int     iSamp:  The sample.
//  
//  Return (int):  The PCM value converted to 16-bit format.
//  
//--------------------------------------------------------------------------;

INLINE void pcmWrite08( HPBYTE pb, int iSamp )
{
    *pb = (BYTE)((iSamp >> 8) + 128);
}

INLINE void pcmWrite16( HPBYTE pb, int iSamp )
{
    *(short HUGE_T *)pb = (short)iSamp;
}

#ifdef WIN32

#define pcmWrite16Unaligned pcmWrite16

#else

INLINE void pcmWrite16Unaligned( HPBYTE pb, int iSamp )
{
    *pb     = (BYTE)( iSamp&0x00FF );
    *(pb+1) = (BYTE)( iSamp>>8 );
}

#endif



//--------------------------------------------------------------------------;
//
//  int adpcmCalcDelta
//
//  Description:
//      This function computes the next Adaptive Scale Factor (ASF) value
//      based on the the current ASF and the current encoded sample.
//
//  Arguments:
//      int iEnc:  The current encoded sample (as a signed integer).
//      int iDelta:  The current ASF.
//
//  Return (int):  The next ASF.
//      
//--------------------------------------------------------------------------;

INLINE int adpcmCalcDelta
(
    int iEnc,
    int iDelta
)
{
    int iNewDelta;

    iNewDelta = (int)((gaiP4[iEnc&OUTPUT4MASK] * (long)iDelta) >> PSCALE);
    if( iNewDelta < DELTA4MIN )
        iNewDelta = DELTA4MIN;

    return iNewDelta;
}



//--------------------------------------------------------------------------;
//
//  long adpcmCalcPrediction
//
//  Description:
//      This function calculates the predicted sample value based on the
//      previous two samples and the current coefficients.
//
//  Arguments:
//      int iSamp1:  The previous decoded sample.
//      int iCoef1:  The coefficient for iSamp1.
//      int iSamp2:  The decoded sample before iSamp1.
//      int iCoef2:  The coefficient for iSamp2.
//
//  Return (long):  The predicted sample.
//      
//--------------------------------------------------------------------------;

INLINE long adpcmCalcPrediction
(
    int iSamp1,
    int iCoef1,
    int iSamp2,
    int iCoef2
)
{
    return ((long)iSamp1 * iCoef1 + (long)iSamp2 * iCoef2) >> CSCALE;
}



//--------------------------------------------------------------------------;
//
//  int adpcmDecodeSample
//
//  Description:
//      This function decodes a single 4-bit encoded ADPCM sample.  There
//      are three steps:
//
//          1.  Sign-extend the 4-bit iInput.
//
//          2.  predict the next sample using the previous two
//              samples and the predictor coefficients:
//
//              Prediction = (iSamp1 * aiCoef1 + iSamp2 * iCoef2) / 256;
//
//          3.  reconstruct the original PCM sample using the encoded
//              sample (iInput), the Adaptive Scale Factor (aiDelta)
//              and the prediction value computed in step 1 above.
//
//              Sample = (iInput * iDelta) + Prediction;
//
//  Arguments:
//      int iSamp1:  The previous decoded sample.
//      int iCoef1:  The coefficient for iSamp1.
//      int iSamp2:  The decoded sample before iSamp1.
//      int iCoef2:  The coefficient for iSamp2.
//      int iInput:  The current encoded sample (lower 4 bits).
//      int iDelta:  The current ASF.
//
//  Return (int):  The decoded sample.
//      
//--------------------------------------------------------------------------;

INLINE int adpcmDecodeSample
(
    int iSamp1,
    int iCoef1,
    int iSamp2,
    int iCoef2,
    int iInput,
    int iDelta
)
{
    long lSamp;

    iInput = (int)( ((signed char)(iInput<<4)) >> 4 );

    lSamp = ((long)iInput * iDelta)  +
            adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

    if (lSamp > 32767)
        lSamp = 32767;
    else if (lSamp < -32768)
        lSamp = -32768;

    return (int)lSamp;
}

    

//--------------------------------------------------------------------------;
//
//  int adpcmEncode4Bit_FirstDelta
//
//  Description:
//      
//
//  Arguments:
//      
//
//  Return (short FNLOCAL):
//
//
//  History:
//       1/27/93    cjp     [curtisp] 
//
//--------------------------------------------------------------------------;

INLINE int FNLOCAL adpcmEncode4Bit_FirstDelta
(
    int iCoef1,
    int iCoef2,
    int iP5,
    int iP4,
    int iP3,
    int iP2,
    int iP1
)
{
    long    lTotal;
    int     iRtn;
    long    lTemp;

    //
    //  use average of 3 predictions
    //
    lTemp  = (((long)iP5 * iCoef2) + ((long)iP4 * iCoef1)) >> CSCALE;
    lTotal = (lTemp > iP3) ? (lTemp - iP3) : (iP3 - lTemp);

    lTemp   = (((long)iP4 * iCoef2) + ((long)iP3 * iCoef1)) >> CSCALE;
    lTotal += (lTemp > iP2) ? (lTemp - iP2) : (iP2 - lTemp);

    lTemp   = (((long)iP3 * iCoef2) + ((long)iP2 * iCoef1)) >> CSCALE;
    lTotal += (lTemp > iP1) ? (lTemp - iP1) : (iP1 - lTemp);
    
    //
    //  optimal iDelta is 1/4 of prediction error
    //
    iRtn = (int)(lTotal / 12);
    if (iRtn < DELTA4MIN)
        iRtn = DELTA4MIN;

    return (iRtn);
} // adpcmEncode4Bit_FirstDelta()




//==========================================================================;
//
//     NON-REALTIME ENCODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD adpcmEncode4Bit_M08_FullPass
//  DWORD adpcmEncode4Bit_M16_FullPass
//  DWORD adpcmEncode4Bit_S08_FullPass
//  DWORD adpcmEncode4Bit_S16_FullPass
//
//  Description:
//      These functions encode a buffer of data from PCM to MS ADPCM in the
//      specified format.  These functions use a fullpass algorithm which
//      tries each set of coefficients in order to determine which set
//      produces the smallest coding error.  The appropriate function is
//      called once for each ACMDM_STREAM_CONVERT message received.
//      
//
//  Arguments:
//      
//
//  Return (DWORD):  The number of bytes used in the destination buffer.
//
//--------------------------------------------------------------------------;

#define ENCODE_DELTA_LOOKAHEAD      5

DWORD FNGLOBAL adpcmEncode4Bit_M08_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    HPBYTE              pbSrcThisBlock;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 aiSamples[ENCODE_DELTA_LOOKAHEAD];
    int                 aiFirstDelta[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalError[MSADPCM_MAX_COEFFICIENTS];

    int                 iCoef1;
    int                 iCoef2;
    int                 iSamp1;
    int                 iSamp2;
    int                 iDelta;
    int                 iOutput1;
    int                 iOutput2;
    int                 iBestPredictor;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;
    DWORD               dw;
    UINT                i,n;


    pbDstStart = pbDst;
    cSrcSamples = pcmM08BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  We need the first ENCODE_DELTA_LOOKAHEAD samples in order to
        //  calculate the first iDelta value.  Therefore we put these samples
        //  into a more accessible array: aiSamples[].  Note: if we don't
        //  have ENCODE_DELTA_LOOKAHEAD samples, we pretend that the samples
        //  that we don't have are actually zeros.  This is important not
        //  only for the iDelta calculation, but also for the case where
        //  there is only 1 sample to encode ... in this case, there is not
        //  really enough data to complete the ADPCM block header, but since
        //  the two delay samples for the block header will be taken from
        //  the aiSamples[] array, iSamp1 [the second sample] will be taken
        //  as zero and there will no problem.
        //
        pbSrcThisBlock = pbSrc;
        for (n = 0; n < ENCODE_DELTA_LOOKAHEAD; n++)
        {
            if( n < cBlockSamples )
                aiSamples[n] = pcmRead08(pbSrcThisBlock++);
            else
                aiSamples[n] = 0;
        }


        //
        //  find the optimal predictor for each channel: to do this, we
        //  must step through and encode using each coefficient set (one
        //  at a time) and determine which one has the least error from
        //  the original data. the one with the least error is then used
        //  for the final encode (the 8th pass done below).
        //
        //  NOTE: keeping the encoded data of the one that has the least
        //  error at all times is an obvious optimization that should be
        //  done. in this way, we only need to do 7 passes instead of 8.
        //
        for (i = 0; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            //
            //  Reset source pointer to the beginning of the block.
            //
            pbSrcThisBlock = pbSrc;

            //
            //  Reset variables for this pass.
            //
            adwTotalError[i]    = 0L;
            iCoef1              = lpCoefSet[i].iCoef1;
            iCoef2              = lpCoefSet[i].iCoef2;

            //
            //  We need to choose the first iDelta--to do this, we need
            //  to look at the first few samples.
            //
            iDelta = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamples[0], aiSamples[1], aiSamples[2],
                                aiSamples[3], aiSamples[4]);
            aiFirstDelta[i] = iDelta;

            //
            //  Set up first two samples - these have already been converted
            //  to 16-bit values in aiSamples[], but make sure to increment
            //  pbSrcThisBlock so that it keeps in sync.
            //
            iSamp1          = aiSamples[1];
            iSamp2          = aiSamples[0];
            pbSrcThisBlock += 2*sizeof(BYTE);

            //
            //  now encode the rest of the PCM data in this block--note
            //  we start 2 samples ahead because the first two samples are
            //  simply copied into the ADPCM block header...
            //
            for (n = 2; n < cBlockSamples; n++)
            {
                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1, iCoef1,
                                                   iSamp2, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample = pcmRead08(pbSrcThisBlock++);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutput1 = (int)(lError / iDelta);
                if (iOutput1 > OUTPUT4MAX)
                    iOutput1 = OUTPUT4MAX;
                else if (iOutput1 < OUTPUT4MIN)
                    iOutput1 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput1);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput1,iDelta);
        
                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalError[i] += (lError * lError) >> 7;
            }
        }


        //
        //  WHEW! we have now made 7 passes over the data and calculated
        //  the error for each--so it's time to find the one that produced
        //  the lowest error and use that predictor.
        //
        iBestPredictor = 0;
        dw = adwTotalError[0];
        for (i = 1; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            if (adwTotalError[i] < dw)
            {
                iBestPredictor = i;
                dw = adwTotalError[i];
            }
        }
        iCoef1 = lpCoefSet[iBestPredictor].iCoef1;
        iCoef2 = lpCoefSet[iBestPredictor].iCoef2;
        
        
        //
        //  grab first iDelta from our precomputed first deltas that we
        //  calculated above
        //
        iDelta = aiFirstDelta[iBestPredictor];


        //
        //  Set up first two samples - these have already been converted
        //  to 16-bit values in aiSamples[], but make sure to increment
        //  pbSrc so that it keeps in sync.
        //
        iSamp1          = aiSamples[1];
        iSamp2          = aiSamples[0];
        pbSrc          += 2*sizeof(BYTE);

        ASSERT( cBlockSamples != 1 );
        cBlockSamples  -= 2;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)iBestPredictor;

        pcmWrite16Unaligned(pbDst,iDelta);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp1);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples>0 )
        {
            //
            //  Sample 1.
            //
            iSample = pcmRead08(pbSrc++);
            cBlockSamples--;

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutput1 = (int)(lError / iDelta);
            if (iOutput1 > OUTPUT4MAX)
                iOutput1 = OUTPUT4MAX;
            else if (iOutput1 < OUTPUT4MIN)
                iOutput1 = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDelta * iOutput1);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDelta = adpcmCalcDelta(iOutput1,iDelta);

            //
            //  Save updated delay samples.
            //
            iSamp2 = iSamp1;
            iSamp1 = (int)lSamp;


            //
            //  Sample 2.
            //
            if( cBlockSamples>0 ) {

                iSample = pcmRead08(pbSrc++);
                cBlockSamples--;

                //
                //  calculate the prediction based on the previous two samples
                //
                lPrediction = adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

                //
                //  encode the sample
                //
                lError = (long)iSample - lPrediction;
                iOutput2 = (int)(lError / iDelta);
                if (iOutput2 > OUTPUT4MAX)
                    iOutput2 = OUTPUT4MAX;
                else if (iOutput2 < OUTPUT4MIN)
                    iOutput2 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput2);
            
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;

                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput2,iDelta);

                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;
            
            } else {
                iOutput2 = 0;
            }


            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutput1&OUTPUT4MASK)<<4) |
                                (iOutput2&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_M08_FullPass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_M16_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    HPBYTE              pbSrcThisBlock;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 aiSamples[ENCODE_DELTA_LOOKAHEAD];
    int                 aiFirstDelta[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalError[MSADPCM_MAX_COEFFICIENTS];

    int                 iCoef1;
    int                 iCoef2;
    int                 iSamp1;
    int                 iSamp2;
    int                 iDelta;
    int                 iOutput1;
    int                 iOutput2;
    int                 iBestPredictor;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;
    DWORD               dw;
    UINT                i,n;


    pbDstStart = pbDst;
    cSrcSamples = pcmM16BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  We need the first ENCODE_DELTA_LOOKAHEAD samples in order to
        //  calculate the first iDelta value.  Therefore we put these samples
        //  into a more accessible array: aiSamples[].  Note: if we don't
        //  have ENCODE_DELTA_LOOKAHEAD samples, we pretend that the samples
        //  that we don't have are actually zeros.  This is important not
        //  only for the iDelta calculation, but also for the case where
        //  there is only 1 sample to encode ... in this case, there is not
        //  really enough data to complete the ADPCM block header, but since
        //  the two delay samples for the block header will be taken from
        //  the aiSamples[] array, iSamp1 [the second sample] will be taken
        //  as zero and there will no problem.
        //
        pbSrcThisBlock = pbSrc;
        for (n = 0; n < ENCODE_DELTA_LOOKAHEAD; n++)
        {
            if( n < cBlockSamples )
            {
                aiSamples[n]    = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);
            }
            else
                aiSamples[n] = 0;
        }


        //
        //  find the optimal predictor for each channel: to do this, we
        //  must step through and encode using each coefficient set (one
        //  at a time) and determine which one has the least error from
        //  the original data. the one with the least error is then used
        //  for the final encode (the 8th pass done below).
        //
        //  NOTE: keeping the encoded data of the one that has the least
        //  error at all times is an obvious optimization that should be
        //  done. in this way, we only need to do 7 passes instead of 8.
        //
        for (i = 0; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            //
            //  Reset source pointer to the beginning of the block.
            //
            pbSrcThisBlock = pbSrc;

            //
            //  Reset variables for this pass.
            //
            adwTotalError[i]    = 0L;
            iCoef1              = lpCoefSet[i].iCoef1;
            iCoef2              = lpCoefSet[i].iCoef2;

            //
            //  We need to choose the first iDelta--to do this, we need
            //  to look at the first few samples.
            //
            iDelta = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamples[0], aiSamples[1], aiSamples[2],
                                aiSamples[3], aiSamples[4]);
            aiFirstDelta[i] = iDelta;

            //
            //  Set up first two samples - these have already been converted
            //  to 16-bit values in aiSamples[], but make sure to increment
            //  pbSrcThisBlock so that it keeps in sync.
            //
            iSamp1          = aiSamples[1];
            iSamp2          = aiSamples[0];
            pbSrcThisBlock += 2*sizeof(short);

            //
            //  now encode the rest of the PCM data in this block--note
            //  we start 2 samples ahead because the first two samples are
            //  simply copied into the ADPCM block header...
            //
            for (n = 2; n < cBlockSamples; n++)
            {
                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1, iCoef1,
                                                   iSamp2, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample         = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutput1 = (int)(lError / iDelta);
                if (iOutput1 > OUTPUT4MAX)
                    iOutput1 = OUTPUT4MAX;
                else if (iOutput1 < OUTPUT4MIN)
                    iOutput1 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput1);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput1,iDelta);
        
                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalError[i] += (lError * lError) >> 7;
            }
        }


        //
        //  WHEW! we have now made 7 passes over the data and calculated
        //  the error for each--so it's time to find the one that produced
        //  the lowest error and use that predictor.
        //
        iBestPredictor = 0;
        dw = adwTotalError[0];
        for (i = 1; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            if (adwTotalError[i] < dw)
            {
                iBestPredictor = i;
                dw = adwTotalError[i];
            }
        }
        iCoef1 = lpCoefSet[iBestPredictor].iCoef1;
        iCoef2 = lpCoefSet[iBestPredictor].iCoef2;
        
        
        //
        //  grab first iDelta from our precomputed first deltas that we
        //  calculated above
        //
        iDelta = aiFirstDelta[iBestPredictor];


        //
        //  Set up first two samples - these have already been converted
        //  to 16-bit values in aiSamples[], but make sure to increment
        //  pbSrc so that it keeps in sync.
        //
        iSamp1          = aiSamples[1];
        iSamp2          = aiSamples[0];
        pbSrc          += 2*sizeof(short);

        ASSERT( cBlockSamples != 1 );
        cBlockSamples  -= 2;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)iBestPredictor;

        pcmWrite16Unaligned(pbDst,iDelta);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp1);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples>0 )
        {
            //
            //  Sample 1.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);
            cBlockSamples--;

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutput1 = (int)(lError / iDelta);
            if (iOutput1 > OUTPUT4MAX)
                iOutput1 = OUTPUT4MAX;
            else if (iOutput1 < OUTPUT4MIN)
                iOutput1 = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDelta * iOutput1);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDelta = adpcmCalcDelta(iOutput1,iDelta);

            //
            //  Save updated delay samples.
            //
            iSamp2 = iSamp1;
            iSamp1 = (int)lSamp;


            //
            //  Sample 2.
            //
            if( cBlockSamples>0 ) {

                iSample     = pcmRead16(pbSrc);
                pbSrc      += sizeof(short);
                cBlockSamples--;

                //
                //  calculate the prediction based on the previous two samples
                //
                lPrediction = adpcmCalcPrediction(iSamp1,iCoef1,iSamp2,iCoef2);

                //
                //  encode the sample
                //
                lError = (long)iSample - lPrediction;
                iOutput2 = (int)(lError / iDelta);
                if (iOutput2 > OUTPUT4MAX)
                    iOutput2 = OUTPUT4MAX;
                else if (iOutput2 < OUTPUT4MIN)
                    iOutput2 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput2);
            
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;

                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput2,iDelta);

                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;
            
            } else {
                iOutput2 = 0;
            }


            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutput1&OUTPUT4MASK)<<4) |
                                (iOutput2&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_M16_FullPass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_S08_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    HPBYTE              pbSrcThisBlock;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 aiSamplesL[ENCODE_DELTA_LOOKAHEAD];
    int                 aiSamplesR[ENCODE_DELTA_LOOKAHEAD];
    int                 aiFirstDeltaL[MSADPCM_MAX_COEFFICIENTS];
    int                 aiFirstDeltaR[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalErrorL[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalErrorR[MSADPCM_MAX_COEFFICIENTS];
    int                 iCoef1;
    int                 iCoef2;

    int                 iCoef1L;
    int                 iCoef2L;
    int                 iSamp1L;
    int                 iSamp2L;
    int                 iDeltaL;
    int                 iOutputL;
    int                 iBestPredictorL;

    int                 iCoef1R;
    int                 iCoef2R;
    int                 iSamp1R;
    int                 iSamp2R;
    int                 iDeltaR;
    int                 iOutputR;
    int                 iBestPredictorR;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;
    DWORD               dwL, dwR;
    UINT                i,n;


    pbDstStart = pbDst;
    cSrcSamples = pcmS08BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  We need the first ENCODE_DELTA_LOOKAHEAD samples in order to
        //  calculate the first iDelta value.  Therefore we put these samples
        //  into a more accessible array: aiSamples[].  Note: if we don't
        //  have ENCODE_DELTA_LOOKAHEAD samples, we pretend that the samples
        //  that we don't have are actually zeros.  This is important not
        //  only for the iDelta calculation, but also for the case where
        //  there is only 1 sample to encode ... in this case, there is not
        //  really enough data to complete the ADPCM block header, but since
        //  the two delay samples for the block header will be taken from
        //  the aiSamples[] array, iSamp1 [the second sample] will be taken
        //  as zero and there will no problem.
        //
        pbSrcThisBlock = pbSrc;
        for (n = 0; n < ENCODE_DELTA_LOOKAHEAD; n++)
        {
            if( n < cBlockSamples )
            {
                aiSamplesL[n] = pcmRead08(pbSrcThisBlock++);
                aiSamplesR[n] = pcmRead08(pbSrcThisBlock++);
            }
            else
            {
                aiSamplesL[n] = 0;
                aiSamplesR[n] = 0;
            }
        }


        //
        //  find the optimal predictor for each channel: to do this, we
        //  must step through and encode using each coefficient set (one
        //  at a time) and determine which one has the least error from
        //  the original data. the one with the least error is then used
        //  for the final encode (the 8th pass done below).
        //
        //  NOTE: keeping the encoded data of the one that has the least
        //  error at all times is an obvious optimization that should be
        //  done. in this way, we only need to do 7 passes instead of 8.
        //
        for (i = 0; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            //
            //  Reset source pointer to the beginning of the block.
            //
            pbSrcThisBlock = pbSrc;

            //
            //  Reset variables for this pass (coefs are the same for L, R).
            //
            adwTotalErrorL[i]   = 0L;
            adwTotalErrorR[i]   = 0L;
            iCoef1              = lpCoefSet[i].iCoef1;
            iCoef2              = lpCoefSet[i].iCoef2;

            //
            //  We need to choose the first iDelta--to do this, we need
            //  to look at the first few samples.
            //
            iDeltaL = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamplesL[0], aiSamplesL[1], aiSamplesL[2],
                                aiSamplesL[3], aiSamplesL[4]);
            iDeltaR = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamplesR[0], aiSamplesR[1], aiSamplesR[2],
                                aiSamplesR[3], aiSamplesR[4]);
            aiFirstDeltaL[i] = iDeltaL;
            aiFirstDeltaR[i] = iDeltaR;

            //
            //  Set up first two samples - these have already been converted
            //  to 16-bit values in aiSamples[], but make sure to increment
            //  pbSrcThisBlock so that it keeps in sync.
            //
            iSamp1L         = aiSamplesL[1];
            iSamp1R         = aiSamplesR[1];
            iSamp2L         = aiSamplesL[0];
            iSamp2R         = aiSamplesR[0];
            pbSrcThisBlock += 2*sizeof(BYTE) * 2; // Last 2 = # of channels.

            //
            //  now encode the rest of the PCM data in this block--note
            //  we start 2 samples ahead because the first two samples are
            //  simply copied into the ADPCM block header...
            //
            for (n = 2; n < cBlockSamples; n++)
            {
                //
                //  LEFT channel.
                //

                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1L, iCoef1,
                                                   iSamp2L, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample = pcmRead08(pbSrcThisBlock++);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutputL = (int)(lError / iDeltaL);
                if (iOutputL > OUTPUT4MAX)
                    iOutputL = OUTPUT4MAX;
                else if (iOutputL < OUTPUT4MIN)
                    iOutputL = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDeltaL * iOutputL);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);
        
                //
                //  Save updated delay samples.
                //
                iSamp2L = iSamp1L;
                iSamp1L = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalErrorL[i] += (lError * lError) >> 7;


                //
                //  RIGHT channel.
                //

                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1R, iCoef1,
                                                   iSamp2R, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample = pcmRead08(pbSrcThisBlock++);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutputR = (int)(lError / iDeltaR);
                if (iOutputR > OUTPUT4MAX)
                    iOutputR = OUTPUT4MAX;
                else if (iOutputR < OUTPUT4MIN)
                    iOutputR = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDeltaR * iOutputR);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);
        
                //
                //  Save updated delay samples.
                //
                iSamp2R = iSamp1R;
                iSamp1R = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalErrorR[i] += (lError * lError) >> 7;
            }
        }


        //
        //  WHEW! we have now made 7 passes over the data and calculated
        //  the error for each--so it's time to find the one that produced
        //  the lowest error and use that predictor.
        //
        iBestPredictorL = 0;
        iBestPredictorR = 0;
        dwL = adwTotalErrorL[0];
        dwR = adwTotalErrorR[0];
        for (i = 1; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            if (adwTotalErrorL[i] < dwL)
            {
                iBestPredictorL = i;
                dwL = adwTotalErrorL[i];
            }

            if (adwTotalErrorR[i] < dwR)
            {
                iBestPredictorR = i;
                dwR = adwTotalErrorR[i];
            }
        }
        iCoef1L = lpCoefSet[iBestPredictorL].iCoef1;
        iCoef1R = lpCoefSet[iBestPredictorR].iCoef1;
        iCoef2L = lpCoefSet[iBestPredictorL].iCoef2;
        iCoef2R = lpCoefSet[iBestPredictorR].iCoef2;
        
        
        //
        //  grab first iDelta from our precomputed first deltas that we
        //  calculated above
        //
        iDeltaL = aiFirstDeltaL[iBestPredictorL];
        iDeltaR = aiFirstDeltaR[iBestPredictorR];


        //
        //  Set up first two samples - these have already been converted
        //  to 16-bit values in aiSamples[], but make sure to increment
        //  pbSrc so that it keeps in sync.
        //
        iSamp1L         = aiSamplesL[1];
        iSamp1R         = aiSamplesR[1];
        iSamp2L         = aiSamplesL[0];
        iSamp2R         = aiSamplesR[0];
        pbSrc          += 2*sizeof(BYTE) * 2;  // Last 2 = # of channels.

        ASSERT( cBlockSamples != 1 );
        cBlockSamples  -= 2;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)iBestPredictorL;
        *pbDst++ = (BYTE)iBestPredictorR;

        pcmWrite16Unaligned(pbDst,iDeltaL);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iDeltaR);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp1R);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp2R);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples-- )
        {
            //
            //  LEFT channel.
            //
            iSample = pcmRead08(pbSrc++);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1L,iCoef1L,iSamp2L,iCoef2L);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputL = (int)(lError / iDeltaL);
            if (iOutputL > OUTPUT4MAX)
                iOutputL = OUTPUT4MAX;
            else if (iOutputL < OUTPUT4MIN)
                iOutputL = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaL * iOutputL);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);

            //
            //  Save updated delay samples.
            //
            iSamp2L = iSamp1L;
            iSamp1L = (int)lSamp;


            //
            //  RIGHT channel.
            //
            iSample = pcmRead08(pbSrc++);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1R,iCoef1R,iSamp2R,iCoef2R);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputR = (int)(lError / iDeltaR);
            if (iOutputR > OUTPUT4MAX)
                iOutputR = OUTPUT4MAX;
            else if (iOutputR < OUTPUT4MIN)
                iOutputR = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaR * iOutputR);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);

            //
            //  Save updated delay samples.
            //
            iSamp2R = iSamp1R;
            iSamp1R = (int)lSamp;
            

            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutputL&OUTPUT4MASK)<<4) |
                                (iOutputR&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_S08_FullPass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_S16_FullPass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    HPBYTE              pbSrcThisBlock;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 aiSamplesL[ENCODE_DELTA_LOOKAHEAD];
    int                 aiSamplesR[ENCODE_DELTA_LOOKAHEAD];
    int                 aiFirstDeltaL[MSADPCM_MAX_COEFFICIENTS];
    int                 aiFirstDeltaR[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalErrorL[MSADPCM_MAX_COEFFICIENTS];
    DWORD               adwTotalErrorR[MSADPCM_MAX_COEFFICIENTS];
    int                 iCoef1;
    int                 iCoef2;

    int                 iCoef1L;
    int                 iCoef2L;
    int                 iSamp1L;
    int                 iSamp2L;
    int                 iDeltaL;
    int                 iOutputL;
    int                 iBestPredictorL;

    int                 iCoef1R;
    int                 iCoef2R;
    int                 iSamp1R;
    int                 iSamp2R;
    int                 iDeltaR;
    int                 iOutputR;
    int                 iBestPredictorR;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;
    DWORD               dwL, dwR;
    UINT                i,n;


    pbDstStart = pbDst;
    cSrcSamples = pcmS16BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  We need the first ENCODE_DELTA_LOOKAHEAD samples in order to
        //  calculate the first iDelta value.  Therefore we put these samples
        //  into a more accessible array: aiSamples[].  Note: if we don't
        //  have ENCODE_DELTA_LOOKAHEAD samples, we pretend that the samples
        //  that we don't have are actually zeros.  This is important not
        //  only for the iDelta calculation, but also for the case where
        //  there is only 1 sample to encode ... in this case, there is not
        //  really enough data to complete the ADPCM block header, but since
        //  the two delay samples for the block header will be taken from
        //  the aiSamples[] array, iSamp1 [the second sample] will be taken
        //  as zero and there will no problem.
        //
        pbSrcThisBlock = pbSrc;
        for (n = 0; n < ENCODE_DELTA_LOOKAHEAD; n++)
        {
            if( n < cBlockSamples )
            {
                aiSamplesL[n]   = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);
                aiSamplesR[n]   = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);
            }
            else
            {
                aiSamplesL[n] = 0;
                aiSamplesR[n] = 0;
            }
        }


        //
        //  find the optimal predictor for each channel: to do this, we
        //  must step through and encode using each coefficient set (one
        //  at a time) and determine which one has the least error from
        //  the original data. the one with the least error is then used
        //  for the final encode (the 8th pass done below).
        //
        //  NOTE: keeping the encoded data of the one that has the least
        //  error at all times is an obvious optimization that should be
        //  done. in this way, we only need to do 7 passes instead of 8.
        //
        for (i = 0; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            //
            //  Reset source pointer to the beginning of the block.
            //
            pbSrcThisBlock = pbSrc;

            //
            //  Reset variables for this pass (coefs are the same for L, R).
            //
            adwTotalErrorL[i]   = 0L;
            adwTotalErrorR[i]   = 0L;
            iCoef1              = lpCoefSet[i].iCoef1;
            iCoef2              = lpCoefSet[i].iCoef2;

            //
            //  We need to choose the first iDelta--to do this, we need
            //  to look at the first few samples.
            //
            iDeltaL = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamplesL[0], aiSamplesL[1], aiSamplesL[2],
                                aiSamplesL[3], aiSamplesL[4]);
            iDeltaR = adpcmEncode4Bit_FirstDelta(iCoef1, iCoef2,
                                aiSamplesR[0], aiSamplesR[1], aiSamplesR[2],
                                aiSamplesR[3], aiSamplesR[4]);
            aiFirstDeltaL[i] = iDeltaL;
            aiFirstDeltaR[i] = iDeltaR;

            //
            //  Set up first two samples - these have already been converted
            //  to 16-bit values in aiSamples[], but make sure to increment
            //  pbSrcThisBlock so that it keeps in sync.
            //
            iSamp1L         = aiSamplesL[1];
            iSamp1R         = aiSamplesR[1];
            iSamp2L         = aiSamplesL[0];
            iSamp2R         = aiSamplesR[0];
            pbSrcThisBlock += 2*sizeof(short) * 2; // Last 2 = # of channels.

            //
            //  now encode the rest of the PCM data in this block--note
            //  we start 2 samples ahead because the first two samples are
            //  simply copied into the ADPCM block header...
            //
            for (n = 2; n < cBlockSamples; n++)
            {
                //
                //  LEFT channel.
                //

                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1L, iCoef1,
                                                   iSamp2L, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample         = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutputL = (int)(lError / iDeltaL);
                if (iOutputL > OUTPUT4MAX)
                    iOutputL = OUTPUT4MAX;
                else if (iOutputL < OUTPUT4MIN)
                    iOutputL = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDeltaL * iOutputL);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);
        
                //
                //  Save updated delay samples.
                //
                iSamp2L = iSamp1L;
                iSamp1L = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalErrorL[i] += (lError * lError) >> 7;


                //
                //  RIGHT channel.
                //

                //
                //  calculate the prediction based on the previous two
                //  samples
                //
                lPrediction = adpcmCalcPrediction( iSamp1R, iCoef1,
                                                   iSamp2R, iCoef2 );

                //
                //  Grab the next sample to encode.
                //
                iSample         = pcmRead16(pbSrcThisBlock);
                pbSrcThisBlock += sizeof(short);

                //
                //  encode it
                //
                lError = (long)iSample - lPrediction;
                iOutputR = (int)(lError / iDeltaR);
                if (iOutputR > OUTPUT4MAX)
                    iOutputR = OUTPUT4MAX;
                else if (iOutputR < OUTPUT4MIN)
                    iOutputR = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDeltaR * iOutputR);
        
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;
        
                //
                //  compute the next iDelta
                //
                iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);
        
                //
                //  Save updated delay samples.
                //
                iSamp2R = iSamp1R;
                iSamp1R = (int)lSamp;

                //
                //  keep a running status on the error for the current
                //  coefficient pair for this channel
                //
                lError = lSamp - iSample;
                adwTotalErrorR[i] += (lError * lError) >> 7;
            }
        }


        //
        //  WHEW! we have now made 7 passes over the data and calculated
        //  the error for each--so it's time to find the one that produced
        //  the lowest error and use that predictor.
        //
        iBestPredictorL = 0;
        iBestPredictorR = 0;
        dwL = adwTotalErrorL[0];
        dwR = adwTotalErrorR[0];
        for (i = 1; i < MSADPCM_MAX_COEFFICIENTS; i++)
        {
            if (adwTotalErrorL[i] < dwL)
            {
                iBestPredictorL = i;
                dwL = adwTotalErrorL[i];
            }

            if (adwTotalErrorR[i] < dwR)
            {
                iBestPredictorR = i;
                dwR = adwTotalErrorR[i];
            }
        }
        iCoef1L = lpCoefSet[iBestPredictorL].iCoef1;
        iCoef1R = lpCoefSet[iBestPredictorR].iCoef1;
        iCoef2L = lpCoefSet[iBestPredictorL].iCoef2;
        iCoef2R = lpCoefSet[iBestPredictorR].iCoef2;
        
        
        //
        //  grab first iDelta from our precomputed first deltas that we
        //  calculated above
        //
        iDeltaL = aiFirstDeltaL[iBestPredictorL];
        iDeltaR = aiFirstDeltaR[iBestPredictorR];


        //
        //  Set up first two samples - these have already been converted
        //  to 16-bit values in aiSamples[], but make sure to increment
        //  pbSrc so that it keeps in sync.
        //
        iSamp1L         = aiSamplesL[1];
        iSamp1R         = aiSamplesR[1];
        iSamp2L         = aiSamplesL[0];
        iSamp2R         = aiSamplesR[0];
        pbSrc          += 2*sizeof(short) * 2;  // Last 2 = # of channels.

        ASSERT( cBlockSamples != 1 );
        cBlockSamples  -= 2;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)iBestPredictorL;
        *pbDst++ = (BYTE)iBestPredictorR;

        pcmWrite16Unaligned(pbDst,iDeltaL);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iDeltaR);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp1R);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp2R);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples-- )
        {
            //
            //  LEFT channel.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1L,iCoef1L,iSamp2L,iCoef2L);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputL = (int)(lError / iDeltaL);
            if (iOutputL > OUTPUT4MAX)
                iOutputL = OUTPUT4MAX;
            else if (iOutputL < OUTPUT4MIN)
                iOutputL = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaL * iOutputL);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);

            //
            //  Save updated delay samples.
            //
            iSamp2L = iSamp1L;
            iSamp1L = (int)lSamp;


            //
            //  RIGHT channel.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = adpcmCalcPrediction(iSamp1R,iCoef1R,iSamp2R,iCoef2R);

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputR = (int)(lError / iDeltaR);
            if (iOutputR > OUTPUT4MAX)
                iOutputR = OUTPUT4MAX;
            else if (iOutputR < OUTPUT4MIN)
                iOutputR = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaR * iOutputR);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);

            //
            //  Save updated delay samples.
            //
            iSamp2R = iSamp1R;
            iSamp1R = (int)lSamp;
            

            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutputL&OUTPUT4MASK)<<4) |
                                (iOutputR&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_S16_FullPass()




//==========================================================================;
//
//      The code below this point is only compiled into WIN32 builds.  Win16
//      builds will call 386 assembler routines instead; see the routine
//      acmdStreamOpen() in codec.c for more details.
//
//==========================================================================;

#ifdef WIN32


//==========================================================================;
//
//      REALTIME ENCODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD FNGLOBAL adpcmEncode4Bit_M08_OnePass
//  DWORD FNGLOBAL adpcmEncode4Bit_M16_OnePass
//  DWORD FNGLOBAL adpcmEncode4Bit_S08_OnePass
//  DWORD FNGLOBAL adpcmEncode4Bit_S16_OnePass
//
//  Description:
//      
//
//  Arguments:
//      
//
//  Return (DWORD FNGLOBAL):
//
//
//  History:
//       1/27/93    cjp     [curtisp] 
//       3/03/94    rmh     [bobhed]
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_M08_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 iSamp1;
    int                 iSamp2;
    int                 iDelta;
    int                 iOutput1;
    int                 iOutput2;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;


    pbDstStart = pbDst;
    cSrcSamples = pcmM08BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)1;

        iDelta = DELTA4START;
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDelta.
        pbDst += sizeof(short);

        //
        //  Note that iSamp2 comes before iSamp1.  If we only have one
        //  sample, then set iSamp1 to zero.
        // 
        iSamp2 = pcmRead08(pbSrc++);
        if( --cBlockSamples > 0 ) {
            iSamp1 = pcmRead08(pbSrc++);
            cBlockSamples--;
        } else {
            iSamp1 = 0;
        }

        pcmWrite16Unaligned(pbDst,iSamp1);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples>0 )
        {
            //
            //  Sample 1.
            //
            iSample = pcmRead08(pbSrc++);
            cBlockSamples--;

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1<<1) - iSamp2;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutput1 = (int)(lError / iDelta);
            if (iOutput1 > OUTPUT4MAX)
                iOutput1 = OUTPUT4MAX;
            else if (iOutput1 < OUTPUT4MIN)
                iOutput1 = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDelta * iOutput1);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDelta = adpcmCalcDelta(iOutput1,iDelta);

            //
            //  Save updated delay samples.
            //
            iSamp2 = iSamp1;
            iSamp1 = (int)lSamp;


            //
            //  Sample 2.
            //
            if( cBlockSamples>0 ) {

                iSample = pcmRead08(pbSrc++);
                cBlockSamples--;

                //
                //  calculate the prediction based on the previous two samples
                //
                lPrediction = ((long)iSamp1<<1) - iSamp2;

                //
                //  encode the sample
                //
                lError = (long)iSample - lPrediction;
                iOutput2 = (int)(lError / iDelta);
                if (iOutput2 > OUTPUT4MAX)
                    iOutput2 = OUTPUT4MAX;
                else if (iOutput2 < OUTPUT4MIN)
                    iOutput2 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput2);
            
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;

                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput2,iDelta);

                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;
            
            } else {
                iOutput2 = 0;
            }


            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutput1&OUTPUT4MASK)<<4) |
                                (iOutput2&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_M08_OnePass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_M16_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 iSamp1;
    int                 iSamp2;
    int                 iDelta;
    int                 iOutput1;
    int                 iOutput2;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;


    pbDstStart = pbDst;
    cSrcSamples = pcmM16BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)1;

        iDelta = DELTA4START;
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDelta;
        pbDst += sizeof(short);

        //
        //  Note that iSamp2 comes before iSamp1.  If we only have one
        //  sample, then set iSamp1 to zero.
        // 
        iSamp2 = pcmRead16(pbSrc);
        pbSrc += sizeof(short);
        if( --cBlockSamples > 0 ) {
            iSamp1 = pcmRead16(pbSrc);
            pbSrc += sizeof(short);
            cBlockSamples--;
        } else {
            iSamp1 = 0;
        }

        pcmWrite16Unaligned(pbDst,iSamp1);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples>0 )
        {
            //
            //  Sample 1.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);
            cBlockSamples--;

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1<<1) - iSamp2;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutput1 = (int)(lError / iDelta);
            if (iOutput1 > OUTPUT4MAX)
                iOutput1 = OUTPUT4MAX;
            else if (iOutput1 < OUTPUT4MIN)
                iOutput1 = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDelta * iOutput1);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDelta = adpcmCalcDelta(iOutput1,iDelta);

            //
            //  Save updated delay samples.
            //
            iSamp2 = iSamp1;
            iSamp1 = (int)lSamp;


            //
            //  Sample 2.
            //
            if( cBlockSamples>0 ) {

                iSample     = pcmRead16(pbSrc);
                pbSrc      += sizeof(short);
                cBlockSamples--;

                //
                //  calculate the prediction based on the previous two samples
                //
                lPrediction = ((long)iSamp1<<1) - iSamp2;

                //
                //  encode the sample
                //
                lError = (long)iSample - lPrediction;
                iOutput2 = (int)(lError / iDelta);
                if (iOutput2 > OUTPUT4MAX)
                    iOutput2 = OUTPUT4MAX;
                else if (iOutput2 < OUTPUT4MIN)
                    iOutput2 = OUTPUT4MIN;

                lSamp = lPrediction + ((long)iDelta * iOutput2);
            
                if (lSamp > 32767)
                    lSamp = 32767;
                else if (lSamp < -32768)
                    lSamp = -32768;

                //
                //  compute the next iDelta
                //
                iDelta = adpcmCalcDelta(iOutput2,iDelta);

                //
                //  Save updated delay samples.
                //
                iSamp2 = iSamp1;
                iSamp1 = (int)lSamp;
            
            } else {
                iOutput2 = 0;
            }


            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutput1&OUTPUT4MASK)<<4) |
                                (iOutput2&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_M16_OnePass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_S08_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 iSamp1L;
    int                 iSamp2L;
    int                 iDeltaL;
    int                 iOutputL;

    int                 iSamp1R;
    int                 iSamp2R;
    int                 iDeltaR;
    int                 iOutputR;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;


    pbDstStart = pbDst;
    cSrcSamples = pcmS08BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)1;
        *pbDst++ = (BYTE)1;

        iDeltaL = DELTA4START;
        iDeltaR = DELTA4START;
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDeltaL.
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDeltaR.
        pbDst += sizeof(short);

        //
        //  Note that iSamp2 comes before iSamp1.  If we only have one
        //  sample, then set iSamp1 to zero.
        // 
        iSamp2L = pcmRead08(pbSrc++);
        iSamp2R = pcmRead08(pbSrc++);
        if( --cBlockSamples > 0 ) {
            iSamp1L = pcmRead08(pbSrc++);
            iSamp1R = pcmRead08(pbSrc++);
            cBlockSamples--;
        } else {
            iSamp1L = 0;
            iSamp1R = 0;
        }

        pcmWrite16Unaligned(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp1R);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp2R);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples-- )
        {
            //
            //  LEFT channel.
            //
            iSample = pcmRead08(pbSrc++);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1L<<1) - iSamp2L;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputL = (int)(lError / iDeltaL);
            if (iOutputL > OUTPUT4MAX)
                iOutputL = OUTPUT4MAX;
            else if (iOutputL < OUTPUT4MIN)
                iOutputL = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaL * iOutputL);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);

            //
            //  Save updated delay samples.
            //
            iSamp2L = iSamp1L;
            iSamp1L = (int)lSamp;


            //
            //  RIGHT channel.
            //
            iSample = pcmRead08(pbSrc++);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1R<<1) - iSamp2R;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputR = (int)(lError / iDeltaR);
            if (iOutputR > OUTPUT4MAX)
                iOutputR = OUTPUT4MAX;
            else if (iOutputR < OUTPUT4MIN)
                iOutputR = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaR * iOutputR);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);

            //
            //  Save updated delay samples.
            //
            iSamp2R = iSamp1R;
            iSamp1R = (int)lSamp;
            

            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutputL&OUTPUT4MASK)<<4) |
                                (iOutputR&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_S08_OnePass()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmEncode4Bit_S16_OnePass
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE              pbDstStart;
    DWORD               cSrcSamples;
    UINT                cBlockSamples;

    int                 iSamp1L;
    int                 iSamp2L;
    int                 iDeltaL;
    int                 iOutputL;

    int                 iSamp1R;
    int                 iSamp2R;
    int                 iDeltaR;
    int                 iOutputR;

    int                 iSample;
    long                lSamp;
    long                lError;
    long                lPrediction;


    pbDstStart = pbDst;
    cSrcSamples = pcmS16BytesToSamples(cbSrcLength);


    //
    //  step through each block of PCM data and encode it to 4 bit ADPCM
    //
    while( 0 != cSrcSamples )
    {
        //
        //  determine how much data we should encode for this block--this
        //  will be cSamplesPerBlock until we hit the last chunk of PCM
        //  data that will not fill a complete block. so on the last block
        //  we only encode that amount of data remaining...
        //
        cBlockSamples = (UINT)min(cSrcSamples, cSamplesPerBlock);
        cSrcSamples  -= cBlockSamples;


        //
        //  write the block header for the encoded data
        //
        //  the block header is composed of the following data:
        //      1 byte predictor per channel
        //      2 byte delta per channel
        //      2 byte first delayed sample per channel
        //      2 byte second delayed sample per channel
        //
        *pbDst++ = (BYTE)1;
        *pbDst++ = (BYTE)1;

        iDeltaL = DELTA4START;
        iDeltaR = DELTA4START;
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDeltaL.
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,DELTA4START);   // Same as iDeltaR.
        pbDst += sizeof(short);

        //
        //  Note that iSamp2 comes before iSamp1.  If we only have one
        //  sample, then set iSamp1 to zero.
        // 
        iSamp2L = pcmRead16(pbSrc);
        pbSrc += sizeof(short);
        iSamp2R = pcmRead16(pbSrc);
        pbSrc += sizeof(short);
        if( --cBlockSamples > 0 ) {
            iSamp1L = pcmRead16(pbSrc);
            pbSrc += sizeof(short);
            iSamp1R = pcmRead16(pbSrc);
            pbSrc += sizeof(short);
            cBlockSamples--;
        } else {
            iSamp1L = 0;
            iSamp1R = 0;
        }

        pcmWrite16Unaligned(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp1R);
        pbDst += sizeof(short);

        pcmWrite16Unaligned(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16Unaligned(pbDst,iSamp2R);
        pbDst += sizeof(short);


        //
        //  We have written the header for this block--now write the data
        //  chunk (which consists of a bunch of encoded nibbles).
        //
        while( cBlockSamples-- )
        {
            //
            //  LEFT channel.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1L<<1) - iSamp2L;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputL = (int)(lError / iDeltaL);
            if (iOutputL > OUTPUT4MAX)
                iOutputL = OUTPUT4MAX;
            else if (iOutputL < OUTPUT4MIN)
                iOutputL = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaL * iOutputL);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaL = adpcmCalcDelta(iOutputL,iDeltaL);

            //
            //  Save updated delay samples.
            //
            iSamp2L = iSamp1L;
            iSamp1L = (int)lSamp;


            //
            //  RIGHT channel.
            //
            iSample     = pcmRead16(pbSrc);
            pbSrc      += sizeof(short);

            //
            //  calculate the prediction based on the previous two samples
            //
            lPrediction = ((long)iSamp1R<<1) - iSamp2R;

            //
            //  encode the sample
            //
            lError = (long)iSample - lPrediction;
            iOutputR = (int)(lError / iDeltaR);
            if (iOutputR > OUTPUT4MAX)
                iOutputR = OUTPUT4MAX;
            else if (iOutputR < OUTPUT4MIN)
                iOutputR = OUTPUT4MIN;

            lSamp = lPrediction + ((long)iDeltaR * iOutputR);
            
            if (lSamp > 32767)
                lSamp = 32767;
            else if (lSamp < -32768)
                lSamp = -32768;

            //
            //  compute the next iDelta
            //
            iDeltaR = adpcmCalcDelta(iOutputR,iDeltaR);

            //
            //  Save updated delay samples.
            //
            iSamp2R = iSamp1R;
            iSamp1R = (int)lSamp;
            

            //
            //  Write out the encoded byte.
            //
            *pbDst++ = (BYTE)( ((iOutputL&OUTPUT4MASK)<<4) |
                                (iOutputR&OUTPUT4MASK)          );
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmEncode4Bit_S16_OnePass()




//==========================================================================;
//
//      DECODE ROUTINES
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD adpcmDecode4Bit_M08
//  DWORD adpcmDecode4Bit_M16
//  DWORD adpcmDecode4Bit_S08
//  DWORD adpcmDecode4Bit_S16
//
//  Description:
//      These functions decode a buffer of data from MS ADPCM to PCM in the
//      specified format.  The appropriate function is called once for each
//      ACMDM_STREAM_CONVERT message received.
//      
//
//  Arguments:
//      
//
//  Return (DWORD):  The number of bytes used in the destination buffer.
//
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmDecode4Bit_M08
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE  pbDstStart;
    UINT    cbHeader;
    UINT    cbBlockLength;

    UINT    nPredictor;
    BYTE    bSample;
    int     iInput;
    int     iSamp;

    int     iSamp1;
    int     iSamp2;
    int     iCoef1;
    int     iCoef2;
    int     iDelta;


    pbDstStart  = pbDst;
    cbHeader    = MSADPCM_HEADER_LENGTH * 1;  // 1 = number of channels.


    //
    //
    //
    while( cbSrcLength >= cbHeader )
    {
        //
        //  We have at least enough data to read a full block header.
        //
        //  the header looks like this:
        //      1 byte predictor per channel  (determines coefficients).
        //      2 byte delta per channel
        //      2 byte first sample per channel
        //      2 byte second sample per channel
        //
        //  this gives us (7 * bChannels) bytes of header information. note
        //  that as long as there is _at least_ (7 * bChannels) of header
        //  info, we will grab the two samples from the header.  We figure
        //  out how much data we have in the rest of the block, ie. whether
        //  we have a full block or not.  That way we don't have to test
        //  each sample to see if we have run out of data.
        //
        cbBlockLength   = (UINT)min(cbSrcLength,nBlockAlignment);
        cbSrcLength    -= cbBlockLength;
        cbBlockLength  -= cbHeader;
        
    
        //
        //  Process the block header.
        //
        nPredictor = (UINT)(BYTE)(*pbSrc++);
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1  = lpCoefSet[nPredictor].iCoef1;
        iCoef2  = lpCoefSet[nPredictor].iCoef2;
        
        iDelta  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);

        iSamp1  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);
        
        iSamp2  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);
        

        //
        //  write out first 2 samples.
        //
        //  NOTE: the samples are written to the destination PCM buffer
        //  in the _reverse_ order that they are in the header block:
        //  remember that iSamp2 is the _previous_ sample to iSamp1.
        //
        pcmWrite08(pbDst,iSamp2);
        pcmWrite08(pbDst,iSamp1);


        //
        //  we now need to decode the 'data' section of the ADPCM block.
        //  this consists of packed 4 bit nibbles.  The high-order nibble
        //  contains the first sample; the low-order nibble contains the
        //  second sample.
        //
        while( cbBlockLength-- )
        {
            bSample = *pbSrc++;

            //
            //  Sample 1.
            //
            iInput  = (int)(((signed char)bSample) >> 4);      //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1,iCoef1,
                                         iSamp2,iCoef2,
                                         iInput,iDelta );
            iDelta      = adpcmCalcDelta( iInput,iDelta );
            pcmWrite08(pbDst++,iSamp);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2 = iSamp1;
            iSamp1 = iSamp;
            

            //
            //  Sample 2.
            //
            iInput  = (int)(((signed char)(bSample<<4)) >> 4); //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1,iCoef1,
                                         iSamp2,iCoef2,
                                         iInput,iDelta );
            iDelta      = adpcmCalcDelta( iInput,iDelta );
            pcmWrite08(pbDst++,iSamp);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2 = iSamp1;
            iSamp1 = iSamp;
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmDecode4Bit_M08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmDecode4Bit_M16
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE  pbDstStart;
    UINT    cbHeader;
    UINT    cbBlockLength;

    UINT    nPredictor;
    BYTE    bSample;
    int     iInput;
    int     iSamp;

    int     iSamp1;
    int     iSamp2;
    int     iCoef1;
    int     iCoef2;
    int     iDelta;


    pbDstStart  = pbDst;
    cbHeader    = MSADPCM_HEADER_LENGTH * 1;  // 1 = number of channels.


    //
    //
    //
    while( cbSrcLength >= cbHeader )
    {
        //
        //  We have at least enough data to read a full block header.
        //
        //  the header looks like this:
        //      1 byte predictor per channel  (determines coefficients).
        //      2 byte delta per channel
        //      2 byte first sample per channel
        //      2 byte second sample per channel
        //
        //  this gives us (7 * bChannels) bytes of header information. note
        //  that as long as there is _at least_ (7 * bChannels) of header
        //  info, we will grab the two samples from the header.  We figure
        //  out how much data we have in the rest of the block, ie. whether
        //  we have a full block or not.  That way we don't have to test
        //  each sample to see if we have run out of data.
        //
        cbBlockLength   = (UINT)min(cbSrcLength,nBlockAlignment);
        cbSrcLength    -= cbBlockLength;
        cbBlockLength  -= cbHeader;
        
    
        //
        //  Process the block header.
        //
        nPredictor = (UINT)(BYTE)(*pbSrc++);
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1  = lpCoefSet[nPredictor].iCoef1;
        iCoef2  = lpCoefSet[nPredictor].iCoef2;
        
        iDelta  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);

        iSamp1  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);
        
        iSamp2  = pcmRead16Unaligned(pbSrc);
        pbSrc  += sizeof(short);
        

        //
        //  write out first 2 samples.
        //
        //  NOTE: the samples are written to the destination PCM buffer
        //  in the _reverse_ order that they are in the header block:
        //  remember that iSamp2 is the _previous_ sample to iSamp1.
        //
        pcmWrite16(pbDst,iSamp2);
        pbDst += sizeof(short);

        pcmWrite16(pbDst,iSamp1);
        pbDst += sizeof(short);


        //
        //  we now need to decode the 'data' section of the ADPCM block.
        //  this consists of packed 4 bit nibbles.  The high-order nibble
        //  contains the first sample; the low-order nibble contains the
        //  second sample.
        //
        while( cbBlockLength-- )
        {
            bSample = *pbSrc++;

            //
            //  Sample 1.
            //
            iInput  = (int)(((signed char)bSample) >> 4);      //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1,iCoef1,
                                         iSamp2,iCoef2,
                                         iInput,iDelta );
            iDelta      = adpcmCalcDelta( iInput,iDelta );
            pcmWrite16(pbDst,iSamp);
            pbDst += sizeof(short);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2 = iSamp1;
            iSamp1 = iSamp;
            

            //
            //  Sample 2.
            //
            iInput  = (int)(((signed char)(bSample<<4)) >> 4); //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1,iCoef1,
                                         iSamp2,iCoef2,
                                         iInput,iDelta );
            iDelta      = adpcmCalcDelta( iInput,iDelta );
            pcmWrite16(pbDst,iSamp);
            pbDst += sizeof(short);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2 = iSamp1;
            iSamp1 = iSamp;
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmDecode4Bit_M16()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmDecode4Bit_S08
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE  pbDstStart;
    UINT    cbHeader;
    UINT    cbBlockLength;

    UINT    nPredictor;
    BYTE    bSample;
    int     iInput;
    int     iSamp;

    int     iSamp1L;
    int     iSamp2L;
    int     iCoef1L;
    int     iCoef2L;
    int     iDeltaL;

    int     iSamp1R;
    int     iSamp2R;
    int     iCoef1R;
    int     iCoef2R;
    int     iDeltaR;


    pbDstStart  = pbDst;
    cbHeader    = MSADPCM_HEADER_LENGTH * 2;  // 2 = number of channels.


    //
    //
    //
    while( cbSrcLength >= cbHeader )
    {
        //
        //  We have at least enough data to read a full block header.
        //
        //  the header looks like this:
        //      1 byte predictor per channel  (determines coefficients).
        //      2 byte delta per channel
        //      2 byte first sample per channel
        //      2 byte second sample per channel
        //
        //  this gives us (7 * bChannels) bytes of header information. note
        //  that as long as there is _at least_ (7 * bChannels) of header
        //  info, we will grab the two samples from the header.  We figure
        //  out how much data we have in the rest of the block, ie. whether
        //  we have a full block or not.  That way we don't have to test
        //  each sample to see if we have run out of data.
        //
        cbBlockLength   = (UINT)min(cbSrcLength,nBlockAlignment);
        cbSrcLength    -= cbBlockLength;
        cbBlockLength  -= cbHeader;
        
    
        //
        //  Process the block header.
        //
        nPredictor = (UINT)(BYTE)(*pbSrc++);            // Left.
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1L = lpCoefSet[nPredictor].iCoef1;
        iCoef2L = lpCoefSet[nPredictor].iCoef2;
        
        nPredictor = (UINT)(BYTE)(*pbSrc++);            // Right.
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1R = lpCoefSet[nPredictor].iCoef1;
        iCoef2R = lpCoefSet[nPredictor].iCoef2;
        
        iDeltaL = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);

        iDeltaR = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);

        iSamp1L = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);
        
        iSamp1R = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);
        
        iSamp2L = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);
        
        iSamp2R = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);
        

        //
        //  write out first 2 samples (per channel).
        //
        //  NOTE: the samples are written to the destination PCM buffer
        //  in the _reverse_ order that they are in the header block:
        //  remember that iSamp2 is the _previous_ sample to iSamp1.
        //
        pcmWrite08(pbDst++,iSamp2L);
        pcmWrite08(pbDst++,iSamp2R);
        pcmWrite08(pbDst++,iSamp1L);
        pcmWrite08(pbDst++,iSamp1R);


        //
        //  we now need to decode the 'data' section of the ADPCM block.
        //  this consists of packed 4 bit nibbles.  The high-order nibble
        //  contains the left sample; the low-order nibble contains the
        //  right sample.
        //
        while( cbBlockLength-- )
        {
            bSample = *pbSrc++;

            //
            //  Left sample.
            //
            iInput  = (int)(((signed char)bSample) >> 4);      //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1L,iCoef1L,
                                         iSamp2L,iCoef2L,
                                         iInput,iDeltaL );
            iDeltaL     = adpcmCalcDelta( iInput,iDeltaL );
            pcmWrite08(pbDst++,iSamp);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2L = iSamp1L;
            iSamp1L = iSamp;
            

            //
            //  Right sample.
            //
            iInput  = (int)(((signed char)(bSample<<4)) >> 4); //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1R,iCoef1R,
                                         iSamp2R,iCoef2R,
                                         iInput,iDeltaR );
            iDeltaR     = adpcmCalcDelta( iInput,iDeltaR );
            pcmWrite08(pbDst++,iSamp);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2R = iSamp1R;
            iSamp1R = iSamp;
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmDecode4Bit_S08()



//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

DWORD FNGLOBAL adpcmDecode4Bit_S16
(
    HPBYTE              pbSrc,
    DWORD               cbSrcLength,
    HPBYTE              pbDst,
    UINT                nBlockAlignment,
    UINT                cSamplesPerBlock,
    UINT                nNumCoef,
    LPADPCMCOEFSET      lpCoefSet
)
{
    HPBYTE  pbDstStart;
    UINT    cbHeader;
    UINT    cbBlockLength;

    UINT    nPredictor;
    BYTE    bSample;
    int     iInput;
    int     iSamp;

    int     iSamp1L;
    int     iSamp2L;
    int     iCoef1L;
    int     iCoef2L;
    int     iDeltaL;

    int     iSamp1R;
    int     iSamp2R;
    int     iCoef1R;
    int     iCoef2R;
    int     iDeltaR;


    pbDstStart  = pbDst;
    cbHeader    = MSADPCM_HEADER_LENGTH * 2;  // 2 = number of channels.


    //
    //
    //
    while( cbSrcLength >= cbHeader )
    {
        //
        //  We have at least enough data to read a full block header.
        //
        //  the header looks like this:
        //      1 byte predictor per channel  (determines coefficients).
        //      2 byte delta per channel
        //      2 byte first sample per channel
        //      2 byte second sample per channel
        //
        //  this gives us (7 * bChannels) bytes of header information. note
        //  that as long as there is _at least_ (7 * bChannels) of header
        //  info, we will grab the two samples from the header.  We figure
        //  out how much data we have in the rest of the block, ie. whether
        //  we have a full block or not.  That way we don't have to test
        //  each sample to see if we have run out of data.
        //
        cbBlockLength   = (UINT)min(cbSrcLength,nBlockAlignment);
        cbSrcLength    -= cbBlockLength;
        cbBlockLength  -= cbHeader;
        
    
        //
        //  Process the block header.
        //
        nPredictor = (UINT)(BYTE)(*pbSrc++);            // Left.
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1L = lpCoefSet[nPredictor].iCoef1;
        iCoef2L = lpCoefSet[nPredictor].iCoef2;
        
        nPredictor = (UINT)(BYTE)(*pbSrc++);            // Right.
        if( nPredictor >= nNumCoef )
        {
            //
            //  the predictor is out of range--this is considered a
            //  fatal error with the ADPCM data, so we fail by returning
            //  zero bytes decoded
            //
            return 0;
        }
        iCoef1R = lpCoefSet[nPredictor].iCoef1;
        iCoef2R = lpCoefSet[nPredictor].iCoef2;
        
        iDeltaL = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);

        iDeltaR = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);

        iSamp1L = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);
        
        iSamp1R = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);
        
        iSamp2L = pcmRead16Unaligned(pbSrc);            // Left.
        pbSrc  += sizeof(short);
        
        iSamp2R = pcmRead16Unaligned(pbSrc);            // Right.
        pbSrc  += sizeof(short);
        

        //
        //  write out first 2 samples (per channel).
        //
        //  NOTE: the samples are written to the destination PCM buffer
        //  in the _reverse_ order that they are in the header block:
        //  remember that iSamp2 is the _previous_ sample to iSamp1.
        //
        pcmWrite16(pbDst,iSamp2L);
        pbDst += sizeof(short);
        pcmWrite16(pbDst,iSamp2R);
        pbDst += sizeof(short);
        pcmWrite16(pbDst,iSamp1L);
        pbDst += sizeof(short);
        pcmWrite16(pbDst,iSamp1R);
        pbDst += sizeof(short);


        //
        //  we now need to decode the 'data' section of the ADPCM block.
        //  this consists of packed 4 bit nibbles.  The high-order nibble
        //  contains the left sample; the low-order nibble contains the
        //  right sample.
        //
        while( cbBlockLength-- )
        {
            bSample = *pbSrc++;

            //
            //  Left sample.
            //
            iInput  = (int)(((signed char)bSample) >> 4);      //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1L,iCoef1L,
                                         iSamp2L,iCoef2L,
                                         iInput,iDeltaL );
            iDeltaL     = adpcmCalcDelta( iInput,iDeltaL );
            pcmWrite16(pbDst,iSamp);
            pbDst += sizeof(short);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2L = iSamp1L;
            iSamp1L = iSamp;
            

            //
            //  Right sample.
            //
            iInput  = (int)(((signed char)(bSample<<4)) >> 4); //Sign-extend.
            iSamp   = adpcmDecodeSample( iSamp1R,iCoef1R,
                                         iSamp2R,iCoef2R,
                                         iInput,iDeltaR );
            iDeltaR     = adpcmCalcDelta( iInput,iDeltaR );
            pcmWrite16(pbDst,iSamp);
            pbDst += sizeof(short);
                
            //
            //  ripple our previous samples down making the new iSamp1
            //  equal to the sample we just decoded
            //
            iSamp2R = iSamp1R;
            iSamp1R = iSamp;
        }
    }

    //
    //  We return the number of bytes used in the destination.  This is
    //  simply the difference in bytes from where we started.
    //
    return (DWORD)(pbDst - pbDstStart);

} // adpcmDecode4Bit_S16()
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msfilter\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "MSFILTER"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msfilter\init.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  init.c
//
//  Description:
//      This file contains module initialization routines.  Note that there
//      is no module initialization for Win32.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "codec.h"
#include "debug.h"


//==========================================================================;
//
//  WIN 16 SPECIFIC SUPPORT
//
//==========================================================================;

#ifndef WIN32

//--------------------------------------------------------------------------;
//
//  int LibMain
//
//  Description:
//      Library initialization code.
//
//  Arguments:
//      HINSTANCE hinst: Our module handle.
//
//      WORD wDataSeg: Specifies the DS value for this DLL.
//
//      WORD cbHeapSize: The heap size from the .def file.
//
//      LPSTR pszCmdLine: The command line.
//
//  Return (int):
//      Returns non-zero if the initialization was successful and 0 otherwise.
//
//  History:
//      11/15/92    Created. 
//
//--------------------------------------------------------------------------;

int FNGLOBAL LibMain
(
    HINSTANCE               hinst, 
    WORD                    wDataSeg, 
    WORD                    cbHeapSize,
    LPSTR                   pszCmdLine
)
{
    DbgInitialize(TRUE);

    //
    //  if debug level is 5 or greater, then do a DebugBreak() to debug
    //  loading of this driver
    //
    DPF(1, "LibMain(hinst=%.4Xh, wDataSeg=%.4Xh, cbHeapSize=%u, pszCmdLine=%.8lXh)",
        hinst, wDataSeg, cbHeapSize, pszCmdLine);
    DPF(5, "!*** break for debugging ***");

    return (TRUE);
} // LibMain()


//--------------------------------------------------------------------------;
//  
//  int WEP
//  
//  Description:
//  
//  
//  Arguments:
//      WORD wUselessParam:
//  
//  Return (int):
//  
//  History:
//      03/28/93    Created.
//  
//--------------------------------------------------------------------------;

EXTERN_C int FNEXPORT WEP
(
    WORD                    wUselessParam
)
{
    DPF(1, "WEP(wUselessParam=%u)", wUselessParam);

    //
    //  always return 1.
    //
    return (1);
} // WEP()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msfilter\codec.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.h
//
//  Description:
//      This file contains codec definitions, Win16/Win32 compatibility
//      definitions, and instance structure definitions.
//
//
//==========================================================================;

#ifndef _INC_CODEC
#define _INC_CODEC                  // #defined if codec.h has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(4,  0, 0)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 51, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(2, 1, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16/32 portability stuff...
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge


    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE                   CONST

    #define HUGE                    UNALIGNED
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//
//  This define deals with unaligned data for Win32, and huge data for Win16.
//  Basically, any time you cast an HPBYTE to a non-byte variable (ie long or
//  short), you should cast it to (UNALIGNED *) for WIN32.  This will make
//  sure that there are no alignment problems for Win32 on MIPA and Alpha
//  machines.
//

typedef BYTE HUGE *HPBYTE;

#ifdef WIN32
    typedef short UNALIGNED *HPSHORT;
#else
    typedef short HUGE *HPSHORT;
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwf argument is a pointer to a PCMWAVEFORMAT structure.
//
#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    LPDRVCONFIGINFO pdci;
    DWORD           fdwConfig;      // driver instance configuration flags

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//
//
//
typedef LRESULT (FNGLOBAL *STREAMCONVERTPROC)
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags


    //
    //  only used on echo filter..
    //
    HPBYTE              hpbHistory;
    DWORD               dwPlace;
    DWORD	        	dwHistoryDone;
} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ICON_ACM_DRIVER             RCID(10)

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures

//
//  ACMFILTERTAGDETAILS.szFilterTag
//
//
#define IDS_ACM_DRIVER_TAG_NAME_VOLUME  (20)
#define IDS_ACM_DRIVER_FORMAT_VOLUME    (21)

//
//  ACMFILTERTAGDETAILS.szFilterTag
//
//
#define IDS_ACM_DRIVER_TAG_NAME_ECHO    (40)
#define IDS_ACM_DRIVER_FORMAT_ECHO      (41)

//
//  About dialog box IDs
//
#define IDD_ABOUT                   RCID(100)
#define IDC_STATIC                  -1
#define IDC_ABOUT_CATCHTHEWAVE      1001



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_CODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msfilter\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code to support easy-to-use debugging support
//      which works for both Win16 and Win32.  All code compiles to
//      nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
#if DBG
        DebugBreak();
#endif
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msfilter\msfilter.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  msfilter.h
//
//  Description:
//      This file contains prototypes for the filtering routines.
//
//
//==========================================================================;

#ifndef _MSFILTER_H_
#define _MSFILTER_H_

#ifdef __cplusplus
extern "C"
{
#endif


#define MSFILTER_MAX_CHANNELS   2   // max number of channels allowed
 
//
//  function prototypes from MSFILTER.C
//
// 
LRESULT FNGLOBAL msfilterVolume
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    pdsh
);

LRESULT FNGLOBAL msfilterEcho
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    pdsh
);


#ifdef __cplusplus
}
#endif

#endif // _MSFILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msfilter\codec.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1999 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  codec.c
//
//  Description:
//      This file contains the DriverProc and other routines which respond
//      to ACM messages.
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <memory.h>

#include "codec.h"
#include "msfilter.h"

#include "debug.h"


//
//  array of WAVE format tags supported.
//
//  NOTE! if you change anything in this structure (order, addition, removal)
//  you must also fix acmdFormatTagDetails!
//
const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM
};

#define ACM_DRIVER_MAX_FORMAT_TAGS  SIZEOF_ARRAY(gauFormatTagIndexToTag)


//
//  array of _standard_ sample rates supported
//
//
const UINT gauFormatIndexToSampleRate[] =
{
    8000,
    11025,
    22050,
    44100
};

#define ACM_DRIVER_MAX_SAMPLE_RATES SIZEOF_ARRAY(gauFormatIndexToSampleRate)

//
//
//
//
#define ACM_DRIVER_MAX_CHANNELS     (MSFILTER_MAX_CHANNELS)


//
//  array of bits per sample supported
//
//
const UINT gauFormatIndexToBitsPerSample[] =
{
    8,
    16
};

#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM    SIZEOF_ARRAY(gauFormatIndexToBitsPerSample)


//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_STANDARD_FORMATS_PCM (ACM_DRIVER_MAX_SAMPLE_RATES *  \
                                             ACM_DRIVER_MAX_CHANNELS *      \
                                             ACM_DRIVER_MAX_BITSPERSAMPLE_PCM)


//
//  Array of WAVE filter tags supported.
//
const DWORD gadwFilterTagIndexToTag[] =
{
    WAVE_FILTER_VOLUME,
    WAVE_FILTER_ECHO
};

#define ACM_DRIVER_MAX_FILTER_TAGS          SIZEOF_ARRAY(gadwFilterTagIndexToTag)


//
//  Array of filters supported.
//
const DWORD gdwFilterIndexToVolume[] =
{
    0x00001000,
    0x00002000,
    0x00004000,
    0x00006000,
    0x00008000,
    0x0000A000,
    0x0000C000,
    0x0000E000,
    0x0000F000,
    0x00011000,
    0x00012000,
    0x00014000,
    0x00016000,
    0x00018000,
    0x0001A000,
    0x0001C000,
    0x00020000
};
#define ACM_DRIVER_MAX_VOLUME_FILTERS   SIZEOF_ARRAY(gdwFilterIndexToVolume)

const DWORD gdwFilterIndexToDelay[] =
{
    0x00000040,
    0x00000080,
    0x00000100,
    0x00000180,
    0x00000200,
    0x00000300,
    0x00000400,
    0x00000800,
};
#define ACM_DRIVER_NUM_DELAY            SIZEOF_ARRAY(gdwFilterIndexToDelay)

const DWORD gdwFilterIndexToEchoVol[] =
{
    0x00001000,
    0x00002000,
    0x00004000,
    0x00008000,
    0x0000C000
};
#define ACM_DRIVER_NUM_ECHOVOL          SIZEOF_ARRAY(gdwFilterIndexToEchoVol)

#define ACM_DRIVER_MAX_ECHO_FILTERS     (ACM_DRIVER_NUM_DELAY *     \
                                         ACM_DRIVER_NUM_ECHOVOL)



//==========================================================================;
//
//  SUPPORT ROUTINES FOR COMMON-BINARY CODECS.
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // WIN32


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that _this_ ACM driver can deal with.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX  pwfx
)
{
    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
        return (FALSE);

    //
    //  verify nChannels member is within the allowed range
    //
    if ((pwfx->nChannels < 1) || (pwfx->nChannels > ACM_DRIVER_MAX_CHANNELS))
        return (FALSE);

    //
    //  only allow the bits per sample that we can encode and decode with
    //
    if ((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))
        return (FALSE);

    //
    //  now verify that the block alignment is correct..
    //
    if (PCM_BLOCKALIGNMENT(pwfx) != pwfx->nBlockAlign)
        return (FALSE);

    //
    //  verify samples per second is within our capabilities
    //
    if ((0L == pwfx->nSamplesPerSec) || (0x3FFFFFFF < pwfx->nSamplesPerSec))
    {
        return (FALSE);
    }

    //
    //  finally, verify that avg bytes per second is correct
    //
    if (PCM_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
        return (FALSE);

    return (TRUE);
} // pcmIsValidFormat()


//--------------------------------------------------------------------------;
//
//  BOOL volumeIsValidFilter
//
//  Description:
//      This function verifies that a wave filter header is a valid volume
//      header that our volume converter can deal with.
//
//  Arguments:
//      LPWAVEFILTER pwf: Pointer to filter header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//  History:
//      06/05/93    Created.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL volumeIsValidFilter
(
    LPWAVEFILTER  pwf
)
{
    if (!pwf)
        return (FALSE);

    if (pwf->cbStruct < sizeof(VOLUMEWAVEFILTER))
        return (FALSE);

    if (pwf->dwFilterTag != WAVE_FILTER_VOLUME)
        return (FALSE);

    if (0L != pwf->fdwFilter)
        return (FALSE);

    return (TRUE);
} // volumeIsValidFilter()



//--------------------------------------------------------------------------;
//
//  BOOL echoIsValidFilter
//
//  Description:
//      This function verifies that a wave filter header is a valid echo
//      header that our echo converter can deal with.
//
//  Arguments:
//      LPWAVEFILTER pwf: Pointer to filter header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//  History:
//      06/05/93    Created.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL echoIsValidFilter
(
    LPWAVEFILTER  pwf
)
{
    LPECHOWAVEFILTER    pwfEcho;

    if (!pwf)
        return (FALSE);

    if (pwf->cbStruct < sizeof(ECHOWAVEFILTER))
        return (FALSE);

    if (pwf->dwFilterTag != WAVE_FILTER_ECHO)
        return (FALSE);

    if (0L != pwf->fdwFilter)
        return (FALSE);

    pwfEcho = (LPECHOWAVEFILTER)pwf;
    // We only support a delay value up to 10 sec or 10 000 msec.
    if (pwfEcho->dwDelay > 10000L)
        return (FALSE);

    return (TRUE);
} // echoIsValidFilter()


//==========================================================================;
//
//
//
//
//==========================================================================;


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

    //
    //  the [optional] open description that is passed to this driver can
    //  be from multiple 'managers.' for example, AVI looks for installable
    //  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
    //  that we are being opened as an Audio Compression Manager driver.
    //
    //  if paod is NULL, then the driver is being opened for some purpose
    //  other than converting (that is, there will be no stream open
    //  requests for this instance of being opened). the most common case
    //  of this is the Control Panel's Drivers option checking for config
    //  support (DRV_[QUERY]CONFIGURE).
    //
    //  we want to succeed this open, but be able to know that this
    //  open instance is bogus for creating streams. for this purpose we
    //  leave most of the members of our instance structure that we
    //  allocate below as zero...
    //
    if (NULL != paod)
    {
        //
        //  refuse to open if we are not being opened as an ACM driver.
        //  note that we do NOT modify the value of paod->dwError in this
        //  case.
        //
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
        {
            return (0L);
        }
    }


    //
    //  we are being opened as an installable driver--we can allocate some
    //  instance data to be returned in dwId argument of the DriverProc;
    //  or simply return non-zero to succeed the open.
    //
    //  this driver allocates a small instance structure. note that we
    //  rely on allocating the memory as zero-initialized!
    //
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
        //
        //  if this open attempt was as an ACM driver, then return the
        //  reason we are failing in the open description structure..
        //
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        //
        //  fail to open
        //
        return (0L);
    }


    //
    //  fill in our instance structure... note that this instance data
    //  can be anything that the ACM driver wishes to maintain the
    //  open driver instance. this data should not contain any information
    //  that must be maintained per open stream since multiple streams
    //  can be opened on a single driver instance.
    //
    //  also note that we do _not_ check the version of the ACM opening
    //  us (paod->dwVersion) to see if it is at least new enough to work
    //  with this driver (for example, if this driver required Version 3.0
    //  of the ACM and a Version 2.0 installation tried to open us). the
    //  reason we do not fail is to allow the ACM to get the driver details
    //  which contains the version of the ACM that is _required_ by this
    //  driver. the ACM will examine that value (in padd->vdwACM) and
    //  do the right thing for this driver... like not load it and inform
    //  the user of the problem.
    //
    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;

        paod->dwError     = MMSYSERR_NOERROR;
    }


    //
    //  non-zero return is success for DRV_OPEN
    //
    return ((LRESULT)pdi);
} // acmdDriverOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
    //
    //  check to see if we allocated instance data. if we did not, then
    //  immediately succeed.
    //
    if (NULL != pdi)
    {
        //
        //  close down the driver instance. this driver simply needs
        //  to free the instance data structure... note that if this
        //  'free' fails, then this ACM driver probably trashed its
        //  heap; assume we didn't do that.
        //
        LocalFree((HLOCAL)pdi);
    }


    //
    //  non-zero return is success for DRV_CLOSE
    //
    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver does not support a configuration dialog box, so
        //  return zero...
        //
        return (0L);
    }


    //
    //  we are being asked to bring up our configuration dialog. if this
    //  driver supports a configuration dialog box, then after the dialog
    //  is dismissed we must return one of the following values:
    //
    //  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
    //  and canceled by the user. this value should also be returned if
    //  no configuration information was modified.
    //
    //  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
    //  the user pressed OK.  This value should be returned even if the
    //  user didn't change anything - otherwise, the driver may not
    //  install properly.
    //
    //  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
    //  and some configuration information was changed that requires
    //  Windows to be restarted before the changes take affect. the driver
    //  should remain configured with current values until the driver
    //  has been 'rebooted'.
    //
    //
    return (DRVCNF_CANCEL);
} // acmdDriverConfigure()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

    //
    //  it is easiest to fill in a temporary structure with valid info
    //  and then copy the requested number of bytes to the destination
    //  buffer.
    //
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


    //
    //  for the current implementation of an ACM driver, the fccType and
    //  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
    //  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
    //
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


    //
    //  the manufacturer id (wMid) and product id (wPid) must be filled
    //  in with your company's _registered_ identifier's. for more
    //  information on these identifier's and how to get them registered
    //  contact Microsoft and get the Multimedia Developer Registration Kit:
    //
    //      Microsoft Corporation
    //      Multimedia Technology Group
    //      One Microsoft Way
    //      Redmond, WA 98052-6399
    //
    //      Developer Services Phone: (800) 227-4679 x11771
    //
    //  note that during the development phase or your ACM driver, you may
    //  use the reserved value of '0' for both wMid and wPid. however it
    //  is not acceptable to ship a driver with these values.
    //
    add.wMid            = MM_MICROSOFT;
    add.wPid            = MM_MSFT_ACM_MSFILTER;


    //
    //  the vdwACM and vdwDriver members contain version information for
    //  the driver.
    //
    //  vdwACM: must contain the version of the *ACM* that the driver was
    //  _designed_ for. this is the _minimum_ version number of the ACM
    //  that the driver will work with. this value must be >= V2.00.000.
    //
    //  vdwDriver: the version of this ACM driver.
    //
    //  ACM driver versions are 32 bit numbers broken into three parts as
    //  follows (note these parts are displayed as decimal values):
    //
    //      bits 24 - 31:   8 bit _major_ version number
    //      bits 16 - 23:   8 bit _minor_ version number
    //      bits  0 - 15:   16 bit build number
    //
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


    //
    //  the following flags are used to specify the type of conversion(s)
    //  that the ACM driver supports. note that a driver may support one or
    //  more of these flags in any combination.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver
    //  supports conversions from one format tag to another format tag. for
    //  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
    //  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
    //  true even if the data is not actually changed in size--for example
    //  a conversion from u-Law to A-Law will still set this bit because
    //  the format tags differ.
    //
    //  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
    //  driver supports conversions on the same format tag. as an example,
    //  the PCM converter that is built into the ACM sets this bit (and only
    //  this bit) because it converts only between PCM formats (bits, sample
    //  rate).
    //
    //  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver
    //  supports transformations on a single format tag but does change
    //  the base characteristics of the format (bit depth, sample rate, etc
    //  will remain the same). for example, a driver that changed the
    //  'volume' of PCM data or applied a low pass filter would set this bit.
    //
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_FILTER;


    //
    //  the number of individual format tags this ACM driver supports. for
    //  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
    //  WAVE_FORMAT_PCM format tags, then this value would be two. if the
    //  driver only supports filtering on WAVE_FORMAT_PCM, then this value
    //  would be one. if this driver supported WAVE_FORMAT_ALAW,
    //  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
    //  three. etc, etc.
    //
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

    //
    //  the number of individual filter tags this ACM driver supports. if
    //  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
    //  NOT set in the fdwSupport member), then this value must be zero.
    //
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


    //
    //  the remaining members in the ACMDRIVERDETAILS structure are sometimes
    //  not needed. because of this we make a quick check to see if we
    //  should go through the effort of filling in these members.
    //
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
        //
        //  fill in the hicon member will a handle to a custom icon for
        //  the ACM driver. this allows the driver to be represented by
        //  an application graphically (usually this will be a company
        //  logo or something). if a driver does not wish to have a custom
        //  icon displayed, then simply set this member to NULL and a
        //  generic icon will be displayed instead.
        //
        add.hicon = LoadIcon(pdi->hinst, ICON_ACM_DRIVER);

        //
        //  the short name and long name are used to represent the driver
        //  in a unique description. the short name is intended for small
        //  display areas (for example, in a menu or combo box). the long
        //  name is intended for more descriptive displays (for example,
        //  in an 'about box').
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
    	LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

        //
        //  the last three members are intended for 'about box' information.
        //  these members are optional and may be zero length strings if
        //  the driver wishes.
        //
        //  NOTE! an ACM driver should never place formatting characters
        //  of any sort in these strings (for example CR/LF's, etc). it
        //  is up to the application to format the text.
        //
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


    //
    //  now copy the correct number of bytes to the caller's buffer
    //
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


    //
    //  success!
    //
    return (MMSYSERR_NOERROR);
} // acmdDriverDetails()


//--------------------------------------------------------------------------;
//
//  INT_PTR acmdDlgProcAbout
//
//  Description:
//
//      This dialog procedure is used for the ubiquitous about box.
//
//      Note that we need to create a brush and store the handle between
//      messages.  In order to avoid using global memory, we store the
//      handle to this brush in the Window structure using the DWLP_USER
//      index.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (INT_PTR):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.  Note, however, that we must return an HBRUSH for Windows
//      to use for painting the background for the WM_CTLCOLORxxx messages.
//
//
//--------------------------------------------------------------------------;

#define ABOUT_BACKGROUNDCOLOR                   RGB(128,128,128)
#define ABOUT_HILIGHTCOLOR                      RGB(0,255,255)

INT_PTR FNEXPORT acmdDlgProcAbout
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    HBRUSH      hbr;
    HWND        hctrl;
    UINT        u;


    hbr = (HBRUSH)GetWindowLongPtr( hwnd, DWLP_USER );

    switch (uMsg)
    {
        case WM_INITDIALOG:
            hbr = CreateSolidBrush( ABOUT_BACKGROUNDCOLOR );
            SetWindowLongPtr( hwnd, DWLP_USER, (LONG_PTR)hbr );
            return TRUE;

        case WM_CTLCOLORSTATIC:
            hctrl = GetDlgItem( hwnd, IDC_ABOUT_CATCHTHEWAVE );
            if( (HWND)lParam == hctrl )
            {
                SetTextColor( (HDC)wParam, ABOUT_HILIGHTCOLOR );
            }
            // Fall through...

        case WM_CTLCOLORDLG:
        case WM_CTLCOLORBTN:
            SetBkColor( (HDC)wParam, ABOUT_BACKGROUNDCOLOR );
            return (INT_PTR)hbr;

        case WM_COMMAND:
            u = GET_WM_COMMAND_ID(wParam, lParam);
            if ((IDOK == u) || (IDCANCEL == u))
            {
                EndDialog(hwnd, (IDOK == u));
            }
            return FALSE;

        case WM_DESTROY:
            DeleteObject( hbr );
            return FALSE;
    }

    return (FALSE);
} // acmdDlgProcAbout()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
    //
    //  first check to see if we are only being queried for custom about
    //  box support. if hwnd == (HWND)-1 then we are being queried and
    //  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
    //  MMSYSERR_NOERROR for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
        //
        //  this ACM driver supports a custom about box, so
        //  return MMSYSERR_NOERROR...
        //
        return (MMSYSERR_NOERROR);
    }


    //
    //  this driver does support a custom dialog, so display it.  Note,
    //  however, that it is better to let the ACM display the About box
    //  for us - that means smaller code, and fewer bugs!
    //
    DialogBox( pdi->hinst, IDD_ABOUT, hwnd, acmdDlgProcAbout );

    return (MMSYSERR_NOERROR);
} // acmdDriverAbout()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatTagDetails
//
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    //
    //
    //
    //
    //
    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant format.  return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            if (WAVE_FORMAT_PCM != padft->dwFormatTag)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = WAVE_FORMAT_PCM;
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_FILTER;
            padft->cStandardFormats = ACM_DRIVER_MAX_STANDARD_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0]   =  '\0';
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatDetails
//
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX      pwfx;
    UINT                uFormatIndex;
    UINT                u;


    //
    //
    //
    //
    //
    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            //
            //  verify that the format tag is something we know about
            //
            if (WAVE_FORMAT_PCM != padf->dwFormatTag)
                return (ACMERR_NOTPOSSIBLE);

            if (ACM_DRIVER_MAX_STANDARD_FORMATS_PCM <= padf->dwFormatIndex)
                return (ACMERR_NOTPOSSIBLE);

            //
            //  put some stuff in more accessible variables--note that we
            //  bring variable sizes down to a reasonable size for 16 bit
            //  code...
            //
            pwfx = padf->pwfx;
            uFormatIndex = (UINT)padf->dwFormatIndex;

            //
            //  now fill in the format structure
            //
            pwfx->wFormatTag      = WAVE_FORMAT_PCM;

            u = uFormatIndex / (ACM_DRIVER_MAX_BITSPERSAMPLE_PCM * ACM_DRIVER_MAX_CHANNELS);
            pwfx->nSamplesPerSec  = gauFormatIndexToSampleRate[u];

            u = uFormatIndex % ACM_DRIVER_MAX_CHANNELS;
            pwfx->nChannels       = u + 1;

            u = (uFormatIndex / ACM_DRIVER_MAX_CHANNELS) % ACM_DRIVER_MAX_CHANNELS;
            pwfx->wBitsPerSample  = (WORD)gauFormatIndexToBitsPerSample[u];

            pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
            pwfx->nAvgBytesPerSec = PCM_AVGBYTESPERSEC(pwfx);


            //
            //  note that the cbSize field is NOT valid for PCM formats
            //
            //  pwfx->cbSize      = 0;
            break;


        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            if (!pcmIsValidFormat(padf->pwfx))
                return (ACMERR_NOTPOSSIBLE);

            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return the size of the valid information we are returning
    //
    //  the ACM will guarantee that the ACMFORMATDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    //  note that we let the ACM create the format string for us since
    //  we require no special formatting (and don't want to deal with
    //  internationalization issues, etc). simply set the string to
    //  a zero length.
    //
    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_FILTER;
    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdFilterTagDetails
//
//  Description:
//
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFILTERTAGDETAILS padft:
//
//      DWORD fdwDetails:
//
//  Return (LRESULT):
//
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFilterTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFILTERTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uIds;
    UINT                uFilterTag;

    //
    //
    //
    //
    //
    switch (ACM_FILTERTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FILTERTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a
            //  non-existant filter.  return error.
            //
            if (ACM_DRIVER_MAX_FILTER_TAGS <= padft->dwFilterTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFilterTag = (UINT)gadwFilterTagIndexToTag[(UINT)padft->dwFilterTagIndex];
            break;


        case ACM_FILTERTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFilterTag)
            {
                case WAVE_FILTER_UNKNOWN:
                case WAVE_FILTER_ECHO:
                    uFilterTag = WAVE_FILTER_ECHO;
                    break;

                case WAVE_FILTER_VOLUME:
                    uFilterTag = WAVE_FILTER_VOLUME;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FILTERTAGDETAILSF_FILTERTAG:
            switch (padft->dwFilterTag)
            {
                case WAVE_FILTER_VOLUME:
                    uFilterTag = WAVE_FILTER_VOLUME;
                    break;

                case WAVE_FILTER_ECHO:
                    uFilterTag = WAVE_FILTER_ECHO;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFilterTag)
    {
        case WAVE_FILTER_VOLUME:
            padft->dwFilterTagIndex = 0;
            padft->dwFilterTag      = WAVE_FILTER_VOLUME;
            padft->cbFilterSize     = sizeof(VOLUMEWAVEFILTER);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_FILTER;
            padft->cStandardFilters = ACM_DRIVER_MAX_VOLUME_FILTERS;

            uIds = IDS_ACM_DRIVER_TAG_NAME_VOLUME;
            break;

        case WAVE_FILTER_ECHO:
            padft->dwFilterTagIndex = 1;
            padft->dwFilterTag      = WAVE_FILTER_ECHO;
            padft->cbFilterSize     = sizeof(ECHOWAVEFILTER);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_FILTER;
            padft->cStandardFilters = ACM_DRIVER_MAX_ECHO_FILTERS;

            uIds = IDS_ACM_DRIVER_TAG_NAME_ECHO;
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFILTERTAGDETAILS structure
    //  passed is at least large enough to hold the base structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));

    LoadStringCodec(pdi->hinst, uIds, padft->szFilterTag, SIZEOFACMSTR(padft->szFilterTag));


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFilterTagDetails()


//--------------------------------------------------------------------------;
//
//  UINT acmdFilterDetailsToString
//
//  Description:
//      This function has a special UNICODE string implementation for common
//      binary codecs between Chicago and Daytona.
//
//  Arguments:
//      LPWAVEFILTER pwf:
//
//      LPTSTR szFilter:
//
//  Return (UINT):
//
//
//--------------------------------------------------------------------------;

#if defined(WIN32) && !defined(UNICODE)

UINT FNLOCAL acmdFilterDetailsToString
(
    PDRIVERINSTANCE         pdi,
    LPWAVEFILTER            pwf,
    LPWSTR                  szFilter
)
{
    UINT                u;
    CHAR                ach1[ACMFILTERDETAILS_FILTER_CHARS];
    CHAR                ach2[ACMFILTERDETAILS_FILTER_CHARS];
    LPVOLUMEWAVEFILTER  pwfVol;
    LPECHOWAVEFILTER    pwfEcho;


    if( !szFilter ) {
        return 0L;
    }

    *szFilter = L'\0';
    if (volumeIsValidFilter(pwf))
    {
        pwfVol = (LPVOLUMEWAVEFILTER)pwf;
        LoadStringA(pdi->hinst, IDS_ACM_DRIVER_FORMAT_VOLUME, ach1, SIZEOF(ach1));
        u = wsprintfA( ach2, ach1,
                 (WORD)(((pwfVol->dwVolume * 100) / 0x10000)) );
    	MultiByteToWideChar( GetACP(), 0, ach2, u+1, szFilter,
                                        ACMFILTERDETAILS_FILTER_CHARS );
        return( u );
    }
    else if (echoIsValidFilter(pwf))
    {
        pwfEcho = (LPECHOWAVEFILTER)pwf;
        LoadStringA(pdi->hinst, IDS_ACM_DRIVER_FORMAT_ECHO, ach1, SIZEOF(ach1));
        u = wsprintfA( ach2, ach1,
                 (WORD)(((pwfEcho->dwVolume * 100) / 0x10000)),
                     (WORD)pwfEcho->dwDelay );
    	MultiByteToWideChar( GetACP(), 0, ach2, u+1, szFilter,
                                        ACMFILTERDETAILS_FILTER_CHARS );
        return( u );
    }
    return ( 0 );
} // acmdFilterDetailsToString()

#else

UINT FNLOCAL acmdFilterDetailsToString
(
    PDRIVERINSTANCE         pdi,
    LPWAVEFILTER            pwf,
    LPTSTR                  szFilter
)
{
    UINT                u;
    TCHAR               ach[ACMFILTERDETAILS_FILTER_CHARS];
    LPVOLUMEWAVEFILTER  pwfVol;
    LPECHOWAVEFILTER    pwfEcho;


    if( !szFilter ) {
        return 0L;
    }

    *szFilter = TEXT('\0');
    if (volumeIsValidFilter(pwf))
    {
        pwfVol = (LPVOLUMEWAVEFILTER)pwf;
        LoadString(pdi->hinst, IDS_ACM_DRIVER_FORMAT_VOLUME, ach, SIZEOF(ach));
        u = wsprintf( szFilter, ach,
                 (WORD)(((pwfVol->dwVolume * 100) / 0x10000)) );
        return( u );
    }
    else if (echoIsValidFilter(pwf))
    {
        pwfEcho = (LPECHOWAVEFILTER)pwf;
        LoadString(pdi->hinst, IDS_ACM_DRIVER_FORMAT_ECHO, ach, SIZEOF(ach));
        u = wsprintf( szFilter, ach,
                 (WORD)(((pwfEcho->dwVolume * 100) / 0x10000)),
                     (WORD)pwfEcho->dwDelay );
        return( u );
    }
    return ( 0 );
} // acmdFilterDetailsToString()

#endif



//--------------------------------------------------------------------------;
//
//  LRESULT acmdFilterDetails
//
//  Description:
//
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFILTERDETAILS padf:
//
//      DWORD fdwDetails:
//
//  Return (LRESULT):
//
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFilterDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFILTERDETAILS      padf,
    DWORD                   fdwDetails
)
{
    UINT                uFilterIndex;
    LPWAVEFILTER        pwf;
    LPVOLUMEWAVEFILTER  pwfVolume;
    LPECHOWAVEFILTER    pwfEcho;
    UINT                u;

    pwf = padf->pwfltr;

    //
    //
    //
    //
    //
    switch (ACM_FILTERDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FILTERDETAILSF_INDEX:
            //
            //  enumerate by index
            //
            //  for this converter, this is more code than necessary... just
            //  verify that the filter tag is something we know about
            //
            switch (padf->dwFilterTag)
            {
                case WAVE_FILTER_VOLUME:
                    if (ACM_DRIVER_MAX_VOLUME_FILTERS <= padf->dwFilterIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfVolume        = (LPVOLUMEWAVEFILTER)padf->pwfltr;
                    pwf->cbStruct    = sizeof(VOLUMEWAVEFILTER);
                    pwf->dwFilterTag = WAVE_FILTER_VOLUME;
                    pwf->fdwFilter   = 0;
                    pwfVolume->dwVolume = gdwFilterIndexToVolume[(UINT)padf->dwFilterIndex];
                    break;

                case WAVE_FILTER_ECHO:
                    if (ACM_DRIVER_MAX_ECHO_FILTERS <= padf->dwFilterIndex)
                        return (ACMERR_NOTPOSSIBLE);

                    pwfEcho             = (LPECHOWAVEFILTER)padf->pwfltr;
                    pwf->cbStruct       = sizeof(ECHOWAVEFILTER);
                    pwf->dwFilterTag    = WAVE_FILTER_ECHO;
                    pwf->fdwFilter      = 0;

                    uFilterIndex = (UINT)padf->dwFilterIndex;

                    u = uFilterIndex / ACM_DRIVER_NUM_DELAY;
                    pwfEcho->dwVolume = gdwFilterIndexToEchoVol[u];

                    u = uFilterIndex % ACM_DRIVER_NUM_DELAY;
                    pwfEcho->dwDelay = gdwFilterIndexToDelay[u];
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        case ACM_FILTERDETAILSF_FILTER:
            //
            //  must want to verify that the filter passed in is supported
            //  and return a string description...
            //
            switch (pwf->dwFilterTag)
            {
                case WAVE_FILTER_VOLUME:
                    if (!volumeIsValidFilter(pwf))
                        return (ACMERR_NOTPOSSIBLE);

                    break;

                case WAVE_FILTER_ECHO:
                    if (!echoIsValidFilter(pwf))
                        return (ACMERR_NOTPOSSIBLE);

                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            //
            //  don't know how to do the query type passed--return 'not
            //  supported'.
            //
            return (MMSYSERR_NOTSUPPORTED);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFILTERDETAILS structure
    //  passed is at least large enough to hold everything in the base
    //  filter details structure...
    //
    //  get a nice friendly string for the filter we made
    //
    acmdFilterDetailsToString(pdi, pwf, padf->szFilter);


    //
    //  if they asked for more info than we know how to return, then
    //  set size of valid structure bytes to correct value.
    //
    padf->fdwSupport = ACMDRIVERDETAILS_SUPPORTF_FILTER;
    padf->cbStruct   = min(padf->cbStruct, sizeof(*padf));

    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFilterDetails()



//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//      If the ACM_STREAMOPENF_NONREALTIME bit is NOT set, then conversion
//      must be done in 'real-time'. This is a tough one to describe
//      exactly. If the driver may have trouble doing the conversion without
//      breaking up the audio, then a configuration dialog might be used
//      to allow the user to specify whether the real-time conversion
//      request should be succeeded. DO NOT SUCCEED THE CALL UNLESS YOU
//      ACTUALLY CAN DO REAL-TIME CONVERSIONS! There may be another driver
//      installed that can--so if you succeed the call you are hindering
//      the performance of the user's system!
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPWAVEFILTER        pwfltr;
    BOOL                fRealTime;


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;
    pwfltr  = padsi->pwfltr;

    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));

    if( fRealTime )
    {
    	//
        //  We only do non-realtime conversions.
    	//  Return failure if we are asked for realtime.
        //
        return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  the most important condition to check before doing anything else
    //  is that this ACM driver can actually perform the conversion we are
    //  being opened for. this check should fail as quickly as possible
    //  if the conversion is not possible by this driver.
    //
    //  it is VERY important to fail quickly so the ACM can attempt to
    //  find a driver that is suitable for the conversion. also note that
    //  the ACM may call this driver several times with slightly different
    //  format specifications before giving up.
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    //  NOTE! for a 'filter only' driver, you only need to check one
    //  of the formats. the ACM will have already verified that the source
    //  and destination formats are equal. so if one is acceptable to this
    //  driver, they both are.
    //
    if (!pcmIsValidFormat(pwfxSrc))
    {
        //
        //  either the source or destination format is illegal for this
        //  driver--or the conversion between the formats can not be
        //  performed by this driver.
        //
        return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  now verify the filter..
    //
    if (!volumeIsValidFilter(pwfltr) && !echoIsValidFilter(pwfltr))
    {
        return (ACMERR_NOTPOSSIBLE);
    }



    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //

    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    psi = (PSTREAMINSTANCE)LocalAlloc(LPTR, sizeof(*psi));
    if (NULL == psi)
    {
        return (MMSYSERR_NOMEM);
    }


    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //

    //
    //
    //
    //
    if (WAVE_FILTER_VOLUME == pwfltr->dwFilterTag)
    {
        psi->fnConvert      = msfilterVolume;
        psi->fdwConfig      = pdi->fdwConfig;
        psi->hpbHistory     = NULL;
        psi->dwPlace        = 0L;
        psi->dwHistoryDone  = 0L;
    }
    else
    {
        LPECHOWAVEFILTER    pwfEcho;
        DWORD               cb;
        LPBYTE              pb;

        psi->fnConvert      = msfilterEcho;
        psi->fdwConfig      = pdi->fdwConfig;
        psi->hpbHistory     = NULL;
        psi->dwPlace        = 0L;
        psi->dwHistoryDone  = 0L;

        pwfEcho = (LPECHOWAVEFILTER)pwfltr;

        //
        //  compute size of delay buffer--add 4 to allow for rounding
	//  errors when we access the delay buffer.   (could do this
	//  more precisely.)
        //
        cb  = (pwfxSrc->nSamplesPerSec * pwfEcho->dwDelay / 1000) *
	      pwfxSrc->nBlockAlign;
        cb += 4;

        pb = (LPBYTE)GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE|GMEM_ZEROINIT, cb);
        if (NULL == pb)
        {
            //
            //  free the stream instance structure and fail with no memory
            //
            LocalFree((HLOCAL)psi);
            return (MMSYSERR_NOMEM);
        }

        psi->hpbHistory = (HPBYTE)pb;
    }


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = (DWORD_PTR)psi;

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose). The ACM driver should clean up any resources
//      that were allocated for the stream.
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      NOTE! It is _strongly_ recommended that a driver not fail to close
//      a conversion stream.
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    PSTREAMINSTANCE     psi;

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (PSTREAMINSTANCE)padsi->dwDriver;
    if (NULL != psi)
    {
        //
        //  free up  the delay buffer if one was allocated (will be for
        //  the echo filter
        //
        if (NULL != psi->hpbHistory)
        {
            GlobalFreePtr((LPVOID)psi->hpbHistory);
        }

        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }

    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamSize
//
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPWAVEFILTER        pwfltr;
    DWORD               dw;


    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;
    pwfltr  = padsi->pwfltr;


    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            dw = padss->cbSrcLength;

            if( pwfltr->dwFilterTag == WAVE_FILTER_VOLUME )
            {
                //
                //  Source and dest sizes are the same for volume.
                //
                //  block align the destination
                //
                dw = PCM_BYTESTOSAMPLES(pwfxSrc, padss->cbSrcLength);
                dw = PCM_SAMPLESTOBYTES(pwfxSrc, dw);
            }
            else if( pwfltr->dwFilterTag == WAVE_FILTER_ECHO )
            {
                dw = PCM_BYTESTOSAMPLES(pwfxSrc, padss->cbSrcLength);
                dw = PCM_SAMPLESTOBYTES(pwfxSrc, dw);
            }

            if (0 == dw)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            padss->cbDstLength = dw;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            dw = padss->cbDstLength;

            if( pwfltr->dwFilterTag == WAVE_FILTER_VOLUME )
            {
                //
                //  Source and dest sizes are the same for volume.
                //
                //  block align the destination
                //
                dw = PCM_BYTESTOSAMPLES(pwfxDst, padss->cbDstLength);
                dw = PCM_SAMPLESTOBYTES(pwfxDst, dw);
            }
            else if( pwfltr->dwFilterTag == WAVE_FILTER_ECHO )
            {
                dw = PCM_BYTESTOSAMPLES(pwfxDst, padss->cbDstLength);
                dw = PCM_SAMPLESTOBYTES(pwfxDst, dw);
            }

            if (0 == dw)
            {
                return (ACMERR_NOTPOSSIBLE);
            }

            padss->cbSrcLength = dw;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message.
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD_PTR               dwId,
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
    pdi = (PDRIVERINSTANCE)dwId;

    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef WIN32
            DbgInitialize(TRUE);
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            return (1L);


        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);



        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: FILTERTAGDETAILS
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FILTERTAG_DETAILS:
            lr = acmdFilterTagDetails(pdi, (LPACMFILTERTAGDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to the details structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FILTER_DETAILS:
            lr = acmdFilterDetails(pdi, (LPACMFILTERDETAILS)lParam1, (DWORD)lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
            lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
        {
            PSTREAMINSTANCE         psi;
            LPACMDRVSTREAMINSTANCE  padsi;
            LPACMDRVSTREAMHEADER    padsh;

            //
            //  our stream instance data is a pointer to the conversion
            //  procedure needed to convert the pwfxSrc data to pwfxDst.
            //  the correct procedure to use was decided in acmdStreamOpen
            //
            padsi = (LPACMDRVSTREAMINSTANCE)lParam1;
            padsh = (LPACMDRVSTREAMHEADER)lParam2;

            psi   = (PSTREAMINSTANCE)padsi->dwDriver;

            lr = psi->fnConvert(padsi, padsh);
            return (lr);
        }
    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\verinfo\usa\verinfo.h ===
/*
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *	!!!!!!!IF YOU CHANGE TABS TO SPACES, YOU WILL BE KILLED!!!!!!!
 *      !!!!!!!!!!!!!!DOING SO MESSES UP THE BUILD PROCESS!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */


/*
 *  verinfo.h - internal header file to define the build version
 *
 */

//
//  WARNING! the following defines are used by some of the components in
//  the multimedia core. do *NOT* put LEADING ZERO's on these numbers or
//  they will end up as OCTAL numbers in the C code!
//

#ifdef MTN

#define OFFICIAL	1
#define FINAL		0

#ifdef ALTACM

#define /*ALTACM*/ MMVERSION		2
#define /*ALTACM*/ MMREVISION		0
#define /*ALTACM*/ MMRELEASE		83

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Audio Compression Manager\0"
#define VERSIONCOPYRIGHT	"Copyright (c) 1992-1994 Microsoft Corporation\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTACM*/ VERSIONSTR	"Motown Retail Debug Version 2.00.083\0"
#elif defined(DEBUG)
#define /*ALTACM*/ VERSIONSTR	"Motown Internal Debug Version 2.00.083\0"
#else
#define /*ALTACM*/ VERSIONSTR	"2.00\0"
#endif

#elif defined(ALTVFW)

#define /*ALTVFW*/ MMVERSION		4
#define /*ALTVFW*/ MMREVISION		0
#define /*ALTVFW*/ MMRELEASE		83

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Video for Windows\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1993\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTVFW*/ VERSIONSTR	"Motown Retail Debug Version 4.00.083\0"
#elif defined(DEBUG)
#define /*ALTVFW*/ VERSIONSTR	"Motown Internal Debug Version 4.00.083\0"
#else
#define /*ALTVFW*/ VERSIONSTR	"4.00\0"
#endif

#else

#define /*MTN*/ MMVERSION		4
#define /*MTN*/ MMREVISION		0
#define /*MTN*/ MMRELEASE		83

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Windows\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1991-1994\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*MTN*/ VERSIONSTR	"Motown Retail Debug Version 4.00.083\0"
#elif defined(DEBUG)
#define /*MTN*/ VERSIONSTR	"Motown Internal Debug Version 4.00.083\0"
#else
#define /*MTN*/ VERSIONSTR	"4.00\0"
#endif

#endif

#elif defined(ACM)

#define OFFICIAL	1
#define FINAL		0

#define /*ACM*/ MMVERSION		2
#define /*ACM*/ MMREVISION		02
#define /*ACM*/ MMRELEASE		005

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Audio Compression Manager\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1993\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ACM*/ VERSIONSTR	"ACM Retail Debug Version 2.02.005\0"
#elif defined(DEBUG)
#define /*ACM*/ VERSIONSTR	"ACM Internal Debug Version 2.02.005\0"
#else
#define /*ACM*/ VERSIONSTR	"2.02\0"
#endif

#elif defined(VFW)

#define OFFICIAL	1
#define FINAL		0

#define /*VFW*/ MMVERSION		1
#define /*VFW*/ MMREVISION		10
#define /*VFW*/ MMRELEASE		176

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Video for Windows\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1993\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*VFW*/ VERSIONSTR	"VfW Retail Debug Version 1.10.176\0"
#elif defined(DEBUG)
#define /*VFW*/ VERSIONSTR	"VfW Internal Debug Version 1.10.176\0"
#else
#define /*VFW*/ VERSIONSTR	"1.1\0"
#endif

#endif

/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED
#define VERSIONCOMPANYNAME	"Microsoft Corporation\0"

/*
 *  Version flags 
 */

#ifndef OFFICIAL
#define VER_PRIVATEBUILD	VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD	0
#endif

#ifndef FINAL
#define VER_PRERELEASE		VS_FF_PRERELEASE
#else
#define VER_PRERELEASE		0
#endif

#if defined(DEBUG_RETAIL)
#define VER_DEBUG		VS_FF_DEBUG    
#elif defined(DEBUG)
#define VER_DEBUG		VS_FF_DEBUG    
#else
#define VER_DEBUG		0
#endif

#define VERSIONFLAGS		(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK	0x0030003FL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\msacm\msfilter\msfilter.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1994 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  msfilter.c
//
//  Description:
//      This file contains filter routines for doing simple
//      volume and echo.
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include "codec.h"
#include "msfilter.h"

#include "debug.h"


//--------------------------------------------------------------------------;
//
//  LRESULT msfilterVolume
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL msfilterVolume
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh

)
{
    LPVOLUMEWAVEFILTER      pwfVol;
    HPSHORT                 hpiSrc;
    HPSHORT                 hpiDst;
    HPBYTE                  hpbSrc;
    HPBYTE                  hpbDst;
    LONG                    lSrc, lDst;
    LONG                    lAmp;
    LONG                    lDone, lSize;
    DWORD                   dw;

    pwfVol = (LPVOLUMEWAVEFILTER)padsi->pwfltr;
    DPF(2, "msfilterVolume Vol %lX ", pwfVol->dwVolume);


    //
    //  Source and dest sizes are the same for volume.
    //  block align source
    //
    dw = PCM_BYTESTOSAMPLES(padsi->pwfxSrc, padsh->cbSrcLength);
    dw = PCM_SAMPLESTOBYTES(padsi->pwfxSrc, dw);

    padsh->cbSrcLengthUsed = dw;

    lSize = (LONG)dw;

    lAmp = pwfVol->dwVolume;

    if( padsi->pwfxSrc->wBitsPerSample == 8 ) {
        hpbSrc = (HPBYTE)padsh->pbSrc;
        hpbDst = (HPBYTE)padsh->pbDst;
        for( lDone = 0; lDone < lSize; lDone++ ) {
            lSrc = ((short)(WORD)(*hpbSrc)) - 128;
            lDst = ((lSrc * lAmp) / 65536L) + 128;
            if( lDst < 0 ) {
                lDst = 0;
            } else if( lDst > 255 ) {
                lDst = 255;
            }
            *hpbDst = (BYTE)lDst;
            if( lDone < (lSize - 1) ) {
                // Will advance to invalid ptr on last sample
                // So do not advance on last sample.
                hpbSrc++;
                hpbDst++;
            }
        }
    } else {
        hpiSrc = (HPSHORT)(padsh->pbSrc);
        hpiDst = (HPSHORT)(padsh->pbDst);
        for( lDone = 0; lDone < lSize; lDone += sizeof(short) ) {
            lDst = ((((LONG)(int)(*hpiSrc)) * (lAmp/2)) / 32768L);
            if( lDst < -32768 ) {
                lDst = -32768;
            } else if( lDst > 32767 ) {
                lDst = 32767;
            }
            *hpiDst = (short)lDst;
            if( lDone < (lSize - 1) ) {
                // Will advance to invalid ptr on last sample
                // So do not advance on last sample.
                hpiSrc++;
                hpiDst++;
            }
        }

    }


    padsh->cbDstLengthUsed = lDone;

    return (MMSYSERR_NOERROR);
}


//--------------------------------------------------------------------------;
//
//  LRESULT msfilterEcho
//
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message. This is the
//      whole purpose of writing an ACM driver--to convert data. This message
//      is sent after a stream has been opened (the driver receives and
//      succeeds the ACMDM_STREAM_OPEN message).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL msfilterEcho
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    PSTREAMINSTANCE         psi;
    LPECHOWAVEFILTER        pwfEcho;
    DWORD                   dw;
    HPSHORT                 hpiHistory;
    HPSHORT                 hpiSrc;
    HPSHORT                 hpiDst;
    HPBYTE                  hpbHistory;
    HPBYTE                  hpbSrc;
    HPBYTE                  hpbDst;
    LONG                    lSrc, lHist, lDst;
    LONG                    lAmp, lDelay;
    LONG                    lDone1, lDone2, lSize, lDelaySize;
    BOOL                    fStart;
    BOOL                    fEnd;
    DWORD                   cbDstLength;

    fStart = (0 != (ACM_STREAMCONVERTF_START & padsh->fdwConvert));
    fEnd   = (0 != (ACM_STREAMCONVERTF_END   & padsh->fdwConvert));


    pwfEcho = (LPECHOWAVEFILTER)padsi->pwfltr;
    DPF(2, "msfilterEcho Vol %lX Delay %ld",
          pwfEcho->dwVolume,
          pwfEcho->dwDelay);


    lAmp = pwfEcho->dwVolume;

    psi = (PSTREAMINSTANCE)padsi->dwDriver;



    lDone1 = 0;
    lDone2 = 0;
    lDelay = psi->dwPlace;

    lDelaySize = padsi->pwfxSrc->nBlockAlign
            * (padsi->pwfxSrc->nSamplesPerSec
            * pwfEcho->dwDelay
            / 1000);


    // If this is a start buffer, then zero out the history
    if(fStart) {
        hpbHistory = psi->hpbHistory;
        for( lDone1 = 0; lDone1 < lDelaySize; lDone1++ ) {
            hpbHistory[lDone1] = 0;
        }

        psi->dwPlace        = 0L;
        psi->dwHistoryDone  = 0L;
    }


    //
    //  Source and dest sizes are the same for volume.
    //  block align source
    //
    dw = PCM_BYTESTOSAMPLES(padsi->pwfxSrc, padsh->cbSrcLength);
    dw = PCM_SAMPLESTOBYTES(padsi->pwfxSrc, dw);

    padsh->cbSrcLengthUsed = dw;

    lSize = (LONG)dw;

    cbDstLength = PCM_BYTESTOSAMPLES(padsi->pwfxDst, padsh->cbDstLength);
    cbDstLength = PCM_SAMPLESTOBYTES(padsi->pwfxDst, cbDstLength);


    if( padsi->pwfxSrc->wBitsPerSample == 8 ) {
        hpbHistory = psi->hpbHistory;
        hpbSrc = (HPBYTE)padsh->pbSrc;
        hpbDst = (HPBYTE)padsh->pbDst;
        for( lDone1 = 0; lDone1 < lSize; lDone1++ ) {
            lSrc  = ((short)(WORD)(*hpbSrc)) - 128;
            lHist = ((short)(char)(hpbHistory[lDelay]));
            lDst = lSrc + lHist + 128;
            if( lDst < 0 ) {
                lDst = 0;
            } else if( lDst > 255 ) {
                lDst = 255;
            }
            *hpbDst = (BYTE)lDst;
            lHist = (((lDst-128) * lAmp) / 65536L);
            if( lHist < -128 ) {
                lHist = -128;
            } else if( lHist > 127 ) {
                lHist = 127;
            }
            hpbHistory[lDelay] = (BYTE)lHist;
            lDelay++;
            if( lDelay >= lDelaySize ) {
                lDelay = 0;
            }
            if( lDone1 < (lSize - 1) ) {
                // Will advance to invalid ptr on last sample
                // So do not advance on last sample.
                hpbSrc++;
                hpbDst++;
            }
        }

	// If this is the end block and there is room,
	// then output the last echo
	if(fEnd && ((DWORD)lDone1 < cbDstLength) ) {
	    lSize = cbDstLength - lDone1;
	    if( lSize > (lDelaySize - (LONG)(psi->dwHistoryDone)) ) {
		lSize = lDelaySize - psi->dwHistoryDone;
	    }
	    if( lSize < 0 ) {
		/* ERROR */
		DPF(2, "!msfilterEcho Size Error!" );
		lSize = 0;
	    }
	    for( lDone2 = 0; lDone2 < lSize; lDone2++ ) {
		*hpbDst = (BYTE)((short)(char)(hpbHistory[lDelay]) + 128);
		lDelay++;
		if( lDelay >= lDelaySize ) {
		    lDelay = 0;
		}
		if( lDone2 < (lSize - 1) ) {
		    // Will advance to invalid ptr on last sample
		    // So do not advance on last sample.
		    hpbSrc++;
		    hpbDst++;
		}
		(psi->dwHistoryDone)++;
	    }
	}
    } else {
        hpiHistory = (HPSHORT)(psi->hpbHistory);
        hpiSrc = (HPSHORT)(padsh->pbSrc);
        hpiDst = (HPSHORT)(padsh->pbDst);
        for( lDone1 = 0; lDone1 < lSize; lDone1 += sizeof(short) ) {
            lDst = (LONG)(*hpiSrc) + (LONG)(hpiHistory[lDelay]);
            if( lDst < -32768 ) {
                lDst = -32768;
            } else if( lDst > 32767 ) {
                lDst = 32767;
            }
            *hpiDst = (short)lDst;
            lHist = ( ( lDst  * (lAmp/2)) / 32768L);
            if( lHist < -32768 ) {
                lHist = -32768;
            } else if( lHist > 32767 ) {
                lHist = 32767;
            }
            hpiHistory[lDelay] = (short)lHist;
            lDelay++;
            if( (LONG)(lDelay * sizeof(short)) >= lDelaySize ) {
                lDelay = 0;
            }
            if( lDone1 < (lSize - 1) ) {
                // Will advance to invalid ptr on last sample
                // So do not advance on last sample.
                hpiSrc++;
                hpiDst++;
            }
        }


	// If this is the end block and there is room,
	// then output the last echo
	if(fEnd && ((DWORD)lDone1 < cbDstLength) ) {
	    lSize = cbDstLength - lDone1;
	    if( lSize > (lDelaySize - (LONG)(psi->dwHistoryDone)) ) {
		lSize = lDelaySize - psi->dwHistoryDone;
	    }
	    if( lSize < 0 ) {
		/* ERROR */
		DPF(2, "!msfilterEcho Size Error!" );
		lSize = 0;
	    }
	    for( lDone2 = 0; lDone2 < lSize; lDone2 += sizeof(short) ) {
		*hpiDst = hpiHistory[lDelay];
		
		lDelay++;
		if( (LONG)(lDelay * sizeof(short)) >= lDelaySize ) {
		    lDelay = 0;
		}
		if( lDone2 < (lSize - 1) ) {
		    // Will advance to invalid ptr on last sample
		    // So do not advance on last sample.
		    hpiSrc++;
		    hpiDst++;
		}
		psi->dwHistoryDone += sizeof(short);
	    }
	}
    }


    // Reset the new point/place in the history
    psi->dwPlace = lDelay;

    padsh->cbDstLengthUsed = lDone1 + lDone2;

    return (MMSYSERR_NOERROR);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\aafile.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  aafile.c
//
//  Description:
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>

#include <mmreg.h>
#include <msacm.h>

#include "appport.h"
#include "waveio.h"
#include "acmapp.h"

#include "debug.h"



//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  DWORD DosGetFileAttributes
//  
//  Description:
//      INT 21 - DOS 2+ - GET FILE ATTRIBUTES
//          AX = 4300h
//          DS:DX -> ASCIZ file name or directory name without trailing slash
//
//      Return: CF set on error
//              AX = error code (01h,02h,03h,05h) (see AH=59h)
//              CF clear if successful
//              CX = file attributes (see AX=4301h)
//
//      SeeAlso: AX=4301h, INT 2F/AX=110Fh
//
//      --------
//      INT 21 - DOS 2+ - PUT FILE ATTRIBUTES (CHMOD)
//          AX = 4301h
//          CX = file attribute bits
//              bit 0 = read only
//                  1 = hidden file
//                  2 = system file
//                  3 = volume label
//                  4 = subdirectory
//                  5 = written since backup ("archive" bit)
//                  8 = shareable (Novell NetWare)
//          DS:DX -> ASCIZ file name
//
//      Return: CF set on error
//              AX = error code (01h,02h,03h,05h) (see AH=59h)
//          CF clear if successful
//
//      Note:   will not change volume label or directory attributes
//
//      SeeAlso: AX=4300h, INT 2F/AX=110Eh
//  
//  
//  Arguments:
//      LPTSTR pszFilePath:
//  
//  Return (DWORD):
//  
//  
//--------------------------------------------------------------------------;
#ifndef WIN32
#pragma optimize("", off)
DWORD FNGLOBAL DosGetFileAttributes
(
    LPTSTR          pszFilePath
)
{
    WORD        fwDosAttributes;

    _asm
    {
        push    ds
        mov     ax, 4300h
        lds     dx, pszFilePath
        int     21h
        jnc     Get_File_Attributes_Continue

        xor     cx, cx

Get_File_Attributes_Continue:

        mov     fwDosAttributes, cx
        pop     ds
    }


    return ((DWORD)fwDosAttributes);
} // DosGetFileAttributes()
#pragma optimize("", on)
#endif


//--------------------------------------------------------------------------;
//  
//  DWORD DosGetDateTime
//  
//  Description:
//  
//  Arguments:
//      HFILE hf:
//  
//  Return (DWORD):
//  
//  
//--------------------------------------------------------------------------;
#ifndef WIN32
#pragma optimize("", off)
DWORD FNGLOBAL DosGetDateTime
(
    HFILE       hf
)
{
    WORD        wDosDate;
    WORD        wDosTime;

    _asm
    {
        mov     ax, 5700h
        mov     bx, hf
        int     21h
        jnc     Get_Date_Time_Continue

        xor     cx, cx
        xor     dx, dx

Get_Date_Time_Continue:

        mov     wDosDate, dx
        mov     wDosTime, cx
    }


    return ((DWORD)MAKELONG(wDosDate, wDosTime));
} // DosGetDateTime()
#pragma optimize("", on)
#endif


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL AcmAppFileSaveModified
//
//  Description:
//      This function tests if the current file has been modified, and
//      if it has it gives the option of saving the file.
//
//      NOTE! This function does *NOT* clear the modified bit for the
//      file. The calling function must do this if necessary.
//
//  Arguments:
//      HWND hwnd: Handle to main window.
//
//      PACMAPPFILEDESC paafd: Pointer to file descriptor.
//
//  Return (BOOL):
//      Returns TRUE if the calling function should continue--the file was
//      either saved or the user does not wish to save it. Returns FALSE
//      if the calling function should cancel its operation--the user
//      wants to keep the data, but it has not been saved.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppFileSaveModified
(
    HWND            hwnd,
    PACMAPPFILEDESC paafd
)
{
    BOOL    f;
    int     n;

    //
    //  check if the contents of the file have been modified--if they have
    //  then ask the user if they want to save the current contents...
    //
    f = (0 != (ACMAPPFILEDESC_STATEF_MODIFIED & paafd->fdwState));
    if (f)
    {
        //
        //  display an appropriate message box asking for the user's opinion
        //
        n = AppMsgBox(hwnd, MB_YESNOCANCEL | MB_ICONQUESTION,
                      TEXT("The file '%s' has been modified. Do you want to save these changes?"),
                      (LPSTR)paafd->szFilePath);
        switch (n)
        {
            case IDYES:
                f = AppFileSave(hwnd, paafd, FALSE);
                if (f)
                    break;

                // -- fall through --

            case IDCANCEL:
                //
                //  don't continue!
                //
                return (FALSE);

            case IDNO:
                break;
        }
    }

    //
    //  ok to continue...
    //
    return (TRUE);
} // AcmAppFileSaveModified()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppFileNew
//
//  Description:
//
//  Arguments:
//      HWND hwnd: Handle to main window.
//
//      PACMAPPFILEDESC paafd: Pointer to file descriptor.
//
//  Return (BOOL):
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppFileNew
(
    HWND                hwnd,
    PACMAPPFILEDESC     paafd
)
{
    TCHAR               szFilePath[APP_MAX_FILE_PATH_CHARS];
    TCHAR               szFileTitle[APP_MAX_FILE_TITLE_CHARS];
    MMRESULT            mmr;
    LPWAVEFORMATEX      pwfx;
    DWORD               cbwfx;
    BOOL                f;
    ACMFORMATCHOOSE     afc;
    HMMIO               hmmio;
    MMCKINFO            ckRIFF;
    MMCKINFO            ck;
    DWORD               cSamples;



    if (!gfAcmAvailable)
    {
        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                  TEXT("AcmAppFileNew() called when ACM is not installed!"));
        return (FALSE);
    }


    //
    //  test for a modified file first...
    //
    f = AcmAppFileSaveModified(hwnd, paafd);
    if (!f)
        return (FALSE);


    //
    //  get a filename
    //
    szFileTitle[0] = '\0';
    szFilePath[0]  = '\0';

    f = AppGetFileName(hwnd, szFilePath, szFileTitle, APP_GETFILENAMEF_SAVE);
    if (!f)
        return (FALSE);


    //
    //
    //
    //
    //
    //
    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &cbwfx);
    if (MMSYSERR_NOERROR != mmr)
    {
        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                  TEXT("AcmAppFileNew() acmMetrics failed mmr=%u!"), mmr);
        return (FALSE);
    }

    pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfx);
    if (NULL == pwfx)
    {
        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                  TEXT("AcmAppFileNew() GlobalAllocPtr(%lu) failed!"), cbwfx);
        return (FALSE);
    }


    //
    //
    //
    //
    f = FALSE;


    //
    //  initialize the ACMFORMATCHOOSE members
    //
    memset(&afc, 0, sizeof(afc));

    afc.cbStruct        = sizeof(afc);
    afc.fdwStyle        = ACMFORMATCHOOSE_STYLEF_SHOWHELP;
    afc.hwndOwner       = hwnd;
    afc.pwfx            = pwfx;
    afc.cbwfx           = cbwfx;
    afc.pszTitle        = TEXT("ACM App: New Format Choice");

    afc.szFormatTag[0]  = '\0';
    afc.szFormat[0]     = '\0';
    afc.pszName         = NULL;
    afc.cchName         = 0;

    afc.fdwEnum         = 0;
    afc.pwfxEnum        = NULL;

    afc.hInstance       = NULL;
    afc.pszTemplateName = NULL;
    afc.lCustData       = 0L;
    afc.pfnHook         = NULL;


    //
    //
    //
    mmr = acmFormatChoose(&afc);
    if (MMSYSERR_NOERROR != mmr)
    {
        if (ACMERR_CANCELED != mmr)
        {
            AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                    TEXT("acmFormatChoose() failed with error = %u!"), mmr);
        }
        
        GlobalFreePtr(pwfx);
        return (FALSE);
    }


    //
    //
    //
    hmmio = mmioOpen(szFilePath,
                     NULL,
                     MMIO_CREATE | MMIO_WRITE | MMIO_EXCLUSIVE | MMIO_ALLOCBUF);
    if (NULL == hmmio)
    {
        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                  TEXT("AcmAppFileNew() cannot create file '%s'!"), (LPSTR)szFilePath);
      
        GlobalFreePtr(pwfx);
        return (FALSE);
    }


    //
    //  create the RIFF chunk of form type 'WAVE'
    //
    ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    ckRIFF.cksize  = 0L;
    mmioCreateChunk(hmmio, &ckRIFF, MMIO_CREATERIFF);


    //
    //  now create the destination fmt, fact, and data chunks _in that order_
    //
    //  hmmio is now descended into the 'RIFF' chunk--create the format chunk
    //  and write the format header into it
    //
    cbwfx = SIZEOF_WAVEFORMATEX(pwfx);

    ck.ckid   = mmioFOURCC('f', 'm', 't', ' ');
    ck.cksize = 0L;
    mmioCreateChunk(hmmio, &ck, 0);

    mmioWrite(hmmio, (HPSTR)pwfx, cbwfx);
    mmioAscend(hmmio, &ck, 0);

    //
    //  create the 'fact' chunk (not necessary for PCM--but is nice to have)
    //  since we are not writing any data to this file (yet), we set the
    //  samples contained in the file to 0..
    //
    ck.ckid   = mmioFOURCC('f', 'a', 'c', 't');
    ck.cksize = 0L;
    mmioCreateChunk(hmmio, &ck, 0);

    cSamples  = 0L;
    mmioWrite(hmmio, (HPSTR)&cSamples, sizeof(DWORD));
    mmioAscend(hmmio, &ck, 0);


    //
    //  create the data chunk with no data..
    //
    ck.ckid   = mmioFOURCC('d', 'a', 't', 'a');
    ck.cksize = 0L;
    mmioCreateChunk(hmmio, &ck, 0);
    mmioAscend(hmmio, &ck, 0);

    mmioAscend(hmmio, &ckRIFF, 0);

    mmioClose(hmmio, 0);


    //
    //
    //
    GlobalFreePtr(pwfx);

    lstrcpy(paafd->szFilePath, szFilePath);
    lstrcpy(paafd->szFileTitle, szFileTitle);

    return (AcmAppFileOpen(hwnd, paafd));


    //
    //  success
    //
    return (TRUE);
} // AcmAppFileNew()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppFileOpen
//
//  Description:
//      This function opens the specified file and get the important info
//      from it.
//
//      NOTE! This function does NOT check for a modified file! It is
//      assumed that the calling function took care of everything before
//      calling this function.
//
//  Arguments:
//      HWND hwnd: Handle to main window.
//
//      PACMAPPFILEDESC paafd: Pointer to file descriptor.
//
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if an error occurred. If an error does occur, then the contents
//      of the file descriptor will remain unchanged.
//
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppFileOpen
(
    HWND            hwnd,
    PACMAPPFILEDESC paafd
)
{
    WAVEIOCB    wio;
    WIOERR      werr;

#ifdef WIN32
    HANDLE      hf;
#else
    #define SEEK_SET        0       // flags for _lseek
    #define SEEK_CUR        1
    #define SEEK_END        2

    HFILE       hf;
    OFSTRUCT    of;
    DWORD       dw;
#endif
    DWORD       cbFileSize;
    BOOL        fReturn;



    //
    //  blow previous stuff...
    //
    if (NULL != paafd->pwfx)
    {
        GlobalFreePtr(paafd->pwfx);
        paafd->pwfx  = NULL;
        paafd->cbwfx = 0;
    }

    paafd->fdwState          = 0L;
    paafd->cbFileSize        = 0L;
    paafd->uDosChangeDate    = 0;
    paafd->uDosChangeTime    = 0;
    paafd->fdwFileAttributes = 0L;
    paafd->dwDataBytes       = 0L;
    paafd->dwDataSamples     = 0L;


    //
    //  open the file for reading..
    //
#ifdef WIN32
    hf = CreateFile(paafd->szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL,
                    OPEN_EXISTING, 0, 0);
    if (INVALID_HANDLE_VALUE == hf)
        return (FALSE);
#else
    of.cBytes = sizeof(of);
    hf = OpenFile(paafd->szFilePath, &of, OF_READ);
    if (HFILE_ERROR == hf)
        return (FALSE);
#endif

    //
    //  assume the worst
    //
    fReturn = FALSE;

    //
    //  determine the length in _bytes_ of the file
    //
#ifdef WIN32
    cbFileSize = GetFileSize((HANDLE)hf, NULL);
#else
    cbFileSize = _llseek(hf, 0L, SEEK_END);
    _llseek(hf, 0L, SEEK_SET);
#endif


    //
    //
    //
    //
    paafd->cbFileSize        = cbFileSize;

#ifdef WIN32
{
    BY_HANDLE_FILE_INFORMATION  bhfi;
    WORD                        wDosChangeDate;
    WORD                        wDosChangeTime;

    GetFileInformationByHandle(hf, &bhfi);

    paafd->fdwFileAttributes = bhfi.dwFileAttributes;

    FileTimeToDosDateTime(&bhfi.ftLastWriteTime,
                          &wDosChangeDate, &wDosChangeTime);

    paafd->uDosChangeDate = (UINT)wDosChangeDate;
    paafd->uDosChangeTime = (UINT)wDosChangeTime;
}
#else
    paafd->fdwFileAttributes = DosGetFileAttributes(paafd->szFilePath);

    dw = DosGetDateTime(hf);
    paafd->uDosChangeDate = LOWORD(dw);
    paafd->uDosChangeTime = HIWORD(dw);
#endif


    //
    //  now return the fully qualified path and title for the file
    //
#ifndef WIN32
    lstrcpy(paafd->szFilePath, of.szPathName);
#endif
    AppGetFileTitle(paafd->szFilePath, paafd->szFileTitle);

#ifdef WIN32
    CloseHandle(hf);
#else
    _lclose(hf);
#endif


    //
    //
    //
    //
    werr = wioFileOpen(&wio, paafd->szFilePath, 0L);
    if (WIOERR_NOERROR == werr)
    {
        UINT        cbwfx;

        cbwfx = SIZEOF_WAVEFORMATEX(wio.pwfx);

        paafd->pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfx);
        if (NULL != paafd->pwfx)
        {
            _fmemcpy(paafd->pwfx, wio.pwfx, cbwfx);

            paafd->cbwfx         = cbwfx;

            paafd->dwDataBytes   = wio.dwDataBytes;
            paafd->dwDataSamples = wio.dwDataSamples;

            fReturn = TRUE;
        }

        wioFileClose(&wio, 0L);
    }
    else
    {
        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL,
                  TEXT("The file '%s' cannot be loaded as a wave file (wio error=%u)."),
                  (LPTSTR)paafd->szFilePath, werr);
    }


    //
    //  !!! before returning, we really should try to display a error
    //      message... memory error, etc..
    //
    return (fReturn);
} // AcmAppFileOpen()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppOpenInstance
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      LPCTSTR pszFilePath:
//  
//      BOOL fForceOpen:
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppOpenInstance
(
    HWND                    hwnd,
    LPCTSTR                 pszFilePath,
    BOOL                    fForceOpen
)
{
    TCHAR               szCmdLine[APP_MAX_FILE_PATH_CHARS * 2];
    BOOL                f;
    UINT                uDosErr;


    //
    //
    //
    if (!fForceOpen)
    {
        if (0 == (APP_OPTIONSF_AUTOOPEN * gfuAppOptions))
        {
            return (TRUE);
        }
    }

    //
    //
    //
    if (0 == GetModuleFileName(ghinst, szCmdLine, SIZEOF(szCmdLine)))
    {
        //
        //  this would be fatal
        //
        AppMsgBox(hwnd, MB_ICONEXCLAMATION | MB_OK,
                  TEXT("GetModuleFileName() is unable to return self reference!"));

        return (FALSE);
    }

    
    lstrcat(szCmdLine, TEXT(" "));
    lstrcat(szCmdLine, pszFilePath);

#ifdef WIN32
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    //
    //  perform the equivalent of WinExec in NT, but we use a Unicode string
    //
    memset(&si, 0, sizeof(si));
    si.cb           = sizeof(si);
    si.dwFlags      = STARTF_USESHOWWINDOW;
    si.wShowWindow  = SW_SHOW;

    f = CreateProcess(NULL,
                      szCmdLine,
                      NULL,
                      NULL,
                      FALSE, 
                      0,
                      NULL,
                      NULL,
                      &si,
                      &pi);

    if (f)
    {
        //
        //  as the docs say.. wait 10 second for process to go idle before
        //  continuing.
        //
        WaitForInputIdle(pi.hProcess, 10000);

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    else
    {
        uDosErr = GetLastError();
    }
}
#else
{
    uDosErr = WinExec(szCmdLine, SW_SHOW);
    f = (uDosErr >= 32);
}
#endif

    if (!f)
    {
        AppMsgBox(hwnd, MB_ICONEXCLAMATION | MB_OK,
                  TEXT("WinExec(%s) failed! DOS error=%u."),
                  (LPTSTR)szCmdLine, uDosErr);

    }

    return (f);
} // AcmAppOpenInstance()





//--------------------------------------------------------------------------;
//
//  BOOL AcmAppFileSave
//
//  Description:
//      This function saves the file to the specified file.
//
//      NOTE! This function does NOT bring up a save file chooser dialog
//      if the file path is invalid. The calling function is responsible
//      for making sure the file path is valid before calling this function.
//
//      This function also does NOT modify the 'modified' bit of the file
//      descriptor. This is up to the calling function.
//
//  Arguments:
//      HWND hwnd: Handle to main window.
//
//      PACMAPPFILEDESC paafd: Pointer to file descriptor.
//
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if an error occurred. If an error does occur, then the contents
//      of the file descriptor was not saved.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppFileSave
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd,
    PTSTR                   pszFilePath,
    PTSTR                   pszFileTitle,
    UINT                    fuSave
)
{

    return (FALSE);
} // AcmAppFileSave()






//==========================================================================;
//==========================================================================;
//==========================================================================;
//==========================================================================;









//
//
//

#define IDD_INFOLIST            100
#define IDD_INFOINFO            101
#define IDD_INFOTEXT            102

#ifdef RC_INVOKED

#define DLG_INFOEDIT            31

#else
                        
#define DLG_INFOEDIT            MAKEINTRESOURCE(31)

#endif

////////////////////////////////////////////////////////////////////////////

typedef struct tCHUNK
{
    FOURCC  fcc;
    DWORD   cksize;
    BYTE    data[];
} CHUNK, * PCHUNK, far * LPCHUNK;



typedef struct tDISP
{
    DWORD   cfid;   // Clipboard id of data
    HANDLE  h;      // handle to data
    struct tDISP *  next;    // next in list
} DISP;

typedef struct tINFODATA
{
    WORD    index;  // index into aINFO
    WORD    wFlags; // flags for chunk
    DWORD   dwINFOOffset;   // offset in file to INFO chunk
    
#define INFOCHUNK_MODIFIED  1
#define INFOCHUNK_REVERT    2   // command to revert to original text

    LPCTSTR   lpText; // text of modified chunk.  None if NULL.

    struct tINFODATA  near *  pnext; // next read sub-chunk
} INFODATA, * PINFODATA, FAR * LPINFODATA;

typedef struct tINFOCHUNK
{
    LPTSTR   lpChunk;    // complete chunk in memory (GlobalPtr)
    DWORD   cksize;     // size of chunk data
    PINFODATA   pHead;  // first sub-chunk data
} INFOCHUNK, * PINFOCHUNK, FAR * LPINFOCHUNK;

////////////////////////////////////////////////////////////////////////////
//
//  error returns from RIFF functions
//
#define RIFFERR_BASE         (0)
#define RIFFERR_NOERROR      (0)
#define RIFFERR_ERROR        (RIFFERR_BASE+1)
#define RIFFERR_BADPARAM     (RIFFERR_BASE+2)
#define RIFFERR_FILEERROR    (RIFFERR_BASE+3)
#define RIFFERR_NOMEM        (RIFFERR_BASE+4)
#define RIFFERR_BADFILE      (RIFFERR_BASE+5)

////////////////////////////////////////////////////////////////////////////
//
//  public function prototypes
//

#define RIFFAPI  FAR PASCAL


BOOL RIFFAPI riffCopyList(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck);
BOOL RIFFAPI riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck);

LRESULT RIFFAPI  riffInitINFO(INFOCHUNK FAR * FAR * lplpInfo);
LRESULT RIFFAPI  riffReadINFO(HMMIO hmmio, const LPMMCKINFO lpck, LPINFOCHUNK lpInfo);
LRESULT RIFFAPI  riffEditINFO(HWND hwnd, LPINFOCHUNK lpInfo, HINSTANCE hInst);
LRESULT RIFFAPI  riffFreeINFO(INFOCHUNK FAR * FAR * lpnpInfo);
LRESULT RIFFAPI riffWriteINFO(HMMIO hmmioDst, LPINFOCHUNK lpInfo);


LRESULT RIFFAPI  riffReadDISP(HMMIO hmmio, LPMMCKINFO lpck, DISP FAR * FAR * lpnpDisp);
LRESULT RIFFAPI  riffFreeDISP(DISP FAR * FAR * lpnpDisp);
LRESULT RIFFAPI riffWriteDISP(HMMIO hmmio, DISP FAR * FAR * lpnpDisp);


LRESULT NEAR PASCAL riffParseINFO(const LPINFOCHUNK lpInfo);



/** BOOL RIFFAPI riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck)
 *
 *  DESCRIPTION:
 *      
 *
 *  ARGUMENTS:
 *      (LPWAVECONVCB lpwc, LPMMCKINFO lpck)
 *
 *  RETURN (BOOL NEAR PASCAL):
 *
 *
 *  NOTES:
 *
 **  */

BOOL RIFFAPI riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck)
{
    MMCKINFO    ck;
    HPSTR       hpBuf;

    //
    //
    //
    hpBuf = (HPSTR)GlobalAllocPtr(GHND, lpck->cksize);
    if (!hpBuf)
        return (FALSE);

    ck.ckid   = lpck->ckid;
    ck.cksize = lpck->cksize;
    if (mmioCreateChunk(hmmioDst, &ck, 0))
        goto rscc_Error;
        
    if (mmioRead(hmmioSrc, hpBuf, lpck->cksize) != (LONG)lpck->cksize)
        goto rscc_Error;

    if (mmioWrite(hmmioDst, hpBuf, lpck->cksize) != (LONG)lpck->cksize)
        goto rscc_Error;

    if (mmioAscend(hmmioDst, &ck, 0))
        goto rscc_Error;

    if (hpBuf)
        GlobalFreePtr(hpBuf);

    return (TRUE);

rscc_Error:

    if (hpBuf)
        GlobalFreePtr(hpBuf);

    return (FALSE);
} /* RIFFSupCopyChunk() */

/** BOOL RIFFAPI riffCopyList(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck)
 *
 *  DESCRIPTION:
 *      
 *
 *  ARGUMENTS:
 *  (HMMIO hmmioSrc, HMMIO hmmioDst, LPMMCKINFO lpck)
 *
 *  RETURN (BOOL NEAR PASCAL):
 *
 *
 *  NOTES:
 *
 ** */

BOOL RIFFAPI riffCopyList(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck)
{
    MMCKINFO    ck;
    HPSTR       hpBuf;
    DWORD       dwCopySize;

    hpBuf = (HPSTR)GlobalAllocPtr(GHND, lpck->cksize);
    if (!hpBuf)
        return (FALSE);

    dwCopySize=lpck->cksize;
    
    // mmio leaves us after LIST ID
        
    ck.ckid   = lpck->ckid;
    ck.cksize = dwCopySize;
    ck.fccType= lpck->fccType;
        
    if (mmioCreateChunk(hmmioDst, &ck, MMIO_CREATELIST))
        goto rscl_Error;

    // we already wrote 'LIST' ID, so reduce byte count
    dwCopySize-=sizeof(FOURCC);

    if (mmioRead(hmmioSrc, hpBuf, dwCopySize) != (LONG)dwCopySize)
        goto rscl_Error;

    if (mmioWrite(hmmioDst, hpBuf, dwCopySize) != (LONG)dwCopySize)
        goto rscl_Error;

    if (mmioAscend(hmmioDst, &ck, 0))
        goto rscl_Error;

    if (hpBuf)
        GlobalFreePtr(hpBuf);

    return (TRUE);

rscl_Error:

    if (hpBuf)
        GlobalFreePtr(hpBuf);

    return (FALSE);
} /* RIFFSupCopyList() */


/////////////////////////////////////////////////////////////////////////////

typedef struct tINFO
{
    PTSTR       pFOURCC;
    PTSTR       pShort;
    PTSTR       pLong;
} INFO;

static INFO aINFO[]=
{
TEXT("IARL"), TEXT("Archival Location"),  TEXT("Indicates where the subject of the file is archived."),
TEXT("IART"), TEXT("Artist"),             TEXT("Lists the artist of the original subject of the file. For example, \"Michaelangelo.\""),
TEXT("ICMS"), TEXT("Commissioned"),       TEXT("Lists the name of the person or organization that commissioned the subject of the file. For example, \"Pope Julian II.\""),
TEXT("ICMT"), TEXT("Comments"),           TEXT("Provides general comments about the file or the subject of the file. If the comment is several sentences long, end each sentence with a period. Do not include newline characters."),
TEXT("ICOP"), TEXT("Copyright"),          TEXT("Records the copyright information for the file. For example, \"Copyright Encyclopedia International 1991.\" If there are multiple copyrights, separate them by a semicolon followed by a space."),
TEXT("ICRD"), TEXT("Creation date"),      TEXT("Specifies the date the subject of the file was created. List dates in year-month-day format, padding one-digit months and days with a zero on the left. For example, \"1553-05-03\" for May 3, 1553."),
TEXT("ICRP"), TEXT("Cropped"),            TEXT("Describes whether an image has been cropped and, if so, how it was cropped. For example, \"lower right corner.\""),
TEXT("IDIM"), TEXT("Dimensions"),         TEXT("Specifies the size of the original subject of the file. For example, \"8.5 in h, 11 in w.\""),
TEXT("IDPI"), TEXT("Dots Per Inch"),      TEXT("Stores dots per inch setting of the digitizer used to produce the file, such as \"300.\""),
TEXT("IENG"), TEXT("Engineer"),           TEXT("Stores the name of the engineer who worked on the file. If there are multiple engineers, separate the names by a semicolon and a blank. For example, \"Smith, John; Adams, Joe.\""),
TEXT("IGNR"), TEXT("Genre"),              TEXT("Describes the original work, such as, \"landscape,\" \"portrait,\" \"still life,\" etc."),
TEXT("IKEY"), TEXT("Keywords"),           TEXT("Provides a list of keywords that refer to the file or subject of the file. Separate multiple keywords with a semicolon and a blank. For example, \"Seattle; aerial view; scenery.\""),
TEXT("ILGT"), TEXT("Lightness"),          TEXT("Describes the changes in lightness settings on the digitizer required to produce the file. Note that the format of this information depends on hardware used."),
TEXT("IMED"), TEXT("Medium"),             TEXT("Describes the original subject of the file, such as, \"computer image,\" \"drawing,\" \"lithograph,\" and so forth."),
TEXT("INAM"), TEXT("Name"),               TEXT("Stores the title of the subject of the file, such as, \"Seattle From Above.\""),
TEXT("IPLT"), TEXT("Palette Setting"),    TEXT("Specifies the number of colors requested when digitizing an image, such as \"256.\""),
TEXT("IPRD"), TEXT("Product"),            TEXT("Specifies the name of the title the file was originally intended for, such as \"Encyclopedia of Pacific Northwest Geography.\""),
TEXT("ISBJ"), TEXT("Subject"),            TEXT("Describes the contents of the file, such as \"Aerial view of Seattle.\""),
TEXT("ISFT"), TEXT("Software"),           TEXT("Identifies the name of the software package used to create the file, such as \"Microsoft WaveEdit.\""),
TEXT("ISHP"), TEXT("Sharpness"),          TEXT("Identifies the changes in sharpness for the digitizer required to produce the file (the format depends on the hardware used)."),
TEXT("ISRC"), TEXT("Source"),             TEXT("Identifies the name of the person or organization who supplied the original subject of the file. For example, \"Trey Research.\""),
TEXT("ISRF"), TEXT("Source Form"),        TEXT("Identifies the original form of the material that was digitized, such as \"slide,\" \"paper,\" \"map,\" and so forth. This is not necessarily the same as IMED."),
TEXT("ITCH"), TEXT("Technician"),         TEXT("Identifies the technician who digitized the subject file. For example, \"Smith, John.\""),

NULL, NULL, NULL

};


void NEAR PASCAL riffInsertINFO(LPINFOCHUNK lpInfo, const PINFODATA pInfo)
{
    PINFODATA pI;
    
    if(!lpInfo)
        return;
    
    if(!lpInfo->pHead)
    {
        lpInfo->pHead=pInfo;
        return;
    }
    
    pI=lpInfo->pHead;
    while(pI->pnext)
    {
        pI=pI->pnext;
    }
    // insert at end
    pI->pnext=pInfo;
    
    return;
}

PINFODATA NEAR PASCAL riffCreateINFO(WORD id, WORD wFlags, DWORD dwInfoOffset, LPCTSTR lpText)
{
    PINFODATA pI;
    pI=(PINFODATA)LocalAlloc(LPTR,sizeof(INFODATA));
    if(!pI)
        return NULL;
    
    pI->index=id;
    pI->wFlags=wFlags;
    pI->dwINFOOffset=dwInfoOffset;
    pI->lpText=lpText;
    
    return pI;
}

LRESULT RIFFAPI riffInitINFO(INFOCHUNK FAR * FAR * lplpInfo)
{
    LPINFOCHUNK lpInfo;
    WORD        id;
    PINFODATA   pI;
    
    lpInfo=(LPINFOCHUNK)GlobalAllocPtr(GHND, sizeof(INFOCHUNK));
    if(!lpInfo)
        return RIFFERR_NOMEM;
    *lplpInfo=lpInfo;

    for (id=0;aINFO[id].pFOURCC;id++)
    {
        pI=riffCreateINFO(id, 0, 0L, NULL);   // create empty INFO
        riffInsertINFO(lpInfo,pI);
    }
    return RIFFERR_NOERROR;
}

LRESULT RIFFAPI riffReadINFO(HMMIO hmmio, const LPMMCKINFO lpck, LPINFOCHUNK lpInfo)
{
    DWORD       dwInfoSize;

    dwInfoSize=lpck->cksize - sizeof(FOURCC);   // take out 'INFO'

    lpInfo->cksize=dwInfoSize;
    lpInfo->lpChunk=(LPTSTR)GlobalAllocPtr(GHND, dwInfoSize);
    if(!lpInfo->lpChunk)
        return RIFFERR_NOMEM;
    
    if (mmioRead(hmmio, (HPSTR)lpInfo->lpChunk, dwInfoSize) != (LONG)dwInfoSize)
        return RIFFERR_FILEERROR;
    else
        return riffParseINFO(lpInfo);
}

PINFODATA NEAR PASCAL riffFindPIINFO(const LPINFOCHUNK lpInfo, FOURCC fcc)
{
    PINFODATA pI;

    pI=lpInfo->pHead;
    while(pI)
    {
        if(mmioStringToFOURCC(aINFO[pI->index].pFOURCC,0)==fcc)
            return(pI);
        pI=pI->pnext;
    }
    return NULL;
}

void NEAR PASCAL riffModifyINFO(const LPINFOCHUNK lpInfo, PINFODATA pI, WORD wFlags, DWORD dw, LPCTSTR lpText)
{
    if(!pI)
        return;
    
    pI->wFlags=wFlags;
    if(!(wFlags&INFOCHUNK_MODIFIED))
        pI->dwINFOOffset=dw;
    
    if(pI->lpText)
    {
        if(lpText)
        {
            if(!lstrcmp(lpText,pI->lpText))
            {
                // they are the same, don't bother changing...
                GlobalFreePtr(lpText);
            }
            else
            {
                GlobalFreePtr(pI->lpText);
                pI->lpText=lpText;
            }
        }
        else if(wFlags&INFOCHUNK_REVERT)
        {
            GlobalFreePtr(pI->lpText);
            pI->lpText=NULL;
        }
    }
    else if(lpText)
    {
        // if no read data, don't bother to check....
        if(!lpInfo->lpChunk && *lpText)
        {
            pI->lpText=lpText;
        }
        else if(lstrcmp(lpText, (LPTSTR)lpInfo->lpChunk+pI->dwINFOOffset))
        {       // new text...
            if(*lpText)
                // NOT the same, set...
                pI->lpText=lpText;
            else
                // new is blank, do nothing...
                GlobalFreePtr(lpText);
        }
        else
            // the same, don't bother...
            GlobalFreePtr(lpText);
    }
}

WORD NEAR PASCAL riffFindaINFO(FOURCC fcc)
{
    WORD    id;

    for (id=0;aINFO[id].pFOURCC;id++)
    {
        if(mmioStringToFOURCC(aINFO[id].pFOURCC,0)==fcc)
            return id;
    }
    return 0xFFFF;
}



LRESULT NEAR PASCAL riffParseINFO(const LPINFOCHUNK lpInfo)
{
    LPTSTR   lpBuf;
    DWORD   dwCurInfoOffset;
    PINFODATA pI;
    LPCHUNK lpck;

    lpBuf=lpInfo->lpChunk;
    for(dwCurInfoOffset=0;dwCurInfoOffset<lpInfo->cksize;)
    {
        lpck=(LPCHUNK)((LPSTR)(lpBuf+dwCurInfoOffset));
        dwCurInfoOffset+=sizeof(CHUNK);   // dwCurInfoOffset is offset of data
        pI=riffFindPIINFO(lpInfo,lpck->fcc);
        if(!pI)
        {
            int     n;

            // file contains unknown INFO chunk
            n = AppMsgBox(NULL, MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL,
                          TEXT("This wave file contains an unknown item in the INFO chunk: '%4.4s'.  Open anyway?"),
                          (LPCSTR)(lpck));
            if (n == IDNO)
            {
                return RIFFERR_BADFILE;
            }
            
            
        }
        else
        {
            // modify entry to show text (data) from file...
            riffModifyINFO(lpInfo, pI, 0, dwCurInfoOffset, NULL);
        }
        dwCurInfoOffset+=lpck->cksize+(lpck->cksize&1);  // skip past data
    }

    return RIFFERR_NOERROR;
}

LRESULT RIFFAPI riffFreeINFO(INFOCHUNK FAR * FAR * lplpInfo)
{
    PINFODATA   pI;
    PINFODATA   pIT;
    LPINFOCHUNK lpInfo;
    LRESULT     lr;

    lr    = RIFFERR_BADPARAM;

    if(!lplpInfo)
        goto riff_FI_Error;
    
    lpInfo=*lplpInfo;
    if(!lpInfo)
        goto riff_FI_Error;
    
    if(lpInfo->lpChunk)
        GlobalFreePtr(lpInfo->lpChunk);


    pI=lpInfo->pHead;
    
    while(pI)
    {
        pIT=pI;
        pI=pI->pnext;
        LocalFree((HANDLE)pIT);
    }

    
    //

    GlobalFreePtr(lpInfo);
    *lplpInfo=NULL;
    return RIFFERR_NOERROR;
    
riff_FI_Error:    
    return lr;
}


TCHAR   szBuf[255];

static BOOL NEAR PASCAL riffSetupEditBoxINFO(HWND hdlg, const LPINFOCHUNK lpInfo, WORD wFlags)
{
    static PTSTR szFormat = TEXT("%-4s%c %-25s");
    PINFODATA   pI;
    WORD        iSel;
    HWND        hLB;
    
    hLB=GetDlgItem(hdlg, IDD_INFOLIST);
    if(wFlags&INFOCHUNK_MODIFIED)
    {
        iSel = ComboBox_GetCurSel(hLB);
        
    }
    else
        iSel = 0;

    ComboBox_ResetContent(hLB);
    
    pI=lpInfo->pHead;
    
    while(pI)
    {
        wsprintf(szBuf,szFormat,
            (LPCSTR)aINFO[pI->index].pFOURCC,
            (pI->dwINFOOffset || ( (pI->lpText) && (pI->lpText[0]) ) ) ?
                        '*' : ' ',
            (LPCSTR)aINFO[pI->index].pShort
            );

        ComboBox_AddString(hLB, szBuf);
        pI=pI->pnext;
    }
    ComboBox_SetCurSel(hLB, iSel);

    if(!(wFlags&INFOCHUNK_MODIFIED))
    {
        // FIRST time only
        pI=lpInfo->pHead;
        if(pI)
            if(pI->lpText)
                // Modified text
                SetDlgItemText(hdlg, IDD_INFOTEXT, (LPCTSTR)pI->lpText);
            else if(pI->dwINFOOffset)
                // default text
                SetDlgItemText(hdlg, IDD_INFOTEXT, (LPCTSTR)(lpInfo->lpChunk+pI->dwINFOOffset));
            else
                // no text
                SetDlgItemText(hdlg, IDD_INFOTEXT, (LPCTSTR)TEXT(""));
        SetDlgItemText(hdlg, IDD_INFOINFO, (LPCTSTR)aINFO[0].pLong);
    }
    return TRUE;
}


static BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    LPINFOCHUNK lpInfo;
    HFONT       hFont;
    HWND        hLB;

    lpInfo = (LPINFOCHUNK)lParam;
    if(!lpInfo)
        return FALSE;

    SetWindowLong(hwnd, DWL_USER, (LONG)lpInfo);
            
    hFont = GetStockFont(ANSI_FIXED_FONT);

    hLB=GetDlgItem(hwnd, IDD_INFOLIST);
    SetWindowFont(hLB, hFont, FALSE);

    riffSetupEditBoxINFO(hwnd, lpInfo, 0);

    return TRUE;
}

static void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    LPINFOCHUNK lpInfo;
    PINFODATA   pI;
    WORD        iSel;
    int         i;
    LPTSTR       lpstr;

    lpInfo=(LPINFOCHUNK)GetWindowLong(hwnd, DWL_USER);
            
    switch(id)
    {
        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, (id == IDOK));
            break;
        case IDD_INFOLIST:
            switch(codeNotify)
            {
                case CBN_SELCHANGE:

                    iSel = ComboBox_GetCurSel(GetDlgItem(hwnd, id));
                    SetDlgItemText(hwnd, IDD_INFOINFO, (LPCTSTR)aINFO[iSel].pLong);

                    pI=lpInfo->pHead;
                    while(pI)
                    {
                        if(pI->index==iSel)
                            break;
                        pI=pI->pnext;
                    }
                    if(pI)
                    {
                        if(pI->lpText)
                            // Modified text
                            SetDlgItemText(hwnd, IDD_INFOTEXT, (LPCTSTR)pI->lpText);
                        else if(pI->dwINFOOffset)
                            // default text
                            SetDlgItemText(hwnd, IDD_INFOTEXT, (LPCTSTR)(lpInfo->lpChunk+pI->dwINFOOffset));
                        else
                            // no text
                            SetDlgItemText(hwnd, IDD_INFOTEXT, (LPCTSTR)TEXT(""));
                    }
                        else
                            SetDlgItemText(hwnd, IDD_INFOINFO, (LPCTSTR)TEXT("Can't FIND iSel"));
                    break;
            }

        case IDD_INFOTEXT:
            switch(codeNotify)
            {
                case EN_KILLFOCUS:
                    // get text out and give to current id
                    iSel=(WORD)SendDlgItemMessage(hwnd,IDD_INFOLIST,CB_GETCURSEL,0,0L);
                    pI=lpInfo->pHead;
                    while(pI)
                    {
                        if(pI->index==iSel)
                            break;
                        pI=pI->pnext;
                    }
                    if(pI)
                    {
                        i=GetDlgItemText(hwnd, IDD_INFOTEXT, szBuf,sizeof(szBuf));
                        lpstr=(LPTSTR)GlobalAllocPtr(GHND,(DWORD)i+1);
                        if(!lpstr)
                            break;

                        lstrcpy(lpstr,szBuf);

                        riffModifyINFO(lpInfo, pI, INFOCHUNK_MODIFIED, 0, lpstr);

                        riffSetupEditBoxINFO(hwnd, lpInfo, INFOCHUNK_MODIFIED);
                    }
                    else
                        SetDlgItemText(hwnd, IDD_INFOINFO, (LPCTSTR)TEXT("Can't FIND iSel"));
                    break;

            }
            break;
        case IDD_INFOINFO:
            break;
    }

}                           

BOOL FNGLOBAL DlgProcINFOEdit(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (BOOL)(UINT)(DWORD)(LRESULT)HANDLE_WM_INITDIALOG(hdlg, wParam, lParam, Cls_OnInitDialog);

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hdlg, wParam, lParam, Cls_OnCommand);
            break;
    }

    return FALSE;
}


LRESULT RIFFAPI riffEditINFO(HWND hwnd, LPINFOCHUNK lpInfo, HINSTANCE hInst)
{
    LRESULT     lr;
    DLGPROC     lpfn;
#ifdef DEBUG    
    int         i;
#endif
    
    lr    = RIFFERR_BADPARAM;

    if(!lpInfo)
        goto riff_EI_Error;

    if (lpfn = (DLGPROC)MakeProcInstance((FARPROC)DlgProcINFOEdit, hInst))
    {
#ifdef DEBUG
        i=
#endif
        DialogBoxParam(hInst, DLG_INFOEDIT, hwnd, lpfn, (LPARAM)(LPVOID)lpInfo);
        FreeProcInstance((FARPROC)lpfn);
        lr=RIFFERR_NOERROR;
#ifdef DEBUG
        if(i==-1)
        {
            MessageBox(hwnd, TEXT("INFO Edit Error: DLG_INFOEDIT not found.  Check .RC file."), TEXT("RIFF SUP module"), MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL);
            lr=RIFFERR_ERROR;
        }
#endif
        
    }
#ifdef DEBUG
    else
    {
        MessageBox(hwnd, TEXT("INFO Edit Error: Can't MakeProcInstace()"), TEXT("RIFF SUP module"), MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL);
        lr=RIFFERR_ERROR;
    }
#endif
    
riff_EI_Error:    
    return lr;
}

LRESULT RIFFAPI riffWriteINFO(HMMIO hmmioDst, LPINFOCHUNK lpInfo)
{
    LRESULT     lr;
    MMCKINFO    ck;
    MMCKINFO    ckINFO;
    PINFODATA   pI;
    LPTSTR      lpstr;
    BOOL        fList=FALSE;

    lr    = RIFFERR_BADPARAM;

    if(!hmmioDst || !lpInfo)
        goto riff_SI_Error;

    lr=RIFFERR_FILEERROR;
    
    ckINFO.ckid   = mmioFOURCC('L', 'I', 'S', 'T');
    ckINFO.cksize = 0;  // mmio fill fill it in later
    ckINFO.fccType= mmioFOURCC('I', 'N', 'F', 'O');
        
    pI=lpInfo->pHead;
    
    while(pI)
    {
        if(pI->lpText)
            // Modified text
            lpstr=(LPTSTR)pI->lpText;
        else if(pI->dwINFOOffset)
            // default text
            lpstr=(lpInfo->lpChunk+pI->dwINFOOffset);
        else
            // no text
            lpstr=NULL;
        if(lpstr)
        {
            if(!fList)
            {
                // only create if needed...
                if (mmioCreateChunk(hmmioDst, &ckINFO, MMIO_CREATELIST))
                    goto riff_SI_Error;
                fList=TRUE;
            }
    
            ck.ckid=mmioStringToFOURCC(aINFO[pI->index].pFOURCC,0);
            ck.cksize=lstrlen(lpstr)+1;
            ck.fccType=0;
            if (mmioCreateChunk(hmmioDst, &ck, 0))
                goto riff_SI_Error;

            if (mmioWrite(hmmioDst, (LPBYTE)lpstr, ck.cksize) != (LONG)(ck.cksize))
                goto riff_SI_Error;

            if (mmioAscend(hmmioDst, &ck, 0))
                goto riff_SI_Error;

        }
        pI=pI->pnext;
    }
    
    if(fList)
    {
        if (mmioAscend(hmmioDst, &ckINFO, 0))
            goto riff_SI_Error;
    }

    return RIFFERR_NOERROR;
    
riff_SI_Error:    
    return lr;
    
}


///////////////////////////////////////////////////////////////////////////////

LRESULT RIFFAPI riffReadDISP(HMMIO hmmio, LPMMCKINFO lpck, DISP FAR * FAR * lpnpDisp)
{
    LRESULT     lr;
    lr    = RIFFERR_ERROR;
   
    return lr;
}

LRESULT RIFFAPI riffFreeDISP(DISP FAR * FAR * lpnpDisp)
{
    LRESULT     lr;
    lr    = RIFFERR_ERROR;
    
    return lr;
}

LRESULT RIFFAPI riffWriteDISP(HMMIO hmmio, DISP FAR * FAR * lpnpDisp)
{
    LRESULT     lr;
    lr    = RIFFERR_ERROR;
    
    return lr;
}









//==========================================================================;
//==========================================================================;
//==========================================================================;
//==========================================================================;




BOOL        gfCancelConvert;


#define WM_CONVERT_BEGIN        (WM_USER + 100)
#define WM_CONVERT_END          (WM_USER + 101)

#define BeginConvert(hwnd, paacd)   PostMessage(hwnd, WM_CONVERT_BEGIN, 0, (LPARAM)(UINT)paacd)
#define EndConvert(hwnd, f, paacd)  PostMessage(hwnd, WM_CONVERT_END, (WPARAM)f, (LPARAM)(UINT)paacd)


//--------------------------------------------------------------------------;
//  
//  void AppDlgYield
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hdlg:
//  
//  Return (void):
//  
//--------------------------------------------------------------------------;

void FNLOCAL AppDlgYield
(
    HWND            hdlg
)
{
    MSG     msg;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if ((hdlg == NULL) || !IsDialogMessage(hdlg, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
} // AppDlgYield()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppConvertEnd
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hdlg:
//  
//      PAACONVERTDESC paacd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppConvertEnd
(
    HWND                hdlg,
    PAACONVERTDESC      paacd
)
{
    MMRESULT            mmr;
    LPACMSTREAMHEADER   pash;


    //
    //
    //
    //
    if (NULL != paacd->hmmioSrc)
    {
        mmioClose(paacd->hmmioSrc, 0);
        paacd->hmmioSrc = NULL;
    }

    if (NULL != paacd->hmmioDst)
    {
        mmioAscend(paacd->hmmioDst, &paacd->ckDst, 0);
        mmioAscend(paacd->hmmioDst, &paacd->ckDstRIFF, 0);

        mmioClose(paacd->hmmioDst, 0);
        paacd->hmmioDst = NULL;
    }


    //
    //
    //
    //
    if (NULL != paacd->has)
    {
        pash = &paacd->ash;

        if (ACMSTREAMHEADER_STATUSF_PREPARED & pash->fdwStatus)
        {
            pash->cbSrcLength = paacd->cbSrcReadSize;
            pash->cbDstLength = paacd->cbDstBufSize;

            mmr = acmStreamUnprepareHeader(paacd->has, &paacd->ash, 0L);
            if (MMSYSERR_NOERROR != mmr)
            {
                AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION,
                          TEXT("acmStreamUnprepareHeader() failed with error = %u!"), mmr);
            }
        }

        //
        //
        //
        acmStreamClose(paacd->has, 0L);
        paacd->has = NULL;

        if (NULL != paacd->had)
        {
            acmDriverClose(paacd->had, 0L);
            paacd->had = NULL;
        }
    }


    //
    //
    //
    //
    if (NULL != paacd->pbSrc)
    {
        GlobalFreePtr(paacd->pbSrc);
        paacd->pbSrc = NULL;
    }
    
    if (NULL != paacd->pbDst)
    {
        GlobalFreePtr(paacd->pbDst);
        paacd->pbDst = NULL;
    }


    return (TRUE);
} // AcmAppConvertEnd()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppConvertBegin
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hdlg:
//  
//      PAACONVERTDESC paacd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppConvertBegin
(
    HWND                    hdlg,
    PAACONVERTDESC          paacd
)
{
    TCHAR               ach[40];
    MMRESULT            mmr;
    MMCKINFO            ckSrcRIFF;
    MMCKINFO            ck;
    DWORD               dw;
    LPACMSTREAMHEADER   pash;
    LPWAVEFILTER        pwfltr;


    //
    //
    //
    if (NULL != paacd->hadid)
    {
        mmr = acmDriverOpen(&paacd->had, paacd->hadid, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            AcmAppGetErrorString(mmr, ach);
            AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION,
                        TEXT("The selected driver (hadid=%.04Xh) cannot be opened. %s (%u)"),
                        paacd->hadid, (LPSTR)ach, mmr);
            return (FALSE);
        }
    }


    //
    //
    //
    //
    pwfltr = paacd->fApplyFilter ? paacd->pwfltr : (LPWAVEFILTER)NULL;

    mmr = acmStreamOpen(&paacd->has,
                        paacd->had,
                        paacd->pwfxSrc,
                        paacd->pwfxDst,
                        pwfltr,
                        0L,
                        0L,
                        paacd->fdwOpen);

    if (MMSYSERR_NOERROR != mmr)
    {
        AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION,
                  TEXT("acmStreamOpen() failed with error = %u!"), mmr);

        return (FALSE);
    }


    //
    //
    //
    mmr = acmStreamSize(paacd->has,
                        paacd->cbSrcReadSize,
                        &paacd->cbDstBufSize,
                        ACM_STREAMSIZEF_SOURCE);

    if (MMSYSERR_NOERROR != mmr)
    {
        AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION,
                  TEXT("acmStreamSize() failed with error = %u!"), mmr);

        return (FALSE);
    }



    //
    //  first try to open the file, etc.. open the given file for reading
    //  using buffered I/O
    //
    paacd->hmmioSrc = mmioOpen(paacd->szFilePathSrc,
                               NULL,
                               MMIO_READ | MMIO_DENYWRITE | MMIO_ALLOCBUF);
    if (NULL == paacd->hmmioSrc)
        goto aacb_Error;

    //
    //
    //
    paacd->hmmioDst = mmioOpen(paacd->szFilePathDst,
                               NULL,
                               MMIO_CREATE | MMIO_WRITE | MMIO_EXCLUSIVE | MMIO_ALLOCBUF);
    if (NULL == paacd->hmmioDst)
        goto aacb_Error;



    //
    //
    //
    //
    pash = &paacd->ash;
    pash->fdwStatus = 0L;


    //
    //  allocate the src and dst buffers for reading/converting data
    //
    paacd->pbSrc = (HPSTR)GlobalAllocPtr(GHND, paacd->cbSrcReadSize);
    if (NULL == paacd->pbSrc)
        goto aacb_Error;
    
    paacd->pbDst = (HPSTR)GlobalAllocPtr(GHND, paacd->cbDstBufSize);
    if (NULL == paacd->pbDst)
        goto aacb_Error;


    //
    //
    //
    //
    pash->cbStruct          = sizeof(*pash);
    pash->fdwStatus         = 0L;
    pash->dwUser            = 0L;
    pash->pbSrc             = paacd->pbSrc;
    pash->cbSrcLength       = paacd->cbSrcReadSize;
    pash->cbSrcLengthUsed   = 0L;
    pash->dwSrcUser         = paacd->cbSrcReadSize;
    pash->pbDst             = paacd->pbDst;
    pash->cbDstLength       = paacd->cbDstBufSize;
    pash->cbDstLengthUsed   = 0L;
    pash->dwDstUser         = paacd->cbDstBufSize;

    mmr = acmStreamPrepareHeader(paacd->has, pash, 0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION,
                    TEXT("acmStreamPrepareHeader() failed with error = %u!"), mmr);

        goto aacb_Error;
    }                          



    //
    //  create the RIFF chunk of form type 'WAVE'
    //
    //
    paacd->ckDstRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    paacd->ckDstRIFF.cksize  = 0L;
    if (mmioCreateChunk(paacd->hmmioDst, &paacd->ckDstRIFF, MMIO_CREATERIFF))
        goto aacb_Error;

    //
    //  locate a 'WAVE' form type in a 'RIFF' thing...
    //
    ckSrcRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    if (mmioDescend(paacd->hmmioSrc, (LPMMCKINFO)&ckSrcRIFF, NULL, MMIO_FINDRIFF))
        goto aacb_Error;

    //
    //  we found a WAVE chunk--now go through and get all subchunks that
    //  we know how to deal with...
    //
    while (mmioDescend(paacd->hmmioSrc, &ck, &ckSrcRIFF, 0) == 0)
    {
        //
        //  quickly check for corrupt RIFF file--don't ascend past end!
        //
        if ((ck.dwDataOffset + ck.cksize) > (ckSrcRIFF.dwDataOffset + ckSrcRIFF.cksize))
            goto aacb_Error;

        switch (ck.ckid)
        {
            //
            //  explicitly skip these...
            //
            //
            //
            case mmioFOURCC('f', 'm', 't', ' '):
                break;

            case mmioFOURCC('d', 'a', 't', 'a'):
                break;

            case mmioFOURCC('f', 'a', 'c', 't'):
                break;

            case mmioFOURCC('J', 'U', 'N', 'K'):
                break;

            case mmioFOURCC('P', 'A', 'D', ' '):
                break;

            case mmioFOURCC('c', 'u', 'e', ' '):
                break;


            //
            //  copy chunks that are OK to copy
            //
            //
            //
            case mmioFOURCC('p', 'l', 's', 't'):
                // although without the 'cue' chunk, it doesn't make much sense
                riffCopyChunk(paacd->hmmioSrc, paacd->hmmioDst, &ck);
                break;

            case mmioFOURCC('D', 'I', 'S', 'P'):
                riffCopyChunk(paacd->hmmioSrc, paacd->hmmioDst, &ck);
                break;

                
            //
            //  don't copy unknown chunks
            //
            //
            //
            default:
                break;
        }

        //
        //  step up to prepare for next chunk..
        //
        mmioAscend(paacd->hmmioSrc, &ck, 0);
    }

#if 0
    //
    //  now write out possibly editted chunks...
    //
    if (riffWriteINFO(paacd->hmmioDst, (glpwio->pInfo)))
    {
        goto aacb_Error;
    }
#endif

    //
    // go back to beginning of data portion of WAVE chunk
    //
    if (-1 == mmioSeek(paacd->hmmioSrc, ckSrcRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET))
        goto aacb_Error;

    ck.ckid = mmioFOURCC('d', 'a', 't', 'a');
    mmioDescend(paacd->hmmioSrc, &ck, &ckSrcRIFF, MMIO_FINDCHUNK);


    //
    //  now create the destination fmt, fact, and data chunks _in that order_
    //
    //
    //
    //  hmmio is now descended into the 'RIFF' chunk--create the format chunk
    //  and write the format header into it
    //
    dw = SIZEOF_WAVEFORMATEX(paacd->pwfxDst);

    paacd->ckDst.ckid   = mmioFOURCC('f', 'm', 't', ' ');
    paacd->ckDst.cksize = dw;
    if (mmioCreateChunk(paacd->hmmioDst, &paacd->ckDst, 0))
        goto aacb_Error;

    if (mmioWrite(paacd->hmmioDst, (HPSTR)paacd->pwfxDst, dw) != (LONG)dw)
        goto aacb_Error;

    if (mmioAscend(paacd->hmmioDst, &paacd->ckDst, 0) != 0)
        goto aacb_Error;

    //
    //  create the 'fact' chunk (not necessary for PCM--but is nice to have)
    //  since we are not writing any data to this file (yet), we set the
    //  samples contained in the file to 0..
    //
    paacd->ckDst.ckid   = mmioFOURCC('f', 'a', 'c', 't');
    paacd->ckDst.cksize = 0L;
    if (mmioCreateChunk(paacd->hmmioDst, &paacd->ckDst, 0))
        goto aacb_Error;

    if (mmioWrite(paacd->hmmioDst, (HPSTR)&paacd->dwSrcSamples, sizeof(DWORD)) != sizeof(DWORD))
        goto aacb_Error;

    if (mmioAscend(paacd->hmmioDst, &paacd->ckDst, 0) != 0)
        goto aacb_Error;


    //
    //  create the data chunk AND STAY DESCENDED... for reasons that will
    //  become apparent later..
    //
    paacd->ckDst.ckid   = mmioFOURCC('d', 'a', 't', 'a');
    paacd->ckDst.cksize = 0L;
    if (mmioCreateChunk(paacd->hmmioDst, &paacd->ckDst, 0))
        goto aacb_Error;

    //
    //  at this point, BOTH the src and dst files are sitting at the very
    //  beginning of their data chunks--so we can READ from the source,
    //  CONVERT the data, then WRITE it to the destination file...
    //
    return (TRUE);


    //
    //
    //
    //
aacb_Error:

    AcmAppConvertEnd(hdlg, paacd);

    return (FALSE);
} // AcmAppConvertBegin()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppConvertConvert
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hdlg:
//  
//      PAACONVERTDESC paacd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppConvertConvert
(
    HWND                hdlg,
    PAACONVERTDESC     paacd
)
{
    MMRESULT            mmr;
    TCHAR               ach[40];
    DWORD               dw;
    WORD                w;
    DWORD               dwCurrent;
    WORD                wCurPercent;
    LPACMSTREAMHEADER   pash;
    DWORD               cbRead;
    DWORD               dwTime;


    wCurPercent = (WORD)-1;

    paacd->cTotalConverts    = 0L;
    paacd->dwTimeTotal       = 0L;
    paacd->dwTimeLongest     = 0L;
    if (0 == paacd->cbSrcData)
    {
        paacd->dwTimeShortest    = 0L;
        paacd->dwShortestConvert = 0L;
        paacd->dwLongestConvert  = 0L;
    }
    else
    {
        paacd->dwTimeShortest    = (DWORD)-1L;
        paacd->dwShortestConvert = (DWORD)-1L;
        paacd->dwLongestConvert  = (DWORD)-1L;
    }

    pash = &paacd->ash;

    for (dwCurrent = 0; dwCurrent < paacd->cbSrcData; )
    {
        w = (WORD)((dwCurrent * 100) / paacd->cbSrcData);
        if (w != wCurPercent)
        {
            wCurPercent = w;
            wsprintf(ach, TEXT("%u%%"), wCurPercent);
            SetDlgItemText(hdlg, IDD_AACONVERT_TXT_STATUS, ach);
        }

        AppDlgYield(hdlg);

        if (gfCancelConvert)
            goto aacc_Error;

        //
        //
        //
        cbRead = min(paacd->cbSrcReadSize, paacd->cbSrcData - dwCurrent);
        dw = mmioRead(paacd->hmmioSrc, paacd->pbSrc, cbRead);
        if (0L == dw)
            break;


        AppDlgYield(hdlg);
        if (gfCancelConvert)
            goto aacc_Error;

             

        //
        //
        //
        pash->cbSrcLength     = dw;
        pash->cbDstLengthUsed = 0L;



        dwTime = timeGetTime();

        mmr = acmStreamConvert(paacd->has,
                               &paacd->ash,
                               ACM_STREAMCONVERTF_BLOCKALIGN);

        if (MMSYSERR_NOERROR != mmr)
        {
            AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION,
                      TEXT("acmStreamConvert() failed with error = %u!"), mmr);
            goto aacc_Error;
        }

        while (0 == (ACMSTREAMHEADER_STATUSF_DONE & ((AACONVERTDESC volatile *)paacd)->ash.fdwStatus))
            ;

        dwTime = timeGetTime() - dwTime;


        paacd->dwTimeTotal += dwTime;

        if (dwTime < paacd->dwTimeShortest)
        {
            paacd->dwTimeShortest    = dwTime;
            paacd->dwShortestConvert = paacd->cTotalConverts;
        }

        if (dwTime > paacd->dwTimeLongest)
        {
            paacd->dwTimeLongest     = dwTime;
            paacd->dwLongestConvert  = paacd->cTotalConverts;
        }

        paacd->cTotalConverts++;


        AppDlgYield(hdlg);
        if (gfCancelConvert)
            goto aacc_Error;


        //
        //
        //
        dw = (cbRead - pash->cbSrcLengthUsed);
        if (0L != dw)
        {
            mmioSeek(paacd->hmmioSrc, -(LONG)dw, SEEK_CUR);
        }

        dwCurrent += pash->cbSrcLengthUsed;


        //
        //
        //
        dw = pash->cbDstLengthUsed;
        if (0L == dw)
            break;
          
        if (mmioWrite(paacd->hmmioDst, paacd->pbDst, dw) != (LONG)dw)
            goto aacc_Error;
    }


    //
    //
    //
    //
    //
    //
    wCurPercent = (WORD)-1;

    for (;paacd->cbSrcData;)
    {
        w = (WORD)((dwCurrent * 100) / paacd->cbSrcData);
        if (w != wCurPercent)
        {
            wCurPercent = w;
            wsprintf(ach, TEXT("Cleanup Pass -- %u%%"), wCurPercent);
            SetDlgItemText(hdlg, IDD_AACONVERT_TXT_STATUS, ach);
        }

        AppDlgYield(hdlg);
        if (gfCancelConvert)
            goto aacc_Error;


        //
        //
        //
        dw = 0L;
        cbRead = min(paacd->cbSrcReadSize, paacd->cbSrcData - dwCurrent);
        if (0L != cbRead)
        {
            dw = mmioRead(paacd->hmmioSrc, paacd->pbSrc, cbRead);
            if (0L == dw)
                break;
        }


        AppDlgYield(hdlg);
        if (gfCancelConvert)
            goto aacc_Error;

             

        //
        //
        //
        pash->cbSrcLength     = dw;
        pash->cbDstLengthUsed = 0L;



        dwTime = timeGetTime();

        mmr = acmStreamConvert(paacd->has,
                               &paacd->ash,
                               ACM_STREAMCONVERTF_BLOCKALIGN |
                               ACM_STREAMCONVERTF_END);

        if (MMSYSERR_NOERROR != mmr)
        {
            AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION,
                      TEXT("acmStreamConvert() failed with error = %u!"), mmr);
            goto aacc_Error;
        }

        while (0 == (ACMSTREAMHEADER_STATUSF_DONE & ((AACONVERTDESC volatile *)paacd)->ash.fdwStatus))
            ;

        dwTime = timeGetTime() - dwTime;


        paacd->dwTimeTotal += dwTime;

        if (dwTime < paacd->dwTimeShortest)
        {
            paacd->dwTimeShortest    = dwTime;
            paacd->dwShortestConvert = paacd->cTotalConverts;
        }

        if (dwTime > paacd->dwTimeLongest)
        {
            paacd->dwTimeLongest     = dwTime;
            paacd->dwLongestConvert  = paacd->cTotalConverts;
        }

        paacd->cTotalConverts++;


        AppDlgYield(hdlg);
        if (gfCancelConvert)
            goto aacc_Error;

        //
        //
        //
        dw = pash->cbDstLengthUsed;
        if (0L == dw)
        {
            pash->cbDstLengthUsed = 0L;

            mmr = acmStreamConvert(paacd->has,
                                   &paacd->ash,
                                   ACM_STREAMCONVERTF_END);

            if (MMSYSERR_NOERROR == mmr)
            {
                while (0 == (ACMSTREAMHEADER_STATUSF_DONE & ((AACONVERTDESC volatile *)paacd)->ash.fdwStatus))
                    ;
            }

            dw = pash->cbDstLengthUsed;
            if (0L == dw)
                break;
        }
          
        if (mmioWrite(paacd->hmmioDst, paacd->pbDst, dw) != (LONG)dw)
            goto aacc_Error;

        //
        //
        //
        dw = (cbRead - pash->cbSrcLengthUsed);
        if (0L != dw)
        {
            mmioSeek(paacd->hmmioSrc, -(LONG)dw, SEEK_CUR);
        }

        dwCurrent += pash->cbSrcLengthUsed;

        if (0L == pash->cbDstLengthUsed)
            break;
    }


    EndConvert(hdlg, !gfCancelConvert, paacd);

    return (!gfCancelConvert);


aacc_Error:

    EndConvert(hdlg, FALSE, paacd);
    return (FALSE);
} // AcmAppConvertConvert()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppConvertDlgProc
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hdlg:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppConvertDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PAACONVERTDESC      paacd;
    UINT                uId;

    paacd = (PAACONVERTDESC)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            paacd = (PAACONVERTDESC)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

            SetWindowFont(GetDlgItem(hwnd, IDD_AACONVERT_TXT_INFILEPATH), ghfontApp, FALSE);
            SetWindowFont(GetDlgItem(hwnd, IDD_AACONVERT_TXT_OUTFILEPATH), ghfontApp, FALSE);
            SetWindowFont(GetDlgItem(hwnd, IDD_AACONVERT_TXT_STATUS), ghfontApp, FALSE);

            SetDlgItemText(hwnd, IDD_AACONVERT_TXT_INFILEPATH, paacd->szFilePathSrc);
            SetDlgItemText(hwnd, IDD_AACONVERT_TXT_OUTFILEPATH, paacd->szFilePathDst);

            BeginConvert(hwnd, paacd);
            return (TRUE);


        case WM_CONVERT_BEGIN:
            gfCancelConvert = FALSE;
            if (AcmAppConvertBegin(hwnd, paacd))
            {
                AcmAppConvertConvert(hwnd, paacd);
            }
            else
            {
                EndConvert(hwnd, FALSE, paacd);
            }
            break;


        case WM_CONVERT_END:
            AcmAppConvertEnd(hwnd, paacd);
            EndDialog(hwnd, !gfCancelConvert);
            break;


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            if (IDCANCEL == uId)
            {
                gfCancelConvert = TRUE;
            }
            break;
    }

    return (FALSE);
} // AcmAppConvertDlgProc()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppFileConvert
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppFileConvert
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    BOOL                f;
    DWORD               nAvgBytesPerSec;
    DWORD               nBlockAlign;
    DWORD               dwTimeAverage;
    PAACONVERTDESC      paacd;

    paacd = (PAACONVERTDESC)LocalAlloc(LPTR, sizeof(*paacd));
    if (NULL == paacd)
    {
        return (FALSE);
    }


    //
    //
    //
    paacd->hmmioSrc      = NULL;
    paacd->hmmioDst      = NULL;

    //
    //  default to 1 second per convert buffer..
    //
    paacd->uBufferTimePerConvert = 1000;

    paacd->dwSrcSamples  = paafd->dwDataSamples;


    //
    //  compute source bytes to read (round down to nearest block for
    //  one second of data)
    //
    nAvgBytesPerSec     = paafd->pwfx->nAvgBytesPerSec;
    nBlockAlign         = paafd->pwfx->nBlockAlign;
    paacd->cbSrcReadSize = nAvgBytesPerSec - (nAvgBytesPerSec % nBlockAlign);

    paacd->cbDstBufSize  = 0L;
    paacd->fdwOpen       = 0L;

    lstrcpy(paacd->szFilePathSrc, paafd->szFilePath);
    paacd->pwfxSrc       = paafd->pwfx;
    paacd->pbSrc         = NULL;

    paacd->cbSrcData     = paafd->dwDataBytes;

    lstrcpy(paacd->szFilePathDst, gszLastSaveFile);
    paacd->pwfxDst       = NULL;
    paacd->pbDst         = NULL;

    paacd->fApplyFilter  = FALSE;
    paacd->pwfltr        = NULL;


    paacd->cTotalConverts     = 0L;
    paacd->dwTimeTotal        = 0L;
    paacd->dwTimeShortest     = (DWORD)-1L;
    paacd->dwShortestConvert  = (DWORD)-1L;
    paacd->dwTimeLongest      = 0L;
    paacd->dwLongestConvert   = (DWORD)-1L;

    //
    //
    //
    f = DialogBoxParam(ghinst,
                       DLG_AACHOOSER,
                       hwnd,
                       AcmAppDlgProcChooser,
                       (LPARAM)(UINT)paacd);
    if (f)
    {
        lstrcpy(gszLastSaveFile, paacd->szFilePathDst);

        //
        //
        //
        f = DialogBoxParam(ghinst,
                            DLG_AACONVERT,
                            hwnd,
                            AcmAppConvertDlgProc,
                            (LPARAM)(UINT)paacd);
        if (!f)
        {
            AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                        TEXT("Conversion aborted--destination file is corrupt!"));
        }


        if (paacd->cTotalConverts > 1)
        {
            dwTimeAverage  = paacd->dwTimeTotal;
            dwTimeAverage -= paacd->dwTimeShortest;

            dwTimeAverage /= (paacd->cTotalConverts - 1);
        }
        else
        {
            dwTimeAverage = paacd->dwTimeTotal;
        }

        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                    TEXT("Conversion Statistics:\n\nTotal Time:\t%lu ms\nTotal Converts:\t%lu\nShortest Time:\t%lu ms (on %lu)\nLongest Time:\t%lu ms (on %lu)\n\nAverage Time:\t%lu ms"),
                    paacd->dwTimeTotal,
                    paacd->cTotalConverts,
                    paacd->dwTimeShortest,
                    paacd->dwShortestConvert,
                    paacd->dwTimeLongest,
                    paacd->dwLongestConvert,
                    dwTimeAverage);

        if (f)
        {
            AcmAppOpenInstance(hwnd, paacd->szFilePathDst, FALSE);
        }
    }


    //
    //
    //
    if (NULL != paacd->pwfxDst)
    {
        GlobalFreePtr(paacd->pwfxDst);
        paacd->pwfxDst = NULL;
    }

    if (NULL != paacd->pwfltr)
    {
        GlobalFreePtr(paacd->pwfltr);
        paacd->pwfltr = NULL;
    }

    paacd->pwfxSrc = NULL;


    LocalFree((HLOCAL)paacd);

    return (f);
} // AcmAppFileConvert()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\aadrvs.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//--------------------------------------------------------------------------;
//
//  aadrvs.c
//
//  Description:
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <memory.h>
#include "tlb.h"

#include "appport.h"
#include "acmapp.h"

#include "debug.h"


TCHAR   gszFormatDriversTitle[] = TEXT("Id\t4!Name\t12!Priority\t6!Support\t6!Full Name");
TCHAR   gszFormatDriversList[]  = TEXT("%.04Xh\t%s\t%lu%s\t%.08lXh\t%s");

TCHAR   gszFormatDriverFormatsTitle[] = TEXT("Id\t4!Index\t2!Tag\t2!Support\t5!cbwfx\t2!Format");
TCHAR   gszFormatDriverFormatsList[]  = TEXT("%.04Xh\t%lu\t%lu\t%.08lXh\t%u\t%-s");

static HACMDRIVERID     ghadidSelected;
static HACMDRIVER       ghadSelected;


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDisplayDriverDetails
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      HACMDRIVER had:
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppDisplayDriverDetails
(
    HWND            hedit,
    HACMDRIVERID    hadid
)
{
    static TCHAR    szDisplayTitle[]  = TEXT("[Driver Details]\r\n");

    MMRESULT            mmr;
    ACMDRIVERDETAILS    add;

    //
    //
    //
    MEditPrintF(hedit, szDisplayTitle);

    MEditPrintF(hedit, TEXT("%25s: %.04Xh"), (LPTSTR)TEXT("Driver Identifier Handle"), hadid);

    //
    //
    //
    //
    add.cbStruct = sizeof(add);
    mmr = acmDriverDetails(hadid, &add, 0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        //
        //  this should never happen..
        //
        MEditPrintF(hedit, TEXT("%25s: %.08lXh"), (LPTSTR)TEXT("ERROR GETTING DRIVER DETAILS"), mmr);
        return (FALSE);
    }


    //
    //
    //
    //
    MEditPrintF(hedit, TEXT("%25s: %lu bytes (requested %lu)"),
                   (LPTSTR)TEXT("Size of Driver Details"),
                   add.cbStruct, (DWORD)sizeof(add));

    //
    //  this would be bad
    //
    if (add.cbStruct < sizeof(add))
        return (0L);

    MEditPrintF(hedit, TEXT("%25s: %.08lXh (%s)"), (LPTSTR)TEXT("FCC Type"),
                   add.fccType,
                   (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC == add.fccType) ?
                   (LPTSTR)TEXT("'audc'") : (LPTSTR)TEXT("**INVALID**"));

    MEditPrintF(hedit, TEXT("%25s: %.08lXh (%s)"), (LPTSTR)TEXT("FCC Compressor"),
                   add.fccComp,
                   (ACMDRIVERDETAILS_FCCCOMP_UNDEFINED == add.fccComp) ?
                   (LPTSTR)TEXT("correct") : (LPTSTR)TEXT("**INVALID**"));

    MEditPrintF(hedit, TEXT("%25s: %u"), (LPTSTR)TEXT("Manufacturer Id"), add.wMid);
    MEditPrintF(hedit, TEXT("%25s: %u"), (LPTSTR)TEXT("Product Id"), add.wPid);

    MEditPrintF(hedit, TEXT("%25s: %u.%.02u (Build %.03u)"), (LPTSTR)TEXT("ACM Version Required"),
                   HIWORD(add.vdwACM) >> 8,
                   HIWORD(add.vdwACM) & 0x00FF,
                   LOWORD(add.vdwACM));

    MEditPrintF(hedit, TEXT("%25s: %u.%.02u (Build %.03u)"), (LPTSTR)TEXT("CODEC Version"),
                   HIWORD(add.vdwDriver) >> 8,
                   HIWORD(add.vdwDriver) & 0x00FF,
                   LOWORD(add.vdwDriver));

    MEditPrintF(hedit, TEXT("%25s: %.08lXh"), (LPTSTR)TEXT("Standard Support"), add.fdwSupport);
    MEditPrintF(hedit, TEXT("%25s: %u"), (LPTSTR)TEXT("Count Format Tags"), add.cFormatTags);
    MEditPrintF(hedit, TEXT("%25s: %u"), (LPTSTR)TEXT("Count Filter Tags"), add.cFilterTags);
    MEditPrintF(hedit, TEXT("%25s: %.04Xh"), (LPTSTR)TEXT("Custom Icon Handle"), add.hicon);
    MEditPrintF(hedit, TEXT("%25s: '%s'"), (LPTSTR)TEXT("Short Name"), (LPTSTR)add.szShortName);
    MEditPrintF(hedit, TEXT("%25s: '%s'"), (LPTSTR)TEXT("Long Name"), (LPTSTR)add.szLongName);
    MEditPrintF(hedit, TEXT("%25s: '%s'"), (LPTSTR)TEXT("Copyright"), (LPTSTR)add.szCopyright);
    MEditPrintF(hedit, TEXT("%25s: '%s'"), (LPTSTR)TEXT("Licensing"), (LPTSTR)add.szLicensing);
    MEditPrintF(hedit, TEXT("%25s: '%s'\r\n"), (LPTSTR)TEXT("Features"), (LPTSTR)add.szFeatures);


    //
    //
    //
    if (0 != (ACMDRIVERDETAILS_SUPPORTF_HARDWARE & add.fdwSupport))
    {
        TCHAR       ach[40];
        DWORD       dw;

        mmr = acmMetrics((HACMOBJ)hadid, ACM_METRIC_HARDWARE_WAVE_INPUT, &dw);
        AcmAppGetErrorString(mmr, ach);
        MEditPrintF(hedit, TEXT("%25s: %ld (mmr = %s, [%u])"), (LPTSTR)TEXT("Wave Input Device"), dw, (LPTSTR)ach, mmr);

        mmr = acmMetrics((HACMOBJ)hadid, ACM_METRIC_HARDWARE_WAVE_OUTPUT, &dw);
        AcmAppGetErrorString(mmr, ach);
        MEditPrintF(hedit, TEXT("%25s: %ld (mmr = %s, [%u])"), (LPTSTR)TEXT("Wave Output Device"), dw, (LPTSTR)ach, mmr);
    }

    return (TRUE);
} // AcmAppDisplayDriverDetails()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDisplayFormats
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      HACMDRIVER had:
//  
//      ACMFORMATTAGDETAILS paftd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppDisplayFormats
(
    HWND                    hedit,
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd
)
{
    MMRESULT            mmr;
    UINT                u;
    ACMFORMATDETAILS    afd;
    PWAVEFORMATEX       pwfx;

    if (0 == paftd->cStandardFormats)
        return (TRUE);

    pwfx = (PWAVEFORMATEX)LocalAlloc(LPTR, (UINT)paftd->cbFormatSize);
    if (NULL == pwfx)
        return (FALSE);

    //
    //
    //
    //
    for (u = 0; u < paftd->cStandardFormats; u++)
    {
        afd.cbStruct        = sizeof(afd);
        afd.dwFormatIndex   = u;
        afd.dwFormatTag     = paftd->dwFormatTag;
        afd.fdwSupport      = 0L;
        afd.pwfx            = pwfx;
        afd.cbwfx           = paftd->cbFormatSize;
        afd.szFormat[0]     = '\0';

        mmr = acmFormatDetails(had, &afd, ACM_FORMATDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
        {
            //
            //  this should never happen..
            //
            MEditPrintF(hedit, TEXT("%25s: err = %.04Xh"), (LPTSTR)TEXT("ERROR GETTING FORMAT DETAILS"), mmr);
            continue;
        }


        //
        //  this would be bad
        //
        if (afd.cbStruct < sizeof(afd))
        {
            MEditPrintF(hedit, TEXT("%25s: %lu bytes (requested %lu)"), (LPTSTR)TEXT("Size of Format Details"),
                        afd.cbStruct, (DWORD)sizeof(afd));
            continue;
        }

        MEditPrintF(hedit, TEXT("%15s %u: '%s'"), (LPTSTR)TEXT("Format"), u, (LPTSTR)afd.szFormat);

    }

    LocalFree((HLOCAL)pwfx);

    return (TRUE);
} // AcmAppDisplayFormats()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDisplayDriverTags
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      HACMDRIVER had:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppDisplayDriverTags
(
    HWND            hedit,
    HACMDRIVER      had
)
{
    static TCHAR    szDisplayTitle[]      = TEXT("[Driver Tags]\r\n");
    static TCHAR    szDisplayFormatTags[] = TEXT("\r\n[Format Tags]");
    static TCHAR    szDisplayFilterTags[] = TEXT("\r\n[Filter Tags]");

    TCHAR               ach[APP_MAX_STRING_CHARS];
    ACMDRIVERDETAILS    add;
    MMRESULT            mmr;
    UINT                u;
    HACMDRIVERID        hadid;

    //
    //
    //
    MEditPrintF(hedit, szDisplayTitle);

    mmr = acmDriverID((HACMOBJ)had, &hadid, 0L);
    MEditPrintF(hedit, TEXT("%25s: %.04Xh"), (LPTSTR)TEXT("Driver Identifier Handle"), hadid);
    MEditPrintF(hedit, TEXT("%25s: %.04Xh"), (LPTSTR)TEXT("Driver Handle"), had);

    //
    //
    //
    //
    add.cbStruct = sizeof(add);
    mmr = acmDriverDetails(hadid, &add, 0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        //
        //  this should never happen..
        //
        MEditPrintF(hedit, TEXT("%25s: %.08lXh"), (LPTSTR)TEXT("ERROR GETTING INFO"), mmr);
        return (FALSE);
    }


    MEditPrintF(hedit, TEXT("%25s: '%s'"), (LPTSTR)TEXT("Name"), (LPTSTR)add.szShortName);
    MEditPrintF(hedit, TEXT("%25s: %u"), (LPTSTR)TEXT("Count Format Tags"), add.cFormatTags);
    MEditPrintF(hedit, TEXT("%25s: %u"), (LPTSTR)TEXT("Count Filter Tags"), add.cFilterTags);

    if (0 != add.cFormatTags)
        MEditPrintF(hedit, szDisplayFormatTags);

    for (u = 0; u < add.cFormatTags; u++)
    {
        ACMFORMATTAGDETAILS aftd;
        WAVEFORMATEX        wfx;

        MEditPrintF(hedit, TEXT("\r\n%25s: %u"), (LPTSTR)TEXT("Format Tag Index"), u);

        _fmemset(&aftd, 0, sizeof(aftd));

        aftd.cbStruct         = sizeof(aftd);
        aftd.dwFormatTagIndex = u;
        mmr = acmFormatTagDetails(had, &aftd, ACM_FORMATTAGDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
        {
            MEditPrintF(hedit, TEXT("%25s: %.08lXh"), (LPTSTR)TEXT("ERROR GETTING TAGS"), mmr);
            return (FALSE);
        }

        MEditPrintF(hedit, TEXT("%25s: %lu bytes (requested %lu)"),
                    (LPTSTR)TEXT("Size of Tag Details"),
                    aftd.cbStruct, (DWORD)sizeof(aftd));

        //
        //  this would be bad
        //
        if (aftd.cbStruct < sizeof(aftd))
            continue;

        wfx.wFormatTag = LOWORD(aftd.dwFormatTag);
        AcmAppGetFormatDescription(&wfx, ach, NULL);
        MEditPrintF(hedit, TEXT("%25s: [%lu], %s"), (LPTSTR)TEXT("Format Tag"), aftd.dwFormatTag, (LPTSTR)ach);
        MEditPrintF(hedit, TEXT("%25s: %u bytes"), (LPTSTR)TEXT("Format Size (Max)"), aftd.cbFormatSize);
        MEditPrintF(hedit, TEXT("%25s: %.08lXh"), (LPTSTR)TEXT("Standard Support"), aftd.fdwSupport);
        MEditPrintF(hedit, TEXT("%25s: %lu"), (LPTSTR)TEXT("Standard Formats"), aftd.cStandardFormats);
        MEditPrintF(hedit, TEXT("%25s: '%s'"), (LPTSTR)TEXT("Format Tag Name"), (LPTSTR)aftd.szFormatTag);

        AcmAppDisplayFormats(hedit, had, &aftd);
    }

    if (0 != add.cFilterTags)
        MEditPrintF(hedit, szDisplayFilterTags);

    for (u = 0; u < add.cFilterTags; u++)
    {
        ACMFILTERTAGDETAILS aftd;
        WAVEFILTER          wfltr;

        MEditPrintF(hedit, TEXT("%25s: %u"), (LPTSTR)TEXT("Filter Tag Index"), u);

        _fmemset(&aftd, 0, sizeof(aftd));

        aftd.cbStruct         = sizeof(aftd);
        aftd.dwFilterTagIndex = u;
        mmr = acmFilterTagDetails(had, &aftd, ACM_FILTERTAGDETAILSF_INDEX);
        if (MMSYSERR_NOERROR != mmr)
        {
            //
            //
            //
            MEditPrintF(hedit, TEXT("%25s: %.08lXh"), (LPTSTR)TEXT("ERROR GETTING TAGS"), mmr);

            return (FALSE);
        }

        MEditPrintF(hedit, TEXT("%25s: %lu bytes (requested %lu)"),
                    (LPTSTR)TEXT("Size of Tag Details"),
                    aftd.cbStruct, (DWORD)sizeof(aftd));

        //
        //  this would be bad
        //
        if (aftd.cbStruct < sizeof(aftd))
            continue;

        wfltr.dwFilterTag = aftd.dwFilterTag;
        AcmAppGetFilterDescription(&wfltr, ach, NULL);
        MEditPrintF(hedit, TEXT("%25s: [%lu], %s"), (LPTSTR)TEXT("Filter Tag"), aftd.dwFilterTag, (LPTSTR)ach);
        MEditPrintF(hedit, TEXT("%25s: %lu bytes"), (LPTSTR)TEXT("Format Size (Max)"), aftd.cbFilterSize);
        MEditPrintF(hedit, TEXT("%25s: %.08lXh"), (LPTSTR)TEXT("Standard Support"), aftd.fdwSupport);
        MEditPrintF(hedit, TEXT("%25s: %lu"), (LPTSTR)TEXT("Standard Filters"), aftd.cStandardFilters);
        MEditPrintF(hedit, TEXT("%25s: '%s'\r\n"), (LPTSTR)TEXT("Filter Tag Name"), (LPTSTR)aftd.szFilterTag);
    }


    return (TRUE);
} // AcmAppDisplayDriverTags()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDriverDetailsDlgProc
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDriverDetailsDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    HACMDRIVERID        hadid;
    HWND                hedit;
    UINT                uId;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            hedit = GetDlgItem(hwnd, IDD_AADETAILS_EDIT_DETAILS);
            SetWindowFont(hedit, ghfontApp, FALSE);

            //
            //  clear the display
            //
            AppHourGlass(TRUE);
            SetWindowRedraw(hedit, FALSE);
            MEditPrintF(hedit, NULL);

            hadid = (HACMDRIVERID)(UINT)lParam;
            if (NULL == hadid)
            {
                MEditPrintF(hedit, TEXT("\r\n\r\nhmm..."));
            }
            else
            {
                AcmAppDisplayDriverDetails(hedit, hadid);
            }

            Edit_SetSel(hedit, (WPARAM)0, (LPARAM)0);

            SetWindowRedraw(hedit, TRUE);
            AppHourGlass(FALSE);

            return (TRUE);

        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);

            if ((IDOK == uId) || (IDCANCEL == uId))
            {
                EndDialog(hwnd, (IDOK == uId));
            }
            break;
    }

    return (FALSE);
} // AcmAppDriverDetailsDlgProc()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDriverFormatDetailsDlgProc
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDriverFormatDetailsDlgProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    HACMDRIVERID        hadid;
    HWND                hlb;
    HWND                hedit;
    int                 n;
    UINT                uId;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            hlb = GetDlgItem(GetParent(hwnd), IDD_AADRIVERFORMATS_LIST_FORMATS);
            n   = ListBox_GetCurSel(hlb);
            if (LB_ERR == n)
                return (TRUE);

            hadid = (HACMDRIVERID)(UINT)ListBox_GetItemData(hlb, n);
            hedit = GetDlgItem(hwnd, IDD_AADETAILS_EDIT_DETAILS);
            SetWindowFont(hedit, ghfontApp, FALSE);

            //
            //  clear the display
            //
            AppHourGlass(TRUE);
            SetWindowRedraw(hedit, FALSE);
            MEditPrintF(hedit, NULL);

            MEditPrintF(hedit, TEXT("\r\n\r\nFormat Details!"));

            Edit_SetSel(hedit, (WPARAM)0, (LPARAM)0);

            SetWindowRedraw(hedit, TRUE);
            AppHourGlass(FALSE);
            return (TRUE);

        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            if ((IDOK == uId) || (IDCANCEL == uId))
            {
                EndDialog(hwnd, (IDOK == uId));
            }
            break;
    }

    return (FALSE);
} // AcmAppDriverFormatDetailsDlgProc()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDriverFormatEnumCallback
//  
//  Description:
//  
//  
//  Arguments:
//      HACMDRIVERID hadid:
//  
//      DWORD dwInstance:
//  
//      DWORD fdwSupport:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDriverFormatEnumCallback
(
    HACMDRIVERID        hadid,
    LPACMFORMATDETAILS  pafd,
    DWORD               dwInstance,
    DWORD               fdwSupport
)
{
    TCHAR               ach[APP_MAX_STRING_CHARS];
    HWND                hlb;
    int                 nIndex;
    LPARAM              lParam;
    UINT                cbwfx;

    //
    //
    //
    hlb = (HWND)(UINT)dwInstance;

    cbwfx = SIZEOF_WAVEFORMATEX(pafd->pwfx);

    wsprintf(ach, gszFormatDriverFormatsList,
             hadid,
             pafd->dwFormatIndex,
             pafd->dwFormatTag,
             pafd->fdwSupport,
             cbwfx,
             (LPTSTR)pafd->szFormat);

    AcmAppDebugLog(ach);
    AcmAppDebugLog(TEXT("\r\n"));

                
    nIndex = ListBox_AddString(hlb, ach);
    lParam = (LPARAM)(UINT)hadid;
    ListBox_SetItemData(hlb, nIndex, lParam);

    //
    //  return TRUE to continue with enumeration
    //
    return (TRUE);
} // AcmAppDriverFormatEnumCallback()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppDriverFormatsDlgProc
//
//  Description:
//      This dialog procedure is used to display driver formats.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDriverFormatsDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    static PTABBEDLISTBOX   ptlb;
    HWND                    hwndStatic;
    MMRESULT                mmr;
    RECT                    rc;
    PAINTSTRUCT             ps;
    UINT                    uId;
    UINT                    uCode;

    HACMDRIVER              had;
    ACMFORMATDETAILS        afd;
    PWAVEFORMATEX           pwfx;
    DWORD                   cbwfx;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            hwndStatic = GetDlgItem(hwnd, IDD_AADRIVERFORMATS_STATIC_POSITION);

            GetWindowRect(hwndStatic, &rc);
            ScreenToClient(hwnd, (LPPOINT)&rc.left);
            ScreenToClient(hwnd, (LPPOINT)&rc.right);

            ShowWindow(hwndStatic, SW_HIDE);

            EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERFORMATS_BTN_DETAILS), FALSE);

            ptlb = TlbCreate(hwnd, IDD_AADRIVERFORMATS_LIST_FORMATS, &rc);
            if (NULL == ptlb)
                return (TRUE);

            TlbSetFont(ptlb, GetStockFont(ANSI_VAR_FONT), FALSE);
            TlbSetTitleAndTabs(ptlb, gszFormatDriverFormatsTitle, FALSE);

            SetWindowPos(ptlb->hlb, GetDlgItem(hwnd, IDOK), 
                            0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

            ListBox_ResetContent(ptlb->hlb);

            AcmAppDebugLog(NULL);

            had = (HACMDRIVER)(UINT)lParam;

            mmr = acmMetrics((HACMOBJ)had, ACM_METRIC_MAX_SIZE_FORMAT, &cbwfx);
            if (MMSYSERR_NOERROR != mmr)
                return (TRUE);

            pwfx = (PWAVEFORMATEX)LocalAlloc(LPTR, (UINT)cbwfx);
            if (NULL == pwfx)
                return (TRUE);

            _fmemset(&afd, 0, sizeof(afd));

            afd.cbStruct    = sizeof(afd);
            afd.dwFormatTag = WAVE_FORMAT_UNKNOWN;
            afd.pwfx        = pwfx;
            afd.cbwfx       = cbwfx;

            //
            //
            //
            SetWindowRedraw(ptlb->hlb, FALSE);

            mmr = acmFormatEnum(had,
                                &afd,
                                AcmAppDriverFormatEnumCallback,
                                (DWORD)(UINT)ptlb->hlb,
                                0L);
            if (MMSYSERR_NOERROR == mmr)
            {
                ListBox_SetCurSel(ptlb->hlb, 0);
                EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERFORMATS_BTN_DETAILS), TRUE);
            }

            SetWindowRedraw(ptlb->hlb, TRUE);
            LocalFree((HLOCAL)pwfx);

            return (TRUE);

        case WM_PAINT:
            if (NULL != ptlb)
            {
                BeginPaint(hwnd, &ps);
                TlbPaint(ptlb, hwnd, ps.hdc);
                EndPaint(hwnd, &ps);
            }
            break;

        case WM_COMMAND:
            uId   = GET_WM_COMMAND_ID(wParam, lParam);
            uCode = GET_WM_COMMAND_CMD(wParam, lParam);
            switch (uId)
            {
                case IDOK:
                case IDCANCEL:
                    if (NULL != ptlb)
                    {
                        //
                        //  hadidk! don't destroy the listbox window, but
                        //  free all other memory for TLB. the listbox
                        //  window will be destroyed when the dialog is
                        //  destroyed.
                        //
                        ptlb->hlb = NULL;

                        TlbDestroy(ptlb);
                        ptlb = NULL;
                    }

                    EndDialog(hwnd, (IDOK == uId));
                    break;

                case IDD_AADRIVERFORMATS_BTN_DETAILS:
                    DialogBoxParam(ghinst,
                                   DLG_AADETAILS,
                                   hwnd,
                                   AcmAppDriverFormatDetailsDlgProc,
                                   uId);
                    break;

                case IDD_AADRIVERFORMATS_LIST_FORMATS:
                    switch (uCode)
                    {
                        case LBN_SELCHANGE:
                            break;

                        case LBN_DBLCLK:
                            DialogBoxParam(ghinst,
                                           DLG_AADETAILS,
                                           hwnd,
                                           AcmAppDriverFormatDetailsDlgProc,
                                           IDD_AADRIVERFORMATS_BTN_DETAILS);
                            break;
                    }
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppDriverFormatsDlgProc()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDriverEnumCallback
//  
//  Description:
//  
//  
//  Arguments:
//      HACMDRIVERID hadid:
//  
//      DWORD dwInstance:
//  
//      DWORD fdwSupport:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDriverEnumCallback
(
    HACMDRIVERID        hadid,
    DWORD               dwInstance,
    DWORD               fdwSupport
)
{
    static TCHAR    szBogus[]       = TEXT("????");

    MMRESULT            mmr;
    TCHAR               ach[APP_MAX_STRING_CHARS];
    HWND                hlb;
    int                 n;
    ACMDRIVERDETAILS    add;
    BOOL                fDisabled;
    DWORD               dwPriority;

    //
    //
    //
    hlb = (HWND)(UINT)dwInstance;

    add.cbStruct = sizeof(add);
    mmr = acmDriverDetails(hadid, &add, 0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        lstrcpy(add.szShortName, szBogus);
        lstrcpy(add.szLongName,  szBogus);
    }

    dwPriority = (DWORD)-1L;
    acmMetrics((HACMOBJ)hadid, ACM_METRIC_DRIVER_PRIORITY, &dwPriority);

    fDisabled = (0 != (ACMDRIVERDETAILS_SUPPORTF_DISABLED & fdwSupport));

    wsprintf(ach, gszFormatDriversList,
             hadid,
             (LPTSTR)add.szShortName,
             dwPriority,
             fDisabled ? (LPTSTR)TEXT(" (disabled)") : (LPTSTR)gszNull,
             fdwSupport,
             (LPTSTR)add.szLongName);

    AcmAppDebugLog(ach);
    AcmAppDebugLog(TEXT("\r\n"));
                
    n = ListBox_AddString(hlb, ach);
    ListBox_SetItemData(hlb, n, (LPARAM)(UINT)hadid);


    //
    //  return TRUE to continue with enumeration (FALSE will stop the
    //  enumerator)
    //
    return (TRUE);
} // AcmAppDriverEnumCallback()


//--------------------------------------------------------------------------;
//  
//  HACMDRIVERID AcmAppGetSelectedDriver
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//  Return (HACMDRIVERID):
//  
//  
//--------------------------------------------------------------------------;

HACMDRIVERID FNLOCAL AcmAppGetSelectedDriver
(
    HWND            hwnd
)
{
    HWND            hlb;
    UINT            u;
    HACMDRIVERID    hadid;

    hlb = GetDlgItem(hwnd, IDD_AADRIVERS_LIST_DRIVERS);

    u = (UINT)ListBox_GetCurSel(hlb);
    if (LB_ERR == u)
    {
        DPF(0, "!AcmAppGetSelectedDriver: apparently there is no selected driver?");
        return (NULL);
    }

    hadid = (HACMDRIVERID)(UINT)ListBox_GetItemData(hlb, u);
    if (NULL == hadid)
    {
        DPF(0, "!AcmAppGetSelectedDriver: NULL item data for selected driver!!?");
        return (NULL);
    }

    return (hadid);
} // AcmAppGetSelectedDriver()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDriverSelected
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

HACMDRIVER FNLOCAL AcmAppDriverSelected
(
    HWND                    hwnd
)
{
    LRESULT             lr;
    MMRESULT            mmr;
    BOOL                f;
    HACMDRIVERID        hadid;
    HACMDRIVER          had;
    DWORD               fdwSupport;

    f = FALSE;

    //
    //
    //
    if (NULL != ghadSelected)
    {
        mmr = acmDriverClose(ghadSelected, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(0, "!AcmAppDriverSelected: driver %.04Xh failed to close! mmr=%u", ghadSelected, mmr);
        }

        ghadSelected = NULL;
    }

    had = NULL;

    //
    //
    //
    hadid = AcmAppGetSelectedDriver(hwnd);
    if (NULL != hadid)
    {
        mmr = acmMetrics((HACMOBJ)hadid, ACM_METRIC_DRIVER_SUPPORT, &fdwSupport);
        if (MMSYSERR_NOERROR != mmr)
        {
            fdwSupport = ACMDRIVERDETAILS_SUPPORTF_DISABLED;

            //
            //  !!! this should NEVER EVER EVER HAPPEN !!!
            //
            DPF(0, "!AcmAppDriverSelected: driver id %.04Xh failed to give support! mmr=%u", hadid, mmr);
        }

        if (0 == (ACMDRIVERDETAILS_SUPPORTF_DISABLED & fdwSupport))
        {
            mmr = acmDriverOpen(&had, hadid, 0L);
            if (MMSYSERR_NOERROR != mmr)
            {
                DPF(0, "!AcmAppDriverSelected: driver id %.04Xh failed to open! mmr=%u", hadid, mmr);
            }
        }

        //
        //
        //
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_DETAILS), TRUE);

        lr = acmDriverMessage((HACMDRIVER)hadid, ACMDM_DRIVER_ABOUT, -1L, 0L);
        f = (MMSYSERR_NOERROR == lr);
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_ABOUT), f);

        lr = acmDriverMessage((HACMDRIVER)hadid, DRV_QUERYCONFIGURE, 0L, 0L);
        f = (0L != lr);
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_CONFIG), f);
    }
    else
    {
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_DETAILS), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_ABOUT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_CONFIG), FALSE);
    }


    //
    //
    //
    if (NULL == had)
    {
        //
        //
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_FORMATS), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_FILTERS), FALSE);
    }
    else
    {
        f = (0 == (ACMDRIVERDETAILS_SUPPORTF_DISABLED & fdwSupport));
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_FORMATS), f);

        f = (0 != (ACMDRIVERDETAILS_SUPPORTF_FILTER & fdwSupport));
        EnableWindow(GetDlgItem(hwnd, IDD_AADRIVERS_BTN_FILTERS), f);
    }

    //
    //
    //
    ghadidSelected = hadid;
    ghadSelected   = had;

    return (had);
} // AcmAppDriverSelected()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppDriversDlgProc
//
//  Description:
//      This dialog procedure is used to display ACM driver capabilities.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDriversDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PTABBEDLISTBOX      ptlb;
    HWND                hstat;
    MMRESULT            mmr;
    LRESULT             lr;
    RECT                rc;
    PAINTSTRUCT         ps;
    UINT                uId;
    UINT                uCode;
    UINT                u;


    ptlb = (PTABBEDLISTBOX)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            hstat = GetDlgItem(hwnd, IDD_AADRIVERS_STATIC_POSITION);

            GetWindowRect(hstat, &rc);
            ScreenToClient(hwnd, (LPPOINT)&rc.left);
            ScreenToClient(hwnd, (LPPOINT)&rc.right);

            ShowWindow(hstat, SW_HIDE);

            ptlb = TlbCreate(hwnd, IDD_AADRIVERS_LIST_DRIVERS, &rc);
            SetWindowLong(hwnd, DWL_USER, (LONG)(UINT)ptlb);
            if (NULL == ptlb)
            {
                EndDialog(hwnd, FALSE);
                return (TRUE);
            }

            //
            //
            //
            TlbSetFont(ptlb, GetStockFont(ANSI_VAR_FONT), FALSE);
            TlbSetTitleAndTabs(ptlb, gszFormatDriversTitle, FALSE);

            SetWindowPos(ptlb->hlb, GetDlgItem(hwnd, IDOK), 
                            0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

            SendMessage(hwnd, WM_ACMAPP_ACM_NOTIFY, 0, 0L);
            return (TRUE);


        case WM_PAINT:
            if (NULL != ptlb)
            {
                BeginPaint(hwnd, &ps);
                TlbPaint(ptlb, hwnd, ps.hdc);
                EndPaint(hwnd, &ps);
            }
            break;


        case WM_ACMAPP_ACM_NOTIFY:
            u = (UINT)ListBox_GetCurSel(ptlb->hlb);
            if (LB_ERR == u)
            {
                u = 0;
            }

            SetWindowRedraw(ptlb->hlb, FALSE);
            ListBox_ResetContent(ptlb->hlb);

            AcmAppDebugLog(NULL);

            //
            //
            //
            mmr = acmDriverEnum(AcmAppDriverEnumCallback,
                                (DWORD)(UINT)ptlb->hlb,
                                ACM_DRIVERENUMF_DISABLED);
            if (MMSYSERR_NOERROR != mmr)
            {
                //
                //  this will let us know something is wrong!
                //
                EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);
            }

            ListBox_SetCurSel(ptlb->hlb, u);
            SetWindowRedraw(ptlb->hlb, TRUE);

            AcmAppDriverSelected(hwnd);
            break;


        case WM_COMMAND:
            uId   = GET_WM_COMMAND_ID(wParam, lParam);
            uCode = GET_WM_COMMAND_CMD(wParam, lParam);
            switch (uId)
            {
                case IDOK:
                case IDCANCEL:
                    if (NULL != ptlb)
                    {
                        //
                        //  hadidk! don't destroy the listbox window, but
                        //  free all other memory for TLB. the listbox
                        //  window will be destroyed when the dialog is
                        //  destroyed.
                        //
                        ptlb->hlb = NULL;

                        TlbDestroy(ptlb);
                        ptlb = NULL;
                    }

                    if (NULL != ghadSelected)
                    {
                        acmDriverClose(ghadSelected, 0L);
                        ghadSelected = NULL;
                    }

                    EndDialog(hwnd, (IDOK == uId));
                    break;

                case IDD_AADRIVERS_BTN_DETAILS:
                    DialogBoxParam(ghinst,
                                   DLG_AADETAILS,
                                   hwnd,
                                   AcmAppDriverDetailsDlgProc,
                                   (LPARAM)(UINT)ghadidSelected);
                    break;

                case IDD_AADRIVERS_BTN_FORMATS:
                    if (NULL != ghadSelected)
                    {
                        DialogBoxParam(ghinst,
                                       DLG_AADRIVERFORMATS,
                                       hwnd,
                                       AcmAppDriverFormatsDlgProc,
                                       (LPARAM)(UINT)ghadSelected);
                    }
                    break;

                case IDD_AADRIVERS_BTN_FILTERS:
#if 0
                    if (NULL != ghadSelected)
                    {
                        DialogBoxParam(ghinst,
                                       DLG_AADRIVERFILTERS,
                                       hwnd,
                                       AcmAppDriverFiltersDlgProc,
                                       (LPARAM)(UINT)ghadSelected);
                    }
#endif
                    break;


                case IDD_AADRIVERS_BTN_CONFIG:
                    if (NULL == ghadidSelected)
                        break;

                    lr = acmDriverMessage((HACMDRIVER)ghadidSelected,
                                          DRV_CONFIGURE,
                                          (LPARAM)(UINT)hwnd,
                                          0L);
                    switch (lr)
                    {
                        case DRVCNF_CANCEL:
                            //
                            //  user canceled the configuration (no
                            //  configuration information was changed)
                            //
                            break;

                        case DRVCNF_OK:
                            //
                            //  user changed AND accepted configuration
                            //  changes--applications should refresh
                            //  anything they have for this driver
                            //
                            break;

                        case DRVCNF_RESTART:
                            //
                            //  user changed and accepted configuration
                            //  changes--however, Windows must be
                            //  restarted for the changes to take 
                            //  affect.
                            //
#pragma message("----AcmAppDriversDlgProc: must do DRVCNF_RESTART!")
                            break;

                        default:
                            DPF(0, "!configure: driver returned bogus value=%lu!", lr);
                            break;
                    }
                    break;

                case IDD_AADRIVERS_BTN_ABOUT:
                    if (NULL != ghadidSelected)
                    {
                        //
                        //  some driver actually provided
                        //  a custom about box... i'm glad i don't have to
                        //  port, maintain, and support this driver!
                        //
                        lr = acmDriverMessage((HACMDRIVER)ghadidSelected,
                                              ACMDM_DRIVER_ABOUT,
                                              (LPARAM)(UINT)hwnd,
                                              0L);
                    }
                    break;


                case IDD_AADRIVERS_BTN_ABLE:
                    if (NULL != ghadidSelected)
                    {
                        DWORD       fdwSupport;
                        DWORD       fdwPriority;

                        mmr = acmMetrics((HACMOBJ)ghadidSelected,
                                         ACM_METRIC_DRIVER_SUPPORT,
                                         &fdwSupport);

                        if (MMSYSERR_NOERROR != mmr)
                        {
                            MessageBeep(0);
                            break;
                        }

                        if (0 == (ACMDRIVERDETAILS_SUPPORTF_DISABLED & fdwSupport))
                        {
                            fdwPriority = ACM_DRIVERPRIORITYF_DISABLE;
                        }
                        else
                        {
                            fdwPriority = ACM_DRIVERPRIORITYF_ENABLE;
                        }

                        mmr = acmDriverPriority(ghadidSelected,
                                                0L,
                                                fdwPriority);
                        if (MMSYSERR_NOERROR != mmr)
                        {
                            MessageBeep(0);
                            break;
                        }
                    }
                    break;


                case IDD_AADRIVERS_BTN_TOTOP:
                    if (NULL != ghadidSelected)
                    {
                        mmr = acmDriverPriority(ghadidSelected, 1, 0L);
                        if (MMSYSERR_NOERROR != mmr)
                        {
                            MessageBeep(0);
                            break;
                        }
                    }
                    break;


                case IDD_AADRIVERS_LIST_DRIVERS:
                    switch (uCode)
                    {
                        case LBN_SELCHANGE:
                            AcmAppDriverSelected(hwnd);
                            break;

                        case LBN_DBLCLK:
                            if (GetKeyState(VK_CONTROL) < 0)
                            {
                                uId = IDD_AADRIVERS_BTN_ABLE;
                            }
                            else if (GetKeyState(VK_SHIFT) < 0)
                            {
                                uId = IDD_AADRIVERS_BTN_TOTOP;
                            }
                            else
                            {
                                uId = IDD_AADRIVERS_BTN_DETAILS;
                            }

                            FORWARD_WM_COMMAND(hwnd,
                                               uId,
                                               GetDlgItem(hwnd, uId),
                                               1,
                                               SendMessage);
                            break;
                    }
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppDriversDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\aasysinf.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//--------------------------------------------------------------------------;
//
//  aasysinf.c
//
//  Description:
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>

#include <mmreg.h>
#include <msacm.h>

#include "appport.h"
#include "acmapp.h"

#include "debug.h"


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDisplaySystemInfo
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppDisplaySystemInfo
(
    HWND            hedit
)
{
    static TCHAR    szDisplayTitle[]  = TEXT("[System Information]\r\n");

    TCHAR       ach[APP_MAX_STRING_RC_BYTES];
    PTSTR       pch, pch1;
    UINT        u;
    DWORD       dw;

    //
    //
    //
    MEditPrintF(hedit, szDisplayTitle);

    AppGetWindowsVersion(ach, NULL);
    MEditPrintF(hedit, TEXT("~%23s: "), (LPTSTR)TEXT("Operating System"));

    for (pch = ach; '\0' != *pch; )
    {
        pch1 = pch;
        while ((*pch1 != '\0') && (*pch1 != '\n'))
            pch1++;

        if ('\n' == *pch1)
            *pch1++ = '\0';
            
        MEditPrintF(hedit, TEXT("%s"), (LPTSTR)pch);

        if ('\0' == *pch1)
            break;

        MEditPrintF(hedit, TEXT("~%25s"), (LPTSTR)gszNull);
        pch = pch1;
    }


    AppGetWindowsVersion(NULL, ach);
    MEditPrintF(hedit, TEXT("%23s: %s"), (LPTSTR)TEXT("Platform"), (LPTSTR)ach);

    //
    //
    //
    u = mmsystemGetVersion();
    MEditPrintF(hedit, TEXT("%23s: %u.%.02u"),
#ifdef WIN32
                    (LPTSTR)TEXT("WinMM Version"),
#else
                    (LPTSTR)TEXT("MMSystem Version"),
#endif
                    (u >> 8), u & 0x00FF);

    //
    //
    //
    MEditPrintF(hedit, TEXT("~%23s: "), (LPTSTR)TEXT("ACM Version"));
    dw = acmGetVersion();
    if (0L == dw)
    {
        MEditPrintF(hedit, TEXT("Not Installed"));
        return (TRUE);
    }

    //
    //  if the 'build' number is zero, it is a _retail_ version of the
    //  ACM that is installed. if it is non-zero, it is the debug version.
    //
    if (0 == LOWORD(dw))
    {
        MEditPrintF(hedit, TEXT("%u.%.02u (retail)"),
                        HIWORD(dw) >> 8, HIWORD(dw) & 0x00FF);
    }
    else
    {
        MEditPrintF(hedit, TEXT("%u.%.02u (debug build %u)"),
                        HIWORD(dw) >> 8, HIWORD(dw) & 0x00FF, LOWORD(dw));
    }

    //
    //
    //
    acmMetrics(NULL, ACM_METRIC_COUNT_DRIVERS, &dw);
    MEditPrintF(hedit, TEXT("\r\n%23s: %lu"), (LPTSTR)TEXT("Enabled Drivers"), dw);
    
    acmMetrics(NULL, ACM_METRIC_COUNT_DISABLED, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Disabled Drivers"), dw);

    acmMetrics(NULL, ACM_METRIC_COUNT_CODECS, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Total CODEC's"), dw);

    acmMetrics(NULL, ACM_METRIC_COUNT_CONVERTERS, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Total Converters"), dw);

    acmMetrics(NULL, ACM_METRIC_COUNT_FILTERS, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Total Filters"), dw);

    acmMetrics(NULL, ACM_METRIC_COUNT_HARDWARE, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Hardware Drivers"), dw);


    acmMetrics(NULL, ACM_METRIC_COUNT_LOCAL_DRIVERS, &dw);
    MEditPrintF(hedit, TEXT("\r\n%23s: %lu"), (LPTSTR)TEXT("Enabled Local Drivers"), dw);
    
    acmMetrics(NULL, ACM_METRIC_COUNT_LOCAL_DISABLED, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Disabled Local Drivers"), dw);

    acmMetrics(NULL, ACM_METRIC_COUNT_LOCAL_CODECS, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Total Local CODEC's"), dw);

    acmMetrics(NULL, ACM_METRIC_COUNT_LOCAL_CONVERTERS, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Total Local Converters"), dw);

    acmMetrics(NULL, ACM_METRIC_COUNT_LOCAL_FILTERS, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Total Local Filters"), dw);


    acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &dw);
    MEditPrintF(hedit, TEXT("\r\n%23s: %lu"), (LPTSTR)TEXT("Max Format Bytes"), dw);

    acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FILTER, &dw);
    MEditPrintF(hedit, TEXT("%23s: %lu"), (LPTSTR)TEXT("Max Filter Bytes"), dw);

    return (TRUE);
} // AcmAppDisplaySystemInfo()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppSystemInfoDlgProc
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppSystemInfoDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    HWND                hedit;
    UINT                uId;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            hedit = GetDlgItem(hwnd, IDD_AADETAILS_EDIT_DETAILS);
            SetWindowFont(hedit, ghfontApp, FALSE);

            //
            //  clear the display
            //
            AppHourGlass(TRUE);
            SetWindowRedraw(hedit, FALSE);
            MEditPrintF(hedit, NULL);

            AcmAppDisplaySystemInfo(hedit);

            Edit_SetSel(hedit, (WPARAM)0, (LPARAM)0);

            SetWindowRedraw(hedit, TRUE);
            AppHourGlass(FALSE);
            return (TRUE);

        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            if ((IDOK == uId) || (IDCANCEL == uId))
            {
                EndDialog(hwnd, (IDOK == uId));
            }
            break;
    }

    return (FALSE);
} // AcmAppSystemInfoDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\aachoose.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  aachoose.c
//
//  Description:
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include <stdlib.h>

#include <mmreg.h>
#include <msacm.h>

#include "muldiv32.h"

#include "appport.h"
#include "waveio.h"
#include "acmapp.h"

#include "debug.h"


TCHAR           gszBogus[]      = TEXT("????");

TCHAR BCODE     gszAcmAppHelpFormat[] = TEXT("choo_win.hlp");
TCHAR BCODE     gszAcmAppHelpFilter[] = TEXT("fil_win.hlp");

LPTSTR          gpszAcmAppHelp;
UINT            guMsgHelp;


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL AcmAppDlgProcFormatStyle
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDlgProcFormatStyle
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PACMFORMATCHOOSE    pafc;
    HFONT               hfont;
    UINT                uId;
    BOOL                f;
    DWORD               fdwStyle;

    pafc = (PACMFORMATCHOOSE)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            pafc = (PACMFORMATCHOOSE)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

            hfont = ghfontApp;

            //
            //
            //
            fdwStyle = pafc->fdwStyle;

            f = (0 != (ACMFORMATCHOOSE_STYLEF_SHOWHELP & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFORMATSTYLE_CHECK_SHOWHELP, f);

            f = (0 != (ACMFORMATCHOOSE_STYLEF_ENABLEHOOK & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFORMATSTYLE_CHECK_ENABLEHOOK, f);

            f = (0 != (ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFORMATSTYLE_CHECK_ENABLETEMPLATE, f);

            f = (0 != (ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFORMATSTYLE_CHECK_ENABLETEMPLATEHANDLE, f);

            f = (0 != (ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFORMATSTYLE_CHECK_INITTOWFXSTRUCT, f);

            return (TRUE);


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uId)
            {
                case IDOK:
                    fdwStyle = 0L;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATSTYLE_CHECK_SHOWHELP);
                    if (f) fdwStyle |= ACMFORMATCHOOSE_STYLEF_SHOWHELP;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATSTYLE_CHECK_ENABLEHOOK);
                    if (f) fdwStyle |= ACMFORMATCHOOSE_STYLEF_ENABLEHOOK;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATSTYLE_CHECK_ENABLETEMPLATE);
                    if (f) fdwStyle |= ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATSTYLE_CHECK_ENABLETEMPLATEHANDLE);
                    if (f) fdwStyle |= ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATSTYLE_CHECK_INITTOWFXSTRUCT);
                    if (f) fdwStyle |= ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT;

                    pafc->fdwStyle = fdwStyle;

                    // -- fall through -- //

                case IDCANCEL:
                    EndDialog(hwnd, (IDOK == uId));
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppDlgProcFormatStyle()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppDlgProcFilterStyle
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDlgProcFilterStyle
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PACMFILTERCHOOSE    pafc;
    HFONT               hfont;
    UINT                uId;
    BOOL                f;
    DWORD               fdwStyle;

    pafc = (PACMFILTERCHOOSE)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            pafc = (PACMFILTERCHOOSE)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

            hfont = ghfontApp;

            //
            //
            //
            fdwStyle = pafc->fdwStyle;

            f = (0 != (ACMFILTERCHOOSE_STYLEF_SHOWHELP & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFILTERSTYLE_CHECK_SHOWHELP, f);

            f = (0 != (ACMFILTERCHOOSE_STYLEF_ENABLEHOOK & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFILTERSTYLE_CHECK_ENABLEHOOK, f);

            f = (0 != (ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFILTERSTYLE_CHECK_ENABLETEMPLATE, f);

            f = (0 != (ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFILTERSTYLE_CHECK_ENABLETEMPLATEHANDLE, f);

            f = (0 != (ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT & fdwStyle));
            CheckDlgButton(hwnd, IDD_AAFILTERSTYLE_CHECK_INITTOFILTERSTRUCT, f);

            return (TRUE);


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uId)
            {
                case IDOK:
                    fdwStyle = 0L;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFILTERSTYLE_CHECK_SHOWHELP);
                    if (f) fdwStyle |= ACMFILTERCHOOSE_STYLEF_SHOWHELP;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFILTERSTYLE_CHECK_ENABLEHOOK);
                    if (f) fdwStyle |= ACMFILTERCHOOSE_STYLEF_ENABLEHOOK;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFILTERSTYLE_CHECK_ENABLETEMPLATE);
                    if (f) fdwStyle |= ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFILTERSTYLE_CHECK_ENABLETEMPLATEHANDLE);
                    if (f) fdwStyle |= ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFILTERSTYLE_CHECK_INITTOFILTERSTRUCT);
                    if (f) fdwStyle |= ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT;

                    pafc->fdwStyle = fdwStyle;

                    // -- fall through -- //

                case IDCANCEL:
                    EndDialog(hwnd, (IDOK == uId));
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppDlgProcFilterStyle()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppDlgProcFilterEnum
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDlgProcFilterEnum
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    TCHAR               ach[14];
    PWAVEFILTER         pwfltr;
    HWND                hedit;
    HFONT               hfont;
    UINT                uId;
    BOOL                f;
    DWORD               fdwEnum;

    pwfltr = (PWAVEFILTER)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            pwfltr = (PWAVEFILTER)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

            hfont = ghfontApp;

            //
            //  the initial fdwEnum flags are passed in fdwFilter
            //  because i'm too lazy to make another structure..
            //
            fdwEnum = pwfltr->fdwFilter;

            f = (0 != (ACM_FILTERENUMF_DWFILTERTAG & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFILTERENUM_CHECK_DWFILTERTAG, f);

            hedit = GetDlgItem(hwnd, IDD_AAFILTERENUM_EDIT_DWFILTERTAG);
            SetWindowFont(hedit, hfont, FALSE);
            AppSetWindowText(hedit, TEXT("%u"), pwfltr->dwFilterTag);

            return (TRUE);


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uId)
            {
                case IDOK:
                    fdwEnum = 0L;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFILTERENUM_CHECK_DWFILTERTAG);
                    if (f) fdwEnum |= ACM_FILTERENUMF_DWFILTERTAG;

                    hedit = GetDlgItem(hwnd, IDD_AAFILTERENUM_EDIT_DWFILTERTAG);
                    Edit_GetText(hedit, ach, SIZEOF(ach));
                    pwfltr->dwFilterTag = _tcstoul(ach, NULL, 10);

                    pwfltr->fdwFilter = fdwEnum;

                    // -- fall through -- //

                case IDCANCEL:
                    EndDialog(hwnd, (IDOK == uId));
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppDlgProcFilterEnum()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppDlgProcFormatEnum
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDlgProcFormatEnum
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    TCHAR               ach[14];
    PWAVEFORMATEX       pwfx;
    HWND                hedit;
    HFONT               hfont;
    UINT                uId;
    BOOL                f;
    DWORD               fdwEnum;

    pwfx = (PWAVEFORMATEX)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            pwfx = (PWAVEFORMATEX)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

            hfont = ghfontApp;

            //
            //  the initial fdwEnum flags are passed in nAvgBytesPerSec
            //  because i'm too lazy to make another structure..
            //
            fdwEnum = pwfx->nAvgBytesPerSec;

            f = (0 != (ACM_FORMATENUMF_WFORMATTAG & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFORMATENUM_CHECK_WFORMATTAG, f);

            f = (0 != (ACM_FORMATENUMF_NCHANNELS & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFORMATENUM_CHECK_NCHANNELS, f);

            f = (0 != (ACM_FORMATENUMF_NSAMPLESPERSEC & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFORMATENUM_CHECK_NSAMPLESPERSEC, f);

            f = (0 != (ACM_FORMATENUMF_WBITSPERSAMPLE & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFORMATENUM_CHECK_WBITSPERSAMPLE, f);

            f = (0 != (ACM_FORMATENUMF_CONVERT & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFORMATENUM_CHECK_CONVERT, f);

            f = (0 != (ACM_FORMATENUMF_SUGGEST & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFORMATENUM_CHECK_SUGGEST, f);

            f = (0 != (ACM_FORMATENUMF_HARDWARE & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFORMATENUM_CHECK_HARDWARE, f);

            f = (0 != (ACM_FORMATENUMF_INPUT & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFORMATENUM_CHECK_INPUT, f);

            f = (0 != (ACM_FORMATENUMF_OUTPUT & fdwEnum));
            CheckDlgButton(hwnd, IDD_AAFORMATENUM_CHECK_OUTPUT, f);

            hedit = GetDlgItem(hwnd, IDD_AAFORMATENUM_EDIT_WFORMATTAG);
            SetWindowFont(hedit, hfont, FALSE);
            AppSetWindowText(hedit, TEXT("%u"), pwfx->wFormatTag);

            hedit = GetDlgItem(hwnd, IDD_AAFORMATENUM_EDIT_NCHANNELS);
            SetWindowFont(hedit, hfont, FALSE);
            AppSetWindowText(hedit, TEXT("%u"), pwfx->nChannels);

            hedit = GetDlgItem(hwnd, IDD_AAFORMATENUM_EDIT_NSAMPLESPERSEC);
            SetWindowFont(hedit, hfont, FALSE);
            AppSetWindowText(hedit, TEXT("%lu"), pwfx->nSamplesPerSec);

            hedit = GetDlgItem(hwnd, IDD_AAFORMATENUM_EDIT_WBITSPERSAMPLE);
            SetWindowFont(hedit, hfont, FALSE);
            AppSetWindowText(hedit, TEXT("%u"), pwfx->wBitsPerSample);

            return (TRUE);


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uId)
            {
                case IDOK:

                    fdwEnum = 0L;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATENUM_CHECK_WFORMATTAG);
                    if (f) fdwEnum |= ACM_FORMATENUMF_WFORMATTAG;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATENUM_CHECK_NCHANNELS);
                    if (f) fdwEnum |= ACM_FORMATENUMF_NCHANNELS;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATENUM_CHECK_NSAMPLESPERSEC);
                    if (f) fdwEnum |= ACM_FORMATENUMF_NSAMPLESPERSEC;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATENUM_CHECK_WBITSPERSAMPLE);
                    if (f) fdwEnum |= ACM_FORMATENUMF_WBITSPERSAMPLE;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATENUM_CHECK_CONVERT);
                    if (f) fdwEnum |= ACM_FORMATENUMF_CONVERT;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATENUM_CHECK_SUGGEST);
                    if (f) fdwEnum |= ACM_FORMATENUMF_SUGGEST;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATENUM_CHECK_HARDWARE);
                    if (f) fdwEnum |= ACM_FORMATENUMF_HARDWARE;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATENUM_CHECK_INPUT);
                    if (f) fdwEnum |= ACM_FORMATENUMF_INPUT;

                    f = IsDlgButtonChecked(hwnd, IDD_AAFORMATENUM_CHECK_OUTPUT);
                    if (f) fdwEnum |= ACM_FORMATENUMF_OUTPUT;

                    hedit = GetDlgItem(hwnd, IDD_AAFORMATENUM_EDIT_WFORMATTAG);
                    Edit_GetText(hedit, ach, SIZEOF(ach));
                    pwfx->wFormatTag = (WORD)_tcstoul(ach, NULL, 10);

                    hedit = GetDlgItem(hwnd, IDD_AAFORMATENUM_EDIT_NCHANNELS);
                    Edit_GetText(hedit, ach, SIZEOF(ach));
                    pwfx->nChannels = (WORD)_tcstoul(ach, NULL, 10);

                    hedit = GetDlgItem(hwnd, IDD_AAFORMATENUM_EDIT_NSAMPLESPERSEC);
                    Edit_GetText(hedit, ach, SIZEOF(ach));
                    pwfx->nSamplesPerSec = _tcstoul(ach, NULL, 10);

                    hedit = GetDlgItem(hwnd, IDD_AAFORMATENUM_EDIT_WBITSPERSAMPLE);
                    Edit_GetText(hedit, ach, SIZEOF(ach));
                    pwfx->wBitsPerSample = (WORD)_tcstoul(ach, NULL, 10);

                    pwfx->nAvgBytesPerSec = fdwEnum;

                    // -- fall through -- //

                case IDCANCEL:
                    EndDialog(hwnd, (IDOK == uId));
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppDlgProcFormatEnum()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppDlgProcProperties
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDlgProcProperties
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    MMRESULT            mmr;
    TCHAR               ach[14];
    PAACONVERTDESC      paacd;
    HWND                hcb;
    HFONT               hfont;
    UINT                uId;
    DWORD               cb;

    paacd = (PAACONVERTDESC)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            paacd = (PAACONVERTDESC)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

            hfont = ghfontApp;

            hcb = GetDlgItem(hwnd, IDD_AAPROPERTIES_COMBO_SOURCE);
            SetWindowFont(hcb, hfont, FALSE);

            wsprintf(ach, TEXT("%lu"), paacd->cbSrcReadSize);
            ComboBox_AddString(hcb, ach);

            wsprintf(ach, TEXT("%lu"), paacd->cbSrcData);
            ComboBox_AddString(hcb, ach);

            wsprintf(ach, TEXT("%u"), paacd->pwfxSrc->nBlockAlign);
            ComboBox_AddString(hcb, ach);

            ComboBox_AddString(hcb, TEXT("1"));
            ComboBox_AddString(hcb, TEXT("2147483648"));
            ComboBox_AddString(hcb, TEXT("4294967295"));

            ComboBox_SetCurSel(hcb, 0);

            mmr = acmStreamSize(paacd->has,
                                paacd->cbSrcReadSize,
                                &paacd->cbDstBufSize,
                                ACM_STREAMSIZEF_SOURCE);

            hcb = GetDlgItem(hwnd, IDD_AAPROPERTIES_COMBO_DESTINATION);
            SetWindowFont(hcb, hfont, FALSE);

            wsprintf(ach, TEXT("%lu"), paacd->cbDstBufSize);
            ComboBox_AddString(hcb, ach);

            wsprintf(ach, TEXT("%u"), paacd->pwfxDst->nBlockAlign);
            ComboBox_AddString(hcb, ach);

            ComboBox_AddString(hcb, TEXT("1"));
            ComboBox_AddString(hcb, TEXT("2147483648"));
            ComboBox_AddString(hcb, TEXT("4294967295"));

            ComboBox_SetCurSel(hcb, 0);

            return (TRUE);


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uId)
            {
                case IDD_AAPROPERTIES_BTN_SOURCE:
                    hcb = GetDlgItem(hwnd, IDD_AAPROPERTIES_COMBO_SOURCE);
                    Edit_GetText(hcb, ach, SIZEOF(ach));
                    cb = _tcstoul(ach, NULL, 10);

                    mmr = acmStreamSize(paacd->has, cb, &cb, ACM_STREAMSIZEF_SOURCE);

                    wsprintf(ach, TEXT("%lu"), cb);

                    hcb = GetDlgItem(hwnd, IDD_AAPROPERTIES_COMBO_DESTINATION);
                    Edit_SetText(hcb, ach);
                    break;


                case IDD_AAPROPERTIES_BTN_DESTINATION:
                    hcb = GetDlgItem(hwnd, IDD_AAPROPERTIES_COMBO_DESTINATION);
                    Edit_GetText(hcb, ach, SIZEOF(ach));
                    cb = _tcstoul(ach, NULL, 10);

                    mmr = acmStreamSize(paacd->has, cb, &cb, ACM_STREAMSIZEF_DESTINATION);

                    wsprintf(ach, TEXT("%lu"), cb);

                    hcb = GetDlgItem(hwnd, IDD_AAPROPERTIES_COMBO_SOURCE);
                    Edit_SetText(hcb, ach);
                    break;


                case IDOK:
                    hcb = GetDlgItem(hwnd, IDD_AAPROPERTIES_COMBO_SOURCE);
                    Edit_GetText(hcb, ach, SIZEOF(ach));
                    paacd->cbSrcReadSize = _tcstoul(ach, NULL, 10);
                                                  
                    // -- fall through -- //

                case IDCANCEL:
                    EndDialog(hwnd, (IDOK == uId));
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppDlgProcProperties()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppChooserFormatSuggest
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PAACONVERTDESC paacd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppChooserFormatSuggest
(
    HWND                    hwnd,
    PAACONVERTDESC          paacd
)
{
    MMRESULT            mmr;
    LPWAVEFORMATEX      pwfx;
    DWORD               cbwfx;
    DWORD               cbwfxSrc;


    //
    //  this should never fail
    //
    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &cbwfx);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!AcmAppChooserFormatSuggest() acmMetrics failed mmr=%u!", mmr);
        return (FALSE);
    }


    //
    //  just in case no ACM driver is installed for the source format and
    //  the source has a larger format size than the largest enabled ACM
    //  driver...
    //
    cbwfxSrc = SIZEOF_WAVEFORMATEX(paacd->pwfxSrc);
    cbwfx    = max(cbwfx, cbwfxSrc);

    pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfx);
    if (NULL == pwfx)
    {
        DPF(0, "!AcmAppChooserFormatSuggest() GlobalAllocPtr(%lu) failed!", cbwfx);
        return (FALSE);
    }


    //
    //  'suggest anything'
    //
    mmr = acmFormatSuggest(NULL, paacd->pwfxSrc, pwfx, cbwfx, 0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                  TEXT("AcmAppChooserFormatSuggest() there is no suggested destination format. Defaulting to source format."));

        _fmemcpy(pwfx, paacd->pwfxSrc, (UINT)cbwfxSrc);
    }

    //
    //
    //
    if (NULL != paacd->pwfxDst)
    {
        GlobalFreePtr(paacd->pwfxDst);
    }

    paacd->pwfxDst = pwfx;
    AcmAppGetFormatDescription(pwfx, paacd->szDstFormatTag, paacd->szDstFormat);

    return (TRUE);
} // AcmAppChooserFormatSuggest()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppChooserSaveFile
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PAACONVERTDESC paacd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppChooserSaveFile
(
    HWND                    hwnd,
    PAACONVERTDESC          paacd
)
{
    TCHAR               szFilePath[APP_MAX_FILE_PATH_CHARS];
    TCHAR               szFileTitle[APP_MAX_FILE_TITLE_CHARS];
    HWND                hedit;
    BOOL                f;

    hedit = GetDlgItem(hwnd, IDD_AACHOOSER_EDIT_FILE_OUTPUT);
    Edit_GetText(hedit, paacd->szFilePathDst, SIZEOF(paacd->szFilePathDst));

    lstrcpy(szFilePath, paacd->szFilePathDst);

    f = AppGetFileName(hwnd, szFilePath, szFileTitle, APP_GETFILENAMEF_SAVE);
    if (f)
    {
        lstrcpy(paacd->szFilePathDst, szFilePath);
        Edit_SetText(hedit, paacd->szFilePathDst);
    }

    return (f);
} // AcmAppChooserSaveFile()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppChooserProperties
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PAACONVERTDESC paacd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppChooserProperties
(
    HWND                    hwnd,
    PAACONVERTDESC          paacd
)
{
    MMRESULT            mmr;
    BOOL                f;


    //
    //
    //
    if (NULL != paacd->hadid)
    {
        mmr = acmDriverOpen(&paacd->had, paacd->hadid, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            return (FALSE);
        }
    }

    mmr = acmStreamOpen(&paacd->has,
                        paacd->had,
                        paacd->pwfxSrc,
                        paacd->pwfxDst,
                        paacd->fApplyFilter ? paacd->pwfltr : (LPWAVEFILTER)NULL,
                        0L,
                        0L,
                        paacd->fdwOpen);

    if (MMSYSERR_NOERROR == mmr)
    {
        f = DialogBoxParam(ghinst,
                            DLG_AAPROPERTIES,
                            hwnd,
                            AcmAppDlgProcProperties,
                            (LPARAM)(UINT)paacd);

        acmStreamClose(paacd->has, 0L);
        paacd->has = NULL;
    }


    if (NULL != paacd->had)
    {
        acmDriverClose(paacd->had, 0L);
        paacd->had = NULL;
    }

    return (f);
} // AcmAppChooserProperties()


//--------------------------------------------------------------------------;
//  
//  UINT AcmAppChooserFormatHook
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (UINT):
//  
//  
//--------------------------------------------------------------------------;

UINT FNWCALLBACK AcmAppChooserFormatHook
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    static BOOL         fVerify;
    LPWAVEFORMATEX      pwfx;
    WAVEFORMATEX        wfx;
    TCHAR               szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    TCHAR               szFormat[ACMFORMATDETAILS_FORMAT_CHARS];
    PAACONVERTDESC      paacd;
    UINT                uId;
    int                 n;
    BOOL                f;


    paacd = (PAACONVERTDESC)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            paacd = (PAACONVERTDESC)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

            DPF(1, "AcmAppChooserFormatHook(%.04Xh, WM_INITDIALOG, %u, %lu): %.04Xh",
                hwnd, wParam, lParam, paacd);

            fVerify = TRUE;

            return (TRUE);


        case MM_ACM_FORMATCHOOSE:
            switch (wParam)
            {
                case FORMATCHOOSE_FORMATTAG_VERIFY:
                    if (!fVerify)
                        break;

                    wfx.wFormatTag = LOWORD(lParam);

                    AcmAppGetFormatDescription(&wfx, szFormatTag, NULL);

                    n = AppMsgBox(hwnd, MB_YESNOCANCEL | MB_ICONQUESTION,
                                    TEXT("Add format tag [%lu], '%s'?"),
                                    lParam, (LPTSTR)szFormatTag);

                    fVerify = (IDCANCEL != n);

                    if (!fVerify)
                        break;

                    f = (IDYES == n);

                    SetWindowLong(hwnd, DWL_MSGRESULT, f);
                    return (TRUE);


                case FORMATCHOOSE_FORMAT_VERIFY:
                    if (!fVerify)
                        break;

                    pwfx = (LPWAVEFORMATEX)lParam;

                    AcmAppGetFormatDescription(pwfx, szFormatTag, szFormat);

                    n = AppMsgBox(hwnd, MB_YESNOCANCEL | MB_ICONQUESTION,
                                    TEXT("Add format '%s' for format tag [%u], '%s'?"),
                                    (LPTSTR)szFormat,
                                    pwfx->wFormatTag,
                                    (LPTSTR)szFormatTag);

                    fVerify = (IDCANCEL != n);

                    if (!fVerify)
                        break;

                    f = (IDYES == n);

                    SetWindowLong(hwnd, DWL_MSGRESULT, f);
                    return (TRUE);


                case FORMATCHOOSE_CUSTOM_VERIFY:
                    if (!fVerify)
                        break;

                    pwfx = (LPWAVEFORMATEX)lParam;

                    AcmAppGetFormatDescription(pwfx, szFormatTag, szFormat);

                    n = AppMsgBox(hwnd, MB_YESNOCANCEL | MB_ICONQUESTION,
                                    TEXT("Add CUSTOM format '%s' for format tag [%u], '%s'?"),
                                    (LPTSTR)szFormat,
                                    pwfx->wFormatTag,
                                    (LPTSTR)szFormatTag);

                    fVerify = (IDCANCEL != n);

                    if (!fVerify)
                        break;

                    f = (IDYES == n);

                    SetWindowLong(hwnd, DWL_MSGRESULT, f);
                    return (TRUE);
            }
            break;


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uId)
            {
                case IDOK:
                case IDCANCEL:
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppChooserFormatHook()


//--------------------------------------------------------------------------;
//  
//  UINT AcmAppChooserFilterHook
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (UINT):
//  
//  
//--------------------------------------------------------------------------;

UINT FNWCALLBACK AcmAppChooserFilterHook
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    static BOOL         fVerify;
    WAVEFILTER          wfltr;
    LPWAVEFILTER        pwfltr;
    TCHAR               szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    TCHAR               szFilter[ACMFILTERDETAILS_FILTER_CHARS];
    PAACONVERTDESC      paacd;
    UINT                uId;
    int                 n;
    BOOL                f;


    paacd = (PAACONVERTDESC)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            paacd = (PAACONVERTDESC)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

            DPF(1, "AcmAppChooserFilterHook(%.04Xh, WM_INITDIALOG, %u, %lu): %.04Xh",
                hwnd, wParam, lParam, paacd);

            fVerify = TRUE;

            return (TRUE);


        case MM_ACM_FILTERCHOOSE:
            switch (wParam)
            {
                case FILTERCHOOSE_FILTERTAG_VERIFY:
                    if (!fVerify)
                        break;

                    wfltr.dwFilterTag = lParam;

                    AcmAppGetFilterDescription(&wfltr, szFilterTag, NULL);

                    n = AppMsgBox(hwnd, MB_YESNOCANCEL | MB_ICONQUESTION,
                                    TEXT("Add filter tag [%lu], '%s'?"),
                                    lParam, (LPTSTR)szFilterTag);

                    fVerify = (IDCANCEL != n);

                    if (!fVerify)
                        break;

                    f = (IDYES == n);

                    SetWindowLong(hwnd, DWL_MSGRESULT, f);
                    return (TRUE);


                case FILTERCHOOSE_FILTER_VERIFY:
                    if (!fVerify)
                        break;

                    pwfltr = (LPWAVEFILTER)lParam;

                    AcmAppGetFilterDescription(pwfltr, szFilterTag, szFilter);

                    n = AppMsgBox(hwnd, MB_YESNOCANCEL | MB_ICONQUESTION,
                                    TEXT("Add filter '%s' for filter tag [%lu], '%s'?"),
                                    (LPTSTR)szFilter,
                                    pwfltr->dwFilterTag,
                                    (LPTSTR)szFilterTag);

                    fVerify = (IDCANCEL != n);

                    if (!fVerify)
                        break;

                    f = (IDYES == n);

                    SetWindowLong(hwnd, DWL_MSGRESULT, f);
                    return (TRUE);


                case FILTERCHOOSE_CUSTOM_VERIFY:
                    if (!fVerify)
                        break;

                    pwfltr = (LPWAVEFILTER)lParam;

                    AcmAppGetFilterDescription(pwfltr, szFilterTag, szFilter);

                    n = AppMsgBox(hwnd, MB_YESNOCANCEL | MB_ICONQUESTION,
                                    TEXT("Add CUSTOM filter '%s' for filter tag [%lu], '%s'?"),
                                    (LPTSTR)szFilter,
                                    pwfltr->dwFilterTag,
                                    (LPTSTR)szFilterTag);

                    fVerify = (IDCANCEL != n);

                    if (!fVerify)
                        break;

                    f = (IDYES == n);

                    SetWindowLong(hwnd, DWL_MSGRESULT, f);
                    return (TRUE);
            }
            break;


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uId)
            {
                case IDOK:
                case IDCANCEL:
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppChooserFilterHook()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppChooserFormat
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PAACONVERTDESC paacd:
//  
//      BOOL fOptions:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppChooserFormat
(
    HWND                    hwnd,
    PAACONVERTDESC          paacd,
    BOOL                    fOptions
)
{
    ACMFORMATCHOOSE     afc;
    MMRESULT            mmr;
    LPWAVEFORMATEX      pwfx;
    DWORD               cbwfx;
    DWORD               cbwfxSrc;
    DWORD               fdwSuggest;
    DWORD               fdwStyle;
    DWORD               fdwEnum;
    WAVEFORMATEX        wfxEnum;
    BOOL                f;
    HRSRC               hrsrc;

    //
    //
    //
    fdwSuggest = 0L;
    fdwStyle   = 0L;
    fdwEnum    = 0L;

    if (fOptions)
    {
        wfxEnum.wFormatTag      = paacd->pwfxSrc->wFormatTag;
        wfxEnum.nChannels       = paacd->pwfxSrc->nChannels;
        wfxEnum.nSamplesPerSec  = paacd->pwfxSrc->nSamplesPerSec;
        wfxEnum.wBitsPerSample  = paacd->pwfxSrc->wBitsPerSample;

        wfxEnum.nBlockAlign     = 0;
        wfxEnum.nAvgBytesPerSec = fdwEnum;
        wfxEnum.cbSize          = 0;

        f = DialogBoxParam(ghinst,
                           DLG_AAFORMATENUM,
                           hwnd,
                           AcmAppDlgProcFormatEnum,
                           (LPARAM)(UINT)&wfxEnum);
        if (!f)
        {
            return (FALSE);
        }

        fdwEnum = wfxEnum.nAvgBytesPerSec;

        wfxEnum.nAvgBytesPerSec = 0L;
    }


    if (fOptions)
    {
        afc.fdwStyle = fdwStyle;

        f = DialogBoxParam(ghinst,
                           DLG_AAFORMATSTYLE,
                           hwnd,
                           AcmAppDlgProcFormatStyle,
                           (LPARAM)(UINT)&afc);
        if (!f)
        {
            return (FALSE);
        }

        fdwStyle = afc.fdwStyle;
    }


    //
    //  this should never fail
    //
    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &cbwfx);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!AcmAppChooserFormat() acmMetrics failed mmr=%u!", mmr);
        return (FALSE);
    }

    //
    //  just in case no ACM driver is installed for the source format and
    //  the source has a larger format size than the largest enabled ACM
    //  driver...
    //
    cbwfxSrc = SIZEOF_WAVEFORMATEX(paacd->pwfxSrc);
    cbwfx    = max(cbwfx, cbwfxSrc);

    pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfx);
    if (NULL == pwfx)
    {
        DPF(0, "!AcmAppChooserFormat() GlobalAllocPtr(%lu) failed!", cbwfx);
        return (FALSE);
    }


    //
    //
    //
    //
    if (0 != (fdwStyle & ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT))
    {
        if (NULL != paacd->pwfxDst)
        {
            _fmemcpy(pwfx, paacd->pwfxDst, SIZEOF_WAVEFORMATEX(paacd->pwfxDst));
        }
        else
        {
            _fmemcpy(pwfx, paacd->pwfxSrc, (UINT)cbwfxSrc);
        }
    }


    //
    //
    //
    //
    if (0 == (ACMFORMATCHOOSE_STYLEF_SHOWHELP & fdwStyle))
    {
        guMsgHelp = 0;
    }
    else
    {
        guMsgHelp = RegisterWindowMessage(ACMHELPMSGSTRING);
        if (0 == guMsgHelp)
        {
            fdwStyle &= ~ACMFORMATCHOOSE_STYLEF_SHOWHELP;
        }
        else
        {
            gpszAcmAppHelp = gszAcmAppHelpFormat;
        }
    }


    //
    //  initialize the ACMFORMATCHOOSE members
    //
    memset(&afc, 0, sizeof(afc));

    afc.cbStruct        = sizeof(afc);
    afc.fdwStyle        = fdwStyle;
    afc.hwndOwner       = hwnd;
    afc.pwfx            = pwfx;
    afc.cbwfx           = cbwfx;
    afc.pszTitle        = TEXT("Destination Format Choice");

    afc.szFormatTag[0]  = '\0';
    afc.szFormat[0]     = '\0';
    afc.pszName         = NULL;
    afc.cchName         = 0;

    afc.fdwEnum         = fdwEnum;
    if (0L == (afc.fdwEnum & (ACM_FORMATENUMF_WFORMATTAG |
                              ACM_FORMATENUMF_NCHANNELS |
                              ACM_FORMATENUMF_NSAMPLESPERSEC |
                              ACM_FORMATENUMF_WBITSPERSAMPLE |
                              ACM_FORMATENUMF_CONVERT |
                              ACM_FORMATENUMF_SUGGEST)))
    {
        afc.pwfxEnum    = NULL;
    }
    else
    {
        if (0 == (afc.fdwEnum & (ACM_FORMATENUMF_CONVERT |
                                 ACM_FORMATENUMF_SUGGEST)))
        {
            //
            //  if _CONVERT and _SUGGEST are not specified, then we only
            //  need to pass in a format structure large enough to describe
            //  everything up to (but not including) the cbSize--it's fine
            //  to pass more, but it is not necessary. in other words, a
            //  PCMWAVEFORMAT would do nicely...
            //
            afc.pwfxEnum = &wfxEnum;
        }
        else
        {
            //
            //  for the _CONVERT and _SUGGEST flags, we must pass a valid
            //  format--and since we're looking for destinations that apply
            //  to our source format, we simply reference it..
            //
            afc.pwfxEnum = paacd->pwfxSrc;
        }
    }

    //
    //
    //
    hrsrc = NULL;

    if (0L == (afc.fdwStyle & (ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATE |
                               ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE)))
    {
        afc.hInstance       = NULL;
        afc.pszTemplateName = NULL;
    }
    else
    {
        if (0L != (afc.fdwStyle & ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE))
        {
            //
            //  ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE
            //
            hrsrc = FindResource(ghinst, DLG_AAFORMATCHOOSE_TEMPLATE, RT_DIALOG);

            afc.hInstance       = (HINSTANCE)LoadResource(ghinst, hrsrc);
            afc.pszTemplateName = NULL;
        }
        else
        {
            afc.hInstance       = ghinst;
            afc.pszTemplateName = DLG_AAFORMATCHOOSE_TEMPLATE;
        }
    }


    if (0L == (afc.fdwStyle & ACMFORMATCHOOSE_STYLEF_ENABLEHOOK))
    {
        afc.lCustData       = 0L;
        afc.pfnHook         = NULL;
    }
    else
    {
        afc.lCustData       = (LPARAM)(UINT)paacd;
        afc.pfnHook         = AcmAppChooserFormatHook;
    }


    //
    //
    //
    mmr = acmFormatChoose(&afc);

    if (NULL != hrsrc)
    {
        FreeResource((HGLOBAL)afc.hInstance);
    }

    //
    //
    //
    if (0 != guMsgHelp)
    {
        WinHelp(hwnd, gszAcmAppHelpFormat, HELP_QUIT, 0L);
        guMsgHelp = 0;
    }


    if (MMSYSERR_NOERROR != mmr)
    {
        if (ACMERR_CANCELED != mmr)
        {
            TCHAR       ach[40];

            AcmAppGetErrorString(mmr, ach);
            AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                      TEXT("acmFormatChoose() failed with error %s, [%u]."),
                      (LPTSTR)ach, mmr);
        }

        GlobalFreePtr(pwfx);
        return (FALSE);
    }


    //
    //
    //
    if (NULL != paacd->pwfxDst)
    {
        GlobalFreePtr(paacd->pwfxDst);
    }

    paacd->pwfxDst = pwfx;
    lstrcpy(paacd->szDstFormatTag, afc.szFormatTag);
    lstrcpy(paacd->szDstFormat, afc.szFormat);


    return (TRUE);
} // AcmAppChooserFormat()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppChooserFilter
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PAACONVERTDESC paacd:
//  
//      BOOL fOptions:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppChooserFilter
(
    HWND                    hwnd,
    PAACONVERTDESC          paacd,
    BOOL                    fOptions
)
{
    ACMFILTERCHOOSE     afc;
    MMRESULT            mmr;
    LPWAVEFILTER        pwfltr;
    DWORD               cbwfltr;
    DWORD               fdwStyle;
    DWORD               fdwEnum;
    WAVEFILTER          wfltrEnum;
    BOOL                f;
    HRSRC               hrsrc;

    //
    //
    //
    fdwStyle   = 0L;
    fdwEnum    = 0L;

    if (fOptions)
    {
        _fmemset(&wfltrEnum, 0, sizeof(wfltrEnum));

        wfltrEnum.cbStruct    = sizeof(wfltrEnum);
        wfltrEnum.dwFilterTag = paacd->pwfxSrc->wFormatTag;

        wfltrEnum.fdwFilter   = fdwEnum;

        f = DialogBoxParam(ghinst,
                           DLG_AAFILTERENUM,
                           hwnd,
                           AcmAppDlgProcFilterEnum,
                           (LPARAM)(UINT)&wfltrEnum);
        if (!f)
        {
            return (FALSE);
        }

        fdwEnum = wfltrEnum.fdwFilter;

        wfltrEnum.fdwFilter = 0L;
    }


    if (fOptions)
    {
        afc.fdwStyle = fdwStyle;

        f = DialogBoxParam(ghinst,
                           DLG_AAFILTERSTYLE,
                           hwnd,
                           AcmAppDlgProcFilterStyle,
                           (LPARAM)(UINT)&afc);
        if (!f)
        {
            return (FALSE);
        }

        fdwStyle = afc.fdwStyle;
    }



    //
    //  this should never fail
    //
    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FILTER, &cbwfltr);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(0, "!AcmAppChooserFilter() acmMetrics failed mmr=%u!", mmr);
        return (FALSE);
    }

    //
    //
    //
    cbwfltr = max(cbwfltr, sizeof(WAVEFILTER));
    pwfltr  = (LPWAVEFILTER)GlobalAllocPtr(GHND, cbwfltr);
    if (NULL == pwfltr)
    {
        DPF(0, "!AcmAppChooserFilter() GlobalAllocPtr(%lu) failed!", cbwfltr);
        return (FALSE);
    }

    //
    //
    //
    if ((NULL != paacd->pwfltr) && (0L == fdwEnum))
    {
        fdwStyle |= ACMFILTERCHOOSE_STYLEF_INITTOFILTERSTRUCT;

        _fmemcpy(pwfltr, paacd->pwfltr, (UINT)paacd->pwfltr->cbStruct);
    }


    //
    //
    //
    //
    if (0 == (ACMFILTERCHOOSE_STYLEF_SHOWHELP & fdwStyle))
    {
        guMsgHelp = 0;
    }
    else
    {
        guMsgHelp = RegisterWindowMessage(ACMHELPMSGSTRING);
        if (0 == guMsgHelp)
        {
            fdwStyle &= ~ACMFILTERCHOOSE_STYLEF_SHOWHELP;
        }
        else
        {
            gpszAcmAppHelp = gszAcmAppHelpFilter;
        }
    }



    //
    //  initialize the ACMFILTERCHOOSE members
    //
    memset(&afc, 0, sizeof(afc));

    afc.cbStruct        = sizeof(afc);
    afc.fdwStyle        = fdwStyle;
    afc.hwndOwner       = hwnd;
    afc.pwfltr          = pwfltr;
    afc.cbwfltr         = cbwfltr;
    afc.pszTitle        = TEXT("Apply Filter Choice");

    afc.szFilterTag[0]  = '\0';
    afc.szFilter[0]     = '\0';
    afc.pszName         = NULL;
    afc.cchName         = 0;

    afc.fdwEnum         = fdwEnum;
    if (0L == (afc.fdwEnum & ACM_FILTERENUMF_DWFILTERTAG))
    {
        afc.pwfltrEnum  = NULL;
    }
    else
    {
        afc.pwfltrEnum  = &wfltrEnum;
    }

    if (0L == (afc.fdwStyle & (ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATE |
                               ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE)))
    {
        afc.hInstance       = NULL;
        afc.pszTemplateName = NULL;
    }
    else
    {
        if (0L != (afc.fdwStyle & ACMFORMATCHOOSE_STYLEF_ENABLETEMPLATEHANDLE))
        {
            //
            //  ACMFILTERCHOOSE_STYLEF_ENABLETEMPLATEHANDLE
            //
            hrsrc = FindResource(ghinst, DLG_AAFILTERCHOOSE_TEMPLATE, RT_DIALOG);

            afc.hInstance       = (HINSTANCE)LoadResource(ghinst, hrsrc);
            afc.pszTemplateName = NULL;
        }
        else
        {
            afc.hInstance       = ghinst;
            afc.pszTemplateName = DLG_AAFILTERCHOOSE_TEMPLATE;
        }
    }


    if (0L == (afc.fdwStyle & ACMFILTERCHOOSE_STYLEF_ENABLEHOOK))
    {
        afc.lCustData       = 0L;
        afc.pfnHook         = NULL;
    }
    else
    {
        afc.lCustData       = (LPARAM)(UINT)paacd;
        afc.pfnHook         = AcmAppChooserFilterHook;
    }


    //
    //
    //
    mmr = acmFilterChoose(&afc);

    if (NULL != hrsrc)
    {
        FreeResource((HGLOBAL)afc.hInstance);
    }

    //
    //
    //
    if (0 != guMsgHelp)
    {
        WinHelp(hwnd, gszAcmAppHelpFilter, HELP_QUIT, 0L);
        guMsgHelp = 0;
    }

    if (MMSYSERR_NOERROR != mmr)
    {
        if (ACMERR_CANCELED != mmr)
        {
            AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                      TEXT("acmFilterChoose() failed with error = %u!"), mmr);
        }
        
        GlobalFreePtr(pwfltr);
        return (FALSE);
    }


    //
    //
    //
    if (NULL != paacd->pwfltr)
    {
        GlobalFreePtr(paacd->pwfltr);
    }

    paacd->pwfltr = pwfltr;
    lstrcpy(paacd->szFilterTag, afc.szFilterTag);
    lstrcpy(paacd->szFilter, afc.szFilter);


    return (TRUE);
} // AcmAppChooserFilter()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppChooserDriverEnumCallback
//  
//  Description:
//  
//  
//  Arguments:
//      HACMDRIVERID hadid:
//  
//      DWORD dwInstance:
//  
//      DWORD fdwSupport:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppChooserDriverEnumCallback
(
    HACMDRIVERID            hadid,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
)
{
    MMRESULT            mmr;
    HWND                hcb;
    int                 n;
    ACMDRIVERDETAILS    add;

    //
    //  skip anything that does not support what we're after (for example,
    //  this will skip _HARDWARE only drivers that do not support stream
    //  functionality).
    //
    if (0 == (fdwSupport & (ACMDRIVERDETAILS_SUPPORTF_CODEC |
                            ACMDRIVERDETAILS_SUPPORTF_CONVERTER |
                            ACMDRIVERDETAILS_SUPPORTF_FILTER)))
    {
        return (TRUE);
    }

    //
    //
    //
    hcb = (HWND)(UINT)dwInstance;

    add.cbStruct = sizeof(add);
    mmr = acmDriverDetails(hadid, &add, 0L);
    if (MMSYSERR_NOERROR != mmr)
    {
        lstrcpy(add.szLongName,  gszBogus);
    }


    AcmAppDebugLog(add.szLongName);
    AcmAppDebugLog(TEXT("\r\n"));
                
    n = ComboBox_AddString(hcb, add.szLongName);
    ComboBox_SetItemData(hcb, n, (LPARAM)(UINT)hadid);


    //
    //  return TRUE to continue with enumeration (FALSE will stop the
    //  enumerator)
    //
    return (TRUE);
} // AcmAppChooserDriverEnumCallback()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppChooserUpdateDisplay
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PAACONVERTDESC paacd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppChooserUpdateDisplay
(
    HWND                    hwnd,
    PAACONVERTDESC          paacd
)
{
    HWND                hedit;
    HWND                htxt;
    HWND                hcb;
    HWND                hsb;
    int                 n;
    MMRESULT            mmr;
    ACMDRIVERDETAILS    add;
    TCHAR               ach[40];
    LPWAVEFILTER        pwfltr;
    HACMDRIVERID        hadid;
    BOOL                f;
    DWORD               fdwOpen;
    int                 nValue;
    int                 nMinPos;
    int                 nMaxPos;
    DWORD               cbSrc;
    DWORD               cbDst;


    //
    //
    //
    htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_FILE_INPUT);
    SetWindowText(htxt, paacd->szFilePathSrc);

    AcmAppGetFormatDescription(paacd->pwfxSrc, paacd->szSrcFormatTag, paacd->szSrcFormat);
    AppFormatBigNumber(ach, paacd->cbSrcData);
    AppFormatBigNumber(&ach[20], paacd->cbSrcData / paacd->pwfxSrc->nBlockAlign);

    htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_FORMAT_INPUT);
    AppSetWindowText(htxt, TEXT("%s: %s\r\nAlignment=%u, Data=%s bytes, %s blocks"),
                        (LPTSTR)paacd->szSrcFormatTag,
                        (LPTSTR)paacd->szSrcFormat,
                        paacd->pwfxSrc->nBlockAlign,
                        (LPTSTR)ach, (LPTSTR)&ach[20]);
    
    hedit = GetDlgItem(hwnd, IDD_AACHOOSER_EDIT_FILE_OUTPUT);
    Edit_GetText(hedit, paacd->szFilePathDst, SIZEOF(paacd->szFilePathDst));


    //
    //
    //
    nValue = (int)paacd->uBufferTimePerConvert;
    hsb = GetDlgItem(hwnd, IDD_AACHOOSER_SCROLL_TIME);
    GetScrollRange(hsb, SB_CTL, &nMinPos, &nMaxPos);
    if (nValue != GetScrollPos(hsb, SB_CTL))
    {
        SetScrollPos(hsb, SB_CTL, nValue, TRUE);

        if (nValue == nMaxPos)
        {
            lstrcpy(ach, TEXT("(ALL)"));
        }
        else if (nValue == nMinPos)
        {
            lstrcpy(ach, TEXT("(Auto)"));
        }
        else
        {
            wsprintf(ach, TEXT("%u.%.03u"), nValue / 1000, nValue % 1000);
        }

        htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_TIME);
        SetWindowText(htxt, ach);
    }

    //
    //
    //
    if (nValue == nMaxPos)
    {
        cbSrc = paacd->cbSrcData;
    }
    else if (nValue == nMinPos)
    {
        //
        //  could do something real here--for now, just do '1/8th of
        //  a second'..
        //
        cbSrc = paacd->pwfxSrc->nAvgBytesPerSec;
        cbSrc = MulDivRN(cbSrc, 175, 1000);
    }
    else
    {
        cbSrc = paacd->pwfxSrc->nAvgBytesPerSec;
        cbSrc = MulDivRN(cbSrc, (UINT)nValue, 1000);
    }

    paacd->cbSrcReadSize = cbSrc;


    //
    //
    //
    paacd->hadid = NULL;

    hcb = GetDlgItem(hwnd, IDD_AACHOOSER_COMBO_DRIVER);
    n   = ComboBox_GetCurSel(hcb);
    if (LB_ERR != n)
    {
        paacd->hadid = (HACMDRIVERID)(UINT)ComboBox_GetItemData(hcb, n);
    }

    //
    //
    //
    //
    htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_FORMAT);
    if (NULL == paacd->pwfxDst)
    {
        SetWindowText(htxt, TEXT("(no format selected)"));
    }
    else
    {
        AppSetWindowText(htxt, TEXT("%s: %s\r\nAlignment=%u"),
                            (LPTSTR)paacd->szDstFormatTag,
                            (LPTSTR)paacd->szDstFormat,
                            paacd->pwfxDst->nBlockAlign);
    }


    //
    //
    //
    //
    htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_FILTER);
    if (NULL == paacd->pwfltr)
    {
        SetWindowText(htxt, TEXT("(no filter selected)"));
    }
    else
    {
        AppSetWindowText(htxt, TEXT("%s: %s"),
                            (LPTSTR)paacd->szFilterTag,
                            (LPTSTR)paacd->szFilter);
    }


    hedit = GetDlgItem(hwnd, IDD_AACHOOSER_EDIT_DETAILS);
    MEditPrintF(hedit, NULL);

    if (NULL == paacd->pwfxDst)
    {
        MEditPrintF(hedit, TEXT("hadid=%.04Xh\r\npwfxDst=%.08lXh\r\npwfltr=%.08lXh"),
                        paacd->hadid,
                        paacd->pwfxDst,
                        paacd->pwfltr);
        return (FALSE);
    }

    //
    //
    //
    if (NULL != paacd->hadid)
    {
        mmr = acmDriverOpen(&paacd->had, paacd->hadid, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            AcmAppGetErrorString(mmr, ach);
            MEditPrintF(hedit, TEXT("The selected driver (hadid=%.04Xh) cannot be opened. %s (%u)"),
                        paacd->hadid, (LPSTR)ach, mmr);
            return (FALSE);
        }
    }


    SetWindowRedraw(hedit, FALSE);


    //
    //
    //
    f = IsDlgButtonChecked(hwnd, IDD_AACHOOSER_CHECK_FILTER);
    pwfltr = (f ? paacd->pwfltr : (LPWAVEFILTER)NULL);

    paacd->fApplyFilter = f;


    fdwOpen = 0L;
    f = IsDlgButtonChecked(hwnd, IDD_AACHOOSER_CHECK_NONREALTIME);
    if (f)
    {
        fdwOpen |= ACM_STREAMOPENF_NONREALTIME;
    }

    f = IsDlgButtonChecked(hwnd, IDD_AACHOOSER_CHECK_ASYNC);
    if (f)
    {
        fdwOpen |= ACM_STREAMOPENF_ASYNC;
    }

    paacd->fdwOpen = fdwOpen;


    //
    //
    //
    MEditPrintF(hedit, TEXT("~%12s: "), (LPTSTR)TEXT("Stream Open"));
    mmr = acmStreamOpen(&paacd->has,
                        paacd->had,
                        paacd->pwfxSrc,
                        paacd->pwfxDst,
                        pwfltr,
                        0L,
                        0L,
                        fdwOpen);

    if (MMSYSERR_NOERROR == mmr)
    {
        TCHAR       szSrc[20];
        BOOL        fSrcAligned;
        BOOL        fDstAligned;

        acmDriverID((HACMOBJ)paacd->has, &hadid, 0L);

        add.cbStruct = sizeof(add);
        mmr = acmDriverDetails(hadid, &add, 0L);
        if (MMSYSERR_NOERROR != mmr)
        {
            lstrcpy(add.szLongName,  gszBogus);
        }


        MEditPrintF(hedit, TEXT("%s, %s"), (LPTSTR)gszYes, (LPTSTR)add.szLongName);

        fSrcAligned = (0 == (cbSrc % paacd->pwfxSrc->nBlockAlign));
        AppFormatBigNumber(szSrc, cbSrc);

        mmr = acmStreamSize(paacd->has, cbSrc, &cbDst, ACM_STREAMSIZEF_SOURCE);
        if (MMSYSERR_NOERROR == mmr)
        {
            TCHAR       szDst[20];

            fDstAligned = (0 == (cbDst % paacd->pwfxDst->nBlockAlign));
            AppFormatBigNumber(szDst, cbDst);

            if (cbSrc < cbDst)
            {
                cbDst = MulDivRN(cbDst, 10, cbSrc);
                cbSrc = 10;
            }
            else
            {
                cbSrc = MulDivRN(cbSrc, 10, cbDst);
                cbDst = 10;
            }

            MEditPrintF(hedit, TEXT("%12s: Src=%c%10s, Dst=%c%10s  (%lu.%lu:%lu.%lu)"),
                        (LPTSTR)TEXT("Buffer Size"),
                        fSrcAligned ? '*' : ' ',
                        (LPTSTR)szSrc,
                        fDstAligned ? '*' : ' ',
                        (LPTSTR)szDst,
                        cbSrc / 10, cbSrc % 10,
                        cbDst / 10, cbDst % 10);
        }
        else
        {
            AcmAppGetErrorString(mmr, ach);
            MEditPrintF(hedit, TEXT("%12s: Src=%c%10s, %s (%u)"), (LPTSTR)TEXT("Buffer Size"),
                        fSrcAligned ? '*' : ' ',
                        (LPTSTR)szSrc, (LPTSTR)ach, mmr);
        }

        acmStreamClose(paacd->has, 0L);
        paacd->has = NULL;
    }
    else
    {
        AcmAppGetErrorString(mmr, ach);
        MEditPrintF(hedit, TEXT("%s, %s (%u)"), (LPTSTR)gszNo, (LPSTR)ach, mmr);
    }


    //
    //
    //
    MEditPrintF(hedit, TEXT("~%12s: "), (LPTSTR)TEXT("(Query)"));
    mmr = acmStreamOpen(NULL,
                        paacd->had,
                        paacd->pwfxSrc,
                        paacd->pwfxDst,
                        pwfltr,
                        0L,
                        0L,
                        fdwOpen | ACM_STREAMOPENF_QUERY);

    if (MMSYSERR_NOERROR == mmr)
    {
        MEditPrintF(hedit, gszYes);
    }
    else
    {
        AcmAppGetErrorString(mmr, ach);
        MEditPrintF(hedit, TEXT("%s, %s (%u)"), (LPTSTR)gszNo, (LPSTR)ach, mmr);
    }

    if (NULL != paacd->had)
    {
        acmDriverClose(paacd->had, 0L);
        paacd->had = NULL;
    }

    SetWindowRedraw(hedit, TRUE);


    return (MMSYSERR_NOERROR == mmr);
} // AcmAppChooserUpdateDisplay()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppChooserScrollConvertTime
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      HWND hsb:
//  
//      UINT uCode:
//  
//      int nPos:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppChooserScrollConvertTime
(
    HWND                    hwnd,
    HWND                    hsb,
    UINT                    uCode,
    int                     nPos
)
{
    PAACONVERTDESC      paacd;
    int                 nMinPos;
    int                 nMaxPos;
    HWND                htxt;
    TCHAR               ach[40];


    GetScrollRange(hsb, SB_CTL, &nMinPos, &nMaxPos);

    if ((SB_THUMBPOSITION != uCode) && (SB_THUMBTRACK != uCode))
    {
        nPos = GetScrollPos(hsb, SB_CTL);
    }

    //
    //
    //
    switch (uCode)
    {
        case SB_PAGEDOWN:
            if (GetKeyState(VK_CONTROL) < 0)
                nPos = min(nMaxPos, nPos + 100);
            else
                nPos = min(nMaxPos, nPos + 500);
            break;

        case SB_LINEDOWN:
            if (GetKeyState(VK_CONTROL) < 0)
                nPos = min(nMaxPos, nPos + 1);
            else
                nPos = min(nMaxPos, nPos + 10);
            break;

        case SB_PAGEUP:
            if (GetKeyState(VK_CONTROL) < 0)
                nPos = max(nMinPos, nPos - 100);
            else
                nPos = max(nMinPos, nPos - 500);
            break;

        case SB_LINEUP:
            if (GetKeyState(VK_CONTROL) < 0)
                nPos = max(nMinPos, nPos - 1);
            else
                nPos = max(nMinPos, nPos - 10);
            break;


        case SB_TOP:
            if (GetKeyState(VK_CONTROL) < 0)
                nPos = nMinPos;
            else
                nPos = 1000;
            break;

        case SB_BOTTOM:
            nPos = nMaxPos;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            break;

        default:
            return (FALSE);
    }

    //
    //
    //
    paacd = (PAACONVERTDESC)(UINT)GetWindowLong(hwnd, DWL_USER);

    paacd->uBufferTimePerConvert = (UINT)nPos;

    SetScrollPos(hsb, SB_CTL, nPos, TRUE);

    if (nPos == nMaxPos)
    {
        lstrcpy(ach, TEXT("(ALL)"));
    }
    else if (nPos == nMinPos)
    {
        lstrcpy(ach, TEXT("(Auto)"));
    }
    else
    {
        wsprintf(ach, TEXT("%u.%.03u"), nPos / 1000, nPos % 1000);
    }

    htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_TIME);
    SetWindowText(htxt, ach);

    //
    //
    //
    return (TRUE);
} // AcmAppChooserScrollConvertTime()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppDlgProcChooser
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDlgProcChooser
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PAACONVERTDESC      paacd;
    HWND                hedit;
    HWND                htxt;
    HWND                hcb;
    HWND                hsb;
    HFONT               hfont;
    UINT                uId;
    UINT                uCmd;
    BOOL                f;

    //
    //
    //
    if ((0 != guMsgHelp) && (uMsg == guMsgHelp))
    {
        WinHelp(hwnd, gpszAcmAppHelp, HELP_CONTENTS, 0L);
        return (TRUE);
    }

    paacd = (PAACONVERTDESC)(UINT)GetWindowLong(hwnd, DWL_USER);

    //
    //
    //
    switch (uMsg)
    {
        case WM_INITDIALOG:
            paacd = (PAACONVERTDESC)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

            if (NULL == paacd->pwfxSrc)
            {
                AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                          TEXT("You must select a source file to convert."));
                EndDialog(hwnd, FALSE);
                return (TRUE);
            }

            if (NULL == paacd->pwfxDst)
            {
                AcmAppChooserFormatSuggest(hwnd, paacd);
            }

            hfont = GetStockFont(ANSI_VAR_FONT);

            htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_FILE_INPUT);
            SetWindowFont(htxt, hfont, FALSE);

            htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_FORMAT_INPUT);
            SetWindowFont(htxt, hfont, FALSE);
    
            hedit = GetDlgItem(hwnd, IDD_AACHOOSER_EDIT_FILE_OUTPUT);
            SetWindowFont(hedit, hfont, FALSE);
            Edit_SetText(hedit, paacd->szFilePathDst);

            hcb = GetDlgItem(hwnd, IDD_AACHOOSER_COMBO_DRIVER);
            SetWindowFont(hcb, hfont, FALSE);

            htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_FORMAT);
            SetWindowFont(htxt, hfont, FALSE);

            htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_FILTER);
            SetWindowFont(htxt, hfont, FALSE);


            hfont = ghfontApp;

            htxt = GetDlgItem(hwnd, IDD_AACHOOSER_TXT_TIME);
            SetWindowFont(htxt, hfont, FALSE);

            hedit = GetDlgItem(hwnd, IDD_AACHOOSER_EDIT_DETAILS);
            SetWindowFont(hedit, hfont, FALSE);

            hsb = GetDlgItem(hwnd, IDD_AACHOOSER_SCROLL_TIME);
            SetScrollRange(hsb, SB_CTL, 0, 10000, FALSE);


            //
            //
            //
            CheckDlgButton(hwnd, IDD_AACHOOSER_CHECK_NONREALTIME, TRUE);

            SendMessage(hwnd, WM_ACMAPP_ACM_NOTIFY, 0, 0L);
            return (TRUE);


        case WM_ACMAPP_ACM_NOTIFY:
            AppHourGlass(TRUE);
            hcb = GetDlgItem(hwnd, IDD_AACHOOSER_COMBO_DRIVER);

            SetWindowRedraw(hcb, FALSE);
            ComboBox_ResetContent(hcb);

            ComboBox_AddString(hcb, TEXT("[ACM Driver Mapper]"));

            AcmAppDebugLog(NULL);
            acmDriverEnum(AcmAppChooserDriverEnumCallback, (DWORD)(UINT)hcb, 0L);

            ComboBox_SetCurSel(hcb, 0);
            SetWindowRedraw(hcb, TRUE);

            f = AcmAppChooserUpdateDisplay(hwnd, paacd);
            EnableWindow(GetDlgItem(hwnd, IDOK), f);
            EnableWindow(GetDlgItem(hwnd, IDD_AACHOOSER_BTN_PROPERTIES), f);

            AppHourGlass(FALSE);
            break;


        case WM_HSCROLL:
            f = (BOOL)HANDLE_WM_HSCROLL(hwnd, wParam, lParam, AcmAppChooserScrollConvertTime);
            f = TRUE;
            if (f)
            {
                AppHourGlass(TRUE);

                f = AcmAppChooserUpdateDisplay(hwnd, paacd);
                EnableWindow(GetDlgItem(hwnd, IDOK), f);
                EnableWindow(GetDlgItem(hwnd, IDD_AACHOOSER_BTN_PROPERTIES), f);

                AppHourGlass(FALSE);
            }
            return (TRUE);


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            f   = FALSE;

            switch (uId)
            {
                case IDD_AACHOOSER_BTN_BROWSE:
                    f = AcmAppChooserSaveFile(hwnd, paacd);
                    break;

                case IDD_AACHOOSER_BTN_PROPERTIES:
                    f = AcmAppChooserProperties(hwnd, paacd);
                    break;

                case IDD_AACHOOSER_BTN_FORMAT_OPTIONS:
                case IDD_AACHOOSER_BTN_FORMAT:
                    f = (IDD_AACHOOSER_BTN_FORMAT_OPTIONS == uId);
                    f = AcmAppChooserFormat(hwnd, paacd, f);
                    break;

                case IDD_AACHOOSER_BTN_FILTER_OPTIONS:
                case IDD_AACHOOSER_BTN_FILTER:
                    f = (IDD_AACHOOSER_BTN_FILTER_OPTIONS == uId);
                    f = AcmAppChooserFilter(hwnd, paacd, f);
                    break;


                case IDD_AACHOOSER_COMBO_DRIVER:
                    uCmd = GET_WM_COMMAND_CMD(wParam, lParam);
                    switch (uCmd)
                    {
                        case CBN_SELCHANGE:
                            f = TRUE;
                            break;
                    }
                    break;


                case IDD_AACHOOSER_CHECK_FILTER:
                case IDD_AACHOOSER_CHECK_NONREALTIME:
                case IDD_AACHOOSER_CHECK_ASYNC:
                    f = TRUE;
                    break;


                case IDOK:
                    hedit = GetDlgItem(hwnd, IDD_AACHOOSER_EDIT_FILE_OUTPUT);
                    Edit_GetText(hedit, paacd->szFilePathDst, SIZEOF(paacd->szFilePathDst));
                    
                case IDCANCEL:
                    EndDialog(hwnd, (IDOK == uId));
                    break;
            }

            //
            //
            //
            if (f)
            {
                AppHourGlass(TRUE);

                f = AcmAppChooserUpdateDisplay(hwnd, paacd);
                EnableWindow(GetDlgItem(hwnd, IDOK), f);
                EnableWindow(GetDlgItem(hwnd, IDD_AACHOOSER_BTN_PROPERTIES), f);

                AppHourGlass(FALSE);
            }
            break;
    }

    return (FALSE);
} // AcmAppDlgProcChooser()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\aaplyrec.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  aaplyrec.c
//
//  Description:
//      An play/record dialog based on MCI Wave.
//
//
//  Known Bugs In MCIWAVE for Windows 3.1:
//  ======================================
//
//  o   If you are running SHARE (or the equivelant) and attempt to open
//      a file that is open by another application, you will receive the
//      following error:
//
//          "Cannot find the specified file. Make sure the path and
//           filename are correct..."
//
//      This is of course wrong. The problem is the file cannot be opened
//      read/write by multiple applications.
//
//  o   Opening a wave file that is more than about three seconds long and
//      issueing the following commands will hang Windows:
//
//          open xxx.wav alias zyz          ; open > 3 second file
//          delete zyz from 1000 to 2000    ; remove some data
//          delete zyz from 1000 to 2000    ; do it again and you hang
//
//      I think this will also happen with the following commands:
//
//          open c:\win31\ding.wav alias zyz
//          delete zyz to 100
//
//  o   You cannot play or record data with a synchronous wave device. This
//      is due to MCIWAVE relying on the ability to 'stream' data. This is
//      not really a bug, just a limitation.
//
//  o   Block alignment is not correctly handled for non-PCM wave files
//      when editing (includes recording). It is illegal to start recording
//      in the middle of a block. The result if this happens is garbage
//      data. This occurs if you insert data with a partial block at the
//      end also...
//
//  o   It is possible to kill Windows by issueing the following commands
//      without yielding between sending the commands:
//
//          capability <file> inputs
//          close <file>
//          open <file>
//
//      Should be able to fix the problem by Yield'ing.
//
//  o   Saving to the same wave file twice without closing the device deletes
//      the existing file. Don't save twice.
//  
//  o   Saving an 'empty' wave file does not work. Issueing the following
//      commands demonstrates the problem:
//
//          open new type waveaudio alias zyz
//          save zyz as c:\zyz.wav
//
//      You will receive an 'out of memory error' which is completely bogus.
//      Just don't save empty files.
//
//  o   Setting the time format to bytes doesn't work with compressed files.
//      Sigh...
//
//  o   And there are others with less frequently used commands.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <stdlib.h>
#include <memory.h>
#include <mmreg.h>
#include <msacm.h>

#include "muldiv32.h"
#include "appport.h"
#include "acmapp.h"

#include "debug.h"


#ifndef _MCIERROR_
#define _MCIERROR_
typedef DWORD           MCIERROR;   // error return code, 0 means no error
#endif


TCHAR           gszAlias[]          = TEXT("zyzthing");

BOOL            gfFileOpen;
BOOL            gfDirty;
BOOL            gfTimerGoing;

UINT            guPlayRecordStatus;


#define AAPLAYRECORD_TIMER_RESOLUTION       54

#define AAPLAYRECORD_MAX_MCI_COMMAND_CHARS  255

#define AAPLAYRECORD_STATUS_NOT_READY       0
#define AAPLAYRECORD_STATUS_PAUSED          1
#define AAPLAYRECORD_STATUS_PLAYING         2
#define AAPLAYRECORD_STATUS_STOPPED         3
#define AAPLAYRECORD_STATUS_RECORDING       4
#define AAPLAYRECORD_STATUS_SEEKING         5

#define AAPLAYRECORD_STATUS_NOT_OPEN        (UINT)-1


//--------------------------------------------------------------------------;
//  
//  MCIERROR AcmPlayRecordSendCommand
//  
//  Description:
//      The string is of the form "verb params" our device name is inserted
//      after the verb and send to the device.
//  
//  Arguments:
//      HWND hwnd:
//  
//      PSTR pszCommand:
//  
//      PSTR pszReturn:
//  
//      UINT cbReturn:
//  
//      BOOL fErrorBox:
//  
//  Return (MCIERROR):
//  
//  
//--------------------------------------------------------------------------;

MCIERROR FNLOCAL AcmPlayRecordSendCommand
(
    HWND                    hwnd,
    PTSTR                   pszCommand,
    PTSTR                   pszReturn,
    UINT                    cbReturn,
    BOOL                    fErrorBox
)
{
    MCIERROR            mcierr;
    TCHAR               ach[AAPLAYRECORD_MAX_MCI_COMMAND_CHARS * 2];
    TCHAR              *pch;
    PTSTR               psz;

    pch = pszCommand;

    while (('\t' == *pch) || (' ' == *pch))
    {
        pch++;
    }

    if (0 == lstrlen(pch))
    {
        return (MMSYSERR_NOERROR);
    }

    pch = ach;
    psz = pszCommand;
    while (('\0' != *psz) && (' ' != *psz))
    {
        *pch++ = *psz++;
    }

    *pch++ = ' ';

    lstrcpy(pch, gszAlias);
    lstrcat(pch, psz);

    mcierr = mciSendString(ach, pszReturn, cbReturn, hwnd);
    if (MMSYSERR_NOERROR != mcierr)
    {
        if (fErrorBox)
        {
            int         n;

            n = wsprintf(ach, TEXT("Command: '%s'\n\nMCI Wave Error (%lu): "),
                            (LPTSTR)pszCommand, mcierr);

            mciGetErrorString(mcierr, &ach[n], SIZEOF(ach) - n);
            MessageBox(hwnd, ach, TEXT("MCI Wave Error"), MB_ICONEXCLAMATION | MB_OK);
        }
    }

    return (mcierr);
} // AcmPlayRecordSendCommand()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordCommand
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordCommand
(
    HWND                    hwnd
)
{
    TCHAR               ach[AAPLAYRECORD_MAX_MCI_COMMAND_CHARS * 2];
    HWND                hedit;
    MCIERROR            mcierr;

    //
    //
    //
    hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND);
    Edit_SetSel(hedit, 0, -1);

    Edit_GetText(hedit, ach, SIZEOF(ach));

    mcierr = AcmPlayRecordSendCommand(hwnd, ach, ach, SIZEOF(ach), FALSE);
    if (MMSYSERR_NOERROR != mcierr)
    {
        mciGetErrorString(mcierr, ach, SIZEOF(ach));
    }

    hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_RESULT);
    Edit_SetText(hedit, ach);

    return (TRUE);
} // AcmAppPlayRecordCommand()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordSetPosition
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      HWND hsb:
//  
//      UINT uCode:
//  
//      int nPos:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordSetPosition
(
    HWND                    hwnd,
    HWND                    hsb,
    UINT                    uCode,
    int                     nPos
)
{
    MCIERROR            mcierr;
    TCHAR               szPosition[40];
    TCHAR               szLength[40];
    LONG                lLength;
    LONG                lPosition;
    LONG                lPageInc;
    int                 nRange;
    int                 nMinPos;


    //
    //
    //
    //
    if (AAPLAYRECORD_STATUS_NOT_OPEN == guPlayRecordStatus)
    {
        return (FALSE);
    }


    //
    //
    //
    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status length"), szLength, SIZEOF(szLength), FALSE);
    if (MMSYSERR_NOERROR != mcierr)
    {
        return (FALSE);
    }

    lLength = _tcstol(szLength, NULL, 10);
    if (0L == lLength)
    {
        return (FALSE);
    }

    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status position"), szPosition, SIZEOF(szPosition), FALSE);
    if (MMSYSERR_NOERROR != mcierr)
    {
        return (FALSE);
    }

    lPosition = _tcstol(szPosition, NULL, 10);

    lPageInc = (lLength / 10);
    if (0L == lPageInc)
    {
        lPageInc = 1;
    }


    //
    //
    //
    switch (uCode)
    {
        case SB_PAGEDOWN:
            lPosition = min(lLength, lPosition + lPageInc);
            break;

        case SB_LINEDOWN:
            lPosition = min(lLength, lPosition + 1);
            break;

        case SB_PAGEUP:
            lPosition -= lPageInc;

            //-- fall through --//

        case SB_LINEUP:
            lPosition = (lPosition < 1) ? 0 : (lPosition - 1);
            break;


        case SB_TOP:
            lPosition = 0;
            break;

        case SB_BOTTOM:
            lPosition = lLength;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            GetScrollRange(hsb, SB_CTL, &nMinPos, &nRange);
            lPosition = (DWORD)MulDivRN((DWORD)nPos, (DWORD)lLength, (DWORD)nRange);
            break;

        default:
            return (FALSE);
    }

    //
    //
    //
    wsprintf(szPosition, TEXT("seek to %lu"), lPosition);
    AcmPlayRecordSendCommand(hwnd, szPosition, NULL, 0, FALSE);

    return (TRUE);
} // AcmAppPlayRecordSetPosition()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordStatus
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordStatus
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    TCHAR               ach[AAPLAYRECORD_MAX_MCI_COMMAND_CHARS];
    TCHAR               szMode[40];
    TCHAR               szPosition[40];
    TCHAR               szLength[40];
    TCHAR               szFormat[40];
    MCIERROR            mcierr;
    UINT                uStatus;
    BOOL                fStartTimer;
    BOOL                fPlay;
    BOOL                fPause;
    BOOL                fStop;
    BOOL                fStart;
    BOOL                fEnd;
    BOOL                fRecord;
    BOOL                fCommand;
    UINT                uIdFocus;
    DWORD               dwLength;
    DWORD               dwPosition;
    HWND                hsb;

    //
    //
    //
    if (AAPLAYRECORD_STATUS_NOT_OPEN != guPlayRecordStatus)
    {
        mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status mode"), szMode, SIZEOF(szMode), FALSE);
        if (MMSYSERR_NOERROR != mcierr)
        {
            guPlayRecordStatus = AAPLAYRECORD_STATUS_NOT_OPEN;
        }
    }


    //
    //  assume all buttons disabled
    //
    fStartTimer = FALSE;
    fPlay       = FALSE;
    fPause      = FALSE;
    fStop       = FALSE;
    fStart      = FALSE;
    fEnd        = FALSE;
    fRecord     = FALSE;
    fCommand    = TRUE;
    uIdFocus    = IDOK;
    dwPosition  = 0L;
    dwLength    = 0L;
    lstrcpy(szFormat, TEXT("???"));

    hsb = GetDlgItem(hwnd, IDD_AAPLAYRECORD_SCROLL_POSITION);


    //
    //
    //
    if (AAPLAYRECORD_STATUS_NOT_OPEN == guPlayRecordStatus)
    {
        lstrcpy(szMode, TEXT("not open"));
    }
    else if (0 == lstrcmpi(TEXT("not ready"), szMode))
    {
        uStatus = AAPLAYRECORD_STATUS_NOT_READY;

        fStartTimer = TRUE;
    }
    else if (0 == lstrcmpi(TEXT("paused"), szMode))
    {
        uStatus = AAPLAYRECORD_STATUS_PAUSED;

        fPause      = TRUE;
        fStop       = TRUE;
    }
    else if (0 == lstrcmpi(TEXT("playing"), szMode))
    {
        uStatus = AAPLAYRECORD_STATUS_PLAYING;

        fStartTimer = TRUE;
        fPause      = TRUE;
        fStop       = TRUE;
    }
    else if (0 == lstrcmpi(TEXT("stopped"), szMode))
    {
        uStatus = AAPLAYRECORD_STATUS_STOPPED;

        fPlay       = TRUE;
        fStart      = TRUE;
        fEnd        = TRUE;
        fRecord     = TRUE;
    }
    else if (0 == lstrcmpi(TEXT("recording"), szMode))
    {
        uStatus = AAPLAYRECORD_STATUS_RECORDING;

        fStartTimer = TRUE;
        fPause      = TRUE;
        fStop       = TRUE;
    }
    else if (0 == lstrcmpi(TEXT("seeking"), szMode))
    {
        uStatus = AAPLAYRECORD_STATUS_SEEKING;

        fStartTimer = TRUE;
        fStop       = TRUE;
    }


    //
    //
    //
    //
    //
    if (fStartTimer)
    {
        if (!gfTimerGoing)
        {
            SetTimer(hwnd, 1, AAPLAYRECORD_TIMER_RESOLUTION, NULL);
            gfTimerGoing = TRUE;
        }
    }
    else if (gfTimerGoing)
    {
        KillTimer(hwnd, 1);
        gfTimerGoing = FALSE;
    }


    //
    //
    //
    //
    if (AAPLAYRECORD_STATUS_NOT_OPEN != guPlayRecordStatus)
    {
        //
        //
        //
        mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status position"), szPosition, SIZEOF(szPosition), FALSE);
        if (MMSYSERR_NOERROR == mcierr)
        {
            dwPosition = _tcstoul(szPosition, NULL, 10);
        }

        mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status length"), szLength, SIZEOF(szLength), FALSE);
        if (MMSYSERR_NOERROR == mcierr)
        {
            dwLength   = _tcstoul(szLength, NULL, 10);
        }

        mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status time format"), szFormat, SIZEOF(szFormat), FALSE);
    }


    //
    //
    //
    //
    if (uStatus != guPlayRecordStatus)
    {
        if (GetFocus() != hsb)
        {
            LRESULT             lr;

            lr = SendMessage(hwnd, DM_GETDEFID, 0, 0L);
            if (DC_HASDEFID == HIWORD(lr))
            {
                UINT        uIdDefId;

                uIdDefId = LOWORD(lr);
                if (IDOK != uIdDefId)
                {
                    HWND        hwndDefId;

                    hwndDefId = GetDlgItem(hwnd, uIdDefId);

                    Button_SetStyle(hwndDefId, BS_PUSHBUTTON, TRUE);
                }
            }


            SendMessage(hwnd, DM_SETDEFID, IDOK, 0L);

            SetFocus(GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND));
        }

        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_PLAY),   fPlay  );
        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_PAUSE),  fPause );
        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_STOP),   fStop  );
        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_START),  fStart );
        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_END),    fEnd   );
        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_RECORD), fRecord);

        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND), fCommand);
        EnableWindow(GetDlgItem(hwnd, IDOK), fCommand);

        if (AAPLAYRECORD_STATUS_PAUSED == uStatus)
            SetDlgItemText(hwnd, IDD_AAPLAYRECORD_BTN_PAUSE, TEXT("Resum&e"));
        else
            SetDlgItemText(hwnd, IDD_AAPLAYRECORD_BTN_PAUSE, TEXT("Paus&e"));

        guPlayRecordStatus = uStatus;
    }

    //
    //
    //
    AppFormatBigNumber(szPosition, dwPosition);
    AppFormatBigNumber(szLength, dwLength);

    wsprintf(ach, TEXT("%s: %14s (%s) %s"),
                 (LPSTR)szMode,
                 (LPSTR)szPosition,
                 (LPSTR)szLength,
                 (LPSTR)szFormat);

    SetDlgItemText(hwnd, IDD_AAPLAYRECORD_TXT_POSITION, ach);


    //
    //
    //
    //
    {
        int         nRange;
        int         nValue;
        int         nMinPos;
        int         nMaxPos;

        GetScrollRange(hsb, SB_CTL, &nMinPos, &nMaxPos);

        nRange = (int)min(dwLength, 32767L);

        if (nMaxPos != nRange)
        {
            SetScrollRange(hsb, SB_CTL, 0, nRange, FALSE);
        }

        //
        //
        //
        nValue = 0;
        if (0L != dwLength)
        {
            nValue = (int)MulDivRN(dwPosition, nRange, dwLength);
        }

        if (nValue != GetScrollPos(hsb, SB_CTL))
        {
            SetScrollPos(hsb, SB_CTL, nValue, TRUE);
        }
    }

    return (TRUE);
} // AcmAppPlayRecordStatus()



//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordRecord
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordRecord
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    MCIERROR            mcierr;

    //
    //
    //
    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("record insert"), NULL, 0, TRUE);
    if (MMSYSERR_NOERROR == mcierr)
    {
        gfDirty = TRUE;
    }

    return (MMSYSERR_NOERROR == mcierr);
} // AcmAppPlayRecordRecord()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordStart
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordStart
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    MCIERROR            mcierr;

    //
    //
    //
    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("seek to start"), NULL, 0, TRUE);

    return (MMSYSERR_NOERROR == mcierr);
} // AcmAppPlayRecordStart()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordEnd
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordEnd
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    MCIERROR            mcierr;

    //
    //
    //
    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("seek to end"), NULL, 0, TRUE);

    return (MMSYSERR_NOERROR == mcierr);
} // AcmAppPlayRecordEnd()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordStop
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordStop
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    MCIERROR            mcierr;

    //
    //
    //
    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("stop"), NULL, 0, TRUE);

    return (MMSYSERR_NOERROR == mcierr);
} // AcmAppPlayRecordStop()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordPause
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordPause
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    MCIERROR            mcierr;
    PTSTR               psz;

    //
    //
    //
    if (AAPLAYRECORD_STATUS_PAUSED == guPlayRecordStatus)
        psz = TEXT("resume");
    else
        psz = TEXT("pause");

    mcierr = AcmPlayRecordSendCommand(hwnd, psz, NULL, 0, TRUE);

    return (MMSYSERR_NOERROR == mcierr);
} // AcmAppPlayRecordPause()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordPlay
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordPlay
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    MCIERROR            mcierr;
    TCHAR               szPosition[40];
    TCHAR               szLength[40];


    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status position"), szPosition, SIZEOF(szPosition), TRUE);
    if (MMSYSERR_NOERROR != mcierr)
    {
        return (FALSE);
    }

    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status length"), szLength, SIZEOF(szLength), TRUE);
    if (MMSYSERR_NOERROR != mcierr)
    {
        return (FALSE);
    }

    if (0 == lstrcmp(szPosition, szLength))
    {
        AcmPlayRecordSendCommand(hwnd, TEXT("seek to start"), NULL, 0, TRUE);
    }


    //
    //
    //
    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("play"), NULL, 0, TRUE);

    return (MMSYSERR_NOERROR == mcierr);
} // AcmAppPlayRecordPlay()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordClose
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordClose
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    MCIERROR            mcierr;

    if (gfDirty)
    {
        UINT    u;

        u = MessageBox(hwnd, TEXT("Save newly recorded data?"), TEXT("Save"),
                       MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2);
        if (IDYES == u)
        {
            AppHourGlass(TRUE);
            mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("save"), NULL, 0, TRUE);
            AppHourGlass(FALSE);
        }
        else
        {
            gfDirty = FALSE;
        }
    }

    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("close"), NULL, 0, TRUE);

    return (MMSYSERR_NOERROR == mcierr);
} // AcmAppPlayRecordClose()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordOpen
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordOpen
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd,
    UINT                    uWaveInId,
    UINT                    uWaveOutId
)
{
    TCHAR               ach[AAPLAYRECORD_MAX_MCI_COMMAND_CHARS];
    MCIERROR            mcierr;

    guPlayRecordStatus = AAPLAYRECORD_STATUS_NOT_OPEN;

    gfTimerGoing       = FALSE;
    gfFileOpen         = FALSE;

    gfDirty = FALSE;

    if (NULL == paafd->pwfx)
    {
        MessageBox(hwnd, TEXT("No wave file currently selected."),
                    TEXT("Open Error"), MB_ICONEXCLAMATION | MB_OK);
        return (FALSE);
    }

    wsprintf(ach, TEXT("open %s alias %s"), (LPSTR)paafd->szFilePath, (LPSTR)gszAlias);

    mcierr = mciSendString(ach, NULL, 0, NULL);
    if (MMSYSERR_NOERROR != mcierr)
    {
        mciGetErrorString(mcierr, ach, SIZEOF(ach));
        MessageBox(hwnd, ach, TEXT("Open Error"), MB_ICONEXCLAMATION | MB_OK);

        return (FALSE);
    }

    gfFileOpen         = TRUE;
    guPlayRecordStatus = AAPLAYRECORD_STATUS_NOT_READY;

    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("set time format samples"), NULL, 0, TRUE);

    if (WAVE_MAPPER != uWaveInId)
    {
        wsprintf(ach, TEXT("set input %u"), uWaveInId);
        mcierr = AcmPlayRecordSendCommand(hwnd, ach, NULL, 0, TRUE);
    }

    if (WAVE_MAPPER != uWaveOutId)
    {
        wsprintf(ach, TEXT("set output %u"), uWaveOutId);
        mcierr = AcmPlayRecordSendCommand(hwnd, ach, NULL, 0, TRUE);
    }

    return (TRUE);
} // AcmAppPlayRecordOpen()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppPlayRecordInitCommands
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppPlayRecordInitCommands
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    static PTSTR    pszCommands[] =
    {
        TEXT("play"),
        TEXT("play to Y"),
        TEXT("play from X to Y"),

        TEXT(""),
        TEXT("capability can eject"),
        TEXT("capability can play"),
        TEXT("capability can record"),
        TEXT("capability can save"),
        TEXT("capability compound device"),
        TEXT("capability device type"),
        TEXT("capability has audio"),
        TEXT("capability has video"),
        TEXT("capability inputs"),
        TEXT("capability outputs"),
        TEXT("capability uses files"),

        TEXT(""),
        TEXT("cue input !"),
        TEXT("cue output !"),

        TEXT(""),
        TEXT("delete to Y !"),
        TEXT("delete from X to Y !"),

        TEXT(""),
        TEXT("info input"),
        TEXT("info file"),
        TEXT("info output"),
        TEXT("info product"),

        TEXT(""),
        TEXT("pause"),

        TEXT(""),
        TEXT("record insert !"),
        TEXT("record overwrite !"),
        TEXT("record to Y !"),
        TEXT("record from X to Y !"),

        TEXT(""),
        TEXT("resume"),

        TEXT(""),
        TEXT("save"),
        TEXT("save FILENAME"),

        TEXT(""),
        TEXT("seek to Y"),
        TEXT("seek to start"),
        TEXT("seek to end"),

        TEXT(""),
        TEXT("set alignment X"),
        TEXT("set any input"),
        TEXT("set any output"),
        TEXT("set audio all off"),
        TEXT("set audio all on"),
        TEXT("set audio left off"),
        TEXT("set audio left on"),
        TEXT("set audio right off"),
        TEXT("set audio right on"),
        TEXT("set bitspersample X"),
        TEXT("set bytespersec X"),
        TEXT("set channels X"),
        TEXT("set format tag X"),
        TEXT("set format tag pcm"),
        TEXT("set input X"),
        TEXT("set output X"),
        TEXT("set samplespersec X"),
        TEXT("set time format bytes"),
        TEXT("set time format milliseconds"),
        TEXT("set time format samples"),

        TEXT(""),
        TEXT("status alignment"),
        TEXT("status bitspersample"),
        TEXT("status bytespersec"),
        TEXT("status channels"),
        TEXT("status current track"),
        TEXT("status format tag"),
        TEXT("status input"),
        TEXT("status length"),
        TEXT("status length track X"),
        TEXT("status level"),
        TEXT("status media present"),
        TEXT("status mode"),
        TEXT("status number of tracks"),
        TEXT("status output"),
        TEXT("status position"),
        TEXT("status position track X"),
        TEXT("status ready"),
        TEXT("status samplespersec"),
        TEXT("status start position"),
        TEXT("status time format"),

        TEXT(""),
        TEXT("stop"),
        NULL
    };

    HWND                hcb;
    UINT                u;
    PTSTR               psz;

    //
    //
    //
    hcb = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND);

    for (u = 0; psz = pszCommands[u]; u++)
    {
        ComboBox_AddString(hcb, psz);
    }

    ComboBox_SetCurSel(hcb, 0);

    return (TRUE);
} // AcmAppPlayRecordInitCommands()



//--------------------------------------------------------------------------;
//
//  BOOL AcmAppPlayRecord
//
//  Description:
//
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppPlayRecord
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    PACMAPPFILEDESC     paafd;
    UINT                uId;
    HWND                hedit;
    HFONT               hfont;

    paafd = (PACMAPPFILEDESC)(UINT)GetWindowLong(hwnd, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            paafd = (PACMAPPFILEDESC)(UINT)lParam;

            SetWindowLong(hwnd, DWL_USER, lParam);

//          hfont = GetStockFont(ANSI_FIXED_FONT);
            hfont = ghfontApp;

            hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_TXT_POSITION);
            SetWindowFont(hedit, hfont, FALSE);

            hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND);
            SetWindowFont(hedit, hfont, FALSE);

            hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_RESULT);
            SetWindowFont(hedit, hfont, FALSE);

            AcmAppPlayRecordInitCommands(hwnd, paafd);

            AcmAppPlayRecordOpen(hwnd, paafd, guWaveInId, guWaveOutId);
            AcmAppPlayRecordStatus(hwnd, paafd);


            //
            //  if the format is non-PCM, display a little warning so the
            //  user knows that not everything may work correctly when
            //  dealing working with MCI Wave..
            //
            if ((NULL != paafd->pwfx) &&
                (WAVE_FORMAT_PCM != paafd->pwfx->wFormatTag))
            {
                hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_RESULT);
                Edit_SetText(hedit, TEXT("WARNING! There are known bugs with MCI Wave EDITING operations on non-PCM formats--see the README.TXT with this application. (end)\r\n\r\nRemember, DON'T PANIC!\r\n\r\n\r\n\r\n\r\n\r\n- zYz -"));
            }
            return (TRUE);

        case WM_TIMER:
            AcmAppPlayRecordStatus(hwnd, paafd);
            break;

        case WM_HSCROLL:
            HANDLE_WM_HSCROLL(hwnd, wParam, lParam, AcmAppPlayRecordSetPosition);

            guPlayRecordStatus = AAPLAYRECORD_STATUS_SEEKING;
            AcmAppPlayRecordStatus(hwnd, paafd);
            return (TRUE);

        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uId)
            {
                case IDD_AAPLAYRECORD_BTN_PLAY:
                    AcmAppPlayRecordPlay(hwnd, paafd);
                    AcmAppPlayRecordStatus(hwnd, paafd);
                    break;

                case IDD_AAPLAYRECORD_BTN_PAUSE:
                    AcmAppPlayRecordPause(hwnd, paafd);
                    AcmAppPlayRecordStatus(hwnd, paafd);
                    break;

                case IDD_AAPLAYRECORD_BTN_STOP:
                    AcmAppPlayRecordStop(hwnd, paafd);
                    AcmAppPlayRecordStatus(hwnd, paafd);
                    break;

                case IDD_AAPLAYRECORD_BTN_START:
                    AcmAppPlayRecordStart(hwnd, paafd);
                    AcmAppPlayRecordStatus(hwnd, paafd);
                    break;

                case IDD_AAPLAYRECORD_BTN_END:
                    AcmAppPlayRecordEnd(hwnd, paafd);
                    AcmAppPlayRecordStatus(hwnd, paafd);
                    break;

                case IDD_AAPLAYRECORD_BTN_RECORD:
                    AcmAppPlayRecordRecord(hwnd, paafd);
                    AcmAppPlayRecordStatus(hwnd, paafd);
                    break;

                case IDOK:
                    AcmAppPlayRecordCommand(hwnd);

                    guPlayRecordStatus = AAPLAYRECORD_STATUS_SEEKING;
                    AcmAppPlayRecordStatus(hwnd, paafd);
                    break;


                case IDCANCEL:
                    if (gfFileOpen)
                    {
                        AcmAppPlayRecordStop(hwnd, paafd);
                        AcmAppPlayRecordStatus(hwnd, paafd);

                        AcmAppPlayRecordClose(hwnd, paafd);
                    }

                    EndDialog(hwnd, gfDirty);
                    break;
            }
            break;
    }

    return (FALSE);
} // AcmAppPlayRecord()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\aainit.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  aainit.c
//
//  Description:
//      This file contains initialization and termination code for the
//      application (as well as some rarely used stuff).
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commdlg.h>
#ifndef WIN32
#include <shellapi.h>
#endif
#include <mmreg.h>
#include <msacm.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>

#include "acmthunk.h"
#include "appport.h"
#include "acmapp.h"

#include "debug.h"


//
//
//
TCHAR   gszSecConfig[]          = TEXT("Configuration");

TCHAR   gszKeyOptions[]         = TEXT("Options");
TCHAR   gszFormatOptions[]      = TEXT("%u");

TCHAR   gszKeyWindow[]          = TEXT("Window");
TCHAR   gszKeyFont[]            = TEXT("Font");
TCHAR   gszKeyInitialDirOpen[]  = TEXT("InitialDirOpen");
TCHAR   gszKeyInitialDirSave[]  = TEXT("InitialDirSave");
TCHAR   gszKeyLastSaveFile[]    = TEXT("LastSaveFile");


//==========================================================================;
//
//  Application helper functions and rarely called stuff...
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD AppGetWindowsVersion
//
//  Description:
//      This function returns the version of Windows that the application
//      is running on plus some platform information.
//
//  Arguments:
//      PTSTR pach: Options pointer to buffer to receive text string of
//      the Windows version and platform.
//
//  Return (LRESULT):
//      The return value will be the version and platform information of
//      the current operating system in the following format:
//
//      0xPPPPMMRR where:
//
//      MM      :   major version of Windows
//      RR      :   minor version (revision) of Windows
//      PPPP    :   the platform the application is running on which
//                  will be one of the following:
//
//                  #ifdef WIN32
//                      the HIWORD() is RESERVED except for the high bit:
//                          high bit is 0 = Windows NT
//                          high bit is 1 = Win32s/Windows 3.1
//                  #else
//                      0xMMRR = Major and Minor version of [MS-]DOS
//                      GetWinFlags() & 0x8000 = Windows on OS/2 (WLO)
//                      GetWinFlags() & 0x4000 = Windows on Windows NT (WOW)
//                  #endif
//
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppGetWindowsVersion
(
    PTSTR                   pszEnvironment,
    PTSTR                   pszPlatform
)
{

    BYTE    bVerWinMajor;
    BYTE    bVerWinMinor;
    UINT    uVerEnv;
    DWORD   dw;
    LRESULT lr;

    dw = GetVersion();

    //
    //  massage the version information into something intelligent
    //
    //
    bVerWinMajor = LOBYTE(LOWORD(dw));
    bVerWinMinor = HIBYTE(LOWORD(dw));
    uVerEnv      = HIWORD(dw);
    lr = MAKELPARAM(((UINT)bVerWinMajor << 8) | bVerWinMinor, uVerEnv);

    //
    //  if caller wants the environment string version...
    //
    if (NULL != pszEnvironment)
    {
    //
    //
    //
#ifdef WIN32
{
    static TCHAR    szFormatVersion[]   = TEXT("%s Version %u.%.2u");
    static TCHAR    szEnvWinNT[]        = TEXT("Windows NT");
    static TCHAR    szEnvWin32s[]       = TEXT("Win32s");

    wsprintf(pszEnvironment, szFormatVersion,
             (LPSTR)((0x8000 & uVerEnv) ? szEnvWin32s : szEnvWinNT),
             bVerWinMajor, bVerWinMinor);
}
#else
{
#ifndef WF_WINNT
    #define WF_WINNT        0x4000
    #define WF_WLO          0x8000
#endif
#ifndef WF_CPUMASK
    #define WF_CPUMASK      0xFC000000
    #define WF_CPU_X86      0
    #define WF_CPU_R4000    1
    #define WF_CPU_ALPHA    2
    #define WF_CPU_CLIPPER  3
    #define WF_CPU_POWERPC  4
#endif

    static TCHAR    szFormatSubSys[]= TEXT("Windows Version %u.%.2u (%s%s)\n%s Subsystem, DOS Version %u.%.2u");
    static TCHAR    szFormatDOS[]   = TEXT("Windows Version %u.%.2u (%s%s)\nDOS Version %u.%.2u");
    static TCHAR    szSubSysWLO[]   = TEXT("WLO");
    static TCHAR    szSubSysWOW[]   = TEXT("WOW");
    static TCHAR    szModeEnhanced[]= TEXT("Enhanced");
    static TCHAR    szModeStandard[]= TEXT("Standard");
    static TCHAR    szEnvPaging[]   = TEXT(", Paging");

    DWORD   dwWinFlags;
    PTSTR   pszMode;

    BYTE    bVerEnvMajor    = HIBYTE(LOWORD(uVerEnv));
    BYTE    bVerEnvMinor    = LOBYTE(LOWORD(uVerEnv));

    dwWinFlags = GetWinFlags();

    pszMode = (dwWinFlags & WF_ENHANCED) ? szModeEnhanced : szModeStandard;
    if (dwWinFlags & (WF_WLO | WF_WINNT))
    {
        wsprintf(pszEnvironment, szFormatSubSys, bVerWinMajor, bVerWinMinor,
                 (LPSTR)pszMode,
                 (LPSTR)((dwWinFlags & WF_PAGING) ? szEnvPaging : gszNull),
                 (LPSTR)((dwWinFlags & WF_WINNT) ? szSubSysWOW : szSubSysWLO),
                 bVerEnvMajor, bVerEnvMinor);
    }
    else
    {
        wsprintf(pszEnvironment, szFormatDOS, bVerWinMajor, bVerWinMinor,
                 (LPSTR)pszMode,
                 (LPSTR)((dwWinFlags & WF_PAGING) ? szEnvPaging : gszNull),
                 bVerEnvMajor, bVerEnvMinor);
    }
}
#endif
    }

    //
    //  if caller wants the platform string version...
    //
    if (NULL != pszPlatform)
    {
#ifdef WIN32
{
    GetEnvironmentVariable(TEXT("PROCESSOR_IDENTIFIER"), pszPlatform, APP_MAX_STRING_RC_BYTES);
}
#else
{
    static TCHAR    szPlat286[]         = TEXT("80286");
    static TCHAR    szPlat386[]         = TEXT("80386");
    static TCHAR    szPlat486[]         = TEXT("i486");
    static TCHAR    szPlatR4000[]       = TEXT("MIPS R4000, Emulation: ");
    static TCHAR    szPlatAlpha21064[]  = TEXT("Alpha 21064, Emulation: ");
    static TCHAR    szPlatPPC[]         = TEXT("PowerPC, Emulation: ");
    static TCHAR    szPlatClipper[]     = TEXT("Clipper, Emulation: ");
    static TCHAR    szPlat80x87[]       = TEXT(", 80x87");

    DWORD   dwWinFlags;

    dwWinFlags = GetWinFlags();
    pszPlatform[0] = '\0';

    if (dwWinFlags & (WF_WLO | WF_WINNT))
    {
        switch ((dwWinFlags & WF_CPUMASK) >> 26)
        {
            case WF_CPU_X86:
                break;

            case WF_CPU_R4000:
                lstrcpy(pszPlatform, szPlatR4000);
                break;

            case WF_CPU_ALPHA:
                lstrcpy(pszPlatform, szPlatAlpha21064);
                break;

            case WF_CPU_POWPERPC:
                lstrcpy(pszPlatform, szPlatPPC);
                break;

            case WF_CPU_CLIPPER:
                lstrcpy(pszPlatform, szPlatClipper);
                break;
        }
    }

    if (dwWinFlags & WF_CPU286)
        lstrcat(pszPlatform, szPlat286);
    else if (dwWinFlags & WF_CPU386)
        lstrcat(pszPlatform, szPlat386);
    else if (dwWinFlags & WF_CPU486)
        lstrcat(pszPlatform, szPlat486);

    if (dwWinFlags & WF_80x87)
        lstrcat(pszPlatform, szPlat80x87);
}
#endif
    }

    //
    //  return the result
    //
    return (lr);
} // AppGetWindowsVersion()


//--------------------------------------------------------------------------;
//
//  LRESULT AppWinIniChange
//
//  Description:
//      This function is responsible for handling the WM_WININICHANGE
//      message. This message is sent when modifications have been made
//      to WIN.INI (from SystemParametersInfo() or other sources).
//
//      An application should re-enumerate system metrics (GetSystemMetrics)
//      and system color (GetSystemColors) information that it has cached.
//      Note that checking the section that was modified should be done if
//      some enumerations are time consuming.
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP
//      message.
//
//      LPCTSTR pszSection: Pointer to section name that has been modified
//      in WIN.INI. Note that this argument might be NULL (sent by apps
//      that were written incorrectly!). If it is NULL, then this application
//      should re-enumerate ALL metrics, colors, etc.
//
//  Return (LRESULT):
//      The return value is zero if the message is processed.
//
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppWinIniChange
(
    HWND                    hwnd,
    LPCTSTR                 pszSection
)
{
    DPF(1, "AppWinIniChanged(hwnd=%Xh, pszSection='%s')",
            hwnd, (NULL == pszSection) ? TEXT("(null)") : pszSection);

    //
    //  we processed the message...
    //
    return (0L);
} // AppWinIniChange()


//--------------------------------------------------------------------------;
//
//  HFONT AppChooseFont
//
//  Description:
//      This function is a wrapper for the ChooseFont() common dialog.
//      The purpose of this function is to let the user choose a font that
//      looks good to them--regardless of how bad it really looks.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for chooser dialog.
//
//      HFONT hfont: Handle to current font (default for chooser dialog).
//
//      PLOGFONT plf: Pointer to optional LOGFONT structure to receive a
//      copy of the LOGFONT information for the newly chosen font.
//
//  Return (HFONT):
//      The return value is the newly chosen font. If no new font was chosen
//      then the return value is NULL.
//
//
//--------------------------------------------------------------------------;

HFONT FNGLOBAL AppChooseFont
(
    HWND                    hwnd,
    HFONT                   hfont,
    PLOGFONT                plf
)
{
    LOGFONT             lf;
    CHOOSEFONT          cf;
    BOOL                f;
    HFONT               hfontNew;

    //
    //  get the font info for the current font...
    //
    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&lf);

    //
    //  fill in the choosefont structure
    //
    cf.lStructSize  = sizeof(CHOOSEFONT);
    cf.hwndOwner    = hwnd;
    cf.hDC          = NULL;
    cf.Flags        = CF_SCREENFONTS |
                      CF_INITTOLOGFONTSTRUCT |
                      CF_FIXEDPITCHONLY |
                      CF_FORCEFONTEXIST;
    cf.lCustData    = 0;
    cf.lpfnHook     = NULL;
    cf.hInstance    = NULL;
    cf.nFontType    = SCREEN_FONTTYPE;
    cf.lpLogFont    = (LPLOGFONT)&lf;

    //
    //  splash a dialog into the user's face..
    //
    hfontNew = NULL;
    f = ChooseFont(&cf);
    if (f)
    {
        //
        //  create the new font..
        //
        hfontNew = CreateFontIndirect(&lf);
        if (NULL == hfontNew)
            return (NULL);

        //
        //  copy the logfont structure if caller wants it
        //
        if (NULL != plf)
            *plf = lf;
    }

    //
    //  return the new font (if one was chosen)
    //
    return (hfontNew);
} // AppChooseFont()



//--------------------------------------------------------------------------;
//
//  BOOL AppProfileWriteBytes
//
//  Description:
//      This function writes a raw structure of bytes to the application's
//      ini section that can later be retrieved using AppProfileReadBytes.
//      This gives an application the ability to write any structure to
//      the ini file and restore it later--very useful.
//
//      NOTE! Starting with Windows for Workgroups 3.1 there are two new
//      profile functions that provide the same functionality of this
//      function. Specifically, these functions are GetPrivateProfileStruct
//      and WritePrivateProfileStruct. These new functions are provided
//      by the Common Controls DLL. The prototypes are as follows:
//
//      BOOL GetPrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      BOOL WritePrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      If you are building an application that is for Window for Workgroups
//      or newer versions of Windows, you will probably want to use the
//      above functions.
//
//  Arguments:
//      PTSTR pszSection: Pointer to section for the stored data.
//
//      PTSTR pszKey: Pointer to key name for the stored data.
//
//      LPBYTE pbStruct: Pointer to the data to be saved.
//
//      UINT cbStruct: Count in bytes of the data to store.
//
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if it fails.
//
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppProfileWriteBytes
(
    PTSTR                   pszSection,
    PTSTR                   pszKey,
    LPBYTE                  pbStruct,
    UINT                    cbStruct
)
{
    static TCHAR achNibbleToChar[] =
    {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
    };
    #define     NIBBLE2CHAR(x)      (achNibbleToChar[x])

    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    LPTSTR      psz;
    LPTSTR      pch;
    UINT        cchTemp;
    BOOL        fAllocated;
    BOOL        fReturn;
    BYTE        b;
    BYTE        bChecksum;

    //
    //  if pbStruct is NULL, then erase the key from the ini file, otherwise
    //  format the raw bytes into a hex string and write that out...
    //
    fAllocated = FALSE;
    psz        = NULL;
    if (NULL != pbStruct)
    {
        //
        //  check if the quick buffer can be used for formatting the output
        //  text--if it cannot, then alloc space for it. note that space
        //  must be available for an ending checksum byte (2 bytes for high
        //  and low nibble) as well as a null terminator.
        //
        psz     = (LPTSTR)ach;
        cchTemp = cbStruct * 2 + 3;
        if (cchTemp > SIZEOF(ach))
        {
            psz = (LPTSTR)GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR));
            if (NULL == psz)
                return (FALSE);

            fAllocated = TRUE;
        }

        //
        //  step through all bytes in the structure and convert it to
        //  a string of hex numbers...
        //
        bChecksum = 0;
        for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
        {
            //
            //  grab the next byte and add into checksum...
            //
            bChecksum += (b = *pbStruct);

            *pch++ = NIBBLE2CHAR((b >> (BYTE)4) & (BYTE)0x0F);
            *pch++ = NIBBLE2CHAR(b & (BYTE)0x0F);
        }

        //
        //  add the checksum byte to the end and null terminate the hex
        //  dumped string...
        //
        *pch++ = NIBBLE2CHAR((bChecksum >> (BYTE)4) & (BYTE)0x0F);
        *pch++ = NIBBLE2CHAR(bChecksum & (BYTE)0x0F);
        *pch   = '\0';
    }

    //
    //  write the string of hex bytes out to the ini file...
    //
    fReturn = WritePrivateProfileString(pszSection, pszKey, psz, gszAppProfile);

    //
    //  free the temporary buffer if one was allocated (lots of bytes!)
    //
    if (fAllocated)
        GlobalFreePtr(psz);

    return (fReturn);
} // AppProfileWriteBytes


//--------------------------------------------------------------------------;
//
//  BOOL AppProfileReadBytes
//
//  Description:
//      This function reads a previously stored structure of bytes from
//      the application's ini file. This data must have been written with
//      the AppProfileWriteBytes function--it is checksumed to keep bad
//      data from blowing up the application.
//
//      NOTE! Starting with Windows for Workgroups 3.1 there are two new
//      profile functions that provide the same functionality of this
//      function. Specifically, these functions are GetPrivateProfileStruct
//      and WritePrivateProfileStruct. These new functions are provided
//      by the Common Controls DLL. The prototypes are as follows:
//
//      BOOL GetPrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      BOOL WritePrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      If you are building an application that is for Window for Workgroups
//      or newer versions of Windows, you will probably want to use the
//      above functions.
//
//  Arguments:
//      PTSTR pszSection: Pointer to section that contains the data.
//
//      PTSTR pszKey: Pointer to key that contains the data.
//
//      LPBYTE pbStruct: Pointer to buffer to receive the data.
//
//      UINT cbStruct: Number of bytes expected.
//
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if the function fails (bad checksum, missing key, etc).
//
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppProfileReadBytes
(
    PTSTR                   pszSection,
    PTSTR                   pszKey,
    LPBYTE                  pbStruct,
    UINT                    cbStruct
)
{
    //
    //  note that the following works for both upper and lower case, and
    //  will return valid values for garbage chars
    //
    #define CHAR2NIBBLE(ch) (BYTE)( ((ch) >= '0' && (ch) <= '9') ?  \
                                (BYTE)((ch) - '0') :                \
                                ((BYTE)(10 + (ch) - 'A') & (BYTE)0x0F) )

    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    LPTSTR      psz;
    LPTSTR      pch;
    UINT        cchTemp;
    UINT        u;
    BOOL        fAllocated;
    BOOL        fReturn;
    BYTE        b;
    BYTE        bChecksum;
    TCHAR       ch;

    //
    //  add one the the number of bytes needed to accomodate the checksum
    //  byte placed at the end by AppProfileWriteBytes...
    //
    cbStruct++;

    //
    //  check if the quick buffer can be used for retrieving the input
    //  text--if it cannot, then alloc space for it. note that there must
    //  be space available for the null terminator (the +1 below).
    //
    fAllocated = FALSE;
    psz        = (LPTSTR)ach;
    cchTemp    = cbStruct * 2 + 1;
    if (cchTemp > SIZEOF(ach))
    {
        psz = (LPTSTR)GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR));
        if (NULL == psz)
            return (FALSE);

        fAllocated = TRUE;
    }

    //
    //  read the hex string... if it is not the correct length, then assume
    //  error and return.
    //
    fReturn = FALSE;
    u = (UINT)GetPrivateProfileString(pszSection, pszKey, gszNull,
                                      psz, cchTemp, gszAppProfile);
    if ((cbStruct * 2) == u)
    {
        bChecksum = 0;
        for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
        {
            ch = *pch++;
            b  = CHAR2NIBBLE(ch) << (BYTE)4;
            ch = *pch++;
            b |= CHAR2NIBBLE(ch);

            //
            //  if this is not the final byte (the checksum byte), then
            //  store it and accumulate checksum..
            //
            if (cbStruct != 1)
                bChecksum += (*pbStruct = b);
        }

        //
        //  check the last byte read against the checksum that we calculated
        //  if they are not equal then return error...
        //
        fReturn = (bChecksum == b);
    }


    //
    //  free the temporary buffer if one was allocated (lots of bytes!)
    //
    if (fAllocated)
        GlobalFreePtr(psz);

    return (fReturn);
} // AppProfileReadBytes


//==========================================================================;
//
//  Startup and shutdown code...
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL AcmAppChooseFont
//
//  Description:
//      This function lets the user choose a new font for the script window.
//      After a new font is chosen, the font structure is stored to the
//      .ini file so it can be restored on the next run of this application.
//
//  Arguments:
//      HWND hwnd: Handle to main window.
//
//  Return (BOOL):
//      The return value is TRUE if a new font was chosen. It is FALSE if
//      the user canceled the operation.
//
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppChooseFont
(
    HWND                    hwnd
)
{
    LOGFONT             lf;
    HWND                hedit;
    HFONT               hfont;
    HFONT               hfontNew;

    hedit = GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY);

    //
    //  get the current font and pass it to the choose font dialog
    //
    hfont = GetWindowFont(hedit);

    hfontNew = AppChooseFont(hwnd, hfont, &lf);
    if (NULL == hfontNew)
        return (FALSE);

    //
    //  select the new font into the window and delete the old one
    //
    SetWindowFont(hedit, hfontNew, TRUE);
    DeleteFont(hfont);

    ghfontApp = hfontNew;


    //
    //  save the complete description of the chosen font so there can be
    //  no strangness in the font mapping next run. this is overkill, but
    //  it works...
    //
    AppProfileWriteBytes(gszSecConfig, gszKeyFont, (LPBYTE)&lf, sizeof(lf));

    return (TRUE);
} // AcmAppChooseFont()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppSettingsRestore
//
//  Description:
//      This function restores state information for the application. This
//      function is called just after the main window is created (it has
//      not been ShowWindow()'d). This function will generate the call
//      to ShowWindow before returning.
//
//  Arguments:
//      HWND hwnd: Handle to main window that has just been created but
//      not shown.
//
//      int nCmdShow: The state that the application window should show as.
//
//  Return (BOOL):
//      The return value is always TRUE.
//
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppSettingsRestore
(
    HWND                    hwnd,
    int                     nCmdShow
)
{
    WINDOWPLACEMENT     wp;
    LOGFONT             lf;
    RECT                rc;
    RECT                rcWindow;
    POINT               pt;
    int                 n;
    BOOL                f;


    //
    //  restore the previous Options state...
    //
    gfuAppOptions = GetPrivateProfileInt(gszSecConfig, gszKeyOptions,
                                         gfuAppOptions, gszAppProfile);



    //
    //  restore the user's preferred font.
    //
    ghfontApp = GetStockFont(ANSI_FIXED_FONT);
    f = AppProfileReadBytes(gszSecConfig, gszKeyFont, (LPBYTE)&lf, sizeof(lf));
    if (f)
    {
        HFONT   hfont;

        hfont = CreateFontIndirect(&lf);
        if (NULL != hfont)
        {
            ghfontApp = hfont;
        }
    }

    SetWindowFont(GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY), ghfontApp, FALSE);


    //
    //
    //
    GetPrivateProfileString(gszSecConfig, gszKeyInitialDirOpen, gszNull,
                            gszInitialDirOpen, SIZEOF(gszInitialDirOpen),
                            gszAppProfile);

    GetPrivateProfileString(gszSecConfig, gszKeyInitialDirSave, gszNull,
                            gszInitialDirSave, SIZEOF(gszInitialDirSave),
                            gszAppProfile);

    GetPrivateProfileString(gszSecConfig, gszKeyLastSaveFile, gszNull,
                            gszLastSaveFile, SIZEOF(gszLastSaveFile),
                            gszAppProfile);


    //
    //  grab the stored window position and size from the .ini file...
    //  there must be four arguments stored or the entry is considered
    //  invalid.
    //
    f = AppProfileReadBytes(gszSecConfig, gszKeyWindow,
                            (LPBYTE)&rcWindow, sizeof(rcWindow));
    if (f)
    {
        //
        //  to make sure the user can always get at the window, check to
        //  see if the midpoint of the caption is visible--if it is not,
        //  then default to the default position used when creating the
        //  window.
        //
        n = (rcWindow.right - rcWindow.left) / 2;
        pt.x = (n + rcWindow.left);

        n = GetSystemMetrics(SM_CYCAPTION) / 2 + GetSystemMetrics(SM_CXFRAME);
        pt.y = (n + rcWindow.top);

        GetWindowRect(GetDesktopWindow(), &rc);
        if (PtInRect(&rc, pt))
        {
            //
            //  fill out the window placement structure--default the
            //  maximized and minimized states to default placement by
            //  getting its current placement.
            //
            wp.length = sizeof(wp);
            GetWindowPlacement(hwnd, &wp);

            wp.showCmd          = nCmdShow;
#if 0
            wp.rcNormalPosition = rcWindow;
#else
            n = rcWindow.right - rcWindow.left;
            wp.rcNormalPosition.right  = wp.rcNormalPosition.left + n;

            n = rcWindow.bottom - rcWindow.top;
            wp.rcNormalPosition.bottom = wp.rcNormalPosition.top + n;
#endif

            SetWindowPlacement(hwnd, &wp);
            return (TRUE);
        }
    }

    //
    //  show defaulted and succeed
    //
    ShowWindow(hwnd, nCmdShow);

    return (TRUE);
} // AcmAppSettingsRestore()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppSettingsSave
//
//  Description:
//      This function saves the current state information for the application.
//      It is called just before the main window is closed (destroyed); or
//      as Windows is exiting (query end session).
//
//      Note that this function should not destroy any resources--it can
//      be called at any time to save a snapshot of the application state.
//
//  Arguments:
//      HWND hwnd: Handle to main window that will be destroyed shortly.
//
//  Return (BOOL):
//      The return value is always TRUE.
//
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppSettingsSave
(
    HWND                    hwnd
)
{
    TCHAR               ach[APP_MAX_STRING_RC_CHARS];
    WINDOWPLACEMENT     wp;
    PRECT               prc;
    BOOL                f;

    //
    //  save the current option settings--note that we ALWAYS turn off the
    //  debug logging option so the app doesn't try to OutputDebugString
    //  unexpectedly during the next session...
    //
    gfuAppOptions &= ~APP_OPTIONSF_DEBUGLOG;
    if (GetPrivateProfileInt(gszSecConfig, gszKeyOptions, 0, gszAppProfile) != gfuAppOptions)
    {
        wsprintf(ach, gszFormatOptions, gfuAppOptions);
        WritePrivateProfileString(gszSecConfig, gszKeyOptions, ach, gszAppProfile);
    }


    //
    //
    //
    //
    WritePrivateProfileString(gszSecConfig, gszKeyInitialDirOpen,
                              gszInitialDirOpen, gszAppProfile);

    WritePrivateProfileString(gszSecConfig, gszKeyInitialDirSave,
                              gszInitialDirSave, gszAppProfile);

    WritePrivateProfileString(gszSecConfig, gszKeyLastSaveFile,
                              gszLastSaveFile, gszAppProfile);



    //
    //  save the current window placement--only store the size and location
    //  of the restored window. maximized and minimized states should
    //  remain defaulted on the next invocation of this application.
    //
    wp.length = sizeof(wp);
    f = GetWindowPlacement(hwnd, &wp);
    if (f)
    {
        prc = &wp.rcNormalPosition;


        //
        //  save the _bounding rectangle_ of the restored window state...
        //
        AppProfileWriteBytes(gszSecConfig, gszKeyWindow, (LPBYTE)prc, sizeof(*prc));
    }


    //
    //  succeed
    //
    return (TRUE);
} // AcmAppSettingsSave()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppShutdown
//
//  Description:
//      This function is called to gracefully shut down the application.
//      If the application should not be closed, a FALSE value is returned.
//      This function is called for WM_CLOSE and WM_QUERYENDSESSION
//      messages...
//
//  Arguments:
//      HWND hwnd: Handle to main window.
//
//      PACMAPPFILEDESC paafd: Pointer to current file description.
//
//  Return (BOOL):
//      Returns TRUE if the application can proceed with close. Returns
//      FALSE if the application should NOT be closed.
//
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppShutdown
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    BOOL                f;


    //
    //  check if the script has been modified without saving. if the user
    //  cancels the operation, then we will NOT close the application.
    //
    f = AcmAppFileSaveModified(hwnd, paafd);
    if (!f)
        return (FALSE);


    //
    //
    //
    if (NULL != ghadidNotify)
    {
        acmDriverRemove(ghadidNotify, 0L);
        ghadidNotify = NULL;
    }


    //
    //  save any settings that should be saved on app termination...
    //
    AcmAppSettingsSave(hwnd);


    //
    //  allow closing of application...
    //
    return (TRUE);
} // AcmAppShutdown()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppInit
//
//  Description:
//
//
//  Arguments:
//
//
//  Return (BOOL):
//
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppInit
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd,
    LPTSTR                  pszCmdLine,
    int                     nCmdShow
)
{
    BOOL                f;
    DWORD               dwVersion;


    //
    //  !!! VERY IMPORTANT !!!
    //
    //  the ACM may or may not be installed. this application is using
    //  the ACMTHUNK.C file to dynamically link to the ACM. if the
    //  acmThunkInitialize() API fails, then the ACM is *NOT* installed
    //  and none of the API's should be used.
    //
    //  if the ACM *is* installed, then the version MUST be at least
    //  V2.00 for the API's to be available (earlier versions do not
    //  supply the API we need).
    //
    acmThunkInitialize();

    dwVersion = acmGetVersion();
    if (0x0200 <= HIWORD(dwVersion))
    {
        MMRESULT        mmr;

        gfAcmAvailable = TRUE;

        mmr = acmDriverAdd(&ghadidNotify,
                            ghinst,
                            (LPARAM)(UINT)hwnd,
                            WM_ACMAPP_ACM_NOTIFY,
                            ACM_DRIVERADDF_NOTIFYHWND);
        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(0, "!AppCreate: acmDriverAdd failed to add notify window! mmr=%u", mmr);
        }
    }
    else
    {
        if (0L == dwVersion)
        {
            AppMsgBoxId(NULL, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL,
                        IDS_ERROR_ACM_NOT_PRESENT);
        }
        else
        {
            AppMsgBoxId(NULL, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL,
                        IDS_ERROR_ACM_TOO_OLD,
                        HIWORD(dwVersion) >> 8,
                        HIWORD(dwVersion) & 0x00FF);
        }

        gfAcmAvailable = FALSE;
    }


    //
    //
    //
    AcmAppSettingsRestore(hwnd, nCmdShow);

    //
    //  strip the command line..
    //
    if (NULL != pszCmdLine)
    {
        while (('\0' != *pszCmdLine) && (' ' == *pszCmdLine))
            pszCmdLine++;
    }

    //
    //  if there is a command line, assume it is a filename for a script
    //  and try to open it. otherwise, just initialize the script window.
    //
    if ((NULL != pszCmdLine) && ('\0' != *pszCmdLine))
    {
        //
        //  attempt to open the specified file..
        //
        lstrcpy(paafd->szFilePath, pszCmdLine);
        f = AcmAppFileOpen(hwnd, paafd);
        if (f)
        {
            AppTitle(hwnd, paafd->szFileTitle);
            AcmAppDisplayFileProperties(hwnd, paafd);
        }
        else
        {
            //
            //  opening the command line file was untriumphant..
            //
            AppMsgBoxId(hwnd, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL,
                        IDS_ERROR_OPEN_FAILED, (LPSTR)paafd->szFilePath);


            paafd->szFilePath[0]  = '\0';
            paafd->szFileTitle[0] = '\0';
            AppFileNew(hwnd, paafd, FALSE);
        }
    }
    else
    {
        AppFileNew(hwnd, paafd, FALSE);
    }

    return (TRUE);
} // AcmAppInit()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppExit
//
//  Description:
//
//
//  Arguments:
//
//
//  Return (BOOL):
//
//
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppExit
(
    void
)
{
    acmThunkTerminate();

    return (TRUE);
} // AcmAppExit()


//==========================================================================;
//
//  Initialization and exit code...
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL AppRegisterPenApp
//
//  Description:
//      This function is used to register and de-register an application
//      as being 'Pen Enhanced.' If the Windows installation is Pen enabled
//      then this function allows the RC Manager to replace all 'Edit'
//      controls with 'HEdit' controls.
//
//      This function must be called to register the application BEFORE
//      creating any edit controls.
//
//  Arguments:
//      BOOL fRegister: If this argument is TRUE, the app is registered
//      with the RC Manager as being Pen aware. If this argument is FALSE
//      the app is de-registered.
//
//  Return (BOOL):
//      The return value is TRUE if Windows for Pen Computing is installed
//      on the system. The return value is FALSE if the Windows installation
//      is not Pen enabled.
//
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL AppRegisterPenApp
(
    BOOL                    fRegister
)
{
    #define RPA_DEFAULT     0x0001

    typedef void (FAR PASCAL *PENWINREGISTERPROC)(UINT, BOOL);

    static char                 szRegPenApp[]   = "RegisterPenApp";
    static PENWINREGISTERPROC   pfnRegPenApp    = NULL;

    HINSTANCE   hinstPenWin;

    //
    //  check if Windows for Pen Computing is installed--and if it is,
    //  dyna-link to the RegisterPenApp() function.
    //
    //  if Pens are not supported, then return FALSE.
    //
    if (NULL == pfnRegPenApp)
    {
        hinstPenWin = (HINSTANCE)GetSystemMetrics(SM_PENWINDOWS);
        if (NULL == hinstPenWin)
            return (FALSE);

        pfnRegPenApp = (PENWINREGISTERPROC)GetProcAddress(hinstPenWin, szRegPenApp);
        if (NULL == pfnRegPenApp)
            return (FALSE);
    }

    //
    //  either enable or disable the RC Manager's Pen meathooks..
    //
    (*pfnRegPenApp)(RPA_DEFAULT, fRegister);

    return (TRUE);
} // AppRegisterPenApp()


//--------------------------------------------------------------------------;
//
//  LRESULT AppCreate
//
//  Description:
//      This function is called to handle the WM_CREATE message for the
//      applications window. The application should finish the creation
//      of the window (create controls, allocate resources, etc). The
//      window has not been displayed (CreateWindow[Ex] has not returned).
//
//  Arguments:
//      HWND hwnd: Handle to the window that is in the process of being
//      created.
//
//      LPCREATESTRUCT pcs: Pointer to a CREATESTRUCT that contains info
//      about the window being created.
//
//  Return (LRESULT):
//      The return value should be nonzero if the application wishes to
//      let the window finish being created. A return of zero tells
//      CreateWindow[Ex] to fail the creation of the window.
//
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppCreate
(
    HWND                    hwnd,
    LPCREATESTRUCT          pcs
)
{
    static TCHAR        szEdit[]    = TEXT("edit");

    HWND                hedit;

    DPF(1, "AppCreate(hwnd=%Xh, cs.x=%d, cs.y=%d, cs.cx=%d, cs.cy=%d)",
            hwnd, pcs->x, pcs->y, pcs->cx, pcs->cy);

    //
    //  create the driver selection listbox
    //
    hedit = CreateWindow(szEdit, gszNull,
                         ES_LEFT | ES_MULTILINE | WS_TABSTOP |
                         ES_AUTOVSCROLL | ES_AUTOHSCROLL |
                         ES_NOHIDESEL | WS_BORDER | WS_VSCROLL | WS_HSCROLL |
                         WS_VISIBLE | WS_CHILD | ES_READONLY,
                         0, 0, 0, 0, hwnd, (HMENU)IDD_ACMAPP_EDIT_DISPLAY,
                         pcs->hInstance, NULL);
    if (NULL == hedit)
        return (0L);


    //
    //  return nonzero to succeed the creation of the window
    //
    return (1L);
} // AppCreate()


//--------------------------------------------------------------------------;
//
//  LRESULT AppQueryEndSession
//
//  Description:
//      This function handles the WM_QUERYENDSESSION. This message is sent
//      by USER when ExitWindows has been called to end the Windows session.
//      This function can stop Windows from exiting if it is not convenient
//      for Windows to end.
//
//      Giving the user the option to save modified data before continueing
//      with the shutdown of Windows is a good idea.
//
//      Telling Windows to continue with the exit procedure does not
//      necessarily mean Windows will exit. All applications are queried
//      for shutdown approval. When the actual decision is made on whether
//      Windows will exit, WM_ENDSESSION will be sent with the result.
//
//  Arguments:
//      HWND hwnd: Handle to window that received the message.
//
//  Return (LRESULT):
//      Returns zero to STOP Windows from exiting. Returns non-zero to
//      allows windows to shut down.
//
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppQueryEndSession
(
    HWND                    hwnd
)
{
    BOOL                f;

    DPF(1, "AppQueryEndSession(hwnd=%Xh)", hwnd);

    //
    //  attempt to shut down--if this fails (user canceled it, etc) then
    //  do NOT allow the Windows to exit.
    //
    f = AcmAppShutdown(hwnd, &gaafd);
    if (!f)
        return (0L);


    //
    //  tell Windows to proceed with the shutdown process!
    //
    return (1L);
} // AppQueryEndSession()


//--------------------------------------------------------------------------;
//
//  LRESULT AppEndSession
//
//  Description:
//      This function is called to handle the WM_ENDSESSION message. This
//      message is generated after the application answers the
//      WM_QUERYENDSESSION message. The purpose of the WM_ENDSESSION
//      message is to tell the application if Windows will be exiting
//      (TRUE  == fEndSession) or the end session was canceled by an
//      application (FALSE == fEndSession).
//
//  Arguments:
//      HWND hwnd: Handle to window that received the message.
//
//      BOOL fEndSession: TRUE if Windows is exiting. FALSE if the end
//      session was canceled.
//
//  Return (LRESULT):
//      Returns zero if the message is processed. Note that an application
//      cannot halt the termination of Windows from this message--the
//      WM_QUERYENDSESSION is the only message that allows that behaviour.
//      If fEndSession is TRUE, Windows *WILL* exit--whether you like it
//      or not.
//
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppEndSession
(
    HWND                    hwnd,
    BOOL                    fEndSession
)
{
    DPF(1, "AppEndSession(hwnd=%Xh, fEndSession=%d)", hwnd, fEndSession);

    //
    //  we processed the message, return zero..
    //
    return (0L);
} // AppEndSession()


//--------------------------------------------------------------------------;
//
//  LRESULT AppClose
//
//  Description:
//      This function handles the WM_CLOSE message for the application.
//      If the application should close, DestroyWindow() must be called
//      by this function. Otherwise the application will not close.
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_CLOSE message.
//
//  Return (LRESULT):
//      There return value is zero. The DestroyWindow function will have
//      been called if the application should actually close.
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppClose
(
    HWND                    hwnd
)
{
    HWND                hedit;
    HFONT               hfont;
    BOOL                f;

    //
    //  if the Shift key is held down during the close message, then just
    //  save the current state but don't destroy the window... this is
    //  useful if the user does not want to exit the app and rerun it
    //  to make sure the state is saved--just before the user does something
    //  that may crash Windows or something..
    //
    if (GetKeyState(VK_SHIFT) < 0)
    {
        //
        //  save any settings that should be saved on app termination...
        //
        AcmAppSettingsSave(hwnd);
        return (0L);
    }

    //
    //  attempt to shut down--if this fails (user canceled it, etc) then
    //  do NOT allow the window to be destroyed.
    //
    f = AcmAppShutdown(hwnd, &gaafd);
    if (!f)
        return (0L);



    //
    //  destroy the font we are using... before deleting the font, select
    //  the system font back into the window so the font won't be 'in use'
    //  anymore.
    //
    hedit = GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY);

    hfont = GetWindowFont(hedit);
    SetWindowFont(hedit, NULL, FALSE);
    DeleteFont(hfont);

    ghfontApp = NULL;

    //
    //  make the window close and terminate the application
    //
    DestroyWindow(hwnd);

    return (0L);
} // AppClose()


//--------------------------------------------------------------------------;
//
//  BOOL AppInit
//
//  Description:
//      This function is called to initialize a new instance of the
//      application. We want to parse our command line, create our window,
//      allocate resources, etc.
//
//      The arguments passed to this function are exactly the same as
//      those passed to WinMain.
//
//  Arguments:
//      HINSTANCE hinst: Identifies the current instance of the
//      application.
//
//      HINSTANCE hinstPrev: Identifies the previous instance of the
//      application (NULL if first instance). For Win 32, this argument
//      is _always_ NULL.
//
//      LPTSTR pszCmdLine: Points to null-terminated unparsed command line.
//      If the application is compiled for Unicode, then this argument is
//      ignored.
//
//      int nCmdShow: How the main window for the application is to be
//      shown by default.
//
//  Return (HWND):
//      Returns the newly created handle to the applications main window.
//      This handle is NULL if something went wrong and tells the application
//      to exit immediately.
//
//
//--------------------------------------------------------------------------;

HWND FNGLOBAL AppInit
(
    HINSTANCE               hinst,
    HINSTANCE               hinstPrev,
    LPTSTR                  pszCmdLine,
    int                     nCmdShow
)
{
    HWND                hwnd;
    WNDCLASS            wc;

    DPF(1, "AppInit(hinst=%Xh, hinstPrev=%Xh, pszCmdLine='%s', nCmdShow=%d)",
            hinst, hinstPrev, pszCmdLine, nCmdShow);

    LoadString(hinst, IDS_APP_NAME, gszAppName, SIZEOF(gszAppName));
    LoadString(hinst, IDS_FILE_UNTITLED, gszFileUntitled, SIZEOF(gszFileUntitled));


    //
    //  determine whether a new window class needs to be registered for
    //  this application. for Win 16, this only needs to be done for the
    //  first instance of the application created. for Win 32, this must
    //  be done for EVERY instance of the application.
    //
    if (NULL == hinstPrev)
    {
        wc.style         = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc   = (WNDPROC)AppWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = hinst;
        wc.hIcon         = LoadIcon(hinst, ICON_APP);
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName  = MENU_APP;
        wc.lpszClassName = gszAppName;

        if (!RegisterClass(&wc))
            return (NULL);
    }


    //
    //  if Windows for Pen Computing is installed, then allow the RC
    //  Manager to replace all edit controls created from this point on
    //  with hedit controls
    //
    AppRegisterPenApp(TRUE);


    //
    //  create the application's main window
    //
    //  style bits available:
    //      WS_EX_ACCEPTFILES   :  will receive WM_DROPFILES messages
    //      WS_EX_DLGMODALFRAME :  creates window with double border
    //      WS_EX_NOPARENTNOTIFY:  won't receive WM_PARENTNOTIFY messages
    //      WS_EX_TOPMOST       :  puts window in topmost space
    //      WS_EX_TRANSPARENT   :  a very bizarre style indeed (Win 16 only)
    //
    hwnd = CreateWindowEx(WS_EX_ACCEPTFILES | WS_EX_NOPARENTNOTIFY,
                          gszAppName,
                          gszAppName,
                          WS_OVERLAPPEDWINDOW,
                          APP_WINDOW_XOFFSET,
                          APP_WINDOW_YOFFSET,
                          APP_WINDOW_WIDTH,
                          APP_WINDOW_HEIGHT,
                          NULL,
                          NULL,
                          hinst,
                          NULL);

    if (NULL == hwnd)
        return (NULL);


#ifdef UNICODE
    //
    //  GetCommandLine() returns a pointer to our command line. but this
    //  command line includes the complete command line used to launch
    //  the application--which is different than the pszCmdLine argument
    //  passed through WinMain()...
    //
    //  so, skip over the command name to get to the argument string
    //
    pszCmdLine = GetCommandLine();
    if (NULL != pszCmdLine)
    {
        while (('\0' != *pszCmdLine) && (' ' != *pszCmdLine++))
            ;
    }
#endif


    //
    //
    //
    //
    AcmAppInit(hwnd, &gaafd, pszCmdLine, nCmdShow);


    //
    //  finally, get the window displayed and return success
    //
    //  the ShowWindow call is made during AcmAppInit
    //
//  ShowWindow(hwnd, nCmdShow);
//  UpdateWindow(hwnd);

    return (hwnd);
} // AppInit()


//--------------------------------------------------------------------------;
//
//  int AppExit
//
//  Description:
//      This function is called just before the application exits from
//      WinMain. Its purpose is to clean up any resources that were allocated
//      for running the application: brushes, heaps, etc..
//
//  Arguments:
//      HINSTANCE hinst: Identifies the current instance of the
//      application that is exiting.
//
//      int nResult: The result of the WM_QUIT message (in wParam of the
//      MSG structure. This argument will usually be 0 (even if the message
//      loop was never entered).
//
//  Return (int):
//      The return value is usually nResult--be we give this function the
//      opportunity to modify its value.
//
//
//--------------------------------------------------------------------------;

int FNGLOBAL AppExit
(
    HINSTANCE               hinst,
    int                     nResult
)
{
    DPF(1, "AppExit(hinst=%Xh, nResult=%d)", hinst, nResult);

    AcmAppExit();

    //
    //  if Windows for Pen Computing is installed, then de-register the
    //  application so the RC Manager knows we will no longer need its
    //  services...
    //
    AppRegisterPenApp(FALSE);

    return (nResult);
} // AppExit()


//==========================================================================;
//
//  Misc rarely used application dialogs and stuff...
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL AboutDlgProc
//
//  Description:
//      This dialog procedure is used for the ubiquitous about box.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AboutDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    HWND                hwndT;
    PTSTR               pach;
    UINT                u;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            //
            //  display some OS version information
            //
            //
            pach = (PTSTR)LocalAlloc(LPTR, APP_MAX_STRING_RC_BYTES);
            if (NULL == pach)
                return (TRUE);

            AppGetWindowsVersion(pach, NULL);
            hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_OS);
            SetWindowText(hwndT, pach);

            AppGetWindowsVersion(NULL, pach);
            hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_PLATFORM);
            SetWindowText(hwndT, pach);

            LocalFree((HLOCAL)pach);

            return (TRUE);

        case WM_COMMAND:
            u = GET_WM_COMMAND_ID(wParam, lParam);
            if ((IDOK == u) || (IDCANCEL == u))
            {
                EndDialog(hwnd, (IDOK == u));
            }
            break;
    }

    return (FALSE);
} // AboutDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\aaprops.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//--------------------------------------------------------------------------;
//
//  aaprops.c
//
//  Description:
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>

#include <mmreg.h>
#include <msacm.h>

#include "muldiv32.h"

#include "appport.h"
#include "acmapp.h"

#include "debug.h"


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppGetErrorString
//  
//  Description:
//  
//  
//  Arguments:
//      MMRESULT mmr:
//  
//      PTSTR psz:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppGetErrorString
(
    MMRESULT                mmr,
    LPTSTR                  pszError
)
{
    PTSTR               psz;

    switch (mmr)
    {
        case MMSYSERR_NOERROR:
            psz = TEXT("MMSYSERR_NOERROR");
            break;

        case MMSYSERR_ERROR:
            psz = TEXT("MMSYSERR_ERROR");
            break;

        case MMSYSERR_BADDEVICEID:
            psz = TEXT("MMSYSERR_BADDEVICEID");
            break;

        case MMSYSERR_NOTENABLED:
            psz = TEXT("MMSYSERR_NOTENABLED");
            break;

        case MMSYSERR_ALLOCATED:
            psz = TEXT("MMSYSERR_ALLOCATED");
            break;

        case MMSYSERR_INVALHANDLE:
            psz = TEXT("MMSYSERR_INVALHANDLE");
            break;

        case MMSYSERR_NODRIVER:
            psz = TEXT("MMSYSERR_NODRIVER");
            break;

        case MMSYSERR_NOMEM:
            psz = TEXT("MMSYSERR_NOMEM");
            break;

        case MMSYSERR_NOTSUPPORTED:
            psz = TEXT("MMSYSERR_NOTSUPPORTED");
            break;

        case MMSYSERR_BADERRNUM:
            psz = TEXT("MMSYSERR_BADERRNUM");
            break;

        case MMSYSERR_INVALFLAG:
            psz = TEXT("MMSYSERR_INVALFLAG");
            break;

        case MMSYSERR_INVALPARAM:
            psz = TEXT("MMSYSERR_INVALPARAM");
            break;


        case WAVERR_BADFORMAT:
            psz = TEXT("WAVERR_BADFORMAT");
            break;

        case WAVERR_STILLPLAYING:
            psz = TEXT("WAVERR_STILLPLAYING");
            break;

        case WAVERR_UNPREPARED:
            psz = TEXT("WAVERR_UNPREPARED");
            break;

        case WAVERR_SYNC:
            psz = TEXT("WAVERR_SYNC");
            break;


        case ACMERR_NOTPOSSIBLE:
            psz = TEXT("ACMERR_NOTPOSSIBLE");
            break;

        case ACMERR_BUSY:
            psz = TEXT("ACMERR_BUSY");
            break;

        case ACMERR_UNPREPARED:
            psz = TEXT("ACMERR_UNPREPARED");
            break;

        case ACMERR_CANCELED:
            psz = TEXT("ACMERR_CANCELED");
            break;


        default:
            lstrcpy(pszError, TEXT("(unknown)"));
            return (FALSE);
    }

    lstrcpy(pszError, psz);
    return (TRUE);
} // AcmAppGetErrorString()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppGetFormatDescription
//  
//  Description:
//  
//  
//  Arguments:
//      LPWAVEFORMATEX pwfx:
//  
//      LPSTR pszFormatTag:
//  
//      LPSTR pszFormat:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

TCHAR   gszIntl[]           = TEXT("Intl");
TCHAR   gszIntlList[]       = TEXT("sList");
TCHAR   gszIntlDecimal[]    = TEXT("sDecimal");
TCHAR   gchIntlList         = ',';
TCHAR   gchIntlDecimal      = '.';

BOOL FNGLOBAL AcmAppGetFormatDescription
(
    LPWAVEFORMATEX          pwfx,
    LPTSTR                  pszFormatTag,
    LPTSTR                  pszFormat
)
{
    MMRESULT            mmr;
    BOOL                f;

    f = TRUE;

    //
    //  get the name for the format tag of the specified format
    //
    if (NULL != pszFormatTag)
    {
        ACMFORMATTAGDETAILS aftd;

        //
        //  initialize all unused members of the ACMFORMATTAGDETAILS
        //  structure to zero
        //
        memset(&aftd, 0, sizeof(aftd));

        //
        //  fill in the required members of the ACMFORMATTAGDETAILS
        //  structure for the ACM_FORMATTAGDETAILSF_FORMATTAG query
        //
        aftd.cbStruct    = sizeof(aftd);
        aftd.dwFormatTag = pwfx->wFormatTag;

        //
        //  ask the ACM to find the first available driver that
        //  supports the specified format tag
        //
        mmr = acmFormatTagDetails(NULL,
                                  &aftd,
                                  ACM_FORMATTAGDETAILSF_FORMATTAG);
        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  copy the format tag name into the caller's buffer
            //
            lstrcpy(pszFormatTag, aftd.szFormatTag);
        }
        else
        {
            PTSTR           psz;

            //
            //  no ACM driver is available that supports the
            //  specified format tag
            //

            f   = FALSE;
            psz = NULL;

            //
            //  the following stuff if proof that the world does NOT need
            //  yet another ADPCM algorithm!!
            //
            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                    psz = TEXT("** RESERVED INVALID TAG **");
                    break;

                case WAVE_FORMAT_PCM:
                    psz = TEXT("PCM");
                    break;

                case WAVE_FORMAT_ADPCM:
                    psz = TEXT("Microsoft ADPCM");
                    break;

                case 0x0003:
                    psz = TEXT("MV's *UNREGISTERED* ADPCM");
                    break;

                case WAVE_FORMAT_IBM_CVSD:
                    psz = TEXT("IBM CVSD");
                    break;

                case WAVE_FORMAT_ALAW:
                    psz = TEXT("A-Law");
                    break;

                case WAVE_FORMAT_MULAW:
                    psz = TEXT("u-Law");
                    break;

                case WAVE_FORMAT_OKI_ADPCM:
                    psz = TEXT("OKI ADPCM");
                    break;

                case WAVE_FORMAT_IMA_ADPCM:
                    psz = TEXT("IMA/DVI ADPCM");
                    break;

                case WAVE_FORMAT_DIGISTD:
                    psz = TEXT("DIGI STD");
                    break;

                case WAVE_FORMAT_DIGIFIX:
                    psz = TEXT("DIGI FIX");
                    break;

                case WAVE_FORMAT_YAMAHA_ADPCM:
                    psz = TEXT("Yamaha ADPCM");
                    break;

                case WAVE_FORMAT_SONARC:
                    psz = TEXT("Sonarc");
                    break;

                case WAVE_FORMAT_DSPGROUP_TRUESPEECH:
                    psz = TEXT("DSP Group TrueSpeech");
                    break;

                case WAVE_FORMAT_ECHOSC1:
                    psz = TEXT("Echo SC1");
                    break;

                case WAVE_FORMAT_AUDIOFILE_AF36:
                    psz = TEXT("Audiofile AF36");
                    break;

                case WAVE_FORMAT_CREATIVE_ADPCM:
                    psz = TEXT("Creative Labs ADPCM");
                    break;

                case WAVE_FORMAT_APTX:
                    psz = TEXT("APTX");
                    break;

                case WAVE_FORMAT_AUDIOFILE_AF10:
                    psz = TEXT("Audiofile AF10");
                    break;

                case WAVE_FORMAT_DOLBY_AC2:
                    psz = TEXT("Dolby AC2");
                    break;

                case WAVE_FORMAT_MEDIASPACE_ADPCM:
                    psz = TEXT("Media Space ADPCM");
                    break;

                case WAVE_FORMAT_SIERRA_ADPCM:
                    psz = TEXT("Sierra ADPCM");
                    break;

                case WAVE_FORMAT_G723_ADPCM:
                    psz = TEXT("CCITT G.723 ADPCM");
                    break;

                case WAVE_FORMAT_GSM610:
                    psz = TEXT("GSM 6.10");
                    break;

                case WAVE_FORMAT_G721_ADPCM:
                    psz = TEXT("CCITT G.721 ADPCM");
                    break;

                case WAVE_FORMAT_DEVELOPMENT:
                    psz = TEXT("** RESERVED DEVELOPMENT ONLY TAG **");
                    break;

                default:
                    wsprintf(pszFormatTag, TEXT("[%u] (unknown)"), pwfx->wFormatTag);
                    break;
            }

            if (NULL != psz)
            {
                lstrcpy(pszFormatTag, psz);
            }
        }
    }

    //
    //  get the description of the attributes for the specified
    //  format
    //
    if (NULL != pszFormat)
    {
        ACMFORMATDETAILS    afd;

        //
        //  initialize all unused members of the ACMFORMATDETAILS
        //  structure to zero
        //
        memset(&afd, 0, sizeof(afd));

        //
        //  fill in the required members of the ACMFORMATDETAILS
        //  structure for the ACM_FORMATDETAILSF_FORMAT query
        //
        afd.cbStruct    = sizeof(afd);
        afd.dwFormatTag = pwfx->wFormatTag;
        afd.pwfx        = pwfx;

        //
        //  the cbwfx member must be initialized to the total size
        //  in bytes needed for the specified format. for a PCM 
        //  format, the cbSize member of the WAVEFORMATEX structure
        //  is not valid.
        //
        if (WAVE_FORMAT_PCM == pwfx->wFormatTag)
        {
            afd.cbwfx   = sizeof(PCMWAVEFORMAT);
        }
        else
        {
            afd.cbwfx   = sizeof(WAVEFORMATEX) + pwfx->cbSize;
        }

        //
        //  ask the ACM to find the first available driver that
        //  supports the specified format
        //
        mmr = acmFormatDetails(NULL, &afd, ACM_FORMATDETAILSF_FORMAT);
        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  copy the format attributes description into the caller's
            //  buffer
            //
            lstrcpy(pszFormat, afd.szFormat);
        }
        else
        {
            TCHAR           ach[2];
            TCHAR           szChannels[24];
            UINT            cBits;

            //
            //  no ACM driver is available that supports the
            //  specified format
            //

            f = FALSE;

            //
            //
            //
            ach[0] = gchIntlList;
            ach[1] = '\0';

            GetProfileString(gszIntl, gszIntlList, ach, ach, sizeof(ach));
            gchIntlList = ach[0];

            ach[0] = gchIntlDecimal;
            ach[1] = '\0';

            GetProfileString(gszIntl, gszIntlDecimal, ach, ach, sizeof(ach));
            gchIntlDecimal = ach[0];


            //
            //  compute the bit depth--this _should_ be the same as
            //  wBitsPerSample, but isn't always...
            //
            cBits = (UINT)(pwfx->nAvgBytesPerSec * 8 /
                           pwfx->nSamplesPerSec /
                           pwfx->nChannels);

            if ((1 == pwfx->nChannels) || (2 == pwfx->nChannels))
            {
                if (1 == pwfx->nChannels)
                    lstrcpy(szChannels, TEXT("Mono"));
                else
                    lstrcpy(szChannels, TEXT("Stereo"));

                wsprintf(pszFormat, TEXT("%lu%c%.03u kHz%c %u Bit%c %s"),
                            pwfx->nSamplesPerSec / 1000,
                            gchIntlDecimal,
                            (UINT)(pwfx->nSamplesPerSec % 1000),
                            gchIntlList,
                            cBits,
                            gchIntlList,
                            (LPTSTR)szChannels);
            }
            else
            {
                wsprintf(pszFormat, TEXT("%lu%c%.03u kHz%c %u Bit%c %u Channels"),
                            pwfx->nSamplesPerSec / 1000,
                            gchIntlDecimal,
                            (UINT)(pwfx->nSamplesPerSec % 1000),
                            gchIntlList,
                            cBits,
                            gchIntlList,
                            pwfx->nChannels);
            }
        }
    }

    //
    //
    //
    return (f);
} // AcmAppGetFormatDescription()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppGetFilterDescription
//  
//  Description:
//  
//  
//  Arguments:
//      LPWAVEFILTER pwfltr:
//  
//      LPSTR pszFilterTag:
//  
//      LPSTR pszFilter:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppGetFilterDescription
(
    LPWAVEFILTER            pwfltr,
    LPTSTR                  pszFilterTag,
    LPTSTR                  pszFilter
)
{
    MMRESULT            mmr;
    BOOL                f;

    f = TRUE;

    //
    //  get the name for the filter tag of the specified filter
    //
    if (NULL != pszFilterTag)
    {
        ACMFILTERTAGDETAILS aftd;

        //
        //  initialize all unused members of the ACMFILTERTAGDETAILS
        //  structure to zero
        //
        memset(&aftd, 0, sizeof(aftd));

        //
        //  fill in the required members of the ACMFILTERTAGDETAILS
        //  structure for the ACM_FILTERTAGDETAILSF_FILTERTAG query
        //
        aftd.cbStruct    = sizeof(aftd);
        aftd.dwFilterTag = pwfltr->dwFilterTag;

        //
        //  ask the ACM to find the first available driver that
        //  supports the specified filter tag
        //
        mmr = acmFilterTagDetails(NULL,
                                  &aftd,
                                  ACM_FILTERTAGDETAILSF_FILTERTAG);
        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  copy the filter tag name into the caller's buffer
            //
            lstrcpy(pszFilterTag, aftd.szFilterTag);
        }
        else
        {
            PTSTR           psz;

            psz = NULL;
            f   = FALSE;

            //
            //  no ACM driver is available that supports the
            //  specified filter tag
            //
            switch (pwfltr->dwFilterTag)
            {
                case WAVE_FILTER_UNKNOWN:
                    psz = TEXT("** RESERVED INVALID TAG **");
                    break;

                case WAVE_FILTER_VOLUME:
                    psz = TEXT("Microsoft Volume Filter");
                    break;

                case WAVE_FILTER_ECHO:
                    psz = TEXT("Microsoft Echo Filter");
                    break;

                case WAVE_FILTER_DEVELOPMENT:
                    psz = TEXT("** RESERVED DEVELOPMENT ONLY TAG **");
                    break;

                default:
                    wsprintf(pszFilterTag, TEXT("[%lu] (unknown)"),pwfltr->dwFilterTag);
                    break;
            }

            if (NULL != psz)
            {
                lstrcpy(pszFilterTag, psz);
            }
        }
    }

    //
    //  get the description of the attributes for the specified
    //  filter
    //
    if (NULL != pszFilter)
    {
        ACMFILTERDETAILS    afd;

        //
        //  initialize all unused members of the ACMFILTERDETAILS
        //  structure to zero
        //
        memset(&afd, 0, sizeof(afd));

        //
        //  fill in the required members of the ACMFILTERDETAILS
        //  structure for the ACM_FILTERDETAILSF_FILTER query
        //
        afd.cbStruct    = sizeof(afd);
        afd.dwFilterTag = pwfltr->dwFilterTag;
        afd.pwfltr      = pwfltr;
        afd.cbwfltr     = pwfltr->cbStruct;

        //
        //  ask the ACM to find the first available driver that
        //  supports the specified filter
        //
        mmr = acmFilterDetails(NULL, &afd, ACM_FILTERDETAILSF_FILTER);
        if (MMSYSERR_NOERROR == mmr)
        {
            //
            //  copy the filter attributes description into the caller's
            //  buffer
            //
            lstrcpy(pszFilter, afd.szFilter);
        }
        else
        {
            //
            //  no ACM driver is available that supports the
            //  specified filter
            //
            f = FALSE;

            wsprintf(pszFilter, TEXT("Unknown Filter %lu, %.08lXh"),
                        pwfltr->dwFilterTag, pwfltr->fdwFilter);
        }
    }

    //
    //
    //
    return (f);
} // AcmAppGetFilterDescription()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDumpExtraHeaderData
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      LPWAVEFORMATEX pwfx:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppDumpExtraHeaderData
(
    HWND            hedit,
    LPWAVEFORMATEX  pwfx
)
{
    static TCHAR    szDisplayTitle[]  = TEXT("Offset Data Bytes");

    if ((WAVE_FORMAT_PCM == pwfx->wFormatTag) || (0 == pwfx->cbSize))
        return (TRUE);

    MEditPrintF(hedit, szDisplayTitle);
    MEditPrintF(hedit, TEXT("------ -----------------------------------------------"));


    //
    //  !!! this is really horrible code !!!
    //
{
    #define ACMAPP_DUMP_BYTES_PER_LINE  16

    UINT    u;
    UINT    v;

    for (u = 0; u < pwfx->cbSize; u += ACMAPP_DUMP_BYTES_PER_LINE)
    {
        MEditPrintF(hedit, TEXT("~0x%.04X"), u);

        for (v = 0; v < ACMAPP_DUMP_BYTES_PER_LINE; v++)
        {
            if ((u + v) >= pwfx->cbSize)
                break;

            MEditPrintF(hedit, TEXT("~ %.02X"), ((LPBYTE)(pwfx + 1))[u + v]);
        }

        MEditPrintF(hedit, gszNull);
    }

    #undef ACMAPP_DUMP_BYTES_PER_LINE
}

    return (TRUE);
} // AcmAppDumpExtraHeaderData()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDisplayFileProperties
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      PACMAPPFILEDESC paafd:
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AcmAppDisplayFileProperties
(
    HWND            hwnd,
    PACMAPPFILEDESC paafd
)
{
    static TCHAR    szInvalidWaveFile[] = TEXT("No File");
    static TCHAR    szDisplayTitle[]    = TEXT("[Wave File Format Properties]\r\n");

    MMRESULT        mmr;
    TCHAR           szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    TCHAR           ach[APP_MAX_STRING_CHARS];
    DWORD           dw;
    LPWAVEFORMATEX  pwfx;
    HWND            hedit;
    HMENU           hmenu;
    BOOL            fCanPlayRecord;
    BOOL            f;


    //
    //  clear the display
    //
    AppHourGlass(TRUE);

    hedit = GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY);
    SetWindowRedraw(hedit, FALSE);

    MEditPrintF(hedit, NULL);


    //
    //
    //
    MEditPrintF(hedit, szDisplayTitle);

    MEditPrintF(hedit, TEXT("%25s: %s"), (LPTSTR)TEXT("Title"), (LPTSTR)paafd->szFileTitle);
    MEditPrintF(hedit, TEXT("%25s: %s"), (LPTSTR)TEXT("Full Path"), (LPTSTR)paafd->szFilePath);

    AppFormatBigNumber(ach, paafd->cbFileSize);
    MEditPrintF(hedit, TEXT("%25s: %s bytes"), (LPTSTR)TEXT("Total File Size"), (LPTSTR)ach);

    AppFormatDosDateTime(ach, paafd->uDosChangeDate, paafd->uDosChangeTime);
    MEditPrintF(hedit, TEXT("%25s: %s"), (LPTSTR)TEXT("Last Change Date/Time"), (LPTSTR)ach);

    dw = paafd->fdwFileAttributes;
    MEditPrintF(hedit, TEXT("%25s: %c %c%c%c%c %c%c%c%c (%.08lXh)"),
                    (LPTSTR)TEXT("Attributes"),
                    (dw & FILE_ATTRIBUTE_TEMPORARY) ? 't' : '-',
                    (dw & FILE_ATTRIBUTE_NORMAL)    ? 'n' : '-',
                    (dw & 0x00000040)               ? '?' : '-',
                    (dw & FILE_ATTRIBUTE_ARCHIVE)   ? 'a' : '-',
                    (dw & FILE_ATTRIBUTE_DIRECTORY) ? 'd' : '-',
                    (dw & 0x00000008)               ? '?' : '-',
                    (dw & FILE_ATTRIBUTE_SYSTEM)    ? 's' : '-',
                    (dw & FILE_ATTRIBUTE_HIDDEN)    ? 'h' : '-',
                    (dw & FILE_ATTRIBUTE_READONLY)  ? 'r' : '-',
                    dw);


    pwfx = paafd->pwfx;
    if (NULL == pwfx)
    {
        fCanPlayRecord = FALSE;
        goto AA_Display_File_Properties_Exit;
    }


    //
    //
    //
    //
    f = AcmAppGetFormatDescription(pwfx, szFormatTag, ach);
    MEditPrintF(hedit, TEXT("\r\n%25s: %s%s"), (LPTSTR)TEXT("Format"),
                f ? (LPTSTR)gszNull : (LPTSTR)TEXT("*"),
                (LPTSTR)szFormatTag);
    MEditPrintF(hedit, TEXT("%25s: %s"), (LPTSTR)TEXT("Attributes"), (LPTSTR)ach);


    AppFormatBigNumber(ach, paafd->dwDataBytes);
    MEditPrintF(hedit, TEXT("\r\n%25s: %s bytes"), (LPTSTR)TEXT("Data Size"), (LPTSTR)ach);

    AppFormatBigNumber(ach, paafd->dwDataBytes / pwfx->nAvgBytesPerSec);
    dw = paafd->dwDataBytes % pwfx->nAvgBytesPerSec;
    dw = (dw * 1000) / pwfx->nAvgBytesPerSec;
    MEditPrintF(hedit, TEXT("%25s: %s.%.03lu seconds"), (LPTSTR)TEXT("Play Time (avg bytes)"), (LPTSTR)ach, dw);

    AppFormatBigNumber(ach, paafd->dwDataSamples);
    MEditPrintF(hedit, TEXT("%25s: %s"), (LPTSTR)TEXT("Total Samples"), (LPTSTR)ach);

    AppFormatBigNumber(ach, paafd->dwDataSamples / pwfx->nSamplesPerSec);
    dw = paafd->dwDataSamples % pwfx->nSamplesPerSec;
    dw = (dw * 1000) / pwfx->nSamplesPerSec;
    MEditPrintF(hedit, TEXT("%25s: %s.%.03lu seconds"), (LPTSTR)TEXT("Play Time (samples)"), (LPTSTR)ach, dw);

    //
    //
    //
    MEditPrintF(hedit, TEXT("\r\n%25s: %u"), (LPTSTR)TEXT("Format Tag"), pwfx->wFormatTag);
    MEditPrintF(hedit, TEXT("%25s: %u"), (LPTSTR)TEXT("Channels"), pwfx->nChannels);

    AppFormatBigNumber(ach, pwfx->nSamplesPerSec);
    MEditPrintF(hedit, TEXT("%25s: %s"), (LPTSTR)TEXT("Samples Per Second"), (LPTSTR)ach);

    AppFormatBigNumber(ach, pwfx->nAvgBytesPerSec);
    MEditPrintF(hedit, TEXT("%25s: %s"), (LPTSTR)TEXT("Avg Bytes Per Second"), (LPTSTR)ach);

    AppFormatBigNumber(ach, pwfx->nBlockAlign);
    MEditPrintF(hedit, TEXT("%25s: %s"), (LPTSTR)TEXT("Block Alignment"), (LPTSTR)ach);

    MEditPrintF(hedit, TEXT("%25s: %u"), (LPTSTR)TEXT("Bits Per Sample"), pwfx->wBitsPerSample);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        AppFormatBigNumber(ach, pwfx->cbSize);
        MEditPrintF(hedit, TEXT("%25s: %s bytes\r\n"), (LPTSTR)TEXT("Extra Format Information"), (LPTSTR)ach);

        AcmAppDumpExtraHeaderData(hedit, pwfx);
    }


    //
    //  note that we do NOT set the 'WAVE_ALLOWSYNC' bit on queries because
    //  the player/recorder dialog uses MCIWAVE--which cannot work with
    //  SYNC devices.
    //
    mmr = waveOutOpen(NULL,
                      guWaveOutId,
#if (WINVER < 0x0400)
                      (LPWAVEFORMAT)pwfx,
#else
                      pwfx,
#endif
                      0L, 0L, WAVE_FORMAT_QUERY);

    fCanPlayRecord = (MMSYSERR_NOERROR == mmr);

    if (!fCanPlayRecord)
    {
        //
        //  this situation can happen with the 'preferred' device settings
        //  for the Sound Mapper.
        //
        mmr = waveInOpen(NULL,
                         guWaveInId,
#if (WINVER < 0x0400)
                         (LPWAVEFORMAT)pwfx,
#else
                         pwfx,
#endif
                         0L, 0L, WAVE_FORMAT_QUERY);

        fCanPlayRecord = (MMSYSERR_NOERROR == mmr);
    }

AA_Display_File_Properties_Exit:

    hmenu = GetMenu(hwnd);
    EnableMenuItem(hmenu, IDM_PLAYRECORD,
                   MF_BYCOMMAND | (fCanPlayRecord ? MF_ENABLED : MF_GRAYED));
    DrawMenuBar(hwnd);

    Edit_SetSel(hedit, (WPARAM)0, (LPARAM)0);

    SetWindowRedraw(hedit, TRUE);
    AppHourGlass(FALSE);

    return (fCanPlayRecord);
} // AcmAppDisplayFileProperties()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\aawavdev.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  aawavdev.c
//
//  Description:
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>

#include <mmreg.h>
#include <msacm.h>

#include "appport.h"
#include "acmapp.h"

#include "debug.h"


//
//  WAVE[IN|OUT]CAPS
//
//
//
PTSTR gaszWaveInOutCapsFormats[32] =
{
    TEXT("8M11"),           // Bit 0    WAVE_FORMAT_1M08
    TEXT("8S11"),           // Bit 1    WAVE_FORMAT_1S08
    TEXT("16M11"),          // Bit 2    WAVE_FORMAT_1M16
    TEXT("16S11"),          // Bit 3    WAVE_FORMAT_1S16
    TEXT("8M22"),           // Bit 4    WAVE_FORMAT_2M08
    TEXT("8S22"),           // Bit 5    WAVE_FORMAT_2S08
    TEXT("16M22"),          // Bit 6    WAVE_FORMAT_2M16
    TEXT("16S22"),          // Bit 7    WAVE_FORMAT_2S16
    TEXT("8M44"),           // Bit 8    WAVE_FORMAT_4M08
    TEXT("8S44"),           // Bit 9    WAVE_FORMAT_4S08
    TEXT("16M44"),          // Bit 10   WAVE_FORMAT_4M16
    TEXT("16S44"),          // Bit 11   WAVE_FORMAT_4S16
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};

PTSTR gaszWaveOutCapsSupport[32] =
{
    TEXT("Pitch"),          // Bit 0    WAVECAPS_PITCH
    TEXT("Playback Rate"),  // Bit 1    WAVECAPS_PLAYBACKRATE
    TEXT("Volume"),         // Bit 2    WAVECAPS_VOLUME
    TEXT("L/R Volume"),     // Bit 3    WAVECAPS_LRVOLUME
    TEXT("Sync"),           // Bit 4    WAVECAPS_SYNC
    NULL,                   // Bit 5
    NULL,                   // Bit 6
    NULL,                   // Bit 7
    NULL,                   // Bit 8
    NULL,                   // Bit 9
    NULL,                   // Bit 10
    NULL,                   // Bit 11
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};




//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  MMRESULT AcmAppWaveInGetDevCaps
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uDevId:
//  
//      LPWAVEINCAPS pwic:
//  
//  Return (MMRESULT):
//  
//  
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL AcmAppWaveInGetDevCaps
(
    UINT                    uDevId,
    LPWAVEINCAPS            pwic
)
{
    MMRESULT            mmr;

    //
    //
    //
    mmr = waveInGetDevCaps(uDevId, pwic, sizeof(*pwic));
    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  because some people shipped drivers without testing.
        //
        pwic->szPname[SIZEOF(pwic->szPname) - 1] = '\0';
    }
    else
    {
        _fmemset(pwic, 0, sizeof(*pwic));

        if (MMSYSERR_BADDEVICEID == mmr)
        {
            return (mmr);
        }

        if (WAVE_MAPPER == uDevId)
        {
            lstrcpy(pwic->szPname, TEXT("Default Wave Input Mapper"));
        }
        else
        {
            wsprintf(pwic->szPname, TEXT("Bad Wave Input Device %u"), uDevId);
        }
    }

    return (MMSYSERR_NOERROR);
} // AcmAppWaveInGetDevCaps()


//--------------------------------------------------------------------------;
//  
//  MMRESULT AcmAppWaveOutGetDevCaps
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uDevId:
//  
//      LPWAVEOUTCAPS pwoc:
//  
//  Return (MMRESULT):
//  
//  
//--------------------------------------------------------------------------;

MMRESULT FNLOCAL AcmAppWaveOutGetDevCaps
(
    UINT                    uDevId,
    LPWAVEOUTCAPS           pwoc
)
{
    MMRESULT            mmr;

    //
    //
    //
    mmr = waveOutGetDevCaps(uDevId, pwoc, sizeof(*pwoc));
    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //  because some people shipped drivers without testing.
        //
        pwoc->szPname[SIZEOF(pwoc->szPname) - 1] = '\0';
    }
    else
    {
        _fmemset(pwoc, 0, sizeof(*pwoc));

        if (MMSYSERR_BADDEVICEID == mmr)
        {
            return (mmr);
        }

        if (WAVE_MAPPER == uDevId)
        {
            lstrcpy(pwoc->szPname, TEXT("Default Wave Output Mapper"));
        }
        else
        {
            wsprintf(pwoc->szPname, TEXT("Bad Wave Output Device %u"), uDevId);
        }
    }

    return (MMSYSERR_NOERROR);
} // AcmAppWaveOutGetDevCaps()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDisplayWaveInDevCaps
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      UINT uDevId:
//  
//      LPWAVEINCAPS pwic:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppDisplayWaveInDevCaps
(
    HWND                    hedit,
    UINT                    uDevId,
    LPWAVEINCAPS            pwic,
    LPWAVEFORMATEX          pwfx
)
{
    static TCHAR        szDisplayTitle[]    = TEXT("[Wave Input Device Capabilities]\r\n");
    TCHAR               ach[40];
    PTSTR               psz;
    UINT                u;
    UINT                v;
    DWORD               dw;

    SetWindowRedraw(hedit, FALSE);

    MEditPrintF(hedit, NULL);
    MEditPrintF(hedit, szDisplayTitle);

    //
    //
    //
    if (NULL != pwfx)
    {
        TCHAR           szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
        TCHAR           szFormat[ACMFORMATDETAILS_FORMAT_CHARS];
        MMRESULT        mmr;
        HWAVEIN         hwi;

        //
        //
        //
        AcmAppGetFormatDescription(pwfx, szFormatTag, szFormat);
        MEditPrintF(hedit, TEXT("%17s: %s"), (LPTSTR)TEXT("Format"), (LPTSTR)szFormatTag);
        MEditPrintF(hedit, TEXT("%17s: %s"), (LPTSTR)TEXT("Attributes"), (LPTSTR)szFormat);


        //
        //
        //
        MEditPrintF(hedit, TEXT("~%17s: "), (LPTSTR)TEXT("Recordable"));
        mmr = waveInOpen(&hwi, uDevId,
#if (WINVER < 0x0400)
                         (LPWAVEFORMAT)pwfx,
#else
                         pwfx,
#endif
                         0L, 0L, 0L);

        if (MMSYSERR_NOERROR == mmr)
        {
            MEditPrintF(hedit, gszYes);
            waveInClose(hwi);
            hwi = NULL;
        }
        else
        {
            AcmAppGetErrorString(mmr, ach);
            MEditPrintF(hedit, TEXT("%s, %s (%u)"), (LPTSTR)gszNo, (LPSTR)ach, mmr);
        }


        //
        //
        //
        MEditPrintF(hedit, TEXT("~%17s: "), (LPTSTR)TEXT("(Query)"));
        mmr = waveInOpen(NULL, uDevId,
#if (WINVER < 0x0400)
                         (LPWAVEFORMAT)pwfx,
#else
                         pwfx,
#endif
                         0L, 0L, WAVE_FORMAT_QUERY);

        if (MMSYSERR_NOERROR == mmr)
        {
            MEditPrintF(hedit, gszYes);
        }
        else
        {
            AcmAppGetErrorString(mmr, ach);
            MEditPrintF(hedit, TEXT("%s, %s (%u)"), (LPTSTR)gszNo, (LPSTR)ach, mmr);
        }


        MEditPrintF(hedit, gszNull);
    }

    //
    //
    //
    MEditPrintF(hedit, TEXT("%17s: %d"), (LPTSTR)TEXT("Device Id"), uDevId);

    MEditPrintF(hedit, TEXT("%17s: %u"), (LPTSTR)TEXT("Manufacturer Id"), pwic->wMid);
    MEditPrintF(hedit, TEXT("%17s: %u"), (LPTSTR)TEXT("Product Id"), pwic->wPid);
    MEditPrintF(hedit, TEXT("%17s: %u.%.02u"), (LPTSTR)TEXT("Driver Version"),
                (pwic->vDriverVersion >> 8),
                (pwic->vDriverVersion & 0x00FF));
    MEditPrintF(hedit, TEXT("%17s: '%s'"), (LPTSTR)TEXT("Device Name"), (LPTSTR)pwic->szPname);
    MEditPrintF(hedit, TEXT("%17s: %u"), (LPTSTR)TEXT("Channels"), pwic->wChannels);


    //
    //
    //
    //
    MEditPrintF(hedit, TEXT("%17s: %.08lXh"), (LPTSTR)TEXT("Standard Formats"), pwic->dwFormats);
    for (v = u = 0, dw = pwic->dwFormats; (0L != dw); u++)
    {
        if ((BYTE)dw & (BYTE)1)
        {
            psz = gaszWaveInOutCapsFormats[u];
            if (NULL == psz)
            {
                wsprintf(ach, TEXT("Unknown%u"), u);
                psz = ach;
            }

            if (0 == (v % 4))
            {
                if (v != 0)
                {
                    MEditPrintF(hedit, gszNull);
                }
                MEditPrintF(hedit, TEXT("~%19s%s"), (LPTSTR)gszNull, (LPTSTR)psz);
            }
            else
            {
                MEditPrintF(hedit, TEXT("~, %s"), (LPTSTR)psz);
            }

            v++;
        }

        dw >>= 1;
    }
    MEditPrintF(hedit, gszNull);

    SetWindowRedraw(hedit, TRUE);

    return (TRUE);
} // AcmAppDisplayWaveInDevCaps()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppDisplayWaveOutDevCaps
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      UINT uDevId:
//  
//      LPWAVEOUTCAPS pwoc:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL AcmAppDisplayWaveOutDevCaps
(
    HWND                    hedit,
    UINT                    uDevId,
    LPWAVEOUTCAPS           pwoc,
    LPWAVEFORMATEX          pwfx
)
{
    static TCHAR    szDisplayTitle[]    = TEXT("[Wave Output Device Capabilities]\r\n");
    TCHAR           ach[40];
    PTSTR           psz;
    UINT            u;
    UINT            v;
    DWORD           dw;

    SetWindowRedraw(hedit, FALSE);

    //
    //
    //
    MEditPrintF(hedit, NULL);
    MEditPrintF(hedit, szDisplayTitle);



    //
    //
    //
    if (NULL != pwfx)
    {
        TCHAR           szFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
        TCHAR           szFormat[ACMFORMATDETAILS_FORMAT_CHARS];
        MMRESULT        mmr;
        HWAVEOUT        hwo;
        DWORD           fdwOpen;

        fdwOpen = (0 != (WAVECAPS_SYNC & pwoc->dwSupport)) ? 0L : WAVE_ALLOWSYNC;

        //
        //
        //
        AcmAppGetFormatDescription(pwfx, szFormatTag, szFormat);
        MEditPrintF(hedit, TEXT("%17s: %s"), (LPTSTR)TEXT("Format"), (LPTSTR)szFormatTag);
        MEditPrintF(hedit, TEXT("%17s: %s"), (LPTSTR)TEXT("Attributes"), (LPTSTR)szFormat);


        //
        //
        //
        MEditPrintF(hedit, TEXT("~%17s: "), (LPTSTR)TEXT("Playable"));
        mmr = waveOutOpen(&hwo, uDevId,
#if (WINVER < 0x0400)
                          (LPWAVEFORMAT)pwfx,
#else
                          pwfx,
#endif
                          0L, 0L, fdwOpen);

        if (MMSYSERR_NOERROR == mmr)
        {
            MEditPrintF(hedit, gszYes);
            waveOutClose(hwo);
            hwo = NULL;
        }
        else
        {
            AcmAppGetErrorString(mmr, ach);
            MEditPrintF(hedit, TEXT("%s, %s (%u)"), (LPTSTR)gszNo, (LPSTR)ach, mmr);
        }

        //
        //
        //
        MEditPrintF(hedit, TEXT("~%17s: "), (LPTSTR)TEXT("(Query)"));
        mmr = waveOutOpen(NULL, uDevId,
#if (WINVER < 0x0400)
                          (LPWAVEFORMAT)pwfx,
#else
                          pwfx,
#endif
                          0L, 0L, fdwOpen | WAVE_FORMAT_QUERY);

        if (MMSYSERR_NOERROR == mmr)
        {
            MEditPrintF(hedit, gszYes);
        }
        else
        {
            AcmAppGetErrorString(mmr, ach);
            MEditPrintF(hedit, TEXT("%s, %s (%u)"), (LPTSTR)gszNo, (LPSTR)ach, mmr);
        }

        MEditPrintF(hedit, gszNull);
    }



    MEditPrintF(hedit, TEXT("%17s: %d"), (LPTSTR)TEXT("Device Id"), uDevId);

    MEditPrintF(hedit, TEXT("%17s: %u"), (LPTSTR)TEXT("Manufacturer Id"), pwoc->wMid);
    MEditPrintF(hedit, TEXT("%17s: %u"), (LPTSTR)TEXT("Product Id"), pwoc->wPid);
    MEditPrintF(hedit, TEXT("%17s: %u.%.02u"), (LPTSTR)TEXT("Driver Version"),
                (pwoc->vDriverVersion >> 8),
                (pwoc->vDriverVersion & 0x00FF));
    MEditPrintF(hedit, TEXT("%17s: '%s'"), (LPTSTR)TEXT("Device Name"), (LPTSTR)pwoc->szPname);
    MEditPrintF(hedit, TEXT("%17s: %u"), (LPTSTR)TEXT("Channels"), pwoc->wChannels);



    //
    //
    //
    //
    MEditPrintF(hedit, TEXT("%17s: %.08lXh"), (LPTSTR)TEXT("Standard Formats"), pwoc->dwFormats);
    for (v = u = 0, dw = pwoc->dwFormats; (0L != dw); u++)
    {
        if ((BYTE)dw & (BYTE)1)
        {
            psz = gaszWaveInOutCapsFormats[u];
            if (NULL == psz)
            {
                wsprintf(ach, TEXT("Unknown%u"), u);
                psz = ach;
            }

            if (0 == (v % 4))
            {
                if (v != 0)
                {
                    MEditPrintF(hedit, gszNull);
                }
                MEditPrintF(hedit, TEXT("~%19s%s"), (LPTSTR)gszNull, (LPTSTR)psz);
            }
            else
            {
                MEditPrintF(hedit, TEXT("~, %s"), (LPTSTR)psz);
            }

            v++;
        }

        dw >>= 1;
    }
    MEditPrintF(hedit, gszNull);

    //
    //
    //
    //
    MEditPrintF(hedit, TEXT("%17s: %.08lXh"), (LPTSTR)TEXT("Standard Support"), pwoc->dwSupport);
    for (v = u = 0, dw = pwoc->dwSupport; dw; u++)
    {
        if ((BYTE)dw & (BYTE)1)
        {
            psz = gaszWaveOutCapsSupport[u];
            if (NULL == psz)
            {
                wsprintf(ach, TEXT("Unknown%u"), u);
                psz = ach;
            }

            if (0 == (v % 4))
            {
                if (v != 0)
                {
                    MEditPrintF(hedit, gszNull);
                }
                MEditPrintF(hedit, TEXT("~%19s%s"), (LPTSTR)gszNull, (LPTSTR)psz);
            }
            else
            {
                MEditPrintF(hedit, TEXT("~, %s"), (LPTSTR)psz);
            }

            v++;
        }

        dw >>= 1;
    }
    MEditPrintF(hedit, gszNull);

    SetWindowRedraw(hedit, TRUE);

    return (TRUE);
} // AcmAppDisplayWaveOutDevCaps()


//--------------------------------------------------------------------------;
//  
//  BOOL AcmAppWaveDeviceDlgProc
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      UINT uMsg:
//  
//      WPARAM wParam:
//  
//      LPARAM lParam:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppWaveDeviceDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    LONG                lDevice;
    BOOL                fInput;
    UINT                uDevId;

    UINT                cWaveDevs;
    UINT                u;
    UINT                uId;
    UINT                uCmd;
    HWND                hcb;
    HWND                hedit;
    HFONT               hfont;

    WAVEINCAPS          wic;
    WAVEOUTCAPS         woc;

    lDevice = GetWindowLong(hwnd, DWL_USER);
    uDevId  = (UINT)(int)(short)LOWORD(lDevice);
    fInput  = (BOOL)HIWORD(lDevice);

    //
    //
    //
    switch (uMsg)
    {
        case WM_INITDIALOG:
//          hfont = GetStockFont(ANSI_FIXED_FONT);
            hfont = ghfontApp;
            hedit = GetDlgItem(hwnd, IDD_AAWAVEDEVICE_EDIT_CAPABILITIES);
            SetWindowFont(hedit, hfont, FALSE);

            uDevId = (UINT)(int)(short)LOWORD(lParam);
            fInput = (BOOL)HIWORD(lParam);
            SetWindowLong(hwnd, DWL_USER, lParam);


            //
            //
            //
            hcb = GetDlgItem(hwnd, IDD_AAWAVEDEVICE_COMBO_DEVICE);
            SetWindowFont(hcb, hfont, FALSE);

            if (fInput)
                cWaveDevs = waveInGetNumDevs() + 1;
            else
                cWaveDevs = waveOutGetNumDevs() + 1;

            for (u = (UINT)WAVE_MAPPER; (0 != cWaveDevs); u++, cWaveDevs--)
            {
                if (fInput)
                {
                    AcmAppWaveInGetDevCaps(u, &wic);
                    ComboBox_AddString(hcb, wic.szPname);
                }
                else
                {
                    AcmAppWaveOutGetDevCaps(u, &woc);
                    ComboBox_AddString(hcb, woc.szPname);
                }

                if (uDevId == u)
                {
                    hedit = GetDlgItem(hwnd, IDD_AAWAVEDEVICE_EDIT_CAPABILITIES);

                    if (fInput)
                        AcmAppDisplayWaveInDevCaps(hedit, uDevId, &wic, gaafd.pwfx);
                    else
                        AcmAppDisplayWaveOutDevCaps(hedit, uDevId, &woc, gaafd.pwfx);
                }
            }

            ComboBox_SetCurSel(hcb, uDevId + 1);
            return (TRUE);


        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);

            switch (uId)
            {
                case IDOK:
                    hcb    = GetDlgItem(hwnd, IDD_AAWAVEDEVICE_COMBO_DEVICE);
                    uDevId = ComboBox_GetCurSel(hcb);
                    if (CB_ERR != uDevId)
                    {
                        EndDialog(hwnd, uDevId - 1);
                        break;
                    }

                    // -- fall through -- //
                    
                case IDCANCEL:
                    EndDialog(hwnd, uDevId);
                    break;
                    

                case IDD_AAWAVEDEVICE_COMBO_DEVICE:
                    uCmd = GET_WM_COMMAND_CMD(wParam, lParam);
                    hcb  = GET_WM_COMMAND_HWND(wParam, lParam);
                    switch (uCmd)
                    {
                        case CBN_SELCHANGE:
                            uDevId = ComboBox_GetCurSel(hcb);
                            if (CB_ERR == uDevId)
                                break;

                            uDevId--;

                            hedit = GetDlgItem(hwnd, IDD_AAWAVEDEVICE_EDIT_CAPABILITIES);
                            if (fInput)
                            {
                                AcmAppWaveInGetDevCaps(uDevId, &wic);
                                AcmAppDisplayWaveInDevCaps(hedit, uDevId, &wic, gaafd.pwfx);
                            }
                            else
                            {
                                AcmAppWaveOutGetDevCaps(uDevId, &woc);
                                AcmAppDisplayWaveOutDevCaps(hedit, uDevId, &woc, gaafd.pwfx);
                            }
                            break;
                    }
            }
            return (TRUE);
    }

    return (FALSE);
} // AcmAppWaveDeviceDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\acmapp.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  acmapp.h
//
//  Description:
//      This is a sample application that demonstrates how to use the 
//      Audio Compression Manager API's in Windows. This application is
//      also useful as an ACM CODEC driver test.
//
//
//==========================================================================;

#ifndef _INC_ACMAPP
#define _INC_ACMAPP                 // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Application Version Information:
//
//
//
//
//  NOTE! all string resources that will be used in app.rcv for the
//  version resource information *MUST* have an explicit \0 terminator!
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define APP_VERSION_MAJOR           1
#define APP_VERSION_MINOR           0
#define APP_VERSION_BUILD           0
#ifdef UNICODE
#define APP_VERSION_STRING_RC       "Version 1.00 (Unicode Enabled)\0"
#else
#define APP_VERSION_STRING_RC       "Version 1.00\0"
#endif

#ifdef WIN32
#define APP_VERSION_NAME_RC         "acmapp32.exe\0"
#else
#define APP_VERSION_NAME_RC         "acmapp16.exe\0"
#endif
#define APP_VERSION_BYLINE_RC       "\0"
#define APP_VERSION_COMPANYNAME_RC  "Microsoft Corporation\0"
#define APP_VERSION_COPYRIGHT_RC    "Copyright \251 Microsoft Corp. 1992-1993\0"

#ifdef WIN32
#if (defined(_X86_)) || (defined(i386))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT Sample Application (i386)\0"
#endif
#if (defined(_MIPS_)) || (defined(MIPS))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT Sample Application (MIPS)\0"
#endif
#if (defined(_ALPHA_)) || (defined(ALPHA))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT Sample Application (Alpha)\0"
#endif
#if (defined(_PPC_)) || (defined(PPC))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT Sample Application (PowerPC)\0"
#endif
#ifndef APP_VERSION_PRODUCTNAME_RC
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT Sample Application\0"
#endif
#else
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows Sample Application\0"
#endif

#ifdef DEBUG
#define APP_VERSION_DESCRIPTION_RC  "Microsoft ACM Sample Application (debug)\0"
#else
#define APP_VERSION_DESCRIPTION_RC  "Microsoft ACM Sample Application\0"
#endif


//
//  Unicode versions (if UNICODE is defined)... the resource compiler
//  cannot deal with the TEXT() macro.
//
#define APP_VERSION_STRING          TEXT(APP_VERSION_STRING_RC)
#define APP_VERSION_NAME            TEXT(APP_VERSION_NAME_RC)
#define APP_VERSION_BYLINE          TEXT(APP_VERSION_BYLINE_RC)
#define APP_VERSION_COMPANYNAME     TEXT(APP_VERSION_COMPANYNAME_RC)
#define APP_VERSION_COPYRIGHT       TEXT(APP_VERSION_COPYRIGHT_RC)
#define APP_VERSION_PRODUCTNAME     TEXT(APP_VERSION_PRODUCTNAME_RC)
#define APP_VERSION_DESCRIPTION     TEXT(APP_VERSION_DESCRIPTION_RC)


//
//
//
#ifndef SIZEOF_WAVEFORMATEX
#define SIZEOF_WAVEFORMATEX(pwfx)   ((WAVE_FORMAT_PCM==(pwfx)->wFormatTag)?sizeof(PCMWAVEFORMAT):(sizeof(WAVEFORMATEX)+(pwfx)->cbSize))
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//  misc. defines
//
#define APP_MAX_APP_NAME_CHARS      30
#define APP_MAX_APP_NAME_BYTES      (APP_MAX_APP_NAME_CHARS * sizeof(TCHAR))
#define APP_MAX_STRING_RC_CHARS     512
#define APP_MAX_STRING_RC_BYTES     (APP_MAX_STRING_RC_CHARS * sizeof(TCHAR))
#define APP_MAX_STRING_ERROR_CHARS  512
#define APP_MAX_STRING_ERROR_BYTES  (APP_MAX_STRING_ERROR_CHARS * sizeof(TCHAR))

#define APP_MAX_STRING_CHARS        128
#define APP_MAX_STRING_BYTES        (APP_MAX_STRING_CHARS * sizeof(TCHAR))
#define APP_MAX_NUMBER_CHARS        144
#define APP_MAX_NUMBER_BYTES        (APP_MAX_NUMBER_CHARS * sizeof(TCHAR))

#define APP_MAX_FILE_PATH_CHARS     144
#define APP_MAX_FILE_PATH_BYTES     (APP_MAX_FILE_PATH_CHARS * sizeof(TCHAR))
#define APP_MAX_FILE_TITLE_CHARS    16
#define APP_MAX_FILE_TITLE_BYTES    (APP_MAX_FILE_TITLE_CHARS * sizeof(TCHAR))

#define APP_MAX_STRING_INT_CHARS    18
#define APP_MAX_STRING_INT_BYTES    (APP_MAX_STRING_INT_CHARS * sizeof(TCHAR))

#define APP_MAX_EXT_DEFAULT_CHARS   4
#define APP_MAX_EXT_DEFAULT_BYTES   (APP_MAX_EXT_DEFAULT_CHARS * sizeof(TCHAR))
#define APP_MAX_EXT_FILTER_CHARS    256
#define APP_MAX_EXT_FILTER_BYTES    (APP_MAX_EXT_FILTER_CHARS * sizeof(TCHAR))

#define APP_WINDOW_XOFFSET          CW_USEDEFAULT
#define APP_WINDOW_YOFFSET          CW_USEDEFAULT
#define APP_WINDOW_WIDTH            460             // CW_USEDEFAULT
#define APP_WINDOW_HEIGHT           400             // CW_USEDEFAULT


//
//  resource defines...
//
#define ICON_APP                    RCID(10)
#define ACCEL_APP                   RCID(15)


//
//  the application menu...
//
//  NOTE! for our Edit menu, we use the following defines from windows.h--
//  so don't reuse these defines for menu items!
//
//      #define WM_CUT      0x0300
//      #define WM_COPY     0x0301
//      #define WM_PASTE    0x0302
//      #define WM_CLEAR    0x0303
//      #define WM_UNDO     0x0304
//
#define MENU_APP                        RCID(20)
#define APP_MENU_ITEM_FILE              0
#define IDM_FILE_NEW                    1100
#define IDM_FILE_OPEN                   1101
#define IDM_FILE_SAVE                   1102
#define IDM_FILE_SAVEAS                 1103
#define IDM_FILE_SNDPLAYSOUND_PLAY      1104
#define IDM_FILE_SNDPLAYSOUND_STOP      1105
#define IDM_FILE_CONVERT                1106
#define IDM_FILE_ABOUT                  1109
#define IDM_FILE_EXIT                   1110

#define APP_MENU_ITEM_EDIT              1
#define IDM_EDIT_SELECTALL              1200

#define APP_MENU_ITEM_VIEW              2
#define IDM_VIEW_SYSTEMINFO             1300
#define IDM_VIEW_ACM_DRIVERS            1301

#define APP_MENU_ITEM_PLAYER            3
#define IDM_PLAYRECORD                  1400

#define APP_MENU_ITEM_OPTIONS           4
#define IDM_OPTIONS_WAVEINDEVICE        1500
#define IDM_OPTIONS_WAVEOUTDEVICE       1501
#define IDM_OPTIONS_AUTOOPEN            1505
#define IDM_OPTIONS_DEBUGLOG            1506
#define IDM_OPTIONS_FONT                1509

#define IDM_UPDATE                      1600


//
//  the main window control id's...
//
#define IDD_ACMAPP_EDIT_DISPLAY                 200


//
//  misc dlg boxes...
//
#define DLG_ABOUT                               RCID(50)
#define IDD_ABOUT_VERSION_OS                    100
#define IDD_ABOUT_VERSION_PLATFORM              101

#define DLG_AADRAGDROP                          RCID(55)

#define DLG_AADETAILS                           RCID(70)
#define IDD_AADETAILS_EDIT_DETAILS              100

#define DLG_AADRIVERS                           RCID(75)
#define IDD_AADRIVERS_STATIC_POSITION           100
#define IDD_AADRIVERS_LIST_DRIVERS              101
#define IDD_AADRIVERS_BTN_DETAILS               102
#define IDD_AADRIVERS_BTN_FORMATS               103
#define IDD_AADRIVERS_BTN_FILTERS               104
#define IDD_AADRIVERS_BTN_ABOUT                 105
#define IDD_AADRIVERS_BTN_CONFIG                106
#define IDD_AADRIVERS_BTN_ABLE                  107
#define IDD_AADRIVERS_BTN_TOTOP                 108

#define DLG_AADRIVERFORMATS                     RCID(80)
#define IDD_AADRIVERFORMATS_STATIC_POSITION     100
#define IDD_AADRIVERFORMATS_LIST_FORMATS        101
#define IDD_AADRIVERFORMATS_BTN_DETAILS         102


#define DLG_AAWAVEDEVICE                        RCID(85)
#define IDD_AAWAVEDEVICE_COMBO_DEVICE           100
#define IDD_AAWAVEDEVICE_EDIT_CAPABILITIES      101


#define DLG_AACHOOSER                           RCID(90)
#define IDD_AACHOOSER_TXT_FILE_INPUT            100
#define IDD_AACHOOSER_TXT_FORMAT_INPUT          101
#define IDD_AACHOOSER_EDIT_FILE_OUTPUT          110
#define IDD_AACHOOSER_BTN_BROWSE                111
#define IDD_AACHOOSER_COMBO_DRIVER              120
#define IDD_AACHOOSER_BTN_PROPERTIES            121
#define IDD_AACHOOSER_TXT_FORMAT                130
#define IDD_AACHOOSER_BTN_FORMAT                131
#define IDD_AACHOOSER_BTN_FORMAT_OPTIONS        132
#define IDD_AACHOOSER_CHECK_FILTER              140
#define IDD_AACHOOSER_TXT_FILTER                141
#define IDD_AACHOOSER_BTN_FILTER                142
#define IDD_AACHOOSER_BTN_FILTER_OPTIONS        143
#define IDD_AACHOOSER_CHECK_NONREALTIME         150
#define IDD_AACHOOSER_CHECK_ASYNC               151
#define IDD_AACHOOSER_TXT_TIME                  160
#define IDD_AACHOOSER_SCROLL_TIME               161
#define IDD_AACHOOSER_EDIT_DETAILS              170


#define DLG_AAFORMATENUM                        RCID(91)
#define IDD_AAFORMATENUM_CHECK_CONVERT          100
#define IDD_AAFORMATENUM_CHECK_SUGGEST          101
#define IDD_AAFORMATENUM_CHECK_HARDWARE         102
#define IDD_AAFORMATENUM_CHECK_INPUT            103
#define IDD_AAFORMATENUM_CHECK_OUTPUT           104
#define IDD_AAFORMATENUM_CHECK_WFORMATTAG       105
#define IDD_AAFORMATENUM_EDIT_WFORMATTAG        106
#define IDD_AAFORMATENUM_CHECK_NCHANNELS        107
#define IDD_AAFORMATENUM_EDIT_NCHANNELS         108
#define IDD_AAFORMATENUM_CHECK_NSAMPLESPERSEC   109
#define IDD_AAFORMATENUM_EDIT_NSAMPLESPERSEC    110
#define IDD_AAFORMATENUM_CHECK_WBITSPERSAMPLE   111
#define IDD_AAFORMATENUM_EDIT_WBITSPERSAMPLE    112

#define DLG_AAFILTERENUM                        RCID(92)
#define IDD_AAFILTERENUM_CHECK_DWFILTERTAG      100
#define IDD_AAFILTERENUM_EDIT_DWFILTERTAG       101


#define DLG_AAPROPERTIES                        RCID(93)
#define IDD_AAPROPERTIES_COMBO_SOURCE           100
#define IDD_AAPROPERTIES_BTN_SOURCE             101
#define IDD_AAPROPERTIES_COMBO_DESTINATION      102
#define IDD_AAPROPERTIES_BTN_DESTINATION        103


#define DLG_AAFORMATSTYLE                               RCID(94)
#define IDD_AAFORMATSTYLE_CHECK_SHOWHELP                100
#define IDD_AAFORMATSTYLE_CHECK_ENABLEHOOK              101
#define IDD_AAFORMATSTYLE_CHECK_ENABLETEMPLATE          102
#define IDD_AAFORMATSTYLE_CHECK_ENABLETEMPLATEHANDLE    103
#define IDD_AAFORMATSTYLE_CHECK_INITTOWFXSTRUCT         104

#define DLG_AAFILTERSTYLE                               RCID(95)
#define IDD_AAFILTERSTYLE_CHECK_SHOWHELP                100
#define IDD_AAFILTERSTYLE_CHECK_ENABLEHOOK              101
#define IDD_AAFILTERSTYLE_CHECK_ENABLETEMPLATE          102
#define IDD_AAFILTERSTYLE_CHECK_ENABLETEMPLATEHANDLE    103
#define IDD_AAFILTERSTYLE_CHECK_INITTOFILTERSTRUCT      104


#define DLG_AAFORMATCHOOSE_TEMPLATE             RCID(98)
#define DLG_AAFILTERCHOOSE_TEMPLATE             RCID(99)



#define DLG_AACONVERT                           RCID(100)
#define IDD_AACONVERT_TXT_INFILEPATH            100
#define IDD_AACONVERT_TXT_OUTFILEPATH           101
#define IDD_AACONVERT_TXT_STATUS                102

#define DLG_AAPLAYRECORD                        RCID(110)
#define IDD_AAPLAYRECORD_BTN_PLAY               100
#define IDD_AAPLAYRECORD_BTN_PAUSE              101
#define IDD_AAPLAYRECORD_BTN_STOP               102
#define IDD_AAPLAYRECORD_BTN_START              103
#define IDD_AAPLAYRECORD_BTN_END                104
#define IDD_AAPLAYRECORD_BTN_RECORD             105
#define IDD_AAPLAYRECORD_SCROLL_POSITION        110
#define IDD_AAPLAYRECORD_TXT_POSITION           115
#define IDD_AAPLAYRECORD_EDIT_COMMAND           120
#define IDD_AAPLAYRECORD_EDIT_RESULT            121




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  string resources
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDS_APP_NAME                100
#define IDS_FILE_UNTITLED           101

#define IDS_OFN_EXT_DEF             125
#define IDS_OFN_EXT_FILTER          126

#define IDS_ERROR_ACM_NOT_PRESENT   500
#define IDS_ERROR_ACM_TOO_OLD       501

#define IDS_ERROR_OPEN_FAILED       550



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//
//
//
typedef struct tACMAPPFILEDESC
{
    DWORD           fdwState;

    TCHAR           szFileTitle[APP_MAX_FILE_TITLE_CHARS];
    TCHAR           szFilePath[APP_MAX_FILE_PATH_CHARS];
    
    DWORD           cbFileSize;
    UINT            uDosChangeDate;
    UINT            uDosChangeTime;
    DWORD           fdwFileAttributes;

    LPWAVEFORMATEX  pwfx;
    UINT            cbwfx;

    DWORD           dwDataBytes;
    DWORD           dwDataSamples;

} ACMAPPFILEDESC, *PACMAPPFILEDESC;

//
//  ACMAPPINST.fdwState flags
//
#define ACMAPPFILEDESC_STATEF_MODIFIED  0x80000000L




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  APPINIT.C -- Public helper functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LRESULT FNGLOBAL AppCreate
(
    HWND                    hwnd,
    LPCREATESTRUCT          pcs
);

LRESULT FNGLOBAL AppQueryEndSession
(
    HWND                    hwnd
);

LRESULT FNGLOBAL AppEndSession
(
    HWND                    hwnd,
    BOOL                    fEndSession
);

LRESULT FNGLOBAL AppClose
(
    HWND                    hwnd
);

HWND FNGLOBAL AppInit
(
    HINSTANCE               hinst,
    HINSTANCE               hinstPrev,
    LPTSTR                  pszCmdLine,
    int                     nCmdShow
);

int FNGLOBAL AppExit
(
    HINSTANCE               hinst,
    int                     nResult
);


LRESULT FNGLOBAL AppGetWindowsVersion
(
    PTSTR                   pszEnvironment,
    PTSTR                   pszPlatform
);

LRESULT FNGLOBAL AppWinIniChange
(
    HWND                    hwnd,
    LPCTSTR                 pszSection
);

HFONT FNGLOBAL AppChooseFont
(
    HWND                    hwnd,
    HFONT                   hFont,
    PLOGFONT                plf
);


BOOL FNEXPORT AboutDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);


BOOL FNGLOBAL AppProfileWriteBytes
(
    PTSTR                   pszSection,
    PTSTR                   pszKey,
    LPBYTE                  pbStruct,
    UINT                    cbStruct
);

BOOL FNGLOBAL AppProfileReadBytes
(
    PTSTR                   pszSection,
    PTSTR                   pszKey,
    LPBYTE                  pbStruct,
    UINT                    cbStruct
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  APP.C -- Public helper functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

int FNCGLOBAL AppMsgBox
(
    HWND                    hwnd,
    UINT                    fuStyle,
    PTSTR                   pszFormat,
    ...
);

int FNCGLOBAL AppMsgBoxId
(
    HWND                    hwnd,
    UINT                    fuStyle,
    UINT                    uIdsFormat,
    ...
);

void FNGLOBAL AppHourGlass
(
    BOOL                    fHourGlass
);

BOOL FNGLOBAL AppYield
(
    HWND                    hwnd,
    BOOL                    fIsDialog
);

BOOL FNGLOBAL AppTitle
(
    HWND                    hwnd,
    PTSTR                   pszFileTitle
);

int FNCGLOBAL AppSetWindowText
(
    HWND                    hwnd,
    PTSTR                   pszFormat,
    ...
);

int FNCGLOBAL AppSetWindowTextId
(
    HWND                    hwnd,
    UINT                    uIdsFormat,
    ...
);

BOOL FNGLOBAL AppFormatBigNumber
(
    LPTSTR                  pszNumber,
    DWORD                   dw
);

BOOL FNGLOBAL AppFormatDosDateTime
(
    LPTSTR                  pszDateTime,
    UINT                    uDosDate,
    UINT                    uDosTime
);

void FNCGLOBAL AcmAppDebugLog
(
    PTSTR                   pszFormat,
    ...
);

int FNCGLOBAL MEditPrintF
(
    HWND                    hedit,
    PTSTR                   pszFormat,
    ...
);

BOOL FNGLOBAL AppGetFileTitle
(
    PTSTR                   pszFilePath,
    PTSTR                   pszFileTitle
);

BOOL FNGLOBAL AppGetFileName
(
    HWND                    hwnd,
    PTSTR                   pszFilePath,
    PTSTR                   pszFileTitle,
    UINT                    fuFlags
);

BOOL FNGLOBAL AppFileNew
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd,
    BOOL                    fCreate
);


//
//  fuFlags for AppGetFileName()...
//
#define APP_GETFILENAMEF_OPEN       0x0000
#define APP_GETFILENAMEF_SAVE       0x0001


BOOL FNGLOBAL AppFileSave
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd,
    BOOL                    fSaveAs
);


LRESULT FNEXPORT AppWndProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  file manipulation functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//
//
//
#ifndef WIN32
DWORD FNGLOBAL DosGetFileAttributes
(
    LPTSTR                  pszFilePath
);

#ifndef FILE_ATTRIBUTE_READONLY
#define FILE_ATTRIBUTE_READONLY         0x00000001  
#define FILE_ATTRIBUTE_HIDDEN           0x00000002  
#define FILE_ATTRIBUTE_SYSTEM           0x00000004  
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010  
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020  
#define FILE_ATTRIBUTE_NORMAL           0x00000080  
#define FILE_ATTRIBUTE_TEMPORARY        0x00000100  
#endif
#endif

MMRESULT FNGLOBAL AcmAppFormatChoose
(
    HWND                    hwnd,
    LPWAVEFORMATEX          pwfx,
    UINT                    cbwfx,
    DWORD                   fdwStyle
);

BOOL FNGLOBAL AcmAppFileSaveModified
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
);

BOOL FNGLOBAL AcmAppFileNew
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
);

BOOL FNGLOBAL AcmAppFileOpen
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
);

BOOL FNGLOBAL AcmAppFileSave
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd,
    PTSTR                   pszFilePath,
    PTSTR                   pszFileTitle,
    UINT                    fuSave
);



BOOL FNGLOBAL AcmAppFileConvert
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
);

BOOL FNGLOBAL AcmAppFileFilter
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
);


BOOL FNGLOBAL AcmAppDisplayFileProperties
(
    HWND                    hedit,
    PACMAPPFILEDESC         paafd
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

BOOL FNEXPORT AcmAppDriversDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);


BOOL FNGLOBAL AcmAppGetFormatDescription
(
    LPWAVEFORMATEX          pwfx,
    LPTSTR                  pszFormatTag,
    LPTSTR                  pszFormat
);

BOOL FNGLOBAL AcmAppGetFilterDescription
(
    LPWAVEFILTER            pwfltr,
    LPTSTR                  pszFilterTag,
    LPTSTR                  pszFilter
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

BOOL FNEXPORT AcmAppSystemInfoDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);




BOOL FNEXPORT AcmAppPlayRecord
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);


BOOL FNEXPORT AcmAppWaveDeviceDlgProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);


BOOL FNGLOBAL AcmAppGetErrorString
(
    MMRESULT                mmr,
    LPTSTR                  pszError
);

//
//
//
#define WM_ACMAPP_ACM_NOTIFY        (WM_USER + 100)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc functions
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

BOOL FNGLOBAL AcmAppChooseFont
(
    HWND                    hwnd
);



//
//
//
//
typedef struct tAACONVERTDESC
{
    HACMDRIVERID        hadid;
    HACMDRIVER          had;
    HACMSTREAM          has;
    DWORD               fdwOpen;

    HMMIO               hmmioSrc;
    HMMIO               hmmioDst;

    MMCKINFO            ckDst;
    MMCKINFO            ckDstRIFF;

    UINT                uBufferTimePerConvert;

    TCHAR               szFilePathSrc[APP_MAX_FILE_PATH_CHARS];
    LPWAVEFORMATEX      pwfxSrc;
    LPBYTE              pbSrc;
    DWORD               dwSrcSamples;
    DWORD               cbSrcData;
    DWORD               cbSrcReadSize;
    TCHAR               szSrcFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    TCHAR               szSrcFormat[ACMFORMATDETAILS_FORMAT_CHARS];

    TCHAR               szFilePathDst[APP_MAX_FILE_PATH_CHARS];
    LPWAVEFORMATEX      pwfxDst;
    LPBYTE              pbDst;
    DWORD               cbDstBufSize;
    TCHAR               szDstFormatTag[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    TCHAR               szDstFormat[ACMFORMATDETAILS_FORMAT_CHARS];

    BOOL                fApplyFilter;
    LPWAVEFILTER        pwfltr;
    TCHAR               szFilterTag[ACMFILTERTAGDETAILS_FILTERTAG_CHARS];
    TCHAR               szFilter[ACMFILTERDETAILS_FILTER_CHARS];

    ACMSTREAMHEADER     ash;

    DWORD               cTotalConverts;
    DWORD               dwTimeTotal;
    DWORD               dwTimeShortest;
    DWORD               dwShortestConvert;
    DWORD               dwTimeLongest;
    DWORD               dwLongestConvert;

} AACONVERTDESC, *PAACONVERTDESC;



BOOL FNEXPORT AcmAppDlgProcChooser
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  global variables, etc.
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  flags for gfuAppOptions
//
#define APP_OPTIONSF_AUTOOPEN   0x0001
#define APP_OPTIONSF_DEBUGLOG   0x0004

extern HINSTANCE            ghinst;
extern BOOL                 gfAcmAvailable;
extern UINT                 gfuAppOptions;
extern HFONT                ghfontApp;
extern HACMDRIVERID         ghadidNotify;

extern UINT                 guWaveInId;
extern UINT                 guWaveOutId;

extern TCHAR                gszNull[];
extern TCHAR                gszAppProfile[];
extern TCHAR                gszYes[];
extern TCHAR                gszNo[];

extern TCHAR                gszAppName[APP_MAX_APP_NAME_CHARS];
extern TCHAR                gszFileUntitled[APP_MAX_FILE_TITLE_CHARS];

extern TCHAR                gszInitialDirOpen[APP_MAX_FILE_PATH_CHARS];
extern TCHAR                gszInitialDirSave[APP_MAX_FILE_PATH_CHARS];

extern TCHAR                gszLastSaveFile[APP_MAX_FILE_PATH_CHARS];


extern ACMAPPFILEDESC       gaafd;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_ACMAPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\acmthunk.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  acmthunk.c
//
//  Description:
//      This is a thunk layer to the Audio Compression Manager. It's 
//      purpose is to allow an application to use the ACM only if it is
//      available (like under Win 3.1 and NT where the ACM may or may not
//      be installed).
//
//      There are two requirements for using this module:
//
//      1.  Compile and link with this module before linking to MMSYSTEM.LIB.
//          Do *NOT* link with MSACM.LIB.
//
//      2.  Before calling any other functions in ACM function set, call
//          acmThunkInitialize(). This will cause all dyna-linking to occur.
//
//      3.  Before exiting your application, call acmThunkTerminate().
//          This will unlink to the ACM and free allocated resources.
//
//      NOTE! this could be written more efficiently in Assembly by doing
//      a jump to the correct API in the ACM, but this would not be
//      portable (easily) on NT. So the arguments will be repushed on the
//      stack.. such is life.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

//
//
//
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif


//==========================================================================;
//
//  Prototypes and String Defines for Dyna-Linking to the ACM
//
//
//==========================================================================;

#define ACMINST_NOT_PRESENT     NULL
#define ACMINST_TRY_LINKING     (HINSTANCE)(UINT)-1

static HINSTANCE    ghinstAcm   = ACMINST_TRY_LINKING;

#ifdef WIN32
TCHAR BCODE gszAcmModuleName[]  = TEXT("MSACM32.DLL");
#else
char BCODE  gszAcmModuleName[]  = "MSACM.DLL";
#endif

FARPROC    *gpafnAcmFunctions;

PSTR BCODE  gapszAcmFunctions[] =
{
    "acmGetVersion",
    "acmMetrics",

    "acmDriverEnum",
#ifdef WIN32
    "acmDriverDetailsW",
    "acmDriverDetailsA",
#else
    "acmDriverDetails",
#endif
#ifdef WIN32
    "acmDriverAddW",
    "acmDriverAddA",
#else
    "acmDriverAdd",
#endif
    "acmDriverRemove",
    "acmDriverOpen",
    "acmDriverClose",
    "acmDriverMessage",
    "acmDriverID",
    "acmDriverPriority",

#ifdef WIN32
    "acmFormatTagDetailsW",
    "acmFormatTagDetailsA",
#else
    "acmFormatTagDetails",
#endif
#ifdef WIN32
    "acmFormatTagEnumW",
    "acmFormatTagEnumA",
#else
    "acmFormatTagEnum",
#endif
#ifdef WIN32
    "acmFormatChooseW",
    "acmFormatChooseA",
#else
    "acmFormatChoose",
#endif
#ifdef WIN32
    "acmFormatDetailsW",
    "acmFormatDetailsA",
#else
    "acmFormatDetails",
#endif
#ifdef WIN32
    "acmFormatEnumW",
    "acmFormatEnumA",
#else
    "acmFormatEnum",
#endif
    "acmFormatSuggest",

#ifdef WIN32
    "acmFilterTagDetailsW",
    "acmFilterTagDetailsA",
#else
    "acmFilterTagDetails",
#endif
#ifdef WIN32
    "acmFilterTagEnumW",
    "acmFilterTagEnumA",
#else
    "acmFilterTagEnum",
#endif
#ifdef WIN32
    "acmFilterChooseW",
    "acmFilterChooseA",
#else
    "acmFilterChoose",
#endif
#ifdef WIN32
    "acmFilterDetailsW",
    "acmFilterDetailsA",
#else
    "acmFilterDetails",
#endif
#ifdef WIN32
    "acmFilterEnumW",
    "acmFilterEnumA",
#else
    "acmFilterEnum",
#endif

    "acmStreamOpen",
    "acmStreamClose",
    "acmStreamSize",
    "acmStreamConvert",
    "acmStreamReset",
    "acmStreamPrepareHeader",
    "acmStreamUnprepareHeader"
};

#ifdef WIN32    
//
//  For Win32
//
enum
{
     ACMTHUNK_GETVERSION = 0,
     ACMTHUNK_METRICS,
     ACMTHUNK_DRIVERENUM,
     ACMTHUNK_DRIVERDETAILSW,
     ACMTHUNK_DRIVERDETAILSA,
     ACMTHUNK_DRIVERADDW,
     ACMTHUNK_DRIVERADDA,
     ACMTHUNK_DRIVERREMOVE,
     ACMTHUNK_DRIVEROPEN,
     ACMTHUNK_DRIVERCLOSE,
     ACMTHUNK_DRIVERMESSAGE,
     ACMTHUNK_DRIVERID,
     ACMTHUNK_DRIVERPRIORITY,
     ACMTHUNK_FORMATTAGDETAILSW,
     ACMTHUNK_FORMATTAGDETAILSA,
     ACMTHUNK_FORMATTAGENUMW,
     ACMTHUNK_FORMATTAGENUMA,
     ACMTHUNK_FORMATCHOOSEW,
     ACMTHUNK_FORMATCHOOSEA,
     ACMTHUNK_FORMATDETAILSW,
     ACMTHUNK_FORMATDETAILSA,
     ACMTHUNK_FORMATENUMW,
     ACMTHUNK_FORMATENUMA,
     ACMTHUNK_FORMATSUGGEST,
     ACMTHUNK_FILTERTAGDETAILSW,
     ACMTHUNK_FILTERTAGDETAILSA,
     ACMTHUNK_FILTERTAGENUMW,
     ACMTHUNK_FILTERTAGENUMA,
     ACMTHUNK_FILTERCHOOSEW,
     ACMTHUNK_FILTERCHOOSEA,
     ACMTHUNK_FILTERDETAILSW,
     ACMTHUNK_FILTERDETAILSA,
     ACMTHUNK_FILTERENUMW,
     ACMTHUNK_FILTERENUMA,
     ACMTHUNK_STREAMOPEN,
     ACMTHUNK_STREAMCLOSE,
     ACMTHUNK_STREAMSIZE,
     ACMTHUNK_STREAMCONVERT,
     ACMTHUNK_STREAMRESET,
     ACMTHUNK_STREAMPREPAREHEADER,
     ACMTHUNK_STREAMUNPREPAREHEADER,

     ACMTHUNK_MAX_FUNCTIONS
};
     
	#ifdef _UNICODE
	#define ACMTHUNK_DRIVERDETAILS	    ACMTHUNK_DRIVERDETAILSW
	#define ACMTHUNK_DRIVERADD	    ACMTHUNK_DRIVERADDW
	#define ACMTHUNK_FORMATTAGDETAILS   ACMTHUNK_FORMATTAGDETAILSW
	#define ACMTHUNK_FORMATTAGENUM	    ACMTHUNK_FORMATTAGENUMW
	#define ACMTHUNK_FORMATCHOOSE	    ACMTHUNK_FORMATCHOOSEW
	#define ACMTHUNK_FORMATDETAILS	    ACMTHUNK_FORMATDETAILSW
	#define ACMTHUNK_FORMATENUM	    ACMTHUNK_FORMATENUMW
	#define ACMTHUNK_FILTERTAGDETAILS   ACMTHUNK_FILTERTAGDETAILSW
	#define ACMTHUNK_FILTERTAGENUM	    ACMTHUNK_FILTERTAGENUMW
	#define ACMTHUNK_FILTERCHOOSE	    ACMTHUNK_FILTERCHOOSEW
	#define ACMTHUNK_FILTERDETAILS	    ACMTHUNK_FILTERDETAILSW
	#define ACMTHUNK_FILTERENUM	    ACMTHUNK_FILTERENUMW

	#else
	#define ACMTHUNK_DRIVERDETAILS	    ACMTHUNK_DRIVERDETAILSA
	#define ACMTHUNK_DRIVERADD	    ACMTHUNK_DRIVERADDA
	#define ACMTHUNK_FORMATTAGDETAILS   ACMTHUNK_FORMATTAGDETAILSA
	#define ACMTHUNK_FORMATTAGENUM	    ACMTHUNK_FORMATTAGENUMA
	#define ACMTHUNK_FORMATCHOOSE	    ACMTHUNK_FORMATCHOOSEA
	#define ACMTHUNK_FORMATDETAILS	    ACMTHUNK_FORMATDETAILSA
	#define ACMTHUNK_FORMATENUM	    ACMTHUNK_FORMATENUMA
	#define ACMTHUNK_FILTERTAGDETAILS   ACMTHUNK_FILTERTAGDETAILSA
	#define ACMTHUNK_FILTERTAGENUM	    ACMTHUNK_FILTERTAGENUMA
	#define ACMTHUNK_FILTERCHOOSE	    ACMTHUNK_FILTERCHOOSEA
	#define ACMTHUNK_FILTERDETAILS	    ACMTHUNK_FILTERDETAILSA
	#define ACMTHUNK_FILTERENUM	    ACMTHUNK_FILTERENUMA

	#endif

#else     // if Win32
//
//  For Win16
//
enum
{
     ACMTHUNK_GETVERSION = 0,
     ACMTHUNK_METRICS,
     ACMTHUNK_DRIVERENUM,
     ACMTHUNK_DRIVERDETAILS,
     ACMTHUNK_DRIVERADD,
     ACMTHUNK_DRIVERREMOVE,
     ACMTHUNK_DRIVEROPEN,
     ACMTHUNK_DRIVERCLOSE,
     ACMTHUNK_DRIVERMESSAGE,
     ACMTHUNK_DRIVERID,
     ACMTHUNK_DRIVERPRIORITY,
     ACMTHUNK_FORMATTAGDETAILS,
     ACMTHUNK_FORMATTAGENUM,
     ACMTHUNK_FORMATCHOOSE,
     ACMTHUNK_FORMATDETAILS,
     ACMTHUNK_FORMATENUM,
     ACMTHUNK_FORMATSUGGEST,
     ACMTHUNK_FILTERTAGDETAILS,
     ACMTHUNK_FILTERTAGENUM,
     ACMTHUNK_FILTERCHOOSE,
     ACMTHUNK_FILTERDETAILS,
     ACMTHUNK_FILTERENUM,
     ACMTHUNK_STREAMOPEN,
     ACMTHUNK_STREAMCLOSE,
     ACMTHUNK_STREAMSIZE,
     ACMTHUNK_STREAMCONVERT,
     ACMTHUNK_STREAMRESET,
     ACMTHUNK_STREAMPREPAREHEADER,
     ACMTHUNK_STREAMUNPREPAREHEADER,

     ACMTHUNK_MAX_FUNCTIONS
};

#endif	// if WIN32 else

#define ACMTHUNK_SIZE_TABLE_BYTES   (ACMTHUNK_MAX_FUNCTIONS * sizeof(FARPROC))


//==========================================================================;
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL acmThunkInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FAR PASCAL acmThunkInitialize
(
    void
)
{
    DWORD (ACMAPI *pfnAcmGetVersion)
    (
        void
    );

    UINT            fuErrorMode;
    DWORD           dwVersion;
    UINT            u;

    //
    //  if we have already linked to the API's, then just succeed...
    //
    if (NULL != gpafnAcmFunctions)
    {
        //
        //  someone isn't satisfied with calling this API only once?
        //
        return (TRUE);
    }


    //
    //  if we have already tried to link to the ACM, then fail this
    //  call--it isn't present.
    //
    if (ACMINST_TRY_LINKING != ghinstAcm)
        return (FALSE);


    //
    //  try to get a handle on the ACM--if we cannot do this, then fail
    //
    fuErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    ghinstAcm = LoadLibrary(gszAcmModuleName);
    SetErrorMode(fuErrorMode);
    if (ghinstAcm < (HINSTANCE)HINSTANCE_ERROR)
    {
        ghinstAcm = ACMINST_NOT_PRESENT;
        return (FALSE);
    }

    (FARPROC)pfnAcmGetVersion = GetProcAddress(ghinstAcm, gapszAcmFunctions[ACMTHUNK_GETVERSION]);
    if (NULL == pfnAcmGetVersion)
    {
        FreeLibrary(ghinstAcm);
        ghinstAcm = ACMINST_NOT_PRESENT;

        return (FALSE);
    }


    //
    //  allocate our array of function pointers to the ACM... note that
    //  this is dynamically allocated so if the ACM is _not_ present,
    //  then this code and data takes up very little space.
    //
    gpafnAcmFunctions = (FARPROC *)LocalAlloc(LPTR, ACMTHUNK_SIZE_TABLE_BYTES);
    if (NULL == gpafnAcmFunctions)
    {
        FreeLibrary(ghinstAcm);
        ghinstAcm = ACMINST_NOT_PRESENT;

        return (FALSE);
    }

    gpafnAcmFunctions[ACMTHUNK_GETVERSION] = (FARPROC)pfnAcmGetVersion;

    //
    //  if the version of the ACM is *NOT* V2.00 or greater, then
    //  all other API's are unavailable--so don't waste time trying
    //  to link to them.
    //
    dwVersion = (* pfnAcmGetVersion)();
    if (0x0200 > HIWORD(dwVersion))
    {
        return (TRUE);
    }


    //
    //  yipee! the ACM V2.00 or greater appears to be installed and
    //  happy with us--so link to the rest of the nifty cool API's.
    //
    //  start at index 1 since we already linked to acmGetVersion above
    //
    for (u = 1; u < ACMTHUNK_MAX_FUNCTIONS; u++)
    {
        gpafnAcmFunctions[u] = GetProcAddress(ghinstAcm, gapszAcmFunctions[u]);
    }


    //
    //  finally, return success
    //
    return (TRUE);
} // acmThunkInitialize()


//--------------------------------------------------------------------------;
//  
//  BOOL acmThunkTerminate
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FAR PASCAL acmThunkTerminate
(
    void
)
{
    //
    //
    //
    if (NULL != gpafnAcmFunctions)
    {
        LocalFree((HLOCAL)gpafnAcmFunctions);

        gpafnAcmFunctions = NULL;

        FreeLibrary(ghinstAcm);
        ghinstAcm = ACMINST_TRY_LINKING;
    }

    return (TRUE);
} // acmThunkTerminate()


//==========================================================================;
//
//  General Information API's
//
//
//==========================================================================;

DWORD ACMAPI acmGetVersion
(
    void
)
{
    DWORD (ACMAPI *pfnAcmGetVersion)
    (
        void
    );

    DWORD           dwVersion;

    if (NULL == gpafnAcmFunctions)
        return (0L);

    (FARPROC)pfnAcmGetVersion = gpafnAcmFunctions[ACMTHUNK_GETVERSION];
    if (NULL == pfnAcmGetVersion)
        return (0L);

    dwVersion = (* pfnAcmGetVersion)();

    return (dwVersion);
} // acmGetVersion()


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmMetrics
(
    HACMOBJ                 hao,
    UINT                    uMetric,
    LPVOID                  pMetric
)
{
    MMRESULT (ACMAPI *pfnAcmMetrics)
    (
        HACMOBJ                 hao,
        UINT                    uMetric,
        LPVOID                  pMetric
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmMetrics = gpafnAcmFunctions[ACMTHUNK_METRICS];
    if (NULL == pfnAcmMetrics)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmMetrics)(hao, uMetric, pMetric);

    return (mmr);
} // acmMetrics()


//==========================================================================;
//
//  ACM Driver Management API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverEnum
(
    ACMDRIVERENUMCB         fnCallback,
    DWORD                   dwInstance,
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmDriverEnum)
    (
        ACMDRIVERENUMCB         fnCallback,
        DWORD                   dwInstance,
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverEnum = gpafnAcmFunctions[ACMTHUNK_DRIVERENUM];
    if (NULL == pfnAcmDriverEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverEnum)(fnCallback, dwInstance, fdwEnum);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverDetails
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILS      padd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmDriverDetails)
    (
        HACMDRIVERID            hadid,
        LPACMDRIVERDETAILS      padd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverDetails = gpafnAcmFunctions[ACMTHUNK_DRIVERDETAILS];
    if (NULL == pfnAcmDriverDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverDetails)(hadid, padd, fdwDetails);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmDriverDetailsA
(
    HACMDRIVERID            hadid,
    LPACMDRIVERDETAILSA     padd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmDriverDetails)
    (
        HACMDRIVERID            hadid,
        LPACMDRIVERDETAILSA     padd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverDetails = gpafnAcmFunctions[ACMTHUNK_DRIVERDETAILSA];
    if (NULL == pfnAcmDriverDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverDetails)(hadid, padd, fdwDetails);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverAdd
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    MMRESULT (ACMAPI *pfnAcmDriverAdd)
    (
        LPHACMDRIVERID          phadid,
        HINSTANCE               hinstModule,
        LPARAM                  lParam, 
        DWORD                   dwPriority,
        DWORD                   fdwAdd
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverAdd = gpafnAcmFunctions[ACMTHUNK_DRIVERADD];
    if (NULL == pfnAcmDriverAdd)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverAdd)(phadid, hinstModule, lParam, dwPriority, fdwAdd);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmDriverAddA
(
    LPHACMDRIVERID          phadid,
    HINSTANCE               hinstModule,
    LPARAM                  lParam, 
    DWORD                   dwPriority,
    DWORD                   fdwAdd
)
{
    MMRESULT (ACMAPI *pfnAcmDriverAdd)
    (
        LPHACMDRIVERID          phadid,
        HINSTANCE               hinstModule,
        LPARAM                  lParam, 
        DWORD                   dwPriority,
        DWORD                   fdwAdd
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverAdd = gpafnAcmFunctions[ACMTHUNK_DRIVERADDA];
    if (NULL == pfnAcmDriverAdd)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverAdd)(phadid, hinstModule, lParam, dwPriority, fdwAdd);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverRemove
(
    HACMDRIVERID            hadid,
    DWORD                   fdwRemove
)
{
    MMRESULT (ACMAPI *pfnAcmDriverRemove)
    (
        HACMDRIVERID            hadid,
        DWORD                   fdwRemove
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverRemove = gpafnAcmFunctions[ACMTHUNK_DRIVERREMOVE];
    if (NULL == pfnAcmDriverRemove)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverRemove)(hadid, fdwRemove);

    return (mmr);
}

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverOpen
(
    LPHACMDRIVER            phad, 
    HACMDRIVERID            hadid,
    DWORD                   fdwOpen
)
{
    MMRESULT (ACMAPI *pfnAcmDriverOpen)
    (
        LPHACMDRIVER            phad, 
        HACMDRIVERID            hadid,
        DWORD                   fdwOpen
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverOpen = gpafnAcmFunctions[ACMTHUNK_DRIVEROPEN];
    if (NULL == pfnAcmDriverOpen)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverOpen)(phad, hadid, fdwOpen);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverClose
(
    HACMDRIVER              had,
    DWORD                   fdwClose
)
{
    MMRESULT (ACMAPI *pfnAcmDriverClose)
    (
        HACMDRIVER              had,
        DWORD                   fdwClose
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverClose = gpafnAcmFunctions[ACMTHUNK_DRIVERCLOSE];
    if (NULL == pfnAcmDriverClose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverClose)(had, fdwClose);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

LRESULT ACMAPI acmDriverMessage
(
    HACMDRIVER              had,
    UINT                    uMsg, 
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT (ACMAPI *pfnAcmDriverMessage)
    (
        HACMDRIVER              had,
        UINT                    uMsg, 
        LPARAM                  lParam1,
        LPARAM                  lParam2
    );

    LRESULT         lr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverMessage = gpafnAcmFunctions[ACMTHUNK_DRIVERMESSAGE];
    if (NULL == pfnAcmDriverMessage)
        return (MMSYSERR_ERROR);

    lr = (* pfnAcmDriverMessage)(had, uMsg, lParam1, lParam2);

    return (lr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverID
(
    HACMOBJ                 hao,
    LPHACMDRIVERID          phadid,
    DWORD                   fdwDriverId
)
{
    MMRESULT (ACMAPI *pfnAcmDriverId)
    (
        HACMOBJ                 hao,
        LPHACMDRIVERID          phadid,
        DWORD                   fdwDriverId
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverId = gpafnAcmFunctions[ACMTHUNK_DRIVERID];
    if (NULL == pfnAcmDriverId)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverId)(hao, phadid, fdwDriverId);

    return (mmr);
}

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmDriverPriority
(
    HACMDRIVERID            hadid,
    DWORD                   dwPriority,
    DWORD                   fdwPriority
)
{
    MMRESULT (ACMAPI *pfnAcmDriverPriority)
    (
        HACMDRIVERID            hadid,
        DWORD                   dwPriority,
        DWORD                   fdwPriority
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmDriverPriority = gpafnAcmFunctions[ACMTHUNK_DRIVERPRIORITY];
    if (NULL == pfnAcmDriverPriority)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmDriverPriority)(hadid, dwPriority, fdwPriority);

    return (mmr);
}


//==========================================================================;
//
//  Format Tag Information API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatTagDetails
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFormatTagDetails)
    (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILS   paftd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatTagDetails = gpafnAcmFunctions[ACMTHUNK_FORMATTAGDETAILS];
    if (NULL == pfnAcmFormatTagDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatTagDetails)(had, paftd, fdwDetails);

    return (mmr);
} // acmFormatTagDetails()

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatTagDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFormatTagDetails)
    (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILSA  paftd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatTagDetails = gpafnAcmFunctions[ACMTHUNK_FORMATTAGDETAILSA];
    if (NULL == pfnAcmFormatTagDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatTagDetails)(had, paftd, fdwDetails);

    return (mmr);
} // acmFormatTagDetails()
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatTagEnum
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILS   paftd,
    ACMFORMATTAGENUMCB      fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFormatTagEnum)
    (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILS   paftd,
        ACMFORMATTAGENUMCB      fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatTagEnum = gpafnAcmFunctions[ACMTHUNK_FORMATTAGENUM];
    if (NULL == pfnAcmFormatTagEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
} // acmFormatTagEnum()

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatTagEnumA
(
    HACMDRIVER              had,
    LPACMFORMATTAGDETAILSA  paftd,
    ACMFORMATTAGENUMCBA     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFormatTagEnum)
    (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILSA  paftd,
        ACMFORMATTAGENUMCBA     fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatTagEnum = gpafnAcmFunctions[ACMTHUNK_FORMATTAGENUMA];
    if (NULL == pfnAcmFormatTagEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
} // acmFormatTagEnum()
#endif

//==========================================================================;
//
//  Format Information API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatChoose
(
    LPACMFORMATCHOOSE       pafmtc
)
{
    MMRESULT (ACMAPI *pfnAcmFormatChoose)
    (
        LPACMFORMATCHOOSE       pafmtc
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatChoose = gpafnAcmFunctions[ACMTHUNK_FORMATCHOOSE];
    if (NULL == pfnAcmFormatChoose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatChoose)(pafmtc);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatChooseA
(
    LPACMFORMATCHOOSEA      pafmtc
)
{
    MMRESULT (ACMAPI *pfnAcmFormatChoose)
    (
        LPACMFORMATCHOOSEA      pafmtc
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatChoose = gpafnAcmFunctions[ACMTHUNK_FORMATCHOOSEA];
    if (NULL == pfnAcmFormatChoose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatChoose)(pafmtc);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatDetails
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFormatDetails)
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILS      pafd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatDetails = gpafnAcmFunctions[ACMTHUNK_FORMATDETAILS];
    if (NULL == pfnAcmFormatDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatDetails)(had, pafd, fdwDetails);

    return (mmr);
} // acmFormatDetails()

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatDetailsA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFormatDetails)
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILSA     pafd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatDetails = gpafnAcmFunctions[ACMTHUNK_FORMATDETAILSA];
    if (NULL == pfnAcmFormatDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatDetails)(had, pafd, fdwDetails);

    return (mmr);
} // acmFormatDetails()
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatEnum
(
    HACMDRIVER              had,
    LPACMFORMATDETAILS      pafd,
    ACMFORMATENUMCB         fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFormatEnum)
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILS      pafd,
        ACMFORMATENUMCB         fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatEnum = gpafnAcmFunctions[ACMTHUNK_FORMATENUM];
    if (NULL == pfnAcmFormatEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatEnum)(had, pafd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmFormatEnumA
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    ACMFORMATENUMCBA        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFormatEnum)
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILSA     pafd,
        ACMFORMATENUMCBA        fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatEnum = gpafnAcmFunctions[ACMTHUNK_FORMATENUMA];
    if (NULL == pfnAcmFormatEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatEnum)(had, pafd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFormatSuggest
(
    HACMDRIVER          had,
    LPWAVEFORMATEX      pwfxSrc,
    LPWAVEFORMATEX      pwfxDst,
    DWORD               cbwfxDst,
    DWORD               fdwSuggest
)
{
    MMRESULT (ACMAPI *pfnAcmFormatSuggest)
    (
        HACMDRIVER          had,
        LPWAVEFORMATEX      pwfxSrc,
        LPWAVEFORMATEX      pwfxDst,
        DWORD               cbwfxDst,
        DWORD               fdwSuggest
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFormatSuggest = gpafnAcmFunctions[ACMTHUNK_FORMATSUGGEST];
    if (NULL == pfnAcmFormatSuggest)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFormatSuggest)(had, pwfxSrc, pwfxDst, cbwfxDst, fdwSuggest);

    return (mmr);
}


//==========================================================================;
//
//  Filter Tag Information API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterTagDetails
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFilterTagDetails)
    (
        HACMDRIVER              had,
        LPACMFILTERTAGDETAILS   paftd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterTagDetails = gpafnAcmFunctions[ACMTHUNK_FILTERTAGDETAILS];
    if (NULL == pfnAcmFilterTagDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterTagDetails)(had, paftd, fdwDetails);

    return (mmr);
} // acmFilterTagDetails()

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterTagDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFilterTagDetails)
    (
        HACMDRIVER              had,
        LPACMFILTERTAGDETAILSA  paftd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterTagDetails = gpafnAcmFunctions[ACMTHUNK_FILTERTAGDETAILSA];
    if (NULL == pfnAcmFilterTagDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterTagDetails)(had, paftd, fdwDetails);

    return (mmr);
} // acmFilterTagDetails()
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterTagEnum
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILS   paftd,
    ACMFILTERTAGENUMCB      fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFilterTagEnum)
    (
        HACMDRIVER              had,
        LPACMFILTERTAGDETAILS   paftd,
        ACMFILTERTAGENUMCB      fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterTagEnum = gpafnAcmFunctions[ACMTHUNK_FILTERTAGENUM];
    if (NULL == pfnAcmFilterTagEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
} // acmFilterTagEnum()

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterTagEnumA
(
    HACMDRIVER              had,
    LPACMFILTERTAGDETAILSA  paftd,
    ACMFILTERTAGENUMCBA     fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFilterTagEnum)
    (
        HACMDRIVER              had,
        LPACMFILTERTAGDETAILSA  paftd,
        ACMFILTERTAGENUMCBA     fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterTagEnum = gpafnAcmFunctions[ACMTHUNK_FILTERTAGENUMA];
    if (NULL == pfnAcmFilterTagEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
} // acmFilterTagEnum()
#endif

//==========================================================================;
//
//  Filter Information API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterChoose
(
    LPACMFILTERCHOOSE       pafltrc
)
{
    MMRESULT (ACMAPI *pfnAcmFilterChoose)
    (
        LPACMFILTERCHOOSE       pafltrc
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterChoose = gpafnAcmFunctions[ACMTHUNK_FILTERCHOOSE];
    if (NULL == pfnAcmFilterChoose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterChoose)(pafltrc);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterChooseA
(
    LPACMFILTERCHOOSEA      pafltrc
)
{
    MMRESULT (ACMAPI *pfnAcmFilterChoose)
    (
        LPACMFILTERCHOOSEA      pafltrc
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterChoose = gpafnAcmFunctions[ACMTHUNK_FILTERCHOOSEA];
    if (NULL == pfnAcmFilterChoose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterChoose)(pafltrc);

    return (mmr);
}
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterDetails
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFilterDetails)
    (
        HACMDRIVER              had,
        LPACMFILTERDETAILS      pafd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterDetails = gpafnAcmFunctions[ACMTHUNK_FILTERDETAILS];
    if (NULL == pfnAcmFilterDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterDetails)(had, pafd, fdwDetails);

    return (mmr);
} // acmFilterDetails()

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterDetailsA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    DWORD                   fdwDetails
)
{
    MMRESULT (ACMAPI *pfnAcmFilterDetails)
    (
        HACMDRIVER              had,
        LPACMFILTERDETAILSA     pafd,
        DWORD                   fdwDetails
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterDetails = gpafnAcmFunctions[ACMTHUNK_FILTERDETAILSA];
    if (NULL == pfnAcmFilterDetails)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterDetails)(had, pafd, fdwDetails);

    return (mmr);
} // acmFilterDetails()
#endif

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmFilterEnum
(
    HACMDRIVER              had,
    LPACMFILTERDETAILS      pafd,
    ACMFILTERENUMCB         fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFilterEnum)
    (
        HACMDRIVER              had,
        LPACMFILTERDETAILS      pafd,
        ACMFILTERENUMCB         fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterEnum = gpafnAcmFunctions[ACMTHUNK_FILTERENUM];
    if (NULL == pfnAcmFilterEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterEnum)(had, pafd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
}

#ifdef _UNICODE
MMRESULT ACMAPI acmFilterEnumA
(
    HACMDRIVER              had,
    LPACMFILTERDETAILSA     pafd,
    ACMFILTERENUMCBA        fnCallback,
    DWORD                   dwInstance, 
    DWORD                   fdwEnum
)
{
    MMRESULT (ACMAPI *pfnAcmFilterEnum)
    (
        HACMDRIVER              had,
        LPACMFILTERDETAILSA     pafd,
        ACMFILTERENUMCBA        fnCallback,
        DWORD                   dwInstance, 
        DWORD                   fdwEnum
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmFilterEnum = gpafnAcmFunctions[ACMTHUNK_FILTERENUMA];
    if (NULL == pfnAcmFilterEnum)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmFilterEnum)(had, pafd, fnCallback, dwInstance, fdwEnum);

    return (mmr);
}
#endif

//==========================================================================;
//
//  ACM Stream Management API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamOpen
(
    LPHACMSTREAM            phas,
    HACMDRIVER              had,
    LPWAVEFORMATEX          pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    LPWAVEFILTER            pwfltr,
    DWORD                   dwCallback,
    DWORD                   dwInstance,
    DWORD                   fdwOpen
)
{
    MMRESULT (ACMAPI *pfnAcmStreamOpen)
    (
        LPHACMSTREAM            phas,
        HACMDRIVER              had,
        LPWAVEFORMATEX          pwfxSrc,
        LPWAVEFORMATEX          pwfxDst,
        LPWAVEFILTER            pwfltr,
        DWORD                   dwCallback,
        DWORD                   dwInstance,
        DWORD                   fdwOpen
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamOpen = gpafnAcmFunctions[ACMTHUNK_STREAMOPEN];
    if (NULL == pfnAcmStreamOpen)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamOpen)(phas, had, pwfxSrc, pwfxDst, pwfltr, dwCallback, dwInstance, fdwOpen);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamClose
(
    HACMSTREAM              has,
    DWORD                   fdwClose
)
{
    MMRESULT (ACMAPI *pfnAcmStreamClose)
    (
        HACMSTREAM              has,
        DWORD                   fdwClose
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamClose = gpafnAcmFunctions[ACMTHUNK_STREAMCLOSE];
    if (NULL == pfnAcmStreamClose)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamClose)(has, fdwClose);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamSize
(
    HACMSTREAM              has,
    DWORD                   cbInput,
    LPDWORD                 pdwOutputBytes,
    DWORD                   fdwSize
)
{
    MMRESULT (ACMAPI *pfnAcmStreamSize)
    (
        HACMSTREAM              has,
        DWORD                   cbInput,
        LPDWORD                 pdwOutputBytes,
        DWORD                   fdwSize
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamSize = gpafnAcmFunctions[ACMTHUNK_STREAMSIZE];
    if (NULL == pfnAcmStreamSize)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamSize)(has, cbInput, pdwOutputBytes, fdwSize);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamConvert
(
    HACMSTREAM              has, 
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwConvert
)
{
    MMRESULT (ACMAPI *pfnAcmStreamConvert)
    (
        HACMSTREAM              has, 
        LPACMSTREAMHEADER       pash,
        DWORD                   fdwConvert
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamConvert = gpafnAcmFunctions[ACMTHUNK_STREAMCONVERT];
    if (NULL == pfnAcmStreamConvert)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamConvert)(has, pash, fdwConvert);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamReset
(
    HACMSTREAM              has, 
    DWORD                   fdwReset
)
{
    MMRESULT (ACMAPI *pfnAcmStreamReset)
    (
        HACMSTREAM              has, 
        DWORD                   fdwReset
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamReset = gpafnAcmFunctions[ACMTHUNK_STREAMRESET];
    if (NULL == pfnAcmStreamReset)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamReset)(has, fdwReset);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamPrepareHeader
(
    HACMSTREAM              has, 
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwPrepare
)
{
    MMRESULT (ACMAPI *pfnAcmStreamPrepareHeader)
    (
        HACMSTREAM              has, 
        LPACMSTREAMHEADER       pash,
        DWORD                   fdwPrepare
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamPrepareHeader = gpafnAcmFunctions[ACMTHUNK_STREAMPREPAREHEADER];
    if (NULL == pfnAcmStreamPrepareHeader)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamPrepareHeader)(has, pash, fdwPrepare);

    return (mmr);
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

MMRESULT ACMAPI acmStreamUnprepareHeader
(
    HACMSTREAM              has, 
    LPACMSTREAMHEADER       pash,
    DWORD                   fdwUnprepare
)
{
    MMRESULT (ACMAPI *pfnAcmStreamUnprepareHeader)
    (
        HACMSTREAM              has, 
        LPACMSTREAMHEADER       pash,
        DWORD                   fdwUnprepare
    );

    MMRESULT        mmr;

    if (NULL == gpafnAcmFunctions)
        return (MMSYSERR_ERROR);

    (FARPROC)pfnAcmStreamUnprepareHeader = gpafnAcmFunctions[ACMTHUNK_STREAMUNPREPAREHEADER];
    if (NULL == pfnAcmStreamUnprepareHeader)
        return (MMSYSERR_ERROR);

    mmr = (* pfnAcmStreamUnprepareHeader)(has, pash, fdwUnprepare);

    return (mmr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\acmthunk.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  acmthunk.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_ACMTHUNK
#define _INC_ACMTHUNK

#ifdef __cplusplus
extern "C"
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

BOOL FAR PASCAL acmThunkInitialize
(
    void
);

BOOL FAR PASCAL acmThunkTerminate
(
    void
);


#ifdef __cplusplus
}
#endif
#endif  // _INC_ACMTHUNK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\acmapp.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  acmapp.c
//
//  Description:
//      This is a sample application that demonstrates how to use the 
//      Audio Compression Manager API's in Windows. This application is
//      also useful as an ACM driver test.
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commdlg.h>
#include <shellapi.h>
#include <stdarg.h>
#include <memory.h>
#include <mmreg.h>
#include <msacm.h>

#include "appport.h"
#include "acmapp.h"

#include "debug.h"


//
//  globals, no less
//
HINSTANCE       ghinst;
BOOL            gfAcmAvailable;
UINT            gfuAppOptions       = APP_OPTIONSF_AUTOOPEN;
HFONT           ghfontApp;
HACMDRIVERID    ghadidNotify;

UINT            guWaveInId          = (UINT)WAVE_MAPPER;
UINT            guWaveOutId         = (UINT)WAVE_MAPPER;

TCHAR           gszNull[]           = TEXT("");
TCHAR           gszAppProfile[]     = TEXT("acmapp.ini");
TCHAR           gszYes[]            = TEXT("Yes");
TCHAR           gszNo[]             = TEXT("No");

TCHAR           gszAppName[APP_MAX_APP_NAME_CHARS];
TCHAR           gszFileUntitled[APP_MAX_FILE_TITLE_CHARS];

TCHAR           gszInitialDirOpen[APP_MAX_FILE_PATH_CHARS];
TCHAR           gszInitialDirSave[APP_MAX_FILE_PATH_CHARS];

TCHAR           gszLastSaveFile[APP_MAX_FILE_PATH_CHARS];

ACMAPPFILEDESC  gaafd;


//==========================================================================;
//
//  Application helper functions
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int AppMsgBox
//
//  Description:
//      This function displays a message for the application in a standard
//      message box.
//
//      Note that this function takes any valid argument list that can
//      be passed to wsprintf. Because of this, the application must
//      remember to cast near string pointers to FAR when built for Win 16.
//      You will get a nice GP fault if you do not cast them correctly.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for message box holding the
//      message.
//
//      UINT fuStyle: Style flags for MessageBox().
//
//      PTSTR pszFormat: Format string used for wvsprintf().
//
//  Return (int):
//      The return value is the result of MessageBox() function.
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppMsgBox
(
    HWND                    hwnd,
    UINT                    fuStyle,
    PTSTR                   pszFormat,
    ...
)
{
    va_list     va;
    TCHAR       ach[1024];
    int         n;

    //
    //  format and display the message..
    //
    va_start(va, pszFormat);
#ifdef WIN32
    wvsprintf(ach, pszFormat, va);
#else
    wvsprintf(ach, pszFormat, (LPSTR)va);
#endif
    va_end(va);

    n = MessageBox(hwnd, ach, gszAppName, fuStyle);

    return (n);
} // AppMsgBox()


//--------------------------------------------------------------------------;
//
//  int AppMsgBoxId
//
//  Description:
//      This function displays a message for the application. The message
//      text is retrieved from the string resource table using LoadString.
//
//      Note that this function takes any valid argument list that can
//      be passed to wsprintf. Because of this, the application must
//      remember to cast near string pointers to FAR when built for Win 16.
//      You will get a nice GP fault if you do not cast them correctly.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for message box holding the
//      message.
//
//      UINT fuStyle: Style flags for MessageBox().
//
//      UINT uIdsFormat: String resource id to be loaded with LoadString()
//      and used a the format string for wvsprintf().
//
//  Return (int):
//      The return value is the result of MessageBox() if the string
//      resource specified by uIdsFormat is valid. The return value is zero
//      if the string resource failed to load.
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppMsgBoxId
(
    HWND                    hwnd,
    UINT                    fuStyle,
    UINT                    uIdsFormat,
    ...
)
{
    va_list     va;
    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS];
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat));
    if (0 != n)
    {
        //
        //  format and display the message..
        //
        va_start(va, uIdsFormat);
#ifdef WIN32
        wvsprintf(ach, szFormat, va);
#else
        wvsprintf(ach, szFormat, (LPSTR)va);
#endif
        va_end(va);

        n = MessageBox(hwnd, ach, gszAppName, fuStyle);
    }

    return (n);
} // AppMsgBoxId()


//--------------------------------------------------------------------------;
//
//  void AppHourGlass
//
//  Description:
//      This function changes the cursor to that of the hour glass or
//      back to the previous cursor.
//
//      This function can be called recursively.
//
//  Arguments:
//      BOOL fHourGlass: TRUE if we need the hour glass.  FALSE if we need
//      the arrow back.
//
//  Return (void):
//      On return, the cursor will be what was requested.
//
//--------------------------------------------------------------------------;

void FNGLOBAL AppHourGlass
(
    BOOL                    fHourGlass
)
{
    static HCURSOR  hcur;
    static UINT     uWaiting = 0;

    if (fHourGlass)
    {
        if (!uWaiting)
        {
            hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
            ShowCursor(TRUE);
        }

        uWaiting++;
    }
    else
    {
        --uWaiting;

        if (!uWaiting)
        {
            ShowCursor(FALSE);
            SetCursor(hcur);
        }
    }
} // AppHourGlass()


//--------------------------------------------------------------------------;
//
//  BOOL AppYield
//
//  Description:
//      This function yields by dispatching all messages stacked up in the
//      application queue.
//
//  Arguments:
//      HWND hwnd: Handle to main window of application if not yielding
//      for a dialog. Handle to dialog box if yielding for a dialog box.
//
//      BOOL fIsDialog: TRUE if being called to yield for a dialog box.
//
//  Return (BOOL):
//      The return value is always TRUE.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppYield
(
    HWND                    hwnd,
    BOOL                    fIsDialog
)
{
    MSG     msg;

    if (fIsDialog)
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if ((NULL == hwnd) || !IsDialogMessage(hwnd, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    else
    {
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return (TRUE);
} // AppYield()


//--------------------------------------------------------------------------;
//
//  int AppSetWindowText
//
//  Description:
//      This function formats a string and sets the specified window text
//      to the result.
//
//  Arguments:
//      HWND hwnd: Handle to window to receive the new text.
//
//      PTSTR pszFormat: Pointer to any valid format for wsprintf.
//
//  Return (int):
//      The return value is the number of bytes that the resulting window
//      text was.
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppSetWindowText
(
    HWND                    hwnd,
    PTSTR                   pszFormat,
    ...
)
{
    va_list     va;
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    //
    //  format and display the string in the window...
    //
    va_start(va, pszFormat);
#ifdef WIN32
    n = wvsprintf(ach, pszFormat, va);
#else
    n = wvsprintf(ach, pszFormat, (LPSTR)va);
#endif
    va_end(va);

    SetWindowText(hwnd, ach);

    return (n);
} // AppSetWindowText()


//--------------------------------------------------------------------------;
//
//  int AppSetWindowTextId
//
//  Description:
//      This function formats a string and sets the specified window text
//      to the result. The format string is extracted from the string
//      table using LoadString() on the uIdsFormat argument.
//
//  Arguments:
//      HWND hwnd: Handle to window to receive the new text.
//
//      UINT uIdsFormat: String resource id to be loaded with LoadString()
//      and used a the format string for wvsprintf().
//
//  Return (int):
//      The return value is the number of bytes that the resulting window
//      text was. This value is zero if the LoadString() function fails
//      for the uIdsFormat argument.
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppSetWindowTextId
(
    HWND                    hwnd,
    UINT                    uIdsFormat,
    ...
)
{
    va_list     va;
    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS];
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat));
    if (0 != n)
    {
        //
        //  format and display the string in the window...
        //
        va_start(va, uIdsFormat);
#ifdef WIN32
        n = wvsprintf(ach, szFormat, va);
#else
        n = wvsprintf(ach, szFormat, (LPSTR)va);
#endif
        va_end(va);

        SetWindowText(hwnd, ach);
    }

    return (n);
} // AppSetWindowTextId()


//--------------------------------------------------------------------------;
//  
//  BOOL AppFormatBigNumber
//  
//  Description:
//  
//  
//  Arguments:
//      LPTSTR pszNumber:
//  
//      DWORD dw:
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppFormatBigNumber
(
    LPTSTR                  pszNumber,
    DWORD                   dw
)
{
    //
    //  this is ugly...
    //
    //
    if (dw >= 1000000000L)
    {
        wsprintf(pszNumber, TEXT("%u,%03u,%03u,%03u"),
                            (WORD)(dw / 1000000000L),
                            (WORD)((dw % 1000000000L) / 1000000L),
                            (WORD)((dw % 1000000L) / 1000),
                            (WORD)(dw % 1000));
    }
    else if (dw >= 1000000L)
    {
        wsprintf(pszNumber, TEXT("%u,%03u,%03u"),
                            (WORD)(dw / 1000000L),
                            (WORD)((dw % 1000000L) / 1000),
                            (WORD)(dw % 1000));
    }
    else if (dw >= 1000)
    {
        wsprintf(pszNumber, TEXT("%u,%03u"),
                            (WORD)(dw / 1000),
                            (WORD)(dw % 1000));
    }
    else
    {
        wsprintf(pszNumber, TEXT("%lu"), dw);
    }


    return (TRUE);
} // AppFormatBigNumber()


//--------------------------------------------------------------------------;
//  
//  BOOL AppFormatDosDateTime
//  
//  Description:
//  
//  
//  Arguments:
//      LPTSTR pszDateTime:
//  
//      UINT uDosDate:
//  
//      UINT uDosTime:
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppFormatDosDateTime
(
    LPTSTR                  pszDateTime,
    UINT                    uDosDate,
    UINT                    uDosTime
)
{
    static TCHAR        szFormatDateTime[]  = TEXT("%.02u/%.02u/%.02u  %.02u:%.02u:%.02u");

    UINT                uDateMonth;
    UINT                uDateDay;
    UINT                uDateYear;
    UINT                uTimeHour;
    UINT                uTimeMinute;
    UINT                uTimeSecond;

    //
    //
    //
    uTimeHour   = uDosTime >> 11;
    uTimeMinute = (uDosTime & 0x07E0) >> 5;
    uTimeSecond = (uDosTime & 0x001F) << 1;

    uDateMonth  = (uDosDate & 0x01E0) >> 5;
    uDateDay    = (uDosDate & 0x001F);
    uDateYear   = (uDosDate >> 9) + 80;

    //
    //
    //
    //
    wsprintf(pszDateTime, szFormatDateTime,
             uDateMonth,
             uDateDay,
             uDateYear,
             uTimeHour,
             uTimeMinute,
             uTimeSecond);

    return (TRUE);
} // AppFormatDosDateTime()


//--------------------------------------------------------------------------;
//
//  void AcmAppDebugLog
//
//  Description:
//      This function logs information to the debugger if the Debug Log
//      option is set. You can then run DBWin (or something similar)
//      to redirect the output whereever you want. Very useful for debugging
//      ACM drivers.
//
//  Arguments:
//      PTSTR pszFormat: Pointer to any valid format for wsprintf.
//
//  Return (void):
//      None.
//
//--------------------------------------------------------------------------;

void FNCGLOBAL AcmAppDebugLog
(
    PTSTR                   pszFormat,
    ...
)
{
    static  TCHAR   szDebugLogSeparator[] = TEXT("=============================================================================\r\n");

    va_list     va;
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];


    //
    //  !!! UNICODE !!!
    //
    //
    if (0 != (APP_OPTIONSF_DEBUGLOG & gfuAppOptions))
    {
        if (NULL == pszFormat)
        {
            OutputDebugString(szDebugLogSeparator);
            return;
        }

        //
        //  format and display the string in a message box...
        //
        va_start(va, pszFormat);
#ifdef WIN32
        wvsprintf(ach, pszFormat, va);
#else
        wvsprintf(ach, pszFormat, (LPSTR)va);
#endif
        va_end(va);

        OutputDebugString(ach);
    }
} // AcmAppDebugLog()


//--------------------------------------------------------------------------;
//  
//  int MEditPrintF
//  
//  Description:
//      This function is used to print formatted text into a Multiline
//      Edit Control as if it were a standard console display. This is
//      a very easy way to display small amounts of text information
//      that can be scrolled and copied to the clip-board.
//  
//  Arguments:
//      HWND hedit: Handle to a Multiline Edit control.
//  
//      PTSTR pszFormat: Pointer to any valid format for wsprintf. If
//      this argument is NULL, then the Multiline Edit Control is cleared
//      of all text.
//
//
//  Return (int):
//      Returns the number of characters written into the edit control.
//
//  Notes:
//      The pszFormat string can contain combinations of escapes that 
//      modify the default behaviour of this function. Escapes are single
//      character codes placed at the _beginning_ of the format string.
//
//      Current escapes defined are:
//
//      ~   :   Suppresses the default CR/LF added to the end of the 
//              printed line. Since the most common use of this function
//              is to output a whole line of text with a CR/LF, that is
//              the default.
//
//      `   :   Suppresses logging to the debug terminal (regardless of
//              the global debug log options flag).
//
//  
//--------------------------------------------------------------------------;

int FNCGLOBAL MEditPrintF
(
    HWND                    hedit,
    PTSTR                   pszFormat,
    ...
)
{
    static  TCHAR   szCRLF[]              = TEXT("\r\n");

    va_list     va;
    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    int         n;
    BOOL        fCRLF;
    BOOL        fDebugLog;

    //
    //  default the escapes
    //
    fCRLF     = TRUE;
    fDebugLog = TRUE;


    //
    //  if the pszFormat argument is NULL, then just clear all text in
    //  the edit control..
    //
    if (NULL == pszFormat)
    {
        SetWindowText(hedit, gszNull);

        AcmAppDebugLog(NULL);

        return (0);
    }

    //
    //  format and display the string in the window... first search for
    //  escapes to modify default behaviour.
    //
    for (;;)
    {
        switch (*pszFormat)
        {
            case '~':
                fCRLF = FALSE;
                pszFormat++;
                continue;

            case '`':
                fDebugLog = FALSE;
                pszFormat++;
                continue;
        }

        break;
    }

    va_start(va, pszFormat);
#ifdef WIN32
    n = wvsprintf(ach, pszFormat, va);
#else
    n = wvsprintf(ach, pszFormat, (LPSTR)va);
#endif
    va_end(va);

    Edit_SetSel(hedit, (WPARAM)-1, (LPARAM)-1);
    Edit_ReplaceSel(hedit, ach);

    if (fDebugLog)
    {
        AcmAppDebugLog(ach);
    }

    if (fCRLF)
    {
        Edit_SetSel(hedit, (WPARAM)-1, (LPARAM)-1);
        Edit_ReplaceSel(hedit, szCRLF);

        if (fDebugLog)
        {
            AcmAppDebugLog(szCRLF);
        }
    }

    return (n);
} // MEditPrintF()


//--------------------------------------------------------------------------;
//
//  BOOL AppGetFileTitle
//
//  Description:
//      This function extracts the file title from a file path and returns
//      it in the caller's specified buffer.
//
//  Arguments:
//      PTSTR pszFilePath: Pointer to null terminated file path.
//
//      PTSTR pszFileTitle: Pointer to buffer to receive the file title.
//
//  Return (BOOL):
//      Always returns TRUE. But should return FALSE if this function
//      checked for bogus values, etc.
//
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppGetFileTitle
(
    PTSTR                   pszFilePath,
    PTSTR                   pszFileTitle
)
{
    #define IS_SLASH(c)     ('/' == (c) || '\\' == (c))

    PTSTR       pch;

    //
    //  scan to the end of the file path string..
    //
    for (pch = pszFilePath; '\0' != *pch; pch++)
        ;

    //
    //  now scan back toward the beginning of the string until a slash (\),
    //  colon, or start of the string is encountered.
    //
    while ((pch >= pszFilePath) && !IS_SLASH(*pch) && (':' != *pch))
    {
        pch--;
    }

    //
    //  finally, copy the 'title' into the destination buffer.. skip ahead
    //  one char since the above loop steps back one too many chars...
    //
    lstrcpy(pszFileTitle, ++pch);

    return (TRUE);
} // AppGetFileTitle()


//--------------------------------------------------------------------------;
//
//  BOOL AppGetFileName
//
//  Description:
//      This function is a wrapper for the Get[Open/Save]FileName commdlg
//      chooser dialogs. Based on the fuFlags argument, this function will
//      display the appropriate chooser dialog and return the result.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for chooser dialog.
//
//      PTSTR pszFilePath: Pointer to buffer to receive the file path.
//
//      PTSTR pszFileTitle: Pointer to buffer to receive the file title.
//      This argument may be NULL, in which case no title will be returned.
//
//      UINT fuFlags:
//
//  Return (BOOL):
//      The return value is TRUE if a file was chosen. It is FALSE if the
//      user canceled the operation.
//
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppGetFileName
(
    HWND                    hwnd,
    PTSTR                   pszFilePath,
    PTSTR                   pszFileTitle,
    UINT                    fuFlags
)
{
    #define APP_OFN_FLAGS_SAVE  (OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT)
    #define APP_OFN_FLAGS_OPEN  (OFN_HIDEREADONLY | OFN_FILEMUSTEXIST)

    TCHAR               szExtDefault[APP_MAX_EXT_DEFAULT_CHARS];
    TCHAR               szExtFilter[APP_MAX_EXT_FILTER_CHARS];
    OPENFILENAME        ofn;
    BOOL                f;
    PTCHAR              pch;


    //
    //  get the extension filter and default extension for this application
    //
    LoadString(ghinst, IDS_OFN_EXT_DEF, szExtDefault, SIZEOF(szExtDefault));
    LoadString(ghinst, IDS_OFN_EXT_FILTER, szExtFilter, SIZEOF(szExtFilter));


    //
    //  NOTE! building the filter string for the OPENFILENAME structure
    //  is a bit more difficult when dealing with Unicode and C8's new
    //  optimizer. it joyfully removes literal '\0' characters from
    //  strings that are concatted together. if you try making each
    //  string separate (array of pointers to strings), the compiler
    //  will dword align them... etc, etc.
    //
    //  if you can think of a better way to build the filter string
    //  for common dialogs and still work in Win 16 and Win 32 [Unicode]
    //  i'd sure like to hear about it...
    //
    for (pch = &szExtFilter[0]; '\0' != *pch; pch++)
    {
        if ('!' == *pch)
            *pch = '\0';
    }

    //
    //  initialize the OPENFILENAME members
    //
    memset(&ofn, 0, sizeof(OPENFILENAME));

    pszFilePath[0]          = '\0';
    if (pszFileTitle)
        pszFileTitle[0]     = '\0';

    ofn.lStructSize         = sizeof(OPENFILENAME);
    ofn.hwndOwner           = hwnd;
    ofn.lpstrFilter         = szExtFilter;
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0L;
    ofn.nFilterIndex        = 1L;
    ofn.lpstrFile           = pszFilePath;
    ofn.nMaxFile            = APP_MAX_FILE_PATH_CHARS;
    ofn.lpstrFileTitle      = pszFileTitle;
    ofn.nMaxFileTitle       = pszFileTitle ? APP_MAX_FILE_TITLE_CHARS : 0;
    if (fuFlags & APP_GETFILENAMEF_SAVE)
    {
        ofn.lpstrInitialDir = gszInitialDirSave;
    }
    else
    {
        ofn.lpstrInitialDir = gszInitialDirOpen;
    }
    ofn.nFileOffset         = 0;
    ofn.nFileExtension      = 0;
    ofn.lpstrDefExt         = szExtDefault;

    //
    //  if the fuFlags.APP_GETFILENAMEF_SAVE bit is set, then call
    //  GetSaveFileName() otherwise call GetOpenFileName(). why commdlg was
    //  designed with two separate functions for save and open only clark
    //  knows.
    //
    if (fuFlags & APP_GETFILENAMEF_SAVE)
    {
        ofn.Flags = APP_OFN_FLAGS_SAVE;
        f = GetSaveFileName(&ofn);
        if (f)
        {
            if (NULL != pszFilePath)
            {
                lstrcpy(gszInitialDirSave, pszFilePath);

                pch = &gszInitialDirSave[lstrlen(gszInitialDirSave) - 1];
                for ( ; gszInitialDirSave != pch; pch--)
                {
                    if ('\\' == *pch)
                    {
                        *pch = '\0';
                        break;
                    }
                }
            }
        }
    }
    else
    {
        ofn.Flags = APP_OFN_FLAGS_OPEN;
        f = GetOpenFileName(&ofn);
        if (f)
        {
            if (NULL != pszFilePath)
            {
                lstrcpy(gszInitialDirOpen, pszFilePath);

                pch = &gszInitialDirOpen[lstrlen(gszInitialDirOpen) - 1];
                for ( ; gszInitialDirOpen != pch; pch--)
                {
                    if ('\\' == *pch)
                    {
                        *pch = '\0';
                        break;
                    }
                }
            }
        }
    }

    return (f);
} // AppGetFileName()


//--------------------------------------------------------------------------;
//
//  BOOL AppTitle
//
//  Description:
//      This function formats and sets the title text of the application's
//      window.
//
//  Arguments:
//      HWND hwnd: Handle to application window to set title text for.
//
//      PTSTR pszFileTitle: Pointer to file title to display.
//
//  Return (BOOL):
//      The return value is always TRUE.
//
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppTitle
(
    HWND                    hwnd,
    PTSTR                   pszFileTitle
)
{
    static  TCHAR   szFormatTitle[]     = TEXT("%s - %s");

    TCHAR       ach[APP_MAX_FILE_PATH_CHARS];

    //
    //  format the title text as 'AppName - FileTitle'
    //
    wsprintf(ach, szFormatTitle, (LPSTR)gszAppName, (LPSTR)pszFileTitle);
    SetWindowText(hwnd, ach);

    return (TRUE);
} // AppTitle()


//--------------------------------------------------------------------------;
//
//  BOOL AppFileNew
//
//  Description:
//      This function is called to handle the IDM_FILE_NEW message. It is
//      responsible for clearing the working area for a new unnamed file.
//
//  Arguments:
//      HWND hwnd: Handle to application window.
//
//      PACMAPPFILEDESC paafd: Pointer to current file descriptor.
//
//  Return (BOOL):
//      The return value is TRUE if the working area was cleared and is
//      ready for new stuff. The return value is FALSE if the user canceled
//      the operation.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppFileNew
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd,
    BOOL                    fCreate
)
{
    BOOL                f;

    if (fCreate)
    {
        f = AcmAppFileNew(hwnd, paafd);
        if (!f)
            return (FALSE);
    }
    else
    {
        //
        //  if there is currently a file path, then we have to do some real
        //  work...
        //
        if ('\0' != paafd->szFilePath[0])
        {
            f = AcmAppFileNew(hwnd, paafd);
            if (!f)
                return (FALSE);
        }

        //
        //  blow away the old file path and title; set the window title
        //  and return success
        //
        lstrcpy(paafd->szFilePath, gszFileUntitled);
        lstrcpy(paafd->szFileTitle, gszFileUntitled);
    }

    AppTitle(hwnd, paafd->szFileTitle);

    AcmAppDisplayFileProperties(hwnd, paafd);

    return (TRUE);
} // AppFileNew()


//--------------------------------------------------------------------------;
//
//  BOOL AppFileOpen
//
//  Description:
//      This function handles the IDM_FILE_OPEN message. It is responsible
//      for getting a new file name from the user and opening that file
//      if possible.
//
//  Arguments:
//      HWND hwnd: Handle to application window.
//
//      PACMAPPFILEDESC paafd: Pointer to current file descriptor.
//
//  Return (BOOL):
//      The return value is TRUE if a new file was selected and opened.
//      It is FALSE if the user canceled the operation.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL AppFileOpen
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd
)
{
    TCHAR               szFilePath[APP_MAX_FILE_PATH_CHARS];
    TCHAR               szFileTitle[APP_MAX_FILE_TITLE_CHARS];
    BOOL                f;

    //
    //  first test for a modified file that has not been saved. if the
    //  return value is FALSE we should cancel the File.Open operation.
    //
    f = AcmAppFileSaveModified(hwnd, paafd);
    if (!f)
        return (FALSE);


    //
    //  get the file name of the new file into temporary buffers (so
    //  if we fail to open it we can back out cleanly).
    //
    f = AppGetFileName(hwnd, szFilePath, szFileTitle, APP_GETFILENAMEF_OPEN);
    if (!f)
        return (FALSE);


    //!!!
    //  read the new file...
    //
    lstrcpy(paafd->szFilePath, szFilePath);
    lstrcpy(paafd->szFileTitle, szFileTitle);

    f = AcmAppFileOpen(hwnd, paafd);
    if (f)
    {
        //
        //  set the window title text...
        //
        AppTitle(hwnd, szFileTitle);
        AcmAppDisplayFileProperties(hwnd, paafd);
    }

    return (f);
} // AppFileOpen()


//--------------------------------------------------------------------------;
//
//  BOOL AppFileSave
//
//  Description:
//      This function handles the IDM_FILE_SAVE[AS] messages. It is
//      responsible for saving the current file. If a file name needs
//      to be specified then the save file dialog is displayed.
//
//  Arguments:
//      HWND hwnd: Handle to application window.
//
//      PACMAPPFILEDESC paafd: Pointer to current file descriptor.
//
//      BOOL fSaveAs: TRUE if the save file chooser should be displayed
//      before saving the file. FALSE if should operate like File.Save.
//
//  Return (BOOL):
//      The return value is TRUE if the file was saved. It is FALSE if the
//      user canceled the operation or the file does not need saved.
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppFileSave
(
    HWND                    hwnd,
    PACMAPPFILEDESC         paafd,
    BOOL                    fSaveAs
)
{
    TCHAR               szFilePath[APP_MAX_FILE_PATH_CHARS];
    TCHAR               szFileTitle[APP_MAX_FILE_TITLE_CHARS];
    BOOL                f;

    //
    //
    //
    lstrcpy(szFilePath, paafd->szFilePath);
    lstrcpy(szFileTitle, paafd->szFileTitle);


    //
    //  check if we should bring up the save file chooser dialog...
    //
    if (fSaveAs || (0 == lstrcmp(paafd->szFileTitle, gszFileUntitled)))
    {
        //
        //  get the file name for saving the data to into temporary
        //  buffers (so if we fail to save it we can back out cleanly).
        //
        f = AppGetFileName(hwnd, szFilePath, szFileTitle, APP_GETFILENAMEF_SAVE);
        if (!f)
            return (FALSE);
    }

    //
    //  save the file...
    //
    f = AcmAppFileSave(hwnd, paafd, szFilePath, szFileTitle, 0);
    if (f)
    {
        //
        //  changes have been saved, so clear the modified bit...
        //
        paafd->fdwState &= ~ACMAPPFILEDESC_STATEF_MODIFIED;

        AppTitle(hwnd, paafd->szFileTitle);

        AcmAppDisplayFileProperties(hwnd, paafd);
    }

    return (f);
} // AppFileSave()


//==========================================================================;
//
//  Main application window handling code...
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT AppInitMenuPopup
//
//  Description:
//      This function handles the WM_INITMENUPOPUP message. This message
//      is sent to the window owning the menu that is going to become
//      active. This gives an application the ability to modify the menu
//      before it is displayed (disable/add items, etc).
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP
//      message.
//
//      HMENU hmenu: Handle to the menu that is to become active.
//
//      int nItem: Specifies the zero-based relative position of the menu
//      item that invoked the popup menu.
//
//      BOOL fSysMenu: Specifies whether the popup menu is a System menu
//      (TRUE) or it is not a System menu (FALSE).
//
//  Return (LRESULT):
//      Returns zero if the message is processed.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppInitMenuPopup
(
    HWND                    hwnd,
    HMENU                   hmenu,
    int                     nItem,
    BOOL                    fSysMenu
)
{
    BOOL                f;
    int                 nSelStart;
    int                 nSelEnd;
    HWND                hedit;

    DPF(4, "AppInitMenuPopup(hwnd=%Xh, hmenu=%Xh, nItem=%d, fSysMenu=%d)",
            hwnd, hmenu, nItem, fSysMenu);

    //
    //  if the system menu is what got hit, succeed immediately... this
    //  application has no stuff in the system menu.
    //
    if (fSysMenu)
        return (0L);

    //
    //  initialize the menu that is being 'popped up'
    //
    switch (nItem)
    {
        case APP_MENU_ITEM_FILE:
            EnableMenuItem(hmenu, IDM_FILE_NEW,
                           (UINT)(gfAcmAvailable ? MF_ENABLED : MF_GRAYED));

            f = (NULL != gaafd.pwfx);
            EnableMenuItem(hmenu, IDM_FILE_SNDPLAYSOUND_PLAY,
                           (UINT)(f ? MF_ENABLED : MF_GRAYED));
            EnableMenuItem(hmenu, IDM_FILE_SNDPLAYSOUND_STOP,
                           (UINT)(f ? MF_ENABLED : MF_GRAYED));

            f = (NULL != gaafd.pwfx) && gfAcmAvailable;
            EnableMenuItem(hmenu, IDM_FILE_CONVERT,
                           (UINT)(f ? MF_ENABLED : MF_GRAYED));


            //
            //  if the file has been modified, then enable the File.Save
            //  menu
            //
            f = (0 != (gaafd.fdwState & ACMAPPFILEDESC_STATEF_MODIFIED));
            EnableMenuItem(hmenu, IDM_FILE_SAVE,
                           (UINT)(f ? MF_ENABLED : MF_GRAYED));

            // f = (NULL != gaafd.pwfx);
            EnableMenuItem(hmenu, IDM_FILE_SAVEAS,
                           (UINT)(f ? MF_ENABLED : MF_GRAYED));
            break;

        case APP_MENU_ITEM_EDIT:
            //
            //  check to see if something is selected in the display
            //  window and enable/disable Edit menu options appropriately
            //
            hedit = GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY);
            Edit_GetSelEx(hedit, &nSelStart, &nSelEnd);

            f = (nSelStart != nSelEnd);
            EnableMenuItem(hmenu, WM_COPY,  (UINT)(f ? MF_ENABLED : MF_GRAYED));
            break;

        case APP_MENU_ITEM_VIEW:
            EnableMenuItem(hmenu, IDM_VIEW_ACM_DRIVERS,
                           (UINT)(gfAcmAvailable ? MF_ENABLED : MF_GRAYED));
            break;


        case APP_MENU_ITEM_OPTIONS:
            f = (0 != waveInGetNumDevs());
            EnableMenuItem(hmenu, IDM_OPTIONS_WAVEINDEVICE,  (UINT)(f ? MF_ENABLED : MF_GRAYED));

            f = (0 != waveOutGetNumDevs());
            EnableMenuItem(hmenu, IDM_OPTIONS_WAVEOUTDEVICE, (UINT)(f ? MF_ENABLED : MF_GRAYED));

            //
            //  make sure the options that need a checkmark are checked..
            //
            f = (0 != (APP_OPTIONSF_AUTOOPEN & gfuAppOptions));
            CheckMenuItem(hmenu, IDM_OPTIONS_AUTOOPEN,
                          (UINT)(f ? MF_CHECKED : MF_UNCHECKED));

            f = (0 != (APP_OPTIONSF_DEBUGLOG & gfuAppOptions));
            CheckMenuItem(hmenu, IDM_OPTIONS_DEBUGLOG,
                          (UINT)(f ? MF_CHECKED : MF_UNCHECKED));
            break;
    }

    //
    //  we processed the message--return 0...
    //
    return (0L);
} // AppInitMenuPopup()


//--------------------------------------------------------------------------;
//
//  LRESULT AppCommand
//
//  Description:
//      This function handles the WM_COMMAND message.
//
//  Arguments:
//      HWND hwnd: Handle to window receiving the WM_COMMAND message.
//
//      int nId: Control or menu item identifier.
//
//      HWND hwndCtl: Handle of control if the message is from a control.
//      This argument is NULL if the message was not generated by a control.
//
//      UINT uCode: Notification code. This argument is 1 if the message
//      was generated by an accelerator. If the message is from a menu,
//      this argument is 0.
//
//  Return (LRESULT):
//      Returns zero if the message is processed.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppCommand
(
    HWND                    hwnd,
    int                     nId,
    HWND                    hwndCtl,
    UINT                    uCode
)
{
    BOOL                f;
    DWORD               dw;
    UINT                uDevId;

    switch (nId)
    {
        case IDM_FILE_NEW:
            AppFileNew(hwnd, &gaafd, TRUE);
            break;

        case IDM_FILE_OPEN:
            AppFileOpen(hwnd, &gaafd);
            break;

        case IDM_FILE_SAVE:
            AppFileSave(hwnd, &gaafd, FALSE);
            break;

        case IDM_FILE_SAVEAS:
            AppFileSave(hwnd, &gaafd, TRUE);
            break;


        case IDM_FILE_SNDPLAYSOUND_PLAY:
            if (NULL == gaafd.pwfx)
            {
                MessageBeep((UINT)-1);
                break;
            }

            AppHourGlass(TRUE);
            dw = timeGetTime();
            f  = sndPlaySound(gaafd.szFilePath, SND_ASYNC | SND_NODEFAULT);
            dw = timeGetTime() - dw;
            AppHourGlass(FALSE);

            if (0 != (APP_OPTIONSF_DEBUGLOG & gfuAppOptions))
            {
                AcmAppDebugLog(NULL);
                AcmAppDebugLog(TEXT("sndPlaySound(%s) took %lu milliseconds to %s.\r\n"),
                                (LPTSTR)gaafd.szFilePath,
                                dw,
                                f ? (LPTSTR)TEXT("succeed") : (LPTSTR)TEXT("fail"));
            }
            
            if (!f)
            {
                AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION,
                          TEXT("The file '%s' cannot be played by sndPlaySound."),
                          (LPSTR)gaafd.szFilePath);
            }
            break;

        case IDM_FILE_SNDPLAYSOUND_STOP:
            sndPlaySound(NULL, 0L);
            break;

        case IDM_FILE_CONVERT:
            AcmAppFileConvert(hwnd, &gaafd);
            break;


        case IDM_FILE_ABOUT:
            DialogBox(ghinst, DLG_ABOUT, hwnd, AboutDlgProc);
            break;

        case IDM_FILE_EXIT:
            FORWARD_WM_CLOSE(hwnd, SendMessage);
            break;


        case WM_COPY:
            //
            //  pass on edit messages received to the display window
            //
            SendMessage(GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY), nId, 0, 0L);
            break;

        case IDM_EDIT_SELECTALL:
            Edit_SetSel(GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY), 0, -1);
            break;


        case IDM_UPDATE:
            AcmAppFileOpen(hwnd, &gaafd);

            AcmAppDisplayFileProperties(hwnd, &gaafd);
            break;

        case IDM_VIEW_SYSTEMINFO:
            DialogBox(ghinst, DLG_AADETAILS, hwnd, AcmAppSystemInfoDlgProc);
            break;

        case IDM_VIEW_ACM_DRIVERS:
            DialogBox(ghinst, DLG_AADRIVERS, hwnd, AcmAppDriversDlgProc);
            break;


        case IDM_OPTIONS_WAVEINDEVICE:
            uDevId = DialogBoxParam(ghinst, DLG_AAWAVEDEVICE, hwnd,
                                    AcmAppWaveDeviceDlgProc,
                                    MAKELONG((WORD)guWaveInId, TRUE));

            if (uDevId != guWaveInId)
            {
                guWaveInId = uDevId;
                AcmAppDisplayFileProperties(hwnd, &gaafd);
            }
            break;

        case IDM_OPTIONS_WAVEOUTDEVICE:
            uDevId = DialogBoxParam(ghinst, DLG_AAWAVEDEVICE, hwnd,
                                    AcmAppWaveDeviceDlgProc,
                                    MAKELONG((WORD)guWaveOutId, FALSE));

            if (uDevId != guWaveOutId)
            {
                guWaveOutId = uDevId;
                AcmAppDisplayFileProperties(hwnd, &gaafd);
            }
            break;


        case IDM_OPTIONS_AUTOOPEN:
            gfuAppOptions ^= APP_OPTIONSF_AUTOOPEN;
            break;

        case IDM_OPTIONS_DEBUGLOG:
            gfuAppOptions ^= APP_OPTIONSF_DEBUGLOG;
            break;

        case IDM_OPTIONS_FONT:
            AcmAppChooseFont(hwnd);
            break;


        case IDM_PLAYRECORD:
            if (NULL == gaafd.pwfx)
            {
                f = AppFileNew(hwnd, &gaafd, TRUE);
                if (!f)
                    break;

                if (NULL == gaafd.pwfx)
                    break;
            }

            f = DialogBoxParam(ghinst, DLG_AAPLAYRECORD, hwnd,
                               AcmAppPlayRecord, (LPARAM)(LPVOID)&gaafd);
            if (f)
            {
                AcmAppFileOpen(hwnd, &gaafd);

                AcmAppDisplayFileProperties(hwnd, &gaafd);
            }
            break;
    }

    return (0L);
} // AppCommand()


//--------------------------------------------------------------------------;
//
//  BOOL AcmAppDlgProcDragDropContinue
//
//  Description:
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AcmAppDlgProcDragDropContinue
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    UINT                uId;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            AppSetWindowText(hwnd, TEXT("File %u of %u"), LOWORD(lParam), HIWORD(lParam));
            return (TRUE);

        case WM_COMMAND:
            uId = GET_WM_COMMAND_ID(wParam, lParam);
            if ((IDOK == uId) || (IDCANCEL == uId))
            {
                EndDialog(hwnd, uId);
            }
            break;
    }

    return (FALSE);
} // AcmAppDlgProcDragDropContinue()


//--------------------------------------------------------------------------;
//
//  LRESULT AppDropFiles
//
//  Description:
//      This function handles the WM_DROPFILES message. This message is
//      sent when files are 'dropped' on the window from file manager
//      (or other drag/drop servers made by ISV's that figured out the
//      undocumented internal workings of the SHELL).
//
//      A window must be registered to receive these messages either by
//      called DragAcceptFiles() or using CreateWindowEx() with the
//      WS_EX_ACCEPTFILES style bit.
//
//  Arguments:
//      HWND hwnd: Handle to window receiving the message.
//
//      HDROP hdrop: Handle to drop structure.
//
//  Return (LRESULT):
//      Returns 0 if the message is processed.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppDropFiles
(
    HWND                    hwnd,
    HDROP                   hdrop
)
{
    TCHAR               szFilePath[APP_MAX_FILE_PATH_CHARS];
    UINT                cFiles;
    UINT                u;
    BOOL                f;
    int                 n;

    //
    //  first test for a file that has not been saved. if the return
    //  value is FALSE we should cancel the drop operation.
    //
    f = AcmAppFileSaveModified(hwnd, &gaafd);
    if (!f)
    {
        goto App_Drop_Files_Exit;
    }

    //
    //  get number of files dropped on our window
    //
    cFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0);

    DPF(4, "AppDropFiles(hwnd=%Xh, hdrop=%Xh)--cFiles=%u", hwnd, hdrop, cFiles);

    //
    //  step through each file and stop on the one the user wants or
    //  the last file (whichever comes first).
    //
    for (u = 0; u < cFiles; u++)
    {
        //
        //  get the next file name and try to open it--if not a valid
        //  file, then skip to the next one (if there is one).
        //
        DragQueryFile(hdrop, u, szFilePath, SIZEOF(szFilePath));


        //
        //  !!! destructive !!!
        //
        //  attempt to open the file
        //
        lstrcpy(gaafd.szFilePath, szFilePath);
        lstrcpy(gaafd.szFileTitle, gszNull);

        f = AcmAppFileOpen(hwnd, &gaafd);
        if (!f)
        {
            continue;
        }

        AppTitle(hwnd, gaafd.szFileTitle);
        AcmAppDisplayFileProperties(hwnd, &gaafd);

        //
        //  if this is NOT the last file in the list of files that are
        //  being dropped on us, then bring up a box asking if we should
        //  continue or stop where we are..
        //
        if ((cFiles - 1) != u)
        {
            n = DialogBoxParam(ghinst,
                               DLG_AADRAGDROP,
                               hwnd,
                               AcmAppDlgProcDragDropContinue,
                               MAKELPARAM((WORD)(u + 1), (WORD)cFiles));
            if (IDCANCEL == n)
                break;
        }
    }

    //
    //  tell the shell to release the memory it allocated for beaming
    //  the file name(s) over to us... return 0 to show we processed
    //  the message.
    //
App_Drop_Files_Exit:

    DragFinish(hdrop);
    return (0L);
} // AppDropFiles()


//--------------------------------------------------------------------------;
//
//  LRESULT AppSize
//
//  Description:
//      This function handles the WM_SIZE message for the application's
//      window. This message is sent to the application window after the
//      size has changed (but before it is painted).
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_SIZE message.
//
//      UINT fuSizeType: Specifies the type of resizing requested. This
//      argument is one of the following: SIZE_MAXIMIZED, SIZE_MINIMIZED,
//      SIZE_RESTORED, SIZE_MAXHIDE, or SIZE_MAXSHOW.
//
//      int nWidth: Width of the new client area for the window.
//
//      int nHeight: Height of the new client area for the window.
//
//  Return (LRESULT):
//      Returns zero if the application processes the message.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppSize
(
    HWND                    hwnd,
    UINT                    fuSizeType,
    int                     nWidth,
    int                     nHeight
)
{
    HWND                hedit;
    RECT                rc;

    DPF(4, "AppSize(hwnd=%Xh, fuSizeType=%u, nWidth=%d, nHeight=%d)",
            hwnd, fuSizeType, nWidth, nHeight);

    //
    //  unless this application is the one being resized then don't waste
    //  time computing stuff that doesn't matter. this applies to being
    //  minimized also because this application does not have a custom
    //  minimized state.
    //
    if ((SIZE_RESTORED != fuSizeType) && (SIZE_MAXIMIZED != fuSizeType))
        return (0L);


    //
    //
    //
    GetClientRect(hwnd, &rc);
    InflateRect(&rc, 1, 1);

    hedit = GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY);
    SetWindowPos(hedit,
                 NULL,
                 rc.left,
                 rc.top,
                 rc.right - rc.left,
                 rc.bottom - rc.top,
                 SWP_NOZORDER);


    //
    //  we processed the message..
    //
    return (0L);
} // AppSize()


//--------------------------------------------------------------------------;
//  
//  LRESULT AcmAppNotify
//  
//  Description:
//  
//  
//  Arguments:
//  
//  Return (LRESULT):
//  
//  
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AcmAppNotify
(
    HWND                hwnd,
    WPARAM              wParam,
    LPARAM              lParam
)
{
    HWND                hwndNext;

    DPF(1, "AcmAppNotify: hwnd=%.04Xh, wParam=%.04Xh, lParam2=%.08lXh",
        hwnd, wParam, lParam);

    //
    //
    //
    hwndNext = GetWindow(hwnd, GW_HWNDFIRST);
    while (NULL != hwndNext)
    {
        if (GetParent(hwndNext) == hwnd)
        {
            SendMessage(hwndNext, WM_ACMAPP_ACM_NOTIFY, wParam, lParam);
        }

        hwndNext = GetWindow(hwndNext, GW_HWNDNEXT);
    }


    //
    //  now force an update to our display in case driver [dis/en]able
    //  changed what is playable/recordable.
    //
    AcmAppDisplayFileProperties(hwnd, &gaafd);


    //
    //
    //
    return (1L);
} // AcmAppNotify()


//--------------------------------------------------------------------------;
//
//  LRESULT AppWndProc
//
//  Description:
//      This is the main application window procedure.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (LRESULT):
//      The return value depends on the message that is being processed.
//
//--------------------------------------------------------------------------;

LRESULT FNEXPORT AppWndProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    LRESULT             lr;

    switch (uMsg)
    {
        case WM_CREATE:
            lr = HANDLE_WM_CREATE(hwnd, wParam, lParam, AppCreate);
            return (lr);

        case WM_WININICHANGE:
            HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, AppWinIniChange);
            return (0L);

        case WM_INITMENUPOPUP:
            HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, AppInitMenuPopup);
            return (0L);

        case WM_COMMAND:
            lr = HANDLE_WM_COMMAND(hwnd, wParam, lParam, AppCommand);
            return (lr);

        case WM_DROPFILES:
            //
            //  some windowsx.h files have a messed up message cracker for
            //  WM_DROPFILES. because this is a sample app, i don't want
            //  people having trouble with bogus windowsx.h files, so crack
            //  the message manually... you should use the message cracker
            //  if you know your windowsx.h file is good.
            //
            //  lr = HANDLE_WM_DROPFILES(hwnd, wParam, lParam, AppDropFiles);
            //
            lr = AppDropFiles(hwnd, (HDROP)wParam);
            return (lr);

        case WM_SIZE:
            //
            //  handle what we want for sizing, and then always call the
            //  default handler...
            //
            HANDLE_WM_SIZE(hwnd, wParam, lParam, AppSize);
            break;

        case WM_QUERYENDSESSION:
            lr = HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, AppQueryEndSession);
            return (lr);

        case WM_ENDSESSION:
            HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, AppEndSession);
            return (0L);

        case WM_CLOSE:
            HANDLE_WM_CLOSE(hwnd, wParam, lParam, AppClose);
            return (0L);

        case WM_DESTROY:
            PostQuitMessage(0);
            return (0L);

        case WM_ACMAPP_ACM_NOTIFY:
            AcmAppNotify(hwnd, wParam, lParam);
            return (0L);
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
} // AppWndProc()


//==========================================================================;
//
//  Main entry and message dispatching code
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int WinMain
//
//  Description:
//      This function is called by the system as the initial entry point
//      for a Windows application.
//
//  Arguments:
//      HINSTANCE hinst: Identifies the current instance of the
//      application.
//
//      HINSTANCE hinstPrev: Identifies the previous instance of the
//      application (NULL if first instance). For Win 32, this argument
//      is _always_ NULL.
//
//      LPSTR pszCmdLine: Points to null-terminated unparsed command line.
//      This string is strictly ANSI regardless of whether the application
//      is built for Unicode. To get the Unicode equivalent call the
//      GetCommandLine() function (Win 32 only).
//
//      int nCmdShow: How the main window for the application is to be
//      shown by default.
//
//  Return (int):
//      Returns result from WM_QUIT message (in wParam of MSG structure) if
//      the application is able to enter its message loop. Returns 0 if
//      the application is not able to enter its message loop.
//
//--------------------------------------------------------------------------;

int PASCAL WinMain
(
    HINSTANCE               hinst,
    HINSTANCE               hinstPrev,
    LPSTR                   pszCmdLine,
    int                     nCmdShow
)
{
    int                 nResult;
    HWND                hwnd;
    MSG                 msg;
    HACCEL              haccl;

    DbgInitialize(TRUE);

    //
    //  our documentation states that WinMain is supposed to return 0 if
    //  we do not enter our message loop--so assume the worst...
    //
    nResult = 0;

    //
    //  make our instance handle global for convenience..
    //
    ghinst = hinst;

    //
    //  init some stuff, create window, etc.. note the explicit cast of
    //  pszCmdLine--this is to mute a warning (and an ugly ifdef) when
    //  compiling for Unicode. see AppInit() for more details.
    //
    hwnd = AppInit(hinst, hinstPrev, (LPTSTR)pszCmdLine, nCmdShow);
    if (hwnd)
    {
        haccl = LoadAccelerators(hinst, ACCEL_APP);

        //
        //  dispatch messages
        //
        while (GetMessage(&msg, NULL, 0, 0))
        {
            //
            //  do all the special stuff required for this application
            //  when dispatching messages..
            //
            if (!TranslateAccelerator(hwnd, haccl, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        //
        //  return result of WM_QUIT message.
        //
        nResult = (int)msg.wParam;
    }

    //
    //  shut things down, clean up, etc.
    //
    nResult = AppExit(hinst, nResult);

    return (nResult);
} // WinMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
        DebugBreak();
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\appport.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  appport.h
//
//  Description:
//      Win 16/32 Portability Stuff
//
//      This file contains common macros to help with writing code that
//      cross compiles between Win 32 and Win 16. This file should be
//      included _after_ windows.h and windowsx.h.
//
//==========================================================================;

#ifndef _INC_APPPORT
#define _INC_APPPORT                // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 32
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
    #ifndef FNLOCAL
    #ifdef DEBUG
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
    #else
        #define FNLOCAL     static _stdcall
        #define FNCLOCAL    static _stdcall
    #endif
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif


    #include <tchar.h>


    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
        ((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    #define HUGE

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif

    #define BCODE
    #define BDATA
    #define BSTACK

    //
    //  win32 apps [usually] don't have to worry about 'huge' data
    //
    #if !defined hmemcpy
	#define hmemcpy	memcpy
    #endif
#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
    #ifdef DEBUG
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
    #else
        #define FNLOCAL     static NEAR PASCAL
        #define FNCLOCAL    static NEAR _cdecl
    #endif
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL _loadds
        #define FNEXPORT    FAR PASCAL _export
    #else
        #define FNWCALLBACK FAR PASCAL _export
        #define FNEXPORT    FAR PASCAL _export
    #endif
    #endif


    #ifndef _tcstod
        #define _tcstod     strtod
        #define _tcstol     strtol
        #define _tcstoul    strtoul
    #endif


    //
    //
    //
    //
    #ifndef NOXACTALLC
        #undef GlobalAllocPtr
        #undef GlobalReAllocPtr

        static __inline LPVOID GlobalExactLock(HGLOBAL hg, DWORD cb)
        {
            return (LPVOID)((hg) ? (LPVOID)((LPBYTE)GlobalLock(hg) + (GlobalSize(hg) - (cb))) : (LPVOID)NULL);
        }

        #define GlobalAllocPtr(flags, cb)   \
                    (GlobalExactLock(GlobalAlloc((flags), (cb)), (cb)))
        #define GlobalReAllocPtr(lp, cbNew, flags)  \
                    (GlobalUnlockPtr(lp), GlobalExactLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags)), (cbNew)))
    #endif


    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))
    #define BDATA           _based(_segname("_DATA"))
    #define BSTACK          _based(_segname("_STACK"))

    #define HUGE            _huge

    #define UNALIGNED


    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #ifndef _MMRESULT_
    #define _MMRESULT_
    typedef UINT        MMRESULT;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
        DWORD   dw;                                                 \
        dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
        *pnE = (int)HIWORD(dw);                                     \
        *pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_APPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#if ( defined(WIN32) || defined(_WIN32) ) && !defined(WIN4)

    //
    //  Compile for Daytona - use __int64 support on C9.
    //


    INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
    {
        return (LONG)( ((LONGLONG)a*b) / c );
    }


    INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( ((DWORDLONG)a*b) / c );
    }


    INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (((DWORDLONG)a*b)+c/2) / c );
    }


    INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (((DWORDLONG)a*b)+c-1) / c );
    }


#else

    //
    //  Compile for Win16 or Chicago - either way, we can use X86 assembly.
    //
    #pragma warning(disable:4035 4704)

#ifdef WIN32

    //
    //  Compile for 32-bit Chicago - we can use i386 assembly.
    //
    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
	_asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     imul    ebx              //  imul ebx
        _asm     idiv    ecx              //  idiv ecx
	_asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     shr     ebx,1            //  sar  ebx,1
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     dec     ebx              //  dec  ebx
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRD32()

#else

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //
    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

#endif

    #pragma warning(default:4035 4704)


#endif

//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "ACMAPP"    // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//  #pragma message(REMIND("this is a reminder"))
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define DEBUG_QUOTE(x)      #x
#define DEBUG_QQUOTE(y)     DEBUG_QUOTE(y)
#define REMIND(sz)          __FILE__ "(" DEBUG_QQUOTE(__LINE__) ") : " sz

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\tlb.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//--------------------------------------------------------------------------;
//
//  tlb.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_TLB
#define _INC_TLB                    // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifdef WIN32
    //
    //  for compiling Unicode
    //
    #ifndef SIZEOF
    #ifdef UNICODE
        #define SIZEOF(x)       (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)       sizeof(x)
    #endif
    #endif
#else
    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef TEXT
    #define TEXT(a)             a
    #endif

    #ifndef SIZEOF
    #define SIZEOF(x)           sizeof(x)
    #endif

    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif
#endif


//
//
//
//
typedef struct tTABBEDLISTBOX
{
    HWND            hlb;

    int             nFontHeight;
    RECT            rc;

    UINT            uTabStops;
    PINT            panTabs;
    PINT            panTitleTabs;

    UINT            cchTitleText;
    PTSTR           pszTitleText;

} TABBEDLISTBOX, *PTABBEDLISTBOX;


#define TLB_MAX_TAB_STOPS           20      // max number of columns
#define TLB_MAX_TITLE_CHARS         512


//
//
//
//
//
BOOL FAR PASCAL TlbPaint
(
    PTABBEDLISTBOX          ptlb,
    HWND                    hwnd,
    HDC                     hdc
);

BOOL FAR PASCAL TlbMove
(
    PTABBEDLISTBOX          ptlb,
    PRECT                   prc,
    BOOL                    fRedraw
);

HFONT FAR PASCAL TlbSetFont
(
    PTABBEDLISTBOX          ptlb,
    HFONT                   hfont,
    BOOL                    fRedraw
);

BOOL FAR PASCAL TlbSetTitleAndTabs
(
    PTABBEDLISTBOX          ptlb,
    PTSTR                   pszTitleFormat,
    BOOL                    fRedraw
);

PTABBEDLISTBOX FAR PASCAL TlbDestroy
(
    PTABBEDLISTBOX          ptlb
);

PTABBEDLISTBOX FAR PASCAL TlbCreate
(
    HWND                    hwnd,
    int                     nId,
    PRECT                   prc
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_TLB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\tlb.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  tlb.c
//
//  Description:
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <memory.h>

#ifdef WIN32
    #include <tchar.h>
#else
    #ifndef _tcstod
        #define _tcstod     strtod
        #define _tcstol     strtol
        #define _tcstoul    strtoul
    #endif
#endif


#include "tlb.h"


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  int GetRealTextMetrics
//  
//  Description:
//      This function gets the textmetrics of the font currently selected
//      into the hdc.  It returns the average char width as the return value.
//
//      This function computes the average character width correctly by
//      using GetTextExtent() on the string "abc...xzyABC...XYZ" which works
//      out much better for proportional fonts. This is also necessary
//      for correct alignment between dialog and client units.
//
//      Note that this function returns the same TEXTMETRIC values that
//      GetTextMetrics() does, it simply has a different return value.
//
//  Arguments:
//      HDC hdc:
//  
//      LPTEXTMETRIC ptm:
//  
//  Return (int):
//  
//  
//--------------------------------------------------------------------------;

int FAR PASCAL GetRealTextMetrics
(
    HDC                     hdc,
    LPTEXTMETRIC            ptm
)
{
    TCHAR               achAlphabet[26 * 2];    // upper and lower case
    SIZE                sSize;
    UINT                u;
    int                 nAveWidth;

    //
    //  get the text metrics of the current font. note that GetTextMetrics
    //  gets the incorrect nAveCharWidth value for proportional fonts.
    //
    GetTextMetrics(hdc, ptm);
    nAveWidth = ptm->tmAveCharWidth;

    //
    //  if it's not a variable pitch font GetTextMetrics was correct
    //  so just return.
    //
    if (ptm->tmPitchAndFamily & FIXED_PITCH)
    {
        //
        //
        //
        for (u = 0; u < 26; u++)
        {
            achAlphabet[u]      = (TCHAR)(u + (UINT)'a');
            achAlphabet[u + 26] = (TCHAR)(u + (UINT)'A');
        }

        //
        //  round up
        //
        GetTextExtentPoint(hdc, achAlphabet, SIZEOF(achAlphabet), &sSize);
        nAveWidth = ((sSize.cx / 26) + 1) / 2;
    }

    //
    //  return the calculated average char width
    //
    return (nAveWidth);
} // GetRealTextMetrics()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL TlbPaint
//  
//  Description:
//  
//  
//  Arguments:
//      PTABBEDLISTBOX ptlb:
//  
//      HWND hwnd:
//  
//      HDC hdc:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FAR PASCAL TlbPaint
(
    PTABBEDLISTBOX          ptlb,
    HWND                    hwnd,
    HDC                     hdc
)
{
    RECT                rc;
    HFONT               hfont;
    COLORREF            crBk;
    COLORREF            crText;
    int                 nHeight;

    //
    //
    //
    hfont = GetWindowFont(ptlb->hlb);
    if (NULL == hfont)
        hfont = GetStockFont(SYSTEM_FONT);

    hfont = (HFONT)SelectObject(hdc, (HGDIOBJ)hfont);

    crBk   = SetBkColor(hdc, GetSysColor(COLOR_ACTIVECAPTION));
    crText = SetTextColor(hdc, GetSysColor(COLOR_CAPTIONTEXT));

    //
    //  compute bounding rect for title only
    //
    rc = ptlb->rc;
    nHeight = min(ptlb->nFontHeight, rc.bottom - rc.top);
    rc.bottom = rc.top + nHeight;

    ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL);
    TabbedTextOut(hdc, rc.left, rc.top,
                  ptlb->pszTitleText,
                  ptlb->cchTitleText,
                  ptlb->uTabStops,
                  ptlb->panTitleTabs, 0);

    //
    //  restore the dc
    //
    SetBkColor(hdc, crBk);
    SetTextColor(hdc, crText);

    SelectObject(hdc, hfont);

    return (TRUE);
} // TlbPaint()


//--------------------------------------------------------------------------;
//  
//  BOOL TlbMove
//  
//  Description:
//  
//  
//  Arguments:
//      PTABBEDLISTBOX ptlb:
//  
//      PRECT prc:
//  
//      BOOL fRedraw:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FAR PASCAL TlbMove
(
    PTABBEDLISTBOX          ptlb,
    PRECT                   prc,
    BOOL                    fRedraw
)
{
    RECT                rc;
    int                 nHeight;
    HWND                hwnd;


    hwnd = GetParent(ptlb->hlb);

    //
    //  invalidate only the region occupied by the current title bar. this
    //  will make sure that area gets repainted. the listbox portion will
    //  be invalidated correctly by the SetWindowPos() function below..
    //
    rc = ptlb->rc;

    nHeight = min(ptlb->nFontHeight, rc.bottom - rc.top);
    rc.bottom = rc.top + nHeight;

    InvalidateRect(hwnd, &rc, TRUE);


    //
    //  now move the listbox--we modify values in the rect structure, so
    //  copy to local storage
    //
    rc = *prc;

    //
    //  leave room at the top of the bounding rect for the title text
    //
    nHeight = min(ptlb->nFontHeight, rc.bottom - rc.top);
    rc.top += nHeight;

    SetWindowPos(ptlb->hlb, NULL, rc.left, rc.top, rc.right - rc.left,
                 rc.bottom - rc.top, SWP_NOZORDER);

    //
    //  save the new location and invalidate the area so it is repainted
    //
    ptlb->rc = *prc;
    InvalidateRect(hwnd, prc, TRUE);

    if (fRedraw)
    {
        UpdateWindow(hwnd);
    }

    return (TRUE);
} // TlbMove()


//--------------------------------------------------------------------------;
//  
//  BOOL TlbRecalcTabs
//  
//  Description:
//  
//  
//  Arguments:
//      PTABBEDLISTBOX ptlb:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL NEAR PASCAL TlbRecalcTabs
(
    PTABBEDLISTBOX          ptlb
)
{
    static TCHAR szGonzoThing[] = TEXT("M");

    int                 anTabsList[TLB_MAX_TAB_STOPS];
    HDC                 hdc;
    HFONT               hfont;
    TEXTMETRIC          tm;
    int                 nAveCharWidth;

    UINT                u;
    int                 nWidth;
    int                 nPrevTabTitle;
    int                 nPrevTabList;
    SIZE                sSize;


    //
    //
    //
    hdc = GetDC(NULL);
    {
        //
        //  get the average char width and height of the current font so we
        //  can compute tabs correctly. note that GetTextMetrics is pretty
        //  bogus when it comes to the average char width--it normally gives
        //  you the width of the character 'x'. what it should be is the
        //  average width of all capitals and lower case letters..
        //
        hfont = GetWindowFont(ptlb->hlb);
        if (NULL == hfont)
            hfont = GetStockFont(SYSTEM_FONT);

        hfont = (HFONT)SelectObject(hdc, (HGDIOBJ)hfont);

#if 0
        GetTextMetrics(hdc, &tm);
        nAveCharWidth = tm.tmAveCharWidth;
#else
        nAveCharWidth = GetRealTextMetrics(hdc, &tm);
#endif
        ptlb->nFontHeight = tm.tmHeight;


        //
        //
        //
        GetTextExtentPoint(hdc, szGonzoThing, 1, &sSize);


        //
        //
        //
        hfont = (HFONT)SelectObject(hdc, (HGDIOBJ)hfont);
    }
    ReleaseDC(NULL, hdc);


    //
    //  calculate the width of each column
    //
    nPrevTabTitle = 0;
    nPrevTabList  = 0;
    for (u = 0; u < ptlb->uTabStops; u++)
    {
//      nWidth = nAveCharWidth * ptlb->panTabs[u] + nAveCharWidth * 2;
        nWidth = sSize.cx * ptlb->panTabs[u] + (sSize.cx * 2);

        //
        //  set tabstop for title text--this is in client units
        //  for TabbedTextOut in TlbPaint
        //
        ptlb->panTitleTabs[u] = nPrevTabTitle + nWidth;
        nPrevTabTitle = ptlb->panTitleTabs[u];

        //
        //  set tabstop for listbox--this is in dialog units
        //
        anTabsList[u] = nPrevTabList + MulDiv(nWidth, 4, nAveCharWidth);
        nPrevTabList  = anTabsList[u];
    }


    //
    //  now setup the tabstops in the listbox
    //
    if (0 == ptlb->uTabStops)
    {
	ListBox_SetTabStops(ptlb->hlb, ptlb->uTabStops, NULL);
    }
    else
    {
	ListBox_SetTabStops(ptlb->hlb, ptlb->uTabStops, anTabsList);
    }

    return (TRUE);
} // TlbRecalcTabs()


//--------------------------------------------------------------------------;
//  
//  HFONT TlbSetFont
//  
//  Description:
//  
//  
//  Arguments:
//      PTABBEDLISTBOX ptlb:
//  
//      HFONT hfont:
//  
//      BOOL fRedraw:
//  
//  Return (HFONT):
//  
//  
//--------------------------------------------------------------------------;

HFONT FAR PASCAL TlbSetFont
(
    PTABBEDLISTBOX          ptlb,
    HFONT                   hfont,
    BOOL                    fRedraw
)
{
    HFONT               hfontOld;

    //
    //
    //
    hfontOld = GetWindowFont(ptlb->hlb);
    SetWindowFont(ptlb->hlb, hfont, FALSE);

    TlbRecalcTabs(ptlb);
    TlbMove(ptlb, &ptlb->rc, fRedraw);

    return (hfontOld);
} // TlbSetFont()


//--------------------------------------------------------------------------;
//  
//  BOOL TlbSetTitleAndTabs
//  
//  Description:
//      This function sets the title text and tab stops for a Tabbed List
//      Box (TLB). The pszTitleFormat specifies the title text for each
//      column along with the tabstop position for each column. The format
//      of this string is as follows:
//
//      <columnname1>\t<tab1>!<columnname2>
//
//      TCHAR   szTlbThings[] = TEXT("Index\t6!Code\t5!Name");
//
//
//  Arguments:
//      PTABBEDLISTBOX ptlb:
//  
//      PTSTR pszTitleFormat:
//
//      BOOL fRedraw:
//  
//  Return (BOOL):
//  
//  
//--------------------------------------------------------------------------;

BOOL FAR PASCAL TlbSetTitleAndTabs
(
    PTABBEDLISTBOX          ptlb,
    PTSTR                   pszTitleFormat,
    BOOL                    fRedraw
)
{
    TCHAR               szTitleText[TLB_MAX_TITLE_CHARS];
    int                 anTabs[TLB_MAX_TAB_STOPS];
    PTSTR               pch;
    PTSTR               pchTitleText;
    UINT                uTabStops;
    UINT                cchTitleText;
    HWND                hwnd;

    //
    //  parse the title format counting tab stops and actual size of title
    //  text
    //
    uTabStops    = 0;
    pchTitleText = szTitleText;
    for (pch = pszTitleFormat; '\0' != *pch; )
    {
        TCHAR       ch;

        //
        //  scan to tab
        //
        while ('\0' != (ch = *pch))
        {
            *pchTitleText++ = *pch++;

            if ('\t' == ch)
                break;
        }

        if ('\0' == ch)
            break;

        //
        //  grab the next tab stop value
        //
        anTabs[uTabStops] = (int)_tcstol(pch, NULL, 10);
        uTabStops++;

        //
        //  skip to start of next column name
        //
        while ('!' != *pch++)
            ;
    }


    //
    //  terminate the converted title text
    //
    *pchTitleText = '\0';
    cchTitleText = lstrlen(szTitleText);

    //
    //  free the memory used for the previous tab stops and title text
    //
    if (NULL != ptlb->panTabs)
    {
        LocalFree((HLOCAL)ptlb->panTabs);

        ptlb->uTabStops    = 0;
        ptlb->panTabs      = NULL;
        ptlb->panTitleTabs = NULL;
    }

    if (NULL != ptlb->pszTitleText)
    {
        LocalFree((HLOCAL)ptlb->pszTitleText);

        ptlb->cchTitleText = 0;
        ptlb->pszTitleText = NULL;
    }


    //
    //  allocate new space for tab stops. there are two different tab
    //  arrays:
    //
    //      panTabs: original tab values as passed by caller. these are
    //      virtual tab locations represented as number of characters. we
    //      need to keep these values for recomputing the real tabs when
    //      the font changes.
    //
    //      panTitleTabs: these values are computed by TlbRecalcTabs and
    //      are actual tab positions in client coordinates for the title
    //      text (needed for TabbedTextOut in TlbPaint).
    //
    //  the tabs for the listbox are computed and set in TlbRecalcTabs
    //
    if (0 != uTabStops)
    {
        ptlb->panTabs = (PINT)LocalAlloc(LPTR, (uTabStops * sizeof(int)) * 2);
        if (NULL == ptlb->panTabs)
            return (FALSE);

        ptlb->uTabStops    = uTabStops;
        ptlb->panTitleTabs = ptlb->panTabs + uTabStops;
        memcpy(ptlb->panTabs, anTabs, uTabStops * sizeof(int));
    }


    //
    //  allocate space for the converted title text (stripped of the tab
    //  spacing values). this string is passed directly to TabbedTextOut
    //  in TlbPaint.
    //
    if (0 != cchTitleText)
    {
        ptlb->pszTitleText = (PTSTR)LocalAlloc(LPTR, (cchTitleText + 1) * sizeof(TCHAR));
        if (NULL == ptlb->pszTitleText)
            return (FALSE);

        ptlb->cchTitleText = cchTitleText;
        lstrcpy(ptlb->pszTitleText, szTitleText);
    }



    //
    //
    //
    TlbRecalcTabs(ptlb);


    //
    //  force a complete repaint of the title text and listbox--redraw
    //  immediately if we are supposed to
    //
    hwnd = GetParent(ptlb->hlb);
    InvalidateRect(hwnd, &ptlb->rc, TRUE);
    if (fRedraw)
    {
        UpdateWindow(hwnd);
    }

    return (TRUE);
} // TlbSetTitleAndTabs()


//--------------------------------------------------------------------------;
//  
//  PTABBEDLISTBOX TlbDestroy
//  
//  Description:
//  
//  
//  Arguments:
//      PTABBEDLISTBOX ptlb:
//  
//  Return (PTABBEDLISTBOX):
//  
//  
//--------------------------------------------------------------------------;

PTABBEDLISTBOX FAR PASCAL TlbDestroy
(
    PTABBEDLISTBOX          ptlb
)
{
    HWND                hwnd;
    int                 nHeight;

    //
    //  get rid of the listbox
    //
    if (NULL != ptlb->hlb)
    {
        DestroyWindow(ptlb->hlb);

        //
        //  invalidate area where title text was so it will be clean
        //
        nHeight = min(ptlb->nFontHeight, ptlb->rc.bottom - ptlb->rc.top);
        ptlb->rc.bottom = ptlb->rc.top + nHeight;

        hwnd = GetParent(ptlb->hlb);
        InvalidateRect(hwnd, &ptlb->rc, TRUE);

    }

    //
    //  free the memory used for tab stops and title text
    //
    if (NULL != ptlb->panTabs)
        LocalFree((HLOCAL)ptlb->panTabs);

    if (NULL != ptlb->pszTitleText)
        LocalFree((HLOCAL)ptlb->pszTitleText);

    LocalFree((HLOCAL)ptlb);

    return (NULL);
} // TlbDestroy()


//--------------------------------------------------------------------------;
//  
//  PTABBEDLISTBOX TlbCreate
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      int nId:
//  
//      PRECT prc:
//  
//  Return (PTABBEDLISTBOX):
//  
//  
//--------------------------------------------------------------------------;

PTABBEDLISTBOX FAR PASCAL TlbCreate
(
    HWND                    hwnd,
    int                     nId,
    PRECT                   prc
)
{
    #define TLB_DEF_STYLE   (WS_VISIBLE|WS_CHILD|WS_VSCROLL|WS_BORDER|  \
                             WS_TABSTOP|WS_GROUP|LBS_NOTIFY|            \
                             LBS_NOINTEGRALHEIGHT|LBS_USETABSTOPS)

    static TCHAR    szNull[]    = TEXT("");
    static TCHAR    szListBox[] = TEXT("ListBox");

    PTABBEDLISTBOX      ptlb;
    HINSTANCE           hinst;


    //
    //  create a new instance data structure..
    //
    ptlb = (PTABBEDLISTBOX)LocalAlloc(LPTR, sizeof(*ptlb));
    if (NULL == ptlb)
        return (NULL);


    //
    //  create the listbox
    //
    hinst = GetWindowInstance(hwnd);

    ptlb->hlb = CreateWindow(szListBox, szNull, TLB_DEF_STYLE,
                             0, 0, 0, 0, hwnd, (HMENU)nId, hinst, NULL);
    if (NULL == ptlb->hlb)
    {
        TlbDestroy(ptlb);
        return (NULL);
    }

    TlbRecalcTabs(ptlb);

    if (NULL != prc)
    {
        ptlb->rc = *prc;
        TlbMove(ptlb, prc, FALSE);
    }

    return (ptlb);
} // TlbCreate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\waveio.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  waveio.c
//
//  Description:
//
//
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <memory.h>

#include "appport.h"
#include "waveio.h"

#include "debug.h"


//--------------------------------------------------------------------------;
//  
//  WIOERR wioFileClose
//  
//  Description:
//  
//  
//  Arguments:
//      LPWAVEIOCB pwio:
//  
//      DWORD fdwClose:
//  
//  Return (WIOERR):
//  
//--------------------------------------------------------------------------;

WIOERR WIOAPI wioFileClose
(
    LPWAVEIOCB      pwio,
    DWORD           fdwClose
)
{
    //
    //  validate a couple of things...
    //
    if (NULL == pwio)
        return (WIOERR_BADPARAM);


    //
    //  get rid of stuff...
    //
//  wioStopWave(pwio);
    
    if (NULL != pwio->hmmio)
    {
        mmioClose(pwio->hmmio, 0);
    }
    
//  FreeWaveHeaders(lpwio);

#if 0
    if (pwio->pInfo)
        riffFreeINFO(&(lpwio->pInfo));
    
    if (pwio->pDisp)
        riffFreeDISP(&(lpwio->pDisp));
#endif

    if (NULL != pwio->pwfx)
        GlobalFreePtr(pwio->pwfx);

    _fmemset(pwio, 0, sizeof(*pwio));

    return (WIOERR_NOERROR);
} // wioFileClose()


//--------------------------------------------------------------------------;
//  
//  WIOERR wioFileOpen
//  
//  Description:
//  
//  
//  Arguments:
//      LPWAVEIOCB pwio:
//  
//      LPCTSTR pszFilePath:
//  
//      DWORD fdwOpen:
//  
//  Return (WIOERR):
//  
//  
//--------------------------------------------------------------------------;

WIOERR WIOAPI wioFileOpen
(
    LPWAVEIOCB      pwio,
    LPCTSTR         pszFilePath,
    DWORD           fdwOpen
)
{
    UINT        u;
    TCHAR       ach[255];
    WIOERR      werr;
    HMMIO       hmmio;
    MMCKINFO    ckRIFF;
    MMCKINFO    ck;
    DWORD       dw;

    //
    //  validate a couple of things...
    //
    if (NULL == pwio)
        return (WIOERR_BADPARAM);

    //
    //  default our error return (assume the worst)
    //
    _fmemset(pwio, 0, sizeof(*pwio));
    werr = WIOERR_FILEERROR;

    pwio->dwFlags   = fdwOpen;

    //
    //  first try to open the file, etc.. open the given file for reading
    //  using buffered I/O
    //
    hmmio = mmioOpen((LPTSTR)pszFilePath, NULL, MMIO_READ | MMIO_ALLOCBUF);
    if (NULL == hmmio)
        goto wio_Open_Error;

    pwio->hmmio     = hmmio;


    //
    //  locate a 'WAVE' form type...
    //
    ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    if (mmioDescend(hmmio, &ckRIFF, NULL, MMIO_FINDRIFF))
        goto wio_Open_Error;

    //
    //  we found a WAVE chunk--now go through and get all subchunks that
    //  we know how to deal with...
    //
    pwio->dwDataSamples = (DWORD)-1L;

#if 0
    if (lrt=riffInitINFO(&wio.pInfo))
    {
        lr=lrt;
        goto wio_Open_Error;
    }
#endif

    //
    //
    //
    while (MMSYSERR_NOERROR == mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        //
        //  quickly check for corrupt RIFF file--don't ascend past end!
        //
        if ((ck.dwDataOffset + ck.cksize) > (ckRIFF.dwDataOffset + ckRIFF.cksize))
        {
            DPF(1, "wioFileOpen() FILE MIGHT BE CORRUPT!");
            DPF(1, "    ckRIFF.dwDataOffset: %lu", ckRIFF.dwDataOffset);
            DPF(1, "          ckRIFF.cksize: %lu", ckRIFF.cksize);
            DPF(1, "        ck.dwDataOffset: %lu", ck.dwDataOffset);
            DPF(1, "              ck.cksize: %lu", ck.cksize);

            wsprintf(ach, TEXT("This wave file might be corrupt. The RIFF chunk.ckid '%.08lX' (data offset at %lu) specifies a cksize of %lu that extends beyond what the RIFF header cksize of %lu allows. Attempt to load?"),
                     ck.ckid, ck.dwDataOffset, ck.cksize, ckRIFF.cksize);
            u = MessageBox(NULL, ach, TEXT("wioFileOpen"),
                           MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL);
            if (IDNO == u)
            {
                werr = WIOERR_BADFILE;
                goto wio_Open_Error;
            }
        }

        switch (ck.ckid)
        {
            case mmioFOURCC('L', 'I', 'S', 'T'):
                if (ck.fccType == mmioFOURCC('I', 'N', 'F', 'O'))
                {
#if 0
                    if(lrt=riffReadINFO(hmmio, &ck, wio.pInfo))
                    {
                        lr=lrt;
                        goto wio_Open_Error;
                    }
#endif
                }
                break;
                
            case mmioFOURCC('D', 'I', 'S', 'P'):
#if 0
                riffReadDISP(hmmio, &ck, &(wio.pDisp));
#endif
                break;
                
            case mmioFOURCC('f', 'm', 't', ' '):
                //
                //  !?! another format chunk !?!
                //
                if (NULL != pwio->pwfx)
                    break;

                //
                //  get size of the format chunk, allocate and lock memory
                //  for it. we always alloc a complete extended format header
                //  (even for PCM headers that do not have the cbSize field
                //  defined--we just set it to zero).
                //
                dw = ck.cksize;
                if (dw < sizeof(WAVEFORMATEX))
                    dw = sizeof(WAVEFORMATEX);

                pwio->pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, dw);
                if (NULL == pwio->pwfx)
                {
                    werr = WIOERR_NOMEM;
                    goto wio_Open_Error;
                }

                //
                //  read the format chunk
                //
                werr = WIOERR_FILEERROR;
                dw = ck.cksize;
                if (mmioRead(hmmio, (HPSTR)pwio->pwfx, dw) != (LONG)dw)
                    goto wio_Open_Error;
                break;


            case mmioFOURCC('d', 'a', 't', 'a'):
                //
                //  !?! multiple data chunks !?!
                //
                if (0L != pwio->dwDataBytes)
                    break;

                //
                //  just hang on to the total length in bytes of this data
                //  chunk.. and the offset to the start of the data
                //
                pwio->dwDataBytes  = ck.cksize;
                pwio->dwDataOffset = ck.dwDataOffset;
                break;


            case mmioFOURCC('f', 'a', 'c', 't'):
                //
                //  !?! multiple fact chunks !?!
                //
                if (-1L != pwio->dwDataSamples)
                    break;

                //
                //  read the first dword in the fact chunk--it's the only
                //  info we need (and is currently the only info defined for
                //  the fact chunk...)
                //
                //  if this fails, dwDataSamples will remain -1 so we will
                //  deal with it later...
                //
                mmioRead(hmmio, (HPSTR)&pwio->dwDataSamples, sizeof(DWORD));
                break;
        }

        //
        //  step up to prepare for next chunk..
        //
        mmioAscend(hmmio, &ck, 0);
    }

    //
    //  if no fmt chunk was found, then die!
    //
    if (NULL == pwio->pwfx)
    {
        werr = WIOERR_ERROR;
        goto wio_Open_Error;
    }

    //
    //  all wave files other than PCM are _REQUIRED_ to have a fact chunk
    //  telling the number of samples that are contained in the file. it
    //  is optional for PCM (and if not present, we compute it here).
    //
    //  if the file is not PCM and the fact chunk is not found, then fail!
    //
    if (-1L == pwio->dwDataSamples)
    {
        if (WAVE_FORMAT_PCM == pwio->pwfx->wFormatTag)
        {
            pwio->dwDataSamples = pwio->dwDataBytes / pwio->pwfx->nBlockAlign;
        }
        else
        {
            //
            //  !!! HACK HACK HACK !!!
            //
            //  although this should be considered an invalid wave file, we
            //  will bring up a message box describing the error--hopefully
            //  people will start realizing that something is missing???
            //
            u = MessageBox(NULL, TEXT("This wave file does not have a 'fact' chunk and requires one! This is completely invalid and MUST be fixed! Attempt to load it anyway?"),
                            TEXT("wioFileOpen"), MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL);
            if (IDNO == u)
            {
                werr = WIOERR_BADFILE;
                goto wio_Open_Error;
            }

            //
            //  !!! need to hack stuff in here !!!
            //
            pwio->dwDataSamples = 0L;
        }
    }

    //
    //  cool! no problems.. 
    //
    return (WIOERR_NOERROR);


    //
    //  return error (after minor cleanup)
    //
wio_Open_Error:

    wioFileClose(pwio, 0L);
    return (werr);
} // wioFileOpen()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\lowpass\lowpass.c ===
/* lowpass.c - WinMain() and dialog procedures for LOWPASS, along with
 *      initialization and support code.
 *
 * LOWPASS is a sample application illustrating how to use the multimedia
 *  file I/O services to read and write RIFF files.
 *
 * LOWPASS runs a simple low-pass filter over an 8-bit-per-sample
 * mono WAVE file.  Note that this program does not copy unknown chunks
 * to the output file.
 *
 *
 *     (C) Copyright Microsoft Corp. 1991.  All rights reserved.
 *
 *     You have a royalty-free right to use, modify, reproduce and
 *     distribute the Sample Files (and/or any modified version) in
 *     any way you find useful, provided that you agree that
 *     Microsoft has no warranty obligations or liability for any
 *     Sample Application Files which are modified.
 */

#include <windows.h>
#include <mmsystem.h>
#include "lowpass.h"


/* Globals
 */
char        gszAppName[] = "LowPass";   // for title bar, etc.
HANDLE      ghInst;                     // app's instance handle


/* DoLowPass - Gets the name of the input and output WAVE files from
 *  the dialog box; reads waveform data from the input file, performs
 *  a simple low-pass filter by averaging adjacent samples, and writes
 *  the filtered waveform data to the output WAVE file.
 *
 * Params:  hWnd - Window handle for our dialog box.
 *
 * Returns:
 */
void DoLowPass(HWND hWnd)
{
    char        achInFile[200];     // name of input file
    char        achOutFile[200];    // name of output file
    HMMIO       hmmioIn = NULL;     // handle to open input WAVE file
    HMMIO       hmmioOut = NULL;    // handle to open output WAVE file
    MMCKINFO    ckInRIFF;           // chunk info. for input RIFF chunk
    MMCKINFO    ckOutRIFF;          // chunk info. for output RIFF chunk
    MMCKINFO    ckIn;               // info. for a chunk in input file
    MMCKINFO    ckOut;              // info. for a chunk in output file
    PCMWAVEFORMAT   pcmWaveFormat;  // contents of 'fmt' chunks
    MMIOINFO    mmioinfoIn;         // current status of <hmmioIn>
    MMIOINFO    mmioinfoOut;        // current status of <hmmioOut>
    long        lSamples;           // number of samples to filter
    BYTE        abSamples[3];       // this, last, and before-last sample

    /* Read filenames from dialog box fields.
     */
    achInFile[0] == 0;
    GetDlgItemText(hWnd, ID_INPUTFILEEDIT, achInFile, sizeof(achInFile));
    achOutFile[0] == 0;
    GetDlgItemText(hWnd, ID_OUTPUTFILEEDIT, achOutFile, sizeof(achOutFile));

    /* Open the input file for reading using buffered I/O.
     */
    hmmioIn = mmioOpen(achInFile, NULL, MMIO_ALLOCBUF | MMIO_READ);
    if (hmmioIn == NULL)
        goto ERROR_CANNOT_READ;     // cannot open WAVE file

    /* Open the output file for writing using buffered I/O. Note that
     * if the file exists, the MMIO_CREATE flag causes it to be truncated
     * to zero length.
     */
    hmmioOut = mmioOpen(achOutFile, NULL,
                        MMIO_ALLOCBUF | MMIO_WRITE | MMIO_CREATE);
    if (hmmioOut == NULL)
        goto ERROR_CANNOT_WRITE;    // cannot open WAVE file

    /* Descend the input file into the 'RIFF' chunk.
     */
    if (mmioDescend(hmmioIn, &ckInRIFF, NULL, 0) != 0)
        goto ERROR_CANNOT_READ;     // end-of-file, probably

    /* Make sure the input file is a WAVE file.
     */
    if ((ckInRIFF.ckid != FOURCC_RIFF) ||
        (ckInRIFF.fccType != mmioFOURCC('W', 'A', 'V', 'E')))
        goto ERROR_FORMAT_BAD;

    /* Search the input file for for the 'fmt ' chunk.
     */
    ckIn.ckid = mmioFOURCC('f', 'm', 't', ' ');
    if (mmioDescend(hmmioIn, &ckIn, &ckInRIFF, MMIO_FINDCHUNK) != 0)
        goto ERROR_FORMAT_BAD;      // no 'fmt ' chunk

    /* Expect the 'fmt' chunk to be at least as large as <pcmWaveFormat>;
     * if there are extra parameters at the end, we'll ignore them
     */
    if (ckIn.cksize < (long) sizeof(pcmWaveFormat))
        goto ERROR_FORMAT_BAD;      // 'fmt ' chunk too small

    /* Read the 'fmt ' chunk into <pcmWaveFormat>.
     */
    if (mmioRead(hmmioIn, (HPSTR) &pcmWaveFormat,
        (long) sizeof(pcmWaveFormat)) != (long) sizeof(pcmWaveFormat))
        goto ERROR_CANNOT_READ;     // truncated file, probably

    /* Ascend the input file out of the 'fmt ' chunk.
     */
    if (mmioAscend(hmmioIn, &ckIn, 0) != 0)
        goto ERROR_CANNOT_READ;     // truncated file, probably

    /* Make sure the input file is an 8-bit mono PCM WAVE file.
     */
    if ((pcmWaveFormat.wf.wFormatTag != WAVE_FORMAT_PCM) ||
        (pcmWaveFormat.wf.nChannels != 1) ||
        (pcmWaveFormat.wBitsPerSample != 8))
        goto ERROR_FORMAT_BAD;      // bad input file format

    /* Search the input file for for the 'data' chunk.
     */
    ckIn.ckid = mmioFOURCC('d', 'a', 't', 'a');
    if (mmioDescend(hmmioIn, &ckIn, &ckInRIFF, MMIO_FINDCHUNK) != 0)
        goto ERROR_FORMAT_BAD;      // no 'data' chunk

    /* Create the output file RIFF chunk of form type 'WAVE'.
     */
    ckOutRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    if (mmioCreateChunk(hmmioOut, &ckOutRIFF, MMIO_CREATERIFF) != 0)
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably

    /* We are now descended into the 'RIFF' chunk we just created.
     * Now create the 'fmt ' chunk. Since we know the size of this chunk,
     * specify it in the MMCKINFO structure so MMIO doesn't have to seek
     * back and set the chunk size after ascending from the chunk.
     */
    ckOut.ckid = mmioFOURCC('f', 'm', 't', ' ');
    ckOut.cksize = sizeof(pcmWaveFormat);   // we know the size of this ck.
    if (mmioCreateChunk(hmmioOut, &ckOut, 0) != 0)
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably

    /* Write the PCMWAVEFORMAT structure to the 'fmt ' chunk.
     */
    if (mmioWrite(hmmioOut, (HPSTR) &pcmWaveFormat, sizeof(pcmWaveFormat))
        != sizeof(pcmWaveFormat))
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably

    /* Ascend out of the 'fmt ' chunk, back into the 'RIFF' chunk.
     */
    if (mmioAscend(hmmioOut, &ckOut, 0) != 0)
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably

    /* Create the 'data' chunk that holds the waveform samples.
     */
    ckOut.ckid = mmioFOURCC('d', 'a', 't', 'a');
    if (mmioCreateChunk(hmmioOut, &ckOut, 0) != 0)
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably

    /* Read samples from the 'data' chunk of the input file, and write
     * samples to the 'data' chunk of the output file.  Each sample in
     * the output file equals the average of the corresponding sample
     * in the input file and the previous two samples from the input file.
     * Access the I/O buffers of <hmmioIn> and <hmmioOut> directly,
     * since this is faster than calling mmioRead() and mmioWrite()
     * for each sample.
     */
    abSamples[0] = abSamples[1] = abSamples[2] = 128;

    /* Begin direct access of the I/O buffers.
     */
    if (mmioGetInfo(hmmioIn, &mmioinfoIn, 0) != 0)
        goto ERROR_UNKNOWN;
    if (mmioGetInfo(hmmioOut, &mmioinfoOut, 0) != 0)
        goto ERROR_UNKNOWN;

    /* For each input sample, compute and write the output sample.
     */
    for (lSamples = ckIn.cksize; lSamples > 0; lSamples--)
    {
        /* If we are at the end of the input file I/O buffer, fill it.
         * Test to see that we don't hit end of file while (lSamples > 0).
         */
        if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead)
        {
            if (mmioAdvance(hmmioIn, &mmioinfoIn, MMIO_READ) != 0)
                goto ERROR_CANNOT_READ;

            if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead)
                goto ERROR_CANNOT_READ;
        }

        /* If we are the end of the output file I/O buffer, flush it.
         */
        if (mmioinfoOut.pchNext == mmioinfoOut.pchEndWrite)
        {
            mmioinfoOut.dwFlags |= MMIO_DIRTY;
            if (mmioAdvance(hmmioOut, &mmioinfoOut, MMIO_WRITE) != 0)
                goto ERROR_CANNOT_WRITE;
        }

        /* Keep track of the last 3 samples so we can average.
         */
        abSamples[2] = abSamples[1];        // next-to-last sample
        abSamples[1] = abSamples[0];        // last sample
        abSamples[0] = *(mmioinfoIn.pchNext)++; // current sample

        /* The output file sample is the average of the last
         * 3 input file samples.
         */
        *(mmioinfoOut.pchNext)++ = (BYTE) (((int) abSamples[0]
            + (int) abSamples[1] + (int) abSamples[2]) / 3);
    }

    /* We are through processing samples, end direct access of
     * the I/O buffers. Set the MMIO_DIRTY flag for the output buffer
     * to flush it.
     */
    if (mmioSetInfo(hmmioIn, &mmioinfoIn, 0) != 0)
        goto ERROR_UNKNOWN;
    mmioinfoOut.dwFlags |= MMIO_DIRTY;
    if (mmioSetInfo(hmmioOut, &mmioinfoOut, 0) != 0)
        goto ERROR_CANNOT_WRITE;    // cannot flush, probably

    /* Ascend the output file out of the 'data' chunk -- this will cause
     * the chunk size of the 'data' chunk to be written.
     */
    if (mmioAscend(hmmioOut, &ckOut, 0) != 0)
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably

    /* Ascend the output file out of the 'RIFF' chunk -- this will cause
     * the chunk size of the 'RIFF' chunk to be written.
     */
    if (mmioAscend(hmmioOut, &ckOutRIFF, 0) != 0)
        goto ERROR_CANNOT_WRITE;    // cannot write file, probably

    /* We are done -- files are closed below.
     */
    goto EXIT_FUNCTION;

ERROR_FORMAT_BAD:

    MessageBox(NULL, "Input file must be an 8-bit mono PCM WAVE file",
        gszAppName, MB_ICONEXCLAMATION | MB_OK);
    goto EXIT_FUNCTION;

ERROR_CANNOT_READ:

    MessageBox(NULL, "Cannot read input WAVE file",
        gszAppName, MB_ICONEXCLAMATION | MB_OK);
    goto EXIT_FUNCTION;

ERROR_CANNOT_WRITE:

    MessageBox(NULL, "Cannot write output WAVE file",
        gszAppName, MB_ICONEXCLAMATION | MB_OK);
    goto EXIT_FUNCTION;

ERROR_UNKNOWN:

    MessageBox(NULL, "Unknown error",
        gszAppName, MB_ICONEXCLAMATION | MB_OK);
    goto EXIT_FUNCTION;

EXIT_FUNCTION:

    /* Close the files (unless they weren't opened successfully).
     */
    if (hmmioIn != NULL)
        mmioClose(hmmioIn, 0);
    if (hmmioOut != NULL)
        mmioClose(hmmioOut, 0);
}


/* WinMain - Entry point for LowPass.
 */
int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpszCmdLine, int iCmdShow)
{
    FARPROC     fpfn;

    /* Save instance handle for dialog boxes.
     */
    ghInst = hInst;

    /* Display our dialog box.
     */
    fpfn = MakeProcInstance((FARPROC) LowPassDlgProc, ghInst);
    DialogBox(ghInst, "LOWPASSBOX", NULL, (DLGPROC)fpfn);
    FreeProcInstance(fpfn);

    return TRUE;
}


/* AboutDlgProc - Dialog procedure function for ABOUTBOX dialog box.
 */
BOOL FAR PASCAL
     AboutDlgProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg)
    {
    case WM_INITDIALOG:
        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK)
            EndDialog(hWnd, TRUE);
        break;
    }
    return FALSE;
}


/* LowPassDlgProc - Dialog procedure function for LOWPASSBOX dialog box.
 */
BOOL FAR PASCAL
     LowPassDlgProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    FARPROC     fpfn;
    HMENU       hmenuSystem;    // system menu
    HCURSOR     ghcurSave;      // previous cursor

    switch (wMsg)
    {
    case WM_INITDIALOG:
        /* Append "About" menu item to system menu.
         */
        hmenuSystem = GetSystemMenu(hWnd, FALSE);
        AppendMenu(hmenuSystem, MF_SEPARATOR, 0, NULL);
        AppendMenu(hmenuSystem, MF_STRING, IDM_ABOUT,
            "&About LowPass...");
        return TRUE;

    case WM_SYSCOMMAND:
        switch (wParam)
        {
        case IDM_ABOUT:
            /* Display "About" dialog box.
             */
            fpfn = MakeProcInstance((FARPROC) AboutDlgProc, ghInst);
            DialogBox(ghInst, "ABOUTBOX", hWnd, (DLGPROC)fpfn);
            FreeProcInstance(fpfn);
            break;
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:          // "Begin"
            /* Set "busy" cursor, filter input file, restore cursor.
             */
            ghcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DoLowPass(hWnd);
            SetCursor(ghcurSave);
            break;

        case IDCANCEL:      // "Done"
            EndDialog(hWnd, TRUE);
            break;
        }
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mcipionr\comm.h ===
/****************************************************************************
 *
 *   comm.h
 *
 *   Copyright (c) 1993 Microsoft Corporation.  All Rights Reserved
 *
 *   MCI Device Driver for the Pioneer 4200 Videodisc Player
 *
 *      Win32/Win16 specific comms definitions
 *
 ***************************************************************************/
#ifdef WIN32

INT     WINAPI OpenComm(LPCTSTR, UINT, UINT);
#define CloseComm(h)     (INT)!CloseHandle((HANDLE)h)

INT     ReadComm(int, void FAR*, int);
INT     WriteComm(int, const void FAR*, int);
INT     GetCommError(int, COMSTAT FAR* );

#endif  /* !WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mcipionr\mcipionr.c ===
/****************************************************************************
 *
 *   mcipionr.c
 *
 *   Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved
 *
 *   MCI Device Driver for the Pioneer 4200 Videodisc Player
 *
 *      MCI Module - MCI commands and interface to device
 *
 ***************************************************************************/

/* Known problems in this driver:
 *
 *  1) Play succeeds with no disc in the drive
 *  2) The command 'spin down' does not notify when completed
 *  3) The first 'status mode' after a 'spin down' followed by a
 *     'seek' to an invalid adress can return 'play' instead of
 *     'stopped'
 *  4) A 'spin down notify' command followed by a 'play' command
 *     will return MCI_NOTIFY_FAILURE instead of MCI_NOTIFY_ABORTED
 *  5) The first 'status time format' command sent after a new
 *     disk is inserted can result in a return value of '0' instead
 *     of a legal value like MCI_FORMAT_HMS
 *  6) Multi-process device sharing for Windows NT is not addressed.
 *     The sharing will work correctly for 16-bit applications.
 */

#define USECOMM
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mcipionr.h"
#include "comm.h"

/* Maximum number of supported comports */
#define PIONEER_MAX_COMPORTS 4

/* Time in milliseconds that the driver will normally wait for the device */
/* to return data */
#define PIONEER_READCHAR_TIMEOUT    1000 /* Minimum for 10Mhz 286 */

/* Time in milliseconds that the driver will wait for the device to return */
/* data when the device is busy (i.e. seeking) */
#define PIONEER_MAX_BUSY_TIME       30000

/* Maximum length of the videodisc's buffer */
#define VDISC_BUFFER_LENGTH         20

/* Macro to determine if the given videodisc frame is valid */
#define VALID_FRAME(n) ((DWORD)(n) <= (DWORD)99999)

/* Maximum number of frames on a CAV disc */
#define CAV_MAX_DISC_FRAMES         54000

/* Frame rate of a CAV disc */
#define CAV_FRAMES_PER_SECOND       30

/* Flags a to position as invalid */
#define NO_TO_POSITION              0xFFFFFFFF

/* Flags a time mode as invalid */
#define NO_TIME_MODE                0xFFFFFFFF

/* Flags a comport as invalid */
#define NO_COMPORT                  -1

/* Internal play directions */
/* Set at least two bits so they'll never equal MCI_PLAY_VD_REVERSE */
#define PION_PLAY_FORWARD       3
#define PION_PLAY_NO_DIRECTION  7

/* Polling period in milliseconds used for setting timer */
#define TIMER_POLLING_PERIOD    100

/* Convert an HMS address to Seconds */
#define HMSTOSEC(hms) (MCI_HMS_HOUR(hms) * 3600 + MCI_HMS_MINUTE(hms) * 60 + \
                       MCI_HMS_SECOND(hms))

/* Difference in seconds between two HMS addresses */
#define HMS_DIFF(h2, h1) (HMSTOSEC(h2) - HMSTOSEC(h1))

/* Absolute value macro */
#define abs(a)  ((a) < 0 ? -(a) : (a))

#ifdef WIN32
#define AnsiUpperChar(c)        ((TCHAR)CharUpper((LPTSTR)(DWORD)(c)))
#else
#define wsprintfA wsprintf
#define lstrlenA lstrlen
#define AnsiUpperChar(c)        ((char)(WORD)(DWORD)AnsiUpper((LPSTR)(DWORD)(WORD)(char)(c)))
#endif /* WIN32 */

/* Module instance handle */
HINSTANCE hInstance;

/* ID of the timer used for polling */
static int wTimerID;

/* Number of channels which are using the timer */
static int nWaitingChannels;

/* Set to FALSE inside TimerProc to prevent re-entrant disasters when */
/* trying to yield */
static BOOL bYieldWhenReading = TRUE;

/* Forward declarations */
static DWORD PASCAL NEAR spinupdown(UINT wDeviceID, int nPort, DWORD dwFlag, BOOL bWait);
static DWORD PASCAL NEAR status(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_STATUS_PARMS lpStatus);

/* Data for each comm port - Port 0 is com1, port 1 is com2, etc... */
static struct {
    int    nCommID;        /* The ID returned by OpenComm */
    UINT   Rate;           /* Baud rate */
    HWND   hCallback;      /* Handle to window function to call back */
    BOOL   bPlayerBusy;    /* TRUE if the player is seeking or transitioning */
                           /* between park and random access mode */
    BOOL   bDoorAction;    /* TRUE if door opening or closing */
    BOOL   bPlayTo;        /* TRUE if playing to a particular frame */
    DWORD  dwPlayTo;       /* The frame being played to */
    DWORD  dwToTimeMode;   /* Time mode of the dwPlayTo position */
    UINT   wAudioChannels; /* Bit 0 is ch1 status, bit 1 is ch2 */
    BOOL   bTimerSet;      /* TRUE when there is a timer for this channel */
    DWORD  dwTimeMode;     /*  One of MCI_FORMAT_MILLISECONDS, */
                           /*         MCI_FORMAT_HMS or */
                           /*         MCI_FORMAT_FRAMES or */
                           /*         MCI_VD_FORMAT_TRACK */
    BOOL   bCAVDisc;       /* True if a CAV disc is inserted */
    UINT   wDeviceID;      /* MCI device ID */
    int    nUseCount;
    BOOL   bShareable;
    BOOL   bResponding;
    DWORD  dwDirection;    /* The current direction.  One of: */
                           /* PION_PLAY_FORWARD */
                           /* PION_PLAY_NO_DIRECTION */
                           /* MCI_VD_PLAY_REVERSE */
    DWORD  dwBusyStart;    /* The time the timer loop started waiting */
#ifdef WIN32
    CRITICAL_SECTION
           DeviceCritSec;  /* Only one person accesses a device at a time */
#endif /* WIN32 */
} comport[PIONEER_MAX_COMPORTS];

#if DBG
/* Amount of information (if any) to dump out the debug port */
static UINT wDebugLevel = 0;
#endif

#ifdef WIN32
#define SZCODE CHAR
#define SZTCODE TCHAR
#else
#define SZCODE CHAR _based(_segname("_CODE"))
#define SZTCODE TCHAR _based(_segname("_CODE"))
#endif /* WIN32 */

static SZTCODE aszComm[] = TEXT("com");
static SZTCODE aszCommOpenFormat[] = TEXT("%s%1d");
static SZTCODE aszCommSetupFormat[] = TEXT("%s%1d:%d,n,8,1");
static SZCODE aszFrameFormat[] = "%lu";
static SZCODE aszTrackFormat[] = "%u";
static SZCODE aszHMSFormat[] = "%1u%2u%2u";
static SZCODE aszCLVLength[] = "10000";
static SZCODE aszNull[] = "";

static SZCODE aszQueryPlaying[] = "?P";
static SZCODE aszQueryMedia[] = "?D";
static SZCODE aszQueryTrack[] = "?C";
static SZCODE aszQueryFormat[] = "?F";
static SZCODE aszQueryTime[] = "?T";
static SZCODE aszFormat[] = "FR";
static SZCODE aszTime[] = "TM";
static SZCODE aszCheck[] = "CH";
static SZCODE aszClose[] = "0KL";
static SZCODE aszAudioOn[] = "3AD";
static SZCODE aszSpinUp[] = "SA";
static SZCODE aszStopMarker[] = "SM";
static SZCODE aszSeekTo[] = "SE";
static SZCODE aszSeekToFormat[] = "%uSE";
static SZCODE aszSeekStart[] = "0SE";
static SZCODE aszSeekEnd[] = "99999SE";
static SZCODE aszSeekSetSpeed[] = "255SP";
static SZCODE aszFastSetSpeed[] = "180SP";
static SZCODE aszSlowSetSpeed[] = "20SP";
static SZCODE aszMediumSetSpeed[] = "60SP";
static SZCODE aszSetSpeedFormat[] = "%uSP";
static SZCODE aszMediaReverse[] = "MR";
static SZCODE aszMediaForward[] = "MF";
static SZCODE aszPlay[] = "PL";
static SZCODE aszPause[] = "PA";
static SZCODE aszStop[] = "ST";
static SZCODE aszReject[] = "RJ";
static SZCODE aszStepReverse[] = "SR";
static SZCODE aszStepForward[] = "SF";
static SZCODE aszOpenDoor[] = "OP";
static SZCODE aszCommandOff[] = "2CM";
static SZCODE aszCommandOn[] = "3CM";
static SZCODE aszIndexOff[] = "0DS";
static SZCODE aszIndexOn[] = "1DS";
static SZCODE aszKeyLockOff[] = "0KL";
static SZCODE aszKeyLockOn[] = "1KL";

/****************************************************************************
 * @doc INTERNAL MCI
 *
 * @api UINT | getchars | Read "n" characters into "buf".  Wait up to
 *     PIONEER_READCHAR_TIMEOUT milliseconds.
 *
 * @parm int | nPort | Port number.
 *
 * @parm LPSTR | lpstrBuf | Buffer to fill.
 *
 * @parm int | n | Number of characters to read.
 *
 * @parm UINT | wWait | Number of milliseconds to wait before timing out
 *     If 0 then wait for PIONEER_READCHAR_TIMEOUT milliseconds.
 *
 * @rdesc Number of characters actually read.
 ***************************************************************************/
static UINT PASCAL NEAR getchars(UINT wDeviceID, int nPort, LPSTR lpstrBuf, int n, UINT wWait)
{
    int nRead, FirstTry = TRUE;
    DWORD dwTime0, dwTime;
    int nToRead = n;
    int nCommID = comport[nPort].nCommID;
#if DBG
    LPSTR lpstrStart = lpstrBuf;
#endif

    if (wWait == 0)
        wWait = PIONEER_READCHAR_TIMEOUT;

    while (n > 0) {
/* Try to read the number of characters that are left to read */
        nRead = ReadComm(nCommID, lpstrBuf, n);

/* Some characters were read */
        if (nRead > 0) {
            n -= nRead;
            lpstrBuf += nRead;
        }
        else {
/* Either 0 characters read or an error occured */
            if (nRead < 0) {
                DOUT("mcipionr: Comm error");
                return MCIERR_HARDWARE;
            }
            if (nRead == 0) {
                COMSTAT comstat;
                if (GetCommError(nCommID, &comstat) != 0) {
                    DOUT("mcipionr: Comm error");
                    return MCIERR_HARDWARE;
                }
            }
        }
/* If not all characters were read */
        if (n > 0) {
/* If first failure then initialize time base */
            if (FirstTry) {
                dwTime0 = GetCurrentTime();
                FirstTry = FALSE;
            }
/* If subsequent failure then check for timeout */
            else {
                dwTime = GetCurrentTime();

/* Check timer rollover case */
                if (dwTime < dwTime0 &&
                    (dwTime + (0xFFFFFFFF - dwTime0)) > wWait) {
                    DOUT("mcipionr: getchars timeout!");
                    break;
                }

/* Normal case */
                if (dwTime - dwTime0 > wWait) {
                    DOUT("mcipionr: getchars timeout!");
                    break;
                }
                if (bYieldWhenReading)
                    pionDriverYield(wDeviceID, nPort);
#ifdef WIN32
                    Sleep(10);
#endif /* WIN32 */
            }
        }
    }
#if DBG
    {
        CHAR temp[50];
        LPSTR lpstrTemp = temp;
        nRead = nToRead - n;
        if (nRead > sizeof(temp) / sizeof(CHAR) - 1)
            nRead = sizeof(temp) / sizeof(CHAR) - 1;

        lpstrBuf = lpstrStart;
        while (nRead-- > 0)
            *lpstrTemp++ = *lpstrBuf++;
        *lpstrTemp = '\0';
        DOUT("MCIPIONR received:");
        DOUTX(temp);
    }
#endif
    return nToRead - n;
}

/****************************************************************************
 * @doc INTERNAL MCI
 *
 * @api int | GetCompletionCode | Read either a completion code ("R<CR>")
 *      or an error ("E0x<CR>").
 *
 * @parm UINT | wDeviceID | Device ID to use.
 *
 * @parm int | nPort | Port number.
 *
 * @parm UINT | wWait | Number of milliseconds to wait before timing out
 *     If 0 then wait for PIONEER_READCHAR_TIMEOUT milliseconds.
 *
 * @rdesc Returns zero if no error.
 ***************************************************************************/
static int PASCAL NEAR GetCompletionCode(UINT wDeviceID, int nPort, UINT wWait)
{
    CHAR buf[4];	/* This must be larger than 2 because of Win 3.1 Comm bug */

    DOUT("Get completion:");
    if (getchars(wDeviceID, nPort, buf, 2, wWait) != 2)
        return MCIERR_HARDWARE;
    if (buf[0] == 'E') {
/* Empty the buffer of the error condition */
        getchars(wDeviceID, nPort, buf, 2, wWait);
        comport[nPort].bPlayerBusy = FALSE;
        return MCIERR_HARDWARE;
    }
    DOUT("True");
    return 0;
}

/****************************************************************************
 * @doc INTERNAL MCI
 *
 * @api static int | putchars | Send "n" characters from "lpstrS" to the
 *     port specified by "nPort".
 *
 * @parm UINT | wDeviceID | Device ID to use.
 *
 * @parm int | nPort | The port number.
 *
 * @parm LPSTR | lpstrS | The string to send.
 *
 * @parm int | bReturn | If TRUE then the function waits for a
 *     completion code (or an error) to be returned or until a timeout
 *     (PIONEER_GETCHAR_TIMEOUT msecs).  The timeout generates an error.
 *
 * @rdesc Returns zero if no error.
 ***************************************************************************/
static int PASCAL NEAR putchars(UINT wDeviceID, int nPort, LPSTR lpstrS, int bReturn)
{
    int nCommID = comport[nPort].nCommID;
    static CHAR c = 0xd;
    int n = 0;

#if DBG
    DOUT("MCIPIONR sent:");
    DOUTX(lpstrS);
#endif

    n = lstrlenA(lpstrS);

/* Send string to player */
    if (WriteComm(nCommID, lpstrS, n) != n ||
        WriteComm(nCommID, &c, 1) != 1) {
        DOUT("mcipionr:  Hardware error on output");
        return MCIERR_HARDWARE;
    }

    if (bReturn)
/* Get completion code */
        return GetCompletionCode(wDeviceID, nPort, 0);
    else
        return 0;
}

/****************************************************************************
 * Get player status - Returns 1 if it is PLAY or MULTI-SPEED, -1 if there
 * is a hardware error, and 0 otherwise.
 ***************************************************************************/
static int PASCAL NEAR IsPlaying(UINT wDeviceID, int nPort)
{
    CHAR buf[8];

    putchars(wDeviceID, nPort, aszQueryPlaying, FALSE);
    if (getchars(wDeviceID, nPort, buf, 4, 0) != 4)
        return -1;
    return buf[0] == 'P' && (buf[2] == '4' || buf[2] == '9');
}

/****************************************************************************
 * @doc INTERNAL MCI
 *
 * @api void | cancel_notify | Cancel any active notification for this port.
 *
 * @parm int | nPort | The port number to check.
 *
 * @parm UINT | wStatus | The notification status to return.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
static void PASCAL NEAR cancel_notify(int nPort, UINT wStatus)
{
    if (comport[nPort].bTimerSet) {
        comport[nPort].bTimerSet = FALSE;
        if (--nWaitingChannels <= 0)
            KillTimer(NULL, wTimerID);
        mciDriverNotify(comport[nPort].hCallback,
                            comport[nPort].wDeviceID, wStatus);
    }
}

/****************************************************************************
 * Check if the disc is spinning and return 0 if it is
 ***************************************************************************/
static DWORD PASCAL NEAR IsDiscSpinning(UINT wDeviceID, UINT nPort)
{
    CHAR buf[8];

    putchars(wDeviceID, nPort, aszQueryPlaying, FALSE);
    if (getchars(wDeviceID, nPort, buf, 4, 0) != 4)
        return MCIERR_HARDWARE;
    if (buf[0] != 'P') {
        DOUT("mcipionr:  bad mode info from player");
        return MCIERR_HARDWARE;
    }
    if (buf[1] != '0')
        return MCIERR_PIONEER_NOT_SPINNING;
    if (buf[2] == '0' || buf[2] == '1')
        return MCIERR_PIONEER_NOT_SPINNING;
    else
        return 0;
}

/****************************************************************************
 * Get the media type
 ***************************************************************************/
/* If a CLV disc has time mode set to FRAMES, set the time mode to HMS */
/* because frames are illegal for CLV. */
static DWORD PASCAL NEAR get_media_type(
	UINT	wDeviceID,
	UINT	nPort,
	DWORD FAR*	pdwMediaType)
{
    CHAR buf[VDISC_BUFFER_LENGTH];

    putchars(wDeviceID, nPort, aszQueryMedia, FALSE);
    if (getchars(wDeviceID, nPort, buf, 6, 0) != 6)
		return MCIERR_HARDWARE;
	if (buf[0] != '0') {
    if (buf[1] == '0') {
        comport[nPort].bCAVDisc = TRUE;
			*pdwMediaType = MCI_VD_MEDIA_CAV;
			return 0;
    }
		if (buf[1] == '1') {
        comport[nPort].bCAVDisc = FALSE;
			if (comport[nPort].dwTimeMode == MCI_FORMAT_FRAMES)
				comport[nPort].dwTimeMode = MCI_FORMAT_HMS;
			*pdwMediaType = MCI_VD_MEDIA_CLV;
			return 0;
		}
	}
	return MCIERR_PIONEER_NOT_SPINNING;
}

/****************************************************************************
 * Set the proper default time mode for the currently loaded media type
 ***************************************************************************/
static void PASCAL NEAR set_time_mode(UINT wDeviceID, UINT nPort)
{
	DWORD	dwMediaType;

	if (!get_media_type(wDeviceID, nPort, &dwMediaType) && (dwMediaType == MCI_VD_MEDIA_CAV)) {
        comport[nPort].dwTimeMode = MCI_FORMAT_FRAMES;
        putchars(wDeviceID, nPort, aszFormat, TRUE);
	} else {
        comport[nPort].dwTimeMode = MCI_FORMAT_HMS;
        putchars(wDeviceID, nPort, aszTime, TRUE);
    }
}

/****************************************************************************
 * See if the player has arrived at the proper 'to' position
 ***************************************************************************/
static BOOL PASCAL NEAR check_arrival(int nPort)
{
    MCI_STATUS_PARMS Status;
    BOOL bWasTracks = FALSE, bResult = TRUE;

    if (comport[nPort].dwPlayTo == NO_TO_POSITION)
        return TRUE;
    if (comport[nPort].dwTimeMode == MCI_VD_FORMAT_TRACK &&
        comport[nPort].dwToTimeMode != MCI_VD_FORMAT_TRACK) {
        bWasTracks = TRUE;
        set_time_mode(comport[nPort].wDeviceID, nPort);
    }
    Status.dwItem = MCI_STATUS_POSITION;
    if (LOWORD(status(comport[nPort].wDeviceID, nPort, MCI_STATUS_ITEM,
                       (LPMCI_STATUS_PARMS)&Status)) != 0) {
        bResult = FALSE;
        goto reset_mode;
    }

    switch (comport[nPort].dwTimeMode) {
        case MCI_FORMAT_HMS:
        {   int n;
            n = HMS_DIFF(Status.dwReturn, comport[nPort].dwPlayTo);
            if (abs(n) > 2)
                bResult = FALSE;
            break;
        }

        case MCI_FORMAT_FRAMES:
            if (abs((long)Status.dwReturn - (long)comport[nPort].dwPlayTo) > 2)
                bResult = FALSE;
            break;

        case MCI_FORMAT_MILLISECONDS:
            if (abs((long)Status.dwReturn - (long)comport[nPort].dwPlayTo) > 2000)
                bResult = FALSE;
            break;

        case MCI_VD_FORMAT_TRACK:
            if (abs((long)Status.dwReturn - (long)comport[nPort].dwPlayTo) > 1)
                bResult = FALSE;
            break;

        default:
            bResult = FALSE;
            break;
    }

reset_mode:;
    if (bWasTracks) {
        putchars(comport[nPort].wDeviceID, nPort, aszCheck, TRUE);
        comport[nPort].dwTimeMode = MCI_VD_FORMAT_TRACK;
    }

    return bResult;
}

/****************************************************************************
 *  The timer is active if any comm port controlled by this driver is
 *  waiting to reach a point on the disc (comport[nPort].bPlayTo == TRUE)
 *  or if it is seeking or spinning up or down
 *  (comport[nPort].bBusy == TRUE) AND if "notify <x>" was specified for
 *  the command
 ***************************************************************************/
void FAR PASCAL _LOADDS TimerProc(HWND hwnd, UINT uMessage, UINT uTimer, DWORD dwParam)
{
    int nCommID;
    int nPort;

    bYieldWhenReading = FALSE;
/* Loop through all channels */
    for (nPort = 0; nPort < PIONEER_MAX_COMPORTS; LeaveCrit(nPort), nPort++) {

        /* Serialize access to this device */

        EnterCrit(nPort);

        nCommID = comport[nPort].nCommID;
/* If this channel is not waiting, skip it */
        if (comport[nPort].bPlayerBusy) {
                int nRetCode;

            nRetCode = GetCompletionCode(comport[nPort].wDeviceID, nPort, 0);
/* If ok, or got valid error return from port */
            if (!nRetCode || !comport[nPort].bPlayerBusy) {
                comport[nPort].dwBusyStart = 0;
                comport[nPort].bPlayerBusy = FALSE;

/*  Unless the channel is waiting for a frame to be reached (play to x) */
/*  notify the application */
                if (!comport[nPort].bPlayTo)
                    cancel_notify(nPort, nRetCode == 0 ?
                                          MCI_NOTIFY_SUCCESSFUL :
                                          MCI_NOTIFY_FAILURE);
            }
            else {
/* No completion code so skip play */
                if (GetCommError(nCommID, NULL) != 0)
                    cancel_notify(nPort, MCI_NOTIFY_FAILURE);

                if (comport[nPort].dwBusyStart != 0) {
                    if (GetCurrentTime() >
                        comport[nPort].dwBusyStart + PIONEER_MAX_BUSY_TIME)
                        cancel_notify(nPort, MCI_NOTIFY_FAILURE);
                } else
                    comport[nPort].dwBusyStart = GetCurrentTime();

                continue;
            }
        }
        if (comport[nPort].bPlayTo) {

            int nPlay;

            if ((nPlay = IsPlaying(comport[nPort].wDeviceID, nPort)) == 0)
                cancel_notify(nPort, check_arrival(nPort) ?
                                      MCI_NOTIFY_SUCCESSFUL :
                                      MCI_NOTIFY_FAILURE);
            else if (nPlay == -1)
                cancel_notify(nPort, MCI_NOTIFY_FAILURE);
        }
    }
    bYieldWhenReading = TRUE;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api int | LibMain | Library initialization code.
 *
 * @parm HINSTANCE | hModule | Our instance handle.
 *
 * @parm UINT | cbHeap | The heap size from the .def file.
 *
 * @parm LPCSTR | lpszCmdLine | The command line.
 *
 * @rdesc Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
int PASCAL NEAR LibMain(HINSTANCE hModule, UINT cbHeap, LPCSTR lpszCmdLine)
{
    int nPort;

    hInstance = hModule;

/* Port 0 is com1, port 1 is com2, etc... */
    for (nPort = 0; nPort < PIONEER_MAX_COMPORTS; nPort++)
        comport[nPort].nCommID = NO_COMPORT;

#if DBG
    wDebugLevel = GetProfileInt(TEXT("mmdebug"), TEXT("mcipionr"), wDebugLevel);
#endif

    return TRUE;
}

/****************************************************************************
 * Compare up to "n" characters in two strings. Comparison is case insensitive.
 * Returns 0 if they match, and non-zero otherwise.
 ***************************************************************************/
static UINT PASCAL NEAR vdisc_lstrncmp_nocase(LPTSTR lpS1, LPTSTR lpS2, int n)
{
    while (*lpS1 && *lpS2 && n--)
    {
        if (AnsiUpperChar(*lpS1) != AnsiUpperChar(*lpS2))
           break;
        lpS1++;
        lpS2++;
    }
    return n;
}

/****************************************************************************
 * Send a successful notify if wErr is 0 and the MCI_NOTIFY flag is set
 * and supersede any active notification
 ***************************************************************************/
static void PASCAL NEAR notify(UINT wErr, DWORD dwFlags, UINT wDeviceID, LPMCI_GENERIC_PARMS lpParms, int nPort)
{
    if (wErr == 0 && dwFlags & MCI_NOTIFY) {
        cancel_notify(nPort, MCI_NOTIFY_SUPERSEDED);

        mciDriverNotify((HWND)(UINT)lpParms->dwCallback, wDeviceID,
                         MCI_NOTIFY_SUCCESSFUL);
    }
}

/****************************************************************************
 *  Process the MCI_NOTIFY and MCI_WAIT flags
 *
 *  If MCI_NOTIFY then start the timer going (if not started)
 *
 *  If MCI_WAIT then wait until completion if seeking or until the
 *  player is stopped if "play to <x>" is the command
 *
 *  Otherwise, if "play to <x>" was the command then just clear the
 *  bPlayTo flag
 ***************************************************************************/
static DWORD PASCAL NEAR process_delay(UINT wDeviceID, int nPort, DWORD dwFlags, DWORD dwCb)
{
    int nCommID;

    nCommID = comport[nPort].nCommID;

    if (dwFlags & MCI_WAIT) {
        if (comport[nPort].bPlayerBusy) {
            comport[nPort].bPlayerBusy = FALSE;
            if (GetCompletionCode(wDeviceID, nPort, PIONEER_MAX_BUSY_TIME)
                != 0) {
                if (dwFlags & MCI_NOTIFY)
                    mciDriverNotify((HANDLE)dwCb, wDeviceID,
                                     MCI_NOTIFY_FAILURE);
                return MCIERR_HARDWARE;
            }
        }
/*        if (comport[nPort].bPlayTo) */
        {
            int nPlay;

            while ((nPlay = IsPlaying(wDeviceID, nPort)) == 1) {
/* If the operation should be aborted */
                if (pionDriverYield(wDeviceID, nPort) != 0)
                    return process_delay(wDeviceID, nPort, dwFlags & ~MCI_WAIT, dwCb);
#ifdef WIN32
                    Sleep(10);
#endif /* WIN32 */
            }
            comport[nPort].bPlayTo = FALSE;
            if (nPlay == -1) {
                if (dwFlags & MCI_NOTIFY)
                    mciDriverNotify((HANDLE)dwCb,
                                     wDeviceID, MCI_NOTIFY_FAILURE);
                return MCIERR_HARDWARE;
            }
        }
        if (dwFlags & MCI_NOTIFY)
            mciDriverNotify((HANDLE)dwCb, wDeviceID, MCI_NOTIFY_SUCCESSFUL);
    }
    else if (dwFlags & MCI_NOTIFY && (HANDLE)dwCb != NULL) {
        comport[nPort].hCallback = (HANDLE)dwCb;
        if (!comport[nPort].bTimerSet) {
            comport[nPort].bTimerSet = TRUE;
            comport[nPort].wDeviceID = wDeviceID;
            if (nWaitingChannels++ == 0)
                if ((wTimerID = SetTimer(NULL, 1, TIMER_POLLING_PERIOD,
                                          (TIMERPROC)TimerProc)) == 0)
                    return MCIERR_PIONEER_NO_TIMERS;
        }
    } else
        comport[nPort].bPlayTo = FALSE;
    return 0;
}

/****************************************************************************
 * Concatenate lpIN onto lpOut but don't exceed wLen in length, including
 * terminating null.  Returns the total length not including the terminating
 * null or 0 on error or overflow.
 ***************************************************************************/
static UINT PASCAL NEAR catstring(LPSTR lpOut, LPSTR lpIn, int nLen)
{
    int nSize = 0;
    if (lpOut == NULL || lpIn == NULL)
        return 0;

/* search to end of lpOut */
    while (*lpOut != '\0') {
        ++lpOut;
        ++nSize;
    }

/* concatenate */
    while (nSize++ < nLen && *lpIn != '\0')
        *lpOut++ = *lpIn++;

    *lpOut = '\0';
    if (*lpIn != '\0')
        return 0;
    return nSize - 1;
}

/****************************************************************************
 * Convert the input string to a DWORD
 ***************************************************************************/
static DWORD PASCAL NEAR vdisc_atodw(LPSTR lpstrInput)
{
    DWORD dwRet = 0;

    while (*lpstrInput >= '0' && *lpstrInput <= '9')
        dwRet = dwRet * 10 + *lpstrInput++ - '0';

    return dwRet;
}

/****************************************************************************
 * Shut down the device and release the com port
 ***************************************************************************/
static void PASCAL NEAR vdisc_close(UINT wDeviceID, int nPort)
{
    int nCommID = comport[nPort].nCommID;

#if DBG
    CHAR buf[100];
    wsprintfA(buf, "port=%d commid=%d", nPort, nCommID);
    DOUT(buf);
#endif
    DOUT("vdisc_close");
    if (nCommID != NO_COMPORT) {
/* Unlock front panel */
        DOUT("unlock");
/* Don't allow a yield because auto-close will be messed up */
        bYieldWhenReading = FALSE;
        putchars(wDeviceID, nPort, aszClose, TRUE);
        bYieldWhenReading = TRUE;
        DOUT("CloseComm");
        CloseComm(nCommID);
    }
}

/****************************************************************************
 * Switch to frame or time mode whichever is appropriate for the disk type
 ***************************************************************************/
static int PASCAL NEAR unset_chapter_mode(UINT wDeviceID, int nPort)
{
    CHAR buf[8];

    putchars(wDeviceID, nPort, aszQueryMedia, FALSE);
    if (getchars(wDeviceID, nPort, buf, 6, 0) != 6)
        return MCIERR_HARDWARE;
    if (buf[1] == '0')
        putchars(wDeviceID, nPort, aszFormat, TRUE);
    else
        putchars(wDeviceID, nPort, aszTime, TRUE);
    return 0;
}

/****************************************************************************
 * Read the comport number for the input in the form "com<x>"
 ***************************************************************************/
void PASCAL FAR pionGetComportAndRate(LPTSTR lpstrBuf, PUINT pPort, PUINT pRate)
{
    LPTSTR pszChar;

    *pPort = 0;
    *pRate = DEFAULT_BAUD_RATE;

    if (lpstrBuf != NULL) {
        while (*lpstrBuf == ' ')
            ++lpstrBuf;
        if (!vdisc_lstrncmp_nocase(lpstrBuf, aszComm, sizeof(aszComm) / sizeof(TCHAR) - 1))
            if (lpstrBuf[sizeof(aszComm) / sizeof(TCHAR) -1] >= '1' &&
                lpstrBuf[sizeof(aszComm) / sizeof(TCHAR)-1] <=
                '0' + PIONEER_MAX_COMPORTS) {
                UINT    wPort;

                if ((wPort = lpstrBuf[sizeof(aszComm)/sizeof(TCHAR)-1] - '1') < PIONEER_MAX_COMPORTS) {
                    *pPort = wPort;
                }
            }

       /*
        *  Baud rate (if any - default is 4800) is after ','
        */

        for (pszChar = lpstrBuf;
             *pszChar != TEXT(',') && *pszChar != TEXT('\0');
             pszChar++);

        if (*pszChar == TEXT(',')) {
            pszChar++;
        }

        /* Remove blanks */

        for (; *pszChar == TEXT(' '); pszChar++);

        if (*pszChar != TEXT('\0')) {
             UINT Rate = 0;

            /*
             *  Extract the rate
             */

             while (*pszChar >= '0' && *pszChar <= '9') {
                 Rate = Rate * 10 + (*pszChar - TEXT('0'));
                 pszChar++;
             }

             if (Rate != 0) {
                 *pRate = Rate;
             }
        }
    }
}

/****************************************************************************
 * Set the rate for the port
 ***************************************************************************/
void pionSetBaudRate(UINT nPort, UINT nRate)
{
   comport[nPort].Rate = nRate;
}

/****************************************************************************
 * Initialize the player
 ***************************************************************************/
static DWORD PASCAL NEAR init_player(UINT wDeviceID, int nPort)
{
    CHAR buf[VDISC_BUFFER_LENGTH];
    BOOL bPlayerSpinning = FALSE;

/* Set the audio channels to a known state (both on) */
    putchars(wDeviceID, nPort, aszAudioOn, TRUE);
    comport[nPort].wAudioChannels = 3;

/* See if the disk is spinning */
    putchars(wDeviceID, nPort, aszQueryPlaying, FALSE);
    getchars(wDeviceID, nPort, buf, 4, 0);

    if (buf[0] == 'P' && buf[2] != '0' && buf[2] != '1') {
        bPlayerSpinning = TRUE;

/* What kind of disc is this (CAV or CLV)? */
        putchars(wDeviceID, nPort, aszQueryMedia, FALSE);
        if (getchars(wDeviceID, nPort, buf, 6, 0) != 6)
            return MCIERR_HARDWARE;
        if (buf[1] != '1') {
            comport[nPort].dwTimeMode = MCI_FORMAT_FRAMES;
            comport[nPort].bCAVDisc = TRUE;
/* Set mode to frames */
            putchars(wDeviceID, nPort, aszFormat, TRUE);
        }
        else {
            comport[nPort].dwTimeMode = MCI_FORMAT_HMS;
            comport[nPort].bCAVDisc = FALSE;
/* Set mode to hms */
            putchars(wDeviceID, nPort, aszTime, TRUE);
        }
    }
    else {
        bPlayerSpinning = FALSE;
        comport[nPort].dwTimeMode = NO_TIME_MODE;
    }

    comport[nPort].bPlayerBusy = FALSE;
    comport[nPort].bDoorAction = FALSE;
    comport[nPort].bPlayTo = FALSE;
    comport[nPort].bTimerSet = FALSE;
    comport[nPort].dwBusyStart = 0;
    comport[nPort].dwDirection = PION_PLAY_NO_DIRECTION;

    if (!bPlayerSpinning && comport[nPort].bResponding
        && spinupdown(wDeviceID, nPort, MCI_VD_SPIN_UP, FALSE) != 0)

        return MCIERR_HARDWARE;
    else
        return 0;
}

/****************************************************************************
 * Process the MCI_OPEN_DRIVER message
 ***************************************************************************/
static DWORD PASCAL NEAR open(UINT wDeviceID, int nPort, DWORD dwFlags)
{
    DCB dcb;
    TCHAR strDescription [20];
    int nCommID;

    if (dwFlags & MCI_OPEN_ELEMENT)
        return MCIERR_NO_ELEMENT_ALLOWED;

/* See if a com port was specified in the SYSTEM.INI parameters */
    wsprintf(strDescription, aszCommOpenFormat, (LPSTR)aszComm, nPort + 1);

/* Try to open the com port */
    if ((nCommID = OpenComm(strDescription, 100, 100)) < 0)
        return MCIERR_HARDWARE;

/* Set up the com port, 4800 baud (switch S7 UP) or 9600 baud is assumed */
    wsprintf(strDescription, aszCommSetupFormat, (LPTSTR)aszComm, nPort + 1,
             comport[nPort].Rate);

    /*
     * need to initialise state of dcb first since BuildCommDCB only sets
     * some fields
     */
    GetCommState((HANDLE)nCommID, &dcb);

    BuildCommDCB(strDescription, &dcb);

    if (!SetCommState((HANDLE)nCommID, &dcb)) {

        CloseComm(nCommID);
        return MCIERR_HARDWARE;
    }

/* Set up the channel description */
    comport[nPort].nCommID = nCommID;
    if (dwFlags & MCI_OPEN_SHAREABLE)
        comport[nPort].bShareable = TRUE;
    else
        comport[nPort].bShareable = FALSE;

/* Don't make the user wait at this point to test if the device responds -
   they can wait when they really try to use the device */

    comport[nPort].bResponding = FALSE;

    return 0;
}

/****************************************************************************
 * Convert the given position dwPos in the current time format into the units
 * appropriate for the disk type puting the result in buf
 ***************************************************************************/
static DWORD PASCAL NEAR encode_position(UINT wDeviceID, LPSTR buf, DWORD dwPos, int nPort)
{
    BYTE h, m, s;

/* Allow frame 0 */
    if (dwPos == 0
        && comport[nPort].dwTimeMode != MCI_FORMAT_HMS
        && comport[nPort].dwTimeMode != MCI_VD_FORMAT_TRACK)
        dwPos = 1;

    if (comport[nPort].dwTimeMode == NO_TIME_MODE)
        set_time_mode(wDeviceID, nPort);

    switch (comport[nPort].dwTimeMode) {

        case MCI_FORMAT_FRAMES:
/* Ensure frame is at most five characters */
            if (!VALID_FRAME(dwPos))
                return MCIERR_OUTOFRANGE;
            wsprintfA(buf, aszFrameFormat, dwPos);
            break;

        case MCI_FORMAT_HMS:
            h = MCI_HMS_HOUR(dwPos);
            m = MCI_HMS_MINUTE(dwPos);
            s = MCI_HMS_SECOND(dwPos);
            if (h > 9 || m > 59 || s > 59)
                return MCIERR_OUTOFRANGE;

            if (comport[nPort].bCAVDisc)
                wsprintfA(buf, aszFrameFormat, (DWORD)(((h * 60) + m) * 60 + s) *
                                      CAV_FRAMES_PER_SECOND);
            else {
                wsprintfA(buf, aszHMSFormat, h, m, s);
                if (m < 10)
                    buf[1] = '0';
                if (s < 10)
                    buf[3] = '0';
            }
            break;

        case MCI_FORMAT_MILLISECONDS:
            if (comport[nPort].bCAVDisc) {
                dwPos = (dwPos * 3) / 100; /* 30 frames/second */
                wsprintfA(buf, aszFrameFormat, dwPos);
            }
            else {
                UINT wX;
                dwPos /= 1000; /* ignore fractions of a second */

                /* Number of minutes leftover from hours */
                wX = (UINT)(dwPos % 3600);
                h = (CHAR)((dwPos - wX) / 3600);
                if (h > 9)
                    return MCIERR_OUTOFRANGE;

                dwPos = wX;

                s = (CHAR)(dwPos % 60);
                m = (CHAR)((dwPos - s) / 60);

                wsprintfA(buf, aszHMSFormat, h, m, s);
/* Fill in leading zero's */
                if (m < 10)
                    buf[1] = '0';
                if (s < 10)
                    buf[3] = '0';
                }
                break;

        case MCI_VD_FORMAT_TRACK:
            if (dwPos > 99)
                return MCIERR_OUTOFRANGE;
            wsprintfA(buf, aszTrackFormat, dwPos);
            break;
    }

    return 0L;
}

/****************************************************************************
 * Convert frames to the output representation for the current time mode
 ***************************************************************************/
static DWORD PASCAL NEAR convert_frames(UINT wDeviceID, int nPort, DWORD dwFrames, LPDWORD lpdwReturn)
{

    if (comport[nPort].dwTimeMode == NO_TIME_MODE)
        set_time_mode(wDeviceID, nPort);
    switch (comport[nPort].dwTimeMode) {

        case MCI_FORMAT_FRAMES:
            *lpdwReturn = dwFrames;
            break;

        case MCI_FORMAT_MILLISECONDS:
            *lpdwReturn = (dwFrames * 100) / 3; /* 30 frames per second */
            break;

        case MCI_FORMAT_HMS:
        {
            DWORD dwSeconds = dwFrames / CAV_FRAMES_PER_SECOND;

            *lpdwReturn = MCI_MAKE_HMS(dwSeconds / 3600,
                                       (dwSeconds % 3600) / 60,
                                       dwSeconds % 60);

            return MCI_COLONIZED3_RETURN;
        }
    }

    return 0;
}

/****************************************************************************
 * Convert hms to the output representation for the current time mode
 ***************************************************************************/
static DWORD PASCAL NEAR convert_hms(UINT wDeviceID, int nPort, LPSTR buf, LPDWORD lpdwReturn)
{
    if (comport[nPort].dwTimeMode == NO_TIME_MODE)
        set_time_mode(wDeviceID, nPort);

    if (comport[nPort].dwTimeMode == MCI_FORMAT_HMS) {
        UINT wTemp;

        *lpdwReturn = MCI_MAKE_HMS(buf[0] - '0',
                                   (buf[1] - '0') * 10 + buf[2] - '0',
                                   (buf[3] - '0') * 10 + buf[4] - '0');

        return MCI_COLONIZED3_RETURN;
    }
    else if (comport[nPort].dwTimeMode == MCI_FORMAT_MILLISECONDS) {
        *lpdwReturn =
                    (buf[0] - '0') * 3600000L +
                    ((buf[1] - '0') * 10 + (buf[2] - '0')) * 60000L +
                    ((buf[3] - '0') * 10 + (buf[4] - '0')) * 1000L;
        return 0;
    } else
        return MCIERR_HARDWARE;
}

/****************************************************************************/

static  int PASCAL NEAR DeviceStatusMode(
        UINT    wDeviceID,
        int     nPort)
{
#define PIONEER_MODE_OPEN     '0'
#define PIONEER_MODE_PARK     '1'
#define PIONEER_MODE_PLAY     '4'
#define PIONEER_MODE_STILL    '5'
#define PIONEER_MODE_PAUSE    '6'
#define PIONEER_MODE_MULTI    '9'

    CHAR buf[VDISC_BUFFER_LENGTH];
    UINT wPos;

    putchars(wDeviceID, nPort, aszQueryPlaying, FALSE);
    if (getchars(wDeviceID, nPort, buf, 4, 0) == 0)
        return MCI_MODE_NOT_READY;
/* This is done to remove the spurious return character generated */
/* if this command is sent after power is cut and restored to the player */
    if (buf[0] != 'P' && buf[1] == 'P') {
        wPos = 3;
        getchars(wDeviceID, nPort, buf, 1, 200);
    }
    else
        wPos = 2;

    switch (buf[wPos]) {

    case PIONEER_MODE_OPEN:
        return MCI_MODE_OPEN;

    case PIONEER_MODE_PARK:
        return MCI_VD_MODE_PARK;

    case PIONEER_MODE_PLAY:
        return MCI_MODE_PLAY;

    case PIONEER_MODE_STILL:
        return MCI_MODE_PAUSE;

    case PIONEER_MODE_PAUSE:
        return MCI_MODE_STOP;

    case PIONEER_MODE_MULTI:
        return MCI_MODE_PLAY;

    default:
        return MCI_MODE_NOT_READY;

    }
}

/****************************************************************************
 * Process the MCI_STATUS message
 ***************************************************************************/
static DWORD PASCAL NEAR status(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_STATUS_PARMS lpStatus)
{
    CHAR buf[VDISC_BUFFER_LENGTH];
    int n;
    DWORD dwRet;
    DWORD dwMediaType;

    if (!(dwFlags & MCI_STATUS_ITEM))
        return MCIERR_MISSING_PARAMETER;

    switch (lpStatus->dwItem) {

        case MCI_STATUS_MODE:
        {
            n = DeviceStatusMode(wDeviceID, nPort);
            if (n == MCI_MODE_NOT_READY)
                n = DeviceStatusMode(wDeviceID, nPort);

            lpStatus->dwReturn = MAKEMCIRESOURCE(n, n);
            return MCI_RESOURCE_RETURNED;
        }

        case MCI_STATUS_POSITION:
            putchars(wDeviceID, nPort, aszQueryPlaying, FALSE);
            getchars(wDeviceID, nPort, buf, 4, 0);

            if (buf[0] == 'P' && buf[1] == '0' && buf[2] == '0')
                return MCIERR_HARDWARE;

            dwRet = spinupdown(wDeviceID, nPort, MCI_VD_SPIN_UP, TRUE);
            if (dwRet != 0)
                return dwRet;
            if (dwFlags & MCI_TRACK)
                return MCIERR_UNSUPPORTED_FUNCTION;
            if (dwFlags & MCI_STATUS_START) {
                if (comport[nPort].dwTimeMode == NO_TIME_MODE)
                    set_time_mode(wDeviceID, nPort);
                switch (comport[nPort].dwTimeMode) {
                    case MCI_VD_FORMAT_TRACK:
                        lpStatus->dwReturn = 0;
                        return 0;
                    case MCI_FORMAT_FRAMES:
                        lpStatus->dwReturn = 1;
                        return 0;
                    case MCI_FORMAT_HMS:
                        lpStatus->dwReturn = 0;
                        return MCI_COLONIZED3_RETURN;
                    case MCI_FORMAT_MILLISECONDS:
                        if (comport[nPort].bCAVDisc)
                            lpStatus->dwReturn = 1000 / CAV_FRAMES_PER_SECOND;
                        else
                            lpStatus->dwReturn = 0;
                        return 0;
                    default:
                        return MCIERR_HARDWARE;
                }
            }
            if (comport[nPort].dwTimeMode == MCI_VD_FORMAT_TRACK) {
                putchars(wDeviceID, nPort, aszQueryTrack, FALSE);
                n = getchars(wDeviceID, nPort, buf, 3, 0);
                buf[n-1] = '\0';
                if (buf[0] == 'E')
                    return MCIERR_HARDWARE;
                lpStatus->dwReturn = vdisc_atodw(buf);
                return 0;
            }

            if (comport[nPort].dwTimeMode == NO_TIME_MODE)
                set_time_mode(wDeviceID, nPort);
            else
                get_media_type(wDeviceID, nPort, &dwMediaType);

            if (comport[nPort].bCAVDisc) {
/* Try FRAMES */
                putchars(wDeviceID, nPort, aszQueryFormat, FALSE);
                n = getchars(wDeviceID, nPort, buf, 6, 0);
                buf[n - 1] = '\0';

/* If no error then convert from frames */
                if (buf[0] != 'E')
                    return convert_frames(wDeviceID, nPort, vdisc_atodw(buf),
                                        &lpStatus->dwReturn);
                else
                    return MCIERR_HARDWARE;
            }
            else {
/* Try TIME */
                putchars(wDeviceID, nPort, aszQueryTime, FALSE);
                n = getchars(wDeviceID, nPort, buf, 6, 0);
                buf[n - 1] = '\0';
                if (buf[0] == 'E') {
                    DOUT("mcipionr:  error returning HMS position");
                    return MCIERR_HARDWARE;
                }
                if (comport[nPort].dwTimeMode == MCI_FORMAT_FRAMES)
                    return MCIERR_HARDWARE;
                else
                    return convert_hms(wDeviceID, nPort, buf, &lpStatus->dwReturn);
            }

        case MCI_STATUS_MEDIA_PRESENT:
            putchars(wDeviceID, nPort, aszQueryMedia, FALSE);
            if (getchars(wDeviceID, nPort, buf, 6, 0) != 6)
                return MCIERR_HARDWARE;
            if (buf[0] == '1')
                lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            else
                lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
            return MCI_RESOURCE_RETURNED;

        case MCI_VD_STATUS_SPEED:
            return MCIERR_UNSUPPORTED_FUNCTION;

        case MCI_VD_STATUS_MEDIA_TYPE:
        {
            dwRet = get_media_type(wDeviceID, nPort, &dwMediaType);
            if (dwRet)
                return dwRet;

            n = LOWORD(dwMediaType);
            lpStatus->dwReturn = MAKEMCIRESOURCE(n, n);
            return MCI_RESOURCE_RETURNED;
        }

        case MCI_VD_STATUS_SIDE:
        {
            DWORD dwRet = IsDiscSpinning(wDeviceID, nPort);

            if (dwRet != 0)
                return dwRet;

            putchars(wDeviceID, nPort, aszQueryMedia, FALSE);
            if (getchars(wDeviceID, nPort, buf, 6, 0) != 6)
                return MCIERR_HARDWARE;
            if (buf[0] == '0')
                return MCIERR_PIONEER_NOT_SPINNING;
            if (buf[3] == '0')
                lpStatus->dwReturn = 1;
            else
                lpStatus->dwReturn = 2;
            return 0;
        }

        case MCI_VD_STATUS_DISC_SIZE:
        {
            DWORD dwRet = IsDiscSpinning(wDeviceID, nPort);

            if (dwRet != 0)
                return dwRet;

            putchars(wDeviceID, nPort, aszQueryMedia, FALSE);
            if (getchars(wDeviceID, nPort, buf, 6, 0) != 6)
                return MCIERR_HARDWARE;
            if (buf[0] == '0')
                return MCIERR_PIONEER_NOT_SPINNING;
            if (buf[2] == '0')
                lpStatus->dwReturn = 12;
            else
                lpStatus->dwReturn = 8;
            return 0;
        }

        case MCI_STATUS_READY:
            putchars(wDeviceID, nPort, aszQueryPlaying, FALSE);
            if (getchars(wDeviceID, nPort, buf, 4, 0) != 4)
                lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
            else
                lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            return MCI_RESOURCE_RETURNED;

        case MCI_STATUS_LENGTH:
        {
            if (dwFlags & MCI_TRACK)
                return MCIERR_UNSUPPORTED_FUNCTION;
            putchars(wDeviceID, nPort, aszQueryPlaying, FALSE);
            getchars(wDeviceID, nPort, buf, 4, 0);

            if (buf[0] == 'P' && buf[1] == '0' && buf[2] == '0')
                return MCIERR_HARDWARE;

            dwRet = spinupdown(wDeviceID, nPort, MCI_VD_SPIN_UP, TRUE);
            if (dwRet != 0)
                return dwRet;

            if (comport[nPort].dwTimeMode == MCI_VD_FORMAT_TRACK)
                return MCIERR_BAD_TIME_FORMAT;

            dwRet = get_media_type(wDeviceID, nPort, &dwMediaType);
            if (dwRet)
                return dwRet;
            if (dwMediaType == MCI_VD_MEDIA_CAV)
                return convert_frames(wDeviceID, nPort, CAV_MAX_DISC_FRAMES,
                                    &lpStatus->dwReturn);
                return convert_hms(wDeviceID, nPort, aszCLVLength, &lpStatus->dwReturn);
        }

        case MCI_STATUS_TIME_FORMAT:
            putchars(wDeviceID, nPort, aszQueryPlaying, FALSE);
            getchars(wDeviceID, nPort, buf, 4, 0);

            if (buf[0] == 'P' && buf[1] == '0' && buf[2] == '0')
                return MCIERR_HARDWARE;

            dwRet = spinupdown(wDeviceID, nPort, MCI_VD_SPIN_UP, TRUE);
            if (dwRet != 0)
                return dwRet;

            if (comport[nPort].dwTimeMode == NO_TIME_MODE)
                set_time_mode(nPort, wDeviceID);
            n = LOWORD(comport[nPort].dwTimeMode);
            if (n == MCI_VD_FORMAT_TRACK)
                lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VD_FORMAT_TRACK,
                                                     MCI_VD_FORMAT_TRACK_S);
            else
                lpStatus->dwReturn =
                    MAKEMCIRESOURCE(n, n + MCI_FORMAT_RETURN_BASE);
            return MCI_RESOURCE_RETURNED;

        case MCI_STATUS_CURRENT_TRACK:
            putchars(wDeviceID, nPort, aszQueryPlaying, FALSE);
            getchars(wDeviceID, nPort, buf, 4, 0);

            if (buf[0] == 'P' && buf[1] == '0' && buf[2] == '0')
                return MCIERR_HARDWARE;

            dwRet = spinupdown(wDeviceID, nPort, MCI_VD_SPIN_UP, TRUE);
            if (dwRet != 0)
                return dwRet;

            putchars(wDeviceID, nPort, aszQueryTrack, FALSE);
            n = getchars(wDeviceID, nPort, buf, 3, 0);
            buf[n-1] = '\0';
            if (buf[0] == 'E') {
                /* Flush buffer */
                getchars(wDeviceID, nPort, buf, 2, 0);

                /* See if the problem is no chapter support */
                putchars(wDeviceID, nPort, aszQueryMedia, FALSE);
                if (getchars(wDeviceID, nPort, buf, 6, 0) != 6 ||
                    buf[4] == '1')
                    return MCIERR_HARDWARE;
                else
                    return MCIERR_PIONEER_NO_CHAPTERS;
            }
            lpStatus->dwReturn = vdisc_atodw(buf);
            return 0;
    }

    return MCIERR_UNSUPPORTED_FUNCTION;
}

/****************************************************************************
 * Process the MCI_SEEK message
 ***************************************************************************/
static DWORD PASCAL NEAR seek(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_SEEK_PARMS lpSeek)
{
    int comlen;
    CHAR buf[VDISC_BUFFER_LENGTH];
    DWORD dwErr;
    DWORD dwMediaType;

    buf[0] = '\0';

/* Position for the wsprintf to start */
    comlen = 0;

    if (IsDiscSpinning(wDeviceID, nPort) != 0) {
        if (dwFlags & MCI_TO) {
/* Must spin up NOW if a to position needs to be converted */
            putchars(wDeviceID, nPort, aszSpinUp, FALSE);
            GetCompletionCode(wDeviceID, nPort, PIONEER_MAX_BUSY_TIME);
        } else
        {
            comlen = 2;
            catstring(buf, aszSpinUp, VDISC_BUFFER_LENGTH);
/* 2 characters possible here */
            comport[nPort].bPlayerBusy = TRUE;
        }
    }
    if (dwFlags & (MCI_TO | MCI_SEEK_TO_START | MCI_SEEK_TO_END)) {
        if (dwFlags & MCI_SEEK_TO_START) {
            if (dwFlags & MCI_SEEK_TO_END)
                return MCIERR_FLAGS_NOT_COMPATIBLE;
            catstring (buf, aszSeekStart, VDISC_BUFFER_LENGTH);
        }
        else if (dwFlags & MCI_SEEK_TO_END) {
            catstring (buf, aszSeekEnd, VDISC_BUFFER_LENGTH);
        }
        else if (dwFlags & MCI_TO) {
            if (comport[nPort].dwTimeMode == NO_TIME_MODE)
                set_time_mode(wDeviceID, nPort);

            if ((dwErr = encode_position(wDeviceID, &buf[comlen], lpSeek->dwTo, nPort))
                != 0)
                return dwErr;

            catstring(buf, aszSeekTo, VDISC_BUFFER_LENGTH);
        }
        putchars(wDeviceID, nPort, buf, FALSE);

        comport[nPort].bPlayerBusy = TRUE;
    }
    else {
        catstring(buf, aszSeekSetSpeed, VDISC_BUFFER_LENGTH);
        if (dwFlags & MCI_VD_SEEK_REVERSE) {
            dwErr = get_media_type(wDeviceID, nPort, &dwMediaType);
	    if (dwErr)
		    return dwErr;
	    if (dwMediaType == MCI_VD_MEDIA_CAV)
                catstring(buf, aszMediaReverse, VDISC_BUFFER_LENGTH);
            else
                return MCIERR_PIONEER_ILLEGAL_FOR_CLV;
        }
        else
            catstring(buf, aszMediaForward, VDISC_BUFFER_LENGTH);
        putchars(wDeviceID, nPort, buf, TRUE);
        if (dwFlags & MCI_NOTIFY) {
            comport[nPort].bPlayTo = TRUE;
            comport[nPort].dwPlayTo = NO_TO_POSITION;
        }
    }

    cancel_notify(nPort, MCI_NOTIFY_ABORTED);

    process_delay(wDeviceID, nPort, dwFlags, lpSeek->dwCallback);
    return 0;
}

/****************************************************************************
 * Process the MCI_PLAY message
 ***************************************************************************/
static DWORD PASCAL NEAR play(UINT wDeviceID, int nPort, DWORD dwFlags, MCI_VD_PLAY_PARMS FAR *lpPlay)
{

    LPSTR compart;
    int comlen;
    DWORD dwErr;
    DWORD dwMediaType;
    BOOL bNormalSpeed = FALSE;
    CHAR buf[VDISC_BUFFER_LENGTH];
    DWORD dwOldToPosition = comport[nPort].bPlayTo ? comport[nPort].dwPlayTo
                            : NO_TO_POSITION;
    DWORD dwOldDirection = comport[nPort].dwDirection;
    BOOL bPlayerSpinning;
    BOOL bGoingToBeBusy = FALSE;

    buf[0] = '\0';

/* Convert a 'play x to x' into 'seek to x' if the positions are equal or */
/* for milliseconds if they are within the same frame or second */
    if (dwFlags & MCI_FROM && dwFlags & MCI_TO &&
        (lpPlay->dwTo == lpPlay->dwFrom ||
        (comport[nPort].dwTimeMode == MCI_FORMAT_MILLISECONDS &&
         lpPlay->dwTo - lpPlay->dwFrom <
         (DWORD)(comport[nPort].bCAVDisc ? 40 : 1000))))
    {
        MCI_SEEK_PARMS Seek;
/* Preserve NOTIFY and WAIT and set TO flag */
        DWORD dwSeekFlags;

        dwSeekFlags = ((dwFlags & (MCI_NOTIFY | MCI_WAIT)) | MCI_TO);

        Seek.dwTo = lpPlay->dwFrom;
        Seek.dwCallback = lpPlay->dwCallback;
        return seek(wDeviceID, nPort, dwSeekFlags,
                     (LPMCI_SEEK_PARMS)&Seek);
    }

/* Build a command string to send to the player */

/* Position for the wsprintf to start */
    comlen = 0;

#define PLAY_SPEED_FLAGS (MCI_VD_PLAY_FAST | MCI_VD_PLAY_SLOW | \
                          MCI_VD_PLAY_SPEED | MCI_VD_PLAY_SCAN)

/* Determine speed */
    if (dwFlags & MCI_VD_PLAY_FAST) {
        if ((dwFlags & PLAY_SPEED_FLAGS) != MCI_VD_PLAY_FAST)
            return MCIERR_FLAGS_NOT_COMPATIBLE;
        /* PLAY FAST */
        compart = aszFastSetSpeed;
    }
    else if (dwFlags & MCI_VD_PLAY_SLOW) {
        if ((dwFlags & PLAY_SPEED_FLAGS) != MCI_VD_PLAY_SLOW)
            return MCIERR_FLAGS_NOT_COMPATIBLE;
        /* PLAY SLOW */
        compart = aszSlowSetSpeed;
    }
    else if (dwFlags & MCI_VD_PLAY_SPEED &&
             lpPlay->dwSpeed != CAV_FRAMES_PER_SECOND) {
        if ((dwFlags & PLAY_SPEED_FLAGS) != MCI_VD_PLAY_SPEED)
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        if (lpPlay->dwSpeed > 127)
            return MCIERR_OUTOFRANGE;

        wsprintfA(buf, aszSetSpeedFormat, (UINT)lpPlay->dwSpeed * 2);
        compart = buf;
    }
    else if (dwFlags & MCI_VD_PLAY_SCAN) {
        wsprintfA(buf, aszSetSpeedFormat, 255);
        compart = buf;
    }
    else {
        /* PLAY NORMAL */
        compart = aszNull;
        if (dwFlags & MCI_VD_PLAY_REVERSE)
            compart = aszMediumSetSpeed;
        bNormalSpeed = TRUE;
    }
    if (compart[0] != '\0')
        putchars(wDeviceID, nPort, compart, TRUE);

    if (!(bPlayerSpinning = !IsDiscSpinning(wDeviceID, nPort))) {
        if ((dwFlags & (MCI_TO | MCI_FROM)) != 0 || !bNormalSpeed) {
/* Must spin up NOW if a position needs to be converted */
            putchars(wDeviceID, nPort, aszSpinUp, FALSE);
            GetCompletionCode(wDeviceID, nPort, PIONEER_MAX_BUSY_TIME);
        }
        else {
            catstring(buf, aszSpinUp, VDISC_BUFFER_LENGTH);
            comlen = 2;
/* 2 characters possible here */
            bGoingToBeBusy = TRUE;
        }
    }

    if (!bNormalSpeed &&
        !get_media_type(wDeviceID, nPort, &dwMediaType) && (dwMediaType == MCI_VD_MEDIA_CLV))
        return MCIERR_PIONEER_ILLEGAL_FOR_CLV;
/* If FROM was specified */
    if (dwFlags & MCI_FROM) {
        if (comport[nPort].dwTimeMode == NO_TIME_MODE)
            set_time_mode(wDeviceID, nPort);

        if ((dwErr = encode_position(wDeviceID, &buf[comlen], lpPlay->dwFrom, nPort))
            != 0)
            return dwErr;
/* 5 characters possible here, total of 7 */
        catstring(buf, aszSeekTo, VDISC_BUFFER_LENGTH);
/* 2 characters possible here, total of 9 */
        bGoingToBeBusy = TRUE;
    }

/* If TO was specified */
    if (dwFlags & MCI_TO) {
        CHAR tobuf[10];
        DWORD dwFrom;

        if (dwFlags & MCI_VD_PLAY_REVERSE)
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        if (comport[nPort].dwTimeMode == NO_TIME_MODE)
            set_time_mode(wDeviceID, nPort);

        if ((dwErr = encode_position(wDeviceID, tobuf, lpPlay->dwTo, nPort)) != 0)
            return dwErr;

        catstring(buf, tobuf, VDISC_BUFFER_LENGTH);
/* 5 characters possible here, total of 14 */
        catstring(buf, aszStopMarker, VDISC_BUFFER_LENGTH);
/* 2 characters possible here, total of 16 */
        comport[nPort].bPlayTo = TRUE;
        comport[nPort].dwPlayTo = lpPlay->dwTo;
        comport[nPort].dwToTimeMode = comport[nPort].dwTimeMode;

/* If to is less than from then go in reverse */
        if (dwFlags & MCI_FROM)
            dwFrom = lpPlay->dwFrom;
        else {
            if (!bPlayerSpinning)
                dwFrom = 0;
            else {
                MCI_STATUS_PARMS Status;
                Status.dwItem = MCI_STATUS_POSITION;
                if ((dwErr =
                    status(wDeviceID, nPort, MCI_STATUS_ITEM,
                            (LPMCI_STATUS_PARMS)&Status)) != 0)
                    return dwErr;
                dwFrom = Status.dwReturn;
            }
        }
/* Compare from and to positions */
        if (comport[nPort].dwTimeMode == MCI_FORMAT_HMS) {
/* Account for slop */
            DWORD dwTo = lpPlay->dwTo;
            if (MCI_HMS_HOUR(dwTo) < MCI_HMS_HOUR(dwFrom))
                dwFlags |= MCI_VD_PLAY_REVERSE;
            else if (MCI_HMS_HOUR(dwTo) == MCI_HMS_HOUR(dwFrom)) {
                if (MCI_HMS_MINUTE(dwTo) < MCI_HMS_MINUTE(dwFrom))
                    dwFlags |= MCI_VD_PLAY_REVERSE;
                else if (MCI_HMS_MINUTE(dwTo) == MCI_HMS_MINUTE(dwFrom)) {
                    int nDelta = MCI_HMS_SECOND(dwTo) - MCI_HMS_SECOND(dwFrom);
/* Position is plus or minus 1 second from HMS */
                    if (nDelta <= 1 && nDelta >= -1)
                        dwFrom = lpPlay->dwTo;
                    else if (nDelta < 0)
                        dwFlags |= MCI_VD_PLAY_REVERSE;
                }
            }
        }
        else if (comport[nPort].dwTimeMode == MCI_FORMAT_MILLISECONDS) {
/* Account for slop */
            long lDelta = lpPlay->dwTo - dwFrom;
            if (lDelta < 0) {
                lDelta = -lDelta;
                dwFlags |= MCI_VD_PLAY_REVERSE;
            }
            if (comport[nPort].bCAVDisc &&
                lDelta < 1000 / CAV_FRAMES_PER_SECOND)
                dwFrom = lpPlay->dwTo;
            else if (lDelta < 1000)
                dwFrom = lpPlay->dwTo;
        } else if (lpPlay->dwTo < dwFrom)
            dwFlags |= MCI_VD_PLAY_REVERSE;
        if (!comport[nPort].bCAVDisc && dwFlags & MCI_VD_PLAY_REVERSE)
            return MCIERR_PIONEER_ILLEGAL_FOR_CLV;
/* If from == to then do nothing */
        if (lpPlay->dwTo == dwFrom) {
            notify(0, dwFlags, wDeviceID,
                    (LPMCI_GENERIC_PARMS)lpPlay, nPort);
            return 0;
        }

    }
    else {
        comport[nPort].bPlayTo = TRUE;
        comport[nPort].dwPlayTo = NO_TO_POSITION;
    }

    /* Determine direction */
    if (dwFlags & MCI_VD_PLAY_REVERSE)
        /* PLAY REVERSE */
        compart = aszMediaReverse;
    else if (bNormalSpeed)
        /* PLAY FORWARD NORMAL SPEED */
/*  The PL command is used here instead of 60SPMF because only PL is */
/*  legal for CLV discs */
        compart = aszPlay;
    else
        /* PLAY FORWARD */
        compart = aszMediaForward;
    catstring(buf, compart, VDISC_BUFFER_LENGTH);
/* 2 characters possible here, total of 18, buffer size is 20 */

    if (putchars(wDeviceID, nPort, buf, !bGoingToBeBusy) != 0)
        return MCIERR_HARDWARE;

    if (bGoingToBeBusy)
        comport[nPort].bPlayerBusy = TRUE;

    if (dwFlags & MCI_VD_PLAY_REVERSE)
        comport[nPort].dwDirection = MCI_VD_PLAY_REVERSE;
    else
        comport[nPort].dwDirection = PION_PLAY_FORWARD;

/* If a from position is specified or a to position is specified with
 * a different position than the active notify or if a new direction is
 * specified then cancel notify;
 */
    if (dwFlags & MCI_FROM ||
        comport[nPort].dwPlayTo != dwOldToPosition ||
        (dwOldDirection != PION_PLAY_NO_DIRECTION &&
         comport[nPort].dwDirection != dwOldDirection))

        cancel_notify(nPort, MCI_NOTIFY_ABORTED);
    else if (dwFlags & MCI_NOTIFY)
        cancel_notify(nPort, MCI_NOTIFY_SUPERSEDED);

/*    if (comport[nPort].bPlayerBusy || comport[nPort].bPlayTo) */
    process_delay(wDeviceID, nPort, dwFlags, lpPlay->dwCallback);
    return 0;
}

/****************************************************************************
 * Process the MCI_STOP and MCI_PAUSE messages
 ***************************************************************************/
static DWORD PASCAL NEAR stop_pause(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_GENERIC_PARMS lpGeneric, UINT wCommand)
{
    DWORD dwErr;
    DWORD dwMediaType;

/* Note, "ST" stands for 'still', "PA" stands for 'pause' but */
/* in MCI lingo "stop" uses the "PA" command and "pause" uses "ST" */
    if ((dwErr = IsDiscSpinning(wDeviceID, nPort)) == 0) {
        dwErr = (DWORD)putchars(wDeviceID, nPort,
                                  wCommand == MCI_STOP ? aszPause : aszStop,
                                  TRUE);
/* If error and CLV disc then try "stop" instead */
        if (dwErr != 0 && wCommand == MCI_PAUSE)
            if (!get_media_type(wDeviceID, nPort, &dwMediaType) && (dwMediaType == MCI_VD_MEDIA_CLV))
                dwErr = (DWORD)putchars(wDeviceID, nPort, aszPause, TRUE);
    }

    if (dwErr == 0)
        cancel_notify(nPort, MCI_NOTIFY_ABORTED);

    notify(LOWORD(dwErr), dwFlags, wDeviceID, lpGeneric, nPort);

    return dwErr;
}

/****************************************************************************
 * Spin the player up or down depending on dwFlag
 ***************************************************************************/
static DWORD PASCAL NEAR spinupdown(UINT wDeviceID, int nPort, DWORD dwFlag, BOOL bWait)
{
    if (dwFlag & MCI_VD_SPIN_UP) {
        if (IsDiscSpinning(wDeviceID, nPort) != 0) {
            DWORD dwErr;
            if (!bWait) {
                comport[nPort].bPlayerBusy = TRUE;
                comport[nPort].bDoorAction = TRUE;
            }
            if (putchars(wDeviceID, nPort, aszSpinUp, FALSE) != 0)
                return MCIERR_HARDWARE;
            if (bWait && (dwErr =
                 GetCompletionCode(wDeviceID, nPort, PIONEER_MAX_BUSY_TIME)) != 0)
                return dwErr;
        }
    }
    else if (dwFlag & MCI_VD_SPIN_DOWN) {
        if (IsDiscSpinning(wDeviceID, nPort) == 0) {
            comport[nPort].bPlayerBusy = TRUE;
            comport[nPort].dwDirection = PION_PLAY_NO_DIRECTION;

            cancel_notify(nPort, MCI_NOTIFY_ABORTED);

            if (putchars(wDeviceID, nPort, aszReject, bWait) != 0)
                return MCIERR_HARDWARE;
        }
    } else
        return MCIERR_MISSING_PARAMETER;

    return 0;
}

/****************************************************************************
 * Process the MCI_SPIN message
 ***************************************************************************/
static DWORD PASCAL NEAR spin(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_GENERIC_PARMS lpGeneric)
{
    DWORD dwErr;

    dwErr = spinupdown(wDeviceID, nPort, dwFlags, FALSE);
    if (dwErr != 0)
        return dwErr;

    if (comport[nPort].bPlayerBusy)
        process_delay(wDeviceID, nPort, dwFlags, lpGeneric->dwCallback);
    else
        notify(0, dwFlags, wDeviceID, lpGeneric,
                nPort);

    return 0;
}

/****************************************************************************
 * Process the MCI_STEP message
 ***************************************************************************/
static DWORD PASCAL NEAR step(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_VD_STEP_PARMS lpStep)
{
    DWORD dwFrame, dwErr;
    int n;
    CHAR buf[VDISC_BUFFER_LENGTH];
    DWORD dwMediaType;

    if (dwFlags & MCI_VD_STEP_FRAMES) {
        if (comport[nPort].dwTimeMode == NO_TIME_MODE)
            set_time_mode(wDeviceID, nPort);
/* Must get current position and go from there */
        if (putchars(wDeviceID, nPort, aszQueryFormat, FALSE) != 0)
            return MCIERR_HARDWARE;

        if ((n = getchars(wDeviceID, nPort, buf, 6, 0)) != 6
            || buf[0] == 'E')
            goto step_error;

        buf[n - 1] = '\0';
        dwFrame = vdisc_atodw(buf);

        if (dwFlags & MCI_VD_STEP_REVERSE)
            dwFrame -= lpStep->dwFrames;
        else
            dwFrame += lpStep->dwFrames;

        wsprintfA(buf, aszSeekToFormat, (UINT)dwFrame);

        comport[nPort].bPlayerBusy = TRUE;

        if (putchars(wDeviceID, nPort, buf, FALSE) != 0)
            return MCIERR_HARDWARE;

        process_delay(wDeviceID, nPort, dwFlags, lpStep->dwCallback);
        return 0;
    }
    else {
        if (dwFlags & MCI_VD_STEP_REVERSE)
            dwErr = putchars(wDeviceID, nPort, aszStepReverse, TRUE);
        else
            dwErr = putchars(wDeviceID, nPort, aszStepForward, TRUE);
        if (dwErr == 0)
            return 0;
        else
            goto step_error;
    }
step_error:
    dwErr = get_media_type(wDeviceID, nPort, &dwMediaType);
    if (dwErr)
        return dwErr;
    if (dwMediaType == MCI_VD_MEDIA_CLV)
        return MCIERR_PIONEER_ILLEGAL_FOR_CLV;
    return MCIERR_HARDWARE;
}

/****************************************************************************
 * Process the MCI_GETDEVCAPS message
 ***************************************************************************/
static DWORD PASCAL NEAR getdevcaps(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_GETDEVCAPS_PARMS lpCaps)
{
    BOOL bCLV = FALSE;
    DWORD dwMediaType;

/* Info is for CAV unless CLV specified or current disc is CLV */
    if (dwFlags & MCI_VD_GETDEVCAPS_CLV)
        bCLV = TRUE;
    else if (!(dwFlags & MCI_VD_GETDEVCAPS_CAV) &&
             !get_media_type(wDeviceID, nPort, &dwMediaType) && (dwMediaType == MCI_VD_MEDIA_CLV))
        bCLV = TRUE;

    if (!(MCI_GETDEVCAPS_ITEM))
        return MCIERR_MISSING_PARAMETER;

    switch (lpCaps->dwItem) {

        case MCI_GETDEVCAPS_CAN_RECORD:
        case MCI_GETDEVCAPS_CAN_SAVE:
        case MCI_GETDEVCAPS_USES_FILES:
        case MCI_GETDEVCAPS_COMPOUND_DEVICE:
            lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
            return MCI_RESOURCE_RETURNED;

        case MCI_GETDEVCAPS_HAS_AUDIO:
        case MCI_GETDEVCAPS_HAS_VIDEO:
        case MCI_GETDEVCAPS_CAN_EJECT:
        case MCI_GETDEVCAPS_CAN_PLAY:
            lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            return MCI_RESOURCE_RETURNED;

        case MCI_VD_GETDEVCAPS_CAN_REVERSE:
            if (bCLV)
                lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
            else
                lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            return MCI_RESOURCE_RETURNED;

        case MCI_GETDEVCAPS_DEVICE_TYPE:
            lpCaps->dwReturn = MAKEMCIRESOURCE(MCI_DEVTYPE_VIDEODISC,
                                               MCI_DEVTYPE_VIDEODISC);
            return MCI_RESOURCE_RETURNED;

        case MCI_VD_GETDEVCAPS_NORMAL_RATE:
            lpCaps->dwReturn = CAV_FRAMES_PER_SECOND;
            return 0;

        case MCI_VD_GETDEVCAPS_SLOW_RATE:
        case MCI_VD_GETDEVCAPS_CLV:
            if (bCLV)
                lpCaps->dwReturn = 0;
            else
                lpCaps->dwReturn = CAV_FRAMES_PER_SECOND / 3;
            return 0;

        case MCI_VD_GETDEVCAPS_FAST_RATE:
            if (bCLV)
                lpCaps->dwReturn = 0;
            else
                lpCaps->dwReturn = CAV_FRAMES_PER_SECOND * 3;
            return 0;
    }
    return MCIERR_MISSING_PARAMETER;
}

/****************************************************************************
 * Process the MCI_SET message
 ***************************************************************************/
static DWORD PASCAL NEAR set(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_SET_PARMS lpSet)
{
    CHAR strCommand[4];
    UINT wMask;
    DWORD dwMediaType;

    if (dwFlags & MCI_SET_AUDIO) {
        if (dwFlags & MCI_SET_VIDEO)
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        strCommand[0] = '0';
        strCommand[1] = 'A';
        strCommand[2] = 'D';
        strCommand[3] = '\0';

        if (lpSet->dwAudio == MCI_SET_AUDIO_LEFT)
            wMask = 1;
        else if (lpSet->dwAudio == MCI_SET_AUDIO_RIGHT)
            wMask = 2;
        else if (lpSet->dwAudio == MCI_SET_AUDIO_ALL)
            wMask = 3;
        else
            return MCIERR_OUTOFRANGE;

        if (dwFlags & MCI_SET_ON) {
            if (dwFlags & MCI_SET_OFF)
                return MCIERR_FLAGS_NOT_COMPATIBLE;

            comport[nPort].wAudioChannels |= wMask;
        }
        else if (dwFlags & MCI_SET_OFF)
            comport[nPort].wAudioChannels &= ~wMask;
        else
            return MCIERR_MISSING_PARAMETER;

        strCommand[0] = (CHAR)(comport[nPort].wAudioChannels + '0');
        putchars(wDeviceID, nPort, strCommand, TRUE);
    }
    else if (dwFlags & MCI_SET_TIME_FORMAT) {
        switch (lpSet->dwTimeFormat) {

            case MCI_FORMAT_MILLISECONDS:
                comport[nPort].dwTimeMode = MCI_FORMAT_MILLISECONDS;
                break;

            case MCI_FORMAT_HMS:
                comport[nPort].dwTimeMode = MCI_FORMAT_HMS;
                break;

            case MCI_FORMAT_FRAMES:
                if (!get_media_type(wDeviceID, nPort, &dwMediaType) && (dwMediaType == MCI_VD_MEDIA_CLV))
                    return MCIERR_PIONEER_ILLEGAL_FOR_CLV;
                comport[nPort].dwTimeMode = MCI_FORMAT_FRAMES;
                break;

            case MCI_VD_FORMAT_TRACK:
                if (putchars(wDeviceID, nPort, aszCheck, TRUE) != 0)
                    return MCIERR_HARDWARE;
                comport[nPort].dwTimeMode = MCI_VD_FORMAT_TRACK;
                break;

            default:
                return MCIERR_BAD_TIME_FORMAT;
        }
        if (lpSet->dwTimeFormat != MCI_VD_FORMAT_TRACK) {
            DWORD dwErr;
            if ((dwErr = unset_chapter_mode(wDeviceID, nPort)) != 0)
                return dwErr;
        }
    }
    else if (dwFlags & MCI_SET_VIDEO) {
        strCommand[1] = 'V';
        strCommand[2] = 'D';
        strCommand[3] = '\0';
        if (dwFlags & MCI_SET_ON) {
            if (dwFlags & MCI_SET_OFF)
                return MCIERR_FLAGS_NOT_COMPATIBLE;

            strCommand[0] = '1';
        } else if (dwFlags & MCI_SET_OFF)
            strCommand[0] = '0';
        else
            return MCIERR_MISSING_PARAMETER;
        if (putchars(wDeviceID, nPort, strCommand, TRUE) != 0)
            return MCIERR_HARDWARE;
    }
    else if (dwFlags & MCI_SET_DOOR_OPEN) {
        if (putchars(wDeviceID, nPort, aszOpenDoor, FALSE) != 0)
            return MCIERR_HARDWARE;
        comport[nPort].bPlayerBusy = TRUE;
        comport[nPort].bDoorAction = TRUE;
        comport[nPort].dwTimeMode = NO_TIME_MODE;
        process_delay(wDeviceID, nPort, dwFlags, lpSet->dwCallback);
        return 0;
    }
    else if (dwFlags & MCI_SET_DOOR_CLOSED) {
/* Don't use spinupdown() because it won't work right for notification */
        if (IsDiscSpinning(wDeviceID, nPort) != 0) {
            comport[nPort].bPlayerBusy = TRUE;
            comport[nPort].bDoorAction = TRUE;
            if (putchars(wDeviceID, nPort, aszSpinUp, FALSE) != 0)
                return MCIERR_HARDWARE;
            process_delay(wDeviceID, nPort, dwFlags, lpSet->dwCallback);
            return 0;
        }

    } else
        return MCIERR_MISSING_PARAMETER;

    notify(0, dwFlags, wDeviceID, (LPMCI_GENERIC_PARMS)lpSet, nPort);
    return 0;
}

/****************************************************************************
 * Process the MCI_ESCAPE message
 ***************************************************************************/
static DWORD PASCAL NEAR command(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_VD_ESCAPE_PARMS lpCommand)
{
    DWORD dwErr, dwReturn = 0;

    if (!(dwFlags & MCI_VD_ESCAPE_STRING) || lpCommand->lpstrCommand == NULL)
        return MCIERR_MISSING_PARAMETER;

/* Turn off return codes -- this command has no return code */
    if ((dwErr = putchars(wDeviceID, nPort, aszCommandOff, FALSE)) != 0)
        return dwErr;

/* Send application's string */
    if ((dwErr = putchars(wDeviceID, nPort, (LPSTR)lpCommand->lpstrCommand, FALSE))
        != 0)
        dwReturn = dwErr;

/* Turn on return codes -- this command has a return code */
    if ((dwErr = putchars(wDeviceID, nPort, aszCommandOn, TRUE)) != 0 &&
        dwReturn == 0)

        dwReturn = dwErr;

    return dwReturn;
}

/****************************************************************************
 * Process the MCI_VDISC_INDEX message
 ***************************************************************************/
static DWORD PASCAL NEAR index(UINT wDeviceID, int nPort, DWORD dwFlags)
{
    return putchars(wDeviceID, nPort,
                      dwFlags & VDISC_FLAG_ON ? aszIndexOn : aszIndexOff, TRUE);
}

/****************************************************************************
 * Process the MCI_VDISC_KEYLOCK message
 ***************************************************************************/
static DWORD PASCAL NEAR keylock(UINT wDeviceID, int nPort, DWORD dwFlags)
{
/* Ensure that one and only flag is set */
    if (dwFlags & VDISC_FLAG_ON && dwFlags & VDISC_FLAG_OFF)
        return MCIERR_FLAGS_NOT_COMPATIBLE;

    if (!(dwFlags & (VDISC_FLAG_ON | VDISC_FLAG_OFF)))
        return MCIERR_MISSING_PARAMETER;

    return putchars(wDeviceID, nPort,
                      dwFlags & VDISC_FLAG_ON ? aszKeyLockOn : aszKeyLockOff,
                      TRUE);
}

/****************************************************************************
 * Process the MCI_INFO message
 ***************************************************************************/
static DWORD PASCAL NEAR info(UINT wDeviceID, int nPort, DWORD dwFlags, LPMCI_INFO_PARMS lpInfo)
{
    DWORD dwErr;

    if (dwFlags & MCI_INFO_PRODUCT) {
        if (lpInfo->lpstrReturn == NULL ||
            !LOWORD(lpInfo->dwRetSize))
            dwErr = MCIERR_PARAM_OVERFLOW;
        else {
            UINT        wReturnBufferLength;

            wReturnBufferLength = LOWORD(lpInfo->dwRetSize);
            *(lpInfo->lpstrReturn + wReturnBufferLength - 1) = '\0';
            lpInfo->dwRetSize = LoadString(hInstance, IDS_PRODUCTNAME, lpInfo->lpstrReturn, wReturnBufferLength);
            if (*(lpInfo->lpstrReturn + wReturnBufferLength - 1) != '\0')
                dwErr = MCIERR_PARAM_OVERFLOW;
            else
                dwErr = 0;
        }
    } else
        dwErr = MCIERR_MISSING_PARAMETER;

    return dwErr;
}

/****************************************************************************
 * Process the MCI_CLOSE message
 ***************************************************************************/
static void PASCAL NEAR close(UINT wDeviceID, int nPort)
{
    DOUT("Closing...");
    if (--comport[nPort].nUseCount == 0) {
        DOUT("comport...");
        vdisc_close(wDeviceID, nPort);
        comport[nPort].nCommID = NO_COMPORT;
        if (comport[nPort].bTimerSet) {
            if (--nWaitingChannels == 0) {
                KillTimer(NULL, wTimerID);
                mciDriverNotify(comport[nPort].hCallback,
                                comport[nPort].wDeviceID,
                                MCI_NOTIFY_ABORTED);
            }

        }
    }
}

/****************************************************************************
 * Process all MCI specific message
 ***************************************************************************/
DWORD FAR PASCAL mciDriverEntry(UINT wDeviceID, UINT message, LPARAM lParam1, LPARAM lParam2)
{
    int nCommID, nPort;
    DWORD dwErr = 0;
    LPMCI_GENERIC_PARMS lpGeneric = (LPMCI_GENERIC_PARMS)lParam2;
#if DBG
    CHAR buf[100];
#endif

/* Catch these here to avoid a mandatory wait */
    switch (message) {
        case MCI_RECORD:
        case MCI_LOAD:
        case MCI_SAVE:
        case MCI_RESUME:
            return MCIERR_UNSUPPORTED_FUNCTION;
    }

    if (lpGeneric == NULL)
        return MCIERR_NULL_PARAMETER_BLOCK;

/* Find the channel number given the device ID */
    nPort = (UINT)mciGetDriverData(wDeviceID);

/* Serialize all access to this com port.  When we yield we release this
   cricical section */

    EnterCrit(nPort);

/* Find the actual comm port handle */

    nCommID = comport[nPort].nCommID;

#if DBG
    wsprintfA(buf, "port=%d commid=%d", nPort, nCommID);
    DOUT(buf);
#endif



/* If the device is busy then wait for completion before sending any commands */
    if (message != MCI_OPEN_DRIVER) {
        if (comport[nPort].bPlayerBusy) {
/* If the command is 'status mode' */
            if (message == MCI_STATUS && (DWORD)lParam1 & MCI_STATUS_ITEM &&
                ((LPMCI_STATUS_PARMS)lParam2)->dwItem == MCI_STATUS_MODE) {
/* Seek if the device is done seeking */
                if (GetCompletionCode(wDeviceID, nPort, 200) == 0) {
                    comport[nPort].bPlayerBusy = FALSE;
                    comport[nPort].bDoorAction = FALSE;
                }
                else {
/* If not then return MCI_MODE_SEEK */
                    UINT wMode;

                    wMode = (comport[nPort].bDoorAction? MCI_MODE_NOT_READY :
                        MCI_MODE_SEEK);
                    ((LPMCI_STATUS_PARMS)lParam2)->dwReturn =
                        MAKEMCIRESOURCE(wMode, wMode);
                    notify(LOWORD(dwErr), (DWORD)lParam1, wDeviceID,
                            (LPMCI_GENERIC_PARMS)lParam2, nPort);
                    LeaveCrit(nPort);
                    return MCI_RESOURCE_RETURNED;
                }
            }
            else {
/* Wait up to 25 seconds for the ongoing command to complete */
                GetCompletionCode(wDeviceID, nPort, 25000);
                comport[nPort].bPlayerBusy = FALSE;
            }
        }
/* If the device has not yet responded try to see if it's alive */
        if (!comport[nPort].bResponding && message != MCI_CLOSE_DRIVER &&
            message != MCI_GETDEVCAPS)
            if (putchars(wDeviceID, nPort, aszKeyLockOn, TRUE) != 0) {
                LeaveCrit(nPort);
                return MCIERR_HARDWARE;
            }
            else {
                comport[nPort].bResponding = TRUE;
                init_player(wDeviceID, nPort);
            }
   }

/* These commands will abort notification or are otherwise strange */
    switch (message) {

        case MCI_PLAY:
            dwErr = play(wDeviceID, nPort, (DWORD)lParam1, (MCI_VD_PLAY_PARMS FAR *)lParam2);
            LeaveCrit(nPort);
            return dwErr;

        case MCI_SEEK:
            dwErr =  seek(wDeviceID, nPort, (DWORD)lParam1, (LPMCI_SEEK_PARMS)lParam2);
            LeaveCrit(nPort);
            return dwErr;

        case MCI_SET:
            dwErr = set(wDeviceID, nPort, (DWORD)lParam1, (LPMCI_SET_PARMS)lParam2);
            LeaveCrit(nPort);
            return dwErr;

        case MCI_SPIN:
            dwErr = spin(wDeviceID, nPort, (DWORD)lParam1, (LPMCI_GENERIC_PARMS)lParam2);
            LeaveCrit(nPort);
            return dwErr;

        case MCI_CLOSE_DRIVER:
            close(wDeviceID, nPort);
            notify(0, (DWORD)lParam1, wDeviceID, (LPMCI_GENERIC_PARMS)lParam2,
                    nPort);
            LeaveCrit(nPort);
            return 0;

        case MCI_STOP:
/* Fall through */

        case MCI_PAUSE:
            dwErr = stop_pause(wDeviceID, nPort,
                                (DWORD)lParam1, lpGeneric, message);
            LeaveCrit(nPort);
            return dwErr;
    }



/* These commands will NOT abort notification */
    switch (message) {
         case MCI_OPEN_DRIVER:
/* If the port is in use then shareable must be specified now and with */
/* the previous open */
            if (comport[nPort].nUseCount != 0)
                if (!((DWORD)lParam1 & MCI_OPEN_SHAREABLE) ||
                    !comport[nPort].bShareable) {
                    LeaveCrit(nPort);
                    return MCIERR_MUST_USE_SHAREABLE;
                }

            ++comport[nPort].nUseCount;

            if (comport[nPort].nCommID == NO_COMPORT)
                dwErr = open(wDeviceID, nPort, (DWORD)lParam1);
            break;

        case VDISC_INDEX:
            dwErr = index(wDeviceID, nPort, (DWORD)lParam1);
            break;

        case VDISC_KEYLOCK:
            dwErr = keylock(wDeviceID, nPort, (DWORD)lParam1);
            break;

        case MCI_ESCAPE:
            dwErr = command(wDeviceID, nPort, (DWORD)lParam1,
                             (LPMCI_VD_ESCAPE_PARMS)lParam2);
            break;

/* The MCI_STEP message should really be in the above list of message */
/* which can abort notification.  In this driver, MCI_STEP never */
/* aborts notification which is an error */
        case MCI_STEP:
            dwErr = step(wDeviceID, nPort, (DWORD)lParam1, (LPMCI_VD_STEP_PARMS)lParam2);
            break;

        case MCI_GETDEVCAPS:
            dwErr = getdevcaps(wDeviceID, nPort, (DWORD)lParam1, (LPMCI_GETDEVCAPS_PARMS)lParam2);
            break;

        case MCI_STATUS:
            dwErr = status(wDeviceID, nPort, (DWORD)lParam1, (LPMCI_STATUS_PARMS)lParam2);
            break;

        case MCI_INFO:
            dwErr = info(wDeviceID, nPort,  (DWORD)lParam1,
                          (LPMCI_INFO_PARMS)lParam2);
            break;

        default:
            dwErr = MCIERR_UNRECOGNIZED_COMMAND;
            break;

    } /* switch */

    notify(LOWORD(dwErr), (DWORD)lParam1, wDeviceID, (LPMCI_GENERIC_PARMS)lParam2,
            nPort);

    LeaveCrit(nPort);
    return dwErr;
}

/****************************************************************************
 * Library exit function
 ***************************************************************************/
BOOL PASCAL FAR _LOADDS WEP(BOOL fSystemExit)
{
    int n;

    for (n = 0; n < PIONEER_MAX_COMPORTS; n++)
        if (comport[n].nCommID != NO_COMPORT)

            /* We use device id 0 which is OK because it's not used anyway
               since the device id is only used for Yielding and we don't
               yield during close */

            vdisc_close(0, n);
    return TRUE;
}


#ifdef WIN32
/****************************************************************************
 * @doc EXTERNAL
 *
 * @api int | DllInstanceInit | Library initialization code.
 *
 * @parm HINSTANCE | hModule | Our instance handle.
 *
 * @parm ULONG | Reason | Reason for being called.
 *
 * @parm PCONTEXT | pContext | Context
 *
 * @rdesc Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/

BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {

        int i;

        for (i = 0; i < PIONEER_MAX_COMPORTS; i++) {
            InitializeCriticalSection(&comport[i].DeviceCritSec);
        }

        return LibMain(hModule, 0, NULL);
    } else {
        if (Reason == DLL_PROCESS_DETACH) {
            return WEP(FALSE);
        } else {
            return TRUE;
        }
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api UINT | pionDriverYield | Yield or yield simulation.
 *
 * @parm UINT | wDeviceId | Device id yielding.
 *
 * @parm UINT | nPort | logical device yielding.
 *
 * @rdesc Returns code returned by mciDriverYield.
 *
 ***************************************************************************/

 UINT pionDriverYield(UINT wDeviceId, UINT nPort)
 {
     UINT rc;

     LeaveCrit(nPort);
     rc = mciDriverYield(wDeviceId);

     /* Let someone else have a go */

     Sleep(10);
     EnterCrit(nPort);

     return rc;
 }
#endif /* WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\lowpass\lowpass.h ===
/* lowpass.h - Header file for LOWPASS sample application.
 */


/* Constants for dialogs.
 */
#define IDM_ABOUT       11          // menu items

#define ID_INPUTFILEEDIT    101     // input file name edit box
#define ID_OUTPUTFILEEDIT   102     // output file name edit box


/* Function Prototypes
 */
void DoLowPass(HWND hwnd);
int PASCAL
    WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpszCmdLine, int iCmdShow);
BOOL FAR PASCAL
     AboutDlgProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
BOOL FAR PASCAL
     LowPassDlgProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\acmapp\waveio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  waveio.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_WAVEIO
#define _INC_WAVEIO                 // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifdef WIN32
    //
    //  for compiling Unicode
    //
    #ifndef SIZEOF
    #ifdef UNICODE
        #define SIZEOF(x)       (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)       sizeof(x)
    #endif
    #endif
#else
    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef TEXT
    #define TEXT(a)             a
    #endif

    #ifndef SIZEOF
    #define SIZEOF(x)           sizeof(x)
    #endif

    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif
#endif


//
//
//
//
//
#ifdef WIN32
    #define WIOAPI      _stdcall
#else
#ifdef _WINDLL
    #define WIOAPI      FAR PASCAL _loadds
#else
    #define WIOAPI      FAR PASCAL
#endif
#endif


//
//
//
typedef UINT        WIOERR;


//
//
//
//
typedef struct tWAVEIOCB
{
    DWORD           dwFlags;
    HMMIO           hmmio;

    DWORD           dwDataOffset;
    DWORD           dwDataBytes;
    DWORD           dwDataSamples;

    LPWAVEFORMATEX  pwfx;

#if 0
    HWAVEOUT        hwo;
    DWORD           dwBytesLeft;
    DWORD           dwBytesPerBuffer;
    
    DISP FAR *      pDisp;
    INFOCHUNK FAR * pInfo;
#endif

} WAVEIOCB, *PWAVEIOCB, FAR *LPWAVEIOCB;



//
//  error returns from waveio functions
//
#define WIOERR_BASE             (0)
#define WIOERR_NOERROR          (0)
#define WIOERR_ERROR            (WIOERR_BASE+1)
#define WIOERR_BADHANDLE        (WIOERR_BASE+2)
#define WIOERR_BADFLAGS         (WIOERR_BASE+3)
#define WIOERR_BADPARAM         (WIOERR_BASE+4)
#define WIOERR_BADSIZE          (WIOERR_BASE+5)
#define WIOERR_FILEERROR        (WIOERR_BASE+6)
#define WIOERR_NOMEM            (WIOERR_BASE+7)
#define WIOERR_BADFILE          (WIOERR_BASE+8)
#define WIOERR_NODEVICE         (WIOERR_BASE+9)
#define WIOERR_BADFORMAT        (WIOERR_BASE+10)
#define WIOERR_ALLOCATED        (WIOERR_BASE+11)
#define WIOERR_NOTSUPPORTED     (WIOERR_BASE+12)



//
//  function prototypes and flag definitions
//
WIOERR WIOAPI wioFileClose
(
    LPWAVEIOCB              pwio,
    DWORD                   fdwClose
);

WIOERR WIOAPI wioFileOpen
(
    LPWAVEIOCB              pwio,
    LPCTSTR                 pszFilePath,
    DWORD                   fdwOpen
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _INC_WAVEIO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mcipionr\mcipionr.h ===
/****************************************************************************
 *
 *   mcipionr.h
 *
 *   Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#define IDS_PRODUCTNAME                 1
#define IDS_COMMANDS                    2
#define MCIERR_PIONEER_ILLEGAL_FOR_CLV  (MCIERR_CUSTOM_DRIVER_BASE)
#define MCIERR_PIONEER_NOT_SPINNING     (MCIERR_CUSTOM_DRIVER_BASE + 1)
#define MCIERR_PIONEER_NO_CHAPTERS      (MCIERR_CUSTOM_DRIVER_BASE + 2)
#define MCIERR_PIONEER_NO_TIMERS        (MCIERR_CUSTOM_DRIVER_BASE + 3)

/* custom command support */
#define VDISC_FLAG_ON       0x00000100L
#define VDISC_FLAG_OFF      0x00000200L

/* must use literals to satisfy the RC compiler  */
#define VDISC_INDEX         1000
#define VDISC_KEYLOCK       1002

#define VDISC_FIRST         VDISC_INDEX
#define VDISC_LAST          VDISC_KEYLOCK

/* Default baud rate */
#define DEFAULT_BAUD_RATE 4800

extern HINSTANCE hInstance;

extern void FAR PASCAL pionGetComportAndRate(LPTSTR lpstrBuf, PUINT pPort,
                                       PUINT pRate);
extern DWORD FAR PASCAL mciDriverEntry(UINT wDeviceID, UINT message,
                                        LPARAM lParam1, LPARAM lParam2);

extern void pionSetBaudRate(UINT nPort, UINT nRate);

#ifdef WIN32

    #define _LOADDS

#else

    #define _LOADDS _loadds

#endif /* WIN32 */

/****************************************************************************

 Tasking

 ****************************************************************************/

#ifdef WIN32

#define EnterCrit(nPort) EnterCriticalSection(&comport[nPort].DeviceCritSec)
#define LeaveCrit(nPort) LeaveCriticalSection(&comport[nPort].DeviceCritSec)

UINT pionDriverYield(UINT wDeviceId, UINT nPort);

#else

#define EnterCrit(nPort) (TRUE)
#define LeaveCrit(nPort) (TRUE)

#define pionDriverYield(wDeviceId, nPort)  mciDriverYield(wDeviceId)

#endif /* WIN32 */

/****************************************************************************

    Debug support

 ***************************************************************************/

#ifndef WIN32
   #define OutputDebugStringA OutputDebugString
#endif /* WIN32 */


#if DBG
   #define DOUT(sz)  (wDebugLevel != 0 ? OutputDebugStringA("\r\n"), OutputDebugStringA(sz), 0 : 0 )
   #define DOUTX(sz) (wDebugLevel != 0 ? OutputDebugStringA(sz), 0 : 0 )
#else
   #define DOUT(sz)  0
   #define DOUTX(sz) 0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mcipionr\pioncnfg.h ===
/****************************************************************************
 *
 *   pioncnfg.h
 *
 *   Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#define IDD_PIONCNFG   1

#define R_4800                      4
#define R_9600                      5

#define BAUD_RATE_SELECT            6

#define P_COM1       100
#define P_COM2       101
#define P_COM3       102
#define P_COM4       103
#define P_SELECT     104

int PASCAL FAR pionConfig(HWND hwndParent, LPDRVCONFIGINFO lpInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mcipionr\ntcomm.c ===
/****************************************************************************
 *
 *   ntcomm.c
 *
 *   Copyright (c) 1993 Microsoft Corporation.  All Rights Reserved
 *
 *   MCI Device Driver for the Pioneer 4200 Videodisc Player
 *
 *      Comms compatibility routines for Windows NT
 *
 ***************************************************************************/

#include <windows.h>

INT OpenComm(LPCTSTR lpstr, UINT wqin, UINT wqout)
 {
     HANDLE hFile;
     COMMTIMEOUTS Timeouts;

     hFile = CreateFile(lpstr,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_WRITE_THROUGH,
                        0);

     if (hFile == INVALID_HANDLE_VALUE) {
         return 0;
     }

    /*
     *  Set the timeouts to be like win3.1 (as defined in the SDK)
     */

     Timeouts.ReadIntervalTimeout = INFINITE;
     Timeouts.ReadTotalTimeoutMultiplier = 0;
     Timeouts.ReadTotalTimeoutConstant = 0;
     Timeouts.WriteTotalTimeoutMultiplier = INFINITE;
     Timeouts.WriteTotalTimeoutConstant = INFINITE;

     if (!SetCommTimeouts(hFile, &Timeouts)) {
         CloseHandle(hFile);
         return 0;
     } else {
         return (INT)hFile;
     }

 }

INT GetCommError(int hDevice, LPCOMSTAT lpComStat)
 {
     DWORD dwErrors;

     if (ClearCommError((HANDLE)hDevice, &dwErrors, lpComStat)) {
         return dwErrors;
     } else {
        /*
         *  Concoct something nasty
         */

         return CE_IOE;
     }
 }

INT ReadComm(HFILE nCid, LPSTR lpBuf, INT nSize)
 {
     DWORD cbRead;

     if (!ReadFile((HANDLE)nCid, lpBuf, nSize, &cbRead, 0))
         return(-(INT)cbRead);
     return((INT)cbRead);
 }


INT WriteComm(HFILE nCid, LPSTR lpBuf, INT nSize)
 {
     DWORD cbWritten;

     if (!WriteFile((HANDLE)nCid, lpBuf, nSize, &cbWritten, 0))
         return(-(INT)cbWritten);
     return((INT)cbWritten);
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\callback.h ===
/*
 *  callback.h
 */


/* Function prototypes
 */
void FAR PASCAL midiInputHandler(HMIDIIN, WORD, DWORD, DWORD, DWORD);
void FAR PASCAL PutEvent(LPCIRCULARBUFFER lpBuf, LPEVENT lpEvent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\circbuf.h ===
/*
 *  circbuf.h
 */


/* Structure to manage the circular input buffer.
 */
typedef struct circularBuffer_tag
{
    HANDLE  hSelf;          /* handle to this structure */
    HANDLE  hBuffer;        /* buffer handle */
    WORD    wError;         /* error flags */
    DWORD   dwSize;         /* buffer size (in EVENTS) */
    DWORD   dwCount;        /* byte count (in EVENTS) */
    LPEVENT lpStart;        /* ptr to start of buffer */
    LPEVENT lpEnd;          /* ptr to end of buffer (last byte + 1) */
    LPEVENT lpHead;         /* ptr to head (next location to fill) */
    LPEVENT lpTail;         /* ptr to tail (next location to empty) */
} CIRCULARBUFFER;
typedef CIRCULARBUFFER FAR *LPCIRCULARBUFFER;


/* Function prototypes
 */
LPCIRCULARBUFFER AllocCircularBuffer(DWORD dwSize);
void FreeCircularBuffer(LPCIRCULARBUFFER lpBuf);
WORD FAR PASCAL GetEvent(LPCIRCULARBUFFER lpBuf, LPEVENT lpEvent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mcipionr\pioncnfg.c ===
/****************************************************************************
 *
 *   pioncnfg.c
 *
 *   Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mcipionr.h"
#include "pioncnfg.h"

#define MAX_INI_LENGTH   128               /* maximum .ini file line length */

#ifdef WIN32
#define SZCODE TCHAR
#else
#define SZCODE char _based(_segname("_CODE"))
#endif /* WIN32 */

static UINT nPort;                         /* which com port we're using */
static UINT nRate;                         /* which baud rate we're using */
static SZCODE szIniFile[] = TEXT("system.ini");  /* configuration information file */
static SZCODE szNull[] = TEXT("");
static SZCODE szCommIniFormat[] = TEXT("com%1d,%d");

/****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | GetDriverName | Returns the file name of the driver
 *       This is the name of the ini section where the driver stores
 *       its parameters
 *
 * @parm LPDRVCONFIGINFO | lpdci | Config information from the DRV_CONFIGURE
 *     message.
 *
 * @parm LPTSTR | lpstrDriver | Where to put the driver file name - must
 *       have room for at least MAX_INI_LENGTH characters
 *
 * @rdesc TRUE if we found some name
 ***************************************************************************/
static BOOL PASCAL NEAR GetDriverName(LPDRVCONFIGINFO lpdci, LPTSTR lpstrDriver)
{
    if (GetPrivateProfileString( lpdci->lpszDCISectionName,
                                 lpdci->lpszDCIAliasName,
                                 TEXT(""),
                                 lpstrDriver,
                                 MAX_INI_LENGTH,
                                 szIniFile))
    {
       /* We have got the name of the driver
        * Just in case the user has added the command parameter to the
        * end of the name we had better make sure there is only one token
        * on the line.
        */

        int i;

        for ( i = 0; i < MAX_PATH && lpstrDriver[i] != TEXT('\0'); i++) {
            if (lpstrDriver[i] == TEXT(' ')) {
                lpstrDriver[i] = TEXT('\0');
                break;
            }
        }

        return TRUE;
    }

    return FALSE;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api UINT | GetCmdParam | Returns the currently selected comport and
 *     baud rate from the user profile
 *
 * @parm LPDRVCONFIGINFO | lpdci | Config information from the DRV_CONFIGURE
 *     message.
 *
 * @rdesc Returns comport number.
 ***************************************************************************/
static void PASCAL NEAR GetCmdParam(LPDRVCONFIGINFO lpdci, PUINT pPort,
                                    PUINT pRate)
{
TCHAR aszDriver[MAX_INI_LENGTH];
TCHAR sz[MAX_INI_LENGTH];

    *pPort = 0;                   /* Default is com1 */
    *pRate = DEFAULT_BAUD_RATE;

    if (!GetDriverName(lpdci, aszDriver)) {
        return;
    }

    if (GetProfileString(
         aszDriver, lpdci->lpszDCIAliasName, szNull, sz,
         MAX_INI_LENGTH)) {
        pionGetComportAndRate(sz, pPort, pRate);
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | PutCmdParam | Sets the current comport in system.ini.
 *
 * @parm LPDRVCONFIGINFO | lpdci | Config information from the DRV_CONFIGURE
 *     message.
 *
 * @parm UINT | nPort | Comport to set.
 *
 * @rdesc Returns comport number.
 ***************************************************************************/
static void PASCAL NEAR PutCmdParam(LPDRVCONFIGINFO lpdci, UINT nPort, UINT nRate)
{
TCHAR aszDriver[MAX_INI_LENGTH];
TCHAR  sz[MAX_INI_LENGTH];

    if (!GetDriverName(lpdci, aszDriver)) {
        return;
    }

    wsprintf(sz, szCommIniFormat, nPort + 1, nRate);

    WriteProfileString(
        aszDriver,
        lpdci->lpszDCIAliasName,
        sz);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ConfigDlgProc | Dialog proc for the configuration dialog box.
 *
 * @parm HWND | hDlg | Handle to the configuration dialog box.
 *
 * @parm UINT | msg | Message sent to the dialog box.
 *
 * @parm WPARAM | wParam | Message dependent parameter.
 *
 * @parm LPARAM | lParam | Message dependent parameter.
 *
 * @rdesc Returns DRV_OK if the user clicks on "OK" and DRV_CANCEL if the
 *     user clicks on "Cancel".
 ***************************************************************************/
BOOL FAR PASCAL _LOADDS ConfigDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
static LPDRVCONFIGINFO lpdci;

    switch (msg) {

    case WM_INITDIALOG:
        lpdci = (LPDRVCONFIGINFO)lParam;
        GetCmdParam(lpdci, &nPort, &nRate);
        CheckRadioButton(hDlg, P_COM1, P_COM4, P_COM1 + nPort);
        CheckRadioButton(hDlg, R_4800, R_9600,
                         nRate == 4800 ? R_4800 : R_9600);
        break;

    case WM_COMMAND:
        switch ((WORD)wParam) {

            case IDOK:
                PutCmdParam(lpdci, nPort, nRate);
                EndDialog(hDlg, DRVCNF_OK);
                break;

            case IDCANCEL:
                EndDialog(hDlg, DRVCNF_CANCEL);
                break;

            case P_COM1:
            case P_COM2:
            case P_COM3:
            case P_COM4:
                nPort = wParam - P_COM1;
                break;

            case R_4800:
                nRate = 4800;
                break;

            case R_9600:
                nRate = 9600;
                break;

            default:
                break;
            }
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @func int | pionConfig | This puts up the configuration dialog box.
 *
 * @parm HWND | hwndParent | Parent window.
 *
 * @parm LPDRVCONFIGINFO | lpInfo | Config information from the DRV_CONFIGURE
 *     message.
 *
 * @rdesc Returns whatever was returned from the dialog box procedure.
 ***************************************************************************/
int PASCAL FAR pionConfig(HWND hwndParent, LPDRVCONFIGINFO lpInfo)
{
    return DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PIONCNFG), hwndParent, ConfigDlgProc,
                             (DWORD)lpInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mcipionr\piondrvr.c ===
/****************************************************************************
 *
 *   piondrvr.c
 *
 *   Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved.
 *
 *   MCI Device Driver for the Pioneer 4200 Videodisc Player
 *
 *      Main Module - Standard Driver Interface and Message Procedures
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mcipionr.h"
#include "pioncnfg.h"

#define CONFIG_ID        10000L         /* use hiword of dwDriverID to */
                                        /* identify config. opens */

static WORD wTableEntry;                /* custom table ID returned */
                                        /* from mciLoadCommandResource() */

/***************************************************************************
 * @doc INTERNAL
 *
 * @api LRESULT | DriverProc | Windows driver entry point.  All Windows driver
 *     control messages and all MCI messages pass through this entry point.
 *
 * @parm DWORD | dwDriverId | For most messages, <p dwDriverId> is the DWORD
 *     value that the driver returns in response to a <m DRV_OPEN> message.
 *     Each time that the driver is opened, through the <f DrvOpen> API,
 *     the driver receives a <m DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <p dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * @parm HDRVR  | hDriver | This is the handle returned to the
 *     application by the driver interface.
 *
 * @parm UINT | message | The requested action to be performed. Message
 *     values below <m DRV_RESERVED> are used for globally defined messages.
 *     Message values from <m DRV_RESERVED> to <m DRV_USER> are used for
 *     defined driver protocols. Messages above <m DRV_USER> are used
 *     for driver specific messages.
 *
 * @parm LPARAM | lParam1 | Data for this message.  Defined separately for
 *     each message
 *
 * @parm LPARAM | lParam2 | Data for this message.  Defined separately for
 *     each message
 *
 * @rdesc Defined separately for each message.
 ***************************************************************************/
LRESULT FAR PASCAL _LOADDS DriverProc(DWORD dwDriverID, HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2)
{
DWORD dwRes = 0L;
TCHAR aszResource[32];

    switch (message) {

        case DRV_LOAD:
            /* the DRV_LOAD message is received once, when the driver is */
            /* first loaded - any one-time initialization code goes here */

            /* load the custom command table */
            LoadString(hInstance,IDS_COMMANDS,aszResource,sizeof(aszResource));
            wTableEntry = mciLoadCommandResource(hInstance, aszResource, 0);

            /* return 0L to FAIL the load. */
            dwRes = wTableEntry != MCI_NO_COMMAND_TABLE;
            break;

        case DRV_FREE:
            /* the DRV_FREE message is received once when the driver is */
            /* unloaded - any final shut down code goes here */

            /* free the custom command table */
            mciFreeCommandResource(wTableEntry);

            dwRes = 1L;
            break;

        case DRV_OPEN:
            /* the DRV_OPEN message is received once for each MCI device open */

            /* configuration open case  */
            if (!lParam2)
                dwRes = CONFIG_ID;
            /* normal case */
            else {
                LPMCI_OPEN_DRIVER_PARMS lpOpen =
                    (LPMCI_OPEN_DRIVER_PARMS)lParam2;
                UINT Port;
                UINT Rate;

                /* associate the channel number with the driver ID */

                pionGetComportAndRate((LPTSTR)lpOpen->lpstrParams, &Port, &Rate);

                pionSetBaudRate(Port, Rate);

                mciSetDriverData(lpOpen->wDeviceID, (DWORD)Port);

                /* specify the custom command table and the device type */
                lpOpen->wCustomCommandTable = wTableEntry;
                lpOpen->wType = MCI_DEVTYPE_VIDEODISC;

                /* return the device ID to be used in subsequent */
                /* messages or 0 to fail the open */
                dwRes = lpOpen->wDeviceID;
                break;

            }

        case DRV_CLOSE:
            /* this message is received once for each MCI device close */

            dwRes = 1L;
            break;

        case DRV_ENABLE:
            /* the DRV_ENABLE message is received when the driver is loaded */
            /* or reloaded and whenever windows is enabled */

            dwRes = 1L;
            break;

        case DRV_DISABLE:
            /* the DRV_DISABLE message is received before the driver is */
            /* freed and whenever windows is disabled */

            dwRes = 1L;
            break;

       case DRV_QUERYCONFIGURE:
            /* the DRV_QUERYCONFIGURE message is used to determine if the */
            /* DRV_CONCIGURE message is supported - return 1 to indicate */
            /* configuration IS supported. */

            dwRes = 1L;
            break;

       case DRV_CONFIGURE:
            /* the DRV_CONFIGURE message instructs the device to perform */
            /* device configuration. */

            if (lParam2 && lParam1 && (((LPDRVCONFIGINFO)lParam2)->dwDCISize == sizeof(DRVCONFIGINFO)))
                dwRes = pionConfig((HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            else
                dwRes = DRVCNF_CANCEL;
            break;

       default:
            /* all other messages are processed here */

            /* select messages in the MCI range */
            if (!HIWORD(dwDriverID) &&
                message >= DRV_MCI_FIRST && message <= DRV_MCI_LAST ||
                message >= VDISC_FIRST && message <= VDISC_LAST)
                dwRes = mciDriverEntry((WORD)dwDriverID, message,
                                        lParam1, lParam2);

            /* other messages get default processing */
            else
                dwRes = DefDriverProc(dwDriverID, hDriver, message,
                                      lParam1, lParam2);
            break;
       }

    return (LRESULT)dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\instdata.h ===
/*
 * instdata.h
 */

/* Structure to pass instance data from the application
   to the low-level callback function.
 */
typedef struct callbackInstance_tag
{
    HWND                hWnd;
    HANDLE              hSelf;  
    DWORD               dwDevice;
    LPCIRCULARBUFFER    lpBuf;
    HMIDIOUT            hMapper;
} CALLBACKINSTANCEDATA;
typedef CALLBACKINSTANCEDATA FAR *LPCALLBACKINSTANCEDATA;

/* Function prototypes
 */
LPCALLBACKINSTANCEDATA FAR PASCAL AllocCallbackInstanceData(void);
void FAR PASCAL FreeCallbackInstanceData(LPCALLBACKINSTANCEDATA lpBuf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\midimon.h ===
/*
 *    midimon.h
 */


/* Compile-time application metrics
 */
#define MAX_NUM_DEVICES         8       // max # of MIDI input devices
#define INPUT_BUFFER_SIZE       200     // size of input buffer in events
#define DISPLAY_BUFFER_SIZE     1000    // size of display buffer in events

/* Menu IDs 
 */
#define IDM_SAVE                101
#define IDM_EXIT                102
#define IDM_SETBUFSIZE          201
#define IDM_SETDISPLAY          202
#define IDM_SAVESETUP           203
#define IDM_SENDTOMAPPER        204
#define IDM_FILTCHAN0           300
#define IDM_FILTCHAN1           301
#define IDM_FILTCHAN2           302
#define IDM_FILTCHAN3           303
#define IDM_FILTCHAN4           304
#define IDM_FILTCHAN5           305
#define IDM_FILTCHAN6           306
#define IDM_FILTCHAN7           307
#define IDM_FILTCHAN8           308
#define IDM_FILTCHAN9           309
#define IDM_FILTCHAN10          310
#define IDM_FILTCHAN11          311
#define IDM_FILTCHAN12          312
#define IDM_FILTCHAN13          313
#define IDM_FILTCHAN14          314
#define IDM_FILTCHAN15          315
#define IDM_NOTEOFF             316
#define IDM_NOTEON              317
#define IDM_POLYAFTERTOUCH      318
#define IDM_CONTROLCHANGE       319
#define IDM_PROGRAMCHANGE       320
#define IDM_CHANNELAFTERTOUCH   321
#define IDM_PITCHBEND           322
#define IDM_CHANNELMODE         323
#define IDM_SYSTEMEXCLUSIVE     324
#define IDM_SYSTEMCOMMON        325
#define IDM_SYSTEMREALTIME      326
#define IDM_ACTIVESENSE         327
#define IDM_STARTSTOP           400
#define IDM_CLEAR               500
#define IDM_ABOUT               600

/* String resource IDs 
 */
#define IDS_APPNAME             1


/* Custom messages sent by low-level callback to application 
 */
#define MM_MIDIINPUT    WM_USER + 0


/* The label for the display window.
 */
#define LABEL " TIMESTAMP STATUS DATA1 DATA2 CHAN EVENT                 "

/* Structure for translating virtual key messages to scroll messages.
 */
typedef struct keyToScroll_tag
{
     WORD wVirtKey;
     int  iMessage;
     WORD wRequest;
} KEYTOSCROLL;

/* Structure to represent a single MIDI event.
 */
typedef struct event_tag
{
    DWORD dwDevice;
    DWORD timestamp;
    DWORD data;
} EVENT;
typedef EVENT FAR *LPEVENT;


/* Function prototypes 
 */
LRESULT FAR PASCAL WndProc(HWND, UINT, WPARAM , LPARAM);
VOID CommandMsg(HWND hWnd, WPARAM wParam, LPARAM lParam);
void DoMenuItemCheck(HWND hWnd, WORD menuItem, BOOL newState);
void SetupCustomChecks(HANDLE hInstance, HWND hWnd);
BOOL InitFirstInstance(HANDLE);
int Error(LPSTR msg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\about.c ===
/*
 * about.c - Show the "About" box.
 */

#include <windows.h>
#include "about.h"


/* About - Shows the "About MIDI Monitor" dialog.
 *
 * Params:  hWnd - The application's main window handle.
 *          hInstance - The application's instance handle.
 *
 * Returns: void
 */

void About(
  HANDLE  hInstance,
  HWND	  hWnd)
{
    FARPROC fpDlg;

    fpDlg = MakeProcInstance((FARPROC)AboutDlgProc, hInstance);
    DialogBox(hInstance, "About", hWnd, (DLGPROC)fpDlg);
    FreeProcInstance(fpDlg);
}


/* AboutDlgProc - The dialog procedure for the "About MIDI Monitor" dialog.
 *
 * Params:  hDlg - Specifies the associated dialog box.
 *          msg - Specifies the message from the dialog box.
 *	    wParam - 32 bits of message-dependent data.
 *          lParam - 32 bits of message-dependent data.
 *
 * Returns: Non-zero if the message is processed, zero otherwise.
 */

int FAR PASCAL AboutDlgProc(
  HWND	  hDlg,
  UINT	  msg,
  WPARAM  wParam,
  LPARAM  lParam)
{
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);

    switch (msg) {
      case WM_INITDIALOG:
        break;

      case WM_COMMAND:
        EndDialog(hDlg, TRUE);
        break;

      default:
        return FALSE;
        break;
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\about.h ===
/*
 *    about.h
 */


/* Function prototypes
 */
void About(HANDLE hInstance, HWND hWnd);
int FAR PASCAL AboutDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\circbuf.c ===
/*
 * circbuf.c - Routines to manage the circular MIDI input buffer.
 *      This buffer is filled by the low-level callback function and
 *      emptied by the application.  Since this buffer is accessed
 *      by a low-level callback, memory for it must be allocated
 *      exactly as shown in AllocCircularBuffer().
 */

#include <windows.h>
#include "midimon.h"
#include "circbuf.h"

/*
 * AllocCircularBuffer -    Allocates memory for a CIRCULARBUFFER structure 
 * and a buffer of the specified size.  Each memory block is allocated 
 * with GlobalAlloc() using GMEM_SHARE and GMEM_MOVEABLE flags, locked 
 * with GlobalLock(), and page-locked with GlobalPageLock().
 *
 * Params:  dwSize - The size of the buffer, in events.
 *
 * Return:  A pointer to a CIRCULARBUFFER structure identifying the 
 *      allocated display buffer.  NULL if the buffer could not be allocated.
 */
LPCIRCULARBUFFER AllocCircularBuffer(DWORD dwSize)
{
    HANDLE hMem;
    LPCIRCULARBUFFER lpBuf;
    LPEVENT lpMem;
    
    /* Allocate and lock a CIRCULARBUFFER structure.
     */
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE,
                       (DWORD)sizeof(CIRCULARBUFFER));
    if(hMem == NULL)
        return NULL;

    lpBuf = (LPCIRCULARBUFFER)GlobalLock(hMem);
    if(lpBuf == NULL)
    {
        GlobalFree(hMem);
        return NULL;
    }
    
    /* Page lock the memory.  Global memory blocks accessed by
     * low-level callback functions must be page locked.
     */
    //GlobalPageLock((HGLOBAL)HIWORD(lpBuf));

    /* Save the memory handle.
     */
    lpBuf->hSelf = hMem;
    
    /* Allocate and lock memory for the actual buffer.
     */
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, dwSize * sizeof(EVENT));
    if(hMem == NULL)
    {
	//GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf));
        GlobalUnlock(lpBuf->hSelf);
        GlobalFree(lpBuf->hSelf);
        return NULL;
    }
    
    lpMem = (LPEVENT)GlobalLock(hMem);
    if(lpMem == NULL)
    {
        GlobalFree(hMem);
	//GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf));
        GlobalUnlock(lpBuf->hSelf);
        GlobalFree(lpBuf->hSelf);
        return NULL;
    }
    
    /* Page lock the memory.  Global memory blocks accessed by
     * low-level callback functions must be page locked.
     */
    //GlobalPageLock((HGLOBAL)HIWORD(lpMem));
    
    /* Set up the CIRCULARBUFFER structure.
     */
    lpBuf->hBuffer = hMem;
    lpBuf->wError = 0;
    lpBuf->dwSize = dwSize;
    lpBuf->dwCount = 0L;
    lpBuf->lpStart = lpMem;
    lpBuf->lpEnd = lpMem + dwSize;
    lpBuf->lpTail = lpMem;
    lpBuf->lpHead = lpMem;
        
    return lpBuf;
}

/* FreeCircularBuffer - Frees the memory for the given CIRCULARBUFFER 
 * structure and the memory for the buffer it references.
 *
 * Params:  lpBuf - Points to the CIRCULARBUFFER to be freed.
 *
 * Return:  void
 */
void FreeCircularBuffer(LPCIRCULARBUFFER lpBuf)
{
    HANDLE hMem;
    
    /* Free the buffer itself.
     */
    //GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf->lpStart));
    GlobalUnlock(lpBuf->hBuffer);
    GlobalFree(lpBuf->hBuffer);
    
    /* Free the CIRCULARBUFFER structure.
     */
    hMem = lpBuf->hSelf;
    //GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf));
    GlobalUnlock(hMem);
    GlobalFree(hMem);
}

/* GetEvent - Gets a MIDI event from the circular input buffer.  Events
 *  are removed from the buffer.  The corresponding PutEvent() function
 *  is called by the low-level callback function, so it must reside in
 *  the callback DLL.  PutEvent() is defined in the CALLBACK.C module.
 *
 * Params:  lpBuf - Points to the circular buffer.
 *          lpEvent - Points to an EVENT structure that is filled with the
 *              retrieved event.
 *
 * Return:  Returns non-zero if successful, zero if there are no 
 *   events to get.
 */
WORD FAR PASCAL GetEvent(LPCIRCULARBUFFER lpBuf, LPEVENT lpEvent)
{
    /* If no event available, return.
     */
    if(lpBuf->dwCount <= 0)
        return 0;
    
    /* Get the event.
     */
    *lpEvent = *lpBuf->lpTail;
    
    /* Decrement the byte count, bump the tail pointer.
     */
    --lpBuf->dwCount;
    ++lpBuf->lpTail;
    
    /* Wrap the tail pointer, if necessary.
     */
    if(lpBuf->lpTail >= lpBuf->lpEnd)
        lpBuf->lpTail = lpBuf->lpStart;

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\callback\callback.c ===
/* callback.c - Contains the low-level MIDI input callback function for
 *      MIDIMon.  This module also contains the LibMain() and WEP() 
 *      DLL routines, and other functions accessed by the callback.
 *
 *      Because this module contains a low-level callback function,
 *      this entire module must reside in a FIXED code segment in a DLL.
 *      The data segment must be FIXED as well, since it accessed by
 *      the callback.
 */

#include <windows.h>
#include <mmsystem.h>
#include "midimon.h"
#include "circbuf.h"
#include "instdata.h"
#include "callback.h"

static EVENT event;
    
/* midiInputHandler - Low-level callback function to handle MIDI input.
 *      Installed by midiInOpen().  The input handler takes incoming
 *      MIDI events and places them in the circular input buffer.  It then
 *      notifies the application by posting a MM_MIDIINPUT message.
 *
 *      This function is accessed at interrupt time, so it should be as 
 *      fast and efficient as possible.  You can't make any
 *      Windows calls here, except PostMessage().  The only Multimedia
 *      Windows call you can make are timeGetSystemTime(), midiOutShortMsg().
 *      
 *
 * Param:   hMidiIn - Handle for the associated input device.
 *          wMsg - One of the MIM_***** messages.
 *          dwInstance - Points to CALLBACKINSTANCEDATA structure.
 *          dwParam1 - MIDI data.
 *          dwParam2 - Timestamp (in milliseconds)
 *
 * Return:  void
 */     
void FAR PASCAL midiInputHandler(
HMIDIIN hMidiIn, 
WORD wMsg, 
DWORD dwInstance, 
DWORD dwParam1, 
DWORD dwParam2)
{
    UNREFERENCED_PARAMETER(hMidiIn);

    switch(wMsg)
    {
        case MIM_OPEN:
            break;

        /* The only error possible is invalid MIDI data, so just pass
         * the invalid data on so we'll see it.
         */
        case MIM_ERROR:
        case MIM_DATA:
            event.dwDevice = ((LPCALLBACKINSTANCEDATA)dwInstance)->dwDevice;
            event.data = dwParam1;
            event.timestamp = dwParam2;
            
            /* Send the MIDI event to the MIDI Mapper, put it in the
             * circular input buffer, and notify the application that
             * data was received.
             */
            if(((LPCALLBACKINSTANCEDATA)dwInstance)->hMapper)
                midiOutShortMsg( 
                            ((LPCALLBACKINSTANCEDATA)dwInstance)->hMapper, 
                              dwParam1);

            PutEvent(((LPCALLBACKINSTANCEDATA)dwInstance)->lpBuf,
                       (LPEVENT) &event); 

            PostMessage(((LPCALLBACKINSTANCEDATA)dwInstance)->hWnd,
                          MM_MIDIINPUT, 0, 0L);

            break;

        default:
            break;
    }
}

/* PutEvent - Puts an EVENT in a CIRCULARBUFFER.  If the buffer is full, 
 *      it sets the wError element of the CIRCULARBUFFER structure 
 *      to be non-zero.
 *
 * Params:  lpBuf - Points to the CIRCULARBUFFER.
 *          lpEvent - Points to the EVENT.
 *
 * Return:  void
*/
void FAR PASCAL PutEvent(LPCIRCULARBUFFER lpBuf, LPEVENT lpEvent)
{
    /* If the buffer is full, set an error and return. 
     */
    if(lpBuf->dwCount >= lpBuf->dwSize){
        lpBuf->wError = 1;
        return;
    }
    
    /* Put the event in the buffer, bump the head pointer and the byte count.
     */
    *lpBuf->lpHead = *lpEvent;
    
    ++lpBuf->lpHead;
    ++lpBuf->dwCount;

    /* Wrap the head pointer, if necessary.
     */
    if(lpBuf->lpHead >= lpBuf->lpEnd)
        lpBuf->lpHead = lpBuf->lpStart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\filter.c ===
/*
 * filter.c - Routines to filter MIDI events.
 */

#include <windows.h>
#include "midimon.h"
#include "display.h"
#include "filter.h"

/* CheckEventFilter - Checks the given EVENT against the given FILTER.
 *      
 * Params:  lpEvent - Points to an EVENT.
 *          lpFilter - Points to a FILTER structure.
 *
 * Return:  Returns 1 if the event is filtered, 0 if it is not filtered.
 */
BOOL CheckEventFilter(LPEVENT lpEvent, LPFILTER lpFilter)
{
    BYTE bStatus, bStatusRaw, bChannel, bData1, bData2;

    /* Get the essential info from the EVENT.
     */
    bStatusRaw = LOBYTE(LOWORD(lpEvent->data));
    bStatus = bStatusRaw & (BYTE) 0xf0;
    bChannel = LOBYTE(LOWORD(lpEvent->data)) & (BYTE) 0x0f;
    bData1 = HIBYTE(LOWORD(lpEvent->data));
    bData2 = LOBYTE(HIWORD(lpEvent->data));

    /* Do channel filtering for all but system events.
     */
    if(bStatus != SYSTEMMESSAGE){
        if(lpFilter->channel[bChannel])
            return 1;
    }

    /* Do event-type filtering.
     */
    switch(bStatus){
        case NOTEOFF:
            if(lpFilter->event.noteOff)
                return 1;
            break;

        case NOTEON:
            /* A note on with a velocity of 0 is a note off.
             */
            if(bData2 == 0){
                if(lpFilter->event.noteOff)
                    return 1;
                break;
            }
            
            if(lpFilter->event.noteOn)
                return 1;
            break;

        case KEYAFTERTOUCH:
            if(lpFilter->event.keyAftertouch)
                return 1;
            break;

        case CONTROLCHANGE:
            if(lpFilter->event.controller)
                return 1;
            
            /* Channel mode messages can be filtered.
             */
            if((bData1 >= 121) && lpFilter->event.channelMode)
                return 1;
            break;

        case PROGRAMCHANGE:
            if(lpFilter->event.progChange)
                return 1;
            break;

        case CHANAFTERTOUCH:
            if(lpFilter->event.chanAftertouch)
                return 1;
            break;

        case PITCHBEND:
            if(lpFilter->event.pitchBend)
                return 1;
            break;

        case SYSTEMMESSAGE:
            /* System common messages.
             */
            if((bStatusRaw < 0xf8) && (lpFilter->event.sysCommon))
                return 1;

            /* Active sensing messages.
             */
            if((bStatusRaw == 0xfe) && (lpFilter->event.activeSense))
                return 1;

            /* System real time messages.
             */
            if((bStatusRaw >= 0xf8) && lpFilter->event.sysRealTime)
                return 1;
            break;

        default:
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\filter.h ===
/*
 *   filter.h
 */

/* Structure to specify a filter for MIDI events.
 */
typedef struct filter_tag
{
    BOOL channel[16];
    struct {
        BOOL noteOn;
        BOOL noteOff;
        BOOL keyAftertouch;
        BOOL controller;
        BOOL progChange;
        BOOL chanAftertouch;
        BOOL pitchBend;
        BOOL channelMode;
    
        BOOL sysEx;
        BOOL sysCommon;
        BOOL sysRealTime;
        BOOL activeSense;
        BOOL pad0;
        BOOL pad1;
        BOOL pad2;
        BOOL pad3;
    } event;
} FILTER;

typedef FILTER FAR *LPFILTER;


/* Function prototypes
 */
BOOL CheckEventFilter(LPEVENT lpEvent, LPFILTER lpFilter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\display.c ===
/*
 * display.c - Functions to manage the display buffer and convert a
 *      MIDI event to a text string for display.
 *   
 *      The display buffer is filled by the application's WndProc() 
 *      function when it receives an MM_MIDIINPUT message.  This message 
 *      is sent by the low-level callback function upon reception of a
 *      MIDI event.  When the display buffer becomes full, newly added
 *      events overwrite the oldest events in the buffer.
 */

#include <windows.h>
#include <stdio.h>
#include "midimon.h"
#include "circbuf.h"
#include "display.h"

/* MIDI event-name strings 
 */
char szEventNames[8][24] = 
{
                    "Note Off",
                    "Note On",
                    "Key Aftertouch",
                    "Control Change",
                    "Program Change",
                    "Channel Aftertouch",
                    "Pitch Bend",
                    "System Message"
};

char szSysMsgNames[16][24] = 
{
                    "System Exclusive",
                    "MTC Quarter Frame",
                    "Song Position Pointer",
                    "Song Select",
                    "Undefined",
                    "Undefined",
                    "Tune Request",
                    "System Exclusive End",
                    "Timing Clock",
                    "Undefined",
                    "Start",
                    "Continue",
                    "Stop",
                    "Undefined",
                    "Active Sensing",
                    "System Reset" 
};

/* GetDisplayText - Takes a MIDI event and creates a text string for display.
 * 
 * Params:  npText - Points to a string that the function fills.
 *          lpEvent - Points to a MIDI event.
 *
 * Return:  The number of characters in the text string pointed to by npText.
 */
int GetDisplayText(NPSTR npText, LPEVENT lpEvent)
{
    BYTE bStatus, bStatusRaw, bChannel, bData1, bData2;
    DWORD dwTimestamp;
    
    bStatusRaw  = LOBYTE(LOWORD(lpEvent->data));
    bStatus     = bStatusRaw & (BYTE) 0xf0;
    bChannel    = bStatusRaw & (BYTE) 0x0f;
    bData1      = HIBYTE(LOWORD(lpEvent->data));
    bData2      = LOBYTE(HIWORD(lpEvent->data));
    dwTimestamp = lpEvent->timestamp;

    switch(bStatus) 
    {
        /* Three byte events 
         */
        case NOTEOFF:
        case NOTEON:
        case KEYAFTERTOUCH:
        case CONTROLCHANGE:
        case PITCHBEND:
            /* A note on with a velocity of 0 is a note off 
             */
            if((bStatus == NOTEON) && (bData2 == 0))
                bStatus = NOTEOFF;
            
            return(sprintf(npText, FORMAT3, dwTimestamp, bStatusRaw, bData1, 
                    bData2, bChannel, &szEventNames[(bStatus-0x80) >> 4][0]));
            break;

        /* Two byte events 
         */
        case PROGRAMCHANGE:
        case CHANAFTERTOUCH:
            return(sprintf(npText, FORMAT2, dwTimestamp, bStatusRaw, bData1,
                    bChannel, &szEventNames[(bStatus-0x80) >> 4][0]));
            break;

        /* MIDI system events (0xf0 - 0xff) 
         */
        case SYSTEMMESSAGE:
            switch(bStatusRaw) 
            {
                /* Two byte system events 
                 */
                case MTCQUARTERFRAME:
                case SONGSELECT:
                    return(sprintf(npText, FORMAT2X, dwTimestamp, bStatusRaw,
                            bData1,
                            &szSysMsgNames[(bStatusRaw & 0x0f)][0]));
                    break;

                /* Three byte system events 
                 */
                case SONGPOSPTR:
                    return(sprintf(npText, FORMAT3X, dwTimestamp, bStatusRaw,
                            bData1, bData2,
                            &szSysMsgNames[(bStatusRaw & 0x0f)][0]));
                    break;

                /* One byte system events 
                 */
                default:
                    return(sprintf(npText, FORMAT1X, dwTimestamp, bStatusRaw,
                            &szSysMsgNames[(bStatusRaw & 0x0f)][0]));
                    break;
            }
            break;
            
        default:
            return(sprintf(npText, FORMAT3X, dwTimestamp, bStatusRaw, bData1,
                    bData2, "Unknown Event"));
            break;
    }
}

/* AddDisplayEvent - Puts a MIDI event in the display buffer.  The display
 *      buffer is a circular buffer.  Once it is full, newly added events
 *      overwrite the oldest events in the buffer.
 *
 * Params:  lpBuf - Points to the display buffer.
 *          lpEvent - Points to a MIDI event.
 *
 * Return:  void
 */
void AddDisplayEvent(LPDISPLAYBUFFER lpBuf, LPEVENT lpEvent)
{
    /* Put the event in the buffer, bump the head pointer and byte count.
     */
    *lpBuf->lpHead = *lpEvent;
    ++lpBuf->lpHead;
    ++lpBuf->dwCount;

    /* Wrap pointer, if necessary.
     */
    if(lpBuf->lpHead == lpBuf->lpEnd)
        lpBuf->lpHead = lpBuf->lpStart;
    
    /* A full buffer is a full buffer, no more.
     */
    lpBuf->dwCount = min(lpBuf->dwCount, lpBuf->dwSize);
}


/* GetDisplayEvent - Retrieves a MIDI event from the display buffer.  
 *      Unlike the input buffer, the event is not removed from the buffer.
 *
 * Params:  lpBuf - Points to the display buffer.
 *          lpEvent - Points to an EVENT structure that is filled with
 *              the retrieved MIDI event.
 *          wNum - Specifies which event to retrieve.
 *
 * Return:  void
 */
void GetDisplayEvent(LPDISPLAYBUFFER lpBuf, LPEVENT lpEvent, DWORD wNum)
{
    LPEVENT lpFirstEvent, lpThisEvent;
    
    /* Get pointer to the first (oldest) event in buffer.
     */
    if(lpBuf->dwCount < lpBuf->dwSize)      // buffer is not yet full
        lpFirstEvent = lpBuf->lpStart;
    
    else                                    // buffer is full
        lpFirstEvent = lpBuf->lpHead;
    
    /* Offset pointer to point to requested event; wrap pointer.
     */
    lpThisEvent = lpFirstEvent + wNum;
    if(lpThisEvent >= lpBuf->lpEnd)
        lpThisEvent = lpBuf->lpStart + (lpThisEvent - lpBuf->lpEnd);
    
    /* Get the requested event.
     */
    *(lpEvent) = *lpThisEvent;
}

/* AllocDisplayBuffer - Allocates memory for a DISPLAYBUFFER structure 
 *      and a buffer of the specified size.  Each memory block is allocated 
 *      with GlobalAlloc() using GMEM_SHARE and GMEM_MOVEABLE flags and 
 *      locked with GlobalLock().  Since this buffer is only accessed by the
 *      application, and not the low-level callback function, it does not
 *      have to be page locked.
 *
 * Params:  dwSize - The size of the buffer, in events.
 *
 * Return:  A pointer to a DISPLAYBUFFER structure identifying the 
 *      allocated display buffer.  NULL if the buffer could not be allocated.
*/
LPDISPLAYBUFFER AllocDisplayBuffer(DWORD dwSize)
{
    HANDLE hMem;
    LPDISPLAYBUFFER lpBuf;
    LPEVENT lpMem;
    
    /* Allocate and lock a DISPLAYBUFFER structure.
     */
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE,
                       (DWORD)sizeof(DISPLAYBUFFER));
    if(hMem == NULL)
        return NULL;

    lpBuf = (LPDISPLAYBUFFER)GlobalLock(hMem);
    if(lpBuf == NULL)
    {
        GlobalFree(hMem);
        return NULL;
    }

    /* Save the handle.
     */
    lpBuf->hSelf = hMem;
    
    /* Allocate and lock memory for the actual buffer.
     */
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, dwSize * sizeof(EVENT));
    if(hMem == NULL)
    {
        GlobalUnlock(lpBuf->hSelf);
        GlobalFree(lpBuf->hSelf);
        return NULL;
    }
    lpMem = (LPEVENT)GlobalLock(hMem);
    if(lpMem == NULL)
    {
        GlobalFree(hMem);
        GlobalUnlock(lpBuf->hSelf);
        GlobalFree(lpBuf->hSelf);
        return NULL;
    }

    /* Set up the DISPLAYBUFFER structure.
     */
    lpBuf->hBuffer = hMem;
    lpBuf->wError = 0;
    lpBuf->dwSize = dwSize;
    lpBuf->dwCount = 0L;
    lpBuf->lpStart = lpMem;
    lpBuf->lpEnd = lpMem + dwSize;
    lpBuf->lpTail = lpMem;
    lpBuf->lpHead = lpMem;
        
    return lpBuf;
}

/* FreeDisplayBuffer - Frees the memory for a display buffer.
 *
 * Params:  lpBuf - Points to the DISPLAYBUFFER to be freed.
 *
 * Return:  void
 */
void FreeDisplayBuffer(LPDISPLAYBUFFER lpBuf)
{
    HANDLE hMem;
    
    /* Unlock and free the buffer itself.
     */
    GlobalUnlock(lpBuf->hBuffer);
    GlobalFree(lpBuf->hBuffer);
    
    /* Unlock and free the DISPLAYBUFFER structure.
     */
    hMem = lpBuf->hSelf;
    GlobalUnlock(hMem);
    GlobalFree(hMem);
}

/* ResetDisplayBuffer - Empties a display buffer.
 *
 * Params:  lpBuf - Points to a display buffer.
 *
 * Return:  void
 */
void ResetDisplayBuffer(LPDISPLAYBUFFER lpBuf)
{
    /* Reset the pointers and event count.
     */
    lpBuf->lpHead = lpBuf->lpStart;
    lpBuf->lpTail = lpBuf->lpStart;
    lpBuf->dwCount = 0L;
    lpBuf->wError = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\display.h ===
/*
 *  display.h
 */


/* MIDI status byte definitions
 */
#define NOTEON          0x90
#define NOTEOFF         0x80
#define KEYAFTERTOUCH   0xa0
#define CONTROLCHANGE   0xb0
#define PROGRAMCHANGE   0xc0
#define CHANAFTERTOUCH  0xd0
#define PITCHBEND       0xe0
#define SYSTEMMESSAGE   0xf0
#define BEGINSYSEX      0xf0
#define MTCQUARTERFRAME 0xf1
#define SONGPOSPTR      0xf2
#define SONGSELECT      0xf3

/* Format strings used by GetDisplayText()
 */
#define FORMAT3  " %08lX  %02X     %02X    %02X    %2d   %-21s "
#define FORMAT2  " %08lX  %02X     %02X    --    %2d   %-21s "
#define FORMAT3X " %08lX  %02X     %02X    %02X    --   %-21s "
#define FORMAT2X " %08lX  %02X     %02X    --    --   %-21s "
#define FORMAT1X " %08lX  %02X     --    --    --   %-21s "


/* Data structure to manage a display buffer.
 */
typedef struct displayBuffer_tag
{
    HANDLE  hSelf;          /* handle to this structure */
    HANDLE  hBuffer;        /* buffer handle */
    WORD    wError;         /* error flags */
    DWORD   dwSize;         /* buffer size (in EVENTS) */
    DWORD   dwCount;        /* byte count (in EVENTS) */
    LPEVENT lpStart;        /* ptr to start of buffer */
    LPEVENT lpEnd;          /* ptr to end of buffer (last byte + 1) */
    LPEVENT lpHead;         /* ptr to head (next location to fill) */
    LPEVENT lpTail;         /* ptr to tail (next location to empty) */
} DISPLAYBUFFER;
typedef DISPLAYBUFFER FAR *LPDISPLAYBUFFER;


/* Function prototypes
 */
int GetDisplayText(NPSTR npText, LPEVENT lpEvent);
void AddDisplayEvent(LPDISPLAYBUFFER lpBuf, LPEVENT lpEvent);
void GetDisplayEvent(LPDISPLAYBUFFER lpBuf, LPEVENT lpEvent, DWORD wNum);
LPDISPLAYBUFFER AllocDisplayBuffer(DWORD dwSize);
void FreeDisplayBuffer(LPDISPLAYBUFFER lpBuf);
void ResetDisplayBuffer(LPDISPLAYBUFFER lpBuf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\prefer.h ===
/*
 *  prefer.h
 */


/* MIDIMON.INI entries.
 */
#define INI_FILENAME        (LPSTR) "MIDIMON.INI"
#define INI_DISPLAYWINDOW   (LPSTR) "Display Window"
#define INI_X               (LPSTR) "x"
#define INI_Y               (LPSTR) "y"
#define INI_W               (LPSTR) "w"
#define INI_H               (LPSTR) "h"

/* Default values for preference variables.
 */
#define DEF_X               20
#define DEF_Y               20
#define DEF_W               481
#define DEF_H               256


/* Data structure used to specify user preferences.
 */
typedef struct preferences_tag
{
    int iInitialX;
    int iInitialY;
    int iInitialW;
    int iInitialH;
    DWORD dwInputBufferSize;
    DWORD dwDisplayBufferSize;
    int wDisplayFormat;
} PREFERENCES;
typedef PREFERENCES FAR *LPPREFERENCES;


/* Function prototypes
 */
void getPreferences(LPPREFERENCES);
void setPreferences(LPPREFERENCES);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\instdata.c ===
/*
 * instdata.c - Functions to allocate and free the instance
 *      data structure passed to the low-level callback function.
 */

#include <windows.h>
#include <mmsystem.h>
#include "midimon.h"
#include "circbuf.h"
#include "instdata.h"

/* AllocCallbackInstanceData - Allocates a CALLBACKINSTANCEDATA
 *      structure.  This structure is used to pass information to the
 *      low-level callback function, each time it receives a message.
 *
 *      Because this structure is accessed by the low-level callback
 *      function, it must be allocated using GlobalAlloc() with the 
 *      GMEM_SHARE and GMEM_MOVEABLE flags and page-locked with
 *      GlobalPageLock().
 *
 * Params:  void
 *
 * Return:  A pointer to the allocated CALLBACKINSTANCE data structure.
 */
LPCALLBACKINSTANCEDATA FAR PASCAL AllocCallbackInstanceData(void)
{
    HANDLE hMem;
    LPCALLBACKINSTANCEDATA lpBuf;
    
    /* Allocate and lock global memory.
     */
    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE,
                       (DWORD)sizeof(CALLBACKINSTANCEDATA));
    if(hMem == NULL)
        return NULL;
    
    lpBuf = (LPCALLBACKINSTANCEDATA)GlobalLock(hMem);
    if(lpBuf == NULL){
        GlobalFree(hMem);
        return NULL;
    }
    
    /* Page lock the memory.
     */
    //GlobalPageLock((HGLOBAL)HIWORD(lpBuf));

    /* Save the handle.
     */
    lpBuf->hSelf = hMem;

    return lpBuf;
}

/* FreeCallbackInstanceData - Frees the given CALLBACKINSTANCEDATA structure.
 *
 * Params:  lpBuf - Points to the CALLBACKINSTANCEDATA structure to be freed.
 *
 * Return:  void
 */
void FAR PASCAL FreeCallbackInstanceData(LPCALLBACKINSTANCEDATA lpBuf)
{
    HANDLE hMem;

    /* Save the handle until we're through here.
     */
    hMem = lpBuf->hSelf;

    /* Free the structure.
     */
    //GlobalPageUnlock((HGLOBAL)HIWORD(lpBuf));
    GlobalUnlock(hMem);
    GlobalFree(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\prefer.c ===
/*
 * prefer.c - Routines to get and set user preferences.
 */

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include "midimon.h"
#include "prefer.h"

/* getPreferences - Reads .INI file and gets the setup preferences.
 *      Currently, the only user preferences are window location and size.
 *      If the .INI file does not exist, returns default values.
 *
 * Params:  lpPreferences - Points to a PREFERENCES data structure that
 *              is filled with the retrieved user preferences.
 *
 * Return:  void
*/
void getPreferences(LPPREFERENCES lpPreferences)
{
    lpPreferences->iInitialX = 
        GetPrivateProfileInt(INI_DISPLAYWINDOW, INI_X, DEF_X, INI_FILENAME);

    lpPreferences->iInitialY = 
        GetPrivateProfileInt(INI_DISPLAYWINDOW, INI_Y, DEF_Y, INI_FILENAME);

    lpPreferences->iInitialW = 
        GetPrivateProfileInt(INI_DISPLAYWINDOW, INI_W, DEF_W, INI_FILENAME);

    lpPreferences->iInitialH = 
        GetPrivateProfileInt(INI_DISPLAYWINDOW, INI_H, DEF_H, INI_FILENAME);
}

/* setPreferences - Writes the .INI file with the given setup preferences.
 *
 * Params:  lpPreferences - Points to a PREFERENCES data structure containing
 *              the user preferences.
 *
 * Return:  void
 */
void setPreferences(LPPREFERENCES lpPreferences)
{
    char szTempString[20];

    sprintf(szTempString, "%d", lpPreferences->iInitialX);
    if(WritePrivateProfileString(INI_DISPLAYWINDOW, INI_X,
                              (LPSTR) szTempString, INI_FILENAME) == 0)
        Error("Error writing MIDIMON.INI");
        
    sprintf(szTempString, "%d", lpPreferences->iInitialY);
    if(WritePrivateProfileString(INI_DISPLAYWINDOW, INI_Y,
                              (LPSTR) szTempString, INI_FILENAME) == 0)
        Error("Error writing MIDIMON.INI");
        
    sprintf(szTempString, "%d", lpPreferences->iInitialW);
    if(WritePrivateProfileString(INI_DISPLAYWINDOW, INI_W,
                              (LPSTR) szTempString, INI_FILENAME) == 0)
        Error("Error writing MIDIMON.INI");
        
    sprintf(szTempString, "%d", lpPreferences->iInitialH);
    if(WritePrivateProfileString(INI_DISPLAYWINDOW, INI_H,
                              (LPSTR) szTempString, INI_FILENAME) == 0)
        Error("Error writing MIDIMON.INI");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mmcapsex\appport.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  appport.h -- Win 16/32 Portability Stuff
//
//  Description:
//      This file contains common macros to help with writing code that
//      cross compiles between Win 32 and Win 16. This file should be
//      included _after_ windows.h and windowsx.h.
//
//  History:
//      11/ 8/92    created.
//
//==========================================================================;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 32
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
    #ifndef FNLOCAL
	#define FNLOCAL     _stdcall
	#define FNCLOCAL    _stdcall
	#define FNGLOBAL    _stdcall
	#define FNCGLOBAL   _stdcall
	#define FNCALLBACK  CALLBACK
	#define FNEXPORT    CALLBACK
    #endif

//    #ifndef PCTSTR
//	typedef const PTSTR     PCTSTR;
//    #endif

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
	((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
	#define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
	#define SIZEOF(x)   sizeof(x)
    #endif

    //
    //  win32 apps [usually] don't have to worry about 'huge' data
    //
    #if !defined hmemcpy
	#define hmemcpy memcpy
    #endif
#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
	#define FNLOCAL     NEAR PASCAL
	#define FNCLOCAL    NEAR _cdecl
	#define FNGLOBAL    FAR PASCAL
	#define FNCGLOBAL   FAR _cdecl
	#define FNCALLBACK  CALLBACK
	#define FNEXPORT    CALLBACK _export
    #endif

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
	#define _TCHAR_DEFINED
	typedef char            TCHAR, *PTCHAR;
	typedef unsigned char   TBYTE, *PTUCHAR;

	typedef PSTR            PTSTR, PTCH;
	typedef const PTSTR     PCTSTR;
	typedef LPSTR           LPTSTR, LPTCH;
	typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
	DWORD   dw;                                                 \
	dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
	*pnE = (int)HIWORD(dw);                                     \
	*pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\midimon\monitor\midimon.c ===
/* midimon.c - WinMain() and WndProc() functions for MIDIMon, along
 *      with some initialization and error reporting functions.
 *
 * MIDIMon is a Windows with Multimedia application that records and displays 
 *  incoming MIDI information.  It uses a low-level callback function to 
 *  get timestamped MIDI input.  The callback function puts the incoming
 *  MIDI event information (source device, timestamp, and raw MIDI
 *  data) in a circular input buffer and notifies the application by posting 
 *  a MM_MIDIINPUT message.  When the application processes the MM_MIDIINPUT
 *  message, it removes the MIDI event from the input buffer and puts it in
 *  a display buffer.  Information in the display buffer is converted to
 *  text and displayed in a scrollable window.  Incoming MIDI data can be sent
 *  to the MIDI Mapper if the user chooses.  Filtering is provided for the
 *  display buffer, but not for data sent to the Mapper.
 *
 *    (C) Copyright Microsoft Corp. 1991.  All rights reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and 
 *    distribute the Sample Files (and/or any modified version) in 
 *    any way you find useful, provided that you agree that 
 *    Microsoft has no warranty obligations or liability for any 
 *    Sample Application Files which are modified. 
 *
 */

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include "midimon.h"
#include "about.h"
#include "circbuf.h"
#include "display.h"
#include "prefer.h"
#include "instdata.h"
#include "callback.h"
#include "filter.h"

HANDLE hInst;                           // Instance handle for application
char szAppName[20];                     // Application name
HWND hMainWnd;                          // Main window handle
HMIDIOUT hMapper = 0;                   // Handle to MIDI Mapper
UINT wNumDevices = 0;			 // Number of MIDI input devices opened
BOOL bRecordingEnabled = 1;             // Enable/disable recording flag
LONG nNumBufferLines = 0;		 // Number of lines in display buffer
RECT rectScrollClip;                    // Clipping rectangle for scrolling

LPCIRCULARBUFFER lpInputBuffer;         // Input buffer structure
LPDISPLAYBUFFER lpDisplayBuffer;        // Display buffer structure
PREFERENCES preferences;                // User preferences structure
EVENT incomingEvent;                    // Incoming MIDI event structure

MIDIINCAPS midiInCaps[MAX_NUM_DEVICES]; // Device capabilities structures
HMIDIIN hMidiIn[MAX_NUM_DEVICES];       // MIDI input device handles

// Callback instance data pointers
LPCALLBACKINSTANCEDATA lpCallbackInstanceData[MAX_NUM_DEVICES];

// Display filter structure
FILTER filter = {
                    0, 0, 0, 0, 0, 0, 0, 0, 
                    0, 0, 0, 0, 0, 0, 0, 0, 
                    0, 0, 0, 0, 0, 0, 0, 0, 
                    0, 0, 0, 0, 0, 0, 0, 0
                };

// Virtual key to scroll message translation structure
KEYTOSCROLL keyToScroll [] = { 
                                VK_HOME,  WM_VSCROLL, SB_TOP,
                                VK_END,   WM_VSCROLL, SB_BOTTOM,
                                VK_PRIOR, WM_VSCROLL, SB_PAGEUP,
                                VK_NEXT,  WM_VSCROLL, SB_PAGEDOWN,
                                VK_UP,    WM_VSCROLL, SB_LINEUP,
                                VK_DOWN,  WM_VSCROLL, SB_LINEDOWN,
                                VK_LEFT,  WM_HSCROLL, SB_LINEUP,
                                VK_RIGHT, WM_HSCROLL, SB_LINEDOWN 
                             };

#define NUMKEYS (sizeof (keyToScroll) / sizeof (keyToScroll[0]))


                                                                        //
/* WinMain - Entry point for MIDIMon.
 */
int PASCAL WinMain(hInstance,hPrevInstance,lpszCmdLine,cmdShow)
HANDLE hInstance,hPrevInstance;
LPSTR lpszCmdLine;
int cmdShow;
{
    MSG msg;
    UINT  wRtn;
    PREFERENCES preferences;
    char szErrorText[256];
    unsigned int i;

    UNREFERENCED_PARAMETER(lpszCmdLine);

    hInst = hInstance;

    /* Get preferred user setup.
     */
    getPreferences(&preferences);
    
    /* Initialize application.
     */
    LoadString(hInstance, IDS_APPNAME, szAppName, sizeof(szAppName)); 
    if (hPrevInstance || !InitFirstInstance(hInstance))
        return 0;

    /* Create a display window.
     */
    hMainWnd = CreateWindow(szAppName,
                        szAppName,
                        WS_OVERLAPPEDWINDOW | WS_HSCROLL | WS_VSCROLL,
                        preferences.iInitialX,
                        preferences.iInitialY,
                        preferences.iInitialW,
                        preferences.iInitialH,
                        (HWND)NULL,
                        (HMENU)NULL,
                        hInstance,
                        (LPSTR)NULL);

    if (!hMainWnd)
        return 1;

    /* Hide scroll bars for now.
     */
    SetScrollRange(hMainWnd, SB_VERT, 0, 0, FALSE);
    SetScrollRange(hMainWnd, SB_HORZ, 0, 0, FALSE);
    
    /* Show the display window.
     */
    ShowWindow(hMainWnd, cmdShow);
    UpdateWindow(hMainWnd);
    
    /* Get the number of MIDI input devices.  Then get the capabilities of
     * each device.  We don't use the capabilities information right now,
     * but we could use it to report the name of the device that received
     * each MIDI event.
     */
    wNumDevices = midiInGetNumDevs();
    if (!wNumDevices) {
        Error("There are no MIDI input devices.");
        PostQuitMessage(0);
    }
    for (i=0; (i<wNumDevices) && (i<MAX_NUM_DEVICES); i++) {
        wRtn = midiInGetDevCaps(i, (LPMIDIINCAPS) &midiInCaps[i],
                                sizeof(MIDIINCAPS));
        if(wRtn) {
            midiInGetErrorText(wRtn, (LPSTR)szErrorText, 
                               sizeof(szErrorText));
            Error(szErrorText);
        }
    }

    /* Allocate a circular buffer for low-level MIDI input.  This buffer
     * is filled by the low-level callback function and emptied by the
     * application when it receives MM_MIDIINPUT messages.
     */
    lpInputBuffer = AllocCircularBuffer(
                        (DWORD)(INPUT_BUFFER_SIZE * sizeof(EVENT)));
    if (lpInputBuffer == NULL) {
        Error("Not enough memory available for input buffer.");
        return 1;
    }

    /* Allocate a display buffer.  Incoming events from the circular input
     * buffer are put into this buffer for display.
     */
    lpDisplayBuffer = AllocDisplayBuffer((DWORD)(DISPLAY_BUFFER_SIZE));
    if (lpDisplayBuffer == NULL) {
        Error("Not enough memory available for display buffer.");
        FreeCircularBuffer(lpInputBuffer);
        return 1;
    }

    /* Open all MIDI input devices after allocating and setting up
     * instance data for each device.  The instance data is used to
     * pass buffer management information between the application and
     * the low-level callback function.  It also includes a device ID,
     * a handle to the MIDI Mapper, and a handle to the application's
     * display window, so the callback can notify the window when input
     * data is available.  A single callback function is used to service
     * all opened input devices.
     */
    for (i=0; (i<wNumDevices) && (i<MAX_NUM_DEVICES); i++)
    {
        if ((lpCallbackInstanceData[i] = AllocCallbackInstanceData()) == NULL)
        {
            Error("Not enough memory available.");
            FreeCircularBuffer(lpInputBuffer);
            FreeDisplayBuffer(lpDisplayBuffer);
            return 1;
        }
        lpCallbackInstanceData[i]->hWnd = hMainWnd;         
        lpCallbackInstanceData[i]->dwDevice = i;
        lpCallbackInstanceData[i]->lpBuf = lpInputBuffer;
        lpCallbackInstanceData[i]->hMapper = hMapper;
        
        wRtn = midiInOpen((LPHMIDIIN)&hMidiIn[i],
                          i,
                          (DWORD)midiInputHandler,
                          (DWORD)lpCallbackInstanceData[i],
                          CALLBACK_FUNCTION);
        if(wRtn)
        {
            FreeCallbackInstanceData(lpCallbackInstanceData[i]);
            midiInGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText));
            Error(szErrorText);
        }
    }

    /* Start MIDI input.
     */
    for (i=0; (i<wNumDevices) && (i<MAX_NUM_DEVICES); i++) {
        if (hMidiIn[i])
            midiInStart(hMidiIn[i]);
    }

    /* Standard Windows message processing loop.  We don't drop out of
     * this loop until the user quits the application.
     */
    while (GetMessage(&msg, NULL, 0, 0)) {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
    }

    /* Stop, reset, close MIDI input.  Free callback instance data.
     */
    for (i=0; (i<wNumDevices) && (i<MAX_NUM_DEVICES); i++) {
        if (hMidiIn[i]) {
            midiInStop(hMidiIn[i]);
            midiInReset(hMidiIn[i]);
            midiInClose(hMidiIn[i]);
            FreeCallbackInstanceData(lpCallbackInstanceData[i]);
        }
    }

    /* Close the MIDI Mapper, if it's open.
     */
    if (hMapper)
        midiOutClose(hMapper);
    
    /* Free input and display buffers.
     */
    FreeCircularBuffer(lpInputBuffer);
    FreeDisplayBuffer(lpDisplayBuffer);

    return (msg.wParam);
}

                                                                        //
/* WndProc - Main window procedure function.
 */
LRESULT FAR PASCAL WndProc(
  HWND	  hWnd,
  UINT	  message,
  WPARAM  wParam,
  LPARAM  lParam)
{
    PAINTSTRUCT ps;
    HFONT hFont;
    HBRUSH hBrush;
//!!    HPEN hPen;
    HDC hDC;
    TEXTMETRIC tm;
    static BOOL  bWindowCreated = 0;
    static LONG	 wChar, hChar;
    static LONG  maxClientWidth;
    static LONG	 wClient, hClient;
    static LONG	 nVscrollMax = 0;
    static LONG	 nHscrollMax = 0;
    static LONG	 nVscrollPos = 0;
    static LONG	 nHscrollPos = 0;
    static LONG  nNumCharsPerLine = 0;
    static LONG  nNumDisplayLines = 0;
    static LONG  nNumDisplayChars = 0;
    BOOL	 bNeedToUpdate = FALSE;
    LONG	 nVscrollInc, nHscrollInc;
    LONG	 nPaintBeg, nPaintEnd;
    LONG  i;
    SIZE  size;
        
    char szDisplayTextBuffer[120];

    switch(message)
    {
        case WM_CREATE:
            hDC = GetDC(hWnd);

            /* Set the font we want to use.
             */
            hFont = GetStockObject(ANSI_FIXED_FONT);
            SelectObject(hDC, hFont);
            
            /* Get text metrics and calculate the number of characters
             * per line and the maximum width required for the client area.
             */
            GetTextMetrics(hDC, &tm);
	    wChar = (LONG) tm.tmAveCharWidth;
	    hChar = (LONG) (tm.tmHeight + tm.tmExternalLeading);
	    nNumCharsPerLine = sizeof(LABEL) - 1;

	    GetTextExtentPoint(hDC,
			       szDisplayTextBuffer,
			       sprintf(szDisplayTextBuffer, LABEL),
			       &size);
	    maxClientWidth = size.cx;

            ReleaseDC(hWnd, hDC);
            
            bWindowCreated = 1;
            break;

        case WM_SIZE:
	    hClient = (LONG) HIWORD(lParam);
	    wClient = (LONG) LOWORD(lParam);

            /* Get new client area and adjust scroll clip rectangle.
             */
            GetClientRect(hWnd, (LPRECT)&rectScrollClip);
            rectScrollClip.top += hChar;
            
            /* Calculate new display metrics.  We subtract 1 from
             * nNumDisplayLines to allow room for the label line.
             */
            nNumDisplayLines = hClient / hChar - 1;
            nNumDisplayChars = wClient / wChar;

            /* Calculate and set new scroll bar calibrations.
             */
	    nVscrollMax = (LONG) max(0, nNumBufferLines - nNumDisplayLines);
	    nVscrollPos = (LONG) min(nVscrollPos, nVscrollMax);
	    nHscrollMax = (LONG) max(0, nNumCharsPerLine - nNumDisplayChars);
	    nHscrollPos = (LONG) min(nHscrollPos, nHscrollMax);
            SetScrollRange(hWnd, SB_VERT, 0, nVscrollMax, FALSE);
            SetScrollPos(hWnd, SB_VERT, nVscrollPos, TRUE);
            SetScrollRange(hWnd, SB_HORZ, 0, nHscrollMax, FALSE);
            SetScrollPos(hWnd, SB_HORZ, nHscrollPos, TRUE);
            break;

        case WM_GETMINMAXINFO:
            /* Limit the maximum width of the window.
             */
	    if(bWindowCreated) {
		((LPPOINT)lParam)[4].x = maxClientWidth +
					 (2 * GetSystemMetrics(SM_CXFRAME)) +
					 (GetSystemMetrics(SM_CXVSCROLL));
	    }

  //		*((LPWORD)lParam + 8) = maxClientWidth +
  //					 (2 * GetSystemMetrics(SM_CXFRAME)) +
  //					(GetSystemMetrics(SM_CXVSCROLL));
            break;
            
        case WM_COMMAND:
            /* Process menu messages. 
             */
            CommandMsg(hWnd, wParam, lParam); 
            break;

        case WM_VSCROLL:
            /* Determine how much to scroll vertically.
             */
	    switch (LOWORD(wParam))
            {
                case SB_TOP:
                    nVscrollInc = -nVscrollPos;
                    break;
                    
                case SB_BOTTOM:
                    nVscrollInc = nVscrollMax - nVscrollPos;
                    break;

                case SB_LINEUP:
                    nVscrollInc = -1;
                    break;

                case SB_LINEDOWN:
                    nVscrollInc = 1;
                    break;

                case SB_PAGEUP:
                    nVscrollInc = min (-1, -nNumDisplayLines);
                    break;

                case SB_PAGEDOWN:
		    nVscrollInc = (LONG) max(1, nNumDisplayLines);
                    break;

                case SB_THUMBTRACK:
		    nVscrollInc = ((LONG)HIWORD(wParam) - nVscrollPos);
                    break;

                default:
                    nVscrollInc = 0;
            
            }
            
            /* Limit the scroll range and do the scroll.  We use the
             * rectScrollClip rectangle because we don't want to scroll
             * the entire window, only the part below the display label line.
             */
	    if(nVscrollInc = max(-nVscrollPos,
				 min(nVscrollInc,
				     nVscrollMax - nVscrollPos)))
            {
                nVscrollPos += nVscrollInc;
                ScrollWindow(hWnd, 0, -hChar * nVscrollInc,
                              (LPRECT)&rectScrollClip,
                              (LPRECT)&rectScrollClip);
                UpdateWindow(hWnd);
                SetScrollPos(hWnd, SB_VERT, nVscrollPos, TRUE);
            }
            break;

        case WM_HSCROLL:
            /* Determine how much to scroll horizontally.
             */
	    switch (LOWORD(wParam))
            {
                case SB_LINEUP:
                    nHscrollInc = -1;
                    break;

                case SB_LINEDOWN:
                    nHscrollInc = 1;
                    break;

                case SB_PAGEUP:
		    nHscrollInc = (LONG) min(-1, -nNumDisplayChars);
                    break;

                case SB_PAGEDOWN:
		    nHscrollInc = (LONG) max(1, nNumDisplayChars);
                    break;

                case SB_THUMBTRACK:
		    nHscrollInc = ((LONG)HIWORD(wParam) - nHscrollPos);
                    break;

                default:
                    nHscrollInc = 0;
            }
            
            /* Limit the scroll range and to the scroll.
             */
	    if(nHscrollInc = max(-nHscrollPos,
				 min(nHscrollInc,
				     nHscrollMax - nHscrollPos)))
            {
                nHscrollPos += nHscrollInc;
                ScrollWindow(hWnd, -wChar * nHscrollInc, 0, NULL, NULL);
                UpdateWindow(hWnd);
                SetScrollPos(hWnd, SB_HORZ, nHscrollPos, TRUE);
            }
            break;

        case WM_KEYDOWN:
            /* Translate keystrokes to scroll message.
             */
            for (i = 0; i < NUMKEYS; i++)
                if (wParam == keyToScroll[i].wVirtKey)
                {
                    SendMessage(hWnd, keyToScroll[i].iMessage,
                                keyToScroll[i].wRequest, 0L);
                    break;
                }
            break;

        case WM_PAINT:
            BeginPaint(hWnd, &ps);

            hBrush = CreateSolidBrush(GetSysColor(COLOR_APPWORKSPACE));
            FillRect(ps.hdc, &ps.rcPaint, hBrush);
            DeleteObject(hBrush);

            /* Set up text attributes.
             */
            hFont = GetStockObject(ANSI_FIXED_FONT);
            SelectObject(ps.hdc, hFont);
            SetBkMode(ps.hdc, TRANSPARENT);

            /* Put up the display label if we're asked to repaint the
             * top line of the screen.
             */
	    if(ps.rcPaint.top < hChar)
            {
                TextOut(ps.hdc, wChar * (0 - nHscrollPos),
                        0, szDisplayTextBuffer,
                        sprintf(szDisplayTextBuffer, LABEL));
		MoveToEx(ps.hdc, wChar * (0 - nHscrollPos), hChar - 1, NULL);
                LineTo(ps.hdc, wClient, hChar - 1);

                ps.rcPaint.top = hChar;
            }
                
            /* Calculate the beginning and ending line numbers that we need
             * to paint.  These line numbers refer to lines in the display
             * buffer, not to lines in the display window.
             */
	    nPaintBeg = max (0, nVscrollPos + ps.rcPaint.top / hChar - 1);
            nPaintEnd = min(nNumBufferLines,
                              nVscrollPos + ps.rcPaint.bottom / hChar + 1);

            /* Get the appropriate events from the display buffer, convert
             * to a text string and paint the text on the display.
             */
            for (i = nPaintBeg; i < nPaintEnd; i++)
            {
                GetDisplayEvent(lpDisplayBuffer, (LPEVENT)&incomingEvent, i);
                TextOut(ps.hdc, 
                        wChar * (0 - nHscrollPos),
                        hChar * (1 - nVscrollPos + i),
                        szDisplayTextBuffer, 
                        GetDisplayText(szDisplayTextBuffer,
                                       (LPEVENT)&incomingEvent));
            }
                
            EndPaint(hWnd, &ps);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case MM_MIDIINPUT:
            /* This is a custom message sent by the low level callback
             * function telling us that there is at least one MIDI event
             * in the input buffer.  We empty the input buffer, and put
             * each event in the display buffer, if it's not filtered.
             * If the input buffer is being filled as fast we can empty
             * it, then we'll stay in this loop and not process any other
             * Windows messages, or yield to other applications.  We need
             * something to restrict the amount of time we spend here...
             */
            while(GetEvent(lpInputBuffer, (LPEVENT)&incomingEvent))
            {
                if(!bRecordingEnabled)
                    continue;

                if(!CheckEventFilter((LPEVENT)&incomingEvent,
                                    (LPFILTER)&filter))
                {
                    AddDisplayEvent(lpDisplayBuffer, 
                                    (LPEVENT)&incomingEvent);
                    ++nNumBufferLines;
                    nNumBufferLines = min(nNumBufferLines,
					  DISPLAY_BUFFER_SIZE - 1);
		    bNeedToUpdate = TRUE;
                }
            }
            
            /* Recalculate vertical scroll bar range, and force
             * the display to be updated.
	     */

	    if (bNeedToUpdate) {
	      nVscrollMax = (LONG) max(0, nNumBufferLines - nNumDisplayLines);
	      nVscrollPos = nVscrollMax;
	      SetScrollRange(hWnd, SB_VERT, 0, nVscrollMax, FALSE);
	      SetScrollPos(hWnd, SB_VERT, nVscrollPos, TRUE);
	      InvalidateRect(hMainWnd, (LPRECT)&rectScrollClip, 0);
	      UpdateWindow(hMainWnd);
	    }
            
            break;

        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
            break;
    }
    return 0;
}

                                                                        //
/* CommandMsg - Processes WM_COMMAND messages.
 *
 * Params:  hWnd - Handle to the window receiving the message.
 *	    wParam - Parameter of the WM_COMMAND message.
 *	    lParam - Parameter of the WM_COMMAND message.
 *
 * Return:  void
 */
VOID  CommandMsg(
  HWND	  hWnd,
  WPARAM  wParam,
  LPARAM  lParam)
{
    PREFERENCES preferences;
    RECT rectWindow;
    UINT  wRtn;
    HMENU hMenu;
    unsigned int i;
    char szErrorText[80];
    WORD  wCommand;

    UNREFERENCED_PARAMETER(lParam);

    wCommand = LOWORD(wParam);
    
    /* Process any WM_COMMAND messages we want */
    switch (wCommand) {
        case IDM_ABOUT:
            About(hInst, hWnd);
            break;

        case IDM_EXIT:
            PostMessage(hWnd, WM_CLOSE, 0, 0l);
            break;

        case IDM_SENDTOMAPPER:
            /* We use hMapper as a toggle between sending events to the
             * Mapper and not sending events.
             */
            if(hMapper) {
                /* Close the Mapper and reset hMapper.  Uncheck the menu item.
                 * Clear Mapper handle in the instance data for each device.
                 */
                wRtn = midiOutClose(hMapper);
                if(wRtn != 0)
                {
                    midiOutGetErrorText(wRtn, (LPSTR)szErrorText, 
                                        sizeof(szErrorText));
                    Error(szErrorText);
                }
                hMapper = 0;

                for (i=0; (i<wNumDevices) && (i<MAX_NUM_DEVICES); i++)
                    lpCallbackInstanceData[i]->hMapper = hMapper;

		DoMenuItemCheck(hWnd, wCommand, FALSE);
            }
            
            else {
                /* Open the MIDI Mapper, put the Mapper handle in the instance
                 * data for each device and check the menu item.
                 */
		wRtn = midiOutOpen((LPHMIDIOUT) &hMapper, (UINT) MIDIMAPPER,
                                    0L, 0L, 0L);
                                
                if(wRtn != 0) {             // error opening Mapper
                    midiOutGetErrorText(wRtn, (LPSTR)szErrorText, 
                                        sizeof(szErrorText));
                    Error(szErrorText);
                    hMapper = 0;
                }

                else {                      // Mapper opened successfully
                    for (i=0; (i<wNumDevices) && (i<MAX_NUM_DEVICES); i++)
                        lpCallbackInstanceData[i]->hMapper = hMapper;

		    DoMenuItemCheck(hWnd, wCommand, TRUE);
                }
            }
            
            break;
            
        case IDM_SAVESETUP:
            /* Save the current location and size of the display window
             * in the MIDIMON.INI file.
             */
            GetWindowRect(hMainWnd, (LPRECT)&rectWindow);
            preferences.iInitialX = rectWindow.left;
            preferences.iInitialY = rectWindow.top;
            preferences.iInitialW = rectWindow.right - rectWindow.left;
            preferences.iInitialH = rectWindow.bottom - rectWindow.top;

            setPreferences((LPPREFERENCES) &preferences);
            break;

        case IDM_STARTSTOP:
            /* Toggle between recording into the display buffer and not
             * recording.  Toggle the menu item between "Start" to "Stop"
             * accordingly.
             */
            hMenu = GetMenu(hWnd);
            if(bRecordingEnabled)
            {
                ModifyMenu(hMenu, IDM_STARTSTOP, MF_BYCOMMAND, IDM_STARTSTOP,
                           "&Start");
                bRecordingEnabled = 0;
            }
            else
            {
                ModifyMenu(hMenu, IDM_STARTSTOP, MF_BYCOMMAND, IDM_STARTSTOP,
                           "&Stop");
                bRecordingEnabled = 1;
            }
            DrawMenuBar(hWnd);
            break;

        case IDM_CLEAR:
            /* Reset the display buffer, recalibrate the scroll bars,
             * and force an update of the display.
             */
            ResetDisplayBuffer(lpDisplayBuffer);
            nNumBufferLines = 0;
            SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);

            InvalidateRect(hWnd, (LPRECT)&rectScrollClip, 0);
            UpdateWindow(hWnd);

            break;
            
        /* Set up filter structure for MIDI channel filtering.
         */
        case IDM_FILTCHAN0:
        case IDM_FILTCHAN1:
        case IDM_FILTCHAN2:
        case IDM_FILTCHAN3:
        case IDM_FILTCHAN4:
        case IDM_FILTCHAN5:
        case IDM_FILTCHAN6:
        case IDM_FILTCHAN7:
        case IDM_FILTCHAN8:
        case IDM_FILTCHAN9:
        case IDM_FILTCHAN10:
        case IDM_FILTCHAN11:
        case IDM_FILTCHAN12:
        case IDM_FILTCHAN13:
        case IDM_FILTCHAN14:
        case IDM_FILTCHAN15:
	    filter.channel[wCommand - IDM_FILTCHAN0] =
		!filter.channel[wCommand - IDM_FILTCHAN0];
	    DoMenuItemCheck(hWnd, wCommand,
		filter.channel[wCommand - IDM_FILTCHAN0]);
            break;
            
        /* Setup filter structure for MIDI event filtering.
         */
        case IDM_NOTEOFF:
            filter.event.noteOff = !filter.event.noteOff;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.noteOff);
            break;
        case IDM_NOTEON:
            filter.event.noteOn = !filter.event.noteOn;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.noteOn);
            break;
        case IDM_POLYAFTERTOUCH:
            filter.event.keyAftertouch = !filter.event.keyAftertouch;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.keyAftertouch);
            break;
        case IDM_CONTROLCHANGE:
            filter.event.controller = !filter.event.controller;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.controller);
            break;
        case IDM_PROGRAMCHANGE:
            filter.event.progChange = !filter.event.progChange;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.progChange);
            break;
        case IDM_CHANNELAFTERTOUCH:
            filter.event.chanAftertouch = !filter.event.chanAftertouch;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.chanAftertouch);
            break;
        case IDM_PITCHBEND:
            filter.event.pitchBend = !filter.event.pitchBend;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.pitchBend);
            break;
        case IDM_CHANNELMODE:
            filter.event.channelMode = !filter.event.channelMode;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.channelMode);
            break;
        case IDM_SYSTEMEXCLUSIVE:
            filter.event.sysEx = !filter.event.sysEx;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.sysEx);
            break;
        case IDM_SYSTEMCOMMON:
            filter.event.sysCommon = !filter.event.sysCommon;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.sysCommon);
            break;
        case IDM_SYSTEMREALTIME:
            filter.event.sysRealTime = !filter.event.sysRealTime;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.sysRealTime);
            break;
        case IDM_ACTIVESENSE:
            filter.event.activeSense = !filter.event.activeSense;
	    DoMenuItemCheck(hWnd, wCommand, filter.event.activeSense);
            break;

        default:
            break;
    }
}

                                                                        //
/* InitFirstInstance - Performs initializaion for the first instance 
 *      of the application.
 *
 * Params:  hInstance - Instance handle.
 *
 * Return:  Returns 1 if there were no errors.  Otherwise, returns 0.
 */
BOOL InitFirstInstance(hInstance)
HANDLE hInstance;
{
    WNDCLASS wc;
    
    /* Define the class of window we want to register.
     */
    wc.lpszClassName    = szAppName;
    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = LoadIcon(hInstance,"Icon");
    wc.lpszMenuName     = "Menu";
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.hInstance        = hInstance;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    
    if(!RegisterClass(&wc))
        return FALSE;
    
    return TRUE;
}

                                                                        //
/* DoMenuItemCheck - Checks and unchecks menu items.
 *
 * Params:  hWnd - Window handle for window associated with menu items.
 *          wMenuItem - The menu ID for the menu item.
 *          newState - The new checked/unchecked state of the menu item.
 *
 * Return:  void
*/
void  DoMenuItemCheck(
  HWND	hWnd,
  WORD	wMenuItem,
  BOOL	newState)
{
    HMENU hMenu;
    
    hMenu = GetMenu(hWnd);
    CheckMenuItem(hMenu, wMenuItem, (newState ? MF_CHECKED: MF_UNCHECKED));
}


/* Error - Beeps and shows an error message.
 *
 * Params:  szMsg - Points to a NULL-terminated string containing the
 *              error message.
 *
 * Return:  Returns the return value from the MessageBox() call.
 *          Since this message box has only a single button, the
 *          return value isn't too meaningful.
 */
int Error(szMsg)
LPSTR szMsg;
{
    MessageBeep(0);
    return MessageBox(hMainWnd, szMsg, szAppName, MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mmcapsex\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//  History:
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define DEBUG_SECTION       "Debug"         // section name for 
#define DEBUG_MODULE_NAME   "MMCAPS"        // key name and prefix for output
#define DEBUG_MAX_LINE_LEN  255             // max line length (bytes)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define DPF      dprintf
#else
    #define DbgEnable(x)        FALSE
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #pragma warning(disable:4002)
    #define DPF()
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mmcapsex\midspids.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  midspids.c
//
//
//  Description:
//
//   !!! WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER !!!
//
//      This code assumes that the receiving buffers are large enough
//      to contain the largest Mid and Pid--so if some of the strings get
//      obnoxiously long, make sure you update the following defines in
//      MMCAPS.H:
//
//          MMCAPS_MAX_STRING_MID_CHARS
//          MMCAPS_MAX_STRING_PID_CHARS
//
//      Also, this code is horribly disgusting. Its purpose is to convert
//      Manufacturer specific Product Id's to human readable text. And
//      since no standard was defined on how to allocate these Id's,
//      all kinds of inconsistent schemes emerged.
//
//      Therefore, I chose the brute force approach. You are more than
//      welcome to clean this up by finding patterns, etc for each
//      manufacturer--I have better things to do.
//
//   !!! WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER !!!
//
//  History:
//       5/13/93
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commdlg.h>
#include <stdarg.h>

#include "appport.h"
#include "mmcaps.h"

#include "debug.h"


//==========================================================================;
//
//  Manufacturer and Product Id Conversion Hacks
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_MICROSOFT
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_MICROSOFT
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]        = TEXT("Microsoft Corporation");
    static PTSTR aszProductId[] =
    {
    NULL,                                            // 0
    TEXT("MIDI Mapper"),                             // 1  MM_MIDI_MAPPER
    TEXT("Wave Mapper"),                             // 2  MM_WAVE_MAPPER
    TEXT("Sound Blaster MIDI output port"),          // 3  MM_SNDBLST_MIDIOUT
    TEXT("Sound Blaster MIDI input port"),           // 4  MM_SNDBLST_MIDIIN
    TEXT("Sound Blaster internal synthesizer"),      // 5  MM_SNDBLST_SYNTH
    TEXT("Sound Blaster waveform output"),           // 6  MM_SNDBLST_WAVEOUT
    TEXT("Sound Blaster waveform input"),            // 7  MM_SNDBLST_WAVEIN
    NULL,                                            // 8
    TEXT("Ad Lib-compatible synthesizer"),           // 9  MM_ADLIB
    TEXT("MPU401-compatible MIDI output port"),      // 10 MM_MPU401_MIDIOUT
    TEXT("MPU401-compatible MIDI input port"),       // 11 MM_MPU401_MIDIIN
    TEXT("Joystick adapter"),                        // 12 MM_PC_JOYSTICK
    TEXT("PC Speaker waveform output"),              // 13 MM_PCSPEAKER_WAVEOUT
    TEXT("MS Audio Board waveform input"),           // 14 MM_MSFT_WSS_WAVEIN
    TEXT("MS Audio Board waveform output"),          // 15 MM_MSFT_WSS_WAVEOUT
    TEXT("MS Audio Board Stereo FM synthesizer"),    // 16 MM_MSFT_WSS_FMSYNTH_STEREO
    TEXT("MS Audio Board Mixer Driver"),             // 17 MM_MSFT_WSS_MIXER
    TEXT("MS OEM Audio Board waveform input"),       // 18 MM_MSFT_WSS_OEM_WAVEIN
    TEXT("MS OEM Audio Board waveform Output"),      // 19 MM_MSFT_WSS_OEM_WAVEOUT
    TEXT("MS OEM Audio Board Stereo FM synthesizer"),// 20 MM_MSFT_WSS_OEM_FMSYNTH_STEREO
    TEXT("MS Audio Board Auxiliary Port"),           // 21 MM_MSFT_WSS_AUX
    TEXT("MS OEM Audio Auxiliary Port"),             // 22 MM_MSFT_WSS_OEM_AUX
    TEXT("MS vanilla driver waveform input"),        // 23 MM_MSFT_GENERIC_WAVEIN
    TEXT("MS vanilla driver waveform output"),       // 24 MM_MSFT_GENERIC_WAVEOUT
    TEXT("MS vanilla driver MIDI input"),            // 25 MM_MSFT_GENERIC_MIDIIN
    TEXT("MS vanilla driver external MIDI output"),  // 26 MM_MSFT_GENERIC_MIDIOUT
    TEXT("MS vanilla driver MIDI synthesizer"),      // 27 MM_MSFT_GENERIC_MIDISYNTH
    TEXT("MS vanilla driver aux (line in)"),         // 28 MM_MSFT_GENERIC_AUX_LINE
    TEXT("MS vanilla driver aux (mic)"),             // 29 MM_MSFT_GENERIC_AUX_MIC
    TEXT("MS vanilla driver aux (CD)"),              // 30 MM_MSFT_GENERIC_AUX_CD
    TEXT("MS OEM Audio Board Mixer Driver"),         // 31 MM_MSFT_WSS_OEM_MIXER
    };

    #define PRODUCTID_MICROSOFT_LAST    MM_MSFT_WSS_OEM_MIXER

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    if ((uPid <= PRODUCTID_MICROSOFT_LAST) && (psz = aszProductId[uPid]))
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    pszPid[0] = '\0';
    return (FALSE);
} // MMCapsMidPid_MM_MICROSOFT()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_CREATIVE
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_CREATIVE
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Creative Labs Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_CREATIVE_SB15_WAVEIN:
        psz = TEXT("SB (r) 1.5 waveform input");
        break;

    case MM_CREATIVE_SB20_WAVEIN:
        psz = TEXT("SB (r) 2.0 waveform input");
        break;

    case MM_CREATIVE_SBPRO_WAVEIN:
        psz = TEXT("SB Pro (r) waveform input");
        break;

    case MM_CREATIVE_SBP16_WAVEIN:
        psz = TEXT("SBP16 (r) waveform input");
        break;

    case MM_CREATIVE_SB15_WAVEOUT:
        psz = TEXT("SB (r) 1.5 waveform output");
        break;

    case MM_CREATIVE_SB20_WAVEOUT:
        psz = TEXT("SB (r) 2.0 waveform output");
        break;

    case MM_CREATIVE_SBPRO_WAVEOUT:
        psz = TEXT("SB Pro (r) waveform output");
        break;

    case MM_CREATIVE_SBP16_WAVEOUT:
        psz = TEXT("SBP16 (r) waveform output");
        break;

    case MM_CREATIVE_MIDIOUT:
        psz = TEXT("SB (r) MIDI output port");
        break;

    case MM_CREATIVE_MIDIIN:
        psz = TEXT("SB (r) MIDI input port");
        break;

    case MM_CREATIVE_FMSYNTH_MONO:
        psz = TEXT("SB (r) FM synthesizer");
        break;

    case MM_CREATIVE_FMSYNTH_STEREO:
        psz = TEXT("SB Pro (r) stereo FM synthesizer");
        break;

    case MM_CREATIVE_AUX_CD:
        psz = TEXT("SB Pro (r) aux (CD)");
        break;

    case MM_CREATIVE_AUX_LINE:
        psz = TEXT("SB Pro (r) aux (line in)");
        break;

    case MM_CREATIVE_AUX_MIC:
        psz = TEXT("SB Pro (r) aux (mic)");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_CREATIVE()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_MEDIAVISION
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_MEDIAVISION
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Media Vision Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_PROAUD_MIDIOUT:
        psz = TEXT("MediaVision MIDI output port");
        break;

    case MM_PROAUD_MIDIIN:
        psz = TEXT("MediaVision MIDI input port");
        break;

    case MM_PROAUD_SYNTH:
        psz = TEXT("MediaVision synthesizer");
        break;

    case MM_PROAUD_WAVEOUT:
        psz = TEXT("MediaVision Waveform output");
        break;

    case MM_PROAUD_WAVEIN:
        psz = TEXT("MediaVision Waveform input");
        break;

    case MM_PROAUD_MIXER:
        psz = TEXT("MediaVision Mixer");
        break;

    case MM_PROAUD_AUX:
        psz = TEXT("MediaVision aux");
        break;

    case MM_MEDIAVISION_THUNDER:
        psz = TEXT("Thunderboard Sound Card");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_MEDIAVISION()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_FUJITSU
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_FUJITSU
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Fujitsu");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_FUJITSU()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_ARTISOFT
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ARTISOFT
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Artisoft Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_ARTISOFT_SBWAVEIN:
        psz = TEXT("Artisoft Sounding Board waveform input");
        break;

    case MM_ARTISOFT_SBWAVEOUT:
        psz = TEXT("Artisoft Sounding Board waveform output");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_ARTISOFT()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_TURTLE_BEACH
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_TURTLE_BEACH
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Turtle Beach");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_TURTLE_BEACH()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_IBM
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_IBM
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("International Bussiness Machines Corp.");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_MMOTION_WAVEAUX:
        psz = TEXT("IBM M-Motion Auxiliary Device");
        break;

    case MM_MMOTION_WAVEOUT:
        psz = TEXT("IBM M-Motion Waveform Output");
        break;

    case MM_MMOTION_WAVEIN:
        psz = TEXT("IBM M-Motion Waveform Input");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_IBM()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_VOCALTEC
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_VOCALTEC
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Vocaltec LTD.");


    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_VOCALTEC_WAVEOUT:
        psz = TEXT("Vocaltec Waveform output port");
        break;

    case MM_VOCALTEC_WAVEIN:
        psz = TEXT("Waveform input port");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_VOCALTEC()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_ROLAND
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ROLAND
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Roland");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_ROLAND_MPU401_MIDIOUT:
        psz = TEXT("MM_ROLAND_MPU401_MIDIOUT");
        break;

    case MM_ROLAND_MPU401_MIDIIN:
        psz = TEXT("MM_ROLAND_MPU401_MIDIIN");
        break;

    case MM_ROLAND_SMPU_MIDIOUTA:
        psz = TEXT("MM_ROLAND_SMPU_MIDIOUTA");
        break;

    case MM_ROLAND_SMPU_MIDIOUTB:
        psz = TEXT("MM_ROLAND_SMPU_MIDIOUTB");
        break;

    case MM_ROLAND_SMPU_MIDIINA:
        psz = TEXT("MM_ROLAND_SMPU_MIDIINA");
        break;

    case MM_ROLAND_SMPU_MIDIINB:
        psz = TEXT("MM_ROLAND_SMPU_MIDIINB");
        break;

    case MM_ROLAND_SC7_MIDIOUT:
        psz = TEXT("MM_ROLAND_SC7_MIDIOUT");
        break;

    case MM_ROLAND_SC7_MIDIIN:
        psz = TEXT("MM_ROLAND_SC7_MIDIIN");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_ROLAND()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_DIGISPEECH
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_DIGISPEECH
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Digispeech, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    //case MM_DIGISP_WAVEOUT:
    case MM_DSP_SOLUTIONS_WAVEOUT:
        psz = TEXT("Digispeech Waveform output port");
        break;

    //case MM_DIGISP_WAVEIN:
    case MM_DSP_SOLUTIONS_WAVEIN:
        psz = TEXT("Digispeech Waveform input port");
        break;
    case MM_DSP_SOLUTIONS_SYNTH:
    case MM_DSP_SOLUTIONS_AUX:
        break;

    #define  MM_DSP_SOLUTIONS_WAVEOUT       1
#define  MM_DSP_SOLUTIONS_WAVEIN            2
#define  MM_DSP_SOLUTIONS_SYNTH             3
#define  MM_DSP_SOLUTIONS_AUX               4

    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_DIGISPEECH()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_NEC
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_NEC
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("NEC");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_NEC()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_ATI
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ATI
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("ATI");

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_ATI()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_WANGLABS
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_WANGLABS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Wang Laboratories, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_WANGLABS_WAVEIN1:
        psz = TEXT("Wave input on Wang models: Exec 4010, 4030 and 3450; PC 251/25C, PC 461/25S and PC 461/33C");
        break;

    case MM_WANGLABS_WAVEOUT1:
        psz = TEXT("Wave output on Wang models: Exec 4010, 4030 and 3450; PC 251/25C, PC 461/25S and PC 461/33C");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_WANGLABS()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_TANDY
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_TANDY
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Tandy Corporation");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_TANDY()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_VOYETRA
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_VOYETRA
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Voyetra");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_VOYETRA()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_ANTEX
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ANTEX
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Antex");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_ANTEX()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_ICL_PS
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ICL_PS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("ICL PS");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_ICL_PS()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_INTEL
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_INTEL
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Intel");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_INTELOPD_WAVEIN:
        psz = TEXT("HID2 WaveAudio Input driver");
        break;

    case MM_INTELOPD_WAVEOUT:
        psz = TEXT("HID2 WaveAudio Output driver");
        break;

    case MM_INTELOPD_AUX:
        psz = TEXT("HID2 Auxiliary driver (required for mixing functions)");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_INTEL()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_GRAVIS
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_GRAVIS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Gravis");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_GRAVIS()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_VAL
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_VAL
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Video Associates Labs");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_VAL()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_INTERACTIVE
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_INTERACTIVE
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("InterActive, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_INTERACTIVE_WAVEIN:
        psz = TEXT("MM_INTERACTIVE_WAVEIN or WAVEOUT ??");
        break;

#if 0
    //  mmreg.h has in and out defined as same value... how quaint.
    case MM_INTERACTIVE_WAVEOUT:
        psz = TEXT("MM_INTERACTIVE_WAVEOUT");
        break;
#endif
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_INTERACTIVE()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_YAMAHA
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_YAMAHA
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Yamaha Corp. of America");


    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_YAMAHA_GSS_SYNTH:
        psz = TEXT("Yamaha Gold Sound Standard FM sythesis driver");
        break;

    case MM_YAMAHA_GSS_WAVEOUT:
        psz = TEXT("Yamaha Gold Sound Standard wave output driver");
        break;

    case MM_YAMAHA_GSS_WAVEIN:
        psz = TEXT("Yamaha Gold Sound Standard wave input driver");
        break;

    case MM_YAMAHA_GSS_MIDIOUT:
        psz = TEXT("Yamaha Gold Sound Standard midi output driver");
        break;

    case MM_YAMAHA_GSS_MIDIIN:
        psz = TEXT("Yamaha Gold Sound Standard midi input driver");
        break;

    case MM_YAMAHA_GSS_AUX:
        psz = TEXT("Yamaha Gold Sound Standard auxillary driver for mixer functions");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_YAMAHA()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_EVEREX
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_EVEREX
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Everex Systems, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_EVEREX_CARRIER:
        psz = TEXT("Everex Carrier SL/25 Notebook");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_EVEREX()


BOOL FNLOCAL MMCapsMidPid_MM_ECHO
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Echo Speech Corporation");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_ECHO_SYNTH:
        psz = TEXT("Echo EuSythesis driver");
        break;

    case MM_ECHO_WAVEOUT:
        psz = TEXT("Wave output driver");
        break;

    case MM_ECHO_WAVEIN:
        psz = TEXT("Wave input driver");
        break;

    case MM_ECHO_MIDIOUT:
        psz = TEXT("MIDI output driver");
        break;

    case MM_ECHO_MIDIIN:
        psz = TEXT("MIDI input driver");
        break;

    case MM_ECHO_AUX:
        psz = TEXT("auxillary driver for mixer functions");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
}


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_SIERRA
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_SIERRA
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Sierra Semiconductor");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_SIERRA_ARIA_MIDIOUT:
        psz = TEXT("Sierra Aria MIDI output");
        break;

    case MM_SIERRA_ARIA_MIDIIN:
        psz = TEXT("Sierra Aria MIDI input");
        break;

    case MM_SIERRA_ARIA_SYNTH:
        psz = TEXT("Sierra Aria Synthesizer");
        break;

    case MM_SIERRA_ARIA_WAVEOUT:
        psz = TEXT("Sierra Aria Waveform output");
        break;

    case MM_SIERRA_ARIA_WAVEIN:
        psz = TEXT("Sierra Aria Waveform input");
        break;

    case MM_SIERRA_ARIA_AUX:
        psz = TEXT("Sierra Aria Auxiliary device");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_SIERRA()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_CAT
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_CAT
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Computer Aided Technologies");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_CAT()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_APPS
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_APPS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("APPS Software International");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_APPS()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_DSP_GROUP
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_DSP_GROUP
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("DSP Group, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_DSP_GROUP_TRUESPEECH:
        psz = TEXT("High quality 9.54:1 Speech Compression Vocoder");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_DSP_GROUP()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_MELABS
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_MELABS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("microEngineering Labs");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_MELABS_MIDI2GO:
        psz = TEXT("parallel port MIDI interface");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_MELABS()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_COMPUTER_FRIENDS
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_COMPUTER_FRIENDS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Computer Friends, Inc");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_COMPUTER_FRIENDS()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_ESS
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ESS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("ESS Technology");

    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_ESS_AMWAVEOUT:
        psz = TEXT("ESS Audio Magician Waveform Output Port");
        break;

    case MM_ESS_AMWAVEIN:
        psz = TEXT("ESS Audio Magician Waveform Input Port");
        break;

    case MM_ESS_AMAUX:
        psz = TEXT("ESS Audio Magician Auxiliary Port");
        break;

    case MM_ESS_AMSYNTH:
        psz = TEXT("ESS Audio Magician Internal Music Synthesizer Port");
        break;

    case MM_ESS_AMMIDIOUT:
        psz = TEXT("ESS Audio Magician MIDI Output Port");
        break;

    case MM_ESS_AMMIDIIN:
        psz = TEXT("ESS Audio Magician MIDI Input Port");
        break;
    }

    if (NULL != psz)
    {
    lstrcat(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_ESS()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_AUDIOFILE
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_AUDIOFILE
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Audio, Inc.");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_AUDIOFILE()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_MOTOROLA
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_MOTOROLA
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Motorola, Inc.");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_MOTOROLA()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_CANOPUS
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_CANOPUS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Canopus Co., Ltd.");


    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_CANOPUS()

//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidPid_MM_UNMAPPED
//
//  Description:
//
//
//  Arguments:
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_UNMAPPED
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Unmapped Mid");
    PTSTR       psz;

    if (NULL != pszMid)
    lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
    return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
    case MM_PID_UNMAPPED:
        psz = TEXT("Unmapped Pid");
        break;
    }

    if (NULL != psz)
    {
    lstrcpy(pszPid, psz);
    return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_UNMAPPED()

//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL MMCapsMidAndPid
//
//  Description:
//
//
//  Arguments:
//      UINT uMid:
//
//      PTSTR pszMid:
//
//      UINT uPid:
//
//      PTSTR pszPid:
//
//  Return (BOOL):
//
//  History:
//      05/13/93
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL MMCapsMidAndPid
(
    UINT            uMid,
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR    szUnknown[]     = TEXT("Unknown");
    static TCHAR    szFormatId[]    = TEXT("[%u], %s");

    TCHAR       achMid[MMCAPS_MAX_STRING_MID_CHARS];
    TCHAR       achPid[MMCAPS_MAX_STRING_PID_CHARS];
    BOOL        f;

    switch (uMid)
    {
    case MM_MICROSOFT:
        f = MMCapsMidPid_MM_MICROSOFT(achMid, uPid, achPid);
        break;

    case MM_CREATIVE:
        f = MMCapsMidPid_MM_CREATIVE(achMid, uPid, achPid);
        break;

    case MM_MEDIAVISION:
        f = MMCapsMidPid_MM_MEDIAVISION(achMid, uPid, achPid);
        break;

    case MM_FUJITSU:
        f = MMCapsMidPid_MM_FUJITSU(achMid, uPid, achPid);
        break;

    case MM_ARTISOFT:
        f = MMCapsMidPid_MM_ARTISOFT(achMid, uPid, achPid);
        break;

    case MM_TURTLE_BEACH:
        f = MMCapsMidPid_MM_TURTLE_BEACH(achMid, uPid, achPid);
        break;

    case MM_IBM:
        f = MMCapsMidPid_MM_IBM(achMid, uPid, achPid);
        break;

    case MM_VOCALTEC:
        f = MMCapsMidPid_MM_VOCALTEC(achMid, uPid, achPid);
        break;

    case MM_ROLAND:
        f = MMCapsMidPid_MM_ROLAND(achMid, uPid, achPid);
        break;

    //case MM_DIGISPEECH:
    case MM_DSP_SOLUTIONS:
        f = MMCapsMidPid_MM_DIGISPEECH(achMid, uPid, achPid);
        break;

    case MM_NEC:
        f = MMCapsMidPid_MM_NEC(achMid, uPid, achPid);
        break;

    case MM_ATI:
        f = MMCapsMidPid_MM_ATI(achMid, uPid, achPid);
        break;

    case MM_WANGLABS:
        f = MMCapsMidPid_MM_WANGLABS(achMid, uPid, achPid);
        break;

    case MM_TANDY:
        f = MMCapsMidPid_MM_TANDY(achMid, uPid, achPid);
        break;

    case MM_VOYETRA:
        f = MMCapsMidPid_MM_VOYETRA(achMid, uPid, achPid);
        break;

    case MM_ANTEX:
        f = MMCapsMidPid_MM_ANTEX(achMid, uPid, achPid);
        break;

    case MM_ICL_PS:
        f = MMCapsMidPid_MM_ICL_PS(achMid, uPid, achPid);
        break;

    case MM_INTEL:
        f = MMCapsMidPid_MM_INTEL(achMid, uPid, achPid);
        break;

    case MM_GRAVIS:
        f = MMCapsMidPid_MM_GRAVIS(achMid, uPid, achPid);
        break;

    case MM_VAL:
        f = MMCapsMidPid_MM_VAL(achMid, uPid, achPid);
        break;

    case MM_INTERACTIVE:
        f = MMCapsMidPid_MM_INTERACTIVE(achMid, uPid, achPid);
        break;

    case MM_YAMAHA:
        f = MMCapsMidPid_MM_YAMAHA(achMid, uPid, achPid);
        break;

    case MM_EVEREX:
        f = MMCapsMidPid_MM_EVEREX(achMid, uPid, achPid);
        break;

    case MM_ECHO:
        f = MMCapsMidPid_MM_ECHO(achMid, uPid, achPid);
        break;

    case MM_SIERRA:
        f = MMCapsMidPid_MM_SIERRA(achMid, uPid, achPid);
        break;

    case MM_CAT:
        f = MMCapsMidPid_MM_CAT(achMid, uPid, achPid);
        break;

    case MM_APPS:
        f = MMCapsMidPid_MM_APPS(achMid, uPid, achPid);
        break;

    case MM_DSP_GROUP:
        f = MMCapsMidPid_MM_DSP_GROUP(achMid, uPid, achPid);
        break;

    case MM_MELABS:
        f = MMCapsMidPid_MM_MELABS(achMid, uPid, achPid);
        break;

    case MM_COMPUTER_FRIENDS:
        f = MMCapsMidPid_MM_COMPUTER_FRIENDS(achMid, uPid, achPid);
        break;

    case MM_ESS:
        f = MMCapsMidPid_MM_ESS(achMid, uPid, achPid);
        break;

    case MM_AUDIOFILE:
        f = MMCapsMidPid_MM_AUDIOFILE(achMid, uPid, achPid);
        break;

    case MM_MOTOROLA:
        f = MMCapsMidPid_MM_MOTOROLA(achMid, uPid, achPid);
        break;

    case MM_CANOPUS:
        f = MMCapsMidPid_MM_CANOPUS(achMid, uPid, achPid);
        break;

    case MM_UNMAPPED:
        f = MMCapsMidPid_MM_UNMAPPED(achMid, uPid, achPid);
        break;

    default:
        lstrcpy(achMid, szUnknown);
        break;
    }

    //
    //
    //
    if (NULL != pszMid)
    {
    wsprintf(pszMid, szFormatId, uMid, (LPTSTR)achMid);
    }

    if (NULL != pszPid)
    {
    if (f)
        wsprintf(pszPid, szFormatId, uPid, (LPTSTR)achPid);
    else
        wsprintf(pszPid, szFormatId, uPid, (LPTSTR)szUnknown);
    }


    //
    //
    //
    return (f);
} // MMCapsMidAndPid()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mmcapsex\mmcaps.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  mmcaps.c
//
//  Description:
//
//
//  History:
//      11/ 8/92
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commdlg.h>
#include <stdarg.h>

#include "appport.h"
#include "mmcaps.h"

#include "debug.h"


//
//  globals, no less
//
HINSTANCE   ghinst;
TCHAR       gszAppSection[]     = TEXT("MMCaps");
TCHAR       gszNull[]           = TEXT("");

TCHAR       gszAppName[APP_MAX_APP_NAME_CHARS];


//
//
//
PZYZTABBEDLISTBOX   gptlbDrivers;

TCHAR       gszUnknown[]        = TEXT("Unknown");
TCHAR       gszNotSpecified[]   = TEXT("Not Specified");

UINT        guDriverType        = MMCAPS_DRIVERTYPE_LOWLEVEL;



//==========================================================================;
//
//  Application helper functions
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL AppProfileWriteBytes
//  
//  Description:
//      This function writes a raw structure of bytes to the application's
//      ini section that can later be retrieved using AppProfileReadBytes.
//      This gives an application the ability to write any structure to
//      the ini file and restore it later--very useful.
//
//      NOTE! Starting with Windows for Workgroups 3.1 there are two new
//      profile functions that provide the same functionality of this
//      function. Specifically, these functions are GetPrivateProfileStruct
//      and WritePrivateProfileStruct. These new functions are provided
//      by the Common Controls DLL. The prototypes are as follows:
//
//      BOOL GetPrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      BOOL WritePrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      If you are building an application that is for Window for Workgroups
//      or newer versions of Windows, you will probably want to use the
//      above functions.
//
//  Arguments:
//      PCTSTR pszKey: Pointer to key name for the stored data.
//  
//      LPBYTE pbStruct: Pointer to the data to be saved.
//  
//      UINT cbStruct: Count in bytes of the data to store.
//  
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if it fails.
//  
//  History:
//       3/10/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppProfileWriteBytes
(
    PCTSTR          pszKey,
    LPBYTE          pbStruct,
    UINT            cbStruct
)
{
    static TCHAR achNibbleToChar[] =
    {
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
    };
    #define     NIBBLE2CHAR(x)      (achNibbleToChar[x])
    
    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    LPTSTR      psz;
    LPTSTR      pch;
    UINT        cchTemp;
    BOOL        fAllocated;
    BOOL        fReturn;
    BYTE        b;
    BYTE        bChecksum;

    //
    //  if pbStruct is NULL, then erase the key from the ini file, otherwise
    //  format the raw bytes into a hex string and write that out...
    //
    fAllocated = FALSE;
    psz        = NULL;
    if (NULL != pbStruct)
    {
	//
	//  check if the quick buffer can be used for formatting the output
	//  text--if it cannot, then alloc space for it. note that space
	//  must be available for an ending checksum byte (2 bytes for high
	//  and low nibble) as well as a null terminator.
	//
	psz     = (LPTSTR)ach;
	cchTemp = cbStruct * 2 + 3;
	if (cchTemp > SIZEOF(ach))
	{
	    psz = GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR));
	    if (NULL == psz)
		return (FALSE);

	    fAllocated = TRUE;
	}
  
	//
	//  step through all bytes in the structure and convert it to
	//  a string of hex numbers...
	//
	bChecksum = 0;
	for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
	{
	    //
	    //  grab the next byte and add into checksum...
	    //
	    bChecksum += (b = *pbStruct);
      
	    *pch++ = NIBBLE2CHAR((b >> (BYTE)4) & (BYTE)0x0F);
	    *pch++ = NIBBLE2CHAR(b & (BYTE)0x0F);
	}

	//
	//  add the checksum byte to the end and null terminate the hex
	//  dumped string...
	//
	*pch++ = NIBBLE2CHAR((bChecksum >> (BYTE)4) & (BYTE)0x0F);
	*pch++ = NIBBLE2CHAR(bChecksum & (BYTE)0x0F);
	*pch   = '\0';
    }

    //
    //  write the string of hex bytes out to the ini file...
    //
    fReturn = WriteProfileString(gszAppSection, pszKey, psz);

    //
    //  free the temporary buffer if one was allocated (lots of bytes!)
    //
    if (fAllocated)
	GlobalFreePtr(psz);
  
    return (fReturn);
} // AppProfileWriteBytes


//--------------------------------------------------------------------------;
//  
//  BOOL AppProfileReadBytes
//  
//  Description:
//      This function reads a previously stored structure of bytes from
//      the application's ini file. This data must have been written with
//      the AppProfileWriteBytes function--it is checksumed to keep bad
//      data from blowing up the application.
//  
//      NOTE! Starting with Windows for Workgroups 3.1 there are two new
//      profile functions that provide the same functionality of this
//      function. Specifically, these functions are GetPrivateProfileStruct
//      and WritePrivateProfileStruct. These new functions are provided
//      by the Common Controls DLL. The prototypes are as follows:
//
//      BOOL GetPrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      BOOL WritePrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      If you are building an application that is for Window for Workgroups
//      or newer versions of Windows, you will probably want to use the
//      above functions.
//  
//  Arguments:
//      PCTSTR pszKey: Pointer to key that contains the data.
//  
//      LPBYTE pbStruct: Pointer to buffer to receive the data.
//  
//      UINT cbStruct: Number of bytes expected.
//  
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if the function fails (bad checksum, missing key, etc).
//  
//  History:
//       3/10/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppProfileReadBytes
(
    PCTSTR          pszKey,
    LPBYTE          pbStruct,
    UINT            cbStruct
)
{
    //
    //  note that the following works for both upper and lower case, and
    //  will return valid values for garbage chars
    //
    #define CHAR2NIBBLE(ch) (BYTE)( ((ch) >= '0' && (ch) <= '9') ?  \
				(BYTE)((ch) - '0') :                \
				((BYTE)(10 + (ch) - 'A') & (BYTE)0x0F) )

    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    LPTSTR      psz;
    LPTSTR      pch;
    UINT        cchTemp;
    UINT        u;
    BOOL        fAllocated;
    BOOL        fReturn;
    BYTE        b;
    BYTE        bChecksum;
    TCHAR       ch;

    //
    //  add one the the number of bytes needed to accomodate the checksum
    //  byte placed at the end by AppProfileWriteBytes...
    //
    cbStruct++;

    //
    //  check if the quick buffer can be used for retrieving the input
    //  text--if it cannot, then alloc space for it. note that there must
    //  be space available for the null terminator (the +1 below).
    //
    fAllocated = FALSE;
    psz        = (LPTSTR)ach;
    cchTemp    = cbStruct * 2 + 1;
    if (cchTemp > SIZEOF(ach))
    {
	psz = GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR));
	if (NULL == psz)
	    return (FALSE);

	fAllocated = TRUE;
    }

    //
    //  read the hex string... if it is not the correct length, then assume
    //  error and return.
    //
    fReturn = FALSE;
    u = (UINT)GetProfileString(gszAppSection, pszKey, gszNull, psz, cchTemp);
    if ((cbStruct * 2) == u)
    {
	bChecksum = 0;
	for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
	{
	    ch = *pch++;
	    b  = CHAR2NIBBLE(ch) << (BYTE)4;
	    ch = *pch++;
	    b |= CHAR2NIBBLE(ch);

	    //
	    //  if this is not the final byte (the checksum byte), then 
	    //  store it and accumulate checksum..
	    //
	    if (cbStruct != 1)
		bChecksum += (*pbStruct = b);
	}

	//
	//  check the last byte read against the checksum that we calculated
	//  if they are not equal then return error...
	//
	fReturn = (bChecksum == b);
    }


    //
    //  free the temporary buffer if one was allocated (lots of bytes!)
    //
    if (fAllocated)
	GlobalFreePtr(psz);
  
    return (fReturn);
} // AppProfileReadBytes


//--------------------------------------------------------------------------;
//
//  int AppMsgBox
//
//  Description:
//      This function displays a message for the application in a standard
//      message box.
//
//      Note that this function takes any valid argument list that can
//      be passed to wsprintf. Because of this, the application must
//      remember to cast near string pointers to FAR when built for Win 16.
//      You will get a nice GP fault if you do not cast them correctly.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for message box holding the
//      message.
//
//      UINT fuStyle: Style flags for MessageBox().
//
//      PCTSTR pszFormat: Format string used for wvsprintf().
//
//  Return (int):
//      The return value is the result of MessageBox() function.
//
//  History:
//       2/13/93
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppMsgBox
(
    HWND            hwnd,
    UINT            fuStyle,
    PCTSTR          pszFormat,
    ...
)
{
    va_list     va;
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    //
    //  format and display the message..
    //
    va_start(va, pszFormat);
    wvsprintf(ach, pszFormat, va);
    va_end(va);

    n = MessageBox(hwnd, ach, gszAppName, fuStyle);

    return (n);
} // AppMsgBox()


//--------------------------------------------------------------------------;
//
//  int AppMsgBoxId
//
//  Description:
//      This function displays a message for the application. The message
//      text is retrieved from the string resource table using LoadString.
//
//      Note that this function takes any valid argument list that can
//      be passed to wsprintf. Because of this, the application must
//      remember to cast near string pointers to FAR when built for Win 16.
//      You will get a nice GP fault if you do not cast them correctly.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for message box holding the
//      message.
//
//      UINT fuStyle: Style flags for MessageBox().
//
//      UINT uIdsFormat: String resource id to be loaded with LoadString()
//      and used a the format string for wvsprintf().
//
//  Return (int):
//      The return value is the result of MessageBox() if the string
//      resource specified by uIdsFormat is valid. The return value is zero
//      if the string resource failed to load.
//
//  History:
//       2/13/93
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppMsgBoxId
(
    HWND            hwnd,
    UINT            fuStyle,
    UINT            uIdsFormat,
    ...
)
{
    va_list     va;
    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS];
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat));
    if (0 != n)
    {
	//
	//  format and display the message..
	//
	va_start(va, uIdsFormat);
	wvsprintf(ach, szFormat, va);
	va_end(va);

	n = MessageBox(hwnd, ach, gszAppName, fuStyle);
    }

    return (n);
} // AppMsgBoxId()


//--------------------------------------------------------------------------;
//
//  void AppHourGlass
//
//  Description:
//      This function changes the cursor to that of the hour glass or
//      back to the previous cursor.
//
//      This function can be called recursively.
//
//  Arguments:
//      BOOL fHourGlass: TRUE if we need the hour glass.  FALSE if we need
//      the arrow back.
//
//  Return (void):
//      On return, the cursor will be what was requested.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

void FNGLOBAL AppHourGlass
(
    BOOL            fHourGlass
)
{
    static HCURSOR  hcur;
    static UINT     uWaiting = 0;

    if (fHourGlass)
    {
	if (!uWaiting)
	{
	    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
	    ShowCursor(TRUE);
	}

	uWaiting++;
    }
    else
    {
	--uWaiting;

	if (!uWaiting)
	{
	    ShowCursor(FALSE);
	    SetCursor(hcur);
	}
    }
} // AppHourGlass()


//--------------------------------------------------------------------------;
//
//  int AppDialogBox
//
//  Description:
//      This function is used to display a dialog modal box.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for new dialog.
//
//      LPCSTR pszDlg: Dialog template to use.
//
//      DLGPROC pfnDlg: Pointer to dialog procedure.
//
//      LPARAM lParam: Any lParam to be passed as lParam for WM_INITDIALOG.
//
//  Return (int):
//      The return value is the nResult from EndDialog.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

int FNGLOBAL AppDialogBox
(
    HWND            hwnd,
    LPCTSTR         pszDlg,
    DLGPROC         pfnDlg,
    LPARAM          lParam
)
{
    int     nResult;

    //
    //  !!! NT doesn't need this--neither does Win 3.1 with C7/C8 !!!
    //
    //
    nResult = 0;
    pfnDlg  = (DLGPROC)MakeProcInstance((FARPROC)pfnDlg, ghinst);
    if (NULL != pfnDlg)
    {
	nResult = DialogBoxParam(ghinst, pszDlg, hwnd, pfnDlg, lParam);
	FreeProcInstance((FARPROC)pfnDlg);
    }

    return (nResult);
} // AppDialogBox()


//--------------------------------------------------------------------------;
//
//  int AppSetWindowText
//
//  Description:
//      This function formats a string and sets the specified window text
//      to the result.
//
//  Arguments:
//      HWND hwnd: Handle to window to receive the new text.
//
//      PCTSTR pszFormat: Pointer to any valid format for wsprintf.
//
//  Return (int):
//      The return value is the number of bytes that the resulting window
//      text was.
//
//  History:
//       2/ 7/93
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppSetWindowText
(
    HWND            hwnd,
    PCTSTR          pszFormat,
    ...
)
{
    va_list     va;
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    //
    //  format and display the string in the window...
    //
    va_start(va, pszFormat);
    n = wvsprintf(ach, pszFormat, va);
    va_end(va);

    SetWindowText(hwnd, ach);

    return (n);
} // AppSetWindowText()


//--------------------------------------------------------------------------;
//
//  int AppSetWindowTextId
//
//  Description:
//      This function formats a string and sets the specified window text
//      to the result. The format string is extracted from the string
//      table using LoadString() on the uIdsFormat argument.
//
//  Arguments:
//      HWND hwnd: Handle to window to receive the new text.
//
//      UINT uIdsFormat: String resource id to be loaded with LoadString()
//      and used a the format string for wvsprintf().
//
//  Return (int):
//      The return value is the number of bytes that the resulting window
//      text was. This value is zero if the LoadString() function fails
//      for the uIdsFormat argument.
//
//  History:
//       2/ 7/93
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppSetWindowTextId
(
    HWND            hwnd,
    UINT            uIdsFormat,
    ...
)
{
    va_list     va;
    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS];
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat));
    if (0 != n)
    {
	//
	//  format and display the string in the window...
	//
	va_start(va, uIdsFormat);
	n = wvsprintf(ach, szFormat, va);
	va_end(va);

	SetWindowText(hwnd, ach);
    }

    return (n);
} // AppSetWindowTextId()


//--------------------------------------------------------------------------;
//  
//  int AppMEditPrintF
//  
//  Description:
//      This function is used to print formatted text into a Multiline
//      Edit Control as if it were a standard console display. This is
//      a very easy way to display small amounts of text information
//      that can be scrolled and copied to the clip-board.
//  
//  Arguments:
//      HWND hedit: Handle to a Multiline Edit control.
//  
//      PCTSTR pszFormat: Pointer to any valid format for wsprintf. If
//      this argument is NULL, then the Multiline Edit Control is cleared
//      of all text.
//  
//  Return (int):
//      Returns the number of characters written into the edit control.
//
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

int FNCGLOBAL AppMEditPrintF
(
    HWND            hedit,
    PCTSTR          pszFormat,
    ...
)
{
    va_list     va;
    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    int         n;


    //
    //  if the pszFormat argument is NULL, then just clear all text in
    //  the edit control..
    //
    if (NULL == pszFormat)
    {
	SetWindowText(hedit, gszNull);
	return (0);
    }


    //
    //  format and display the string in the window...
    //
    va_start(va, pszFormat);
    n = wvsprintf(ach, pszFormat, va);
    va_end(va);

    Edit_SetSel(hedit, (WPARAM)-1, (LPARAM)-1);
    Edit_ReplaceSel(hedit, ach);

    return (n);
} // AppMEditPrintF()


//--------------------------------------------------------------------------;
//
//  DWORD AppGetWindowsVersion
//
//  Description:
//      This function returns the version of Windows that the application
//      is running on plus some platform information.
//
//  Arguments:
//      PTSTR pach: Options pointer to buffer to receive text string of
//      the Windows version and platform.
//
//  Return (LRESULT):
//      The return value will be the version and platform information of
//      the current operating system in the following format:
//
//      0xPPPPMMRR where:
//
//      MM      :   major version of Windows
//      RR      :   minor version (revision) of Windows
//      PPPP    :   the platform the application is running on which
//                  will be one of the following:
//
//                  #ifdef WIN32
//                      the HIWORD() is RESERVED except for the high bit:
//                          high bit is 0 = Windows NT
//                          high bit is 1 = Win32s/Windows 3.1
//                  #else
//                      0xMMRR = Major and Minor version of [MS-]DOS
//                      GetWinFlags() & 0x8000 = Windows on OS/2 (WLO)
//                      GetWinFlags() & 0x4000 = Windows on Windows NT (WOW)
//                  #endif
//
//  History:
//       2/13/93
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppGetWindowsVersion
(
    PTSTR           pszEnvironment,
    PTSTR           pszPlatform
)
{

    BYTE    bVerWinMajor;
    BYTE    bVerWinMinor;
    UINT    uVerEnv;
    DWORD   dw;
    LRESULT lr;

    dw = GetVersion();

    //
    //  massage the version information into something intelligent
    //
    //
    bVerWinMajor = LOBYTE(LOWORD(dw));
    bVerWinMinor = HIBYTE(LOWORD(dw));
    uVerEnv      = HIWORD(dw);
    lr = MAKELPARAM(((UINT)bVerWinMajor << 8) | bVerWinMinor, uVerEnv);

    //
    //  if caller wants the environment string version...
    //
    if (NULL != pszEnvironment)
    {
    //
    //
    //
#ifdef WIN32
{
    static TCHAR    szFormatVersion[]   = TEXT("%s Version %u.%.2u");
    static TCHAR    szEnvWinNT[]        = TEXT("Windows NT");
    static TCHAR    szEnvWin32s[]       = TEXT("Win32s");

    wsprintf(pszEnvironment, szFormatVersion,
	     (LPSTR)((0x8000 & uVerEnv) ? szEnvWin32s : szEnvWinNT),
	     bVerWinMajor, bVerWinMinor);
}
#else
{
#ifndef WF_WINNT
    #define WF_CPUR4000         0x0100
    #define WF_CPUALPHA21064    0x0200
    #define WF_WINNT            0x4000
    #define WF_WLO              0x8000
#endif

    static TCHAR    szFormatSubSys[]= TEXT("Windows Version %u.%.2u (%s%s)\n%s Subsystem, DOS Version %u.%.2u");
    static TCHAR    szFormatDOS[]   = TEXT("Windows Version %u.%.2u (%s%s)\nDOS Version %u.%.2u");
    static TCHAR    szSubSysWLO[]   = TEXT("WLO");
    static TCHAR    szSubSysWOW[]   = TEXT("WOW");
    static TCHAR    szModeEnhanced[]= TEXT("Enhanced");
    static TCHAR    szModeStandard[]= TEXT("Standard");
    static TCHAR    szEnvPaging[]   = TEXT(", Paging");

    DWORD   dwWinFlags;
    PTSTR   pszMode;

    BYTE    bVerEnvMajor    = HIBYTE(LOWORD(uVerEnv));
    BYTE    bVerEnvMinor    = LOBYTE(LOWORD(uVerEnv));

    dwWinFlags = GetWinFlags();

    pszMode = (dwWinFlags & WF_ENHANCED) ? szModeEnhanced : szModeStandard;
    if (dwWinFlags & (WF_WLO | WF_WINNT))
    {
	wsprintf(pszEnvironment, szFormatSubSys, bVerWinMajor, bVerWinMinor,
		 (LPSTR)pszMode,
		 (LPSTR)((dwWinFlags & WF_PAGING) ? szEnvPaging : gszNull),
		 (LPSTR)((dwWinFlags & WF_WINNT) ? szSubSysWOW : szSubSysWLO),
		 bVerEnvMajor, bVerEnvMinor);
    }
    else
    {
	wsprintf(pszEnvironment, szFormatDOS, bVerWinMajor, bVerWinMinor,
		 (LPSTR)pszMode,
		 (LPSTR)((dwWinFlags & WF_PAGING) ? szEnvPaging : gszNull),
		 bVerEnvMajor, bVerEnvMinor);
    }
}
#endif
    }

    //
    //  if caller wants the platform string version...
    //
    if (NULL != pszPlatform)
    {
#ifdef WIN32
{
    static TCHAR    szFormatPlatform[]  = TEXT("%s%u, %u Processor(s)");
    static TCHAR    szProcessorIntel[]  = TEXT("Intel ");
    static TCHAR    szProcessorMIPS[]   = TEXT("MIPS R");
    static TCHAR    szProcessorAlpha[]  = TEXT("DEC Alpha ");
    static TCHAR    szProcessorDunno[]  = TEXT("Dunno zYz");

    SYSTEM_INFO sysinfo;
    PTSTR       pszProcessor;

    //
    //  this is absolutely silly. one would think that the dwOemId member
    //  would provide something useful like the processor class... but
    //  no, it doesn't--it is always 0.
    //
    GetSystemInfo(&sysinfo);
    switch (sysinfo.dwProcessorType)
    {
	case PROCESSOR_INTEL_386:
	case PROCESSOR_INTEL_486:
	    pszProcessor = szProcessorIntel;
	    break;

	case PROCESSOR_MIPS_R4000:
	    pszProcessor = szProcessorMIPS;
	    break;

	case PROCESSOR_ALPHA_21064:
	    pszProcessor = szProcessorAlpha;
	    break;

	default:
	    pszProcessor = szProcessorDunno;
	    break;
    }

    //
    //
    //
    wsprintf(pszPlatform, szFormatPlatform, (LPSTR)pszProcessor,
	     sysinfo.dwProcessorType, sysinfo.dwNumberOfProcessors);
}
#else
{
    static TCHAR    szPlat286[]         = TEXT("80286");
    static TCHAR    szPlat386[]         = TEXT("80386");
    static TCHAR    szPlat486[]         = TEXT("i486");
    static TCHAR    szPlatR4000[]       = TEXT("MIPS R4000, Emulation: ");
    static TCHAR    szPlatAlpha21064[]  = TEXT("Alpha 21064, Emulation: ");
    static TCHAR    szPlat80x87[]       = TEXT(", 80x87");

    DWORD   dwWinFlags;

    dwWinFlags = GetWinFlags();
    pszPlatform[0] = '\0';

    if (dwWinFlags & (WF_WLO | WF_WINNT))
    {
	if (dwWinFlags & WF_CPUR4000)
	    lstrcpy(pszPlatform, szPlatR4000);
	else if (dwWinFlags & WF_CPUALPHA21064)
	    lstrcpy(pszPlatform, szPlatAlpha21064);
    }

    if (dwWinFlags & WF_CPU286)
	lstrcat(pszPlatform, szPlat286);
    else if (dwWinFlags & WF_CPU386)
	lstrcat(pszPlatform, szPlat386);
    else if (dwWinFlags & WF_CPU486)
	lstrcat(pszPlatform, szPlat486);

    if (dwWinFlags & WF_80x87)
	lstrcat(pszPlatform, szPlat80x87);
}
#endif
    }

    //
    //  return the result
    //
    return (lr);
} // AppGetWindowsVersion()


//--------------------------------------------------------------------------;
//
//  HFONT AppChooseFont
//
//  Description:
//      This function is a wrapper for the ChooseFont() common dialog.
//      The purpose of this function is to let the user choose a font that
//      looks good to them--regardless of how stupid it really looks.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for chooser dialog.
//
//      HFONT hfont: Handle to current font (default for chooser dialog).
//
//      PLOGFONT plf: Pointer to optional LOGFONT structure to receive a
//      copy of the LOGFONT information for the newly chosen font.
//
//  Return (HFONT):
//      The return value is the newly chosen font. If no new font was chosen
//      then the return value is NULL.
//
//  History:
//       2/ 7/93
//
//--------------------------------------------------------------------------;

HFONT FNGLOBAL AppChooseFont
(
    HWND            hwnd,
    HFONT           hfont,
    PLOGFONT        plf
)
{
    LOGFONT     lf;
    CHOOSEFONT  cf;
    BOOL        f;
    HFONT       hfontNew;

    //
    //  get the font info for the current font...
    //
    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&lf);

    //
    //  fill in the choosefont structure
    //
    cf.lStructSize  = sizeof(CHOOSEFONT);
    cf.hwndOwner    = hwnd;
    cf.hDC          = NULL;
    cf.Flags        = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT;
    cf.lCustData    = 0;
    cf.lpfnHook     = NULL;
    cf.hInstance    = NULL;
    cf.nFontType    = SCREEN_FONTTYPE;
    cf.lpLogFont    = (LPLOGFONT)&lf;

    //
    //  splash a dialog into the user's face..
    //
    hfontNew = NULL;
    f = ChooseFont(&cf);
    if (f)
    {
	//
	//  create the new font..
	//
	hfontNew = CreateFontIndirect(&lf);
	if (NULL == hfontNew)
	    return (NULL);

	//
	//  copy the logfont structure if caller wants it
	//
	if (NULL != plf)
	    *plf = lf;
    }

    //
    //  return the new font (if one was chosen)
    //
    return (hfontNew);
} // AppChooseFont()


//==========================================================================;
//
//  Misc rarely used application dialogs and stuff...
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL AboutDlgProc
//
//  Description:
//      This dialog procedure is used for the ubiquitous about box.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//  History:
//       1/ 2/93
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AboutDlgProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    HWND    hwndT;
    PTSTR   pach;
    UINT    u;

    switch (uMsg)
    {
	case WM_INITDIALOG:
	    //
	    //  display some OS version information
	    //
	    //
	    pach = (PTSTR)LocalAlloc(LPTR, APP_MAX_STRING_RC_BYTES);
	    if (NULL == pach)
		return (TRUE);

	    AppGetWindowsVersion(pach, NULL);
	    hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_OS);
	    SetWindowText(hwndT, pach);

	    AppGetWindowsVersion(NULL, pach);
	    hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_PLATFORM);
	    SetWindowText(hwndT, pach);

	    wsprintf(pach, "MMREG.H V%u.%.02u",
		     (_INC_MMREG / 100), (_INC_MMREG % 100));
	    hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_MMSYSTEM);
	    SetWindowText(hwndT, pach);

	    LocalFree((HLOCAL)pach);

	    //
	    //  return nonzero to set the input focus to the control
	    //  identified by the (hwndFocus = (HWND)wParam) argument.
	    //  a zero return tells the dialog manager that this function
	    //  has set the focus using SetFocus.
	    //
	    return (TRUE);

	case WM_COMMAND:
	    u = GET_WM_COMMAND_ID(wParam, lParam);
	    if ((IDOK == u) || (IDCANCEL == u))
	    {
		EndDialog(hwnd, (IDOK == u));
	    }
	    break;
    }

    return (FALSE);
} // AboutDlgProc()


//==========================================================================;
//
//  Initialization and exit code...
//
//
//==========================================================================;

TCHAR   gszKeyWindow[]      = TEXT("Window");
TCHAR   gszKeyFont[]        = TEXT("Font");

//--------------------------------------------------------------------------;
//
//  BOOL MMCapsChooseFont
//
//  Description:
//      This function lets the user choose a new font for the script window.
//      After a new font is chosen, the font structure is stored to the
//      .ini file so it can be restored on the next run of this application.
//
//  Arguments:
//      HWND hwnd: Handle to main window.
//
//  Return (BOOL):
//      The return value is TRUE if a new font was chosen. It is FALSE if
//      the user canceled the operation.
//
//  History:
//       2/ 7/93
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL MMCapsChooseFont
(
    HWND            hwnd
)
{
    LOGFONT     lf;
    HWND        hlb;
    HFONT       hfont;
    HFONT       hfontNew;

    hlb = GetDlgItem(hwnd, IDD_APP_LIST_DEVICES);

    //
    //  get the current font and pass it to the choose font dialog
    //
    hfont = GetWindowFont(gptlbDrivers->hlb);

    hfontNew = AppChooseFont(hwnd, hfont, &lf);
    if (NULL == hfontNew)
	return (FALSE);

    //
    //  select the new font into the script window and delete the old one
    //
    TlbSetFont(gptlbDrivers, hfontNew, TRUE);
    DeleteFont(hfont);


    //
    //  save the complete description of the chosen font so there can be
    //  no strangness in the font mapping next run. this is overkill, but
    //  it works...
    //
    AppProfileWriteBytes(gszKeyFont, (LPBYTE)&lf, sizeof(lf));

    return (TRUE);
} // MMCapsChooseFont()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsSettingsRestore
//  
//  Description:
//      This function restores state information for the application. This
//      function is called just after the main window is created (it has
//      not been ShowWindow()'d). This function will generate the call
//      to ShowWindow before returning.
//
//  Arguments:
//      HWND hwnd: Handle to main window that has just been created but
//      not shown.
//
//      int nCmdShow: The state that the application window should show as.
//
//  Return (BOOL):
//      The return value is always TRUE.
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsSettingsRestore
(
    HWND            hwnd,
    int             nCmdShow
)
{
    WINDOWPLACEMENT wp;
    PRECT           prc;
    HFONT           hfont;
    LOGFONT         lf;
    RECT            rc;
    POINT           pt;
    int             n;
    BOOL            f;



    //
    //  restore the user's preferred font.
    //
    hfont = NULL;
    f = AppProfileReadBytes(gszKeyFont, (LPBYTE)&lf, sizeof(lf));
    if (f)
    {
	hfont = CreateFontIndirect(&lf);
    }

    if (NULL == hfont)
    {
	hfont = GetStockFont(ANSI_VAR_FONT);
    }

    TlbSetFont(gptlbDrivers, hfont, TRUE);


    //
    //  grab the stored window position and size from the .ini file...
    //  there must be four arguments stored or the entry is considered
    //  invalid.
    //
    prc = &wp.rcNormalPosition;
    f = AppProfileReadBytes(gszKeyWindow, (LPBYTE)prc, sizeof(*prc));
    if (f)
    {
	//
	//  to make sure the user can always get at the window, check to
	//  see if the midpoint of the caption is visible--if it is not,
	//  then default to the default position used when creating the
	//  window.
	//
	n = (prc->right - prc->left) / 2;
	pt.x = (n + prc->left);

	n = GetSystemMetrics(SM_CYCAPTION) / 2 + GetSystemMetrics(SM_CXFRAME);
	pt.y = (n + prc->top);

	GetWindowRect(GetDesktopWindow(), &rc);
	if (PtInRect(&rc, pt))
	{
	    //
	    //  fill out the window placement structure--default the
	    //  maximized and minimized states to default placement by
	    //  getting its current placement.
	    //
	    wp.length = sizeof(wp);
	    GetWindowPlacement(hwnd, &wp);

	    wp.flags           = 0;
	    wp.showCmd         = nCmdShow;

	    SetWindowPlacement(hwnd, &wp);
	    return (TRUE);
	}
    }

    //
    //  show defaulted and succeed
    //
    ShowWindow(hwnd, nCmdShow);
    return (TRUE);
} // MMCapsSettingsRestore()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsSettingsSave
//  
//  Description:
//      This function saves the current state information for the application.
//      It is called just before the main window is closed (destroyed); or
//      as Windows is exiting (query end session).
//
//      Note that this function should not destroy any resources--it can
//      be called at any time to save a snapshot of the application state.
//
//  Arguments:
//      HWND hwnd: Handle to main window that will be destroyed shortly.
//
//  Return (BOOL):
//      The return value is always TRUE.
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsSettingsSave
(
    HWND            hwnd
)
{
    WINDOWPLACEMENT wp;
    PRECT           prc;
    BOOL            f;

    //
    //  save the current window placement--only store the size and location
    //  of the restored window. maximized and minimized states should
    //  remain defaulted on the next invocation of this application.
    //
    wp.length = sizeof(wp);
    f = GetWindowPlacement(hwnd, &wp);
    if (f)
    {
	prc = &wp.rcNormalPosition;

	DPF(0, "WindowPlacement: show=%d, minX=%d, minY=%d, maxX=%d, maxY=%d",
	     wp.showCmd, wp.ptMinPosition.x, wp.ptMinPosition.y,
	     wp.ptMaxPosition.x, wp.ptMaxPosition.y);

	DPF(0, "                 normX=%d, normY=%d, normW=%d, normH=%d",
	     prc->left, prc->top, prc->right, prc->bottom);

	//
	//  save the _bounding rectangle_ of the restored window state...
	//
	AppProfileWriteBytes(gszKeyWindow, (LPBYTE)prc, sizeof(*prc));
    }


    //
    //  succeed
    //
    return (TRUE);
} // MMCapsSettingsSave()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDlgProc
//
//  Description:
//      This dialog procedure is used to display driver capabilities.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//  History:
//       1/ 2/93
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT MMCapsDlgProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    HWND        hedit;
    UINT        u;

    switch (uMsg)
    {
	case WM_INITDIALOG:
	    hedit = GetDlgItem(hwnd, IDD_DEVCAPS_EDIT_DETAILS);
	    SetWindowFont(hedit, GetStockFont(ANSI_FIXED_FONT), FALSE);

	    //
	    //
	    //
	    switch (guDriverType)
	    {
		case MMCAPS_DRIVERTYPE_LOWLEVEL:
		    MMCapsDetailLowLevel(hedit, lParam);
		    break;

#if 0
		case MMCAPS_DRIVERTYPE_MCI:
		    MMCapsDetailMCI(hedit, lParam);
		    break;

		case MMCAPS_DRIVERTYPE_ACM:
		    MMCapsDetailACM(hedit, lParam);
		    break;

		case MMCAPS_DRIVERTYPE_VIDEO:
		    MMCapsDetailVideo(hedit, lParam);
		    break;
#endif
	    }

	    //
	    //  return nonzero to set the input focus to the control
	    //  identified by the (hwndFocus = (HWND)wParam) argument.
	    //  a zero return tells the dialog manager that this function
	    //  has set the focus using SetFocus.
	    //
	    return (TRUE);

	case WM_COMMAND:
	    u = GET_WM_COMMAND_ID(wParam, lParam);
	    if ((IDOK == u) || (IDCANCEL == u))
	    {
		EndDialog(hwnd, (IDOK == u));
	    }
	    break;
    }

    return (FALSE);
} // MMCapsDlgProc()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsRefreshDriverList
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd: Handle of main window.
//  
//  Return (BOOL):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsRefreshDriverList
(
    PZYZTABBEDLISTBOX   ptlb
)
{
    static UINT     uIdPrev = (UINT)-1;

    BOOL        fComplete;

    //
    //
    //
    SetWindowRedraw(ptlb->hlb, FALSE);
    ListBox_ResetContent(ptlb->hlb);


    //
    //  only force complete update if the driver type is different from
    //  previous...
    //
    fComplete = (guDriverType != uIdPrev);
    uIdPrev = guDriverType;

    //
    //
    //
    switch (guDriverType)
    {
	case MMCAPS_DRIVERTYPE_LOWLEVEL:
	    MMCapsEnumerateLowLevel(ptlb, fComplete);
	    break;


#if 0
	case MMCAPS_DRIVERTYPE_MCI:
	    MMCapsEnumerateMCI(ptlb, fComplete);
	    break;

	case MMCAPS_DRIVERTYPE_ACM:
	    MMCapsEnumerateACM(ptlb, fComplete);
	    break;

	case MMCAPS_DRIVERTYPE_VIDEO:
	    MMCapsEnumerateVideo(ptlb, fComplete);
	    break;

	case MMCAPS_DRIVERTYPE_DRIVERS:
	    MMCapsEnumerateDrivers(ptlb, fComplete);
	    break;
#endif

    }

    //
    //
    //
    SetWindowRedraw(ptlb->hlb, TRUE);

    return (TRUE);
} // MMCapsRefreshDriverList()


//==========================================================================;
//
//  Main application window handling code...
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT AppCreate
//
//  Description:
//      This function is called to handle the WM_CREATE message for the
//      application's window. The application should finish the creation
//      of the window (create controls, allocate resources, etc). The
//      window has not been displayed (CreateWindow[Ex] has not returned).
//
//  Arguments:
//      HWND hwnd: Handle to the window that is in the process of being
//      created.
//
//      LPCREATESTRUCT pcs: Pointer to a CREATESTRUCT that contains info
//      about the window being created.
//
//  Return (LRESULT):
//      The return value should be nonzero if the application wishes to
//      let the window finish being created. A return of zero tells
//      CreateWindow[Ex] to fail the creation of the window.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppCreate
(
    HWND            hwnd,
    LPCREATESTRUCT  pcs
)
{
    DPF(0, "AppCreate(hwnd=%Xh, cs.x=%d, cs.y=%d, cs.cx=%d, cs.cy=%d)",
	    hwnd, pcs->x, pcs->y, pcs->cx, pcs->cy);

    //
    //  create the driver selection listbox
    //
    gptlbDrivers = TlbCreate(hwnd, IDD_APP_LIST_DEVICES, NULL);
    if (NULL == gptlbDrivers)
	return (0L);

    //
    //
    //
    MMCapsRefreshDriverList(gptlbDrivers);


    //
    //  we want the focus to default to the device listbox window
    //
    SetFocus(gptlbDrivers->hlb);


    //
    //  return nonzero to succeed the creation of the window
    //
    return (1L);
} // AppCreate()


//--------------------------------------------------------------------------;
//
//  LRESULT AppQueryEndSession
//
//  Description:
//      This function handles the WM_QUERYENDSESSION. This message is sent
//      by USER when ExitWindows has been called to end the Windows session.
//      This function can stop Windows from exiting if it is not convenient
//      for Windows to end.
//
//      Giving the user the option to save modified data before continueing
//      with the shutdown of Windows is a good idea.
//
//      Telling Windows to continue with the exit procedure does not
//      necessarily mean Windows will exit. All applications are queried
//      for shutdown approval. When the actual decision is made on whether
//      Windows will exit, WM_ENDSESSION will be sent with the result.
//
//  Arguments:
//      HWND hwnd: Handle to window that received the message.
//
//  Return (LRESULT):
//      Returns zero to STOP Windows from exiting. Returns non-zero to
//      allows windows to shut down.
//
//  History:
//       2/ 9/93
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppQueryEndSession
(
    HWND            hwnd
)
{
    DPF(0, "AppQueryEndSession(hwnd=%Xh)", hwnd);

    //
    //  tell Windows to proceed with the shutdown process!
    //
    return (1L);
} // AppQueryEndSession()


//--------------------------------------------------------------------------;
//
//  LRESULT AppEndSession
//
//  Description:
//      This function is called to handle the WM_ENDSESSION message. This
//      message is generated after the application answers the
//      WM_QUERYENDSESSION message. The purpose of the WM_ENDSESSION
//      message is to tell the application if Windows will be exiting
//      (TRUE  == fEndSession) or the end session was canceled by an
//      application (FALSE == fEndSession).
//
//  Arguments:
//      HWND hwnd: Handle to window that received the message.
//
//      BOOL fEndSession: TRUE if Windows is exiting. FALSE if the end
//      session was canceled.
//
//  Return (LRESULT):
//      Returns zero if the message is processed. Note that an application
//      cannot halt the termination of Windows from this message--the
//      WM_QUERYENDSESSION is the only message that allows that behaviour.
//      If fEndSession is TRUE, Windows *WILL* exit--whether you like it
//      or not.
//
//  History:
//       2/ 9/93
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppEndSession
(
    HWND            hwnd,
    BOOL            fEndSession
)
{
    DPF(0, "AppEndSession(hwnd=%Xh, fEndSession=%d)", hwnd, fEndSession);

    //
    //  we processed the message, return zero..
    //
    return (0L);
} // AppEndSession()


//--------------------------------------------------------------------------;
//
//  LRESULT AppClose
//
//  Description:
//      This function handles the WM_CLOSE message for the application.
//      If the application should close, DestroyWindow() must be called
//      by this function. Otherwise the application will not close.
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_CLOSE message.
//
//  Return (LRESULT):
//      There return value is zero. The DestroyWindow function will have
//      been called if the application should actually close.
//
//  History:
//       2/ 6/93
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppClose
(
    HWND            hwnd
)
{
    HWND        hlb;
    HFONT       hfont;


    DPF(0, "AppClose(hwnd=%Xh)", hwnd);

    //
    //  save any settings that should be saved on app termination...
    //
    MMCapsSettingsSave(hwnd);


    //
    //  if the Shift key is held down during the close message, then just
    //  save the current state but don't destroy the window... this is
    //  useful if the user does not want to exit the app and rerun it
    //  to make sure the state is saved--just before the user does something
    //  that may crash Windows or something..
    //
    if (GetKeyState(VK_SHIFT) < 0)
    {
	return (0L);
    }


    //
    //  destroy the font we are using... before deleting the font, select
    //  the system font back into the script window so the font won't
    //  be 'in use' anymore.
    //
    hlb = GetDlgItem(hwnd, IDD_APP_LIST_DEVICES);

    hfont = GetWindowFont(hlb);
    SetWindowFont(hlb, NULL, FALSE);
    DeleteFont(hfont);

    //
    //  make the window close and terminate the application
    //
    DestroyWindow(hwnd);

    return (0L);
} // AppClose()


//--------------------------------------------------------------------------;
//
//  LRESULT AppInitMenuPopup
//
//  Description:
//      This function handles the WM_INITMENUPOPUP message. This message
//      is sent to the window owning the menu that is going to become
//      active. This gives an application the ability to modify the menu
//      before it is displayed (disable/add items, etc).
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP
//      message.
//
//      HMENU hmenu: Handle to the menu that is to become active.
//
//      int nItem: Specifies the zero-based relative position of the menu
//      item that invoked the popup menu.
//
//      BOOL fSysMenu: Specifies whether the popup menu is a System menu
//      (TRUE) or it is not a System menu (FALSE).
//
//  Return (LRESULT):
//      Returns zero if the message is processed.
//
//  History:
//       1/ 2/93
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppInitMenuPopup
(
    HWND            hwnd,
    HMENU           hmenu,
    int             nItem,
    BOOL            fSysMenu
)
{
    UINT        u;

    DPF(0, "AppInitMenuPopup(hwnd=%Xh, hmenu=%Xh, nItem=%d, fSysMenu=%d)",
	    hwnd, hmenu, nItem, fSysMenu);

    //
    //  if the system menu is what got hit, succeed immediately... this
    //  application has no stuff in the system menu.
    //
    if (fSysMenu)
	return (0L);

    //
    //  initialize the menu that is being 'popped up'
    //
    switch (nItem)
    {
	case APP_MENU_ITEM_FILE:
	    break;

	case APP_MENU_ITEM_DRIVERS:
	    for (u = IDM_DRIVERS_LOWLEVEL; u <= IDM_DRIVERS_DRIVERS; u++)
	    {
		UINT    uCheck;

		uCheck = (u == guDriverType) ? MF_CHECKED : MF_UNCHECKED;
		CheckMenuItem(hmenu, u, uCheck);
	    }
	    break;
    }

    //
    //  we processed the message--return 0...
    //
    return (0L);
} // AppInitMenuPopup()


//--------------------------------------------------------------------------;
//
//  LRESULT AppCommand
//
//  Description:
//      This function handles the WM_COMMAND message.
//
//  Arguments:
//      HWND hwnd: Handle to window receiving the WM_COMMAND message.
//
//      int nId: Control or menu item identifier.
//
//      HWND hwndCtl: Handle of control if the message is from a control.
//      This argument is NULL if the message was not generated by a control.
//
//      UINT uCode: Notification code. This argument is 1 if the message
//      was generated by an accelerator. If the message is from a menu,
//      this argument is 0.
//
//  Return (LRESULT):
//      Returns zero if the message is processed.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppCommand
(
    HWND            hwnd,
    int             nId,
    HWND            hwndCtl,
    UINT            uCode
)
{
    int         n;
    LRESULT     lr;

    switch (nId)
    {
	case IDM_FILE_FONT:
	    MMCapsChooseFont(hwnd);
	    break;

	case IDM_FILE_ABOUT:
	    AppDialogBox(hwnd, DLG_ABOUT, (DLGPROC)AboutDlgProc, 0L);
	    break;

	case IDM_FILE_EXIT:
	    FORWARD_WM_CLOSE(hwnd, SendMessage);
	    break;


	case IDM_DRIVERS_LOWLEVEL:
	case IDM_DRIVERS_MCI:
	case IDM_DRIVERS_ACM:
	case IDM_DRIVERS_VIDEO:
	case IDM_DRIVERS_DRIVERS:
	    if ((UINT)nId == guDriverType)
		break;

	    guDriverType = (UINT)nId;

	    // -- fall through -- //

	case IDM_UPDATE:
	    MMCapsRefreshDriverList(gptlbDrivers);
	    break;


	case IDD_APP_LIST_DEVICES:
	    switch (uCode)
	    {
		case LBN_SELCHANGE:
		    break;

		case LBN_DBLCLK:
		    n  = ListBox_GetCurSel(hwndCtl);
		    lr = ListBox_GetItemData(hwndCtl, n);
		    AppDialogBox(hwnd, DLG_DEVCAPS, (DLGPROC)MMCapsDlgProc, lr);
		    break;
	    }
	    break;
    }

    return (0L);
} // AppCommand()


//--------------------------------------------------------------------------;
//
//  LRESULT AppSize
//
//  Description:
//      This function handles the WM_SIZE message for the application's
//      window. This message is sent to the application window after the
//      size has changed (but before it is painted).
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_SIZE message.
//
//      UINT fuSizeType: Specifies the type of resizing requested. This
//      argument is one of the following: SIZE_MAXIMIZED, SIZE_MINIMIZED,
//      SIZE_RESTORED, SIZE_MAXHIDE, or SIZE_MAXSHOW.
//
//      int nWidth: Width of the new client area for the window.
//
//      int nHeight: Height of the new client area for the window.
//
//  Return (LRESULT):
//      Returns zero if the application processes the message.
//
//  History:
//       2/ 5/93
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppSize
(
    HWND            hwnd,
    UINT            fuSizeType,
    int             nWidth,
    int             nHeight
)
{
    RECT        rc;

    DPF(0, "AppSize(hwnd=%Xh, fuSizeType=%u, nWidth=%d, nHeight=%d)",
	    hwnd, fuSizeType, nWidth, nHeight);

    //
    //  unless this application is the one being resized then don't waste
    //  time computing stuff that doesn't matter. this applies to being
    //  minimized also because this application does not have a custom
    //  minimized state.
    //
    if ((SIZE_RESTORED != fuSizeType) && (SIZE_MAXIMIZED != fuSizeType))
	return (0L);


    //
    //  size the devices listbox to be the total size of the client area--
    //  inflate the rect by one so borders are not visible. note that 
    //  we need to leave room at the top for the title text which is one
    //  line of text in height...
    //
    GetClientRect(hwnd, &rc);
    InflateRect(&rc, 1, 1);


    TlbMove(gptlbDrivers, &rc, FALSE);


    //
    //  we processed the message..
    //
    return (0L);
} // AppSize()


//--------------------------------------------------------------------------;
//  
//  LRESULT AppPaint
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//  Return (LRESULT):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppPaint
(
    HWND            hwnd
)
{
    PAINTSTRUCT ps;

    //
    //
    //
    BeginPaint(hwnd, &ps);

    TlbPaint(gptlbDrivers, hwnd, ps.hdc);

    EndPaint(hwnd, &ps);

    //
    //  we processed the message
    //
    return (0L);
} // AppPaint()


//--------------------------------------------------------------------------;
//
//  LRESULT AppWndProc
//
//  Description:
//      This is the main application window procedure.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (LRESULT):
//      The return value depends on the message that is being processed.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

LRESULT FNEXPORT AppWndProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    LRESULT     lr;

    switch (uMsg)
    {
	case WM_CREATE:
	    lr = HANDLE_WM_CREATE(hwnd, wParam, lParam, AppCreate);
	    return (lr);

	case WM_INITMENUPOPUP:
	    HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, AppInitMenuPopup);
	    return (0L);

	case WM_COMMAND:
	    lr = HANDLE_WM_COMMAND(hwnd, wParam, lParam, AppCommand);
	    return (lr);

	case WM_SIZE:
	    //
	    //  handle what we want for sizing, and then always call the
	    //  default handler...
	    //
	    HANDLE_WM_SIZE(hwnd, wParam, lParam, AppSize);
	    break;

	case WM_PAINT:
	    HANDLE_WM_PAINT(hwnd, wParam, lParam, AppPaint);
	    break;

	case WM_QUERYENDSESSION:
	    lr = HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, AppQueryEndSession);
	    return (lr);

	case WM_ENDSESSION:
	    HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, AppEndSession);
	    return (0L);

	case WM_CLOSE:
	    HANDLE_WM_CLOSE(hwnd, wParam, lParam, AppClose);
	    return (0L);

	case WM_DESTROY:
	    PostQuitMessage(0);
	    return (0L);
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
} // AppWndProc()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL AppInit
//
//  Description:
//      This function is called to initialize a new instance of the
//      application. We want to parse our command line, create our window,
//      allocate resources, etc.
//
//      The arguments passed to this function are exactly the same as
//      those passed to WinMain.
//
//  Arguments:
//      HINSTANCE hinst: Identifies the current instance of the
//      application.
//
//      HINSTANCE hinstPrev: Identifies the previous instance of the
//      application (NULL if first instance). For Win 32, this argument
//      is _always_ NULL.
//
//      LPTSTR pszCmdLine: Points to null-terminated unparsed command line.
//      If the application is compiled for Unicode, then this argument is
//      ignored.
//
//      int nCmdShow: How the main window for the application is to be
//      shown by default.
//
//  Return (HWND):
//      Returns the newly created handle to the applications main window.
//      This handle is NULL if something went wrong and tells the application
//      to exit immediately.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

HWND FNGLOBAL AppInit
(
    HINSTANCE       hinst,
    HINSTANCE       hinstPrev,
    LPTSTR          pszCmdLine,
    int             nCmdShow
)
{
    LRESULT FNEXPORT AppWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND        hwnd;
    WNDCLASS    wc;

    DPF(0, "AppInit(hinst=%Xh, hinstPrev=%Xh, pszCmdLine='%s', nCmdShow=%d)",
	    hinst, hinstPrev, pszCmdLine, nCmdShow);

    LoadString(hinst, IDS_APP_NAME, gszAppName, SIZEOF(gszAppName));


    //
    //  determine whether a new window class needs to be registered for
    //  this application. for Win 16, this only needs to be done for the
    //  first instance of the application created. for Win 32, this must
    //  be done for EVERY instance of the application.
    //
    if (NULL == hinstPrev)
    {
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc   = (WNDPROC)AppWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hinst;
	wc.hIcon         = LoadIcon(hinst, ICON_APP);
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wc.lpszMenuName  = MENU_APP;
	wc.lpszClassName = gszAppName;

	if (!RegisterClass(&wc))
	    return (NULL);
    }


    //
    //  create the application's main window
    //
    //  style bits available:
    //      WS_EX_ACCEPTFILES   :  will receive WM_DROPFILES messages
    //      WS_EX_DLGMODALFRAME :  creates window with double border
    //      WS_EX_NOPARENTNOTIFY:  won't receive WM_PARENTNOTIFY messages
    //      WS_EX_TOPMOST       :  puts window in topmost space
    //      WS_EX_TRANSPARENT   :  a very bizarre style indeed (Win 16 only)
    //
    hwnd = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
			  gszAppName,
			  gszAppName,
			  WS_OVERLAPPEDWINDOW,
			  APP_WINDOW_XOFFSET,
			  APP_WINDOW_YOFFSET,
			  APP_WINDOW_WIDTH,
			  APP_WINDOW_HEIGHT,
			  NULL,
			  NULL,
			  hinst,
			  NULL);

    if (NULL == hwnd)
	return (NULL);

#ifdef UNICODE
    //
    //  the application--which is different than the pszCmdLine argument
    //  passed through WinMain()...
    //
    //  so, skip over the command name to get to the argument string
    //
    pszCmdLine = GetCommandLine();
    if (NULL != pszCmdLine)
    {
	while (('\0' != *pszCmdLine) && (' ' != *pszCmdLine++))
	    ;
    }
#endif


    //
    //
    //
    //
    MMCapsSettingsRestore(hwnd, nCmdShow);


    //
    //  finally, get the window displayed and return success
    //
    //  the ShowWindow call is made during MMCapsInit
    //
//  ShowWindow(hwnd, nCmdShow);
//  UpdateWindow(hwnd);

    return (hwnd);
} // AppInit()


//--------------------------------------------------------------------------;
//
//  int AppExit
//
//  Description:
//      This function is called just before the application exits from
//      WinMain. Its purpose is to clean up any resources that were allocated
//      for running the application: brushes, heaps, etc..
//
//  Arguments:
//      HINSTANCE hinst: Identifies the current instance of the
//      application that is exiting.
//
//      int nResult: The result of the WM_QUIT message (in wParam of the
//      MSG structure. This argument will usually be 0 (even if the message
//      loop was never entered).
//
//  Return (int):
//      The return value is usually nResult--be we give this function the
//      opportunity to modify its value.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

int FNGLOBAL AppExit
(
    HINSTANCE       hinst,
    int             nResult
)
{
    DPF(0, "AppExit(hinst=%Xh, nResult=%d)", hinst, nResult);

    //
    //
    //
    //

    return (nResult);
} // AppExit()


//==========================================================================;
//
//  Main entry and message dispatching code
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int WinMain
//
//  Description:
//      This function is called by the system as the initial entry point
//      for a Windows application.
//
//  Arguments:
//      HINSTANCE hinst: Identifies the current instance of the
//      application.
//
//      HINSTANCE hinstPrev: Identifies the previous instance of the
//      application (NULL if first instance). For Win 32, this argument
//      is _always_ NULL.
//
//      LPSTR pszCmdLine: Points to null-terminated unparsed command line.
//      This string is strictly ANSI regardless of whether the application
//      is built for Unicode. To get the Unicode equivalent call the
//      GetCommandLine() function (Win 32 only).
//
//      int nCmdShow: How the main window for the application is to be
//      shown by default.
//
//  Return (int):
//      Returns result from WM_QUIT message (in wParam of MSG structure) if
//      the application is able to enter its message loop. Returns 0 if
//      the application is not able to enter its message loop.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

int PASCAL WinMain
(
    HINSTANCE       hinst,
    HINSTANCE       hinstPrev,
    LPSTR           pszCmdLine,
    int             nCmdShow
)
{
    int     nResult;
    HWND    hwnd;
    MSG     msg;
    HACCEL  haccl;

    //
    //  our documentation states that WinMain is supposed to return 0 if
    //  we do not enter our message loop--so assume the worst...
    //
    nResult = 0;

    //
    //  make our instance handle global for convenience..
    //
    ghinst = hinst;

    //
    //  init some stuff, create window, etc.. note the explicit cast of
    //  pszCmdLine--this is to mute a warning (and an ugly ifdef) when
    //  compiling for Unicode. see AppInit() for more details.
    //
    hwnd = AppInit(hinst, hinstPrev, (LPTSTR)pszCmdLine, nCmdShow);
    if (hwnd)
    {
	haccl = LoadAccelerators(hinst, ACCEL_APP);

	//
	//  dispatch messages
	//
	while (GetMessage(&msg, NULL, 0, 0))
	{
	    //
	    //  do all the special stuff required for this application
	    //  when dispatching messages..
	    //
	    if (!TranslateAccelerator(hwnd, haccl, &msg))
	    {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	    }
	}

	//
	//  return result of WM_QUIT message.
	//
	nResult = (int)msg.wParam;
    }

    //
    //  shut things down, clean up, etc.
    //
    nResult = AppExit(hinst, nResult);

    return (nResult);
} // WinMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mmcapsex\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define wvsprintfA          wvsprintf
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level


//--------------------------------------------------------------------------;
//
//  void DbgVPrintF(LPSTR szFmt, LPSTR va)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (void):
//
//
//  History:
//      11/28/92
//
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF(LPSTR szFmt, LPSTR va)
{
    char    ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
	switch(*szFmt)
	{
	    case '!':
		fDebugBreak = TRUE;
		szFmt++;
		continue;

	    case '`':
		fPrefix = FALSE;
		szFmt++;
		continue;

	    case '~':
		fCRLF = FALSE;
		szFmt++;
		continue;
	}

	break;
    }

    if (fDebugBreak)
    {
	ach[0] = '\007';
	ach[1] = '\0';
    }

    if (fPrefix)
	lstrcatA(ach, DEBUG_MODULE_NAME ": ");

    wvsprintfA(ach + lstrlenA(ach), szFmt, va);

    if (fCRLF)
	lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);

    if (fDebugBreak)
	DebugBreak();
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//
//  void dprintf(UINT uDbgLevel, LPSTR szFmt, ...)
//
//  Description:
//      dprintf() is called by the DPF macro if DEBUG is defined at compile
//      time.
//      
//      The messages will be send to COM1: like any debug message. To
//      enable debug output, add the following to WIN.INI :
//
//      [debug]
//      ICSAMPLE=1
//
//  Arguments:
//
//  Return (void):
//
//
//  History:
//      11/23/92
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
	return;

    va_start(va, szFmt);
    DbgVPrintF(szFmt, va);
    va_end(va);
} // dprintf()

//--------------------------------------------------------------------------;
//
//  BOOL DbgEnable(BOOL fEnable)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (BOOL):
//
//
//  History:
//      11/28/92
//
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable(BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//
//  UINT DbgSetLevel(UINT uLevel)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel(UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(void)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize(BOOL fEnable)
{
    DbgSetLevel(GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mmcapsex\mmcaps.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  mmcaps.h
//
//  Description:
//
//
//  History:
//      11/ 8/92
//
//==========================================================================;


//
//  NOTE! we keep a copy of MMREG.H in this project so we can update
//  things by using 'diff'
//
#include "mmreg.h"
#include "zyztlb.h"


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Application Version Information:
//
//
//
//
//  NOTE! all string resources that will be used in app.rcv for the
//  version resource information *MUST* have an explicit \0 terminator!
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define APP_VERSION_MAJOR	    4
#define APP_VERSION_MINOR           0
#define APP_VERSION_BUILD           0
#ifdef UNICODE
#define APP_VERSION_STRING_RC	    "Version 4.00 (Unicode Enabled)\0"
#else
#define APP_VERSION_STRING_RC	    "Version 4.00\0"
#endif

#ifdef WIN32
#define APP_VERSION_NAME_RC         "mmcaps32.exe\0"
#else
#define APP_VERSION_NAME_RC         "mmcaps16.exe\0"
#endif
#define APP_VERSION_COMPANYNAME_RC  "Microsoft Corporation\0"
#define APP_VERSION_COPYRIGHT_RC    "Copyright \251 Microsoft Corp. 1992-1995\0"

#ifdef WIN32
#if (defined(_X86_)) || (defined(i386))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT (i386)\0"
#endif
#if (defined(_MIPS_)) || (defined(MIPS))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT (MIPS)\0"
#endif
#if (defined(_ALPHA_)) || (defined(ALPHA))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT (Alpha)\0"
#endif
#ifndef APP_VERSION_PRODUCTNAME_RC
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT\0"
#endif
#else
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows\0"
#endif

#ifdef DEBUG
#define APP_VERSION_DESCRIPTION_RC  "Multimedia Device Capabilities (debug)\0"
#else
#define APP_VERSION_DESCRIPTION_RC  "Multimedia Device Capabilities\0"
#endif


//
//  Unicode versions (if UNICODE is defined)... the resource compiler
//  cannot deal with the TEXT() macro.
//
#define APP_VERSION_STRING          TEXT(APP_VERSION_STRING_RC)
#define APP_VERSION_NAME            TEXT(APP_VERSION_NAME_RC)
#define APP_VERSION_COMPANYNAME     TEXT(APP_VERSION_COMPANYNAME_RC)
#define APP_VERSION_COPYRIGHT       TEXT(APP_VERSION_COPYRIGHT_RC)
#define APP_VERSION_PRODUCTNAME     TEXT(APP_VERSION_PRODUCTNAME_RC)
#define APP_VERSION_DESCRIPTION     TEXT(APP_VERSION_DESCRIPTION_RC)




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//  misc. defines
//
#define APP_MAX_APP_NAME_CHARS      30
#define APP_MAX_APP_NAME_BYTES      (APP_MAX_APP_NAME_CHARS * sizeof(TCHAR))
#define APP_MAX_STRING_RC_CHARS     512
#define APP_MAX_STRING_RC_BYTES     (APP_MAX_STRING_RC_CHARS * sizeof(TCHAR))
#define APP_MAX_STRING_ERROR_CHARS  512
#define APP_MAX_STRING_ERROR_BYTES  (APP_MAX_STRING_ERROR_CHARS * sizeof(TCHAR))

#define APP_WINDOW_XOFFSET          CW_USEDEFAULT
#define APP_WINDOW_YOFFSET          CW_USEDEFAULT
#define APP_WINDOW_WIDTH            500 //CW_USEDEFAULT
#define APP_WINDOW_HEIGHT           300 //CW_USEDEFAULT


//
//
//
//
#define MMCAPS_MAX_STRING_MID_CHARS 80
#define MMCAPS_MAX_STRING_MID_BYTES (MMCAPS_MAX_STRING_MID_CHARS * sizeof(TCHAR))
#define MMCAPS_MAX_STRING_PID_CHARS 128
#define MMCAPS_MAX_STRING_PID_BYTES (MMCAPS_MAX_STRING_PID_CHARS * sizeof(TCHAR))

//
//  max for pid or mid plus some
//
#define MMCAPS_MAX_STRING_MIDPID_CHARS  132



//
//  resource defines...
//
#define ICON_APP                    RCID(10)
#define ACCEL_APP                   RCID(15)


//
//  the application menu...
//
//
#define MENU_APP                    RCID(20)
#define APP_MENU_ITEM_FILE          0
#define IDM_FILE_FONT               1000
#define IDM_FILE_ABOUT              1009
#define IDM_FILE_EXIT               1010

#define APP_MENU_ITEM_DRIVERS       1
#define IDM_DRIVERS_LOWLEVEL        1050
#define IDM_DRIVERS_MCI             1051
#define IDM_DRIVERS_ACM             1052
#define IDM_DRIVERS_VIDEO           1053
#define IDM_DRIVERS_DRIVERS         1054

#define IDM_UPDATE                  1100


//
//
//
#define MMCAPS_DRIVERTYPE_LOWLEVEL  IDM_DRIVERS_LOWLEVEL
#define MMCAPS_DRIVERTYPE_MCI       IDM_DRIVERS_MCI
#define MMCAPS_DRIVERTYPE_ACM       IDM_DRIVERS_ACM
#define MMCAPS_DRIVERTYPE_VIDEO     IDM_DRIVERS_VIDEO
#define MMCAPS_DRIVERTYPE_DRIVERS   IDM_DRIVERS_DRIVERS



//
//  the main window control id's...
//
#define IDD_APP_LIST_DEVICES        100


//
//  misc dlg boxes...
//
#define DLG_ABOUT                   RCID(50)
#define IDD_ABOUT_VERSION_OS        100
#define IDD_ABOUT_VERSION_PLATFORM  101

#define IDD_ABOUT_VERSION_MMSYSTEM  150


#define DLG_DEVCAPS                 RCID(55)
#define IDD_DEVCAPS_EDIT_DETAILS    100



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  string resources
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDS_APP_NAME                100



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Public function prototypes
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  mmcaps.c
//
//
//
int FNCGLOBAL AppMEditPrintF
(
    HWND            hedit,
    PCTSTR          pszFormat,
    ...
);




//
//  midspids.c
//
//
//
BOOL FNGLOBAL MMCapsMidAndPid
(
    UINT            uMid,
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
);



//
//
//
//
BOOL FNGLOBAL MMCapsEnumerateLowLevel(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);
BOOL FNGLOBAL MMCapsEnumerateMCI(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);
BOOL FNGLOBAL MMCapsEnumerateACM(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);
BOOL FNGLOBAL MMCapsEnumerateVideo(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);
BOOL FNGLOBAL MMCapsEnumerateDrivers(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);

BOOL FNGLOBAL MMCapsDetailLowLevel(HWND hedit, LPARAM lParam);
BOOL FNGLOBAL MMCapsDetailMCI(HWND hedit, LPARAM lParam);
BOOL FNGLOBAL MMCapsDetailACM(HWND hedit, LPARAM lParam);
BOOL FNGLOBAL MMCapsDetailVideo(HWND hedit, LPARAM lParam);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  global variables, etc.
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

extern HINSTANCE    ghinst;

extern TCHAR        gszAppSection[];
extern TCHAR        gszNull[];

extern TCHAR        gszAppName[APP_MAX_APP_NAME_CHARS];


//
//
//
extern TCHAR        gszUnknown[];
extern TCHAR        gszNotSpecified[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mmcapsex\lowlevel.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  lowlevel.c
//
//  Description:
//
//
//  History:
//       5/16/93
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

//#include "msmixmgr.h"

#include "appport.h"
#include "mmcaps.h"

#include "debug.h"


//
//
//
TCHAR       gszDeviceFormatTitle[]  = TEXT("Type\t8!Index\t5!Version\t7!Product Name");
TCHAR       gszDeviceFormatList[]   = TEXT("%-9s\t%d\t%u.%.02u\t%-32s");


//
//
//
//
TCHAR       gszBogusCaps[]       = TEXT("????");
TCHAR       gszTimerDevice[]     = TEXT("Internal PC Timer");
TCHAR       gszDefaultMapper[]   = TEXT("Default Mapper");


#define MMCAPS_DEVTYPE_UNKNOWN      0
#define MMCAPS_DEVTYPE_AUXILIARY    1
#define MMCAPS_DEVTYPE_JOYSTICK     2
#define MMCAPS_DEVTYPE_MIDIIN       3
#define MMCAPS_DEVTYPE_MIDIOUT      4
#define MMCAPS_DEVTYPE_MIXER        5
#define MMCAPS_DEVTYPE_TIMER        6
#define MMCAPS_DEVTYPE_WAVEIN       7
#define MMCAPS_DEVTYPE_WAVEOUT      8

PTSTR gaszDeviceType[] =
{
    gszUnknown,
    TEXT("Auxiliary"),
    TEXT("Joystick"),
    TEXT("MIDI In"),
    TEXT("MIDI Out"),
    TEXT("Mixer"),
    TEXT("Timer"),
    TEXT("Wave In"),
    TEXT("Wave Out")
};





//
//  AUXCAPS
//
//
//
PTSTR gaszAuxCapsTechnology[] =
{
    gszNotSpecified,                //
    TEXT("CD-Audio"),               // AUXCAPS_CDAUDIO
    TEXT("Auxiliary Input")         // AUXCAPS_AUXIN
};

#define AUXCAPS_TECHNOLOGY_LAST   