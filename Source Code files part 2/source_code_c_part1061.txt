r->lpPath);

				// Tack on the startup group to the end.
				//
				LoadString(NULL, iString, szDir + lstrlen(szDir), (sizeof(szDir) / sizeof(TCHAR)) - lstrlen(szDir) - 1);

				// Look for all the files.
				//
				if ( (hFindFile = FindFirstFile(szDir, &FindData)) != INVALID_HANDLE_VALUE )
				{
					do
					{
						// Ignore directories.
						//
						if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
						{
							//
							// Ok, this is a link that we need to add.  We need to build the
							// structure for it.
							//

							// Now allocate the memory we need for the structure that holds
							// all the info for the startup link.
							//
							if ( *lpNextLink = (LPSTARTUPLINK) MALLOC(sizeof(STARTUPLINK)) )
							{
								// Create the full path to the file and add it to the structure.
								//
								(*lpNextLink)->szFileName[0] = NULLCHR;
								lstrcpyn((*lpNextLink)->szFileName, szDir, lstrlen(szDir));
								lstrcat((*lpNextLink)->szFileName, FindData.cFileName);

								// Get the selected small icon for the file.
								//
								SHGetFileInfo((*lpNextLink)->szFileName, 0, &SHFileInfo, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_SMALLICON | SHGFI_SELECTED);
								(*lpNextLink)->hIconSelected = SHFileInfo.hIcon;

								// Get the normal small icon and the display name
								// to use in the list box.
								//
								SHGetFileInfo((*lpNextLink)->szFileName, 0, &SHFileInfo, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_SMALLICON | SHGFI_DISPLAYNAME);
								(*lpNextLink)->hIcon = SHFileInfo.hIcon;
								lstrcpy((*lpNextLink)->szDisplayName, SHFileInfo.szDisplayName);

								// Set the initial selected state for the item.
								//
								if ( ( lstrcmpi(lpOffice95, (*lpNextLink)->szDisplayName) == 0 ) ||
								     ( lstrcmpi(lpOffice97, (*lpNextLink)->szDisplayName) == 0 ) )
									(*lpNextLink)->bSelected = FALSE;
								else
									(*lpNextLink)->bSelected = ( iString == IDS_STARTUP );

								// Add the name to the list box and set the structure pointer as the list box item data.
								//
								if ( (iIndex = (INT)SendDlgItemMessage(hDlg, IDC_STARTUP, LB_ADDSTRING, 0, (LPARAM) SHFileInfo.szDisplayName)) >= 0 )
								{
									SendDlgItemMessage(hDlg, IDC_STARTUP, LB_SETITEMDATA, iIndex, (LPARAM) *lpNextLink);
									lpNextLink = &((*lpNextLink)->lpNext);
								}
								else
									FREE(*lpNextLink);
							}
						}
					}
					while ( FindNextFile(hFindFile, &FindData) );

					FindClose(hFindFile);
				}

				if ( iString == IDS_STARTUP )
					iString = IDS_APTUNEUP;
				else
					iString = 0;
			}
		}
	}

	return TRUE;
}


BOOL UserHasStartupItems()
{
	PSID			pSid;
	TCHAR			szBuffer[MAX_PATH + 1];
	LPTSTR			lpBuffer;
	BOOL			bFound		= FALSE;
	INT				iString		= IDS_STARTUP;
	HANDLE			hFindFile;
	WIN32_FIND_DATA	FindData;

	if ( ( pSid = GetUserSid() ) &&
	     ( lpBuffer = GetSidString(pSid) ) )
	{
		// First we need the profile directory for this user.
		//
		wsprintf(szBuffer, _T("%s\\%s"), g_szRegKeyProfiles, lpBuffer);
		FREE(lpBuffer);

		// Get the users profile directory.
		//
		if ( lpBuffer = RegGetString(HKLM, szBuffer, _T("ProfileImagePath")) )
		{
			// We only want them if the directory exists.
			//
			if ( EXIST(lpBuffer) )
			{
				// Loop through the two directories (the actual startup items and the disabled ones).
				//
				while ( iString )
				{
					// Copy the user's profile directory into the buffer.
					//
					lstrcpy(szBuffer, lpBuffer);

					// Tack on the startup group to the end.
					//
					LoadString(NULL, iString, szBuffer + lstrlen(szBuffer), (sizeof(szBuffer) / sizeof(TCHAR)) - lstrlen(szBuffer) - 1);

					// Look for all the files.
					//
					if ( (hFindFile = FindFirstFile(szBuffer, &FindData)) != INVALID_HANDLE_VALUE )
					{
						do
						{
							// Ignore directories.
							//
							if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
								bFound = TRUE;
						}
						while ( FindNextFile(hFindFile, &FindData) );

						FindClose(hFindFile);
					}

					if ( iString == IDS_STARTUP )
						iString = IDS_APTUNEUP;
					else
						iString = 0;
				}
			}
			FREE(lpBuffer);
		}
	}
	return bFound;
}


VOID SelectUserRadio(HWND hDlg, BOOL bAllNotCur)
{
	LPTSTR lpBuffer;

	if (bAllNotCur)
	{
		if ( lpBuffer = AllocateString(NULL, IDS_ALLUSERS) )
		{
			SendDlgItemMessage(hDlg, IDC_USERS, CB_SELECTSTRING, 0, (LPARAM) lpBuffer);
			FREE(lpBuffer);
		}
	}
	else
		SendDlgItemMessage(hDlg, IDC_USERS, CB_SELECTSTRING, 0, (LPARAM) g_szUserName);
	InitStartupList(hDlg);
}


static VOID FreeStartupLink(LPSTARTUPLINK lpStartupLink, LPTSTR lpPath)
{
	// Obviously don't want to free this memory if we were passed in NULL.
	//
	if ( lpStartupLink != NULL)
	{
		// Check to see if we need to move the file before
		// we free it's structure.  We dynamically allocate the MAX_PATH
		// buffer so we don't fill up the stack with this recursive function.
		//
		if ( g_dwFlags & TUNEUP_FINISHED )
		{
			TCHAR	szNewPath[MAX_PATH],
					szOldPath[MAX_PATH];
			LPTSTR	lpOldName;

			// Copy the profile path into the dir buffer.
			//
			lstrcpy(szNewPath, lpPath);

			// Get the rest of the path info.
			//
			if ( lpStartupLink->bSelected )
				LoadString(NULL, IDS_STARTUP, szNewPath + lstrlen(szNewPath), (sizeof(szNewPath) / sizeof(TCHAR)) - lstrlen(szNewPath));
			else
				LoadString(NULL, IDS_APTUNEUP, szNewPath + lstrlen(szNewPath), (sizeof(szNewPath) / sizeof(TCHAR)) - lstrlen(szNewPath));

			// Remove the * from the end of the path.
			//
			*(szNewPath + lstrlen(szNewPath) - 1) = NULLCHR;

			// Make sure the path exists.
			//
			CreatePath(szNewPath);

			// Get a pointer to the file name.
			//
			GetFullPathName(lpStartupLink->szFileName, sizeof(szOldPath) / sizeof(TCHAR), szOldPath, &lpOldName);

			// Add the file name to the new path.
			//
			lstrcat(szNewPath, lpOldName);

			// Now we have the full path to what the file name should be.
			// If the file that should be there doesn't exist and the old
			// file name does, move it.
			//
			if ( !EXIST(szNewPath) && EXIST(szOldPath) )
				MoveFile(szOldPath, szNewPath);
		}

		// Free the next link.
		//
		FreeStartupLink(lpStartupLink->lpNext, lpPath);

		// Now finally free the memory for this link.
		//
		FREE(lpStartupLink);
	}
}


static VOID InitStartupUsers(HWND hCtrlUsers)
{
	INT			iString[] = { IDS_ALLUSERS, IDS_DEFAULTUSER, 0 },
				iId,
				iIndex;
	LPTSTR		lpProfile,
				lpPath;
	LPUSERDIR	lpUserDir;
	TCHAR		szString[256];

	RegEnumKeys(HKLM, g_szRegKeyProfiles, (REGENUMKEYPROC) AddString, (LPARAM) hCtrlUsers, FALSE);

	if ( lpProfile = RegGetString(HKLM, g_szRegKeyProfiles, g_szRegValProfileDir) )
	{
		// Loop through the default users.
		//
		for (iId = 0; iString[iId] != 0; iId++)
		{
			// Load the string and allocate memory for it and the full path.
			//
			if ( ( LoadString(NULL, iString[iId], szString, sizeof(szString) / sizeof(TCHAR)) ) &&
				 ( lpPath = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(lpProfile) + lstrlen(szString) + 2)) ) )
			{
				// Create the full path.
				//
				wsprintf(lpPath, _T("%s\\%s"), lpProfile, szString);

				// Make sure the path exists.
				//
				if ( EXIST(lpPath) )
				{
					// Add the name to the combo box.
					//
					if ( (iIndex = (INT)SendMessage(hCtrlUsers, CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) szString)) > CB_ERR )
					{
						// Add the path data to the name.
						//
						if ( lpUserDir = (LPUSERDIR) MALLOC(sizeof(USERDIR)) )
						{
							lpUserDir->lpPath = lpPath;
							if ( (iIndex = (INT)SendMessage(hCtrlUsers, CB_SETITEMDATA, iIndex, (LPARAM) lpUserDir)) == CB_ERR )
								FREE(lpUserDir);
						}
						else
						{
							SendDlgItemMessage(hCtrlUsers, IDC_USERS, CB_DELETESTRING, iIndex, 0L);
							iIndex = CB_ERR;
						}
						
					}
				}
				else
					iIndex = CB_ERR;

				// If anything failed, we should free the buffer.
				//
				if ( iIndex <= CB_ERR )
					FREE(lpPath);

			}
		}

		// Free the path to the profiles.
		//
		FREE(lpProfile);
	}
}


static BOOL CALLBACK AddString(HKEY hKey, LPTSTR lpKey, LPARAM lParam)
{
	LPTSTR			lpBuffer;
	LPUSERDIR		lpUserDir;
	PSID			pSid;
	TCHAR			szUserName[UNLEN],
					szCompName[CNLEN],
					szDomainName[DNLEN],
					szDisplayName[UNLEN + CNLEN + 1];
	DWORD			cbUserName		= sizeof(szUserName) / sizeof(TCHAR),
					cbCompName		= sizeof(szCompName),
					cbDomainName	= sizeof(szDomainName) / sizeof(TCHAR);
	INT				nIndex = CB_ERR;
	SID_NAME_USE	SidName;

	// First we need the profile directory for this user.
	//
	if ( lpBuffer = RegGetString(hKey, NULL, g_szRegValProfilePath) )
	{
		// We only want them if the directory exists.
		//
		if ( EXIST(lpBuffer) )
		{
			// Now get the sid for this user from the registry.
			//
			if ( pSid = (PSID) RegGetBin(hKey, NULL, _T("Sid")) )
			{
				// Lookup the account info with the sid so we know the user and domain name.
				//
				if ( LookupAccountSid(NULL, pSid, szUserName, &cbUserName, szDomainName, &cbDomainName, &SidName) )
				{
					// Create the display name (combine the computer/domain name with the
					// user name unless the computer/domain name is the same as the computer name.
					//
					if ( ( GetComputerName(szCompName, &cbCompName) ) &&
					     ( lstrcmp(szCompName, szDomainName) == 0 ) )
						lstrcpy(szDisplayName, szUserName);
					else
						wsprintf(szDisplayName, _T("%s\\%s"), szDomainName, szUserName);

					// Add the display name to the combo box.
					//
					if ( (nIndex = (INT)SendMessage((HWND) lParam, CB_ADDSTRING, 0, (LPARAM) (LPCTSTR) szDisplayName)) > CB_ERR )
					{
						if ( lpUserDir = (LPUSERDIR) MALLOC(sizeof(USERDIR)) )
						{
							lpUserDir->lpPath = lpBuffer;
							if ( (nIndex = (INT)SendMessage((HWND) lParam, CB_SETITEMDATA, nIndex, (LPARAM) lpUserDir)) == CB_ERR )
								FREE(lpUserDir);
						}
						else
						{
							SendDlgItemMessage((HWND) lParam, IDC_USERS, CB_DELETESTRING, nIndex, 0L);
							nIndex = CB_ERR;
						}
						
					}
				}
				FREE(pSid);
			}
		}

		// If the add never happend, we should free the buffer.
		//
		if (nIndex < 0)
			FREE(lpBuffer);
	}

	// Return TRUE to keep proccessing the registry keys.
	//
	return TRUE;
}


static PSID GetUserSid()
{
    PTOKEN_USER	pUser	= NULL;
    DWORD		dwSize	= 0;
    HANDLE		hToken	= INVALID_HANDLE_VALUE;
	PSID		pSid	= NULL;

	// Get the current process token and
	// allocate space for and get the user info.
	//
    if ( !( ( OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) ) &&
	        ( !GetTokenInformation(hToken, TokenUser, pUser, dwSize, &dwSize) ) &&
	        ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) &&
	        ( pUser = (PTOKEN_USER) MALLOC(dwSize) ) &&
	        ( GetTokenInformation(hToken, TokenUser, pUser, dwSize, &dwSize) ) &&
	        ( pSid = (PSID) MALLOC(dwSize = GetLengthSid(pUser->User.Sid)) ) &&
	        ( CopySid(dwSize, pSid, pUser->User.Sid) ) ) )

		// If all those items didn't succeed, we need to free the sid.
		// This macro automatically checks for NULL before freeing and
		// sets to NULL after freeing.
		//
		FREE(pSid);

	// Free up and close up the resources used.
	//
	FREE(pUser);
	if ( hToken != INVALID_HANDLE_VALUE )
		CloseHandle(hToken);

	return pSid;
}


static LPTSTR GetSidString(PSID pSid)
{
	LPTSTR						lpszSid	= NULL;
	PSID_IDENTIFIER_AUTHORITY	pSidIA;
    DWORD						dwSubAuthorities,
								dwCounter,
								dwSidSize;

	// Check to make sure the Sid is vallid.
	//
    if ( pSid && IsValidSid(pSid) )
	{
		// Obtain SidIdentifierAuthority
		//
		pSidIA = GetSidIdentifierAuthority(pSid);

		// Obtain SidSubAuthority count
		//
		dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

		// Compute buffer length:
		// S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
		//
		dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

		// Automatically allocate the space needed for the Sid.
		//
		if ( lpszSid = (LPTSTR) MALLOC(dwSidSize) )
		{
			// Prepare S-SID_REVISION-
			//
			dwSidSize = wsprintf(lpszSid, TEXT("S-%lu-"), SID_REVISION);

			// Prepare SidIdentifierAuthority.
			//
			if ( ( pSidIA->Value[0] != 0 ) || ( pSidIA->Value[1] != 0 ) )
			{
				dwSidSize += wsprintf(
								lpszSid + lstrlen(lpszSid),
								_T("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
								(USHORT) pSidIA->Value[0],
								(USHORT) pSidIA->Value[1],
								(USHORT) pSidIA->Value[2],
								(USHORT) pSidIA->Value[3],
								(USHORT) pSidIA->Value[4],
								(USHORT) pSidIA->Value[5]
								);
			}
			else
			{
				dwSidSize += wsprintf(lpszSid + lstrlen(lpszSid),
								_T("%lu"),
								(ULONG) (pSidIA->Value[5]      ) +
								(ULONG) (pSidIA->Value[4] <<  8) +
								(ULONG) (pSidIA->Value[3] << 16) +
								(ULONG) (pSidIA->Value[2] << 24)
								);
			}

			// Loop through SidSubAuthorities.
			//
			for (dwCounter = 0; dwCounter < dwSubAuthorities; dwCounter++)
				dwSidSize += wsprintf(lpszSid + dwSidSize, _T("-%lu"), *GetSidSubAuthority(pSid, dwCounter));
		}
	}
	return lpszSid;
}


BOOL StartupDrawItem(HWND hWnd, const DRAWITEMSTRUCT * lpDrawItem)
{

    TCHAR			szBuffer[MAX_PATH];
	BOOL			bRestore	= FALSE;
	COLORREF		crText,
					crBk;
	DWORD			dwColor;
	RECT			rect;
	HBRUSH			hbrBack;
	LPSTARTUPLINK	lpStartupLink;

	static HICON	hIconCheck		= NULL,
					hIconUnCheck	= NULL;

	switch ( lpDrawItem->itemAction )
	{
		case ODA_SELECT:
		case ODA_DRAWENTIRE:

			if (lpDrawItem->itemState & ODS_SELECTED)
			{
				// Set new text/background colors and store the old ones away.
				//
				crText	= SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
				crBk	= SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHT));

				// Restore the text and background colors when we are finished.
				//
				bRestore = TRUE;

				// Get the hightlight color to fill in the listbox item.
				//
				dwColor = GetSysColor(COLOR_HIGHLIGHT);

			}
			else
			{
				// Get the window color so we can clear the listbox item.
				//
				dwColor = GetSysColor(COLOR_WINDOW);
			}

			// Fill entire item rectangle with the appropriate color
			//
			hbrBack = CreateSolidBrush(dwColor);
			FillRect(lpDrawItem->hDC, &(lpDrawItem->rcItem), hbrBack);
			DeleteObject(hbrBack);

			// Display the icon associated with the item.
			//
			if ( lpStartupLink = (LPSTARTUPLINK) SendMessage(lpDrawItem->hwndItem, LB_GETITEMDATA, lpDrawItem->itemID, (LPARAM) 0) )
			{
				// Load the checked and unchecked icons if we don't
				// have them already.
				//
				if ( hIconCheck == NULL )
					hIconCheck = (HICON) LoadImage(g_hInst, MAKEINTRESOURCE(IDI_CHECK), IMAGE_ICON, 16, 16, 0);
				if ( hIconUnCheck == NULL )
					hIconUnCheck = (HICON) LoadImage(g_hInst, MAKEINTRESOURCE(IDI_UNCHECK), IMAGE_ICON, 16, 16, 0);

				// Draw the checked or unchecked icon.
				//
				DrawIconEx(	lpDrawItem->hDC,
							lpDrawItem->rcItem.left,
							lpDrawItem->rcItem.top,
							lpStartupLink->bSelected ? hIconCheck : hIconUnCheck,
							lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top,
							lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top,
							0,
							0,
							DI_NORMAL);

				// Draw the items icon.
				//
				DrawIconEx(	lpDrawItem->hDC,
							lpDrawItem->rcItem.left + lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top + 2,
							lpDrawItem->rcItem.top,
							(lpDrawItem->itemState & ODS_SELECTED) ? lpStartupLink->hIconSelected : lpStartupLink->hIcon,
							lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top,
							lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top,
							0,
							0,
							DI_NORMAL);
			}

			// Display the text associated with the item.
			//
			SendMessage(lpDrawItem->hwndItem, LB_GETTEXT, lpDrawItem->itemID, (LPARAM) szBuffer);

			TextOut(	lpDrawItem->hDC,
						lpDrawItem->rcItem.left + ((lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top + 2) * 2),
						lpDrawItem->rcItem.top + 1,
						szBuffer,
						lstrlen(szBuffer));

			if (bRestore)
			{
				// Restore original text and background colors.
				//
				SetTextColor(lpDrawItem->hDC, crText);
				SetBkColor(lpDrawItem->hDC, crBk);
			}
			break;

		case ODA_FOCUS:

			// Get rectangle coordinates for listbox item.
			//
			SendMessage(lpDrawItem->hwndItem, LB_GETITEMRECT, lpDrawItem->itemID, (LPARAM) &rect);
			DrawFocusRect(lpDrawItem->hDC, &rect);
			break;

	}

	return TRUE;
}


VOID StartupSelectItem(HWND hWndCtrl)
{
	INT				nIndex;
	LPSTARTUPLINK	lpStartupLink;

	if ( ( (nIndex = (INT)SendMessage(hWndCtrl, LB_GETCURSEL, 0, 0L)) >= 0 ) &&
	     ( (lpStartupLink = (LPSTARTUPLINK) SendMessage(hWndCtrl, LB_GETITEMDATA, nIndex, 0L)) != NULL ) )
	{
		lpStartupLink->bSelected = !lpStartupLink->bSelected;
		SendMessage(hWndCtrl, LB_SETCURSEL, (WPARAM) nIndex, 0L);
	}
}


static LRESULT CALLBACK ListBox_Proc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	static WNDPROC	ListBoxProc = NULL;
	LONG			rc = 0;

	if ( iMsg == WM_REPLACEPROC )
	{
		// Replace the default Windows procedure for the list box.  AKA: The Glorious Hack!
		//
		if ( ( ListBoxProc == NULL ) &&
		     ( (ListBoxProc = (WNDPROC) GetWindowLongPtr(hWnd, GWLP_WNDPROC)) != NULL ) )
			SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR) ListBox_Proc);
		return rc;
	}

	// Just a safty catch to make sure we have the default windows procedure.
	//
	if ( ( ListBoxProc == NULL ) &&
	     ( (ListBoxProc = (WNDPROC) GetWindowLongPtr(hWnd, GWLP_WNDPROC)) == NULL ) )
		 return rc;

	// Let the standard window proc handle the message.
	//
	rc = (LONG)CallWindowProc((WNDPROC) ListBoxProc, hWnd, iMsg, wParam, lParam);

	// Do the single click thing if we need to.
	//
	if ( ( iMsg == WM_LBUTTONDOWN ) &&
	     ( (LOWORD(lParam) < 16) && (HIWORD(lParam) < (SendMessage(hWnd, LB_GETCOUNT, 0, 0L) * 16)) ) )
		StartupSelectItem(hWnd);

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\runnow.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// RUNNOW.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  8/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


//
// Internal include file(s).
//

#include <windows.h>
#include "tasks.h"
#include "main.h"


//
// Internal defined value(s).
//

#define CHECK_WIDTH             18

#define FIRST_SPACING   7
#define LINE_SPACING    13

#define WINGDING_CHECK  0xFC
#define WINGDING_ARROW  0xD8 //0x77 //0xE8 //0xE0

#define WM_PROGRESS             (WM_USER + 1000)


//
// Internal global variable(s).
//

HWND    g_hWndRunNowDlg = NULL;


//
// Inernal function prototype(s).
//


static INT                              RunNowProgressProc(DWORD);
static BOOL CALLBACK    RunNowDlgProc(HWND, UINT, WPARAM, LPARAM);
static VOID                             InitWingdingFont(HWND);



//
// External function(s).
//


VOID RunTasksNow(HWND hWndParent, LPTASKDATA lpTasks)
{
        HANDLE  hThread;
        DWORD   dwThreadID;

        // Use another thread to run progressing dialog.
        //
        hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) RunNowProgressProc, (LPVOID) NULL, 0, (LPDWORD) &dwThreadID);

        // Hide the wizard window.
        //
        ShowEnableWindow(hWndParent, FALSE);

        // Wait for the dialog to be created.
        //
        while ( g_hWndRunNowDlg == NULL )
                Sleep(10);

        // Loop through all the tasks.
        //
        while ( lpTasks && g_hWndRunNowDlg )
        {
                // Check to see if it is scheduled.
                //
                if ( !(g_dwFlags & TUNEUP_CUSTOM) || (lpTasks->dwOptions & TASK_SCHEDULED) )
                {
                        // Put an arrow next to the item.
                        //
                        SendMessage(g_hWndRunNowDlg, WM_PROGRESS, 0, 0L);

                        // Execute the task.
                        //
                        ExecAndWait(hWndParent, lpTasks->lpFullPathName, lpTasks->lpParameters, NULL, FALSE, FALSE);
                }
                lpTasks = lpTasks->lpNext;
        }

        // If the progress dialog is still there, close it
        //
        if ( g_hWndRunNowDlg )
                SendMessage(g_hWndRunNowDlg, WM_CLOSE, 0, 0);
}



//
// Internal function(s).
//


static INT RunNowProgressProc(DWORD dwDummy)
{
        return (INT)DialogBox(g_hInst, MAKEINTRESOURCE(IDD_PROGRESS), NULL, (DLGPROC) RunNowDlgProc);
}


static BOOL CALLBACK RunNowDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
        static POINT    Point;
        static INT              nHeight,
                                        nIndex                  = -1;
        static HWND             hWndTemp                = NULL,
                                        *lphWnd                 = NULL;
        static HFONT    hBoldFont               = NULL,
                                        hNormFont               = NULL;

        TCHAR                   szWingDing[]    = _T("  ");
        POINT                   PointMove;
        RECT                    Rect,
                                        RectDlg;
        LPTASKDATA              lpTasks;

        switch (message)
        {
                case WM_COMMAND:

                        if ( (INT) LOWORD(wParam) == IDCANCEL )
                                EndDialog(hDlg, 0);
                        return 0;

                case WM_DESTROY:

                        
                        // Free the font handles.
                        //
                        if ( hBoldFont )
                                DeleteObject(hBoldFont);
                        if ( hNormFont )
                                DeleteObject(hNormFont);
                        InitWingdingFont(NULL);

                        // Free the hWnd.
                        //
                        FREE(lphWnd);

                        g_hWndRunNowDlg = NULL;

                        return TRUE;

                case WM_INITDIALOG:

                        // Disable system menu itmes.
                        //
                        //EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_CLOSE, MF_BYCOMMAND | MF_DISABLED);

                        // Move the window to the upper right corner of the desktop.
                        //
                        CenterWindow(hDlg, NULL, TRUE);

                        // Get the rect of the title control we are going to base all the others of.
                        //
                        GetWindowRect(GetDlgItem(hDlg, IDC_TITLE), &Rect);
                        MapWindowPoints(NULL, hDlg, (LPPOINT)&Rect, 2);

                        // Figure the width and height of the new controls.
                        //
                        Rect.right -= Rect.left;        // The width of the control.
                        Rect.bottom -= Rect.top;        // The height of the control.
                        
                        // Now we need to convert the left top coordinates from screen to client coordinates.
                        //
                        Point.x = Rect.left;    // The left of the control.
                        Point.y = Rect.top;             // The top of the control.
                        Point.y += FIRST_SPACING;

                        // Allocate the memory for the hWnds.
                        //
                        nHeight = TasksScheduled(g_Tasks);
                        lphWnd = (HWND *) MALLOC(sizeof(HWND) * nHeight--);
                        nIndex = nHeight;

                        for (lpTasks = g_Tasks; lpTasks; lpTasks = lpTasks->lpNext)
                        {
                                // Check to see if it is scheduled.
                                //
                                if ( !(g_dwFlags & TUNEUP_CUSTOM) || (lpTasks->dwOptions & TASK_SCHEDULED) )
                                {
                                        // Each new control should be 2 times the width of the control down
                                        // from the previous control.  This will give 1 width of the control
                                        // between each.
                                        //
                                        Point.y += Rect.bottom + LINE_SPACING;

                                        // Create the control and set the font and text.
                                        //
                                        hWndTemp = CreateWindow(_T("STATIC"), _T(""), WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE, Point.x + CHECK_WIDTH, Point.y, Rect.right - CHECK_WIDTH, Rect.bottom, hDlg, NULL, g_hInst, NULL);
                                        if ( hNormFont == NULL )
                                                hNormFont = (HFONT) SendDlgItemMessage(hDlg, IDC_TITLE, WM_GETFONT, 0, 0L);
                                        SendMessage(hWndTemp, WM_SETFONT, (WPARAM) hNormFont, MAKELPARAM(FALSE, 0));
                                        SetWindowText(hWndTemp, lpTasks->lpTitle);

                                        // If we can, save the hwnd so we can use it to make
                                        // the current text bold.
                                        //
                                        if ( lphWnd && (nIndex >= 0) )
                                                *(lphWnd + nIndex) = hWndTemp;
                                        nIndex--;
                                }
                        }

                        // Make sure we allocated the memory and used all of it.
                        // nIndex should be exatly -1 if we got the right number
                        // of hWnds.
                        //
                        if ( lphWnd && (nIndex == -1) )
                                nIndex = nHeight;
                        else
                                nIndex = -1;

                        // Reset this so that the progress message knows the
                        // first time it is run.
                        //
                        hWndTemp = NULL;

                        // Make sure that the Point.y is at the bottom of the
                        // last control created by adding the height of the control
                        // to it.
                        //
                        Point.y += Rect.bottom;

                        // Get the current position in client coordinates
                        // of the Cancel button.
                        //
                        GetWindowRect(GetDlgItem(hDlg, IDCANCEL), &Rect);
                        MapWindowPoints(NULL, hDlg, (LPPOINT)&Rect, 2);
                        PointMove.x = Rect.left;
                        PointMove.y = Rect.top;
                        GetWindowRect(GetDlgItem(hDlg, IDCANCEL), &Rect);

                        // Get the rect of the dialog in screen coordinates.
                        //
                        GetWindowRect(hDlg, &RectDlg);

                        // Move up the cancel button based on the bottom of the last control
                        // created and adding the space between the bottom of the cancel button
                        // and the bottom of the dialog.
                        //
                        PointMove.y = Point.y + (RectDlg.bottom - Rect.bottom);

                        // Move the Cancel button so it is up under the last control created.
                        //
                        SetWindowPos(GetDlgItem(hDlg, IDCANCEL), NULL, PointMove.x, PointMove.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

                        // Set where the bottom of the dialog in screen coordinates should
                        // be based on where the cancel button was moved to.
                        //
                        Point.x = 0;  // Don't care.
                        Point.y = PointMove.y + RectDlg.bottom - Rect.top;
                        ClientToScreen(hDlg, &Point);

                        // Move up the bottom of the dialog so it is just under the cancel button.
                        //
                        SetWindowPos(hDlg, NULL, 0, 0, RectDlg.right - RectDlg.left, Point.y - RectDlg.top, SWP_NOMOVE | SWP_NOZORDER);

                        g_hWndRunNowDlg = hDlg;

                        return FALSE;

                case WM_PROGRESS:

                        // Check to see if this is the first
                        // time this function is run.
                        //
                        if ( hWndTemp == NULL )
                        {
                                // Get the rect of the title control we are going to base all the others of.
                                // We need to convert the left top coordinates from screen to client coordinates.
                                //
                                GetWindowRect(GetDlgItem(hDlg, IDC_TITLE), &Rect);
                                MapWindowPoints(NULL, hDlg, (LPPOINT)&Rect, 2);
                                Point.x = Rect.left;                            // The left of the control.
                                Point.y = Rect.top;                                     // The top of the control.
                                nHeight = Rect.bottom - Rect.top;       // The height of the control.
                                MapWindowPoints(NULL, hDlg, (LPPOINT)&Rect, 2);
                                Point.y += FIRST_SPACING;
                        }
                        else
                        {
                                // Set the previous control to checked before creating the next one.
                                //
                                szWingDing[0] = (TCHAR) WINGDING_CHECK;
                                SetWindowText(hWndTemp, szWingDing);
                                if ( lphWnd && (nIndex >= 0) )
                                        SendMessage(*(lphWnd + nIndex), WM_SETFONT, (WPARAM) hNormFont, MAKELPARAM(TRUE, 0));
                                nIndex--;
                        }
                        
                        // Each new control should be 2 times the width of the control down
                        // from the previous control.  This will give 1 width of the control
                        // between each.
                        //
                        Point.y += nHeight + LINE_SPACING;

                        // Create the control and set the wingding font and arrow text.
                        //
                        hWndTemp = CreateWindow(_T("STATIC"), _T(""), WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE, Point.x, Point.y, CHECK_WIDTH, nHeight, hDlg, NULL, g_hInst, NULL);
                        InitWingdingFont(hWndTemp);
                        szWingDing[0] = (TCHAR) WINGDING_ARROW;
                        SetWindowText(hWndTemp, szWingDing);

                        // Bold the current item if we can.
                        //
                        if ( lphWnd && (nIndex >= 0) )
                        {
                                if ( hBoldFont == NULL )
                                        hBoldFont = GetFont(*(lphWnd + nIndex), NULL, 10, FW_BOLD);
                                        
                                if ( hBoldFont )
                                        SendMessage(*(lphWnd + nIndex), WM_SETFONT, (WPARAM) hBoldFont, MAKELPARAM(TRUE, 0));
                        }

                        return TRUE;

                default:
                        return FALSE;
        }
}


static VOID InitWingdingFont(HWND hWndCtrl)
{
        static HFONT    hCheckFont = NULL;
        TCHAR                   szFontName[32];
        DWORD                   dwFontSize;

        // If NULL is passed in, we should free the font handle.
        //
        if ( hWndCtrl == NULL )
        {
                // Free the font handle.
                //
                if ( hCheckFont )
                        DeleteObject(hCheckFont);
        }
        else
        {
                // We may already have the handle to the font we need,
                // but if not, we need to get it.
                //
                if ( hCheckFont == NULL )
                {
                        // Get the font size.
                        //
                        if ( LoadString(NULL, IDS_CHECKFONTSIZE, szFontName, sizeof(szFontName) / sizeof(TCHAR)) )
                                dwFontSize = _tcstoul(szFontName, NULL, 10);
                        else
                                dwFontSize = 12;

                        // Get the font name.
                        //
                        if ( !LoadString(NULL, IDS_CHECKFONTNAME, szFontName, sizeof(szFontName) / sizeof(TCHAR)) )
                                lstrcpy(szFontName, _T("Wingdings"));

                        hCheckFont = GetFont(hWndCtrl, szFontName, dwFontSize, FW_BOLD, TRUE);
                }

                // Now send the font to the control.
                //
                if ( hCheckFont )
                        SendMessage(hWndCtrl, WM_SETFONT, (WPARAM) hCheckFont, MAKELPARAM(TRUE, 0));
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\summary.h ===
//////////////////////////////////////////////////////////////////////////////
//
// SUMMARY.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all external include files, defined values, macros, data
//  structures, and fucntion prototypes for the corisponding CXX file.
//
//  Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////



// Only include this file once.
//
#ifndef _SUMMARY_H_
#define _SUMMARY_H_


// Include file(s).
//
#include <windows.h>
#include "main.h"


// External function prototype(s).
//
VOID InitSummaryList(HWND, LPTASKDATA);
BOOL SummaryDrawItem(HWND, const DRAWITEMSTRUCT *);


#endif // _SUMMARY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\scm.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// SCM.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Contains the Service Control Manager functions used in Tuneup.
//
//  9/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include files.
//
#include <windows.h>


// Internal function prototypes.
//
static SC_HANDLE	ServiceOpen(LPCTSTR);
static DWORD		ServicePending(SC_HANDLE);


//
// External function(s).
//


BOOL ServiceStart(LPCTSTR szServiceName)
{
	BOOL		bReturn		= TRUE;
	SC_HANDLE	hService	= ServiceOpen(szServiceName);

	if ( hService )
	{
		// First start the service and wait for it to startup.
		//
		if ( (ServicePending(hService) != SERVICE_RUNNING) &&
			 ( (!StartService(hService, 0, NULL)) || (ServicePending(hService) != SERVICE_RUNNING) ) )
			bReturn = FALSE;

		// If it is started, change it's startup to automatic.
		//
		if ( bReturn )
			ChangeServiceConfig(hService, SERVICE_NO_CHANGE, SERVICE_AUTO_START, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

		CloseServiceHandle(hService);
		return bReturn;
	}
	return FALSE;
}


BOOL ServiceRunning(LPCTSTR szServiceName) 
{
    BOOL		bReturn		= FALSE;
	SC_HANDLE	hService	= ServiceOpen(szServiceName);

	if ( hService )
	{
		if ( ServicePending(hService) == SERVICE_RUNNING )
			bReturn = TRUE;
		CloseServiceHandle(hService);
	}
	return bReturn;
}



//
// Internal function(s).
//


static SC_HANDLE ServiceOpen(LPCTSTR szServiceName)
{
    SC_HANDLE   hSCManager,
                hService;

    // Open the Service Control Manager database.
    //
    if ( (hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)) == NULL )
        return NULL;

    // Open the service.
    //
    hService = OpenService(
        hSCManager,         // handle to service control manager database 
        szServiceName,      // pointer to name of service to start 
        SERVICE_ALL_ACCESS  // type of access to service 
    );

    // Close the handle to the service Control Manager database.
    //
    CloseServiceHandle(hSCManager);

    // Return the handle to the service, or NULL if it failed.
    //
    return hService;
}


static DWORD ServicePending(SC_HANDLE schService)
{
	SERVICE_STATUS	ssStatus;
	DWORD			dwOldCheckPoint;
	BOOL			bCheck = TRUE,
					bQuery;

	ZeroMemory(&ssStatus, sizeof(SERVICE_STATUS));
	bQuery = QueryServiceStatus(schService, &ssStatus);
	while ( ( bQuery && bCheck ) &&
		    ( (ssStatus.dwCurrentState == SERVICE_START_PENDING) ||
		      (ssStatus.dwCurrentState == SERVICE_STOP_PENDING) ||
		      (ssStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
		      (ssStatus.dwCurrentState == SERVICE_PAUSE_PENDING)
		    )
		  )
	{
		dwOldCheckPoint = ssStatus.dwCheckPoint;
		Sleep(ssStatus.dwWaitHint);
		bQuery = QueryServiceStatus(schService, &ssStatus);
		bCheck = (dwOldCheckPoint < ssStatus.dwCheckPoint);
		dwOldCheckPoint = ssStatus.dwCheckPoint; 
	}
	return ssStatus.dwCurrentState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\summary.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// SUMMARY.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Functions for the summary wizard page.
//
//  8/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include file(s).
//
#include "main.h"
#include <shellapi.h>
#include "schedwiz.H"


VOID InitSummaryList(HWND hwndLb, LPTASKDATA lpTasks)
{
	LPTSTR		lpTime,
				lpSummary;
	SHFILEINFO	SHFileInfo;
	INT			iIndex;

	SendMessage(hwndLb, LB_RESETCONTENT, 0, 0L );
	while (lpTasks)
	{
		if ( !(g_dwFlags & TUNEUP_CUSTOM) || (lpTasks->dwOptions & TASK_SCHEDULED) )
		{
			if ( lpTime = GetNextRunTimeText(lpTasks->pTask, lpTasks->dwFlags) )
			{
				// Get the text to use for the summary.  The summary text is preffered,
				// but may be NULL so then we would have to use the title, which is required.
				//
				if ( lpTasks->lpSummary )
					lpSummary = lpTasks->lpSummary;
				else
					lpSummary = lpTasks->lpTitle;

				// Add the summary line to the list box.
				//
				if ( (iIndex = (INT)SendMessage(hwndLb, LB_ADDSTRING, 0, (LPARAM) lpSummary)) >= 0 )
				{
					SHGetFileInfo(lpTasks->lpFullPathName, 0, &SHFileInfo, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_SMALLICON);
					SendMessage(hwndLb, LB_SETITEMDATA, iIndex, (LPARAM) SHFileInfo.hIcon);
					SendMessage(hwndLb, LB_ADDSTRING, 0, (LPARAM) lpTime);
				}
				//SendMessage(hwndLb, LB_ADDSTRING, 0, (LPARAM) _T(""));
#if 0
				if ( lpAll = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(lpSummary) + lstrlen(lpTime) + 2)) )
				{
					wsprintf(lpAll, _T("%s\n%s"), lpSummary, lpTime);
					SendMessage(hwndLb, LB_ADDSTRING, 0, (LPARAM) lpAll);
					FREE(lpAll);
				}
#endif
				FREE(lpTime);
			}
		}
		lpTasks = lpTasks->lpNext;
	}
}


BOOL SummaryDrawItem(HWND hWnd, const DRAWITEMSTRUCT * lpDrawItem)
{

    TCHAR		szBuffer[MAX_PATH];
	DWORD		dwColor;
	HBRUSH		hbrBack;
	HICON		hIcon;

	if ( lpDrawItem->itemAction != ODA_DRAWENTIRE )
		return TRUE;

	// Get the window color so we can clear the listbox item.
	//
	dwColor = GetSysColor(COLOR_WINDOW);

	// Fill entire item rectangle with the appropriate color.
	//
	hbrBack = CreateSolidBrush(dwColor);
	FillRect(lpDrawItem->hDC, &(lpDrawItem->rcItem), hbrBack);
	DeleteObject(hbrBack);

	// Display the icon associated with the item.
	//
	if ( hIcon = (HICON) SendMessage(lpDrawItem->hwndItem, LB_GETITEMDATA, lpDrawItem->itemID, (LPARAM) 0) )
	{
		// Draw the file icon.
		//
		DrawIconEx(	lpDrawItem->hDC,
					lpDrawItem->rcItem.left,
					lpDrawItem->rcItem.top,
					hIcon,
					lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top,
					lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top,
					0,
					0,
					DI_NORMAL);
	}

	// Display the text associated with the item.
	//
	SendMessage(lpDrawItem->hwndItem, LB_GETTEXT, lpDrawItem->itemID, (LPARAM) szBuffer);

	TextOut(	lpDrawItem->hDC,
				lpDrawItem->rcItem.left + lpDrawItem->rcItem.bottom - lpDrawItem->rcItem.top + 2,
				lpDrawItem->rcItem.top + 1,
				szBuffer,
				lstrlen(szBuffer));

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\tasks.h ===
//////////////////////////////////////////////////////////////////////////////
//
// TASKS.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all internal and external include files, defined values, macros,
//  data structures, and fucntion prototypes for the corisponding CXX file.
//
//  Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////



// Only include this file once.
//
#ifndef _TASKS_H_
#define _TASKS_H_


// Include file(s).
//
#include <windows.h>
#include "main.h"


// External function prototype(s).
//
LPTASKDATA	CreateTasks(VOID);
VOID		FreeTasks(LPTASKDATA);
DWORD		TasksScheduled(LPTASKDATA);
BOOL		InitGenericTask(HWND);


#endif // _TASKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\timeschm.h ===
//////////////////////////////////////////////////////////////////////////////
//
// TIMESCHM.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all external include files, defined values, macros, data
//  structures, and fucntion prototypes for the corisponding CXX file.
//
//  Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////



// Only include this file once.
//
#ifndef _TIMESCHM_H_
#define _TIMESCHM_H_


// Include file(s).
//
#include <windows.h>


// External function prototype(s).
//
VOID UpdateTimeScheme(HWND);


#endif // _TIMESCHM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\tasks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// TASKS.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  7/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Internal include file(s).
//
#include "main.h"
#include "scm.h"


// Internal defince value(s).
//
#define TUNEUP_TASK_CI	0x00000001
#define SERVICE_CISVC	_T("CISVC")


// Internal data structure(s).
//
typedef struct _DEFTASKS
{
	INT		nPageID;			// Resource ID for the dialog used in the wizard page.
	LPTSTR	lpAppName;			// File name of the task to schedule.
	LPTSTR	lpParameters;		// Parameters for the application.
	LPTSTR	lpSetParam;			// Command line to execute for the settings button.
	DWORD	dwFlags;			// Default flags to use for the job.
	DWORD	dwOptions;			// Default tuneup options for the task.
	INT		nSchedule;			// The task schedule.
	INT		nTitle;				// Resource ID for the title of the wizard page.
	INT		nSubTitle;			// Resource ID for the subtitle of the wizard.
	INT		nDescription;		// Resource ID for the description on the wizard page.
	INT		nJobName;			// Resource ID for the string used for the job name of the task.
	INT		nJobComment;		// Resource ID for the string used for the job comment of the task.
	INT		nYesAction;			// Resource ID for the string used in the Yes option button.  Only for IDD_TASKS pages.
	INT		nNoAction;			// Resource ID for the string used in the No option button.  Only for IDD_TASKS pages.
	INT		nSummary;			// Resource ID for the string used in on the summary page.
	DWORD	nSpecial;			// Special identifier for tasks that require specific code.
} DEFTASKS, *PDEFTASKS, *LPDEFTASKS;


// Internal function prtotype(s).
//
static BOOL CALLBACK	ThirdPartyAddOn(HKEY, LPTSTR, LPARAM);
static LPTASKDATA		AllocateTaskData(LPTASKDATA *);



//
// External function(s).
//


LPTASKDATA CreateTasks(VOID)
{
	LPDEFTASKS	lpDefTask;
	LPTASKDATA	lpCurrent,
				lpHead = NULL;
	BOOL		bAdd;
	TCHAR		szPathBuffer[MAX_PATH];

	// This is how we now what the default tasks are.  You can simply
	// add any tasks to this list that you want.
	//
	DEFTASKS DefaultTasks[] =
	{
		//{ IDD_TASK,       _T("SMTIDY.EXE"),    _T(""),                _T(""),            DEFAULT_TASK_FLAG2,  0,            TASK_MONTHLY,    IDS_TITLE_SMTIDY,     IDS_SUBTITLE_SMTIDY,     IDS_DESC_SMTIDY,    IDS_TASK_SMTIDY,    IDS_CMT_SMTIDY,    IDS_TEXT_SMTIDY},
		{ IDD_TASK,       _T("SCANDISK.EXE"),  _T("/sagerun:0"),      _T("/sageset:0"),  DEFAULT_TASK_FLAG,   0,            TASK_WEEKLY,     IDS_TITLE_CHKDSK,     IDS_SUBTITLE_CHKDSK,     IDS_DESC_CHKDSK,    IDS_TASK_CHKDSK,    IDS_CMT_CHKDSK,    IDS_YES_CHKDSK,		IDS_NO_CHKDSK,		IDS_SUM_CHKDSK,    0},
		{ IDD_CLEANUP,    _T("CLEANMGR.EXE"),  _T("/sagerun:0"),      _T("/sageset:0"),  DEFAULT_TASK_FLAG2,  TASK_NOIDLE,  TASK_MONTHLY,    IDS_TITLE_CLEANUP,    IDS_SUBTITLE_CLEANUP,    IDS_DESC_CLEANUP,   IDS_TASK_CLEANUP,   IDS_CMT_CLEANUP,   0,					0,					IDS_SUM_CLEANUP,   0},
		{ IDD_TASK,       _T("TUNEUP.EXE"),    _T("/service:cisvc"),  NULL,              DEFAULT_TASK_FLAG,   0,            TASK_ONCE,       IDS_TITLE_CIDAEMON,   IDS_SUBTITLE_CIDAEMON,   IDS_DESC_CIDAEMON,  IDS_TASK_CIDAEMON,  IDS_CMT_CIDAEMON,  IDS_YES_CIDAEMON,	IDS_NO_CIDAEMON,	IDS_SUM_CIDAEMON,  TUNEUP_TASK_CI},
		//{ IDD_TASK,       _T("NTBACKUP.EXE"),  _T(""),                _T(""),            DEFAULT_TASK_FLAG,   0,            TASK_MONTHLY,    IDS_TITLE_BACKUP,     IDS_SUBTITLE_BACKUP,     IDS_TASK_BACKUP,    IDS_CMT_BACKUP,    IDS_TEXT_BACKUP},
		{ 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  // The first field of the last item must be zero.
	};

	// Loop through all the default tasks.
	//
	for (lpDefTask = DefaultTasks; lpDefTask->nPageID != 0; lpDefTask++)
	{
		// First make sure we need this page in case there is a condition where we
		// shouldn't display it (just for content indexing now).
		//
		switch (lpDefTask->nSpecial)
		{
			case TUNEUP_TASK_CI:
				bAdd = (IsUserAdmin() && !ServiceRunning(SERVICE_CISVC));
				break;
			default:
				bAdd = TRUE;
		}

		// Allocate the memory for this task's data structure.
		//
		if ( bAdd && (lpCurrent = AllocateTaskData(&lpHead)) )
		{
			//
			// Now we need to setup all the settings we need
			// to create this task's job in Task Scheduler.
			//
			// These structure items must be filled in:
			// lpFullPathName, lpParameters, lpSetParam,
			// lpJobName, lpComment, nSchedule, dwFlags,
			// dwOptions.
			//			

			// Get the full path and app name (lpFullPathName).  The default path for all the
			// default tasks is the system32 directory.
			//
			if ( GetSystemDirectory(szPathBuffer, sizeof(szPathBuffer)) )
			{
				lstrcat(szPathBuffer, _T("\\"));
				lstrcat(szPathBuffer, lpDefTask->lpAppName);
				if ( lpCurrent->lpFullPathName = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(szPathBuffer) + 1)) )
					lstrcpy(lpCurrent->lpFullPathName, szPathBuffer);
			}

			// Get the app name (lpParameters) from the default task structure.
			//
			if ( lpCurrent->lpParameters = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(lpDefTask->lpParameters) + 1)) )
				lstrcpy(lpCurrent->lpParameters, lpDefTask->lpParameters);


			// Get the settings button parameters.  We leave the settings name to null because
			// the default tasks use the same exe as the task, just with different command line parameters.
			//
			if ( ( lpDefTask->lpSetParam ) &&
			     ( lpCurrent->lpSetParam = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(lpDefTask->lpSetParam) + 1)) ) )
				lstrcpy(lpCurrent->lpSetParam, lpDefTask->lpSetParam);

			// Get the job name (lpJobName) from the string table.
			//
			lpCurrent->lpJobName = AllocateString(NULL, lpDefTask->nJobName);

			// Get the name of the job comment (lpComment) from the string table.
			//
			lpCurrent->lpComment = AllocateString(NULL, lpDefTask->nJobComment);

			// Set the schedule for this job (nSchedule).
			//
			lpCurrent->nSchedule = lpDefTask->nSchedule;

			// Set the default flags for this job (dwFlags).
			//
			lpCurrent->dwFlags = lpDefTask->dwFlags;

			// Set the default tuneup options for this job (dwOptions).
			//
			lpCurrent->dwOptions = lpDefTask->dwOptions;


			//
			// Now we are going to setup all the data to create
			// this task's wizard page in Tuneup.  All the task
			// structure items for the wizard must be filled in.
			//

			// Get the resource ID for the dialog.
			//
			lpCurrent->nPageID = lpDefTask->nPageID;

			// Get the other strings needed by the wizard.
			//
			lpCurrent->lpTitle = AllocateString(NULL, lpDefTask->nTitle);
			lpCurrent->lpSubTitle = AllocateString(NULL, lpDefTask->nSubTitle);
			lpCurrent->lpDescription = AllocateString(NULL, lpDefTask->nDescription);
			lpCurrent->lpYesAction = AllocateString(NULL, lpDefTask->nYesAction);
			lpCurrent->lpNoAction = AllocateString(NULL, lpDefTask->nNoAction);
			lpCurrent->lpSummary = AllocateString(NULL, lpDefTask->nSummary);
		}
	}

	// Now loop through all the third-party tasks.
	//
	RegEnumKeys(HKLM, g_szRegKeyAddOns, ThirdPartyAddOn, (LPARAM) &lpHead, FALSE);

	// Return the head of this list.
	//
	return lpHead;
}


VOID FreeTasks(LPTASKDATA lpTask)
{
	// Don't free NULL data (this is the last item).
	//
	if ( lpTask != NULL )
	{
		// First free the next guy in the list.
		//
		FreeTasks(lpTask->lpNext);

		// Free all the job data.  The FREE macro
		// will make sure that it isn't freeing NULL.
		//
		FREE(lpTask->lpFullPathName);
		FREE(lpTask->lpParameters);
		FREE(lpTask->lpSetName);
		FREE(lpTask->lpSetParam);
		FREE(lpTask->lpJobName);
		FREE(lpTask->lpComment);

		// Free all the wizard data.
		//
		FREE(lpTask->lpTitle);
		FREE(lpTask->lpSubTitle);
		FREE(lpTask->lpDescription);
		FREE(lpTask->lpYesAction);
		FREE(lpTask->lpNoAction);
		FREE(lpTask->lpSummary);

		// Now finally free the actuall task item.
		//
		FREE(lpTask);
	}
}


DWORD TasksScheduled(LPTASKDATA lpTasks)
{
	DWORD dwFound = 0;

	while ( lpTasks )
	{
		if ( !(g_dwFlags & TUNEUP_CUSTOM) || (lpTasks->dwOptions & TASK_SCHEDULED) )
			dwFound++;
		lpTasks = lpTasks->lpNext;
	}

	return dwFound;
}


static BOOL CALLBACK ThirdPartyAddOn(HKEY hKey, LPTSTR lpKey, LPARAM lParam)
{
	LPTASKDATA			lpCurrent;
	LPTSTR				lpBuffer,
						lpString;

	// Allocate the memory for this task's data structure.
	//
	if ( lpCurrent = AllocateTaskData((LPTASKDATA *) lParam) )
	{
		//
		// Now we need to setup all the settings we need
		// to create this task's job in Task Scheduler.
		//
		// These structure items must be filled in:
		// lpFullPathName, lpParameters, lpSetParam,
		// lpJobName, lpComment, nSchedule, dwFlags,
		// dwOptions.
		//			

		// Get the full path and app name (lpFullPathName).
		//
		lpCurrent->lpFullPathName = RegGetString(hKey, NULL, g_szRegValProgram);

		// Get the app name (lpParameters) from the registry.
		//
		lpCurrent->lpParameters = RegGetString(hKey, NULL, g_szRegValProgParam);

		// Get the settings button exe and parameters.
		//
		lpCurrent->lpSetName = RegGetString(hKey, NULL, g_szRegValSettings);
		lpCurrent->lpSetParam = RegGetString(hKey, NULL, g_szRegValSetParam);

		// Get the job name (lpJobName) from the registry.
		//
		lpCurrent->lpJobName = RegGetString(hKey, NULL, g_szRegValJobName);

		// Get the name of the job comment (lpComment) from the registry.
		//
		lpCurrent->lpComment = RegGetString(hKey, NULL, g_szRegValComment);

		// Set the schedule for this job (nSchedule).
		//
		if ( lpBuffer = RegGetString(hKey, NULL, g_szRegValSchedule) )
		{
			lpCurrent->nSchedule = *lpBuffer - _T('0');
			FREE(lpBuffer);
		}

		// Set the default flags for this job (dwFlags).
		//
		lpCurrent->dwFlags = DEFAULT_TASK_FLAG;		

		//
		// Now we are going to setup all the data to create
		// this task's wizard page in Tuneup.  All the task
		// structure items for the wizard must be filled in.
		//

		// Set the resource ID for the dialog.
		//
		lpCurrent->nPageID = IDD_TASK;

		// Get the other strings needed by the wizard.
		//
		lpCurrent->lpTitle = RegGetString(hKey, NULL, g_szRegValTitle);
		lpCurrent->lpSubTitle = RegGetString(hKey, NULL, g_szRegValSubtitle);
		lpCurrent->lpDescription = RegGetString(hKey, NULL, g_szRegValDescription);
		lpCurrent->lpSummary = RegGetString(hKey, NULL, g_szRegValSummary);

		// Get and hold the action text in case we need it.
		//
		lpString = RegGetString(hKey, NULL, REG_VAL_ACTION);

		// Get the yes action option text for the wizard page.
		//
		if ( (lpCurrent->lpYesAction = RegGetString(hKey, NULL, g_szRegValYesAction)) == NULL )
		{
			// Since the no specific registry key wasn't there, we can create the
			// string from the action text and the '&Yes, ' prefix.
			//
			if ( lpString && (lpBuffer = AllocateString(NULL, IDS_YES)) )
			{
				if ( lpCurrent->lpYesAction = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(lpString) + lstrlen(lpBuffer) + 1)) )
					wsprintf(lpCurrent->lpYesAction, _T("%s%s"), lpBuffer, lpString);
				FREE(lpBuffer);
			}
		}

		// Get the no action option text for the wizard page.
		//
		if ( (lpCurrent->lpNoAction = RegGetString(hKey, NULL, g_szRegValNoAction)) == NULL )
		{
			// Since the no specific registry key wasn't there, we can create the
			// string from the action text and the 'No, &don't ' prefix.
			//
			if ( lpString && (lpBuffer = AllocateString(NULL, IDS_NO)) )
			{
				if ( lpCurrent->lpNoAction = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(lpString) + lstrlen(lpBuffer) + 1)) )
					wsprintf(lpCurrent->lpNoAction, _T("%s%s"), lpBuffer, lpString);
				FREE(lpBuffer);
			}
		}

		// Free the action text if we allocated it (FREE macro checks for us).
		//
		FREE(lpString);

		// Now lets make sure there is enough info for this item.  If not we
		// need to free it so we don't display the page.
		//
		if ( ( lpCurrent->lpFullPathName == NULL ) ||
		     ( !(EXIST(lpCurrent->lpFullPathName)) ) ||
		     ( lpCurrent->nSchedule < TASK_ONCE ) ||
		     ( lpCurrent->nSchedule > TASK_YEARLY ) ||
		     ( lpCurrent->lpJobName == NULL) ||
		     ( lpCurrent->lpTitle == NULL ) ||
		     ( lpCurrent->lpYesAction == NULL ) ||
		     ( lpCurrent->lpNoAction == NULL ) )
		{
			// Passing in NULL to this function will cause it to
			// free the last item allocated.
			//
			AllocateTaskData(NULL);
		}
	}

	// Always return true so the enum will continue.
	//
	return TRUE;
}


static LPTASKDATA AllocateTaskData(LPTASKDATA * lpHead)
{
	// The current pointer needs to be static so that we can setup
	// the the next and back pointers after allocating the next
	// task data item.
	//
	static LPTASKDATA	lpCurrent	= NULL;
	LPTASKDATA			lpBuffer	= NULL;

	// lpHead can not be NULL.  If it is, then we want to free
	// the last page allocated (used so if we decide that the third
	// party program doesn't have enough info in the registry for
	// us to use it, we can remove it).
	//
	if ( lpHead == NULL )
	{
		// Make sure there is a last item to free.
		//
		if ( lpCurrent )
		{
			// Record the current lpCurrent pointer so we can free
			// it later.
			//
			lpBuffer = lpCurrent;

			// Back up the lpCurrent pointer to the previous item
			// and Null out its next pointer so that it doesn't
			// think that this item still exists.
			//
			lpCurrent = lpCurrent->lpBack;
			lpCurrent->lpNext = NULL;

			// Now free the orphaned last item.
			//
			FreeTasks(lpBuffer);
		}
		return NULL;
	}

	// Allocate the memory for this task's data structure.
	//
	if ( lpBuffer = (LPTASKDATA) MALLOC(sizeof(TASKDATA)) )
	{
		//
		// We need to setup the next and back pointers
		// for the doubly linked list.
		//

		// Record the new pointer in the next of the pervious (current)
		// data.
		//
		if ( *lpHead && lpCurrent )
		{
			lpCurrent->lpNext = lpBuffer;
			lpBuffer->lpBack = lpCurrent;
		}
		// Or the head if this is the first item.
		//
		else
			*lpHead = lpBuffer;

		// Then set the current pointer to the new buffer.
		//
		lpCurrent = lpBuffer;
	}

	return lpBuffer;
}


BOOL InitGenericTask(HWND hDlg)
{
	// Setup the "Yes" and "No" option string.
	//
	SetDlgItemText(hDlg, IDC_YES, g_CurrentTask->lpYesAction);
	SetDlgItemText(hDlg, IDC_DENY, g_CurrentTask->lpNoAction);

	// We can free these now, because we don't need them anymore.
	// The FREE macro also sets the pointer to NULL so we don't free
	// it again when we close the program.
	//
	FREE(g_CurrentTask->lpYesAction);
	FREE(g_CurrentTask->lpNoAction);

	// Disable the settings button if there is nothing for it to do.
	//
	if ( ( g_CurrentTask->lpSetName == NULL ) &&
	     ( g_CurrentTask->lpSetParam == NULL) )
		EnableWindow(GetDlgItem(hDlg, IDC_SETTING), FALSE);

	// Always return false.
	//
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\timeschm.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// TIMESCHM.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Functions for the startup startmenu group wizard page.
//
//  7/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


// Include file(s).
//
#include "main.h"
#include "schedwiz.h"



VOID UpdateTimeScheme(HWND hDlg)
{
	INT	nButtons[] = { IDC_NIGHT, IDC_DAY, IDC_EVENING, 0 },
		nIndex = -1;

	// Get the selected radio button.
	//
	while ( nButtons[++nIndex] && !IsDlgButtonChecked(hDlg, nButtons[nIndex]) );

	// Check to see if the time scheme changed.
	//
	if ( nButtons[nIndex] )
	{
		// Update the time scheme.
		//
		g_nTimeScheme = nButtons[nIndex];

		// Update the jobs.
		//
		SetTimeScheme(g_nTimeScheme);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\wizard.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// WIZARD.CPP / Tuneup
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Wizard creation and common functions.
//
//  7/98 - Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////


//
// Include file(s).
//

#include "main.h"
#include <windowsx.h>
#include <commctrl.h>
#include <prsht.h>
#include "startup.h"
#include "schedwiz.h"
#include "tasks.h"
#include "timeschm.h"
#include "cleanup.h"
#include "summary.h"
#include "runnow.h"


//
// Internal structure(s).
//

typedef struct _WIZPAGE
{
	INT					iDialog;
	LPTSTR				lpTitle;
	LPTSTR				lpSubTitle;
	struct _WIZPAGE *	lpNext;
} WIZPAGE, *PWIZPAGE, *LPWIZPAGE;


//
// Inernal function prototype(s).
//

// Wizard proc.
//
static INT_PTR APIENTRY WizardPageProc(HWND, UINT, WPARAM, LPARAM);

// Message proccessing functions.
//
static BOOL OnInit(HWND, INT);
static VOID OnDestroy(HWND, INT);
static VOID OnCommand(HWND, INT, HWND, UINT);
static BOOL OnNotify(HWND, INT, INT);
static BOOL OnDrawItem(HWND, const DRAWITEMSTRUCT *);

// Other common wizard functions.
//
static VOID			InitBoldFont(HWND);
static VOID			FreeWizPages(LPWIZPAGE);
static LPWIZPAGE	CreateWizPage(LPWIZPAGE, INT, LPTSTR, LPTSTR);



INT CreateWizard(HINSTANCE hInstance, HWND hWndParent)
{
	LPPROPSHEETPAGE	lppsPage;
    PROPSHEETHEADER	psHeader;
	DWORD			dwPages = 0;
	INT				iReturn;
	LPWIZPAGE		lpWizPageHead,
					lpWizPageBuffer;
	LPTASKDATA		lpTasks;

	// Make sure the common constrols are loaded and ready to use.
	//
	InitCommonControls();

	// Set the current job pointer to the begining of
	// or global list of jobs.
	//
	g_CurrentTask = g_Tasks;

	// We always have the welcome dialog in the wizard.
	// If the first memory allocation fails, we have to bail.
	//
	if ( lpWizPageHead = (LPWIZPAGE) MALLOC(sizeof(WIZPAGE)) )
	{
		lpWizPageBuffer = lpWizPageHead;
		lpWizPageBuffer->iDialog = IDD_WELCOME;
	}
	else
		return -1;

	// Add the time page.
	//
	lpWizPageBuffer = CreateWizPage(lpWizPageBuffer, IDD_TIME, MAKEINTRESOURCE(IDS_TITLE_TIME), MAKEINTRESOURCE(IDS_SUBTITLE_TIME));

	// Add the startup group page.
	//
	if ( IsUserAdmin() || UserHasStartupItems() )
		lpWizPageBuffer = CreateWizPage(lpWizPageBuffer, IDD_STARTMENU, MAKEINTRESOURCE(IDS_TITLE_STARTMENU), MAKEINTRESOURCE(IDS_SUBTITLE_STARTMENU));

	// Create all the task pages.
	//
	for (lpTasks = g_Tasks; lpTasks; lpTasks = lpTasks->lpNext)
		lpWizPageBuffer = CreateWizPage(lpWizPageBuffer, lpTasks->nPageID, lpTasks->lpTitle, lpTasks->lpSubTitle);

	// Add the backup group page.
	//
	//lpWizPageBuffer = CreateWizPage(lpWizPageBuffer, IDD_BACKUP, MAKEINTRESOURCE(IDS_TITLE_BACKUP), MAKEINTRESOURCE(IDS_SUBTITLE_BACKUP));
	
	// We always have the summary page.
	// If this memory allocation fails, we must
	// free the others and bail out.
	//
	if ( lpWizPageBuffer->lpNext = (LPWIZPAGE) MALLOC(sizeof(WIZPAGE)) )
	{
		lpWizPageBuffer = lpWizPageBuffer->lpNext;
		lpWizPageBuffer->iDialog = IDD_SUMMARY;
		lpWizPageBuffer->lpNext = NULL;
		
	}
	else
	{
		lpWizPageBuffer->lpNext = NULL;
		FreeWizPages(lpWizPageHead);
		return -1;
	}

	// Get the number of pages.
	//
	for (lpWizPageBuffer = lpWizPageHead; lpWizPageBuffer; lpWizPageBuffer = lpWizPageBuffer->lpNext)
		dwPages++;
	
	// Alocate all the memory needed for all the wizard pages.
	//
	if ( (psHeader.ppsp = (LPCPROPSHEETPAGE) MALLOC(dwPages * sizeof(PROPSHEETPAGE))) == NULL )
	{
		FreeWizPages(lpWizPageHead);
		return -1;
	}

	// Setup the property sheet header.
	//
	psHeader.dwSize			= sizeof(PROPSHEETHEADER);
	psHeader.hwndParent		= hWndParent;
	psHeader.nPages			= dwPages;
	psHeader.nStartPage		= 0;
	psHeader.hInstance		= hInstance;
    psHeader.pszIcon		= MAKEINTRESOURCE(IDI_TUNEUP);
#ifdef OLDWIZ
	psHeader.dwFlags		= PSH_USEICONID | PSH_PROPSHEETPAGE | PSH_WIZARD;
#else
	// Wizard 97 only info.
	//
	psHeader.dwFlags		= PSH_USEICONID | PSH_PROPSHEETPAGE | PSH_WIZARD97 | PSH_HEADER | PSH_WATERMARK;
	psHeader.pszbmWatermark	= MAKEINTRESOURCE(IDB_WATERMARK);
	psHeader.pszbmHeader	= MAKEINTRESOURCE(IDB_HEADER);
#endif

	// Setup all the page sheet structures.
	//
	for ( lppsPage = (LPPROPSHEETPAGE) psHeader.ppsp, lpWizPageBuffer = lpWizPageHead;
	      lppsPage - psHeader.ppsp < (INT) dwPages && lpWizPageBuffer;
	      lppsPage++, lpWizPageBuffer = lpWizPageBuffer->lpNext)
	{
		// Assign all the values for this property sheet.
		//
		lppsPage->dwSize			= sizeof(PROPSHEETPAGE);
		lppsPage->hInstance			= hInstance;
		lppsPage->pszTemplate		= MAKEINTRESOURCE(lpWizPageBuffer->iDialog);
		lppsPage->pfnDlgProc		= WizardPageProc;
		lppsPage->pszTitle			= MAKEINTRESOURCE(IDS_TUNEUP);
		lppsPage->lParam			= lpWizPageBuffer->iDialog;
#ifndef OLDWIZ
		// Wizard 97 only info.
		//
		switch (lpWizPageBuffer->iDialog)
		{
			case IDD_WELCOME:
			case IDD_SUMMARY:
				lppsPage->dwFlags			= PSP_USETITLE | PSP_HIDEHEADER;
				break;
			default:
				lppsPage->dwFlags			= PSP_USETITLE | PSP_USEHEADERSUBTITLE | PSP_USEHEADERTITLE;
				lppsPage->pszHeaderTitle	= lpWizPageBuffer->lpTitle;
				lppsPage->pszHeaderSubTitle	= lpWizPageBuffer->lpSubTitle;
		}
#endif
	}

	// Create the wizard and save the return code.
	//
	iReturn = (INT)PropertySheet(&psHeader);

	// Free the memory for the property sheet wizard pages.
	//
	FREE(psHeader.ppsp);
	FreeWizPages(lpWizPageHead);

	// Return positive value if successfull.
	//
	return(iReturn);
}


static INT_PTR APIENTRY WizardPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
//	LPPROPSHEETPAGE	lpsp;
//	PAINTSTRUCT		ps;

	switch (message)
	{
		// Message cracking macros.
		//
		HANDLE_MSG(hDlg, WM_COMMAND, OnCommand);

		// Other messages to handle.
		//
		case WM_INITDIALOG:
			return OnInit(hDlg, (INT) (((LPPROPSHEETPAGE) lParam)->lParam));
		case WM_NOTIFY:
			return OnNotify(hDlg, (INT) GetWindowLongPtr(hDlg, DWLP_USER), ((NMHDR *) lParam)->code);
		case WM_DRAWITEM:
			return OnDrawItem(hDlg, (const DRAWITEMSTRUCT *) lParam);
		case WM_DESTROY:
			OnDestroy(hDlg, (INT) GetWindowLongPtr(hDlg, DWLP_USER));
			return FALSE;

		case WM_VKEYTOITEM:
			switch ( LOWORD(wParam) )
			{
				case _T(' '):
					StartupSelectItem(GetDlgItem(hDlg, IDC_STARTUP));
					return -2;
				default:
					return -1;
			}
			break;
/*
			if ( g_hBoldFont && GetDlgItem(hDlg, IDC_HIGHTEXT) )
				SendDlgItemMessage(hDlg, IDC_HIGHTEXT, WM_SETFONT, (WPARAM) g_hBoldFont, MAKELPARAM(TRUE, 0));

			InitWizardPage(hDlg, lpsp->lParam);

			if (g_hStdPal == NULL)	// We don't need to handle the bitmap in this environment.
				SendDlgItemMessage(hDlg, IDB_WIZBMP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) (HANDLE) BmpData.hDib);
			break;

		case WM_DRAWITEM:
			PaintLine((DRAWITEMSTRUCT *) lParam);
			break;

		case WM_MEASUREITEM:
			OnMeasureItem((MEASUREITEMSTRUCT *) lParam, hDlg);
			break;

		case WM_PAINT:
			if (g_hStdPal)
			{
				BeginPaint(hDlg, &ps);
				PaintBitmap(&ps);
				EndPaint(hDlg, &ps);
			}
			else
				DefWindowProc(hDlg, message, wParam, lParam);
			break;

		case WM_ACTIVATE:
			if (g_hStdPal)
				InvalidateRect(hDlg, &BmpData.rect, FALSE);
			break;		
  
		case WM_PALETTECHANGED:
			WmPaletteChanged(hDlg, wParam);
			break;

		case WM_QUERYNEWPALETTE:
			return WmQueryNewPalette(hDlg);
*/
		default:
			return FALSE;
	}
	return TRUE;
}


static BOOL OnInit(HWND hDlg, INT nPageId)
{
	BOOL	bTaskInit = FALSE;

	// Store page dialog resource in the window data for later.
	// That way we can tell what page we are on when we get a
	// notification message.
	//
	SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM) nPageId);

	// Now init the individule pages.
	//
	switch (nPageId)
	{
		case IDD_WELCOME:
			InitBoldFont(GetDlgItem(hDlg, IDC_STATIC_TITLE));
			CheckRadioButton(hDlg, IDC_EXPRESS, IDC_MANUAL, (g_dwFlags & TUNEUP_CUSTOM) ? IDC_MANUAL : IDC_EXPRESS);
			CenterWindow(GetParent(hDlg), NULL);
			break;
		case IDD_TIME:
			break;
		case IDD_STARTMENU:
			InitStartupMenu(hDlg);
			break;
		case IDD_CLEANUP:
			// Init the list box with the disk cleanup settings.
			//
			GetCleanupSettings(GetDlgItem(hDlg, IDC_LISTSET));
			bTaskInit = TRUE;
			break;
		case IDD_TASK:
			bTaskInit = TRUE;
			InitGenericTask(hDlg);
			break;
		case IDD_SUMMARY:
			InitBoldFont(GetDlgItem(hDlg, IDC_STATIC_TITLE));
			break;
	}

	// Do task init now.
	//
	if (bTaskInit)
	{
		if ( g_CurrentTask->dwOptions & TASK_SCHEDULED )
			CheckRadioButton(hDlg, IDC_YES, IDC_DENY, IDC_YES);
		else
		{
			CheckRadioButton(hDlg, IDC_YES, IDC_DENY, IDC_DENY);
			EnableWindow(GetDlgItem(hDlg, IDC_RESCHED), FALSE);
			EnableWindow(GetDlgItem(hDlg, IDC_SETTING), FALSE);
			EnableWindow(GetDlgItem(hDlg, IDC_SCHEDTEXT), FALSE);
		}
		SetDlgItemText(hDlg, IDC_TASKDESC, g_CurrentTask->lpDescription);
	}

	return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
//
// INTERNAL:
//  OnDestroy()
//              - This function is called for every wizard dialog page when
//                the wizard is terminated either by finishing or canceling.
//                This should be used to free up any resources associated with
//                any of the wizard pages.
//
// ENTRY:
//  hDlg        - Window handle to the wizard dialog being destroyed.
//  nPageId     - Dialog resource ID for the dialog being destroyed.
//
// EXIT:
//  VOID
//
//////////////////////////////////////////////////////////////////////////////

static VOID OnDestroy(HWND hDlg, INT nPageId)
{
	switch (nPageId)
	{
		case IDD_WELCOME:
		case IDD_SUMMARY:
			// Release the font we created for the welcome and summary pages.
			//
			InitBoldFont(NULL);
			break;

		case IDD_STARTMENU:
			// Need to release the data associated with the items in the combo box.
			//
			ReleaseStartupMenu(hDlg);
			break;
	}
}


static VOID OnCommand(HWND hDlg, INT id, HWND hwndCtl, UINT codeNotify)
{
	LPTSTR	lpBuffer;

	switch (id)
	{
		// Welcome page:
		//
		case IDC_EXPRESS:
			g_dwFlags &= ~TUNEUP_CUSTOM;
			break;
		case IDC_MANUAL:
			g_dwFlags |= TUNEUP_CUSTOM;
			break;

		// Time page:
		//
		case IDC_CURRENT:
		case IDC_RESET:
			EnableWindow(GetDlgItem(hDlg, IDC_NIGHT), (id == IDC_RESET));
			EnableWindow(GetDlgItem(hDlg, IDC_DAY), (id == IDC_RESET));
			EnableWindow(GetDlgItem(hDlg, IDC_EVENING), (id == IDC_RESET));
			break;

		// Startup start menu group page:
		//
#if 0 // No advanced button anymore.
		case IDC_ADVANCED:
			// Get the profiles directory and Shell Execute it.
			//
			if ( ( (lpBuffer = RegGetString(HKLM, g_szRegKeyProfiles, g_szRegValProfileDir)) == NULL ) ||
			     ( (DWORD) ShellExecute(hDlg, _T("explore"), lpBuffer, NULL, NULL, SW_SHOWNORMAL) <= 32 ) )
			{
				// Error showing the folder.
				//
				// TODO:
			}

			// Free the buffer returned by RegGetString.
			// Macro automatically checks for NULL case before freeing.
			//
			FREE(lpBuffer);
			break;
#endif
		case IDC_USERS:
			switch (codeNotify)
			{
				case CBN_SELCHANGE:
					InitStartupList(hDlg);
					break;
			}
			break;
		case IDC_STARTUP:
			if ( codeNotify == LBN_DBLCLK )
				StartupSelectItem(hwndCtl);
			break;

		// Disk space cleanup page:
		//
		case IDC_CUSETTING:
			ExecAndWait(GetParent(hDlg), g_CurrentTask->lpSetName ? g_CurrentTask->lpSetName : g_CurrentTask->lpFullPathName, g_CurrentTask->lpSetParam, NULL);
			SendDlgItemMessage(hDlg, IDC_LISTSET, LB_RESETCONTENT, 0, 0);
			GetCleanupSettings(GetDlgItem(hDlg, IDC_LISTSET));
			break;

		// Common controls to all pages:
		//
		case IDC_YES:
		case IDC_DENY:
			g_CurrentTask->dwOptions ^= TASK_SCHEDULED;
			EnableWindow(GetDlgItem(hDlg, IDC_RESCHED), id == IDC_YES);
			EnableWindow(GetDlgItem(hDlg, IDC_SETTING), ( id == IDC_YES ) && ( (g_CurrentTask->lpSetName != NULL) || (g_CurrentTask->lpSetParam != NULL) ));
			EnableWindow(GetDlgItem(hDlg, IDC_SCHEDTEXT), id == IDC_YES);
			break;
		case IDC_RESCHED:

			// Display the reschedule property sheet.
			//
			if ( JobReschedule(hDlg, g_CurrentTask->pTask) )
			{
				// If the schedule change update the display with
				// the new trigger string.
				//
				if ( lpBuffer = GetTaskTriggerText(g_CurrentTask->pTask) )
				{
					SetWindowText(GetDlgItem(hDlg, IDC_SCHEDTEXT), lpBuffer);
					FREE(lpBuffer);
				}
			}
			break;

		case IDC_SETTING:
			ExecAndWait(GetParent(hDlg), g_CurrentTask->lpSetName ? g_CurrentTask->lpSetName : g_CurrentTask->lpFullPathName, g_CurrentTask->lpSetParam, NULL);
			break;
/*
	
		case IDC_SETTING:
			nItem = PageContents[g_nPageIdx].nTaskID;
			WideCharToMultiByte(CP_ACP, 0, ItemData[nItem].pwFullPathName, -1, szTemp, MAX_PATH, NULL, NULL);

			if (nItem == TASK_SMARTTIDY)
				SetSmartTidyOption(hDlg);
			else {
				wsprintf(szParameters, (nItem == TASK_CLEANUP) ? "/TUNEUP:%d" : "/SAGESET:%d", 
						ItemData[PageContents[g_nPageIdx].nTaskID].nSageID);
				ExecAndWait(szTemp, szParameters, g_pWinDir, GetParent(hDlg), TRUE);
			}
			
			SetFocus(hDlg);
			if (nItem == TASK_CLEANUP) {
				
			}
			break;

		*/
	}
}


static BOOL OnDrawItem(HWND hWnd, const DRAWITEMSTRUCT * lpDrawItem)
{
    BOOL bReturn;

	switch (lpDrawItem->CtlID)
	{
		case IDC_STARTUP:
			bReturn = StartupDrawItem(hWnd, lpDrawItem);
			break;
		case IDC_SUMLIST:
			bReturn = SummaryDrawItem(hWnd, lpDrawItem);
			break;
		default:
			bReturn = FALSE;
	}

	SetWindowLongPtr(hWnd, DWLP_MSGRESULT, bReturn);
	return bReturn;
}


static BOOL OnNotify(HWND hDlg, INT nPageId, INT nCode)
{
	BOOL	bTest;
	LPTSTR	lpBuffer;

    switch (nCode)
	{
		case PSN_SETACTIVE:

			// Set Back, Next, Finish correctly.
			//
			PropSheet_SetWizButtons(GetParent(hDlg), (nPageId == IDD_WELCOME  ? 0 : PSWIZB_BACK) | ( (nPageId == IDD_SUMMARY) ? PSWIZB_FINISH : PSWIZB_NEXT) );

			switch (nPageId)
			{
				case IDD_WELCOME:
				case IDD_BACKUP:
				case IDD_STARTMENU:
					break;
				case IDD_TIME:
					EnableWindow(GetDlgItem(hDlg, IDC_CURRENT), !(g_dwFlags & TUNEUP_NOSCHEDULE));
					EnableWindow(GetDlgItem(hDlg, IDC_NIGHT), (g_dwFlags & TUNEUP_NOSCHEDULE));
					EnableWindow(GetDlgItem(hDlg, IDC_DAY), (g_dwFlags & TUNEUP_NOSCHEDULE));
					EnableWindow(GetDlgItem(hDlg, IDC_EVENING), (g_dwFlags & TUNEUP_NOSCHEDULE));

					if ( g_dwFlags & TUNEUP_NOSCHEDULE )						
						CheckRadioButton(hDlg, IDC_CURRENT, IDC_RESET, IDC_RESET);
					else
						CheckRadioButton(hDlg, IDC_CURRENT, IDC_RESET, IDC_CURRENT);

					CheckRadioButton(hDlg, IDC_NIGHT, IDC_EVENING, g_nTimeScheme);
					break;
				case IDD_SUMMARY:
					bTest = ( TasksScheduled(g_Tasks) > 0);
					ShowEnableWindow(GetDlgItem(hDlg, IDC_SUMTEXT), bTest);
					ShowEnableWindow(GetDlgItem(hDlg, IDC_SUMLIST), bTest);
					ShowEnableWindow(GetDlgItem(hDlg, IDC_RUNNOW), bTest);
					ShowEnableWindow(GetDlgItem(hDlg, IDC_NOTASKS), !bTest);

					if (bTest)
						InitSummaryList(GetDlgItem(hDlg, IDC_SUMLIST), g_Tasks);

					//LoadString(g_hInst, IDS_REM_NIGHT + g_nTimeScheme - IDC_NIGHT, szTemp, 256);
					//SetDlgItemText(hDlg, IDC_REMIND, szTemp);
					//InitSummaryList(GetDlgItem(hDlg, IDC_SUMMARYLIST3), nPage);
					break;
				default:
					// Update the task trigger text.
					//
					if ( lpBuffer = GetTaskTriggerText(g_CurrentTask->pTask) )
					{
						SetWindowText(GetDlgItem(hDlg, IDC_SCHEDTEXT), lpBuffer);
						FREE(lpBuffer);
					}
			}
			break;

		case PSN_WIZBACK:
			switch (nPageId)
			{
				case IDD_SUMMARY:
					if ( !(g_dwFlags & TUNEUP_CUSTOM) )
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_TIME);
					break;
				case IDD_WELCOME:
				case IDD_TIME:					
					break;
				default:
					if (g_CurrentTask->lpBack)
						g_CurrentTask = g_CurrentTask->lpBack;
			}
			break;

		case PSN_WIZNEXT:
			switch (nPageId)
			{
				case IDD_TIME:

					// Change the time scheme if needed.
					//
					if ( IsDlgButtonChecked(hDlg, IDC_RESET) )
						UpdateTimeScheme(hDlg);

					// Set this so that the next time this page is displayed,
					// we know there is already a schedule.
					//
					g_dwFlags &= ~TUNEUP_NOSCHEDULE;

					// Jump right to the summary page if we are in
					// express mode.
					//
					if ( !(g_dwFlags & TUNEUP_CUSTOM) )
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_SUMMARY);
					break;

				case IDD_WELCOME:
				case IDD_STARTMENU:
				case IDD_SUMMARY:
					break;
				default:
					if (g_CurrentTask->lpNext)
						g_CurrentTask = g_CurrentTask->lpNext;
			}
			break;

		case PSN_WIZFINISH:

			// Set this flag so that we know to save settings (like
			// cleaning up the startup groups).
			//
			g_dwFlags |= TUNEUP_FINISHED;
			ReleaseJobs(g_Tasks, g_dwFlags & TUNEUP_FINISHED);

			// Save the registry settings.
			//
			RegSetString(HKLM, g_szTuneupKey, g_szRegValFirstTime, _T("1"));
			RegSetDword(HKLM, g_szTuneupKey, g_szRegValTime, g_nTimeScheme);
			RegSetString(HKLM, g_szTuneupKey, g_szRegValCustom, (g_dwFlags & TUNEUP_CUSTOM) ? _T("1") : _T("0"));

			// Run the tasks now if the box is checked.
			//
			if ( IsDlgButtonChecked(hDlg, IDC_RUNNOW) && (TasksScheduled(g_Tasks) > 0) )
				RunTasksNow(GetParent(hDlg), g_Tasks);

			// Launch backup if we wanted to.
			//
			if ( g_dwFlags & TUNEUP_RUNBACKUP )
				ExecAndWait(GetParent(hDlg), g_szBackupExe, NULL, NULL);

			break;

		case PSN_QUERYCANCEL:
			// Now release the jobs, saving each one if we fell
			// through the above PSN_WIZFINISH.
			//
			ReleaseJobs(g_Tasks, g_dwFlags & TUNEUP_FINISHED);
			break;
		
/*
			if ( (nPage == PAGE_TIME) && (g_nTimeScheme != IDC_CUSTOM) )
				// keep the init status; we may need to reset the time scheme when leave this page, 
				nOrgTimeScheme = g_nTimeScheme = GetTimeScheme();

			ActivateWizardPage(hDlg, nPage);
			g_nPageIdx = nPage;

		case PSN_WIZFINISH:
			// start Task Scheduler if any item is scheduled
			if (IsAnythingScheduled()) {
				// Add the Key for restarting computer
				static TCHAR szKey[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices";
				HKEY	hKey;
				if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)	{
					RegSetValueEx(hKey, (LPCTSTR)"SchedulingAgent", 0, REG_SZ, (LPBYTE)"mstask.exe", 11);
					RegCloseKey(hKey);
				}
				StartScheduler();
			}

			// do all non-scheduled stuff, or run now...
			PerformAction(hDlg, IsDlgButtonChecked(hDlg, IDC_RUN_NOW));	

			// release all TaskScheduler interface/method, cal IPersist->save to write it
			ReleaseJob(TRUE);
			break;
*/
		default:
			return FALSE;
	}
	return TRUE;
}


static VOID InitBoldFont(HWND hWndCtrl)
{
	static HFONT	hBigFont = NULL;
	TCHAR			szFontName[32];
	DWORD			dwFontSize;

	// If NULL is passed in, we should free the font handle.
	//
	if ( hWndCtrl == NULL )
	{
		// Free the font handle.
		//
		if (hBigFont)
			DeleteObject(hBigFont);
	}
	else
	{
		// We may already have the handle to the font we need,
		// but if not, we need to get it.
		//
		if ( hBigFont == NULL )
		{
			// Get the font size.
			//
			if ( LoadString(NULL, IDS_TITLEFONTSIZE, szFontName, sizeof(szFontName) / sizeof(TCHAR)) )
				dwFontSize = _tcstoul(szFontName, NULL, 10);
			else
				dwFontSize = 12;

			// Get the font name.
			//
			if ( !LoadString(NULL, IDS_TITLEFONTNAME, szFontName, sizeof(szFontName) / sizeof(TCHAR)) )
				lstrcpy(szFontName, _T("Verdana"));

			hBigFont = GetFont(hWndCtrl, szFontName, dwFontSize, FW_BOLD);
		}

		// Now send the font to the control.
		//
		if ( hBigFont )
			SendMessage(hWndCtrl, WM_SETFONT, (WPARAM) hBigFont, MAKELPARAM(TRUE, 0));
	}
}


static VOID FreeWizPages(LPWIZPAGE lpWizPage)
{
	if (lpWizPage)
	{
		FreeWizPages(lpWizPage->lpNext);
		FREE(lpWizPage);
	}
}


static LPWIZPAGE CreateWizPage(LPWIZPAGE lpWizPage, INT iDialog, LPTSTR lpTitle, LPTSTR lpSubTitle)
{
	if ( lpWizPage->lpNext = (LPWIZPAGE) MALLOC(sizeof(WIZPAGE)) )
	{
		lpWizPage = lpWizPage->lpNext;
		lpWizPage->iDialog = iDialog;
		lpWizPage->lpTitle = lpTitle;
		lpWizPage->lpSubTitle = lpSubTitle;
	}
	return lpWizPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\eaheader.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    eaheader.cxx

Abstract:

    This class models the header and tables of the EA file.

Author:

    Norbert P. Kusters (norbertk) 28-Nov-90

Notes:

    Luckily all the structures are well aligned.

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( EA_HEADER, CLUSTER_CHAIN, UFAT_EXPORT );

VOID
EA_HEADER::Construct (
        )
/*++

Routine Description:

        Constructor for EA_HEADER.  Initializes private data to default values.

Arguments:

        None.

Return Value:

        None.

--*/
{
   _ht = NULL;
   _off_tab_size = 0;
}


UFAT_EXPORT
EA_HEADER::~EA_HEADER(
    )
/*++

Routine Description:

    Destructor for EA_HEADER.  Frees memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
EA_HEADER::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               StartingCluster,
    IN      ULONG               LengthOfChain
    )
/*++

Routine Description:

    This routine prepares this object for reads and writes.  It also
    prepares the object with memory so that it can accept queries.

    If the length of the cluster chain is not specified this routine
    will read in the first cluster in order to compute the actual
    length of the cluster chain.

Arguments:

    Mem             - Supplies the memory for the cluster chain.
    Drive           - Supplies the drive that contains the EA file.
    FatSuperArea    - Supplies information about the FAT file system.
    Fat             - Supplies the file allocation table.
    StartingCluster - Supplies the first cluster of the EA file.
    LengthOfChain   - Supplies the number of clusters necessary to contain
                      the EA file header, base table and offset table.

Return Value:

    FALSE   - Initialization failed.
    TRUE    - Initialization succeeded.

--*/
{
    HMEM    hmem;
    INT     i;

    Destroy();

    // See if the length of the chain needs to be computed.
    if (!LengthOfChain) {
        if (!hmem.Initialize() ||
            !CLUSTER_CHAIN::Initialize(&hmem, Drive, FatSuperArea, Fat,
                                       StartingCluster, 1) ||
            !(_ht = (PEA_HEADER_AND_TABLE) GetBuf()) ||
            !CLUSTER_CHAIN::Read() ||
            !(_ht->Header.Signature == HeaderSignature) ||
            !(_ht->Header.FormatType == 0) ||
            !(_ht->Header.LogType == 0)) {

           DebugPrintTrace(("UFAT: Failure to initialize EA_HEADER %d\n", 1));
           Destroy();
           return FALSE;

        }
        for (i = 0; i < BaseTableSize && !_ht->Table.BaseTab[i]; i++) {
        }
        if (i == BaseTableSize) {

           DebugPrintTrace(("UFAT: Failure to initialize EA_HEADER %d\n", 2));
           Destroy();
           return FALSE;

        }
        LengthOfChain = _ht->Table.BaseTab[i];
    }

    if (!CLUSTER_CHAIN::Initialize(Mem, Drive, FatSuperArea, Fat,
                                   StartingCluster, LengthOfChain) ||
        !(_ht = (PEA_HEADER_AND_TABLE) GetBuf())) {

        DebugPrintTrace(("UFAT: Failure to initialize EA_HEADER %d\n", 3));
        Destroy();
        return FALSE;

    }

    // Compute the number of offset table entries.
    _off_tab_size = Drive->QuerySectorSize() *
                    FatSuperArea->QuerySectorsPerCluster() *
                    LengthOfChain;
    _off_tab_size -= sizeof(EA_FILE_HEADER);
    _off_tab_size -= BaseTableSize*sizeof(USHORT);
    _off_tab_size /= sizeof(USHORT);

    if (_off_tab_size < 0) {

       DebugPrintTrace(("UFAT: Failure to initialize EA_HEADER %d\n", 4));
       Destroy();
       return FALSE;

    }

    return TRUE;
}


UFAT_EXPORT
USHORT
EA_HEADER::QueryEaSetClusterNumber(
    IN  USHORT  Handle
    ) CONST
/*++

Routine Description:

    This function computes the EA cluster number for an EA set in the
    EA file.  This function will return 0 if the handle is invalid or
    outside the range of the table.

Arguments:

    Handle  - Supplies the handle for the desired EA set.

Return Value:

    Returns the EA cluster number for the EA set whose handle is 'Handle'.

--*/
{
    USHORT  off;

    if (!_ht) {
       DebugPrintTrace(("UFAT: Failure to QueryEaSetClusterNumber in EA_HEADER\n"));
       return 0;
    }

    Handle = (( Handle << 1 ) >> 1 );

    if ((LONG)Handle >= _off_tab_size ||
        (off = _ht->Table.OffTab[Handle]) == InvalidHandle) {
       return 0;
    }

    return (( off << 1 ) >> 1 ) + _ht->Table.BaseTab[Handle>>7];
}


VOID
EA_HEADER::Destroy(
    )
/*++

Routine Description:

    This routine puts this object in a blank state.  It is not necessary
    to call this routine between calls to Init because Init calls this
    routine automatically.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _ht = NULL;
    _off_tab_size = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\tuneup\wizard.h ===
//////////////////////////////////////////////////////////////////////////////
//
// WIZARD.H
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Includes all external include files, defined values, macros, data
//  structures, and fucntion prototypes for the corisponding CXX file.
//
//  Jason Cohen (JCOHEN)
//
//////////////////////////////////////////////////////////////////////////////



// Only include this file once.
//
#ifndef _WIZARD_H_
#define _WIZARD_H_


// Include file(s).
//
#include <windows.h>


// External function prototype(s).
//
INT CreateWizard(HINSTANCE, HWND);


#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\inc\mrcf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Mrcf.h

Abstract:

    This module defines all of the double space compression routines

Author:

    Gary Kimura     [GaryKi]    03-Jun-1993

Revision History:

--*/

#ifndef _MRCF_
#define _MRCF_

//
//  To decompress/compress a block of data the user needs to
//  provide a work space as an extra parameter to all the exported
//  procedures.  That way the routines will not need to use excessive
//  stack space and will still be multithread safe
//

//
//  Variables for reading and writing bits
//

typedef struct _MRCF_BIT_IO {

    USHORT  abitsBB;        //  16-bit buffer being read
    LONG    cbitsBB;        //  Number of bits left in abitsBB

    PUCHAR  pbBB;           //  Pointer to byte stream being read
    ULONG   cbBB;           //  Number of bytes left in pbBB
    ULONG   cbBBInitial;    //  Initial size of pbBB

} MRCF_BIT_IO;
typedef MRCF_BIT_IO *PMRCF_BIT_IO;

//
//  Decompression only needs the bit i/o structure
//

typedef struct _MRCF_DECOMPRESS {

    MRCF_BIT_IO BitIo;

} MRCF_DECOMPRESS;
typedef MRCF_DECOMPRESS *PMRCF_DECOMPRESS;

//
//  Standard compression uses a few more field to contain
//  the lookup table
//

#define cMAXSLOTS   (8)             //  The maximum number of slots used in the algorithm

#define ltUNUSED    (0xE000)        //  Value of unused ltX table entry
#define mruUNUSED   (0xFF)          //  Value of unused MRU table entry
#define bRARE       (0xD5)          //  Rarely occuring character value

typedef struct _MRCF_STANDARD_COMPRESS {

    MRCF_BIT_IO BitIo;

    ULONG   ltX[256][cMAXSLOTS];    //  Source text pointer look-up table
    UCHAR   abChar[256][cMAXSLOTS]; //  Character look-up table
    UCHAR   abMRUX[256];            //  Most Recently Used ltX/abChar entry

} MRCF_STANDARD_COMPRESS;
typedef MRCF_STANDARD_COMPRESS *PMRCF_STANDARD_COMPRESS;

ULONG
MrcfDecompress (
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PMRCF_DECOMPRESS WorkSpace
    );

ULONG
MrcfStandardCompress (
    PUCHAR CompressedBuffer,
    ULONG CompressedLength,
    PUCHAR UncompressedBuffer,
    ULONG UncompressedLength,
    PMRCF_STANDARD_COMPRESS WorkSpace
    );

#endif // _MRCF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\easet.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    easet.cxx

Abstract:

    This class models an EA set.

Author:

    Norbert P. Kusters (norbertk) 28-Nov-90

Notes:

    There are minor alignment problems here.

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( EA_SET, CLUSTER_CHAIN, UFAT_EXPORT );

VOID
EA_SET::Construct (
        )
/*++

Routine Description:

        Constructor for EA_SET.  Sets private data to default values.

Arguments:

        None.

Return Value:

        None.

--*/
{
   memset(&_eahdr, 0, sizeof(_eahdr));
   _size = 0;
   _size_imposed = FALSE;
   _current_ea = NULL;
   _current_index = 0;
}


UFAT_EXPORT
EA_SET::~EA_SET(
    )
/*++

Routine Description:

    Destructor for EA_SET.  Frees memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
EA_SET::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               ClusterNumber,
    IN      ULONG               LengthOfChain
    )
/*++

Routine Description:

    This routine initialize the EA_SET to model the EA set which resides
    at FAT cluster 'ClusterNumber'.

Arguments:

    Mem             - Supplies the memory for the cluster chain.
    Drive           - Supplies the drive where the EA set is contained.
    FatSuperArea    - Supplies the important drive parameters.
    Fat             - Supplies the file allocation table.
    StartingCluster - Supplies the starting cluster of the EA set.
    LengthOfChain   - Supplies the length of the cluster chai which contains
                        the EA set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM    hmem;
    ULONG   cluster_size;
    ULONG   sector_size;

    Destroy();

    if (!FatSuperArea || !Drive || !(sector_size = Drive->QuerySectorSize())) {
        DebugPrintTrace(("UFAT: Failure to initialize EA_SET %d\n", 1));
        Destroy();
        return FALSE;
    }

    cluster_size = sector_size*FatSuperArea->QuerySectorsPerCluster();

    if (!LengthOfChain) {
        if (!hmem.Initialize() ||
            !CLUSTER_CHAIN::Initialize(&hmem, Drive, FatSuperArea, Fat,
                                       ClusterNumber, 1) ||
            !Read()) {
            DebugPrintTrace(("UFAT: Failure to initialize EA_SET %d\n", 2));
            Destroy();
            return FALSE;
        }

        _size = _eahdr.TotalSize + SizeOfEaHdr - sizeof(LONG);
        _size_imposed = TRUE;

        if (_size%cluster_size) {
            LengthOfChain = (USHORT) (_size/cluster_size + 1);
        } else {
            LengthOfChain = (USHORT) (_size/cluster_size);
        }
    } else {
        _size = cluster_size*LengthOfChain;
        _size_imposed = FALSE;
    }


    if (!CLUSTER_CHAIN::Initialize(Mem, Drive, FatSuperArea, Fat,
                                   ClusterNumber, LengthOfChain)) {
        DebugPrintTrace(("UFAT: Failure to initialize EA_SET %d\n", 3));
        Destroy();
        return FALSE;
    }

    return TRUE;
}


UFAT_EXPORT
BOOLEAN
EA_SET::Read(
    )
/*++

Routine Description:

    This routine reads the cluster chain and then unpacks the ea header.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG    size;


    if (!CLUSTER_CHAIN::Read() || !UnPackEaHeader()) {
        return FALSE;
    }

    size = _eahdr.TotalSize + SizeOfEaHdr - sizeof(LONG);
    if (size < _size) {
        _size = size;
        _size_imposed = TRUE;
    }

    return TRUE;
}


UFAT_EXPORT
PEA
EA_SET::GetEa(
    IN  ULONG       Index,
    OUT PLONG       EaSize,
    OUT PBOOLEAN    PossiblyMore
    )
/*++

Routine Description:

    This routine returns a pointer to the Index'th EA.  An Index of 0
    indicates the first EA and so on.  A NULL pointer will be returned if
    the Index'th EA does not exist.

    This routine will validate the EA before returning it.  If the EA is
    invalid then NULL will be returned.

    The return value 'PossiblyMore' will only be computed in the event
    that the EA at index 'Index' can't be found.  It is used to indicate
    that there may be another EA in the next cluster of the cluster chain.

Arguments:

    Index   - Supplies which EA is requested.
    EaSize  - Returns the size of the EA.
    PossiblyMore    - Returns TRUE if there may possibly be more EAs in
                        a cluster beyond the boundary of the cluster chain.
                        Returns FALSE if this is impossible.

Return Value:

    A pointer to an EA structure or NULL.

--*/
{
    ULONG   i;
    PEA     r;
    PCHAR   p, b;
    ULONG   offset;

    if (PossiblyMore) {
        *PossiblyMore = FALSE;
    }

    if (!(b = (PCHAR) GetBuf())) {
        DebugPrintTrace(("UFAT: Failure to GetEa in EA_SET\n"));
        return NULL;
    }

    if (!_current_ea || Index < _current_index) {
        p = (PCHAR) (r = (PEA) (b + SizeOfEaHdr));

        if (!r->NameSize || !r->ValueSize[0] && !r->ValueSize[1]) {
            return NULL;
        }

        offset = sizeof(EA) + r->NameSize + r->ValueSize[0] +
                 (r->ValueSize[1]<<8);

        if (p - b + offset > (ULONG)_size) {
            if (PossiblyMore && !_size_imposed) {
                *PossiblyMore = TRUE;
            }

            return NULL;
        }

        if (p[sizeof(EA) + r->NameSize - 1]) {
            return NULL;
        }

        _current_index = 0;
    } else {
        p = (PCHAR) (r = _current_ea);

        offset = sizeof(EA) + r->NameSize + r->ValueSize[0] +
                (r->ValueSize[1]<<8);
    }

    for (i = _current_index; i < Index; i++) {
        r = (PEA) (p += offset);

        if (p - b + sizeof(EA) > (ULONG)_size) {
            if (PossiblyMore && !_size_imposed) {
                *PossiblyMore = TRUE;
            }

            return NULL;
        }

        if (!r->NameSize || !r->ValueSize[0] && !r->ValueSize[1]) {
            return NULL;
        }

        offset = sizeof(EA) + r->NameSize + r->ValueSize[0] +
                (r->ValueSize[1]<<8);

        if (p - b + offset > (ULONG)_size) {
            if (PossiblyMore && !_size_imposed) {
                *PossiblyMore = TRUE;
            }

            return NULL;
        }

        if (p[sizeof(EA) + r->NameSize - 1]) {
            return NULL;
        }
    }

    _current_index = i;
    _current_ea = r;

    if (EaSize) {
        *EaSize = offset;
    }

    return r;
}


VOID
EA_SET::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(&_eahdr, 0, sizeof(_eahdr));
    _size = 0;
    _size_imposed = FALSE;
    _current_ea = NULL;
    _current_index = 0;
}


BOOLEAN
EA_SET::PackEaHeader(
    )
/*++

Routine Description:

    This routine packs the EA set header.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPACKED_EA_HDR  peahdr;

    if (!(peahdr = (PPACKED_EA_HDR) GetBuf())) {
        DebugPrintTrace(("UFAT: Failure to PackEaHeader in EA_SET\n"));
        return FALSE;
    }

    peahdr->Signature = _eahdr.Signature;
    peahdr->OwnHandle = _eahdr.OwnHandle;
    peahdr->NeedCount = _eahdr.NeedCount;
    memcpy(peahdr->OwnerFileName, _eahdr.OwnerFileName, 14);
    memcpy(peahdr->Reserved, &_eahdr.Reserved, sizeof(ULONG));
    memcpy(peahdr->TotalSize, &_eahdr.TotalSize, sizeof(LONG));

    return TRUE;
}


BOOLEAN
EA_SET::UnPackEaHeader(
    )
/*++

Routine Description:

    This routine unpacks the EA set header.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPACKED_EA_HDR  peahdr;

    if (!(peahdr = (PPACKED_EA_HDR) GetBuf())) {
        DebugPrintTrace(("UFAT: Failure to UnPackEaHeader in EA_SET\n"));
        return FALSE;
    }

    _eahdr.Signature = peahdr->Signature;
    _eahdr.OwnHandle = peahdr->OwnHandle;
    _eahdr.NeedCount = peahdr->NeedCount;
    memcpy(_eahdr.OwnerFileName, peahdr->OwnerFileName, 14);
    memcpy(&_eahdr.Reserved, peahdr->Reserved, sizeof(ULONG));
    memcpy(&_eahdr.TotalSize, peahdr->TotalSize, sizeof(LONG));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\fat.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UFAT_MEMBER_

#include "ulib.hxx"
#include "ufat.hxx"

#include "bitvect.hxx"
#include "error.hxx"
#include "fat.hxx"


DEFINE_CONSTRUCTOR( FAT, SECRUN );


FAT::~FAT(
    )
/*++

Routine Description:

    Destructor for FAT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

extern VOID DoInsufMemory(VOID);

VOID
FAT::Construct (
    )
/*++

Routine Description:

    Constructor for FAT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _fat = NULL;
    _num_entries = 0;
    _fat_bits = 0;
    _low_end_of_chain = 0;
    _end_of_chain = 0;
    _bad_cluster = 0;
    _low_reserved = 0;
    _high_reserved = 0;
    _AllocatedClusters = 0xFFFFFFFF;
}


VOID
FAT::Destroy(
    )
/*++

Routine Description:

    This routine returns a FAT object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _fat = NULL;
    _num_entries = 0;
    _fat_bits = 0;
    _low_end_of_chain = 0;
    _end_of_chain = 0;
    _bad_cluster = 0;
    _low_reserved = 0;
    _high_reserved = 0;
    _AllocatedClusters = 0xFFFFFFFF;
}


BOOLEAN
FAT::Initialize(
    IN OUT  PSECRUN     Srun,
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LBN                 StartSector,
    IN      ULONG               NumOfEntries,
    IN      ULONG               NumSectors
    )
/*++

Routine Description:

    This routine initialize a FAT object.

Arguments:

    Mem             - Supplies the memory for the run of sectors.
    Drive           - Supplies the drive to read and write from.
    StartSector     - Supplies the start of the fat.
    NumberOfEntries - Supplies the number of entries in the FAT
                      which should be the total number of clusters
                      plus two reserved entries at the beginning.
    NumSectors      - Supplies the number of sectors allocated for
                      the fat.  If this parameter is not supplied
                      then this routine will compute this value
                      from the given number of entries.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The 'NumSectors' parameter is added to this function
    DOS FORMAT does not always make the FAT large enough for
    the volume.  If this parameter is supported then the
    number of entries supported by this FAT will be the lesser
    or the actual number passed in that the maximum number that
    the given FAT size will support.

--*/
{
    SECTORCOUNT n;
    ULONG       sector_size;
    ULONG       max_num_entries;

    DebugAssert(Mem);
    DebugAssert(Drive);

    Destroy();

    if (!(sector_size = Drive->QuerySectorSize())) {
        Destroy();
        return FALSE;
    }

    _num_entries = NumOfEntries;

    if (_num_entries < FirstDiskCluster + MaxNumClusForSmallFat) {
       _fat_bits = fFat12;
    } else if (_num_entries < FirstDiskCluster + MinNumClusForFat32) {
       _fat_bits = fFat16;
    } else {
       _fat_bits = fFat32;
    }

    if (fFat32 == _fat_bits) {
        _low_end_of_chain = 0x0FFFFFF8;
        _end_of_chain = 0x0FFFFFFF;
        _bad_cluster = 0x0FFFFFF7;
        _low_reserved = 0x0FFFFFF0;
        _high_reserved = 0x0FFFFFF6;
        n = (_num_entries*4 - 1)/sector_size + 1;
    }
    else if (fFat16 == _fat_bits) {
        // COMMON CODE for FAT 12 and FAT 16
        // FAT 16
        _low_end_of_chain = 0xFFF8;
        _end_of_chain = 0xFFFF;
        _bad_cluster = 0xFFF7;
        _low_reserved = 0xFFF0;
        _high_reserved = 0xFFF6;

        n = (_num_entries*2 - 1)/sector_size + 1;

    }
    else {      // FAT 12
        _low_end_of_chain = 0x0FF8;
        _end_of_chain = 0x0FFF;
        _bad_cluster = 0x0FF7;
        _low_reserved = 0x0FF0;
        _high_reserved = 0x0FF6;

        n = (_num_entries*3 - 1)/2/sector_size + 1;
    }

    if (NumSectors) {
        n = NumSectors;
        if (fFat32 == _fat_bits) {
           max_num_entries = (n*sector_size/4);
        } else if (fFat16 == _fat_bits) {
           // COMMON CODE for FAT 12 and FAT 16
           max_num_entries = (n*sector_size/2);
        } else {
            max_num_entries = (n*sector_size*2/3);
        }
        _num_entries = min(_num_entries, max_num_entries);
    }
    _AllocatedClusters = 0xFFFFFFFF;

    if (!Srun->Initialize(Mem, Drive, StartSector, n)) {
    DoInsufMemory();
        Destroy();
        return FALSE;
    }

    _fat = Srun->GetBuf();
    return TRUE;
}



BOOLEAN
FAT::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LBN                 StartSector,
    IN      ULONG               NumOfEntries,
    IN      ULONG               NumSectors
    )
/*++

Routine Description:

    This routine initialize a FAT object.

Arguments:

    Mem             - Supplies the memory for the run of sectors.
    Drive           - Supplies the drive to read and write from.
    StartSector     - Supplies the start of the fat.
    NumberOfEntries - Supplies the number of entries in the FAT
                      which should be the total number of clusters
                      plus two reserved entries at the beginning.
    NumSectors      - Supplies the number of sectors allocated for
                      the fat.  If this parameter is not supplied
                      then this routine will compute this value
                      from the given number of entries.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The 'NumSectors' parameter is added to this function
    DOS FORMAT does not always make the FAT large enough for
    the volume.  If this parameter is supported then the
    number of entries supported by this FAT will be the lesser
    or the actual number passed in that the maximum number that
    the given FAT size will support.

--*/
{
    SECTORCOUNT n;
    ULONG       sector_size;
    ULONG       max_num_entries;

    DebugAssert(Mem);
    DebugAssert(Drive);

    Destroy();

    if (!(sector_size = Drive->QuerySectorSize())) {
        Destroy();
        return FALSE;
    }

    _num_entries = NumOfEntries;

    if (_num_entries < FirstDiskCluster + MaxNumClusForSmallFat) {
       _fat_bits = fFat12;
    } else if (_num_entries < FirstDiskCluster + MinNumClusForFat32) {
       _fat_bits = fFat16;
    } else {
       _fat_bits = fFat32;
    }

    if (fFat32 == _fat_bits) {
        _low_end_of_chain = 0x0FFFFFF8;
        _end_of_chain = 0x0FFFFFFF;
        _bad_cluster = 0x0FFFFFF7;
        _low_reserved = 0x0FFFFFF0;
        _high_reserved = 0x0FFFFFF6;
    n = ((_num_entries * 4) + (sector_size - 1)) / sector_size;
    }
    else if (fFat16 == _fat_bits) {
        // COMMON CODE for FAT 12 and FAT 16
        // FAT 16
        _low_end_of_chain = 0xFFF8;
        _end_of_chain = 0xFFFF;
        _bad_cluster = 0xFFF7;
        _low_reserved = 0xFFF0;
        _high_reserved = 0xFFF6;

    n = ((_num_entries * 2) + (sector_size - 1)) / sector_size;

    }
    else {      // FAT 12
        _low_end_of_chain = 0x0FF8;
        _end_of_chain = 0x0FFF;
        _bad_cluster = 0x0FF7;
        _low_reserved = 0x0FF0;
        _high_reserved = 0x0FF6;

    // NOTE: the "+ (2 - 1)) / 2)" below is doing a round up divide by 2
    //   it is left this way because it is clearer what it is doing....

    n = ((((_num_entries * 3) + (2 - 1)) / 2) + (sector_size - 1)) / sector_size;
    }

    if (NumSectors) {
        n = NumSectors;
        if (fFat32 == _fat_bits) {
           max_num_entries = (n*sector_size/4);
        } else if (fFat16 == _fat_bits) {
           // COMMON CODE for FAT 12 and FAT 16
           max_num_entries = (n*sector_size/2);
        } else {
            max_num_entries = (n*sector_size*2/3);
        }
        _num_entries = min(_num_entries, max_num_entries);
    }
    _AllocatedClusters = 0xFFFFFFFF;

    if (!SECRUN::Initialize(Mem, Drive, StartSector, n)) {
    DoInsufMemory();
        Destroy();
        return FALSE;
    }

    _fat = GetBuf();
    return TRUE;
}


UFAT_EXPORT
ULONG
FAT::Index12(
    IN  ULONG    ClusterNumber
    ) CONST
/*++

Routine Description:

    This routine indexes the FAT as 12 bit little endian entries.

Arguments:

    ClusterNumber   - Supplies the FAT entry desired.

Return Value:

    The value of the FAT entry at ClusterNumber.

--*/
{
    ULONG   n;
    PUCHAR  p;

    p = (PUCHAR) _fat;

    DebugAssert(p);

    n = ClusterNumber*3;
    if (n%2) {
        return (p[n/2]>>4) | (p[n/2 + 1]<<4);
    } else {
        return p[n/2] | ((p[n/2 + 1]&0x0F)<<8);
    }
}


UFAT_EXPORT
VOID
FAT::Set12(
    IN  ULONG    ClusterNumber,
    IN  ULONG    Value
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 12 bit FAT entry to Value.

Arguments:

    ClusterNumber   - Supplies the FAT entry to set.
    Value           - Supplies the value to set the FAT entry to.

Return Value:

    None.

--*/
{
    ULONG   n;
    PUCHAR  p;

    p = (PUCHAR) _fat;

    DebugAssert(p);

    n = ClusterNumber*3;
    if (n%2) {
        p[n/2] = (p[n/2]&0x0F) | (((UCHAR)Value&0x000F)<<4);
        p[n/2 + 1] = (UCHAR)((Value&0x0FF0)>>4);
    } else {
        p[n/2] = (UCHAR)Value&0x00FF;
        p[n/2 + 1] = (p[n/2 + 1]&0xF0) | (UCHAR)((Value&0x0F00)>>8);
    }
    _AllocatedClusters = 0xFFFFFFFF;
}

ULONG
FAT::QueryFreeClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of free clusters on the disk by
    scanning the FAT and counting the number of empty entries.

Arguments:

    None.

Return Value:

    The number of free clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterFree(i)) {

            r++;
        }
    }

    return r;
}


ULONG
FAT::QueryBadClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bad clusters on the disk by
    scanning the FAT and counting the number of entries marked bad.

Arguments:

    None.

Return Value:

    The number of bad clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterBad(i)) {
            r++;
        }
    }

    return r;
}


ULONG
FAT::QueryReservedClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of reserved clusters on the disk by
    scanning the FAT and counting the number of entries marked reserved.

Arguments:

    None.

Return Value:

    The number of reserved clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterReserved(i)) {
            r++;
        }
    }

    return r;
}

ULONG
FAT::QueryAllocatedClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of allocated clusters on the
    disk by scanning the FAT and counting the entries marked allocated.

Arguments:

    None.

Return Value:

    The number of allocated clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (!IsClusterReserved(i) && !IsClusterBad(i) && !IsClusterFree(i)) {
            r++;
        }
    }

    return r;
}


UFAT_EXPORT
ULONG
FAT::QueryNthCluster(
    IN  ULONG    StartingCluster,
    IN  ULONG    Index
    ) CONST
/*++

Routine Description:

    This routine returns the cluster number of the cluster that is in the
    'Index'th position in the cluster chain beginning at 'StartingCluster'.
    The clusters in a chain are numbered beginning at zero.

Arguments:

    StartingCluster - Supplies the first cluster of a cluster chain.
    Index           - Supplies the number of the cluster in the chain
                        requested.

Return Value:

    The cluster number of the 'Index'th cluster in the cluster chain
    beginning with cluster 'StartingCluster' or 0.

--*/
{
    for (; Index; Index--) {

        if (!IsInRange(StartingCluster)) {
            return 0;
        }

        StartingCluster = QueryEntry(StartingCluster);
    }

    return StartingCluster;
}


UFAT_EXPORT
ULONG
FAT::QueryLengthOfChain(
    IN  ULONG    StartingCluster,
    OUT PULONG   LastCluster
    ) CONST
/*++

Routine Description:

    This routine computes the length of a cluster chain given the number
    of its first cluster.

    This routine depends on the chain being valid.  In particular, if the
    chain contains any cycles then this routine will not finish.  The
    routine 'ScrubChain' will turn an invalid chain into a valid one.

Arguments:

    StartingCluster - Supplies the first cluster of a cluster chain.
    LastCluster     - Returns the number of the last cluster in the chain.

Return Value:

    The length of the cluster chain beginning with 'StartingCluster'.

--*/
{
    ULONG    length;

    if (!StartingCluster) {
        if (LastCluster) {
            *LastCluster = 0;
        }
        return 0;
    }

    for (length = 1; IsInRange(StartingCluster) && !IsEndOfChain(StartingCluster); length++) {
        StartingCluster = QueryEntry(StartingCluster);
    }

    if (LastCluster) {
        *LastCluster = StartingCluster;
    }

    return length;
}


ULONG
FAT::QueryLengthOfChain(
    IN  ULONG    StartingCluster,
    IN  ULONG    EndingCluster
    ) CONST
/*++

Routine Description:

    This routine computes the length of a cluster chain given the number
    of its first cluster and the number of its last cluster.  To compute
    the length of a chain which is terminated by "end of chain", see
    the one parameter version of this routine above.  If 'EndingCluster'
    is not a member of the chain beginning with 'StartingCluster' then
    this routine will return 0.

    This routine depends on the chain being valid.

Arguments:

    StartingCluster - Supplies the first cluster of the cluster chain.
    EndingCluster   - Supplies the last cluster of the cluster chain.

Return Value:

    The length of the cluster chain beginning with 'StartingCluster' and
    ending with 'EndingCluster' or 0.

--*/
{
    ULONG    length;

    if (!StartingCluster) {
        return 0;
    }

    for (length = 1; StartingCluster != EndingCluster &&
                     !IsEndOfChain(StartingCluster); length++) {
        StartingCluster = QueryEntry(StartingCluster);
    }

    return StartingCluster == EndingCluster ? length : 0;
}


ULONG
FAT::QueryPrevious(
    IN  ULONG    Cluster
    ) CONST
/*++

Routine Description:

    Obtains the previous cluster in a chain, i.e. the cluster that
    references the given cluster.

Arguments:

    Cluster -   Supplies the cluster whose predecesor we're looking for.

Return Value:

    The predecesor of the given cluster. 0 if there is no predecesor.

--*/

{
    ULONG    i;

    DebugAssert( Cluster );

    if ( !IsClusterFree( Cluster ) ) {
        for (i = FirstDiskCluster; IsInRange(i); i++) {
            if ( QueryEntry(i) == Cluster ) {
                return i;
            }
        }
    }

    return 0;
}


VOID
FAT::Scrub(
    OUT PBOOLEAN    ChangesMade
    )
/*++

Routine Description:

    This routine goes through all of the FAT entries changing invalid values
    to reasonable values for the purposes of CHKDSK.

    Illegal FAT entries are those that are set out of disk range and that
    are not magic values.  This routine will set all illegal FAT entries to
    the "end of chain" magic value.

Arguments:

    ChangesMade - Returns TRUE if any changes were made to the FAT.

Return Value:

    None.

--*/
{
    ULONG    i;

    if (ChangesMade) {
        *ChangesMade = FALSE;
    }

    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (!IsInRange(QueryEntry(i)) &&
            !IsClusterFree(i) &&
            !IsEndOfChain(i) &&
            !IsClusterBad(i) &&
            !IsClusterReserved(i)) {

            SetEndOfChain(i);

            if (ChangesMade) {
                *ChangesMade = TRUE;
            }
        }
    }
}


VOID
FAT::ScrubChain(
    IN      ULONG        StartingCluster,
    OUT     PBOOLEAN     ChangesMade
    )
/*++

Routine Description:

    This routine goes through all of the FAT entries in the chain beginning
    with cluster 'StartingCluster'.  It is expected that all of the entries
    in this chain point to valid clusters on the disk.  This routine will
    mark the first invalid entry, if any, as the final cluster of the chain
    thus transforming the invalid chain into a valid one.

Arguments:

    StartingCluster - Supplies the first cluster of the chain to
                      scrub.
    ChangesMade     - Returns TRUE if changes were made to correct
                      the chain.

Return Value:

    None.

--*/
{
    ULONG    clus, next;

    DebugAssert(IsInRange(StartingCluster));
    DebugAssert(ChangesMade);

    *ChangesMade = FALSE;

    clus = StartingCluster;
    while (!IsEndOfChain(clus)) {

        next = QueryEntry(clus);
        if (!IsInRange(next) || IsClusterFree(next)) {
            SetEndOfChain(clus);
            *ChangesMade = TRUE;
            return;
        }

        clus = next;
    }
}


VOID
FAT::ScrubChain(
    IN      ULONG       StartingCluster,
    OUT     PBITVECTOR  FatBitMap,
    OUT     PBOOLEAN    ChangesMade,
    OUT     PBOOLEAN    CrossLinkDetected,
    OUT     PULONG      CrossLinkPreviousCluster
    )
/*++

Routine Description:

    This routine goes through all of the FAT entries in the chain beginning
    with cluster 'StartingCluster'.  It is expected that all of the entries
    in this chain point to valid clusters on the disk.  This routine will
    mark the first invalid entry, if any, as the final cluster of the chain
    thus transforming the invalid chain into a valid one.

    This routine will also eliminate any cycles in the cluster chain as well
    as detect cross-links.

Arguments:

    StartingCluster             - Supplies the first cluster of the chain to
                                    scrub.
    UsedClusters                - Supplies a bitvector marking all used
                                    clusters.
    ChangesMade                 - Returns TRUE if changes were made to correct
                                    the chain.
    CrossLinkDetected           - Returns TRUE if a cluster in the chain was
                                    already claimed in the 'FatBitMap'.
    CrossLinkPreviousCluster    - Returns the cluster number previous to the
                                    cross linked cluster number or 0 if the
                                    cross linked cluster number was the first
                                    in the chain.

Return Value:

    None.

--*/
{
    ULONG    clus, next;

    DebugAssert(IsInRange(StartingCluster));
    DebugAssert(ChangesMade);
    DebugAssert(CrossLinkDetected);
    DebugAssert(CrossLinkPreviousCluster);

    *ChangesMade = FALSE;
    *CrossLinkDetected = FALSE;

    if (FatBitMap->IsBitSet(StartingCluster)) {
        *CrossLinkDetected = TRUE;
        *CrossLinkPreviousCluster = 0;
        return;
    }

    clus = StartingCluster;
    while (!IsEndOfChain(clus)) {

        FatBitMap->SetBit(clus);

        next = QueryEntry(clus);
        if (!IsInRange(next) || IsClusterFree(next)) {
            SetEndOfChain(clus);
            *ChangesMade = TRUE;
            return;
        }

        if (FatBitMap->IsBitSet(next)) {

            if (clus == next) {       // Cluster points to itself.
                *ChangesMade = TRUE;
                SetEndOfChain(clus);
                return;
            }

            while (StartingCluster != clus) {

                if (StartingCluster == next) { // Cluster points to previous.
                    *ChangesMade = TRUE;
                    SetEndOfChain(clus);
                    return;
                }

                StartingCluster = QueryEntry(StartingCluster);
            }

            // Otherwise it's a cross link, not a cycle.

            *CrossLinkDetected = TRUE;
            *CrossLinkPreviousCluster = clus;
            return;
        }

        clus = next;
    }

    FatBitMap->SetBit(clus);
}

NONVIRTUAL
BOOLEAN
FAT::IsValidChain(
    IN  ULONG    StartingCluster
    ) CONST
/*++

Routine Description:

    This method determines whether the chain is valid, ie. that it
    consists of a chain of valid cluster numbers ending with an end
    of chain entry.

Arguments:

    StartingCluster - Supplies the first cluster of the chain.

Return Value:

    TRUE if the chain is valid.

--*/
{
    ULONG    current;
    ULONG    clusters_in_chain = 0;

    current = StartingCluster;

    for( ;; ) {

        if (!IsInRange(current) ||
            clusters_in_chain++ > _num_entries ) {

            // Either a bad entry or an infinite loop detected.
            //
            return FALSE;
        }

        if (IsEndOfChain(current)) {
            break;
        }

        current = QueryEntry(current);
    }

    return TRUE;
}


UFAT_EXPORT
ULONG
FAT::AllocChain(
    IN  ULONG    Length,
    OUT PULONG   LastCluster
    )
/*++

Routine Description:

    This routine attempts to allocate a chain of length 'Length' from the
    FAT.  If this routine is successful it will return the cluster number
    of the beginning of the chain.  Upon failure this routine will return
    0 and will make no changes to the FAT.

Arguments:

    Length      - Supplies the length of the chain desired.
    LastCluster - Returns the last cluster of the allocated chain.

Return Value:

    The cluster number of the beginning of the allocated chain or 0.

--*/
{
    ULONG    i, j;
    ULONG    start;
    ULONG    prev;

    if (!Length) {
        return 0;
    }

    start = 0;
    prev = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterFree(i)) {
            if (!start) {
                start = i;
            } else {
                SetEntry(prev, i);
            }
            prev = i;
            Length--;
            if (!Length) {
                SetEndOfChain(i);

                if (LastCluster) {
                    *LastCluster = i;
                }

                return start;
            }
        }
    }

    // There is not enough disk space for the chain so free what was taken.
    for (i = start; i != prev; ) {
        j = QueryEntry(i);
        SetClusterFree(i);
        i = j;
    }

    return 0;
}


ULONG
FAT::ReAllocChain(
    IN  ULONG    StartOfChain,
    IN  ULONG    NewLength,
    OUT PULONG   LastCluster
    )
/*++

Routine Description:

    This routine insures that the cluster chain beginning at cluster
    'StartOfChain' is of length greater than or equal to 'NewSize'.
    If it is not then this routine will attempt to grow the chain by
    allocating new clusters.  Failure to allocate sufficient clusters
    to grow the chain to 'NewSize' clusters will cause this routine to
    restore the chain to its original length and state.  This routine will
    return the current length of the chain : either the old length or the
    new length.  If an error occurs then 0 will be returned.

Arguments:

    StartOfChain    - Supplies the first cluster of the chain.
    NewLength       - Supplies the desired new length of the chain.
    LastCluster     - Returns the last cluster of the chain.

Return Value:

    The current length of the chain or 0.

--*/
{
    ULONG    length;
    ULONG    new_clusters_needed;
    ULONG    end_of_chain;
    ULONG    i, j;
    ULONG    start;

    if (!IsInRange(StartOfChain)) {
        return 0;
    }

    for (length = 1; !IsEndOfChain(StartOfChain); length++) {
        StartOfChain = QueryEntry(StartOfChain);
        if (!IsInRange(StartOfChain)) {
            return 0;
        }
    }

    if (length >= NewLength) {
        if (LastCluster) {
            *LastCluster = StartOfChain;
        }
        return length;
    }

    new_clusters_needed = NewLength - length;

    start = end_of_chain = StartOfChain;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterFree(i)) {
            SetEntry(end_of_chain, i);
            end_of_chain = i;
            new_clusters_needed--;
            if (!new_clusters_needed) {
                SetEndOfChain(i);
                if (LastCluster) {
                    *LastCluster = i;
                }
                return NewLength;
            }
        }
    }

    // There is not enough disk space to lengthen the new chain so
    // settle for the old length.

    for (i = start; i != end_of_chain; ) {
        j = QueryEntry(i);
        SetClusterFree(i);
        i = j;
    }

    SetEndOfChain(start);

    if (LastCluster) {
        *LastCluster = start;
    }

    return length;
}


UFAT_EXPORT
VOID
FAT::FreeChain(
    IN  ULONG    StartOfChain
    )
/*++

Routine Description:

    This routine sets free all of the clusters in the cluster chain
    beginning with 'StartOfChain'.

Arguments:

    StartOfChain    - Supplies the first cluster of the chain to free.

Return Value:

    None.

--*/
{
    ULONG    tmp;

    while (!IsEndOfChain(StartOfChain)) {
        tmp = QueryEntry(StartOfChain);
        SetClusterFree(StartOfChain);
        StartOfChain = tmp;
    }
    SetClusterFree(StartOfChain);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\cluster.cxx ===
#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"


#include "cmem.hxx"

extern "C" {
#ifdef DBLSPACE_ENABLED
#include "mrcf.h"
#endif // DBLSPACE_ENABLED
#include "ntrtl.h"
}

extern VOID DoInsufMemory(VOID);

DEFINE_EXPORTED_CONSTRUCTOR( CLUSTER_CHAIN, OBJECT, UFAT_EXPORT );

VOID
CLUSTER_CHAIN::Construct (
    )
/*++

Routine Description:

    Constructor for CLUSTER_CHAIN which initializes private data to
    default values.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _secruns = NULL;
    _num_secruns = 0;
    _length_of_chain = 0;
    _is_compressed = FALSE;
    _buf = NULL;
    _drive = NULL;
    _fat_sa = NULL;
    _secrun = NULL;
}

UFAT_EXPORT
CLUSTER_CHAIN::~CLUSTER_CHAIN(
    )
/*++

Routine Description:

    Destructor for CLUSTER_CHAIN.  Frees memory and returns references.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
CLUSTER_CHAIN::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               ClusterNumber,
    IN      ULONG               LengthOfChain
    )
/*++

Routine Description:

    Prepares the CLUSTER_CHAIN object for reads and writes to disk.
    The length of the cluster chain may be specified by the
    LengthOfChain argument.  Setting this parameter to 0 will cause
    the length of the chain to be until the end of file.

Arguments:

    Mem             - Supplies memory for the cluster object.
    Drive           - Supplies the drive to which reads and writes will
                        take place.
    FatSuperArea    - Supplies the FAT super area which contains information
                        about the current FAT implementation.
    Fat             - Supplies the file allocation table for this drive.
    ClusterNumber   - Supplies the cluster number to map.
    LengthOfChain   - Supplies the number of clusters in the chain.
                        This value defaults to 0 which indicates that all
                        clusters until end of file will be addressed.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONT_MEM    cmem;
    SECTORCOUNT sec_per_clus;
    ULONG       clus;
    LONG        size;
    PVOID       buf;
    ULONG       i, j;
    LBN         lbn;

    Destroy();

    if (!Mem ||
        !Drive ||
        !FatSuperArea ||
        !Fat ||
        !Fat->IsInRange(ClusterNumber)) {
        Destroy();
        return FALSE;
    }

    if (LengthOfChain) {
        _length_of_chain = LengthOfChain;
    } else {
        _length_of_chain = Fat->QueryLengthOfChain(ClusterNumber);
    }

    if (!_length_of_chain) {
        Destroy();
        return FALSE;
    }

    sec_per_clus = FatSuperArea->QuerySectorsPerCluster();
    size = sec_per_clus*Drive->QuerySectorSize()*_length_of_chain;

    _is_compressed = FatSuperArea->IsCompressed();
    _fat_sa = FatSuperArea;

#ifdef DBLSPACE_ENABLED
    if (_is_compressed) {

        _fat = Fat;
        _drive = Drive;
        _starting_cluster = ClusterNumber;
        if (!(_secrun = NEW SECRUN)) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }
        // This buf will hold the cluster chain's uncompressed data.
        if (!(_buf = (PUCHAR)Mem->Acquire(size, Drive->QueryAlignmentMask()))) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }
        if (!_hmem.Initialize()) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }
        return TRUE;
    
    }
#endif // DBLSPACE_ENABLED

    if (!(_secruns = (PSECRUN*) MALLOC(_length_of_chain*sizeof(PSECRUN)))) {
        Destroy();
	DoInsufMemory();
        return FALSE;
    }

    if (!(buf = Mem->Acquire(size, Drive->QueryAlignmentMask())) ||
        !cmem.Initialize(buf, size)) {
        
        Destroy();
	DoInsufMemory();
        return FALSE;
    }


    clus = ClusterNumber;
    i = 0;
    for (;;) {
        lbn = _fat_sa->QuerySectorFromCluster(clus);

        for (j = 1; !Fat->IsEndOfChain(clus) &&
                    (clus + 1) == Fat->QueryEntry(clus) &&
                    i + j < _length_of_chain; j++) {
            clus++;
        }
        i += j;

        if (!(_secruns[_num_secruns] = NEW SECRUN)) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }

        if (!_secruns[_num_secruns]->Initialize(&cmem, Drive, lbn,
                                                j*sec_per_clus)) {
            Destroy();
	    DoInsufMemory();
            return FALSE;
        }

        _num_secruns++;

        if (i == _length_of_chain) {
            break;
        }

        clus = Fat->QueryEntry(clus);
        if (!Fat->IsInRange(clus)) {
            Destroy();
            return FALSE;
        }
    }

    return TRUE;
}


UFAT_EXPORT
BOOLEAN
CLUSTER_CHAIN::Read(
    )
/*++

Routine Description:

    This routine reads the cluster chain into memory.  This is done
    by making repetitive use of SECRUN's Read routine.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    BOOLEAN     b = TRUE;
    ULONG       clus;
    LBN         lbn;
    UCHAR       nsec;
#ifdef DBLSPACE_ENABLED
    MRCF_DECOMPRESS
                wkspc;
#endif // DBLSPACE_ENABLED
    ULONG       u;
    ULONG       cluster_size;
    ULONG       sector_size;

    if (!_is_compressed) {

        if (!_secruns) {
            return FALSE;
        }

        for (i = 0; i < _num_secruns; i++) {

            b = (BOOLEAN)(_secruns[i]->Read() && b);
        }

        return b;
    }

#ifdef DBLSPACE_ENABLED
    //
    // The volume is compressed.
    //

    sector_size = _drive->QuerySectorSize();
    cluster_size = sector_size * _fat_sa->QuerySectorsPerCluster();

    clus = _starting_cluster;

    i = 0;
    for (;;) {

        lbn = _fat_sa->QuerySectorFromCluster(clus, &nsec);

        if (!_secrun->Initialize(&_hmem, _drive, lbn, nsec)) {
	    DoInsufMemory();
            return FALSE;
        }

        if (!_secrun->Read()) {
            return FALSE;
        }

        if (_fat_sa->IsClusterCompressed(clus)) {

            RtlZeroMemory(&_buf[i * sector_size], cluster_size);

            u = MrcfDecompress(&_buf[i * sector_size],
                _fat_sa->QuerySectorsRequiredForPlainData(clus) * sector_size,
                (PUCHAR)_secrun->GetBuf(),
                nsec * sector_size, &wkspc);

            if (0 == u) {
                // error: can't decompress data
                return TRUE;
            }

        } else {

            // This cluster isn't compressed; just copy.

            memcpy(&_buf[i * cluster_size], _secrun->GetBuf(), cluster_size);
        }

        if (++i == _length_of_chain) {
            return TRUE;
        }

        clus = _fat->QueryEntry(clus);
        if (!_fat->IsInRange(clus)) {
            return FALSE;
        }
    }

    //NOTREACHED
#endif // DBLSPACE_ENABLED
    return FALSE;
}


UFAT_EXPORT
BOOLEAN
CLUSTER_CHAIN::Write(
    )
/*++

Routine Description:

    This routine writes the cluster chain to disk.  This is done
    by making repetitive use of SECRUN's Write routine.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    BOOLEAN     b = TRUE;
    UCHAR       nsec, new_nsec;
    ULONG       clus;
    LBN         lbn;
#ifdef DBLSPACE_ENABLED
    MRCF_STANDARD_COMPRESS
                wkspc;
#endif // DBLSPACE_ENABLED
    ULONG       cluster_size;
    ULONG       sector_size;
    ULONG       u;
    HMEM        work_buf;

    if (!_is_compressed) {
        
       if (!_secruns) {
          return FALSE;
       }
       for (i = 0; i < _num_secruns; i++) {
          b = (BOOLEAN)(_secruns[i]->Write() && b);
       }   
       return b;
    }

#ifdef DBLSPACE_ENABLED
    //
    // The volume is compressed.
    //

    sector_size = _drive->QuerySectorSize();
    cluster_size = _fat_sa->QuerySectorsPerCluster() * sector_size;

    if (!work_buf.Initialize() ||
        !work_buf.Acquire(cluster_size, _drive->QueryAlignmentMask())) {
	DoInsufMemory();
        return FALSE;
    }

    clus = _starting_cluster;
    i = 0;
    for (;;) {
        lbn = _fat_sa->QuerySectorFromCluster(clus, &nsec);

        u = MrcfStandardCompress((PUCHAR)work_buf.GetBuf(), cluster_size,
            &_buf[i * cluster_size], cluster_size, &wkspc);
        if (0 == u) {
            // the data could not be compressed

            if (nsec < _fat_sa->QuerySectorsPerCluster()) {

                //
                // previously the data had been compressed; need to allocate
                // more disk space.
                //

                nsec = _fat_sa->QuerySectorsPerCluster();
                _fat_sa->FreeClusterData(clus);
                if (!_fat_sa->AllocateClusterData(clus, nsec, FALSE,
                    _fat_sa->QuerySectorsPerCluster())) {
                    // error: no space
                    return FALSE;
                }
                lbn = _fat_sa->QuerySectorFromCluster(clus);
            }
            DbgAssert(nsec == _fat_sa->QuerySectorsPerCluster());

            _fat_sa->SetClusterCompressed(clus, FALSE);

        } else {
            
           new_nsec = (u + sector_size - 1)/sector_size;

           if (new_nsec != nsec) {

              //
              // The data has been changed, and it won't compress into
              // the same size as it used to.
              //
              _fat_sa->FreeClusterData(clus);
              if (!_fat_sa->AllocateClusterData(clus, new_nsec, TRUE,
                                                _fat_sa->QuerySectorsPerCluster())) {

                 // error: not enough free space
                 return FALSE;
              }
              lbn = _fat_sa->QuerySectorFromCluster(clus, &nsec);
            
           } else {

                //
                // The cluster may not have been compressed before,
                // but we still need the same amount of space even though
                // it's now compressed.
                //
                _fat_sa->SetClusterCompressed(clus, TRUE);
            }
        }

	if (!_hmem.Initialize()) {
	    DoInsufMemory();
            return FALSE;
	}
        if (!_secrun->Initialize(&_hmem, _drive, lbn, nsec)) {
	    DoInsufMemory();
            return FALSE;
        }

        memcpy(_secrun->GetBuf(), work_buf.GetBuf(),
            nsec * sector_size);

        b = (BOOLEAN)(_secrun->Write() && b);

        if (++i == _length_of_chain) {
            return b;
        }

        clus = _fat->QueryEntry(clus);
        if (!_fat->IsInRange(clus)) {
            return FALSE;
        }
    }

    //NOTREACHED
#endif // DBLSPACE_ENABLED
    return FALSE;
}


VOID
CLUSTER_CHAIN::Destroy(
    )
/*++

Routine Description:

    This routine cleans up the objects internal components.  It does not
    need to be called before Init as Init does this automatically.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG i;

#ifdef DBLSPACE_ENABLED
    if (_is_compressed) {
        DELETE(_secrun);
        _num_secruns = 0;
        _length_of_chain = 0;
        _buf = NULL;
        _drive = NULL;
        return;
    }
#endif // DBLSPACE_ENABLED

    for (i = 0; i < _num_secruns; i++) {
        DELETE(_secruns[i]);
    }

    DELETE(_secruns);
    _num_secruns = 0;
    _length_of_chain = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\entry.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

   entry.cxx

Abstract:

   This module contains the entry points for UFAT.DLL.  These
   include:

      Chkdsk
      ChkdskEx
      Format
      Recover

Author:

   Bill McJohn (billmc) 31-05-91

Environment:

   ULIB, User Mode

--*/

#include <pch.cxx>

#include "error.hxx"
#include "path.hxx"
#include "ifssys.hxx"
#include "filter.hxx"
#include "system.hxx"
#include "dir.hxx"
#include "rcache.hxx"
#ifdef DBLSPACE_ENABLED
#include "dblentry.hxx"
#endif // DBLSPACE_ENABLED

extern "C" {
    #include "nturtl.h"
}

#include "message.hxx"
#include "rtmsg.h"
#include "ifsserv.hxx"


VOID
ReportFileNotFoundError(
    IN      PPATH       PathToCheck,
    IN OUT  PMESSAGE    Message
    )
{
    PWSTRING        dirs_and_name;

    if (dirs_and_name = PathToCheck->QueryDirsAndName()) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", dirs_and_name);
        DELETE(dirs_and_name);
    }
}


BOOLEAN
FAR APIENTRY
Chkdsk(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Fix,
    IN      BOOLEAN     Verbose,
    IN      BOOLEAN     OnlyIfDirty,
    IN      BOOLEAN     Recover,
    IN      PPATH       PathToCheck,
    IN      BOOLEAN     Extend,
    IN      BOOLEAN     ResizeLogFile,
    IN      ULONG       LogFileSize,
    IN      PULONG      ExitStatus
   )
/*++

Routine Description:

   Check a FAT volume.

Arguments:

   DosDrivName    supplies the name of the drive to check
   Message        supplies an outlet for messages
   Fix            TRUE if Chkdsk should fix errors
   Verbose        TRUE if Chkdsk should list every file it finds
   OnlyIfDirty    TRUE if the drive should be checked only if
                  it is dirty
   Recover        TRUE if Chkdsk should verify all of the sectors
                  on the disk.
   PathToCheck    Supplies a path to files Chkdsk should check
                  for contiguity
   Extend         Unused (should always be FALSE)
   ExitStatus     Returns exit status to chkdsk.exe

Return Value:

   TRUE if successful.

--*/
{
    FAT_VOL         FatVol;
    BOOLEAN         r;
    PWSTRING        dir_name;
    PWSTRING        name;
    PWSTRING        prefix_name;
    FSN_FILTER      filter;
    PFSN_DIRECTORY  directory;
    PARRAY          file_array;
    PDSTRING        files_to_check;
    ULONG           num_files;
    ULONG           i;
    PFSNODE         fsnode;
    PATH            dir_path;
    DSTRING         backslash;
    PPATH           full_path;
    PREAD_CACHE     read_cache;
    ULONG           exit_status;
    ULONG           flags;

    if (NULL == ExitStatus) {
       ExitStatus = &exit_status;
    }

    if (Extend || !FatVol.Initialize(Message, NtDriveName)) {

       *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
       return FALSE;
    }

    if (Fix && !FatVol.IsWriteable()) {
        Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    if (Fix && !FatVol.Lock()) {

        if (FatVol.IsFloppy()) {

            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display();

        } else {

            //
            // The client wants to fix the drive, but we can't lock it.
            // Offer to fix it on next reboot.
            //
            Message->Set(MSG_CHKDSK_ON_REBOOT_PROMPT);
            Message->Display("");

            if( Message->IsYesResponse( FALSE ) ) {

                if( FatVol.ForceAutochk( Fix,
                                         Recover ? CHKDSK_RECOVER : 0,
                                         0,
                                         0,
                                         NtDriveName ) ) {

                    Message->Set(MSG_CHKDSK_SCHEDULED);
                    Message->Display();

                } else {

                    Message->Set(MSG_CHKDSK_CANNOT_SCHEDULE);
                    Message->Display();
                }
            }
        }

        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;

        return FALSE;
    }

    // Try to enable caching, if there's not enough resources then
    // just run without a cache.

    if ((read_cache = NEW READ_CACHE) &&
        read_cache->Initialize(&FatVol, 75)) {

        FatVol.SetCache(read_cache);

    } else {
        DELETE(read_cache);
    }



    flags = (Verbose ? CHKDSK_VERBOSE : 0);
    flags |= (OnlyIfDirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    flags |= (Recover ? CHKDSK_RECOVER : 0);

    r = FatVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                       Message,
                       flags,
                       0,
                       0,
                       ExitStatus );

    if (!r) {
        return FALSE;
    }

    if (PathToCheck) {

        if (!(name = PathToCheck->QueryName()) ||
            name->QueryChCount() == 0) {

            DELETE(name);
            return TRUE;
        }

        if (!(full_path = PathToCheck->QueryFullPath())) {

            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            DELETE(name);
            return FALSE;
        }

        if (!FatVol.Initialize(Message, NtDriveName)) {
        Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
        DELETE(full_path);
            DELETE(name);
            return FALSE;
        }

        if (!(prefix_name = full_path->QueryPrefix()) ||
            !dir_path.Initialize(prefix_name)) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(prefix_name);
            DELETE(full_path);
            return FALSE;
        }

        if (!(directory = SYSTEM::QueryDirectory(&dir_path)) ||
            !filter.Initialize() ||
            !filter.SetFileName(name)) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(prefix_name);
            DELETE(directory);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(prefix_name);

        if (!(file_array = directory->QueryFsnodeArray(&filter))) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(directory);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(directory);

        if (!(num_files = file_array->QueryMemberCount())) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(directory);
            file_array->DeleteAllMembers();
            DELETE(file_array);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(name);

        if (!(files_to_check = NEW DSTRING[num_files])) {

            ReportFileNotFoundError(full_path, Message);
            file_array->DeleteAllMembers();
            DELETE(file_array);
            DELETE(full_path);
            return FALSE;
        }

        for (i = 0; i < num_files; i++) {

            fsnode = (PFSNODE) file_array->GetAt(i);

            if (!(name = fsnode->QueryName()) ||
                !files_to_check[i].Initialize(name)) {

                ReportFileNotFoundError(full_path, Message);
                DELETE(name);
                file_array->DeleteAllMembers();
                DELETE(file_array);
                // t-raymak: Should use the array version of delete
                // instead.
                // DELETE(files_to_check);
                delete [] files_to_check;
                files_to_check = NULL;
                DELETE(full_path);
                return FALSE;
            }

            DELETE(name);
        }

        file_array->DeleteAllMembers();
        DELETE(file_array);

        if (!(dir_name = full_path->QueryDirs())) {

            if (!backslash.Initialize("\\")) {
                ReportFileNotFoundError(full_path, Message);
                // DELETE(files_to_check);
                delete [] files_to_check;
                files_to_check = NULL;
                DELETE(full_path);
                return FALSE;
            }
        }

        r = FatVol.ContiguityReport(dir_name ? dir_name : &backslash,
                                    files_to_check,
                                    num_files,
                                    Message);

        // DELETE(files_to_check);
        delete [] files_to_check;
        files_to_check = NULL;
        DELETE(dir_name);
        DELETE(full_path);
    }

    return r;
}


BOOLEAN
FAR APIENTRY
ChkdskEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Fix,
    IN      PCHKDSKEX_FN_PARAM  Param,
    IN      PULONG              ExitStatus
   )
/*++

Routine Description:

   Check a FAT volume.

Arguments:

   NtDrivName  supplies the name of the drive to check
   Message     supplies an outlet for messages
   Fix         TRUE if Chkdsk should fix errors on the disk.
   Param       supplies the parameter block
               (see ulib\inc\ifsserv.hxx for details)
   ExitStatus  Returns exit status to chkdsk.exe

Return Value:

   TRUE if successful.

--*/
{
    FAT_VOL         FatVol;
    BOOLEAN         r;
    PWSTRING        dir_name;
    PWSTRING        name;
    PWSTRING        prefix_name;
    FSN_FILTER      filter;
    PFSN_DIRECTORY  directory;
    PARRAY          file_array;
    PDSTRING        files_to_check;
    ULONG           num_files;
    ULONG           i;
    PFSNODE         fsnode;
    PATH            dir_path;
    DSTRING         backslash;
    PPATH           full_path;
    PREAD_CACHE     read_cache;
    ULONG           exit_status;

    if (Param->Major != 1 || (Param->Minor != 0 && Param->Minor != 1)) {
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    if (NULL == ExitStatus) {
       ExitStatus = &exit_status;
    }

    if ((Param->Flags & CHKDSK_EXTEND) ||
        !FatVol.Initialize(Message, NtDriveName)) {

       *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
       return FALSE;
    }

    if (Fix && !FatVol.IsWriteable()) {
        Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    if (Fix && !FatVol.Lock()) {

        BOOLEAN DismntLock = FALSE;
        WCHAR   windows_path[MAX_PATH];
        DSTRING sdrive, nt_drive_name;
        BOOLEAN system_drive = FALSE;

        if (GetWindowsDirectory(windows_path, sizeof(windows_path)/sizeof(WCHAR)) &&
            wcslen(windows_path) >= 2 &&
            windows_path[1] == TEXT(':') &&
            !(windows_path[2] = 0) &&
            sdrive.Initialize(windows_path) &&
            IFS_SYSTEM::DosDriveNameToNtDriveName(&sdrive, &nt_drive_name)) {

            system_drive = nt_drive_name.Stricmp(NtDriveName) == 0;
        } else {

            Message->DisplayMsg(MSG_CHK_UNABLE_TO_TELL_IF_SYSTEM_DRIVE);
            system_drive = FALSE;
        }

        if (!system_drive) {
            if (Param->Flags & CHKDSK_FORCE) {
                if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
                    Message->Set(MSG_VOLUME_DISMOUNTED);
                    Message->Display();
                    if (!FatVol.Initialize(Message, NtDriveName)) {
                        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
                        return FALSE;
                    }
                    if(FatVol.Lock()) {
                        DismntLock = TRUE;
                    }
                }
            } else {
                Message->Set(MSG_CHKDSK_FORCE_DISMOUNT_PROMPT);
                Message->Display("");

                if (Message->IsYesResponse( FALSE )) {
                    if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
                        Message->Set(MSG_VOLUME_DISMOUNTED);
                        Message->Display();
                        if (!FatVol.Initialize(Message, NtDriveName)) {
                            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
                            return FALSE;
                        }
                        if (FatVol.Lock()) {
                            DismntLock = TRUE;
                        }
                    }
                }
            }
        }

        if (!DismntLock) {
            if (FatVol.IsFloppy()) {
                Message->Set(MSG_CANT_LOCK_THE_DRIVE);
                Message->Display();
            } else {
                //
                // The client wants to fix the drive, but we can't lock it.
                // Offer to fix it on next reboot.
                //
                Message->Set(MSG_CHKDSK_ON_REBOOT_PROMPT);
                Message->Display("");

                if( Message->IsYesResponse( FALSE ) ) {

                    if( FatVol.ForceAutochk( Fix,
                                             Param->Flags,
                                             0,
                                             0,
                                             NtDriveName ) ) {

                        Message->Set(MSG_CHKDSK_SCHEDULED);
                        Message->Display();

                    } else {

                        Message->Set(MSG_CHKDSK_CANNOT_SCHEDULE);
                        Message->Display();
                    }
                }
            }
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
    }

    // Try to enable caching, if there's not enough resources then
    // just run without a cache.

    if ((read_cache = NEW READ_CACHE) &&
        read_cache->Initialize(&FatVol, 75)) {

        FatVol.SetCache(read_cache);

    } else {
        DELETE(read_cache);
    }

    Param->Flags &= (~CHKDSK_RESIZE_LOGFILE);   // ignore resize of logfile

    r = FatVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                       Message,
                       Param->Flags,
                       0,
                       0,
                       ExitStatus );

    if (!r) {
        return FALSE;
    }

    if (Param->PathToCheck) {

        if (Param->RootPath) {
            if (!(name = Param->RootPath->QueryName()) ||
                name->QueryChCount() == 0) {

                DELETE(name);
                return TRUE;
            }
        } else {
            if (!(name = Param->PathToCheck->QueryName()) ||
                name->QueryChCount() == 0) {

                DELETE(name);
                return TRUE;
            }
        }

        if (!(full_path = Param->PathToCheck->QueryFullPath())) {

            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            DELETE(name);
            return FALSE;
        }

        if (!FatVol.Initialize(Message, NtDriveName)) {
        Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
        DELETE(full_path);
            DELETE(name);
            return FALSE;
        }

        if (!(prefix_name = full_path->QueryPrefix()) ||
            !dir_path.Initialize(prefix_name)) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(prefix_name);
            DELETE(full_path);
            return FALSE;
        }

        if (!(directory = SYSTEM::QueryDirectory(&dir_path)) ||
            !filter.Initialize() ||
            !filter.SetFileName(name)) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(prefix_name);
            DELETE(directory);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(prefix_name);

        if (!(file_array = directory->QueryFsnodeArray(&filter))) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(directory);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(directory);

        if (!(num_files = file_array->QueryMemberCount())) {

            ReportFileNotFoundError(full_path, Message);
            DELETE(name);
            DELETE(directory);
            file_array->DeleteAllMembers();
            DELETE(file_array);
            DELETE(full_path);
            return FALSE;
        }

        DELETE(name);

        if (!(files_to_check = NEW DSTRING[num_files])) {

            ReportFileNotFoundError(full_path, Message);
            file_array->DeleteAllMembers();
            DELETE(file_array);
            DELETE(full_path);
            return FALSE;
        }

        for (i = 0; i < num_files; i++) {

            fsnode = (PFSNODE) file_array->GetAt(i);

            if (!(name = fsnode->QueryName()) ||
                !files_to_check[i].Initialize(name)) {

                ReportFileNotFoundError(full_path, Message);
                DELETE(name);
                file_array->DeleteAllMembers();
                DELETE(file_array);
                // t-raymak: Should use the array version of delete
                // instead.
                // DELETE(files_to_check);
                delete [] files_to_check;
                files_to_check = NULL;
                DELETE(full_path);
                return FALSE;
            }

            DELETE(name);
        }

        file_array->DeleteAllMembers();
        DELETE(file_array);

        if (Param->RootPath) {
            dir_name = Param->RootPath->QueryDirs();
        } else
            dir_name = full_path->QueryDirs();

        if (!dir_name) {

            if (!backslash.Initialize("\\")) {
                ReportFileNotFoundError(full_path, Message);
                // DELETE(files_to_check);
                delete [] files_to_check;
                files_to_check = NULL;
                DELETE(full_path);
                return FALSE;
            }
        }

        r = FatVol.ContiguityReport(dir_name ? dir_name : &backslash,
                                    files_to_check,
                                    num_files,
                                    Message);

        // DELETE(files_to_check);
        delete [] files_to_check;
        files_to_check = NULL;
        DELETE(dir_name);
        DELETE(full_path);
    }

    return r;
}

FORMAT_ERROR_CODE
ValidateFATClusterSizeArg(
    IN      PDP_DRIVE   DpDrive,
    IN OUT  PMESSAGE    Message,
    IN      ULONG   ClusterSize
    )
/*++

Routine Description:

    This routine does a quick and dirty validation that the specified
    cluster size is a valid cluster size to specify for the drive

    NOTE: This routine saying OK does NOT mean that the cluster size
      is valid, it just means that the cluster size is in the right
      ballpark. It may be rejected later when the format code does
      a more exhaustive check on it.

Arguments:

    DpDrive - Drive object for the drive being formated
    Message     - Supplies an outlet for messages.
    ClusterSize - Supplies the cluster size in bytes

Return Value:

    NoError - Success.
    Other   - Failure.

--*/
{
    ULONG SectorSize;

    SectorSize = DpDrive->QuerySectorSize();
    if(ClusterSize < SectorSize) {
        Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_SMALL_MIN);
        Message->Display("%u", SectorSize);
        return(GeneralError);
    }
    if(ClusterSize > (SectorSize * 128)) {
        Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_BIG);
        Message->Display("%s", "FAT");
        return(GeneralError);
    }
    return(NoError);
}

BOOLEAN
FAR APIENTRY
Format(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Quick,
    IN      BOOLEAN             BackwardCompatible,
    IN      MEDIA_TYPE          MediaType,
    IN      PCWSTRING           LabelString,
    IN      ULONG               ClusterSize
    )
/*++

Routine Description:

    This routine formats a volume for the FAT file system.

Arguments:

    NtDriveName - Supplies the NT style drive name of the volume to format.
    Message     - Supplies an outlet for messages.
    Quick       - Supplies whether or not to do a quick format.
    BackwardCompatible - Supplies whether or not the newly formatted volume
                         will be compatible with FAT16.
    MediaType   - Supplies the media type of the drive.
    LabelString - Supplies a volume label to be set on the volume after
                    format.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PDP_DRIVE   DpDrive;
    FAT_VOL     FatVol;
    BIG_INT     Sectors;
    DSTRING     FileSystemName;
    BOOLEAN     IsCompressed;
    BOOLEAN     ret_status;
    FORMAT_ERROR_CODE   errcode;
    ULONG       flags;
    USHORT      format_type;
    BOOLEAN     send_fmt_cmd, fmt_cmd_capable;

    if( !(DpDrive = NEW DP_DRIVE) ) {

        Message->Set( MSG_FMT_NO_MEMORY );
        Message->Display( "" );
        return FALSE;
    }

#if defined(FE_SB) && defined(_X86_)
    if (IsPC98_N()) {

        // PC98 Nov.01.1994
        // We need to notify DP_DRIVE:Initialize() that we will format media by FAT
        format_type = DP_DRIVE::FAT;
    } else
#endif
    {
        format_type = DP_DRIVE::NONE;
    }

    if (!DpDrive->Initialize(NtDriveName, Message, TRUE, FALSE, format_type)) {
        DELETE( DpDrive );
        return FALSE;
    }

    if (!BackwardCompatible && DpDrive->IsFloppy()) {
        DELETE( DpDrive );
        Message->Set(MSG_FMT_FAT32_NO_FLOPPIES);
        Message->Display();
        return FALSE;
    }

    //
    // Check to see if the volume is too large and determine
    // whether it's compressed.  Volumes with more than 4Gig sectors are
    // not supported by fastfat.
    //
    Sectors = DpDrive->QuerySectors();

    //
    // A drive has to have > 0x0FFFFFF6 * 128 to be too big for
    // FAT32. Since 0x0FFFFFF6 * 128 > 2^32, there is no need for the
    // second condition; besides, ComputeSecClus will never return
    // a sector per cluster value > 128.
    //
#if 0
    if (Sectors.GetHighPart() != 0 ||
        FAT_SA::ComputeSecClus(Sectors.GetLowPart(),
                               LARGE32, MediaType) > MaxSecPerClus) {
#endif
    if (Sectors.GetHighPart() != 0) {

        DELETE( DpDrive );
        Message->Set(MSG_DISK_TOO_LARGE_TO_FORMAT);
        Message->Display();
        return FALSE;
    }

#ifdef DBLSPACE_ENABLED
    // Note that we don't care about the return value from
    // QueryMountedFileSystemName, just whether the volume
    // is compressed.
    //
    DpDrive->QueryMountedFileSystemName( &FileSystemName, &IsCompressed );
#endif // DBLSPACE_ENABLED


    // Do a quick check on the cluster size before we do anything lengthy

    if(ClusterSize
#ifdef DBLSPACE_ENABLED
       && !IsCompressed
#endif // DBLSPACE_ENABLED
          ) {
        errcode = ValidateFATClusterSizeArg(DpDrive,Message,ClusterSize);
        if(errcode != NoError) {
            DELETE( DpDrive );
            ret_status = FALSE;
            return ret_status;
        }
    }

    send_fmt_cmd = DpDrive->IsSonyMS();
    fmt_cmd_capable = DpDrive->IsSonyMSFmtCmdCapable();

    // Delete the DP_DRIVE object so it's handle will go away.
    //

    DELETE( DpDrive );

    if (send_fmt_cmd && ClusterSize) {
        Message->Set(MSG_FMT_CLUS_SIZE_NOT_ALLOWED);
        Message->Display();
        if (!Message->IsYesResponse(FALSE)) {
            return FALSE;
        }
        send_fmt_cmd = FALSE;
    }

    send_fmt_cmd = send_fmt_cmd && fmt_cmd_capable;

    if (send_fmt_cmd && Quick) {

        // If it is a Sony memory stick device that has self formatting capability
        // and the user didn't specify any cluster size then quick format is not
        // allowed since the self formatting capability is basically a long format.
        // The quick format will then be promoted to long format with a warning to
        // the user.
        Message->Set(MSG_FMT_QUICK_FORMAT_NOT_AVAILABLE);
        Message->Display();
        if (Message->IsYesResponse(FALSE)) {
            Quick = FALSE;
        } else {
            return FALSE;
        }
    }

    // Volume is not too large, proceed with format.

    errcode = FatVol.Initialize(NtDriveName,
                                Message,
                                FALSE,
                                !Quick,
                                MediaType,
                                format_type );

    if (errcode == NoError) {
        if (!send_fmt_cmd) {
            flags = BackwardCompatible ? FORMAT_BACKWARD_COMPATIBLE : 0;
            errcode = FatVol.Format(LabelString, Message, flags, ClusterSize);
        } else {
            if (!FatVol.SetVolumeLabelAndPrintFormatReport(LabelString,
                                                           Message)) {
                errcode = GeneralError;
            }
        }
    }

    if (errcode == LockError) {
        Message->Set(MSG_CANT_LOCK_THE_DRIVE);
        Message->Display("");
        ret_status = FALSE;
    } else
        ret_status = (errcode == NoError);

    return ret_status;
}


BOOLEAN
FAR APIENTRY
FormatEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      PFORMATEX_FN_PARAM  Param,
    IN      MEDIA_TYPE          MediaType
    )
/*++

Routine Description:

    This routine formats a volume for the FAT file system.

Arguments:

    NtDriveName - Supplies the NT style drive name of the volume to format.
    Message     - Supplies an outlet for messages.
    Param       - Supplies the format parameter block
    MediaType   - Supplies the media type of the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PDP_DRIVE   DpDrive;
    FAT_VOL     FatVol;
    BIG_INT     Sectors;
    DSTRING     FileSystemName;
    BOOLEAN     IsCompressed;
    BOOLEAN     ret_status;
    FORMAT_ERROR_CODE   errcode;
    BOOLEAN     do_not_dismount = FALSE;
    USHORT      format_type;
    BOOLEAN     send_fmt_cmd;

    if (Param->Major != 1 || Param->Minor != 0) {
        return FALSE;
    }

    if( !(DpDrive = NEW DP_DRIVE) ) {

        Message->Set( MSG_FMT_NO_MEMORY );
        Message->Display( "" );
        return FALSE;
    }

#if defined(FE_SB) && defined(_X86_)
    if (IsPC98_N()) {

        // PC98 Nov.01.1994
        // We need to notify DP_DRIVE:Initialize() that we will format media by FAT
        format_type = DP_DRIVE::FAT;
    } else
#endif
    {
        format_type = DP_DRIVE::NONE;
    }

    if (!DpDrive->Initialize(NtDriveName, Message, TRUE, FALSE, format_type)) {
        DELETE( DpDrive );
        return FALSE;
    }

    if (!(Param->Flags & FORMAT_BACKWARD_COMPATIBLE) &&
        DpDrive->IsFloppy()) {
        DELETE( DpDrive );
        Message->Set(MSG_FMT_FAT32_NO_FLOPPIES);
        Message->Display();
        return FALSE;
    }

    //
    // Check to see if the volume is too large and determine
    // whether it's compressed.  Volumes with more than 4Gig sectors are
    // not supported by fastfat.
    //
    Sectors = DpDrive->QuerySectors();

    //
    // A drive has to have > 0x0FFFFFF6 * 128 to be too big for
    // FAT32. Since 0x0FFFFFF6 * 128 > 2^32, there is no need for the
    // second condition; besides, ComputeSecClus will never return
    // a sector per cluster value > 128.
    //
#if 0
    if (Sectors.GetHighPart() != 0 ||
        FAT_SA::ComputeSecClus(Sectors.GetLowPart(),
                               LARGE32, MediaType) > MaxSecPerClus) {
#endif
    if (Sectors.GetHighPart() != 0) {

        DELETE( DpDrive );
        Message->Set(MSG_DISK_TOO_LARGE_TO_FORMAT);
        Message->Display();
        return FALSE;
    }

#ifdef DBLSPACE_ENABLED
    // Note that we don't care about the return value from
    // QueryMountedFileSystemName, just whether the volume
    // is compressed.
    //
    DpDrive->QueryMountedFileSystemName( &FileSystemName, &IsCompressed );
#endif // DBLSPACE_ENABLED


    // Do a quick check on the cluster size before we do anything lengthy

    if(Param->ClusterSize
#ifdef DBLSPACE_ENABLED
       && !IsCompressed
#endif // DBLSPACE_ENABLED
          ) {
        errcode = ValidateFATClusterSizeArg(DpDrive,Message,Param->ClusterSize);
        if (errcode != NoError) {
            DELETE( DpDrive );
            ret_status = FALSE;
            return ret_status;
        }
    }

    send_fmt_cmd = DpDrive->IsSonyMS();

    if (send_fmt_cmd && Param->ClusterSize) {
        if (Param->Flags & FORMAT_YES) {
            Message->Set(MSG_FMT_CLUS_SIZE_NOT_ALLOWED_WARNING);
            Message->Display();
        } else {
            Message->Set(MSG_FMT_CLUS_SIZE_NOT_ALLOWED);
            Message->Display();
            if (!Message->IsYesResponse(FALSE)) {
                return FALSE;
            }
        }
        send_fmt_cmd = FALSE;
    }

    send_fmt_cmd = send_fmt_cmd && DpDrive->IsSonyMSFmtCmdCapable();

    if (send_fmt_cmd &&
        (Param->Flags & FORMAT_QUICK)) {

        // If it is a Sony memory stick device that has self formatting capability
        // and the user didn't specify any cluster size then quick format is not
        // allowed since the self formatting capability is basically a long format.
        // The quick format will then be promoted to long format with a warning to
        // the user.
        if (Param->Flags & FORMAT_YES) {
            Message->Set(MSG_FMT_QUICK_FORMAT_NOT_AVAILABLE_WARNING);
            Message->Display();
            Param->Flags &= ~FORMAT_QUICK;      // override
        } else {
            Message->Set(MSG_FMT_QUICK_FORMAT_NOT_AVAILABLE);
            Message->Display();
            if (Message->IsYesResponse(FALSE)) {
                Param->Flags &= ~FORMAT_QUICK;      // override
            } else {
                return FALSE;
            }
        }
    }

    // Volume is not too large, proceed with format.
    // Delete the DP_DRIVE object so it's handle will go away.
    //
    DELETE( DpDrive );

    errcode = FatVol.Initialize(NtDriveName,
                                Message,
                                FALSE,
                                (Param->Flags & FORMAT_QUICK) ? FALSE : TRUE,
                                MediaType,
                                format_type);

    if (errcode == NoError) {
        if (!send_fmt_cmd) {
            errcode = FatVol.Format(Param->LabelString,
                                    Message,
                                    Param->Flags,
                                    Param->ClusterSize);
        } else {

            if (!FatVol.SetVolumeLabelAndPrintFormatReport(Param->LabelString,
                                                           Message)) {
                errcode = GeneralError;
            }
        }
    }

    if (errcode == LockError) {

        if (!(Param->Flags & FORMAT_FORCE)) {
            Message->Set(MSG_FMT_FORCE_DISMOUNT_PROMPT);
            Message->Display();

            if (Message->IsYesResponse(FALSE) &&
                IFS_SYSTEM::DismountVolume(NtDriveName)) {
                Message->Set(MSG_VOLUME_DISMOUNTED);
                Message->Display();
            } else {
                do_not_dismount = TRUE;
            }
        } else if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
            Message->Set(MSG_VOLUME_DISMOUNTED);
            Message->Display();
        }

        if (!do_not_dismount) {
            errcode = FatVol.Initialize(NtDriveName,
                                        Message,
                                        FALSE,
                                        (Param->Flags & FORMAT_QUICK) ? FALSE : TRUE,
                                        MediaType,
                                        format_type);

            if (errcode == NoError) {
                if (!send_fmt_cmd) {
                    errcode = FatVol.Format(Param->LabelString,
                                            Message,
                                            Param->Flags,
                                            Param->ClusterSize);
                } else {

                    if (!FatVol.SetVolumeLabelAndPrintFormatReport(Param->LabelString,
                                                                   Message)) {
                        errcode = GeneralError;
                    }
                }
            }
        }

        if (errcode == LockError) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            ret_status = FALSE;
        } else
            ret_status = (errcode == NoError);
    } else
        ret_status = (errcode == NoError);

    return ret_status;
}


BOOLEAN
FAR APIENTRY
Recover(
   IN       PPATH    RecFilePath,
   IN OUT   PMESSAGE Message
   )
/*++

Routine Description:

   Recover a file on a FAT disk.

Arguments:

Return Value:

   TRUE if successful.

--*/
{
    FAT_VOL       FatVol;
    PWSTRING      fullpathfilename;
    PWSTRING      dosdrive;
    DSTRING       ntdrive;

    fullpathfilename = RecFilePath->QueryDirsAndName();
    dosdrive = RecFilePath->QueryDevice();
    if (!dosdrive ||
        !IFS_SYSTEM::DosDriveNameToNtDriveName(dosdrive, &ntdrive)) {

       DELETE(dosdrive);
       DELETE(fullpathfilename);
       return FALSE;
    }

    if (!fullpathfilename) {

       DELETE(dosdrive);
       DELETE(fullpathfilename);
       return FALSE;
    }

    Message->Set(MSG_RECOV_BEGIN);
    Message->Display("%W", dosdrive);
    Message->WaitForUserSignal();

    if (!FatVol.Initialize(Message, &ntdrive)) {
        DELETE(dosdrive);
        DELETE(fullpathfilename);
        return FALSE;
    }

    if (!FatVol.Recover(fullpathfilename, Message)) {
        DELETE(dosdrive);
        DELETE(fullpathfilename);
        return FALSE;
    }

    DELETE(dosdrive);
    DELETE(fullpathfilename);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\fatdent.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    fatdent.cxx

Abstract:

    This class models a FAT directory entry.

Author:

    Norbert P. Kusters (norbertk) 4-Dec-90

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "ifssys.hxx"
#include "wstring.hxx"

// TimeInfo is full of windows stuff.
#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

#include "timeinfo.hxx"

#endif


DEFINE_EXPORTED_CONSTRUCTOR( FAT_DIRENT, OBJECT, UFAT_EXPORT );

VOID
FAT_DIRENT::Construct (
        )
/*++

Routine Description:

    Constructor for FAT_DIRENT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _dirent = NULL;
}


UFAT_EXPORT
FAT_DIRENT::~FAT_DIRENT(
    )
/*++

Routine Description:

    Destructor for FAT_DIRENT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
FAT_DIRENT::Initialize(
    IN OUT  PVOID   Dirent
    )
/*++

Routine Description:

    This routine initializes the object to use the directory entry
    pointed to by Dirent.

Arguments:

    Dirent  - Supplies the directory entry.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _dirent = (PUCHAR) Dirent;
    _FatType = FAT_TYPE_UNKNOWN;
    return _dirent ? TRUE : FALSE;
}


UFAT_EXPORT
BOOLEAN
FAT_DIRENT::Initialize(
    IN OUT  PVOID   Dirent,
    IN      UCHAR   FatType
    )
/*++

Routine Description:

    This routine initializes the object to use the directory entry
    pointed to by Dirent.

Arguments:

    Dirent  - Supplies the directory entry.
    FatType - Supplies the FAT type.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _dirent = (PUCHAR) Dirent;
    _FatType = FatType;
    return _dirent ? TRUE : FALSE;
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryName(
    OUT PWSTRING    Name
    ) CONST
/*++

Routine Description:

    This routine copies the directory entries name to 'Name' in an
    appropriate format.

    Directories and files will be returned in compressed 8.3 format.
    Labels will be returned in compressed 11 character format.

Arguments:

    Name    - Returns the name of the directory entry in the appropriate
              format.

Return Value:

    None.

--*/
{
    LONG    i;
    STR     buf[80];
    DSTRING tmp_string;
    DSTRING tmp2;
    CHNUM   l;

    if (!_dirent) {
        return Name->Initialize();
    }

    if (IsVolumeLabel()) {
        memcpy(buf, _dirent, 11);
        buf[11] = 0;

        if (buf[0] == 0x05) {
            buf[0] = (UCHAR)0xE5;
        }

        if (!tmp_string.Initialize(buf))
            return FALSE;

        l = tmp_string.QueryChCount();

        for (i = l - 1; i >= 0 && tmp_string.QueryChAt(i) == ' '; i--) {
        }

        return Name->Initialize(&tmp_string, 0, i + 1);
    }

    memcpy(buf, _dirent, 8);
    buf[8] = 0;

    if (buf[0] == 0x05) {
        buf[0] = (UCHAR)0xE5;
    }

    if (!tmp_string.Initialize(buf))
        return FALSE;

    if (Is8LowerCase()) {
        tmp_string.Strlwr(0);
    }

    l = tmp_string.QueryChCount();

    // Remove trailing white spaces
    for (i = l - 1; i >= 0 && tmp_string.QueryChAt(i) == ' '; i--) {
    }

    if (!Name->Initialize(&tmp_string, 0, i + 1))
        return FALSE;

    memcpy(buf, &_dirent[8], 3);
    buf[3] = 0;

    if (!tmp_string.Initialize(buf))
        return FALSE;

    if (Is3LowerCase()) {
        tmp_string.Strlwr(0);
    }

    l = tmp_string.QueryChCount();

    for (i = l - 1; i >= 0 && tmp_string.QueryChAt(i) == ' '; i--) {
    }

    if (i + 1) {
        if (!tmp2.Initialize(".") ||
            !Name->Strcat(&tmp2) ||
            !tmp2.Initialize(&tmp_string, 0, i + 1) ||
            !Name->Strcat(&tmp2))
            return FALSE;
    }
    return TRUE;
}

extern VOID DoInsufMemory(VOID);

BOOLEAN
FAT_DIRENT::SetName(
    IN  PCWSTRING   Name
    )
/*++

Routine Description:

    This routine expects a "compressed" null-terminated name in a format
    compatible with the return value of 'QueryName'.

    The validity of the characters in the name will not be checked
    by this routine.  Only that the name has the appropriate
    structure.  The routine "IsValidName" will check the validity
    of the name characters.

Arguments:

    Name    - Supplies the new name for the directory entry.

Return Value:

    FALSE   - The name was invalid.
    TRUE    - The name was successfully set.

--*/
{
    CHNUM   i, j;
    STR     buf[40];
    CHNUM   l;
    DSTRING tmp_string;

    if (IsVolumeLabel()) {
       if (!Name->QuerySTR( 0, TO_END, buf, 40) ||
           (i = strlen(buf)) > 11) {
          return FALSE;
       }

       if (!FAT_SA::IsValidString(Name)) {
          return FALSE;
       }

       memset(&_dirent[i], ' ', (UINT) (11 - i));
       memcpy(_dirent, buf, (UINT) i);

       if (_dirent[0] == 0xE5) {
          _dirent[0] = 0x05;
       }

       return TRUE;
    }

    l = Name->QueryChCount();

    if (Name->QueryChAt(0) == '.' && l == 1) {
        memcpy(_dirent, ".          ", 11);
        return TRUE;
    } else if (Name->QueryChAt(0) == '.' &&
               Name->QueryChAt(1) == '.' &&
               l == 2) {
        memcpy(_dirent, "..         ", 11);
        return TRUE;
    }


    for (i = 0; i < l && Name->QueryChAt(i) != '.'; i++) {
    }

    if (!tmp_string.Initialize(Name, 0, i)) {
    DoInsufMemory();
        return FALSE;
    }

    if (!tmp_string.QuerySTR( 0, TO_END, buf, 40)) {
        return FALSE;
    }

    if ((j = strlen(buf)) > 8) {
        return FALSE;
    }

    memset(&buf[j], ' ', (UINT) (11 - j));

    if (i < l) {
        for (j = i + 1; j < l && Name->QueryChAt(j) != '.'; j++) {
        }

        if (j < l) {
            return FALSE;
        }

        if (i + 1 < l) {
            if (!tmp_string.Initialize(Name, i + 1)) {
        DoInsufMemory();
                return FALSE;
            }

        if (!tmp_string.QuerySTR( 0, TO_END, &buf[8], 32)) {
                return FALSE;
            }

            if ((j = strlen(buf)) > 11) {
                return FALSE;
            }

            memset(&buf[j], ' ', (UINT) (11 - j));
        }
    }

    memcpy(_dirent, buf, 11);

    if (_dirent[0] == 0xE5) {
        _dirent[0] = 0x05;
    }

    return TRUE;
}


BOOLEAN
FAT_DIRENT::IsValidName(
    ) CONST
/*++

Routine Description:

    This routine verifies that the name is composed of valid
    characters.

Arguments:

    None.

Return Value:

    FALSE   - The name is not valid.
    TRUE    - The name is valid.

--*/
{
    DSTRING tmp;
    STR     buf[40];

    // There isn't much to validate as there is no telling of what
    // code page is used when those names are created especially
    // if DBCS.

#if 1
    return TRUE;
#else
    if (!_dirent) {
        DebugPrintTrace(("UFAT: Failure in IsValidName in FAT_DIRENT\n"));
        return FALSE;
    }

    if (IsDot() || IsDotDot()) {
        return IsDirectory();
    }

    memcpy(buf, _dirent, 11);
    buf[11] = 0;

    if (buf[0] == 0x05) {
        buf[0] = (UCHAR)0xE5;
    }

    if (!tmp.Initialize(buf)) {
        return FALSE;
    }

    return FAT_SA::IsValidString(&tmp);
#endif
}


UFAT_EXPORT
BOOLEAN
FAT_DIRENT::IsValidLastWriteTime(
    ) CONST
/*++

Routine Description:

    This routine verifies the validity of the last write time.

Arguments:

    None.

Return Value:

    FALSE   - Invalid time stamp.
    TRUE    - Valid time stamp.

--*/
{
    USHORT  t;
    USHORT  d;

    DebugAssert(_dirent);

    memcpy(&t, &_dirent[22], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[24], sizeof(USHORT)); // date field

    return TimeStampsAreValid(t, d);
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryLastWriteTime(
    OUT LARGE_INTEGER   *TimeStamp
    ) CONST
/*++

Routine Description:

    This routine returns the last write time in the form of a time fields
    structure.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    TIME_FIELDS TimeFields;
    USHORT      t;
    USHORT      d;
    USHORT      year, month, day, hour, minute, second;

    DebugAssert( _dirent );
    DebugPtrAssert( TimeStamp );

    memcpy(&t, &_dirent[22], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[24], sizeof(USHORT)); // date field

    second  = (t&0x001F)*2;     // seconds
    minute  = (t&0x07E0)>>5;    // Minutes
    hour    = t>>11;            // Hours
    day     = d&0x001F;         // Day of month 1-31
    month   = (d&0x01E0)>>5;    // Month
    year    = (d>>9) + 1980;    // Year

    TimeFields.Year         = year;
    TimeFields.Month        = month;
    TimeFields.Day          = day;
    TimeFields.Hour         = hour;
    TimeFields.Minute       = minute;
    TimeFields.Second       = second;
    TimeFields.Milliseconds = 0;

    return RtlTimeFieldsToTime( &TimeFields, (PTIME)TimeStamp );
}



BOOLEAN
FAT_DIRENT::SetLastWriteTime(
    )
/*++

Routine Description:

    This routine sets the last write time to the current date and time.

Arguments:

    None.

Return Value:

    FALSE   - Time stamp was not set successfully.
    TRUE    - Time stamp was set successfully.

--*/
{
    USHORT  fat_time;
    USHORT  fat_date;

    DebugAssert(_dirent);

    LARGE_INTEGER SystemTime, LocalTime;
    TIME_FIELDS Time;


#if !defined( _SETUP_LOADER_ )
    IFS_SYSTEM::QueryNtfsTime( &SystemTime );
    RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
#else
    IFS_SYSTEM::QueryNtfsTime( &LocalTime );
#endif

    RtlTimeToTimeFields(&LocalTime, &Time);

    fat_time = Time.Second/2;
    fat_time |= Time.Minute<<5;
    fat_time |= Time.Hour<<11;

    fat_date = Time.Day;
    fat_date |= Time.Month<<5;
    fat_date |= (Time.Year - 1980)<<9;

        memcpy(&_dirent[22], &fat_time, sizeof(USHORT));
    memcpy(&_dirent[24], &fat_date, sizeof(USHORT));

    return TRUE;
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::IsValidCreationTime(
    ) CONST
/*++

Routine Description:

    This routine verifies the validity of the creation time.

Arguments:

    None.

Return Value:

    FALSE   - Invalid time stamp.
    TRUE    - Valid time stamp.

--*/
{
    USHORT  t;
    USHORT  d;

    DebugAssert(_dirent);

    memcpy(&t, &_dirent[14], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[16], sizeof(USHORT)); // date field

    return TimeStampsAreValid(t, d);

}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryCreationTime(
    OUT LARGE_INTEGER   *TimeStamp
    ) CONST
/*++

Routine Description:

    This routine returns the creation time in the form of a time fields
    structure.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    TIME_FIELDS TimeFields;
    USHORT      t;
    USHORT      d;
    USHORT      msec;
    USHORT      year, month, day, hour, minute, second;

    DebugAssert( _dirent );
    DebugPtrAssert( TimeStamp );

    memcpy(&t, &_dirent[14], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[16], sizeof(USHORT)); // date field
    msec = _dirent[13] * 10;                  // msec field

    second  = (t&0x001F)*2;     // seconds
    minute  = (t&0x07E0)>>5;    // Minutes
    hour    = t>>11;            // Hours
    day     = d&0x001F;         // Day of month 1-31
    month   = (d&0x01E0)>>5;    // Month
    year    = (d>>9) + 1980;    // Year

    if (msec >= 1000) {
        second += 1;
        msec -= 1000;
    }

    TimeFields.Year         = year;
    TimeFields.Month        = month;
    TimeFields.Day          = day;
    TimeFields.Hour         = hour;
    TimeFields.Minute       = minute;
    TimeFields.Second       = second;
    TimeFields.Milliseconds = msec;

    return RtlTimeFieldsToTime( &TimeFields, (PTIME)TimeStamp );
}

BOOLEAN
FAT_DIRENT::SetCreationTime(
    )
/*++

Routine Description:

    This routine sets the creation time to the current date and time.

Arguments:

    None.

Return Value:

    FALSE   - Time stamp was not set successfully.
    TRUE    - Time stamp was set successfully.

--*/
{
    USHORT  fat_time;
    USHORT  fat_date;

    DebugAssert(_dirent);

    LARGE_INTEGER SystemTime, LocalTime;
    TIME_FIELDS Time;


#if !defined( _SETUP_LOADER_ )
    IFS_SYSTEM::QueryNtfsTime( &SystemTime );
    RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
#else
    IFS_SYSTEM::QueryNtfsTime( &LocalTime );
#endif

    RtlTimeToTimeFields(&LocalTime, &Time);

    fat_time = Time.Second/2;
    fat_time |= Time.Minute<<5;
    fat_time |= Time.Hour<<11;

    fat_date = Time.Day;
    fat_date |= Time.Month<<5;
    fat_date |= (Time.Year - 1980)<<9;

    memcpy(&_dirent[14], &fat_time, sizeof(USHORT));
    memcpy(&_dirent[16], &fat_date, sizeof(USHORT));

    return TRUE;
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::IsValidLastAccessTime(
    ) CONST
/*++

Routine Description:

    This routine verifies the validity of the last access time.

Arguments:

    None.

Return Value:

    FALSE   - Invalid time stamp.
    TRUE    - Valid time stamp.

--*/
{
    USHORT  t = 0;
    USHORT  d;

    DebugAssert(_dirent);

    memcpy(&d, &_dirent[18], sizeof(USHORT)); // date field

    return TimeStampsAreValid(t, d);
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryLastAccessTime(
    OUT LARGE_INTEGER   *TimeStamp
    ) CONST
/*++

Routine Description:

    This routine returns the last access time in the form of a time fields
    structure.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    TIME_FIELDS TimeFields;
    USHORT      t;
    USHORT      d;
    USHORT      year, month, day, hour, minute, second;

    DebugAssert( _dirent );
    DebugPtrAssert( TimeStamp );

    t = 0;                                    // no time for last access; just date
    memcpy(&d, &_dirent[18], sizeof(USHORT)); // date field

    second  = (t&0x001F)*2;     // seconds
    minute  = (t&0x07E0)>>5;    // Minutes
    hour    = t>>11;            // Hours
    day     = d&0x001F;         // Day of month 1-31
    month   = (d&0x01E0)>>5;    // Month
    year    = (d>>9) + 1980;    // Year

    TimeFields.Year         = year;
    TimeFields.Month        = month;
    TimeFields.Day          = day;
    TimeFields.Hour         = hour;
    TimeFields.Minute       = minute;
    TimeFields.Second       = second;
    TimeFields.Milliseconds = 0;

    return RtlTimeFieldsToTime( &TimeFields, (PTIME)TimeStamp );
}

BOOLEAN
FAT_DIRENT::SetLastAccessTime(
    )
/*++

Routine Description:

    This routine sets the last access time to the current date and time.

Arguments:

    None.

Return Value:

    FALSE   - Time stamp was not set successfully.
    TRUE    - Time stamp was set successfully.

--*/
{
    USHORT  fat_date;

    DebugAssert(_dirent);

    LARGE_INTEGER SystemTime, LocalTime;
    TIME_FIELDS Time;


#if !defined( _SETUP_LOADER_ )
    IFS_SYSTEM::QueryNtfsTime( &SystemTime );
    RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
#else
    IFS_SYSTEM::QueryNtfsTime( &LocalTime );
#endif

    RtlTimeToTimeFields(&LocalTime, &Time);

    fat_date = Time.Day;
    fat_date |= Time.Month<<5;
    fat_date |= (Time.Year - 1980)<<9;

    memcpy(&_dirent[18], &fat_date, sizeof(USHORT));

    return TRUE;
}

VOID
FAT_DIRENT::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _dirent = NULL;
}

UCHAR
RotateCharRight(
    IN  UCHAR   Char,
    IN  INT     Shift
    )
/*++

Routine Description:

    This function rotates an eight-bit character right by the
    specified number of bits.

Arguments:

    Char    --  Supplies the character to rotate
    Shift   --  Supplies the number of bits to shift

Return Value:

    The rotated character.

--*/
{
    UCHAR low_bit;

    Shift %= 8;

    while( Shift-- ) {

        low_bit = Char & 1;
        Char >>= 1;
        if( low_bit ) {
            Char |= 0x80;
        }
    }

    return (UCHAR)Char;
}

UCHAR
FAT_DIRENT::QueryChecksum(
    ) CONST

/*++

Routine Description:

    This method gets the checksum from the directory entry.  If
    the entry is a short entry, the checksum is computed; if the
    entry is long, the checksum field is returned.

Arguments:

    None.

Return Value:

    The directory entry's checksum.

--*/
{
    int name_length;
    UCHAR sum;
    PUCHAR name;

    if( IsLongEntry() ) {

        return( _dirent[13] );

    } else {

        sum = 0;
        name = _dirent;
        for( name_length = 11; name_length != 0; name_length-- ) {

            sum = RotateCharRight(sum, 1) + *name++;
        }

        return( sum );
    }
}

BOOLEAN
FAT_DIRENT::IsWellTerminatedLongNameEntry(
    ) CONST
/*++

Routine Description:

    This method determines whether the entry is a well-terminated
    long-name entry.  A long-name entry is well terminated if:


--*/
{
    ULONG   i;
    WCHAR   Name[13];

    if( IsErased() || !IsLongNameEntry() ) {

        return FALSE;
    }

    // Assemble the bits and pieces of the name:
    //
    memcpy( &Name[0], &_dirent[1], 10 );
    memcpy( &Name[5], &_dirent[14], 12 );
    memcpy( &Name[11], &_dirent[28], 4 );

    if( IsLastLongEntry() ) {

        //
        // Valid syntax for the last name entry is:
        //
        //     N* {0 0xFFFF*}
        //
        // where N is the set of non-null characters.
        //
        for( i = 0; i < 13; i++ ) {

            if( Name[i] == 0 ) {

                break;
            }
        }

        if( i < 13 ) {

            //
            // We hit a null character--step over it.
            //
            i++;
        }

        //
        // The rest of the name-component must be 0xFFFF.
        //
        for( ; i < 13; i++ ) {

            if( Name[i] != 0xFFFF ) {

                return FALSE;
            }
        }

        // This name-component was accepted.
        //
        return TRUE;

    } else {

#if 0
        // This is an additional consistency check that
        // could be performed; however, now (as of 3/28/94)
        // the file-system doesn't care, so neither do we.

        // This is not the last component of the name, so
        // it can't have any NULL's in it.
        //
        for( i = 0; i < 13; i++ ) {

            if( Name[i] == 0 ) {

                return FALSE;
            }
        }
#endif

        return TRUE;
    }
}

BOOLEAN
FAT_DIRENT::QueryLongNameComponent(
    OUT PWSTRING    NameComponent
    ) CONST
/*++

Routine Description:

    This method extracts the long-name component from a Long Name
    Directory Entry.

Arguments:

    NameComponent   --  Receives the long-name component

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG   i;
    WCHAR   Name[13];

    if( IsErased() || !IsLongNameEntry() ) {

        return FALSE;
    }

    // Assemble the bits and pieces of the name:
    //
    memcpy( &Name[0], &_dirent[1], 10 );
    memcpy( &Name[5], &_dirent[14], 12 );
    memcpy( &Name[11], &_dirent[28], 4 );

    // Long names may be zero terminated; however, if the
    // name fits exactly into n long entries will not be
    // zero terminated.
    //
    for( i = 0; i < 13 && Name[i]; i++ );

    return( NameComponent->Initialize( Name, i ) );
}

BOOLEAN
FAT_DIRENT::NameHasTilde(
    ) CONST
/*++

Routine Description:

    This routine checks a short name entry to see if it contains a tilde.

Arguments:

    None.

Return Value:

    TRUE                        - Tilde.
    FALSE                       - No tilde.

--*/
{
    USHORT i;

    if (IsErased() || IsLongNameEntry()) {
        return FALSE;
    }

    for (i = 0; i < 11; ++i) {
        if ('~' == _dirent[i]) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOLEAN
FAT_DIRENT::NameHasExtendedChars(
    ) CONST
/*++

Routine Description:

    This routine determines whether there are any extended chars
    (those with value >= 0x80) in the short file name.

Arguments:

    None.

Return Value:

    TRUE    - There are one or more extended chars.
    FALSE   - There are no extended chars.

--*/
{
    USHORT i;

    if (IsErased() || IsLongNameEntry()) {
        return FALSE;
    }

    for (i = 0; i < 11; ++i) {
        if (_dirent[i] >= 0x80) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOLEAN
FAT_DIRENT::TimeStampsAreValid(
    USHORT t,
    USHORT d
    ) CONST
/*++

Routine Description:

    This routine examines the given time and date fields and
    determines whether they represent valid dates.

Arguments:

    None.

Return Value:

    TRUE    - The time and date are valid.
    FALSE   - One or both are invalid.

--*/
{
    USHORT  tmp;

    if (t != 0) {
        tmp = t&0x001F;         // 2-second increments
        if (tmp > 29) {
            return FALSE;
        }
    
        tmp = (t&0x07E0)>>5;    // Minutes
        if (tmp > 59) {
            return FALSE;
        }
    
        tmp = (t&0xF800)>>11;   // Hours
        if (tmp > 23) {
            return FALSE;
        }
    }

    if (d != 0) {
        tmp = d&0x001F;         // Day of month
        if (tmp < 1 || tmp > 31) {
            return FALSE;
        }
    
        tmp = (d&0x01E0)>>5;    // Month
        if (tmp < 1 || tmp > 12) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
FAT_DIRENT::IsValidLongName(
    PWSTRING    LongName
    )
/*++

Routine Description:

    This method validates the content of a long name.

Arguments:

    LongName    - Supplies the long name to be validated.

Return Value:

    TRUE if name is valid.

--*/
{
    ULONG   i;

    if (LongName->QueryChCount() == 0)
        return FALSE;

    for (i=0; i<LongName->QueryChCount(); i++) {
        switch (LongName->QueryChAt(i)) {
            case L'*':
            case L'?':
            case L'/':
            case L'\\':
            case L'|':
            case L':':
            case L'<':
            case L'>':
            case L'"':
                return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\fatsacnv.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UFAT_MEMBER_

#include "ulib.hxx"
#include "ufat.hxx"

#include "cluster.hxx"
#include "cmem.hxx"
#include "error.hxx"
#include "fatdent.hxx"
#include "fatsa.hxx"
#include "rootdir.hxx"
#include "rtmsg.h"
#include "sortlist.hxx"
#include "sortlit.hxx"
#include "filedir.hxx"
#include "fat.hxx"
#include "reloclus.hxx"
#include "intstack.hxx"

// #include "keyboard.hxx"


UFAT_EXPORT
BOOLEAN
FAT_SA::QueryCensusAndRelocate (
    OUT     PCENSUS_REPORT  CensusReport,
    IN OUT  PINTSTACK       RelocationStack,
    OUT     PBOOLEAN        Relocated
    )

/*++

Routine Description:

    This function serves a double purpose:

    1.- Generates a census report containing the number and size of different
        FAT structures. This report is somewhat similar to the ChkDsk report.

    2.- Relocates clusters to free areas of the disk.

    Depending on the input parameters, this method may generate the census
    report, relocate clusters, both, or none.

Arguments:

    CensusReport    -   Supplies a pointer to the buffer that will contain
                        the census report.

    RelocationStack -   Supplies a stack with the runs to be relocated.
                        The runs have to be pushed onto the stack as
                        (Start, Size) tuples, with the Size value being
                        pushed first. Both values must be given in sectors.


    Relocated       -   Supplies pointer to boolean which is set to TRUE
                        if any cluster was relocated.

Return Value:

    BOOLEAN -   TRUE if (if requested) the census report was generated and
                if (if requested) the clusters were relocated.
--*/

{
    ULONG       RelocatedChain;         //  Chain of relocated clusters
    SORTED_LIST ClustersToRelocate;     //  List of clusters to relocate

    *Relocated = FALSE;

    //
    //  Initialize the list of clusters to relocate and the relocated chain.
    //  The Relocated chain is the chain of clusters that have been relocated,
    //  it exists so that the clusters that have been freed by relocation
    //  are not re-used while relocating other clusters.
    //
    if ( !ClustersToRelocate.Initialize( ) ) {
        return FALSE;
    }

    RelocatedChain = 0;

    //
    //  If a Relocation stack is provided, relocate all clusters that can
    //  be easily relocated and put all other clusters in the
    //  ClustersToRelocate list.
    //
    //  The clusters that are easily relocated are those that are not the
    //  first cluster of a chain. These clusters can be relocated by copying
    //  their contents and then patching the chain.  Clusters that are the
    //  head of a chain require us to traverse the filesystem tree in order
    //  to locate their corresponding directory entry.
    //
    if ( RelocationStack ) {

        //
        //  InitRelocationList takes care of relocating all "easy" clusters.
        //  It puts the rest of the clusters (i.e. those that are head of
        //  chains) in the ClustersToRelocate list.
        //
        if ( !InitRelocationList( RelocationStack,
                                  &RelocatedChain,
                                  &ClustersToRelocate,
                                  Relocated ) ) {

            ClustersToRelocate.DeleteAllMembers( );

            return FALSE;
        }

        //
        //  The RelocationStack should be empty. All the clusters that it
        //  specified have either been relocated or are now in the
        //  ClustersToRelocate list.
        //
        DebugAssert( RelocationStack->QuerySize() == 0 );

    }

    //
    //  If we need to, traverse the directory tree obtaining the census
    //  and/or relocating the clusters in the ClustersToRelocate list.
    //
    if ( CensusReport || (ClustersToRelocate.QueryMemberCount() > 0 ) ) {

        if ( !DoVolumeCensusAndRelocation( CensusReport,
                                           &ClustersToRelocate,
                                           &RelocatedChain,
                                           Relocated ) ) {

            ClustersToRelocate.DeleteAllMembers( );

            return FALSE;
        }

        DebugAssert( ClustersToRelocate.QueryMemberCount() == 0 );
    }

    //
    //  All the clusters in the relocation stack have been relocated,
    //  we can now free the clusters in the RelocatedChain.
    //
    if ( RelocatedChain ) {
        _fat->FreeChain( RelocatedChain );
    }

    //
    //  Write the fat to disk
    //
    return Write();
}




BOOLEAN
FAT_SA::InitRelocationList(
    IN OUT  PINTSTACK       RelocationStack,
    IN OUT  PULONG          RelocatedChain,
    IN OUT  PSORTED_LIST    ClustersToRelocate,
    OUT     PBOOLEAN        Relocated
    )
/*++

Routine Description:

    Takes runs of sectors out of a relocation stack and converts the sectors
    into clusters. If a cluster is easily relocatable, this method relocates
    the cluster and adds the cluster to the RelocatedChain. Otherwise the
    cluster is added to the ClustersToRelocate list.

    If everything goes right, upon return the RelocationStack is empty, and
    every cluster it specified is either in the RelocatedChain or in the
    ClustersToRelocate list.

    Note that the relocation stack specifies runs of SECTORS. This method converts
    the sectors to FAT clusters.

Arguments:

    RelocationStack     -   Supplies the Relocation stack
    RelocatedChain      -   Supplies the chain of relocated clusters
    ClustersToRelocate  -   Supplies the list of cluisters to relocate
    Relocated           -   Supplies pointer to relocated flag

Return Value:

    BOOLEAN -   TRUE if all the clusters in the runs were added to some
                list.

--*/

{

    SORTED_LIST             RelocatedList;          //  List of relocated clusters
    PSORTED_LIST_ITERATOR   ToRelocateIterator;     //  Iterates over ClustersToRelocate
    PSORTED_LIST_ITERATOR   RelocatedIterator;      //  Iterates over RelocatedList
    BIG_INT                 FirstSector;            //  First sector in run
    BIG_INT                 Size;                   //  Size of run
    BIG_INT                 Sector;                 //  Iterates over each run
    ULONG                   Offset;                 //  Offset within run
    ULONG                   Cluster;                //  Cluster to move
    ULONG                   Previous;               //  Previous in chain
    RELOCATION_CLUSTER      TmpCluster;             //  Tmp. Cluster
    PRELOCATION_CLUSTER     RelCluster;             //  To put in cluster list
    UCHAR                   FatType;
    BOOLEAN                 InRange;


    DebugPtrAssert( RelocationStack   );
    DebugPtrAssert( RelocatedChain    );
    DebugPtrAssert( ClustersToRelocate);
    DebugAssert( ( RelocationStack->QuerySize() % 2 ) == 0 );

    if ( GetFileDir() )
       FatType = FAT_TYPE_FAT32;
    else
       FatType = FAT_TYPE_EAS_OKAY;

    if ( RelocatedList.Initialize()                             &&
         (RelocatedIterator  = (PSORTED_LIST_ITERATOR)(RelocatedList.QueryIterator()) )   &&
         (ToRelocateIterator = (PSORTED_LIST_ITERATOR)(ClustersToRelocate->QueryIterator()) ) ) {

        while ( RelocationStack->QuerySize() > 0 ) {

            //
            //  Take a Run (i.e. a <FirstSector, Size> tuple) off the stack.
            //
            FirstSector = RelocationStack->Look( 0 );
            Size        = RelocationStack->Look( 1 );
            RelocationStack->Pop( 2 );

            DebugPrintTrace(( "    Relocating: Sector %X, size %X\n",
                            FirstSector.GetLowPart(), Size.GetLowPart() ));

            //
            //  Convert the run into a sequence of clusters and determine
            //  what to do with those clusters.
            //
            Offset      = 0;
            while ( Offset < Size.GetLowPart() ) {

                //
                //  Get the sector to relocate
                //
                Sector = FirstSector + Offset;

                //
                //  Get the cluster in which that sector lives
                //
                Cluster = (ULONG)(((Sector - QueryStartDataLbn() )/ (ULONG)QuerySectorsPerCluster()).GetLowPart() + FirstDiskCluster);

                //
                //  Initialize the tmp. cluster and reset iterators
                //
                TmpCluster.Initialize( Cluster );
                RelocatedIterator->Reset();
                ToRelocateIterator->Reset();

                InRange = _fat->IsInRange( Cluster );

                if ( InRange ) {
                    DebugPrintTrace(( "    Cluster to relocate: %X ( Sector %X ) Contents %X \n",
                                     Cluster, Sector.GetLowPart(), _fat->QueryEntry( Cluster )));
                }
                //
                //  If the cluster is already in a list, ignore it.
                //
                if ( InRange &&
                     !RelocatedIterator->FindNext( &TmpCluster ) &&
                     !ToRelocateIterator->FindNext( &TmpCluster ) ) {

                    //
                    //  New cluster. Determine what to do with it
                    //
                    if ( !(RelCluster = NEW RELOCATION_CLUSTER) ) {
                        break;
                    }

                    RelCluster->Initialize( Cluster );

                    if ( _fat->IsClusterFree( Cluster ) ) {

                        //
                        //  The cluster is already free. Add it to the
                        //  RelocatedChain.
                        //
                        DebugPrintTrace(( "        Cluster %X already free\n", Cluster ));
                        *RelocatedChain = _fat->InsertChain( *RelocatedChain, Cluster );
                        RelocatedList.Put( RelCluster );

                    } else if ( Previous =
                                //
                                //  Assume that the clusters in the run are part of
                                //  a chain. If the previous cluster number is the
                                //  previous in the chain, then we don't have to
                                //  search the FAT
                                //
                                (_fat->QueryEntry( Cluster - 1 ) == Cluster) ?
                                ( Cluster - 1 ) :
                                _fat->QueryPrevious( Cluster ) ) {

                        //
                        //  The cluster is not the first of a chain. We can
                        //  relocate it right away.
                        //
                        DebugPrintTrace(( "        Cluster %X not head of chain\n", Cluster ));
                        if ( !RelocateOneCluster( Cluster, Previous ) ) {
                            DELETE( RelCluster );
                            break;
                        }
                        *Relocated = TRUE;
                        *RelocatedChain = _fat->InsertChain( *RelocatedChain, Cluster );
                        RelocatedList.Put( RelCluster );

                    } else if ( _fat->IsClusterBad( Cluster ) ) {

                        //
                        //  Bad cluster. We will stop relocating clusters.
                        //
                        DebugPrintTrace(( "        Cluster %X is Bad!\n", Cluster ));
                        DELETE( RelCluster );
                        break;

                    } else {

                        //
                        //  The first cluster of a chain. Some directory
                        //  must make reference to it, but we don't know
                        //  which directory, so we put the cluster in the
                        //  ClusterToRelocate list.
                        //
                        DebugPrintTrace(( "        Cluster %X head of chain\n", Cluster ));
                        ClustersToRelocate->Put( RelCluster );
                    }
                }

                Offset++;
            }

            //
            //  If could not process all the sectors in the run, something
            //  failed. Get out.
            //
            if ( Offset < Size.GetLowPart() ) {
                break;
            }
        }

        DELETE( RelocatedIterator );
        DELETE( ToRelocateIterator );
        RelocatedList.DeleteAllMembers();

        return ((RelocationStack->QuerySize() == 0) && ( Offset >= Size.GetLowPart() ) );
    }

    return FALSE;
}



BOOLEAN
FAT_SA::RelocateFirstCluster(
    IN OUT  PFAT_DIRENT Dirent
    )

/*++

Routine Description:

    Relocates the first cluster of the file described by a directory
    entry.

Arguments:

    Dirent      -   Supplies the directory entry

Return Value:

    BOOLEAN -   TRUE if cluster relocated.

--*/
{

    HMEM            Hmem;           //  Memory
    ULONG           OldCluster;     //  Original cluster
    ULONG           NewCluster;     //  New cluster
    CLUSTER_CHAIN   ClusterChain;   //  Cluster chain

    DebugPtrAssert( Dirent );

    //
    //  Allocate a free cluster
    //
    if ( !Hmem.Initialize() ||
         !( NewCluster = _fat->AllocChain( 1 ) ) ) {
        return FALSE;
    }

    //
    //  Copy the contents of the cluster to the new cluster
    //
    OldCluster = Dirent->QueryStartingCluster();

    // DebugPrintTrace(( "        Relocating cluster %X -> %X\n", OldCluster, NewCluster ));

    if ( ClusterChain.Initialize( &Hmem, _drive, this, _fat, OldCluster, 1 ) &&
         ClusterChain.Read()                                                 &&
         ClusterChain.Initialize( &Hmem, _drive, this, _fat, NewCluster, 1 ) &&
         ClusterChain.Write() ) {

        //
        //  Patch the cluster chain
        //
        _fat->SetEntry( NewCluster, _fat->QueryEntry( OldCluster ) );

        //
        //  Patch the directory entry. Note that if we crash, we're ok because
        //  the new cluster that we point to is valid. The original cluster would
        //  be an orphan and can be recovered by ChkDsk.
        //
        Dirent->SetStartingCluster( NewCluster );
        _fat->SetClusterFree( OldCluster );

        // DebugPrintTrace(( "            Directory entry patched.\n"));
        return TRUE;
    }

    //
    //  Could not relocate the cluster, Free the new cluster
    //
    _fat->FreeChain( NewCluster );
    return FALSE;
}






ULONG
FAT_SA::RelocateOneCluster(
    IN  ULONG   Cluster,
    IN  ULONG   Previous
    )

/*++

Routine Description:

    Relocates one cluster given its cluster number and the previous
    cluster in its chain.

Arguments:

    Cluster     -   Supplies cluster to relocate
    Previous    -   Supplies the previous cluster in the chain

Return Value:

    ULONG   -   Cluster where the cluster was relocated

--*/
{

    HMEM            Hmem;           //  Memory
    ULONG           NewCluster;     //  New cluster
    CLUSTER_CHAIN   ClusterChain;   //  Cluster chain

    DebugAssert( Cluster );
    DebugAssert( Previous );

    //
    //  Allocate a free cluster
    //
    if ( !Hmem.Initialize() ||
         !( NewCluster = _fat->AllocChain(1)) ) {
        return FALSE;
    }

    // DebugPrintTrace(( "        Relocating cluster %X -> %X\n", Cluster, NewCluster ));

    //
    //  Copy the contents of the cluster to the new cluster
    //
    if ( ClusterChain.Initialize( &Hmem, _drive, this, _fat, Cluster, 1 )    &&
         ClusterChain.Read()                                                 &&
         ClusterChain.Initialize( &Hmem, _drive, this, _fat, NewCluster, 1 ) &&
         ClusterChain.Write() ) {

        //
        //  Patch the chain. We set the new cluster first, so that if we crash,
        //  the previous cluster will always point to a valid cluster (either the
        //  original one or the new one), the chain will remain consistent and
        //  ChkDsk will remove orphans.
        //
        _fat->SetEntry( NewCluster, _fat->QueryEntry( Cluster ) );
        _fat->SetEntry( Previous, NewCluster );
        _fat->SetClusterFree( Cluster );

        // DebugPrintTrace(( "            Done, Chain: Prev[%X (%X)] - [%X (%X)]\n",
        //            Previous,
        //            _fat->QueryEntry(Previous),
        //            NewCluster,
        //            _fat->QueryEntry(NewCluster)
        //            ));

        return NewCluster;
    }

    //
    //  Could not relocate the cluster, Free the new cluster
    //
    _fat->FreeChain( NewCluster );
    return 0;
}






BOOLEAN
FAT_SA::DoVolumeCensusAndRelocation(
    IN OUT  PCENSUS_REPORT  CensusReport,
    IN OUT  PSORTED_LIST    ClustersToRelocate,
    IN OUT  PULONG          RelocatedChain,
    OUT     PBOOLEAN        Relocated
    )
/*++

Routine Description:

    Does a volume census and/or relocates clusters in the supplied
    relocation list.

Arguments:

    CensusReport        -   Supplies pointer to the census report structure
    ClustersToRelocate  -   Supplies pointer to list of clusters to relocate
    RelocatedChain      -   Supplies pointer to chain of relocated clusters
    Relocated           -   Supplies pointer to relocated flag

Return Value:

    BOOLEAN -   TRUE if census report obtained (if requested) and all
                the clusters in the relocation list were relocated (if
                requested).

--*/
{
    PFATDIR     RootDir;    //  Root directory
    FAT_DIRENT  DirEnt;     //  Directory entry for iterating thru directory
    DSTRING     EAFile;     //  Name of EA file
    UCHAR       FatType;

    DebugAssert( !ClustersToRelocate || RelocatedChain );

    //
    //  If there is something to do, do it.
    //
    if ( CensusReport ||
         (ClustersToRelocate && ClustersToRelocate->QueryMemberCount() > 0) ) {

        //
        //  Initialize the Census report if requested
        //
        if ( CensusReport ) {
            CensusReport->FileEntriesCount  =   0;
            CensusReport->FileClusters      =   0;
            CensusReport->DirEntriesCount   =   0;
            CensusReport->DirClusters       =   0;
            CensusReport->EaClusters        =   0;
        }

        //
        //  Get root directory
        //
        RootDir = (PFATDIR)GetRootDir();
        if ( !RootDir ) {
            RootDir = (PFATDIR)GetFileDir();
            FatType = FAT_TYPE_FAT32;
        }
        else
            FatType = FAT_TYPE_EAS_OKAY;

        DebugPtrAssert( RootDir );

        //
        //  Do the census of the volume by recursively obtaining the
        //  census of the root directory.
        //
        if ( DoDirectoryCensusAndRelocation( RootDir,
                                             CensusReport,
                                             ClustersToRelocate,
                                             RelocatedChain,
                                             Relocated ) ) {

            //
            //  If a census report is requested, find out the size of
            //  the EA file (if it exists).
            //
            if ( CensusReport ) {
                EAFile.Initialize( "EA DATA. SF" );

                if ( DirEnt.Initialize( (PFAT_DIRENT)RootDir->SearchForDirEntry( &EAFile ), FatType) ) {
                    CensusReport->EaClusters =
                       (ULONG)((ULONG)DirEnt.QueryFileSize()/
                                (_drive->QuerySectorSize()*QuerySectorsPerCluster())+1);
                }
            }
        } else {

            //
            //  Could not do the directory census
            //
            return FALSE;
        }
    }

        return TRUE;

}




BOOLEAN
FAT_SA::DoDirectoryCensusAndRelocation(
    IN OUT  PFATDIR         Directory,
    IN OUT  PCENSUS_REPORT  CensusReport,
    IN OUT  PSORTED_LIST    ClustersToRelocate,
    IN OUT  PULONG          RelocatedChain,
    OUT     PBOOLEAN        Relocated
    )
/*++

Routine Description:

    Does the census and cluster relocation of a directory an all
    its subdirectories.

Arguments:

    Directory           -   Supplies the directory
    CensusReport        -   Supplies pointer to the census report structure
    ClustersToRelocate  -   Supplies pointer to list of clusters to relocate
    RelocatedChain      -   Supplies pointer to chain of relocated clusters
    Relocated           -   Supplies pointer to relocated flag

Return Value:

    BOOLEAN -   TRUE if census report obtained (if requested) and all
                the clusters in the relocation list (if provided) that
                were references by this directory (or a subdirectory)
                were relocated.

--*/

{

    FAT_DIRENT              Dirent;                     //  For iterating thru Dir
    HMEM                    HMem;                       //  Memory
    FILEDIR                 FileDir;                    //  Subdir
    RELOCATION_CLUSTER      TmpCluster;                 //  Tmp. cluster
    PRELOCATION_CLUSTER     ClusterToRelocate;          //  Cluster to relocate
    PRELOCATION_CLUSTER     RelocatedCluster;           //  Cluster relocated
    PITERATOR               Iterator        =   NULL;   //  Iterates thru ClustersToRelocate
    ULONG                   EntryNumber     =   0;      //  Iterates thru Directorty
    BOOLEAN                 Ok              =   TRUE;   //  FALSE if error
    BOOLEAN                 RelocatedHere   =   FALSE;  //  True if relocated something
    UCHAR                   FatType;

    if ( _dir ) {
        FatType = FAT_TYPE_EAS_OKAY;
    } else {
        FatType = FAT_TYPE_FAT32;
    }

    DebugPtrAssert( Directory );

    //
    //  If there are clusters to relocate, get an iterator for searching
    //  thru the list.
    //
    if ( ClustersToRelocate && ClustersToRelocate->QueryMemberCount() > 0 ) {
        Iterator = ClustersToRelocate->QueryIterator();
        if ( !Iterator ) {
            return FALSE;
        }
    }

    while ( Ok &&
            (CensusReport || (ClustersToRelocate && ClustersToRelocate->QueryMemberCount() > 0)) ) {

        //
        //  Get next directory entry and get out if we reach the end.
        //
        if ( !Dirent.Initialize( Directory->GetDirEntry( EntryNumber ),FatType ) ||
             Dirent.IsEndOfDirectory()
            ) {
            break;
        }

        //
        //  Ignore the deleted, the "parent" and the "self" entries
        //  and any long directory entries
        //
        if ( !( Dirent.IsErased() ||
                Dirent.IsDot()    ||
                Dirent.IsDotDot() ||
                Dirent.IsLongEntry() ) ) {


            //
            //  If a Relocation list is provided, and the first cluster
            //  of the entry is in the relocation list, then relocate
            //  the cluster.
            //
            if ( ClustersToRelocate && ClustersToRelocate->QueryMemberCount() > 0 ) {

                Iterator->Reset();
                TmpCluster.Initialize( Dirent.QueryStartingCluster() );

                if ( ClusterToRelocate = (PRELOCATION_CLUSTER)Iterator->FindNext( &TmpCluster ) ) {

                    //
                    //  Cluster is in the relocation list, relocate it.
                    //
                    if ( !RelocateFirstCluster( &Dirent ) ) {
                        DebugAssert( FALSE );
                        Ok = FALSE;
                        break;
                    }


                    //
                    //  Cluster has been relocated. Remove the cluster from
                    //  the relocation list and add it to the Relocated
                    //  chain.
                    //
                    RelocatedCluster = (PRELOCATION_CLUSTER)ClustersToRelocate->Remove( Iterator );
                    DebugAssert( RelocatedCluster == ClusterToRelocate );
                    *RelocatedChain = _fat->InsertChain( *RelocatedChain, RelocatedCluster->QueryClusterNumber() );
                    DELETE( RelocatedCluster );

                    //
                    //  Set the Relocated flag so that we remember to write out
                    //  the directory when we are done traversing it.
                    //
                    *Relocated    = TRUE;
                    RelocatedHere = TRUE;

                }
            }

            if ( Dirent.IsDirectory() ) {

                //
                //  This is a directory entry, update the census
                //  (if provided) and recurse.
                //
                if( !_fat->IsValidChain( Dirent.QueryStartingCluster() ) ) {

                    Ok = FALSE;
                    break;
                }

                if ( CensusReport ) {
                    CensusReport->DirEntriesCount++;
                    CensusReport->DirClusters += _fat->QueryLengthOfChain( Dirent.QueryStartingCluster() );
                }

                if ( !HMem.Initialize()     ||

                     !FileDir.Initialize( &HMem,
                                          _drive,
                                          this,
                                          _fat,
                                          Dirent.QueryStartingCluster() ) ||

                     !FileDir.Read() ||

                     !DoDirectoryCensusAndRelocation( &FileDir,
                                                      CensusReport,
                                                      ClustersToRelocate,
                                                      RelocatedChain,
                                                      Relocated ) ) {

                    //
                    //  Something went wrong, we return failure
                    //
                    Ok = FALSE;
                    break;
                }

            } else if ( !Dirent.IsVolumeLabel() ) {

                //
                //  This is a file entry, update the census
                //  (if provided )
                //
                if( Dirent.QueryStartingCluster() != 0 &&
                    !_fat->IsValidChain( Dirent.QueryStartingCluster() ) ) {

                    Ok = FALSE;
                    break;
                }

                if ( CensusReport ) {
                    CensusReport->FileEntriesCount++;
                    CensusReport->FileClusters += _fat->QueryLengthOfChain( Dirent.QueryStartingCluster() );
                }
            }
        }

                EntryNumber++;
        }

    if ( Iterator ) {
        DELETE( Iterator );
    }

    //
    //  If we relocated something, then we have patched some entry in this
    //  directory. Write it out to disk
    //
    if ( Ok && RelocatedHere ) {
        Ok = Directory->Write();

        DebugAssert( Ok );

    }

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\fatvol.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    fatvol.cxx

Author:

    Bill McJohn (billmc) 30-May-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include "message.hxx"
#include "rtmsg.h"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( FAT_VOL, VOL_LIODPDRV );

VOID
FAT_VOL::Construct (
    )

/*++

Routine Description:

    Constructor for FAT_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}


FAT_VOL::~FAT_VOL(
    )
/*++

Routine Description:

    Destructor for FAT_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


FORMAT_ERROR_CODE
FAT_VOL::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType,
    IN      USHORT      FormatType
    )
/*++

Routine Description:

    This routine initializes a FAT_VOL object.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                      opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_fatsa, Message,
                                       ExclusiveWrite, FormatMedia,
                                       MediaType, FormatType);

    if (errcode != NoError) {
        Destroy();
        return errcode;
    }


    if (!Message) {
        Message = &msg;
    }


    if (!_fatsa.Initialize(this, Message, FALSE)) {
        Destroy();
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return GeneralError;
    }

    return NoError;
}

BOOLEAN
FAT_VOL::Initialize(
    IN OUT  PMESSAGE    Message,
    IN      PCWSTRING   NtDriveName,
    IN      BOOLEAN     OnlyIfDirty,
    IN      USHORT      FormatType
    )
/*++


Routine Description:

    This routine initializes a FAT_VOL object. If OnlyIfDirty is TRUE
    the SECRUN structure in the _fatsa object to only be
    big enough to perform the QueryVolumeFlags function,
    to see if the volume is dirty. This prevents AUTOCHK from setting up the whole
    super area (which is quite memory intensive on FAT32 drives) when it isn't going
    to do anything because the volume is clean.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    OnlyIfDirty     - TRUE if the volume is only going to be checked if dirty
    FormatType      - Supplies the file system type in the event of a format

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_fatsa, Message,
                                       FALSE,
                                       FALSE,   // will not return LockError
                                       Unknown,
                                       FormatType);

    if (errcode != NoError) {
        Destroy();
        return FALSE;
    }


    if (!Message) {
        Message = &msg;
    }

    // If we fix the QueryVolumeFlags to look at the FAT[1] entry
    // This will need to be changed to increase the SECRUN initialization
    // by one sector so that the first FAT sector comes in.

    // The above comment is not an indication of bug.  It just a
    // note for any future change in QueryVolumeFlags.
    // From what I understand, the super area for FAT reads the
    // boot sector and both FATs while that of FAT32 reads the
    // boot sectors and just one FAT.  So, if we want to look at the
    // second FAT entry of the second copy of FAT, we will need to
    // read one more sector.  However, if we have more than 2 FATs,
    // we will have to make more changes to accomodate that.
    // -DanielCh 3/8/2000

    if (!_fatsa.Initialize(this, Message, OnlyIfDirty ? FALSE : TRUE)) {
        Destroy();
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (!_fatsa.Read(Message)) {
        Destroy();
        return FALSE;
    }

    if (OnlyIfDirty) {
        //
        // Note that we ignore any error return on this call.
        //
        _fatsa.InitFATChkDirty(this,Message);
    }

    return TRUE;
}

BOOLEAN
FAT_VOL::IsFileContiguous(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message,
    OUT     PULONG      NumBlocks
    )
/*++

Routine Description:

    This routine computes the number of contiguous blocks for the given
    file.  If the file has only one block then the file is contiguous and
    this function returns TRUE.  Otherwise this function returns FALSE and
    the number of blocks is optionally returned into 'NumBlocks'.

Arguments:

    FullPathFileName    - Supplies the file name of the file to check for
                            contiguity.
    Message             - Supplies an outlet for messages.
    NumBlocks           - Returns the number of contiguous blocks.

Return Value:

    FALSE   - The file is not contiguous.
    TRUE    - The file is contiguous.

--*/
{
    ULONG       num_blocks;
    PFAT        fat;
    ULONG       clus;
    DSTRING     slash;

    if (NumBlocks) {
        *NumBlocks = 0;
    }

    if (!slash.Initialize("\\")) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display("") : 1;
        return FALSE;
    }

    if (*FullPathFileName == slash) {
        *NumBlocks = 1;
        return TRUE;
    }

    if ((clus = _fatsa.QueryFileStartingCluster(FullPathFileName)) == 1) {
        Message ? Message->Set(MSG_FILE_NOT_FOUND) : 1;
        Message ? Message->Display("%W", FullPathFileName) : 1;
        return FALSE;
    }

    if (clus == 0xFFFFFFFF) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display("") : 1;
        return FALSE;
    }

    // Say that a zero length file is contiguous.

    if (clus == 0) {
        *NumBlocks = 1;
        return TRUE;
    }


    fat = _fatsa.GetFat();

    DebugAssert(fat);

    for (num_blocks = 1; ; num_blocks++) {
        while (!fat->IsEndOfChain(clus) &&
               (ULONG)(clus + 1) == fat->QueryEntry(clus)) {
            clus++;
        }
        if (fat->IsEndOfChain(clus)) {
            break;
        }
        clus = fat->QueryEntry(clus);
    }

    if (NumBlocks) {
        *NumBlocks = num_blocks;
    }

    return num_blocks == 1;
}


BOOLEAN
FAT_VOL::ContiguityReport(
    IN      PCWSTRING   DirectoryPath,
    IN      PCDSTRING   FilesToCheck,
    IN      ULONG       NumberOfFiles,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine generates a contiguity report for all of the 'FilesToCheck'.
    These file are assumed to all be in the directory pointed to by
    'DirectoryPath'.

Arguments:

    DirectoryPath   - Supplies the directory containing the files to check.
    FilesToCheck    - Supplies an array of files to check.
    NumberOfFiles   - Supplies the number of files in the preceeding array.
    Message         - Suppliea an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       num_blocks;
    PFAT        fat;
    ULONG       clus;
    DSTRING     slash;
    FILEDIR     filedir;
    PFATDIR     dir;
    HMEM        hmem;
    BOOLEAN     all_contig;
    FAT_DIRENT  fatdent;
    DSTRING     current_file;
    ULONG       i;
    DSTRING     directory_path;
    UCHAR       FatType;


    if (!slash.Initialize("\\")) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display() : 1;
        return FALSE;
    }

    if ((clus = _fatsa.QueryFileStartingCluster(DirectoryPath)) == 1) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", DirectoryPath);
        return FALSE;
    }

    if (clus == 0xFFFFFFFF) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display() : 1;
        return FALSE;
    }

    fat = _fatsa.GetFat();

    if (!clus) {
        dir = _fatsa.GetRootDir();

        if ( !dir ) {
            dir = _fatsa.GetFileDir();
            FatType = FAT_TYPE_FAT32;
        } else
            FatType = FAT_TYPE_EAS_OKAY;

    } else {
        dir = &filedir;
        if (!hmem.Initialize() ||
            !filedir.Initialize(&hmem, this, &_fatsa, fat, clus)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        if (!filedir.Read()) {
            Message->Set(MSG_FILE_NOT_FOUND);
            Message->Display("%W", DirectoryPath);
            return FALSE;
        }
    }

    if (*DirectoryPath == slash) {

        if (!directory_path.Initialize("")) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }
    } else {
        if (!directory_path.Initialize(DirectoryPath)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }
    }


    all_contig = TRUE;
    for (i = 0; i < NumberOfFiles; i++) {

        if (!current_file.Initialize(&directory_path) ||
            !current_file.Strcat(&slash) ||
            !current_file.Strcat(&FilesToCheck[i])) {

            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        if (fatdent.Initialize(dir->SearchForDirEntry(&FilesToCheck[i]),FatType))
        {
           if (clus = fatdent.QueryStartingCluster()) {

                for (num_blocks = 1; ; num_blocks++) {
                    while (!fat->IsEndOfChain(clus) &&
                           (ULONG)(clus + 1) == fat->QueryEntry(clus)) {
                        clus++;
                    }
                    if (fat->IsEndOfChain(clus)) {
                        break;
                    }
                    clus = fat->QueryEntry(clus);
                }

                if (num_blocks != 1) {
                    Message->Set(MSG_CONTIGUITY_REPORT);
                    Message->Display("%W%d", &current_file, num_blocks);
                    all_contig = FALSE;
                }

            }

        } else {
            Message->Set(MSG_FILE_NOT_FOUND);
            Message->Display("%W", &current_file);
            all_contig = FALSE;
        }
    }

    if (all_contig) {
        Message->Set(MSG_ALL_FILES_CONTIGUOUS);
        Message->Display("");
    }

    return TRUE;
}


PVOL_LIODPDRV
FAT_VOL::QueryDupVolume(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine allocates a FAT_VOL and initializes it to 'NtDriveName'.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    A pointer to a newly allocated FAT volume.

--*/
{
    PFAT_VOL    vol;

    // unreferenced parameters
    (void)(this);

    if (!(vol = NEW FAT_VOL)) {
    Message ? Message->Set(MSG_FMT_NO_MEMORY) : 1;
        Message ? Message->Display("") : 1;
        return NULL;
    }

    if (!vol->Initialize(NtDriveName, Message, ExclusiveWrite,
                         FormatMedia, MediaType)) {
        DELETE(vol);
        return NULL;
    }

    return vol;
}


VOID
FAT_VOL::Destroy(
    )
/*++

Routine Description:

    This routine returns a FAT_VOL object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\hashindx.cxx ===
#include <pch.cxx>

#include "ulib.hxx"

#include "hashindx.hxx"

extern "C" {
#include <stdio.h>
}

//#define HASH_INDEX_PERFORMANCE    1

#if HASH_INDEX_PERFORMANCE
#include <math.h>
#endif

#define MAX_HASH_TABLE_SIZE     32768

DEFINE_CONSTRUCTOR( HASH_INDEX, OBJECT );

VOID
HASH_INDEX::Construct (
        )
/*++

Routine Description:

    Constructor for HASH_INDEX.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _hashTable = NULL;
    _hash_table_size = 0;
    _hash_table_mask = 0;
    _hash_table_bits = 0;
    _hash_element_increment = 0;
}


VOID
HASH_INDEX::Destroy(
    )
/*++

Routine Description:

    This routine returns the HASH_INDEX to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PHASH_INDEX_ELEMENT   hashElementPtr;
    USHORT                i;

    if (_hashTable == NULL)
        return;

    hashElementPtr = _hashTable;
    for (i=0; i<_hash_table_size; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr++;
    }
    FREE(_hashTable);

    _hash_table_size = 0;
    _hash_table_mask = 0;
    _hash_table_bits = 0;
    _hash_element_increment = 0;
}


HASH_INDEX::~HASH_INDEX(
    )
/*++

Routine Description:

    Destructor for HASH_INDEX.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
HASH_INDEX::Initialize(
    ULONG       HashTableSize,
    USHORT      HashElementIncrement
    )
/*++

Routine Description:

    This routine initializes the set for new input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    USHORT                i;
    USHORT                hash_table_size;

    Destroy();

    // compute hash table bit size

    if (HashTableSize <= 1024)
        _hash_table_bits = 10;
    else if (HashTableSize <= 2048)
        _hash_table_bits = 11;
    else if (HashTableSize <= 4096)
        _hash_table_bits = 12;
    else if (HashTableSize <= 8192)
        _hash_table_bits = 13;
    else if (HashTableSize <= 16384)
        _hash_table_bits = 14;
    else
        _hash_table_bits = 15;

    // set hash table size & mask

    _hash_table_size = (1 << _hash_table_bits);
    _hash_table_mask = _hash_table_size - 1;
    _hash_element_increment = HashElementIncrement;

    _hashTable = (PHASH_INDEX_ELEMENT)MALLOC(sizeof(HASH_INDEX_ELEMENT)*_hash_table_size);

    if (_hashTable == NULL)
        return FALSE;

    memset(_hashTable, 0, sizeof(HASH_INDEX_ELEMENT)*_hash_table_size);

    return TRUE;
}

BOOLEAN
HASH_INDEX::QueryAndAdd(
    IN  ULONG       HashValue,
    IN  ULONG       Index,
    OUT PULONG      *MatchIndexArray,
    OUT PULONG      MatchIndexCount
    )
/*++

Routine Description:

    This routine adds 'Number' to the set.

Arguments:

    Number    - Supplies the number to add to the set.
    Duplicate - Returns TRUE if Number already exists in the set

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PHASH_INDEX_ELEMENT hashElementPtr;
    PULONG              tmpPtr;
    PULONG              elementPtr;
    ULONG               i;
    SHORT               bits_left;
    USHORT              hash_key;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    bits_left = sizeof(ULONG)*8;
    hash_key = 0;
    do {
        hash_key ^= (HashValue & _hash_table_mask);
        HashValue = HashValue >> _hash_table_bits;
        bits_left -= _hash_table_bits;
    } while (bits_left > 0);

    hashElementPtr = &(_hashTable[hash_key]);

    //
    // Is this the first entry
    //

    if (hashElementPtr->elements == NULL) {

        hashElementPtr->elements = (PULONG)
                                   MALLOC(sizeof(ULONG)*_hash_element_increment);
        if (hashElementPtr->elements == NULL)
            return FALSE;
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = _hash_element_increment;
    }

    //
    // Is there room to add another entry
    //
    if (hashElementPtr->elementCount == hashElementPtr->maxElementCount) {
        tmpPtr = (PULONG)REALLOC(hashElementPtr->elements,
                                 sizeof(ULONG)*
                                 (_hash_element_increment +
                                  hashElementPtr->maxElementCount));
        if (tmpPtr == NULL)
            return FALSE;
        hashElementPtr->elements = tmpPtr;
        hashElementPtr->maxElementCount += _hash_element_increment;
    }

    //
    // Insert the element
    //
    hashElementPtr->elements[hashElementPtr->elementCount] = Index;
    hashElementPtr->elementCount += 1;
    DebugAssert(hashElementPtr->elementCount <= hashElementPtr->maxElementCount);

    *MatchIndexArray = hashElementPtr->elements;
    *MatchIndexCount = hashElementPtr->elementCount;

    return TRUE;
}

BOOLEAN
HASH_INDEX::RemoveAll(
     )
{
    PHASH_INDEX_ELEMENT     hashElementPtr;
    USHORT                  i;

    DebugPtrAssert(_hashTable);
    hashElementPtr = _hashTable;
    for (i=0; i<_hash_table_size; i++) {
        FREE(hashElementPtr->elements);
        hashElementPtr->elementCount = 0;
        hashElementPtr->maxElementCount = 0;
        hashElementPtr++;
    }
    return TRUE;
}

VOID
HASH_INDEX::RemoveLastEntry(
    ULONG   HashValue,
    ULONG   Index
    )
{
    PHASH_INDEX_ELEMENT hashElementPtr;
    SHORT               bits_left;
    USHORT              hash_key;
    ULONG               count;

    DebugPtrAssert(_hashTable);

    //
    // Compute hash key
    //

    bits_left = sizeof(ULONG)*8;
    hash_key = 0;
    do {
        hash_key ^= (HashValue & _hash_table_mask);
        HashValue = HashValue >> _hash_table_bits;
        bits_left -= _hash_table_bits;
    } while (bits_left > 0);

    hashElementPtr = &(_hashTable[hash_key]);

    count = hashElementPtr->elementCount;
    if (count-- >= 1) {
        DebugAssert(hashElementPtr->elements[count] == Index);
        hashElementPtr->elementCount = count;
    }
}

VOID
HASH_INDEX::DumpHashTable(
    )
/*++

Routine Description:

    This routine dumps out the hash table

--*/
{
#if HASH_INDEX_PERFORMANCE
    USHORT                  i;
    PHASH_INDEX_ELEMENT     hashElementPtr;
    ULONG                   slotused = 0, min_count = 100000, max_count = 0, elem_count = 0;
    double                  avg_count = 0, sd_count = 0, avg_slot = 0, sd_slot = 0;

    hashElementPtr = _hashTable;
    printf("\n");
    for (i=0; i<_hash_table_size; i++) {
        if (hashElementPtr->elements != NULL) {
            slotused++;
            avg_slot += i;
            sd_slot += i*i;
//            printf("%d, %d\n", i, hashElementPtr->elementCount);
            if (min_count > hashElementPtr->elementCount)
                min_count = hashElementPtr->elementCount;
            if (max_count < hashElementPtr->elementCount)
                max_count = hashElementPtr->elementCount;
            avg_count += hashElementPtr->elementCount;
            sd_count += (hashElementPtr->elementCount)*(hashElementPtr->elementCount);
        }
        hashElementPtr++;
    }
    printf("Slot (%d): %d, %g, %g\n",
           _hash_table_size, slotused, avg_slot/slotused, sqrt(sd_slot/(slotused-1)));
    printf("Element: %d, %d, %g, %g\n",
           min_count, max_count, avg_count/slotused, sqrt(sd_count/(slotused-1)));

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\filedir.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    filedir.cxx

Abstract:

    This class is an implementation of FATDIR for all FAT directories
    that are implemented as files.  In other words all FAT directories
    besides the root directory.

Author:

    Norbert P. Kusters (norbertk) 4-Dec-90

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( FILEDIR, FATDIR, UFAT_EXPORT );

VOID
FILEDIR::Construct (
    )
/*++

Routine Description:

    Constructor for FILEDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _number_of_entries = 0;
}


UFAT_EXPORT
FILEDIR::~FILEDIR(
    )
/*++

Routine Description:

    Destructor for FILEDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

extern VOID DoInsufMemory(VOID);

UFAT_EXPORT
BOOLEAN
FILEDIR::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               StartingCluster
    )
/*++

Routine Description:

    This routine initializes the FILEDIR object for use.  It will enable
    referencing the directory starting at StartingCluster.

Arguments:

    Mem             - Supplies the memory for the cluster chain.
    Drive           - Supplies the drive on which the directory resides.
    FatSuperArea    - Supplies the super area for the FAT file system on
                        the drive.
    Fat             - Supplies the file allocation table for the drive.
    StartingCluster - Supplies the first cluster of the directory.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _starting_cluster = StartingCluster;

    if (!_cluster.Initialize(Mem, Drive, FatSuperArea, Fat, StartingCluster)) {
        DoInsufMemory();
        Destroy();
        return FALSE;

    }

    _number_of_entries = Drive->QuerySectorSize()*
                         FatSuperArea->QuerySectorsPerCluster()*
                         _cluster.QueryLength()/
                         BytesPerDirent;

    if (!_number_of_entries) {

        DebugPrintTrace(("UFAT: Failure to Initialize in FILEDIR\n"));
        Destroy();
        return FALSE;
    }

    return TRUE;
}


VOID
FILEDIR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.  Memory will
    be freed and all other function besided Init will be inoperative.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _number_of_entries = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\fatdir.cxx ===
#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "error.hxx"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( FATDIR, OBJECT );

UFAT_EXPORT
PVOID
FATDIR::SearchForDirEntry(
    IN  PCWSTRING   FileName
    )
/*++

Routine Description:

    This routine gets the directory entry with the (null-terminated)
    filename 'FileName'.  If no such directory entry exists then
    this routine return NULL.

Arguments:

    FileName    - The name of the file searched for.

Return Value:

    A pointer to a directory entry or NULL.

--*/
{
    FAT_DIRENT  dirent;
    ULONG       i;
    DSTRING     filename;
    PVOID       p;

    for (i = 0; dirent.Initialize(p = GetDirEntry(i)); i++) {

        if (dirent.IsEndOfDirectory()) {
            break;
        }

        if (dirent.IsErased()) {
            continue;
        }

        dirent.QueryName(&filename);

        if (dirent.IsVolumeLabel()) {
            continue;
        }

        if (*FileName == filename) {
            return p;
        }

        if (QueryLongName(i, &filename) && (*FileName == filename)) {
            return p;
        }
    }

    return NULL;
}


PVOID
FATDIR::GetFreeDirEntry(
    )
/*++

Routine Description:

    This routine gets an unused directory entry, if one exists.
    If one doesn't exist then this routine returns NULL.

Arguments:

    None.

Return Value:

    A pointer to a directory entry or NULL.

--*/
{
    FAT_DIRENT  dirent;
    ULONG       i;
    PVOID       p;

    for (i = 0; dirent.Initialize(p = GetDirEntry(i)); i++) {

        if (dirent.IsEndOfDirectory()) {
            if (dirent.Initialize(GetDirEntry(i + 1))) {
                dirent.SetEndOfDirectory();
            }
            return p;
        }

        if (dirent.IsErased()) {
            return p;
        }
    }

    return NULL;
}

extern VOID DoInsufMemory(VOID);

UFAT_EXPORT
BOOLEAN
FATDIR::QueryLongName(
    IN  LONG        EntryNumber,
    OUT PWSTRING    LongName
    )
/*++

Routine Description:

    This method fetches the long file name associated with the
    short directory entry at index EntryNumber.

Arguments:

    EntryNumber
    LongName        --  Receives the long name associated with this entry.
                        Receives "" if there is no long name.

Return Value:

    TRUE upon successful completion
    FALSE to indicate failure or disk corruption.

--*/
{
    DSTRING     NameComponent;
    FAT_DIRENT  CurrentEntry;
    LONG        CurrentIndex;
    ULONG       Ordinal = 1;
    UCHAR       Checksum;

    CurrentIndex = EntryNumber;

    if( !CurrentEntry.Initialize( GetDirEntry( CurrentIndex ) ) ||
        !LongName->Initialize( "" ) ) {
	DoInsufMemory();
        return FALSE;
    }

    Checksum = CurrentEntry.QueryChecksum();

    CurrentIndex--;

    for( ; CurrentIndex >= 0; CurrentIndex-- ) {

        if( !CurrentEntry.Initialize( GetDirEntry( CurrentIndex ) ) ) {

	    DoInsufMemory();
            return FALSE;
        }

        if( CurrentEntry.IsErased() ||  !CurrentEntry.IsLongEntry() ) {

            // The long name entries are not valid--return an
            // empty string for the long name.
            //
            return( LongName->Initialize( "" ) );
        }

        if( CurrentEntry.IsLongNameEntry() ) {

            if( CurrentEntry.QueryLongOrdinal() != Ordinal ||
                CurrentEntry.QueryChecksum() != Checksum ) {

                // The long-name entries don't belong to the
                // specified short entry.
                //
                return( LongName->Initialize( "" ) );
            }

            if( !CurrentEntry.QueryLongNameComponent( &NameComponent ) ||
                !LongName->Strcat( &NameComponent ) ) {

                return FALSE;
            }

            if( CurrentEntry.IsLastLongEntry() ) {

                // This was the last entry.
                //
                return TRUE;
            }

            Ordinal++;
        }
    }

    // There is no long name, or it is not valid.
    //
    return( LongName->Initialize( "" ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\fatsachk.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    fatsachk.cxx

Author:

    Bill McJohn (billmc) 30-May-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include "bitvect.hxx"
#include "intstack.hxx"
#include "rtmsg.h"
#include "ifsentry.hxx"

// Timeinfo is full of windows stuff.
#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

#include "timeinfo.hxx"

#endif

#define UCHAR_SP        ' '

typedef struct _VISIT_DIR *PVISIT_DIR;
typedef struct _VISIT_DIR {
    PVISIT_DIR Next;
    PWSTRING Path;
    ULONG Cluster;
} VISIT_DIR;

extern "C" {
    #include <stdio.h>
}

extern VOID InsertSeparators(
                  LPCWSTR OutWNumber,
                  char * InANumber,
                  ULONG  Width
                );

VOID
dofmsg(
    IN      PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
{
    if (*NeedErrorsMessage) {
        Message->Set(MSG_CORRECTIONS_WILL_NOT_BE_WRITTEN, NORMAL_MESSAGE, TEXT_MESSAGE);
        Message->Display();
        *NeedErrorsMessage = FALSE;
    }
}

BOOLEAN
CheckAndFixFileName(
    PVOID       DirEntry,
    PBOOLEAN    Changes
)
{
    PUCHAR      p = (PUCHAR)DirEntry;
    BOOLEAN     first_char_replaced;
    PUCHAR      backup_copy[11];
    WCHAR       unicode_string[30];
    ULONG       unicode_string_length;
    NTSTATUS    ntstatus;

#if 1
    //
    // Should not correct case error within file name because
    // different language build translates differently.  On a
    // dual boot machine containing build of two different languages,
    // the chkdsk from one build may not like what the second build
    // put onto the disk.
    //
    return TRUE;
#else

    memcpy(backup_copy, p, 11);

    first_char_replaced = (0x5 == p[0]);

    if (first_char_replaced)
        p[0] = 0xe5;

    ntstatus = RtlOemToUnicodeN(unicode_string,
                                sizeof(unicode_string),
                                &unicode_string_length,
                                (PCHAR)p,
                                11);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UFAT: Error in RtlOemToUnicodeN, 0x%x\n", ntstatus));
        memcpy(p, backup_copy, 11);
        return FALSE;
    }

    ntstatus = RtlUpcaseUnicodeToOemN((PCHAR)p,
                                      11,
                                      NULL,
                                      unicode_string,
                                      unicode_string_length);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UFAT: Error in RtlUpcaseUnicodeToOemN, 0x%x\n", ntstatus));
        memcpy(p, backup_copy, 11);
        return FALSE;
    }

    if (first_char_replaced) {
        if (0xe5 == p[0]) {
            p[0] = 0x5;
        } else {
            DebugPrintTrace(("UFAT: First byte changed to 0x%x unexpectedly\n", p[0]));
            memcpy(p, backup_copy, 11);
            return FALSE;
        }
    }

    *Changes = (memcmp(p, backup_copy, 11) != 0);

    return TRUE;
#endif
}

BOOLEAN
IsFileNameMatch(
    PFATDIR     Dir,
    UCHAR       FatType,
    ULONG       CurrentIndex,
    ULONG       MatchingIndexCount,
    PULONG      MatchingIndexArray
)
{
    ULONG   j;

    for (j = 0; j < MatchingIndexCount; j++) {

        FAT_DIRENT fd;
        ULONG      indx = MatchingIndexArray[j];

        if (!fd.Initialize(Dir->GetDirEntry(indx), FatType) ||
            fd.IsVolumeLabel()) {
            continue;
        }

        if (!memcmp(Dir->GetDirEntry(indx), Dir->GetDirEntry(CurrentIndex), 11)) {
            return TRUE;    // there is a match
        }
    }
    return FALSE;   // no match
}

BOOLEAN
RenameFileName(
    PULONG  Positions,
    PVOID   DirEntry
)
{
    PUCHAR  p = (PUCHAR)DirEntry;
    INT     i;

    if (*Positions == 0) {   // if first rename
        // find out the first char in the extension that is real
        for (i = 10; i > 7; i--)
            if (p[i] != UCHAR_SP)
                break;
        if (i >= 7 && i < 10) {  // fill the unused extension space with dashes
            for (i++; i < 10; i++)
                p[i] = '-';
        }
        *Positions = 1;
        if (p[10] != '0') {
            p[10] = '0';    // the last char of the extension gets a zero
            return TRUE;
        }
    }

    // extension chars are all in use now
    // check to see if renaming is already in progress

    for (i=10; i>=0; i--) {
        if (!(*Positions & (1 << (10-i)))) {
            *Positions |= (1 << (10-i));
            if (p[i] != '0') {
                p[i] = '0';
                return TRUE;
            }
        }
        if (p[i] >= '0' && p[i] < '9') {
            p[i]++;
            return TRUE;
        } else if (p[i] == '9') {
            p[i] = '0';
        }
    }

    // if we get here that means we have exhausted all possible name
    // shouldn't be as there are more combination than the max number
    // of files that can be in a FAT directory (65536)

    return FALSE;
}

BOOLEAN
PushVisitDir(
    IN OUT PVISIT_DIR *VisitDirStack,
    IN     ULONG Cluster,
    IN     PWSTRING DirectoryPath
    )
{
    PVISIT_DIR visit_dir;

    visit_dir = (PVISIT_DIR)MALLOC( sizeof( VISIT_DIR ) );
    if( visit_dir == NULL ){
        return FALSE;
    }

    visit_dir->Path = DirectoryPath;
    visit_dir->Cluster = Cluster;
    visit_dir->Next = *VisitDirStack;
    *VisitDirStack = visit_dir;

    return TRUE;
}

BOOLEAN
PopVisitDir(
    IN OUT PVISIT_DIR *VisitDirStack,
    OUT    PULONG Cluster OPTIONAL,
    OUT    PWSTRING *DirectoryPath OPTIONAL
    )
{
    PVISIT_DIR visit_dir;

    visit_dir = *VisitDirStack;
    if( visit_dir == NULL ){
        return FALSE;
    }
    *VisitDirStack = visit_dir->Next;

    if( ARGUMENT_PRESENT( Cluster ) ){
        *Cluster = visit_dir->Cluster;
    }

    if( ARGUMENT_PRESENT( DirectoryPath ) ){
        *DirectoryPath = visit_dir->Path;
    }

    FREE( visit_dir );
    return TRUE;
}

STATIC VOID
EraseAssociatedLongName(
    PFATDIR Dir,
    INT     FirstLongEntry,
    INT     ShortEntry
    )
{
    FAT_DIRENT dirent;

    for (int j = FirstLongEntry; j < ShortEntry; ++j) {
        dirent.Initialize(Dir->GetDirEntry(j));
        dirent.SetErased();
    }
}

STATIC BOOLEAN
IsString8Dot3(
    PCWSTRING   s
    )
/*++

Routine Description:

    This routine is used to ensure that lfn's legally correspond
    to their short names.  The given string is examined to see if it
    is a legal fat 8.3 name.

Arguments:

    s -- lfn to examine.

Return Value:

    TRUE            - The string is a legal 8.3 name.
    FALSE           - Not legal.

--*/
{
    USHORT i;
    BOOLEAN extension_present = FALSE;
    WCHAR c;

    //
    // The name can't be more than 12 characters (including a single dot).
    //

    if (s->QueryChCount() > 12) {
        return FALSE;
    }

    for (i = 0; i < s->QueryChCount(); ++i) {

        c = s->QueryChAt(i);

#if 0
        if (!FsRtlIsAnsiCharLegalFat(c, FALSE)) {
            return FALSE;
        }
#endif

        if (c == '.') {

            //
            // We stepped onto a period.  We require the following things:
            //
            //      - it can't be the first character
            //      - there can be only one
            //      - there can't be more than 3 characters following it
            //      - the previous character can't be a space
            //

            if (i == 0 ||
                extension_present ||
                s->QueryChCount() - (i + 1) > 3 ||
                s->QueryChAt(i - 1) == ' ') {

                return FALSE;
            }
            extension_present = TRUE;
        }

        //
        // The base part of the name can't be more than 8 characters long.
        //

        if (i >= 8 && !extension_present) {
            return FALSE;
        }

    }

    //
    // The name cannot end in a space or a period.
    //

    if (c == ' ' || c == '.') {
        return FALSE;
    }

    return TRUE;
}

STATIC PMESSAGE      _pvfMessage = NULL;
STATIC BOOLEAN       _Verbose = FALSE;

VOID
FreeSpaceInBitmap(
    IN      ULONG       StartingCluster,
    IN      PCFAT       Fat,
    IN OUT  PBITVECTOR  FatBitMap
    );

BOOLEAN
FAT_SA::VerifyAndFix(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       LogFileSize,
    IN      USHORT      Algorithm,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine verifies the FAT superarea and if neccessary fixes
    it to a correct state.

Arguments:

    FixLevel        - Supplies the level of fixes that may be performed on
                      the disk.
    Message         - Supplies an outlet for messages.
    Flags           - Supplies flags to control the behavior of chkdsk
                      (see ulib\inc\ifsserv.hxx for details)
    LogFileSize     - ignored
    Algorithm       - ignored
    ExitStatus      - Returns an indication of the result of the check
    DriveLetter     - For autocheck, supplies the letter of the volume
                      being checked

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FAT_DIRENT      eadent;
    ULONG           cluster_size;
    ULONG           ea_clus_num;
    USHORT          num_eas, save_num_eas;
    PEA_INFO        ea_infos;
    ULONG           cluster_count;
    HMEM            ea_header_mem;
    EA_HEADER       ea_header;
    BOOLEAN         changes = FALSE;
    BITVECTOR       fat_bitmap;
    FATCHK_REPORT   report;
    PUSHORT         p;
    VOLID           volid;
    ULONG           free_count, bad_count, total_count;
    BOOLEAN         fmsg;
    DSTRING         label;
    DSTRING         eafilename;
    DSTRING         eafilepath;
    BOOLEAN         tmp_bool;
    ULONG           tmp_ulong;
    DSTRING         date;
    DSTRING         time;
    UCHAR           dirty_byte, media_byte;
    ULONG           errFixedStatus = CHKDSK_EXIT_SUCCESS;

    BOOLEAN         Verbose = (BOOLEAN)(Flags & CHKDSK_VERBOSE);
    BOOLEAN         OnlyIfDirty = (BOOLEAN)(Flags & CHKDSK_CHECK_IF_DIRTY);
    BOOLEAN         EnableUpgrade = (BOOLEAN)(Flags & CHKDSK_ENABLE_UPGRADE);
    BOOLEAN         EnableDowngrade = (BOOLEAN)(Flags & CHKDSK_DOWNGRADE);
    BOOLEAN         RecoverFree = (BOOLEAN)(Flags & CHKDSK_RECOVER_FREE_SPACE);
    BOOLEAN         RecoverAlloc = (BOOLEAN)(Flags & CHKDSK_RECOVER_ALLOC_SPACE);

#if !defined(_AUTOCHECK_)
    STATIC LONG     FatChkdskIsRunning = 0;
#endif

    memset(&report, 0, sizeof(FATCHK_REPORT));

    if (NULL == ExitStatus) {
        ExitStatus = &report.ExitStatus;
    }
    report.ExitStatus = CHKDSK_EXIT_SUCCESS;
    *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;

#if !defined(_AUTOCHECK_)
    if (InterlockedCompareExchange(&FatChkdskIsRunning, 1, 0) != 0) {
        Message->DisplayMsg(MSG_CHK_NO_MULTI_THREAD);
        return FALSE;
    }
#endif

    _pvfMessage = Message;
    _Verbose = Verbose;

    fmsg = TRUE;

    if (FixLevel != CheckOnly) {
        fmsg = FALSE;
    }

    if (EnableUpgrade || EnableDowngrade) {
        Message->Set(MSG_CHK_CANNOT_UPGRADE_DOWNGRADE_FAT);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    //
    // Check to see if the dirty bit is set.
    //
    dirty_byte = QueryVolumeFlags();

    if (OnlyIfDirty) {
        if ((dirty_byte &
             (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE)) == 0) {
            Message->Set(MSG_CHK_VOLUME_CLEAN);
            Message->Display();
            Message->SetLoggingEnabled(FALSE);
            *ExitStatus = CHKDSK_EXIT_SUCCESS;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return TRUE;
        }

        // We need to re-initialize the fatsa object to include the whole
        // super area

        if (!Initialize(_drive, Message, TRUE)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        if (!Read(Message)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        // If the second bit of the dirty byte is set then
        // also perform a full recovery of the free and allocated
        // space.

        if (dirty_byte & FAT_BPB_RESERVED_TEST_SURFACE) {
            RecoverFree = TRUE;
            RecoverAlloc = TRUE;
        }
    }

    //
    // NOTE that this check must follow the above "if (OnlyIfDirty)" because in the
    //      OnlyIfDirty case only the first part of the FAT_SA object is in memory
    //      until the above if gets executed.
    //
    if (QueryLength() <= SecPerBoot()) {
        Message->Set(MSG_NOT_FAT);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    //
    // The volume is not clean, so if we're autochecking we want to
    // make sure that we're printing real messages on the console
    // instead of just dots.
    //

#ifdef _AUTOCHECK_

    if (Message->SetDotsOnly(FALSE)) {

        Message->SetLoggingEnabled(FALSE);
        if (NULL != DriveLetter) {
            Message->Set(MSG_CHK_RUNNING);
            Message->Display("%W", DriveLetter);
        }

        Message->Set(MSG_FILE_SYSTEM_TYPE);
        Message->Display("%s", _ft == LARGE32 ? "FAT32" : "FAT");
        Message->SetLoggingEnabled();

    }

    if (Message->IsInAutoChk()) {

        ULONG   timeout;

        if (!VOL_LIODPDRV::QueryAutochkTimeOut(&timeout)) {
            timeout = AUTOCHK_TIMEOUT;
        }

        if (timeout > MAX_AUTOCHK_TIMEOUT_VALUE)
            timeout = AUTOCHK_TIMEOUT;

        if (timeout != 0) {
            if (dirty_byte & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE))
                Message->Set(MSG_CHK_AUTOCHK_SKIP_WARNING);
            else
                Message->Set(MSG_CHK_USER_AUTOCHK_SKIP_WARNING);
            Message->Display();
            if (Message->IsKeyPressed(MSG_CHK_ABORT_AUTOCHK, timeout)) {
                Message->SetLoggingEnabled(FALSE);
                Message->Set(MSG_CHK_AUTOCHK_ABORTED);
                Message->Display();
                *ExitStatus = CHKDSK_EXIT_SUCCESS;
                return TRUE;
            } else {
                Message->Set(MSG_CHK_AUTOCHK_RESUMED);
                Message->Display();
            }
        } else if ((dirty_byte & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE))) {
            Message->Set(MSG_CHK_VOLUME_IS_DIRTY);
            Message->Display();
        }
    } else {
        DebugAssert(Message->IsInSetup());

        if (dirty_byte & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE)) {
            Message->Set(MSG_CHK_VOLUME_IS_DIRTY);
            Message->Display();
        }
    }

#endif  // _AUTOCHECK_

    //
    // The BPB's Media Byte must be in the set accepted
    // by the file system.
    //
    media_byte = QueryMediaByte();

#if defined(FE_SB) && defined(_X86_)
    if ((media_byte != 0x00) &&  /* FMR */
        (media_byte != 0x01) &&  /* FMR */
        (media_byte != 0xf0) &&
#else
    if ((media_byte != 0xf0) &&
#endif
        (media_byte != 0xf8) &&
        (media_byte != 0xf9) &&
#if defined(FE_SB) && defined(_X86_)
        (media_byte != 0xfa) &&  /* FMR */
        (media_byte != 0xfb) &&  /* FMR */
#endif
        (media_byte != 0xfc) &&
        (media_byte != 0xfd) &&
        (media_byte != 0xfe) &&
        (media_byte != 0xff)) {

        SetMediaByte(_drive->QueryMediaByte());
        dofmsg(Message, &fmsg);
        Message->Set(MSG_CHK_INVALID_MEDIA_BYTE);
        Message->Display();
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // First print out the label and volume serial number.
    // We won't bother printing this message under autocheck.

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

    TIMEINFO        timeinfo;

    if ((QueryLabel(&label, &timeinfo) || label.Initialize("")) &&
        label.QueryChCount() &&
        timeinfo.QueryDate(&date) &&
        timeinfo.QueryTime(&time)) {

        Message->Set(MSG_VOLUME_LABEL_AND_DATE);
        Message->Display("%W%W%W", &label, &date, &time);
    }

#endif // !_AUTOCHECK_ && !_SETUP_LOADER_


    if (volid = QueryVolId()) {
        p = (PUSHORT) &volid;
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", p[1], p[0]);
    }

    // Validate the FAT.

    if (_dirF32 == NULL)
        _fat->Scrub(&changes);

    if (changes) {
        dofmsg(Message, &fmsg);
        Message->Set(MSG_CHK_ERRORS_IN_FAT);
        Message->Display();
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }


    //
    // Make sure that the media type in the BPB is the same as at
    // the beginning of the FAT.
    //

    if (QueryMediaByte() != _fat->QueryMediaByte()) {
#if defined(FE_SB) // MO & OEM FAT Support
        BOOLEAN bPrintError = TRUE;

#if defined(_X86_)
        if (IsPC98_N()) {

            // PC98 Nov.01.1994
            // to help the early NEC DOS

            if(_drive->QueryMediaType() == FixedMedia &&
                       QueryMediaByte() == 0xf8 && _fat->QueryMediaByte() == 0xfe) {

                bPrintError = FALSE;

            }
        }
#endif

        if (bPrintError &&
            (_drive->QueryMediaType() == F3_128Mb_512 ||
             _drive->QueryMediaType() == F3_230Mb_512   )) {

            // We won't to recognized as illegal in following case.
            //
            // Some OpticalDisk might have 0xf0 as media in BPB, but it also has 0xF8 in FAT.
            //

            if (QueryMediaByte() == 0xf0 && _fat->QueryMediaByte() == 0xf8) {

                bPrintError = FALSE;
            }
        }

        if( bPrintError ) {
#endif

            dofmsg(Message, &fmsg);
            Message->Set(MSG_PROBABLE_NON_DOS_DISK);
            Message->Display();
            if (!Message->IsYesResponse(FALSE)) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return TRUE;
            }

#if defined(FE_SB) // REAL_FAT_SA::Create():Optical disk support
            //
            // Here is a table of Optical Disk (MO) format on OEM DOS.
            //
            //   128MB    |  NEC  |  IBM  | Fujitsu |
            // -----------+-------+-------+---------+
            // BPB.Media  | 0xF0  | 0xF0  | 0xF0    |
            // -----------+-------+-------+---------+
            // FAT.DiskID | 0xF0  | 0xF8  | 0xF8    |
            // -----------+-------+-------+---------+
            //
            //   230MB    |  NEC  |  IBM  | Fujitsu |
            // -----------+-------+-------+---------+
            // BPB.Media  | 0xF0  | 0xF0  | 0xF0    |
            // -----------+-------+-------+---------+
            // FAT.DiskID | 0xF8  | 0xF8  | 0xF8    |
            // -----------+-------+-------+---------+
            //
            // We will take NEC's way....

            if (_drive->QueryMediaType() == F3_230Mb_512) {

                DebugAssert(QueryMediaByte() == (UCHAR) 0xF0);

                _fat->SetEarlyEntries((UCHAR) 0xF8);
            } else {
                _fat->SetEarlyEntries(QueryMediaByte());
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
#else
        _fat->SetEarlyEntries(QueryMediaByte());
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
#endif
    }


    // Compute the cluster size and the number of clusters on disk.

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();
    cluster_count = QueryClusterCount();


    // No EAs have been detected yet.

    ea_infos = NULL;
    num_eas = 0;


    // Create an EA file name string.

    if (!eafilename.Initialize("EA DATA. SF") ||
        !eafilepath.Initialize("\\EA DATA. SF")) {
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }


    //
    // This bitmap will be reinitialized before 'WalkDirectoryTree'.
    // Its contents will be ignored until then.
    //

    if (!fat_bitmap.Initialize(cluster_count)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // If there is an EA file on disk then...

    // FAT32 volume does not support EA.
    if (_dir != NULL && // <-- If this is not a FAT32 volume.
        eadent.Initialize(_dir->SearchForDirEntry(&eafilename), FAT_TYPE_EAS_OKAY)) {

        // Validate the EA file directory entry.

        if (!ValidateDirent(&eadent, &eafilepath, FixLevel, FALSE, &report, Message,
                            &fmsg, &fat_bitmap, &tmp_bool, &tmp_ulong)) {
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }


        // If the EA file directory entry was valid then...

        // FATDIR::SearchForDirEntry will not return an erased dirent, but whatever...
        if (!eadent.IsErased()) {

            // The EA file should not have an EA handle.
            if (eadent.QueryEaHandle()) {
                dofmsg(Message, &fmsg);
                Message->Set(MSG_CHK_EAFILE_HAS_HANDLE);
                Message->Display();
                eadent.SetEaHandle(0);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }

            // Compute the EA file's starting cluster.
            ea_clus_num = eadent.QueryStartingCluster();

            //
            // Perform any log operations recorded at the beginning
            // of the EA file.
            //

            if (!PerformEaLogOperations(ea_clus_num, FixLevel, &report,
                                        Message, &fmsg)) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return FALSE;
            }

            //
            // Validate the EA file's EA sets and return an array of
            // information about them.
            //
            ea_infos = RecoverEaSets(ea_clus_num, &num_eas, FixLevel, &report,
                                     Message, &fmsg);

            //
            // If there are no valid EAs in the EA file then erase
            // the EA file.
            //
            if (!ea_infos) {

                if (num_eas) {
                    _Verbose = FALSE;
                    _pvfMessage = NULL;
                    return FALSE;
                }

                eadent.SetErased();

                dofmsg(Message, &fmsg);
                Message->Set(MSG_CHK_EMPTY_EA_FILE);
                Message->Display();
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }
    }


    // Initialize FAT bitmap to be used in detection of cross-links.

    if (!fat_bitmap.Initialize(cluster_count)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    if (!CheckSectorHeapAllocation(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    if (!VerifyFatExtensions(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }


    //
    // Should probably add another function to perform the following task.
    //

    if (_dirF32 != NULL)  {

        if (!VerifyAndFixFat32RootDir( &fat_bitmap, Message, &report, &fmsg)) {
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

    }

    // Validate all of the files on the disk.
    save_num_eas = num_eas;

    if (!WalkDirectoryTree(ea_infos, &num_eas, &fat_bitmap, &report,
                           FixLevel, RecoverAlloc, Message, Verbose, &fmsg)) {
       // DELETE(ea_infos);
       delete [] ea_infos; ea_infos = NULL;
       _Verbose = FALSE;
       _pvfMessage = NULL;
       return FALSE;
    }

    if (save_num_eas != num_eas && ea_infos) {

        if (!EraseEaHandle(ea_infos, num_eas, save_num_eas, FixLevel, Message)) {
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        if (!num_eas) {

            delete [] ea_infos;
            ea_infos = NULL;

            //
            // Note that the following two steps cause the EA file chain to get recovered
            //  as a lost cluster chain since all this does is erase the dirent, not the
            //  cluster chain.
            //
            eadent.SetErased();
            FreeSpaceInBitmap(eadent.QueryStartingCluster(), _fat,
                              &fat_bitmap);

            dofmsg(Message, &fmsg);
            Message->Set(MSG_CHK_EMPTY_EA_FILE);
            Message->Display();
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    // If there are EAs on the disk then...

    if (ea_infos) {

        // Remove all unused EAs from EA file.

        if (!PurgeEaFile(ea_infos, num_eas, &fat_bitmap, FixLevel, &report, Message,
                         &fmsg)) {
            // DELETE( ea_infos );
            delete [] ea_infos; ea_infos = NULL;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }


        // Rebuild header portion of EA file.

        if (!ea_header_mem.Initialize() ||
            !RebuildEaHeader(&ea_clus_num, ea_infos, num_eas,
                             &ea_header_mem, &ea_header, &fat_bitmap,
                             FixLevel, &report, Message, &fmsg)) {
            // DELETE( ea_infos );
            delete [] ea_infos; ea_infos = NULL;
            _Verbose = FALSE;
            _pvfMessage = NULL;
            return FALSE;
        }

        changes = FALSE;
        if (ea_clus_num) {
            if (eadent.QueryStartingCluster() != ea_clus_num) {
                eadent.SetStartingCluster(ea_clus_num);
                changes = TRUE;
            }
            ULONG new_file_size = cluster_size * _fat->QueryLengthOfChain(ea_clus_num);
            if (eadent.QueryFileSize() != new_file_size) {
                eadent.SetFileSize(new_file_size);
                changes = TRUE;
            }
        } else {
            changes = TRUE;
            dofmsg(Message, &fmsg);
            Message->Set(MSG_CHK_EMPTY_EA_FILE);
            Message->Display();

            //
            // Note that the following two steps cause the EA file chain to get recovered
            //  as a lost cluster chain since all this does is erase the dirent, not the
            //  cluster chain.
            //
            eadent.SetErased();
            FreeSpaceInBitmap(eadent.QueryStartingCluster(), _fat,
                              &fat_bitmap);
        }
        if (changes) {
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            dofmsg(Message, &fmsg);
            Message->Set(MSG_CHK_REPAIRED_EA);
            Message->Display();
        }
    }

    //
    // If WalkDirectoryTree deleted any files, we need to sync the
    // FAT_EXTENSIONS up with the FAT again.
    //
    if (!VerifyFatExtensions(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    if (!RecoverOrphans(&fat_bitmap, FixLevel, Message, &fmsg, &report)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    //
    // RecoverOrphans may have cleared faulty entries from the FAT,
    // and now we need to sync the FAT_EXTENSIONS again.
    //
    if (!VerifyFatExtensions(FixLevel, Message, &fmsg)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // If requested, validate all of the free space on the volume.

    if (RecoverFree && !RecoverFreeSpace(&report, Message)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    total_count = cluster_count - FirstDiskCluster;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, &report);
    *ExitStatus = report.ExitStatus;

    switch (*ExitStatus) {
      case CHKDSK_EXIT_SUCCESS:
        Message->DisplayMsg(MSG_CHK_NO_PROBLEM_FOUND);
        break;

      case CHKDSK_EXIT_ERRS_FIXED:
        Message->DisplayMsg((FixLevel != CheckOnly) ? MSG_CHK_ERRORS_FIXED : MSG_CHK_NEED_F_PARAMETER);
        break;

      case CHKDSK_EXIT_COULD_NOT_CHK:
//    case CHKDSK_EXIT_ERRS_NOT_FIXED:
//    case CHKDSK_EXIT_COULD_NOT_FIX:
        Message->DisplayMsg(MSG_CHK_ERRORS_NOT_FIXED);
        break;

    }

    BIG_INT temp_big_int;
    ULONG   temp_ulong;
    MSGID   message_id;
    BOOLEAN KSize;
    DSTRING wdNum1;
    char    wdAstr[14];
    DSTRING wdNum2;


    if (!wdNum1.Initialize("             ") ||
        !wdNum2.Initialize("             ")   ) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    temp_big_int = cluster_size;
    temp_big_int = temp_big_int * total_count;

    // NOTE: The magic number 4095MB comes from Win9x's GUI SCANDISK utility

    if (temp_big_int.GetHighPart() || (temp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_TOTAL_KILOBYTES;
        KSize = TRUE;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_TOTAL_DISK_SPACE;
        KSize = FALSE;
    }

    Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (report.HiddenEntriesCount) {
        temp_big_int = cluster_size;
        temp_big_int = temp_big_int * report.HiddenClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_HIDDEN_FILES;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_HIDDEN_FILES;
        }
        Message->Set(message_id);

        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);

        sprintf(wdAstr, "%d", report.HiddenEntriesCount);
        InsertSeparators(wdNum2.GetWSTR(),wdAstr, 0);

        Message->Display("%ws%ws", wdNum1.GetWSTR(), wdNum2.GetWSTR());
    }

    if (report.DirEntriesCount) {
        temp_big_int = cluster_size;
        temp_big_int = temp_big_int * report.DirClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_DIRECTORIES;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_DIRECTORIES;
        }
        Message->Set(message_id);

        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);

        sprintf(wdAstr, "%d", report.DirEntriesCount);
        InsertSeparators(wdNum2.GetWSTR(),wdAstr, 0);

        Message->Display("%ws%ws", wdNum1.GetWSTR(), wdNum2.GetWSTR());
    }

    if (report.FileEntriesCount) {

        temp_big_int = cluster_size;
        temp_big_int = temp_big_int * report.FileClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_USER_FILES;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_USER_FILES;
        }
        Message->Set(message_id);

        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);

        sprintf(wdAstr, "%d", report.FileEntriesCount);
        InsertSeparators(wdNum2.GetWSTR(),wdAstr, 0);

        Message->Display("%ws%ws", wdNum1.GetWSTR(), wdNum2.GetWSTR());
    }

    if (bad_count = _fat->QueryBadClusters()) {
        temp_big_int = bad_count;
        temp_big_int = temp_big_int * cluster_size;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_BAD_SECTORS;
        }
        Message->Set(message_id);
        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
        Message->Display("%ws", wdNum1.GetWSTR());
    }

    if (ea_infos) {
        Message->Set(MSG_CHK_EA_SIZE);

        sprintf(wdAstr, "%u", cluster_size*_fat->QueryLengthOfChain(ea_clus_num));
        InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
        Message->Display("%ws", wdNum1.GetWSTR());
    }

    free_count = _fat->QueryFreeClusters();

    temp_big_int = free_count;
    temp_big_int = temp_big_int * cluster_size;
    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_AVAILABLE_KILOBYTES;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_AVAILABLE_DISK_SPACE;
    }
    Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_ALLOCATION_UNIT_SIZE);
    sprintf(wdAstr, "%u", cluster_size);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_TOTAL_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", total_count);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_AVAILABLE_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", free_count);
    InsertSeparators(wdNum1.GetWSTR(),wdAstr, 13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (FixLevel != CheckOnly && ea_infos && !ea_header.Write()) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // Clear the dirty bit.
    //
    if( RecoverAlloc ) {
        SetVolumeFlags(FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE,
                       TRUE);
    } else {
        SetVolumeFlags(FAT_BPB_RESERVED_DIRTY, TRUE);
    }

    if (FixLevel != CheckOnly && !Write(Message)) {
        // DELETE(ea_infos);
        delete [] ea_infos; ea_infos = NULL;
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }

    // DELETE(ea_infos);
    delete [] ea_infos; ea_infos = NULL;
    _Verbose = FALSE;
    _pvfMessage = NULL;
    return TRUE;
}

BOOLEAN
FAT_SA::VerifyAndFixFat32RootDir (
    IN OUT  PBITVECTOR      FatBitMap,
    IN      PMESSAGE        Message,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PBOOLEAN        NeedErrorMessage
    )

/*++

Routine Description:

    This routine verifies the FAT32 root directory which is not an integral
    part of the super area buffer. The method employed to verify and fix the
    root directory is very similar to the one used to verify and fix regular
    directory structure.

Arguments:

    BitVector - Supplies a bit map for cross/bad links detection. The whole
                map should be zeroed when it is passed in this method.
    Message   - Supplies an outlet for messages.
    Report    - Supplies the fat chkdsk report structures for storing the
                actions performed by this method.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          under check only conditions.

Return Values:

    TRUE  - Success.
    FALSE - Failed.

--*/
{

    BOOLEAN crosslink_detected = FALSE;
    BOOLEAN changes_made = FALSE;
    ULONG   starting_cluster;
    ULONG   dummy;
    ULONG   errFixedStatus = CHKDSK_EXIT_SUCCESS;

    starting_cluster = QueryFat32RootDirStartingCluster();
    _fat->ScrubChain( starting_cluster,
                      FatBitMap,
                      &changes_made,
                      &crosslink_detected,
                      &dummy );
    //
    // Root dir is the only component marked in the
    // bitmap so far.
    //

    DebugAssert(!crosslink_detected);

    if (changes_made) {
        dofmsg(Message, NeedErrorMessage);
        Message->Set(MSG_BAD_LINK);
        Message->Display("%s", "\\");
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        //
        //  We have to reinitialized the root directory.
        //

        if (!_hmem_F32->Initialize() ||
            !_dirF32->Initialize( _hmem_F32, _drive, this,
                                  _fat, starting_cluster)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        //
        //  Force a re-reading of the root directory.
        //  We don't care if it fails, subsequent code can fix that.
        //

        _dirF32->Read();
    }

    //
    // Validate the readability of the root chain
    //

    //
    // t-raymak:
    // We don't want replacement clusters becuase the replacement given
    // by RecoverChain will be zeroed which, according to the spec., means
    // it contains the end of the directory structure and WalkDirectoryTree
    // will just go ahead and erase all the 'good' directory entries that comes
    // after the replaced cluster. Not a really nice thing to do to the root
    // directory IMHO.
    //
    if(!RecoverChain(&starting_cluster, &changes_made, 0, FALSE)){
        dofmsg(Message, NeedErrorMessage);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (changes_made) {

        if ( starting_cluster ) {

            if ( starting_cluster != _dirF32->QueryStartingCluster() ) {
                SetFat32RootDirStartingCluster( starting_cluster );
            }

            //
            // Should reinitialize the root directory
            //
            if (!_hmem_F32->Initialize() ||
                !_dirF32->Initialize( _hmem_F32, _drive, this,
                                      _fat, starting_cluster)) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }


        } else {

            if(!RelocateNewFat32RootDirectory( Report, FatBitMap, Message )) {
                return FALSE;
            }

        }


        //
        //  Reread the root directory
        //
        if (!_dirF32->Read()) {
            //
            //  Shouldn't fail.
            //
            DebugAbort("Failed to read the FAT32 root directory despite all the fixing.\n");

        }
        dofmsg(Message, NeedErrorMessage);
        Message->Set(MSG_CHK_NTFS_CORRECTING_ERROR_IN_DIRECTORY);
        Message->Display("%s", "\\");
        //
        // Erasing the root will totally destroy the disk
        // so we just leave it partially corrupted and
        // hopefully WalkDirectoryTree will be able to fix it.
        //
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}

BOOLEAN
FAT_SA::RelocateNewFat32RootDirectory (
    IN OUT PFATCHK_REPORT   Report,
    IN OUT PBITVECTOR       FatBitMap,
    IN     PMESSAGE         Message
    )
/*++

Routine Description:

    This routine relocates a FAT32 root directory

Arguments:

    Report - Supplies the fat chkdsk report structure for storing
             the fix status.

    FatBitMap - Supplies a pointer to the bit map for cross-link
                detection.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - Success.
    FALSE - Failed.

--*/
{

    SECRUN  root_secrun; // Allocate one cluster for the
                         // new root directory.
    ULONG   root_clus;   // New cluster number of the
                         // root directory
    ULONG   cluster_size;// Number of sectors in a cluster.

    ULONG   starting_data_lbn;
    ULONG   sector_size;

    starting_data_lbn = QueryStartDataLbn();
    cluster_size = QuerySectorsPerCluster();
    sector_size = _drive->QuerySectorSize();


    for (;;) {

        root_clus = _fat->AllocChain(1, NULL);

        if (!root_clus) {
            //
            // The disk is full, we have no choice but to bail out.
            //
            Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            return FALSE;
        }

        if ( !_hmem_F32->Initialize() ||
             !root_secrun.Initialize( _hmem_F32,
                                      _drive,
                                      QuerySectorFromCluster(root_clus, NULL),
                                      cluster_size)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        memset(root_secrun.GetBuf(), 0, cluster_size * sector_size);

        if (root_secrun.Write() && root_secrun.Read()) {
            SetFat32RootDirStartingCluster(root_clus);
            //
            //  Set the bit for the new root in the bit map.
            //
            FatBitMap->SetBit(root_clus);

            //
            //  Reinitialize the FAT32 root directory
            //
            if ( !_hmem_F32->Initialize() ||
                 !_dirF32->Initialize( _hmem_F32, _drive, this,
                                       _fat, root_clus)) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);

            return TRUE;
        } else {
            _fat->SetClusterBad(root_clus);
        }

    }

    DebugPrintTrace(("FAT_SA::RelocateNewFat32RootDirectory: This line should not be reached.\n"));
    return FALSE;
}


BOOLEAN
FAT_SA::PerformEaLogOperations(
    IN      ULONG           EaFileCn,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine reads the EA file log from the disk and then performs
    any logged operations specified.

Arguments:

    EaFileCn            - Supplies the first cluster of the EA file.
    FixLevel            - Supplies the fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM            hmem;
    EA_HEADER       ea_header;
    PEA_FILE_HEADER pea_header;
    ULONG           cluster_size;
    ULONG           num_clus;

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();
    num_clus = sizeof(EA_FILE_HEADER) + BaseTableSize*sizeof(USHORT);
    if (num_clus%cluster_size) {
        num_clus = (num_clus/cluster_size + 1);
    } else {
        num_clus = (num_clus/cluster_size);
    }

    if (!hmem.Initialize() ||
        !ea_header.Initialize(&hmem, _drive, this, _fat, EaFileCn, num_clus) ||
        !(pea_header = ea_header.GetEaFileHeader())) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!ea_header.Read()) {
        Message->Set(MSG_CHK_CANT_CHECK_EA_LOG);
        Message->Display();
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return TRUE;
    }

    if (pea_header->Signature != HeaderSignature ||
        pea_header->FormatType ||
        pea_header->LogType) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_BAD_LOG, NORMAL_MESSAGE, TEXT_MESSAGE);
        Message->Display();
        if (Message->IsYesResponse(TRUE)) {
            pea_header->Signature = HeaderSignature;
            pea_header->Cluster1 = 0;
            pea_header->Cluster2 = 0;
            pea_header->Cluster3 = 0;

            if (FixLevel != CheckOnly && !ea_header.Write()) {
                Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
            }

            UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);

            return TRUE;
        } else {
            return FALSE;
        }
    }

    if (pea_header->Cluster1) {
        if (_fat->IsInRange(pea_header->Cluster1) &&
            _fat->IsInRange(pea_header->NewCValue1)) {
            _fat->SetEntry(pea_header->Cluster1, pea_header->NewCValue1);
        } else {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_ERROR_IN_LOG);
            Message->Display();
        }
    }

    if (pea_header->Cluster2) {
        if (_fat->IsInRange(pea_header->Cluster2) &&
            _fat->IsInRange(pea_header->NewCValue2)) {
            _fat->SetEntry(pea_header->Cluster2, pea_header->NewCValue2);
        } else {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_ERROR_IN_LOG);
            Message->Display();
        }
    }

    if (pea_header->Cluster3) {
        if (_fat->IsInRange(pea_header->Cluster3) &&
            _fat->IsInRange(pea_header->NewCValue3)) {
            _fat->SetEntry(pea_header->Cluster3, pea_header->NewCValue3);
        } else {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_ERROR_IN_LOG);
            Message->Display();
        }
    }

    return TRUE;
}


PEA_INFO
FAT_SA::RecoverEaSets(
    IN      ULONG           EaFileCn,
    OUT     PUSHORT         NumEas,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine validates and if necessary recovers the EA file.

Arguments:

    EaFileCn            - Supplies the cluster number for the EA file.
    NumEas              - Returns the number of EA sets in the EA file.
    FixLevel            - Supplies the CHKDSK fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          under check only conditions.

Return Value:

    An allocated array containing 'NumberOfEaSets' entries documenting
    important information about the EA sets.  If there are no EAs then
    'NumberOfEaSets' is returned as 0 and NULL is returned.  If there
    is an error then NULL will be returned with a non-zero
    'NumberOfEaSets'.

--*/
{
    PEA_INFO    ea_infos;
    ULONG       clus, prev;
    USHORT      num_eas;
    ULONG       i;
    ULONG       length;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    DebugAssert(NumEas);

    *NumEas = 1;

    length = _fat->QueryLengthOfChain(EaFileCn);
    ea_infos = NEW EA_INFO[length];
    if (!ea_infos) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return NULL;
    }

    memset(ea_infos, 0, length*sizeof(EA_INFO));

    //
    // Scan file for EA sets and validate them while updating the
    // array.
    //
    num_eas = 0;
    prev = EaFileCn;
    while (!_fat->IsEndOfChain(prev)) {

        clus = VerifyAndFixEaSet(prev, &ea_infos[num_eas], FixLevel, Report,
                                 Message, NeedErrorsMessage);

        if (clus) {
            num_eas++;
        } else {
            clus = _fat->QueryEntry(prev);
        }

        prev = clus;
    }

    if (!num_eas) {

        // All the ea sets are unused, the ea file is
        // effectively empty.

        // Should use array delete instead.
        // DELETE( ea_infos );
        delete [] ea_infos;

        // Free the cluster chain occupied by the ea file
        // so subsequent checking and fixing will not
        // complain about the lost chain in the ea file.

        _fat->FreeChain(EaFileCn);

        ea_infos = NULL;
        *NumEas = 0;
        return NULL;
    }


    // Go through and remove unused portions of the EA file.

    for (i = 0; i < (USHORT)(num_eas - 1); i++) {
        if (ea_infos[i].LastCn != ea_infos[i + 1].PreceedingCn) {

            _fat->RemoveChain(ea_infos[i].LastCn,
                              ea_infos[i + 1].PreceedingCn);

            dofmsg(Message, NeedErrorsMessage);

            Message->Set(MSG_CHK_UNUSED_EA_PORTION);
            Message->Display();

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            ea_infos[i + 1].PreceedingCn = ea_infos[i].LastCn;
        }
    }

    if (!_fat->IsEndOfChain(ea_infos[num_eas - 1].LastCn)) {

        _fat->SetEndOfChain(ea_infos[num_eas - 1].LastCn);

        dofmsg(Message, NeedErrorsMessage);

        Message->Set(MSG_CHK_UNUSED_EA_PORTION);
        Message->Display();

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }


    // Sort the EAs in the EA file.

    if (!EaSort(ea_infos, num_eas, Report, Message, NeedErrorsMessage)) {
        return NULL;
    }

    *NumEas = num_eas;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return ea_infos;
}


ULONG
FAT_SA::VerifyAndFixEaSet(
    IN      ULONG           PreceedingCluster,
    OUT     PEA_INFO        EaInfo,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine attempts to identify the clusters following the
    'PreceedingCluster' as an EA set.  If this routine does not
    recognize these clusters as an EA set then it will return 0.
    Otherwise, it will return the last cluster of the validated EA set.

    Changes may be made to the clusters if they are recognized as an EA
    set with errors.

Arguments:

    PreceedingCluster   - Supplies the cluster preceeding the EA set cluster.
    Info                - Returns information about the EA set.
    FixLevel            - Supplies the CHKDSK fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    The cluster number of the last cluster in the EA set or 0.

--*/
{
    HMEM    hmem;
    EA_SET  easet;
    ULONG   clus;
    PEA_HDR eahdr;
    LONG    i;
    ULONG   j;
    ULONG   need_count;
    LONG    total_size;
    LONG    size;
    ULONG   length;
    BOOLEAN need_write;
    PEA     pea;
    BOOLEAN more;
    ULONG   chain_length;

    clus = _fat->QueryEntry(PreceedingCluster);
    chain_length = _fat->QueryLengthOfChain(clus);

    length = 1;
    need_write = FALSE;

    if (!hmem.Initialize() ||
        !easet.Initialize(&hmem, _drive, this, _fat, clus, length) ||
        !(eahdr = easet.GetEaSetHeader())) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return 0;
    }

    if (!easet.Read()) {
        return 0;
    }

    if (!easet.VerifySignature()) {
        return 0;
    }

    need_count = 0;
    total_size = 4;
    for (i = 0; ; i++) {
        for (j = 0; !(pea = easet.GetEa(i, &size, &more)) && more &&
                     length + j < chain_length; ) {
            j++;
            if (!hmem.Initialize() ||
                !easet.Initialize(&hmem, _drive, this, _fat, clus, length + j)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return 0;
            }

            if (!easet.Read()) {
                return 0;
            }
        }

        if (pea) {
            length += j;
        } else {
            break;
        }

        total_size += size;

        if (pea->Flag & NeedFlag) {
            need_count++;
        }
    }

    if (!i) {
        return 0;
    }

    if (total_size != eahdr->TotalSize) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_EASET_SIZE);
        Message->Display("%d", clus);
        eahdr->TotalSize = total_size;
        need_write = TRUE;
    }

    if (need_count != eahdr->NeedCount) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_EASET_NEED_COUNT);
        Message->Display("%d", clus);
        eahdr->NeedCount = need_count;
        need_write = TRUE;
    }

    EaInfo->OwnHandle = eahdr->OwnHandle;
    EaInfo->PreceedingCn = PreceedingCluster;
    EaInfo->LastCn = _fat->QueryNthCluster(PreceedingCluster, length);
    memcpy(EaInfo->OwnerFileName, eahdr->OwnerFileName, 14);
    EaInfo->UsedCount = 0;

    if (need_write) {
        if (FixLevel != CheckOnly && !easet.Write()) {
            return 0;
        }
        UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
    }

    return EaInfo->LastCn;
}


BOOLEAN
FAT_SA::EaSort(
    IN OUT  PEA_INFO        EaInfos,
    IN      ULONG           NumEas,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine sorts the EaInfos array by 'OwnHandle' into ascending order.
    It also edits the FAT with the changes in the EAs order.

Arguments:

    EaInfos             - Supplies the array of EA_INFOs to sort.
    NumEas              - Supplies the number of elements in the array.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN done;
    EA_INFO tmp;
    ULONG   clus;
    ULONG   i;
    BOOLEAN change;

    done = FALSE;
    change = FALSE;
    while (!done) {
        done = TRUE;
        for (i = 0; i < NumEas - 1; i++) {
            if (EaInfos[i].OwnHandle > EaInfos[i + 1].OwnHandle) {
                done = FALSE;

                clus = _fat->RemoveChain(EaInfos[i + 1].PreceedingCn,
                                         EaInfos[i + 1].LastCn);

                _fat->InsertChain(clus,
                                  EaInfos[i + 1].LastCn,
                                  EaInfos[i].PreceedingCn);

                EaInfos[i + 1].PreceedingCn = EaInfos[i].PreceedingCn;
                EaInfos[i].PreceedingCn = EaInfos[i + 1].LastCn;
                if (i + 2 < NumEas) {
                    EaInfos[i + 2].PreceedingCn = EaInfos[i].LastCn;
                }

                change = TRUE;

                tmp = EaInfos[i];
                EaInfos[i] = EaInfos[i + 1];
                EaInfos[i + 1] = tmp;
            }
        }
    }

    if (change) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_UNORDERED_EA_SETS);
        Message->Display();
        UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
    }

    return TRUE;
}


BOOLEAN
FAT_SA::RebuildEaHeader(
    IN OUT  PULONG          StartingCluster,
    IN OUT  PEA_INFO        EaInfos,
    IN      ULONG           NumEas,
    IN OUT  PMEM            EaHeaderMem,
    OUT     PEA_HEADER      EaHeader,
    IN OUT  PBITVECTOR      FatBitMap,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine rebuilds the header and tables of the EA file base on the
    information in the 'EaInfos' array.  The header log is set to zero,
    and the header itself is relocated if any of the clusters are bad.

    The starting cluster may be relocated if there are bad clusters.

Arguments:

    StartingCluster     - Supplies the first cluster of the EA file.
    EaInfos             - Supplies an array containing information for every
                            EA set.
    NumberOfEas         - Supplies the total number of EA sets.
    EaHeaderMem         - Supplies the memory for the EA header.
    EaHeader            - Returns the EA header.
    FatBitMap           - Supplies the cross-links bitmap.
    FixLevel            - Supplies the CHKDSK fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           length;
    ULONG           cluster_size;
    ULONG           actual_length;
    ULONG           new_chain;
    ULONG           last_cluster;
    BOOLEAN         changes;
    LONG            i, j, k;
    PEA_MAP_TBL     table;
    PEA_FILE_HEADER header;
    LONG            tmp;
    BOOLEAN         empty_ea_file;
    ULONG           clus;
    ULONG           errFixedStatus = CHKDSK_EXIT_SUCCESS;

    // Compute the number of clusters necessary for the header portion of
    // the EA file.

    length = sizeof(EA_FILE_HEADER) +
             BaseTableSize*sizeof(USHORT) +
             EaInfos[NumEas - 1].OwnHandle*sizeof(USHORT);

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    if (length%cluster_size) {
        length = length/cluster_size + 1;
    } else {
        length = length/cluster_size;
    }

    //
    // Make sure that the header contains enough clusters to accomodate
    // the size of the offset table.
    //

    last_cluster = EaInfos[0].PreceedingCn;

    actual_length = _fat->QueryLengthOfChain(*StartingCluster, last_cluster);

    if (length > actual_length) {

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_NEED_MORE_HEADER_SPACE);
        Message->Display();

        new_chain = _fat->AllocChain((length - actual_length),
                                     &last_cluster);
        if (!new_chain) {
            Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            return FALSE;
        }

        if (IsCompressed() && !AllocSectorsForChain(new_chain)) {
            _fat->FreeChain(new_chain);
            Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
            Message->Display();
            return FALSE;
        }

        for (clus = new_chain;
             !_fat->IsEndOfChain(clus);
             clus = _fat->QueryEntry(clus)) {

            FatBitMap->SetBit(clus);
        }
        FatBitMap->SetBit(clus);

        _fat->InsertChain(new_chain, last_cluster, EaInfos[0].PreceedingCn);

        EaInfos[0].PreceedingCn = last_cluster;

    } else if (length < actual_length) {

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_UNUSED_EA_PORTION);
        Message->Display();

        last_cluster = _fat->QueryNthCluster(*StartingCluster,
                                             length - 1);

        clus = _fat->RemoveChain(last_cluster, EaInfos[0].PreceedingCn);

        EaInfos[0].PreceedingCn = last_cluster;

        for (;
             !_fat->IsEndOfChain(clus);
             clus = _fat->QueryEntry(clus)) {

            FatBitMap->ResetBit(clus);
        }
        FatBitMap->ResetBit(clus);

    }


    // Verify the cluster chain containing the header.

    changes = FALSE;
    if (FixLevel != CheckOnly &&
        !RecoverChain(StartingCluster, &changes, last_cluster, TRUE)) {

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_INSUFFICIENT_DISK_SPACE);
        Message->Display();

        return FALSE;
    }

    if (changes) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_RELOCATED_EA_HEADER);
        Message->Display();
    }


    // Compute the tables.

    if (!EaHeader->Initialize(EaHeaderMem, _drive, this, _fat,
                              *StartingCluster, (USHORT) length) ||
        !(table = EaHeader->GetMapTable()) ||
        !(header = EaHeader->GetEaFileHeader())) {

        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!EaHeader->Read()) {
        if (FixLevel == CheckOnly) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_RELOCATED_EA_HEADER);
            Message->Display();
        } else {
            return FALSE;
        }
    }


    // Set the log in the header to zero.

    header->Signature = HeaderSignature;
    header->FormatType = 0;
    header->LogType = 0;
    header->Cluster1 = 0;
    header->NewCValue1 = 0;
    header->Cluster2 = 0;
    header->NewCValue2 = 0;
    header->Cluster3 = 0;
    header->NewCValue3 = 0;
    header->Handle = 0;
    header->NewHOffset = 0;


    // Reconcile the tables with the EaInfo information.

    changes = FALSE;

    for (i = 0; i < BaseTableSize; i++) {
        table->BaseTab[i] = 0;
    }

    j = 0;
    empty_ea_file = TRUE;
    for (i = 0; i < (LONG) NumEas; i++) {

        if (EaInfos[i].UsedCount != 1) {
            continue;
        }

        empty_ea_file = FALSE;

        for (; j < (LONG) EaInfos[i].OwnHandle; j++) {
            if (table->OffTab[j] != InvalidHandle) {
                table->OffTab[j] = InvalidHandle;
                changes = TRUE;
            }
        }

        length = _fat->QueryLengthOfChain(*StartingCluster,
                                         EaInfos[i].PreceedingCn);

        for (k = j>>7; k >= 0 && !table->BaseTab[k]; k--) {
            table->BaseTab[k] = (USHORT) length;
        }

        tmp = length - table->BaseTab[j>>7];

        if ((LONG)table->OffTab[j] != tmp) {
            table->OffTab[j] = (USHORT) tmp;
            changes = TRUE;
        }

        j++;
    }

    if (empty_ea_file) {

        for (clus = *StartingCluster;
             !_fat->IsEndOfChain(clus);
             clus = _fat->QueryEntry(clus)) {

            FatBitMap->ResetBit(clus);

        }
        FatBitMap->ResetBit(clus);

        *StartingCluster = 0;

        return TRUE;
    }

    tmp = _fat->QueryLengthOfChain(*StartingCluster);
    for (k = ((j - 1)>>7) + 1; k < BaseTableSize; k++) {
        table->BaseTab[k] = (USHORT) tmp;
    }

    for (; j < (LONG) EaHeader->QueryOffTabSize(); j++) {
        if (table->OffTab[j] != InvalidHandle) {
            table->OffTab[j] = InvalidHandle;
            changes = TRUE;
        }
    }

    if (changes) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_ERROR_IN_EA_HEADER);
        Message->Display();
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}


VOID
FreeSpaceInBitmap(
    IN      ULONG       StartingCluster,
    IN      PCFAT       Fat,
    IN OUT  PBITVECTOR  FatBitMap
    )
{
    if (!StartingCluster) {
        return;
    }

    while (!Fat->IsEndOfChain(StartingCluster)) {
        FatBitMap->ResetBit(StartingCluster);
        StartingCluster = Fat->QueryEntry(StartingCluster);
    }
    FatBitMap->ResetBit(StartingCluster);
}


ULONG
ComputeFileNameHashValue(
    IN  PVOID   FileName
    )
{
    ULONG   h, g;
    BYTE    i;
    PUCHAR  p;

    p = (PUCHAR) FileName;
    h = 0;
    for (i=0; i<11; i++) {
        h = (h << 2) ^ p[i];
    }
    for (i=0; i<2; i++) {
        h = (h << 2) ^ p[i];
    }
    return h;
}

STATIC ULONG         _Twinkle = 0;
STATIC LONG64        _LastTwnkTime = 0;
STATIC ULONG         _LastPercent = 0xFFFFFFFF;

BOOLEAN
DisplayTwnkPercent(
    ULONG   percent
    )
{
    BIG_INT currenttime;

    NtQuerySystemTime((_LARGE_INTEGER *)&currenttime);

    // The above clock counts in 1/10,000ths of a second

    if((percent != _LastPercent) ||
       ((currenttime.GetQuadPart() - _LastTwnkTime) >= (6 * 100 * 10000)))
    {
        if(percent > 100) {
            percent = 100;
        }
        if((_Twinkle > 5) || _Verbose) {
            _Twinkle = 0;
        }
        if(_Verbose && (percent == _LastPercent)) {
            return TRUE;
        }
        _LastPercent = percent;
        _LastTwnkTime = currenttime.GetQuadPart();
        if(_pvfMessage) {
            STR  dots[6];

            dots[5] = '\0';
            dots[4] = ' ';
            dots[3] = ' ';
            dots[2] = ' ';
            dots[1] = ' ';
            dots[0] = ' ';
            switch(_Twinkle) {
                case 5:
                default:
                    dots[4] = '.';
                case 4:
                    dots[3] = '.';
                case 3:
                    dots[2] = '.';
                case 2:
                    dots[1] = '.';
                case 1:
                    dots[0] = '.';
                case 0:
                    ;
            }
            if(!_Verbose) {
                _Twinkle++;
            }
            _pvfMessage->Set(MSG_PERCENT_COMPLETE2);
            if (!_pvfMessage->Display("%d%s", percent, &dots[0])) {
                return FALSE;
            }
            if(_Verbose) {
                _pvfMessage->Set(MSG_BLANK_LINE);
                _pvfMessage->Display();
            }

        }
    }
    return TRUE;
}

VOID DoTwinkle(
    VOID
          )
{
    DisplayTwnkPercent(_LastPercent);
    return;
}

VOID DoInsufMemory(
   VOID
          )
{

    if(_pvfMessage) {
        _pvfMessage->Set(MSG_CHK_NO_MEMORY);
        _pvfMessage->Display();
    } else {
        DebugPrintTrace(("UFAT: Insufficient memory\n"));
    }
    return;
}

BOOLEAN
FAT_SA::WalkDirectoryTree(
    IN OUT  PEA_INFO        EaInfos,
    IN OUT  PUSHORT         NumEas,
    IN OUT  PBITVECTOR      FatBitMap,
    OUT     PFATCHK_REPORT  Report,
    IN      FIX_LEVEL       FixLevel,
    IN      BOOLEAN         RecoverAlloc,
    IN OUT  PMESSAGE        Message,
    IN      BOOLEAN         Verbose,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine walks all of the files on the volume by traversing
    the directory tree.  In doing so it validates all of the
    directory entries on the disk.  It also verifies the proper
    chaining of all file cluster chains.  This routine also validates
    the integrity of the EA handles for all of the directory entries
    on the disk.

    The FatBitMap is used to find and eliminate cross-links in the file
    system.

Arguments:

    EaInfos             - Supplies the EA information.
    NumEas              - Supplies the number of EA sets.
    FatBitMap           - Supplies a bit map marking all of the clusters
                            currently in use.
    Report              - Returns a FAT CHKDSK report on the files of the disk.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    Verbose             - Supplies whether or not to be verbose.
    NeedErrorsMessage   - Supplies whether or not errors have occurred
                            under check only conditions.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVISIT_DIR      visit_list;
    ULONG           current_dir;
    PFATDIR         dir;
    FILEDIR         filedir;
    FAT_DIRENT      dirent;
    ULONG           i, j;
    ULONG           clus, next;
    DSTRING         file_path;
    PWSTRING        new_path;
    PWSTRING        current_path;
    ULONG           new_dir;
    DSTRING         filename;
    DSTRING         long_name;
    HMEM            hmem;
    CLUSTER_CHAIN   cluster;
    ULONG           new_chain;
    ULONG           cluster_size;
    ULONG           length;
    DSTRING         backslash;
    DSTRING         eafilename;
    DSTRING         eafilename_path;
    DSTRING         tmp_string;
    BOOLEAN         cross_link_detected;
    ULONG           cross_link_prevclus;
    HMEM            tmphmem;
    FILEDIR         tmpfiledir;
    FAT_DIRENT      tmpdirent1;
    FAT_DIRENT      tmpdirent2;
    BOOLEAN         non_zero_dirents;
    HASH_INDEX      file_name_hash_table;
    ULONG           hash_value;
    PULONG          matching_index_array;
    ULONG           matching_index_count;
    BOOLEAN         has_long_entry = FALSE;
    UCHAR           chksum;
    BOOLEAN         broke;
    ULONG           first_long_entry;
    FAT_DIRENT      dirent2;
    ULONG           percent;
    ULONG           allocated_clusters;
    BOOLEAN         processing_ea_file;
    ULONG           old_clus;
    ULONG           new_clus;
    UCHAR           FatType;
    USHORT          numEasLeft = *NumEas;
    ULONG           errFixedStatus = CHKDSK_EXIT_SUCCESS;


//    DebugAssert(sizeof(PUCHAR) <= sizeof(INT));
    DebugAssert(sizeof(USHORT) <= sizeof(INT));
    DebugAssert(sizeof(ULONG  ) <= sizeof(INT));

    visit_list = NULL;

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    if (!backslash.Initialize("\\") ||
        !eafilename.Initialize("EA DATA. SF") ||
        !eafilename_path.Initialize("\\EA DATA. SF")) {

        return FALSE;
    }

    if (!(current_path = NEW DSTRING) ||
        !current_path->Initialize(&backslash)) {

        return FALSE;
    }

    if (!PushVisitDir( &visit_list, 0, current_path )) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    Message->Set(MSG_CHK_CHECKING_FILES);
    Message->Display();

    percent = 0;
    if(!DisplayTwnkPercent(percent)) {
        return FALSE;
    }

    for (;
         PopVisitDir( &visit_list, &current_dir, &current_path );
         DELETE( current_path )) {

        DoTwinkle();

        has_long_entry = FALSE;

        if (current_dir) {
            if (!hmem.Initialize() ||
                !filedir.Initialize(&hmem, _drive, this, _fat, current_dir)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            if (!filedir.Read()) {
                Message->Set(MSG_BAD_DIR_READ);
                Message->Display();
                return FALSE;
            }

            dir = &filedir;
        } else {

           if ( _dir ) {
              dir = _dir;
              FatType = FAT_TYPE_EAS_OKAY;
           } else {
              dir = _dirF32;
              FatType = FAT_TYPE_FAT32;
           }

        }

        if (!file_name_hash_table.Initialize(dir->QueryNumberOfEntries(), 10)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        for (i = (current_dir ? 2 : 0); ; i++) {

            if (!dirent.Initialize(dir->GetDirEntry(i), FatType) ||
                dirent.IsEndOfDirectory()) {

                if (has_long_entry) {
                    //
                    // There was an orphaned lfn at the end of the
                    // directory.  Erase it now.
                    //

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_BAD_LONG_NAME);
                    Message->Display( "%W", current_path );

                    EraseAssociatedLongName(dir, first_long_entry, i);

                    has_long_entry = FALSE;
                }

                //
                // This code must make sure that all other directory
                // entries are end of directory entries.
                //
                non_zero_dirents = FALSE;

                for (; dirent.Initialize(dir->GetDirEntry(i),FatType); i++) {

                    if (!dirent.IsEndOfDirectory()) {
                        non_zero_dirents = TRUE;
                        dirent.SetEndOfDirectory();
                    }
                }

                if (non_zero_dirents) {
                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_TRAILING_DIRENTS);
                    Message->Display("%W", current_path);

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                }

                break;
            }

            if (dirent.IsErased()) {

                if (has_long_entry) {

                    //
                    // The preceding lfn is orphaned.  Remove it.
                    //

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_BAD_LONG_NAME);
                    Message->Display( "%W", current_path );

                    EraseAssociatedLongName(dir, first_long_entry, i);

                    has_long_entry = FALSE;
                }

                continue;
            }

            if (dirent.IsLongEntry()) {

                // skip long name entries; come back to them later

                if (has_long_entry) {
                    // already amid long entry
                    continue;
                }

                // first long entry

                has_long_entry = TRUE;
                first_long_entry = i;
                continue;
            }

            dirent.QueryName(&filename);

            if (has_long_entry) {

                DSTRING lfn;

                //
                // The current entry is short, and we've just finished
                // skipping the associated long entry.  Look back through
                // the long entries, make sure they're okay.
                //

                broke = FALSE;

                chksum = dirent.QueryChecksum();

                for (j = i - 1; j >= first_long_entry; j--) {
                    dirent2.Initialize(dir->GetDirEntry(j),FatType);

                    if (!dirent2.IsLongNameEntry()) {
                        continue;
                    }

                    broke = (dirent2.QueryLongOrdinal() != i - j) ||
                            (dirent2.QueryChecksum() != chksum) ||
                            (LOUSHORT(dirent2.QueryStartingCluster()) != 0);

                    broke = broke || !dirent2.IsWellTerminatedLongNameEntry();

                    if (broke || dirent2.IsLastLongEntry()) {
                        break;
                    }
                }

                broke = broke || (!dirent2.IsLastLongEntry());

                if (!broke && dir->QueryLongName(i, &lfn)) {
                    broke = !FAT_DIRENT::IsValidLongName(&lfn);
                }

#if 0
//MJB: We'll elide this code because Win95 isn't this strict and we
// don't want to delete all their lfn's.

                if (!broke && dir->QueryLongName(i, &lfn)) {

                    broke = !dirent.NameHasTilde() &&
                        (dirent.NameHasExtendedChars() ||
                            0 != filename.Stricmp(&lfn)) &&
                        !IsString8Dot3(&lfn);
                }
#endif

                if (broke) {

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    //
                    // Erase all the long name entries.
                    //

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_BAD_LONG_NAME);
                    Message->Display( "%W", current_path );

                    EraseAssociatedLongName(dir, first_long_entry, i);

                    has_long_entry = FALSE;

                }

                //
                // Fall into code to check short name.
                //
            }

            DoTwinkle();

            dirent.QueryName(&filename);

            if (!file_path.Initialize(current_path)) {
                return FALSE;
            }

            if (current_dir) {
                if (!file_path.Strcat(&backslash)) {
                    return FALSE;
                }
            }

            if (dir->QueryLongName(i, &long_name) &&
                long_name.QueryChCount() != 0) {

                if (!file_path.Strcat(&long_name)) {
                    return FALSE;
                }

            } else {

                if (!file_path.Strcat(&filename)) {
                    return FALSE;
                }
            }

            if (Verbose && !dirent.IsVolumeLabel()) {
                Message->Set(MSG_CHK_FILENAME);
                Message->Display("%W", &file_path);
            }

            if (!ValidateDirent(&dirent, &file_path, FixLevel, RecoverAlloc,
                                Report, Message, NeedErrorsMessage, FatBitMap,
                                &cross_link_detected, &cross_link_prevclus)) {
                return FALSE;
            }

            DoTwinkle();

            if (dirent.IsErased()) {

                //
                // ValidateDirent erased this entry, presumably because it's
                // hosed.  Remove corresponding long name, if any.
                //

                if (has_long_entry) {
                    EraseAssociatedLongName(dir, first_long_entry, i);
                    has_long_entry = FALSE;
                }
                continue;
            }

            //
            // Analyze for duplicate names
            //
            if (!dirent.IsVolumeLabel()) {

                BOOLEAN     renamed = FALSE;
                ULONG       renaming_positions = 0;
                FAT_DIRENT  temp_dirent;
                DSTRING     new_filename;
                BOOLEAN     changes = FALSE;

                if (!CheckAndFixFileName(dir->GetDirEntry(i), &changes)) {
                    Message->Set(MSG_CHK_UNHANDLED_INVALID_NAME);
                    Message->Display("%W%W", &filename, current_path);
                }

                for (;;) {
                    hash_value = ComputeFileNameHashValue(dir->GetDirEntry(i));

                    if (!file_name_hash_table.QueryAndAdd(hash_value,
                                                          i,
                                                          &matching_index_array,
                                                          &matching_index_count)) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }

                    DebugAssert(matching_index_count >= 1);
                    matching_index_count--;

                    if (matching_index_count &&
                        IsFileNameMatch(dir, FatType, i, matching_index_count, matching_index_array)) {

                        file_name_hash_table.RemoveLastEntry(hash_value, i);

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        renamed = TRUE;
                        if (!RenameFileName(&renaming_positions, dir->GetDirEntry(i))) {

                            if (!temp_dirent.Initialize(dir->GetDirEntry(i), FatType)) {
                                if (!new_filename.Initialize(L"????????.???")) {
                                    Message->Set(MSG_CHK_NO_MEMORY);
                                    Message->Display();
                                    return FALSE;
                                }
                            } else {
                                if (!temp_dirent.QueryName(&new_filename)) {
                                    Message->Set(MSG_CHK_NO_MEMORY);
                                    Message->Display();
                                    return FALSE;
                                }
                            }

                            dofmsg(Message, NeedErrorsMessage);
                            Message->Set(MSG_CHK_RENAMING_FAILURE);
                            Message->Display("%W%W%W", &filename, current_path, &new_filename);

                            if (!filename.Initialize(&new_filename)) {
                                Message->Set(MSG_CHK_NO_MEMORY);
                                Message->Display();
                                return FALSE;
                            }

                            if (!file_path.Initialize(current_path)) {
                                return FALSE;
                            }

                            if (current_dir) {
                                if (!file_path.Strcat(&backslash)) {
                                    return FALSE;
                                }
                            }

                            if (dir->QueryLongName(i, &long_name) &&
                                long_name.QueryChCount() != 0) {

                                if (!file_path.Strcat(&long_name)) {
                                    return FALSE;
                                }

                            } else {

                                if (!file_path.Strcat(&new_filename)) {
                                    return FALSE;
                                }
                            }

                            break;  // done
                        } else {

                            if (!temp_dirent.Initialize(dir->GetDirEntry(i), FatType)) {
                                if (!new_filename.Initialize(L"????????.???")) {
                                    Message->Set(MSG_CHK_NO_MEMORY);
                                    Message->Display();
                                    return FALSE;
                                }
                            } else {
                                if (!temp_dirent.QueryName(&new_filename)) {
                                    Message->Set(MSG_CHK_NO_MEMORY);
                                    Message->Display();
                                    return FALSE;
                                }
                            }

                            dofmsg(Message, NeedErrorsMessage);
                            Message->Set(MSG_CHK_RENAMED_REPEATED_ENTRY);
                            Message->Display("%W%W%W", &filename, current_path, &new_filename);
                        }

                    } else if (renamed) {

                        if (!temp_dirent.Initialize(dir->GetDirEntry(i), FatType)) {
                            if (!new_filename.Initialize(L"????????.???")) {
                                Message->Set(MSG_CHK_NO_MEMORY);
                                Message->Display();
                                return FALSE;
                            }
                        } else {
                            if (!temp_dirent.QueryName(&new_filename)) {
                                Message->Set(MSG_CHK_NO_MEMORY);
                                Message->Display();
                                return FALSE;
                            }
                        }

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        dofmsg(Message, NeedErrorsMessage);
                        Message->Set(MSG_CHK_RENAMED_REPEATED_ENTRY);
                        Message->Display("%W%W%W", &filename, current_path, &new_filename);

                        if (!filename.Initialize(&new_filename)) {
                            Message->Set(MSG_CHK_NO_MEMORY);
                            Message->Display();
                            return FALSE;
                        }

                        if (!file_path.Initialize(current_path)) {
                            return FALSE;
                        }

                        if (current_dir) {
                            if (!file_path.Strcat(&backslash)) {
                                return FALSE;
                            }
                        }

                        if (dir->QueryLongName(i, &long_name) &&
                            long_name.QueryChCount() != 0) {

                            if (!file_path.Strcat(&long_name)) {
                                return FALSE;
                            }

                        } else {

                            if (!file_path.Strcat(&new_filename)) {
                                return FALSE;
                            }
                        }

                        break;  // no more conflict, done

                    } else if (changes) {

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        dofmsg(Message, NeedErrorsMessage);
                        Message->Set(MSG_CHK_INVALID_NAME_CORRECTED);
                        Message->Display("%W%W", &filename, current_path);
                        break;  // done

                    } else
                        break;  // done as there is no name conflict

                    DoTwinkle();
                }
            }

            DoTwinkle();

            //
            // Analyze for cross-links.
            //
            if (cross_link_detected) {  // CROSSLINK !!

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                // Identify cross linked cluster.

                clus = cross_link_prevclus;

                next = cross_link_prevclus ?
                       _fat->QueryEntry(cross_link_prevclus) :
                       dirent.QueryStartingCluster();

                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_CROSS_LINK);
                Message->Display("%W%d", &file_path, next);

                processing_ea_file = (eafilename_path == file_path);

                if (dirent.IsDirectory()) {

                    DebugAssert(!processing_ea_file);

                    Message->Set(MSG_CHK_DIR_TRUNC);
                    Message->Display();

                    if (clus) {
                        _fat->SetEndOfChain(clus);
                    } else {
                        dirent.SetErased();
                        if (has_long_entry) {
                            EraseAssociatedLongName(dir, first_long_entry, i);
                            has_long_entry = FALSE;
                        }
                        continue;
                    }

                } else {

                    if (!CopyClusters(next, &new_chain, FatBitMap,
                                      FixLevel, Message)) {
                        return FALSE;
                    }

                    if (new_chain) {
                        Message->Set(MSG_CHK_CROSS_LINK_COPY);
                        Message->Display();

                        if (processing_ea_file) {

                            USHORT      j;

                            old_clus = next;
                            new_clus = new_chain;
                            for(;;) {
                                for (j=0; j<*NumEas; j++) {
                                    if (EaInfos[j].PreceedingCn == old_clus) {
                                        EaInfos[j].PreceedingCn = new_clus;
                                    } else if (EaInfos[j].LastCn == old_clus) {
                                        EaInfos[j].LastCn = new_clus;
                                    }
                                }
                                if (_fat->IsEndOfChain(new_clus) || _fat->IsEndOfChain(old_clus)) {
                                    DebugAssert(_fat->IsEndOfChain(new_clus) &&
                                                _fat->IsEndOfChain(old_clus));
                                    break;
                                }
                                old_clus = _fat->QueryEntry(old_clus);
                                new_clus = _fat->QueryEntry(new_clus);
                            }
                        }

                        if (clus) {
                            _fat->SetEntry(clus, new_chain);
                        } else {
                            dirent.SetStartingCluster(new_chain);
                        }

                    } else {

                        Message->Set(MSG_CHK_CROSS_LINK_TRUNC);
                        Message->Display();

                        if (clus) {

                            if (processing_ea_file) {

                                USHORT      j;

                                old_clus = next;
                                for(;;) {
                                    for (j=0; j<*NumEas; j++) {
                                        if (EaInfos[j].LastCn == old_clus) {
                                            numEasLeft = j;
                                            break;
                                        }
                                    }
                                    if (_fat->IsEndOfChain(old_clus))
                                        break;
                                    old_clus = _fat->QueryEntry(old_clus);
                                }
                            }

                            _fat->SetEndOfChain(clus);
                            dirent.SetFileSize(
                                    cluster_size*_fat->QueryLengthOfChain(
                                    dirent.QueryStartingCluster()));

                        } else {
                            numEasLeft = 0;
                            dirent.SetErased();

                            if (has_long_entry) {
                                EraseAssociatedLongName(dir, first_long_entry,
                                    i);
                                has_long_entry = FALSE;
                            }
                        }
                    }
                }
            }

            DoTwinkle();

            if (!ValidateEaHandle(&dirent, current_dir, i, EaInfos, *NumEas,
                                  &file_path, FixLevel, Report, Message,
                                  NeedErrorsMessage)) {
                return FALSE;
            }

            DoTwinkle();

            //
            // Do special stuff if the current entry is a directory.
            //

            if (dirent.IsDirectory()) {

                new_dir = dirent.QueryStartingCluster();

                //
                // Validate the integrity of the directory.
                //

                // Very first make sure it actually has a valid starting clus (check for 0)

                if(!(_fat->IsInRange(new_dir))) {

                    if (dirent.IsDot() ||
                    dirent.IsDotDot()) {

                    // If this happens on the . or .. entry just ignore it as it will
                    // get fixed up later.

                    continue;
                    }

                    Message->Set(MSG_CHK_ERROR_IN_DIR);
                            Message->Display("%W", &file_path);
                            Message->Set(MSG_CHK_CONVERT_DIR_TO_FILE, NORMAL_MESSAGE, TEXT_MESSAGE);
                            Message->Display();
                    if (Message->IsYesResponse(TRUE)) {
                        dirent.ResetDirectory();
                        dirent.SetStartingCluster(0);
                        dirent.SetFileSize(0);
                    }
                    continue;
                }

                // Read the directory.

                if (!tmphmem.Initialize() ||
                    !tmpfiledir.Initialize(&tmphmem, _drive, this, _fat,
                                           new_dir) ||
                    !tmpfiledir.Read()) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();

                        return FALSE;
                }

                // Check the . and .. entries.

                if (!tmpdirent1.Initialize(tmpfiledir.GetDirEntry(0),FatType) ||
                    !tmpdirent2.Initialize(tmpfiledir.GetDirEntry(1),FatType)) {
                    DebugAbort("GetDirEntry of 0 and 1 failed!");
                    return FALSE;
                }

                if (!tmpdirent1.IsDot() ||
                    !tmpdirent2.IsDotDot() ||
                    !tmpdirent1.IsDirectory() ||
                    !tmpdirent2.IsDirectory()) {

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_ERROR_IN_DIR);
                    Message->Display("%W", &file_path);
                    Message->Set(MSG_CHK_CONVERT_DIR_TO_FILE, NORMAL_MESSAGE, TEXT_MESSAGE);
                    Message->Display();

                    if (Message->IsYesResponse(TRUE)) {
                        dirent.ResetDirectory();
                        dirent.SetFileSize(
                               _fat->QueryLengthOfChain(new_dir)*
                               cluster_size);

                    } else {

                        FreeSpaceInBitmap(dirent.QueryStartingCluster(),
                                          _fat, FatBitMap);

                        dirent.SetErased();

                        if (has_long_entry) {
                            EraseAssociatedLongName(dir, first_long_entry, i);
                            has_long_entry = FALSE;
                        }
                        continue;
                    }

                } else {  // Directory looks valid.

                    if (tmpdirent1.QueryStartingCluster() != new_dir ||
                        tmpdirent2.QueryStartingCluster() != current_dir ||
                        tmpdirent1.QueryFileSize() ||
                        tmpdirent2.QueryFileSize()) {

                        dofmsg(Message, NeedErrorsMessage);
                        Message->Set(MSG_CHK_ERRORS_IN_DIR_CORR);
                        Message->Display("%W", &file_path);

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        tmpdirent1.SetStartingCluster(new_dir);
                        tmpdirent2.SetStartingCluster(current_dir);
                        tmpdirent1.SetFileSize(0);
                        tmpdirent2.SetFileSize(0);

                        if (FixLevel != CheckOnly && !tmpfiledir.Write()) {
                            DebugAbort("Could not write tmp file dir.");
                            return FALSE;
                        }
                    }

                    // Add the directory to the list of directories
                    // to validate.

                    if (!(new_path = NEW DSTRING) ||
                        !new_path->Initialize(&file_path)) {

                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }

                    if (!PushVisitDir( &visit_list, new_dir, new_path )) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }
                }
            }

            //
            // Generate report stats.
            //

            if (current_dir || !(filename == eafilename)) {
                length = _fat->QueryLengthOfChain(dirent.QueryStartingCluster());
                if (dirent.IsHidden()) {
                    Report->HiddenEntriesCount++;
                    Report->HiddenClusters += length;
                } else if (dirent.IsDirectory()) {
                    Report->DirEntriesCount++;
                    Report->DirClusters += length;
                } else if (!dirent.IsVolumeLabel()) {
                    Report->FileEntriesCount++;
                    Report->FileClusters += length;
                }
            }

            allocated_clusters = _fat->QueryAllocatedClusterCount();

            if (0 == allocated_clusters) {
                allocated_clusters++;   // Prevent divide by 0
            }

            percent = (Report->HiddenClusters + Report->DirClusters +
                      Report->FileClusters) * 100 / allocated_clusters;

            if(!DisplayTwnkPercent(percent)) {
                return FALSE;
            }
            has_long_entry = FALSE;
        }

        file_name_hash_table.DumpHashTable();
#if 0
        //
        // The following line should be moved to REAL_FAT_SA::Write.
        //
        //
        //  t-raymak
        //  The placement of the following line actually touches upon
        //  the philosophical dilemma of what makes a superarea a superarea.
        //  In the good old FAT16/12 days when the root directory is a fixed size
        //  structure and sitting right next to the fat and boot sector, it kind
        //  of makes sense to define the superarea as a run of sectors including the
        //  the root directory. But now that the FAT32 root directory is defined
        //  as a cluster chain, is the superarea still an area (or a run of sectors
        //  as a matter of fact) by including the FAT32 root directory?(Rhetorical
        //  question) Hence I can sort of understand why the following line
        //  is placed where it is originally (but this is an incomplete job
        //  considering the fact that the FAT32 root directory is still part of
        //  the superarea object). So in order to honor the fine tradition of
        //  totally embedding the root directory into the superarea, I have decided
        //  to move the following line to the Write method of the FAT superarea
        //  object. The proper way out of this dilemma is to define the superarea
        //  as a persistent object which is not necessarily a contagious run of
        //  sectors. (I think I get a little bit carried away.)
        //
        if((_dirF32) && !(current_dir)) { //root directory fix
            if (FixLevel != CheckOnly && !_dirF32->Write()) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return FALSE;
            }
        }
#endif

        if (current_dir) {
            if (FixLevel != CheckOnly && !filedir.Write()) {
                _Verbose = FALSE;
                _pvfMessage = NULL;
                return FALSE;
            }
        }
    }

    percent = 100;
    if(!DisplayTwnkPercent(percent)) {
        _Verbose = FALSE;
        _pvfMessage = NULL;
        return FALSE;
    }
    Message->Set(MSG_CHK_DONE_CHECKING);
    Message->Display();

    *NumEas = numEasLeft;
    _Verbose = FALSE;
    _pvfMessage = NULL;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}


BOOLEAN
FAT_SA::ValidateDirent(
    IN OUT  PFAT_DIRENT     Dirent,
    IN      PCWSTRING       FilePath,
    IN      FIX_LEVEL       FixLevel,
    IN      BOOLEAN         RecoverAlloc,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage,
    IN OUT  PBITVECTOR      FatBitMap,
    OUT     PBOOLEAN        CrossLinkDetected,
    OUT     PULONG          CrossLinkPreviousCluster
    )
/*++

Routine Description:

    This routine verifies that all components of a directory entry are
    correct.  If the time stamps are invalid then they will be corrected
    to the current time.  If the filename is invalid then the directory
    entry will be marked as deleted.  If the cluster number is out of
    disk range then the directory entry will be marked as deleted.
    Otherwise, the cluster chain will be validated and the length of
    the cluster chain will be compared against the file size.  If there
    is a difference then the file size will be corrected.

    If there are any strange errors then FALSE will be returned.

Arguments:

    Dirent                      - Supplies the directory entry to validate.
    FilePath                    - Supplies the full path name for the directory
                                    entry.
    RecoverAlloc                - Supplies whether or not to recover all
                                    allocated space on the volume.
    Report                      - Supplies the fat chkdsk report structures for storing the
                                    actions performed by this method.
    Message                     - Supplies an outlet for messages.
    NeedErrorsMessage           - Supplies whether or not an error has
                                    occurred during check only mode.
    FatBitMap                   - Supplies a bitmap marking in use all known
                                    clusters.
    CrossLinkDetected           - Returns TRUE if the file is cross-linked with
                                   another.
    CrossLinkPreviousCluster    - Returns the cluster previous to the
                                    cross-linked one.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   start_clus;
    BOOLEAN changes;
    ULONG   length;
    ULONG   max_file_size;
    ULONG   min_file_size;
    ULONG   clus;
    BIG_INT tmp_big_int;
    ULONG   file_size;
    ULONG   cluster_size;
    BOOLEAN recover_status;
    ULONG   errFixedStatus = CHKDSK_EXIT_SUCCESS;
    BOOLEAN minor_inconsistency_found = FALSE;

    DebugAssert(CrossLinkDetected);
    DebugAssert(CrossLinkPreviousCluster);

    *CrossLinkDetected = FALSE;

    if (Dirent->IsErased()) {
        return TRUE;
    }

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    // Try to validate names that can be created under different languages

    if (!Dirent->IsValidName()) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_INVALID_NAME);
        Message->Display("%W", FilePath);
        Dirent->SetErased();
        return TRUE;
    }

    if (!Dirent->IsValidLastWriteTime()) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_INVALID_TIME_STAMP);
        Message->Display("%W", FilePath);
        if (!Dirent->SetLastWriteTime()) {
            return FALSE;
        }
    }

    if (!Dirent->IsVolumeLabel()) {
        if (!Dirent->IsValidCreationTime()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_INVALID_TIME_STAMP);
            Message->Display("%W", FilePath);
            if (!Dirent->SetCreationTime()) {
                return FALSE;
            }
        }

        if (!Dirent->IsValidLastAccessTime()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_INVALID_TIME_STAMP);
            Message->Display("%W", FilePath);
            if (!Dirent->SetLastAccessTime()) {
                return FALSE;
            }
        }
    }

    if (Dirent->IsDirectory() && Dirent->QueryFileSize()) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_DIR_HAS_FILESIZE);
        Message->Display("%W", FilePath);
        Dirent->SetFileSize( 0 );
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    if ((start_clus = Dirent->QueryStartingCluster()) != 0 ) {
        if (!_fat->IsInRange(start_clus) || _fat->IsClusterFree(start_clus)) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_FIRST_UNIT);
            Message->Display("%W", FilePath);

            Dirent->SetErased();
            UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
            return TRUE;
        }

        _fat->ScrubChain(start_clus, FatBitMap, &changes,
                         CrossLinkDetected, CrossLinkPreviousCluster);

        if (changes) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_LINK);
            Message->Display("%W", FilePath);
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (Dirent->IsDirectory() || RecoverAlloc) {

            //
            // Validate the readability of the directory or file
            // in the case that 'RecoverAlloc' is TRUE.
            //
            if (Dirent->IsDirectory()) {
                if (!(recover_status = RecoverChain(&start_clus, &changes, 0, FALSE, FatBitMap))) {
                   Message->Set(MSG_CHK_NO_MEMORY);
                   Message->Display();
                   return FALSE;
                }
            } else if (FixLevel != CheckOnly) {

               // t-raymak: If we check the recover status for directory, why shouldn't we check
               // the recover status for file also? (I added the following check.)
               if (!(recover_status = RecoverChain(&start_clus, &changes, 0, TRUE, FatBitMap))) {
                   Message->Set(MSG_CHK_NO_MEMORY);
                   Message->Display();
                   return FALSE;
               }
            } else {
                recover_status = TRUE;
                changes = FALSE;
            }

            if (changes) {
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                dofmsg(Message, NeedErrorsMessage);
                if (Dirent->IsDirectory()) {
                    if (!start_clus) {
                        Message->Set(MSG_CHK_BAD_DIR);
                        Message->Display("%W", FilePath);
                        Dirent->SetErased();
                        UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);
                        return TRUE;
                    } else {
                        Message->Set(MSG_CHK_BAD_CLUSTERS_IN_DIR);
                        Message->Display("%W", FilePath);
                        Dirent->SetStartingCluster(start_clus);
                    }
                } else {
                    // In the file case, since we're replacing bad clusters
                    // with new ones, start_clus cannot be zero.
                    DebugAssert(start_clus);

                    if (recover_status) {
                        Message->Set(MSG_CHK_BAD_CLUSTERS_IN_FILE_SUCCESS);
                        Message->Display("%W", FilePath);
                    } else {
                        Message->Set(MSG_CHK_BAD_CLUSTERS_IN_FILE_FAILURE);
                        Message->Display();
                    }
                    Dirent->SetStartingCluster(start_clus);
                }
            }
        }

        // Note here that we know here that start_clus != 0 so length will be
        // at least 1.

        tmp_big_int = length = _fat->QueryLengthOfChain(start_clus);

        tmp_big_int = tmp_big_int * cluster_size;

        if (tmp_big_int.GetHighPart()) {
            if ((tmp_big_int.GetHighPart() != 1) || tmp_big_int.GetLowPart()) {
                //
                // Cluster chain is > 4GB in size, error. Max allowed is 4GB worth
                // of clusters. Note that since cluster size is a power of 2 (since
                // sec/clus and sector_size are both powers of 2) we KNOW that cluster_size
                // evenly divides 4GB.
                //
                clus = start_clus;
                tmp_big_int = cluster_size;
                while(tmp_big_int.GetHighPart() == 0) {
                    clus = _fat->QueryEntry(clus);
                    tmp_big_int += cluster_size;
                }
                _fat->SetEndOfChain(clus);

                // This message is not exactly correct, but saying that the file size
                // is messed up is not totally unreasonable..........

                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_BAD_FILE_SIZE);
                Message->Display("%W", FilePath);
                Dirent->SetFileSize(0xFFFFFFFF);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
            max_file_size = 0xFFFFFFFF;
            min_file_size = (0xFFFFFFFF - cluster_size) + 2;
        } else {
            max_file_size = tmp_big_int.GetLowPart();
            min_file_size = (max_file_size - cluster_size) + 1;
        }

        if (( file_size = Dirent->QueryFileSize()) != 0 ) {
            if (file_size > max_file_size ||
                file_size < min_file_size) {

                if (file_size > max_file_size) {
                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_BAD_FILE_SIZE);
                    Message->Display("%W", FilePath);
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                }

                if (file_size < min_file_size) {

                    minor_inconsistency_found = TRUE;

                    WCHAR   fpath[MAX_PATH];

                    if (!FilePath->QueryWSTR(0, TO_END, fpath, MAX_PATH, TRUE)) {
                        fpath[0] = '?';
                        fpath[1] = 0;
                    }

                    DebugPrintTrace(("UFAT: %ls of size %x should be within %x and %x bytes.\n",
                                     fpath, file_size, min_file_size, max_file_size));
                }

                Dirent->SetFileSize(max_file_size);
            }
        } else {
            if (!Dirent->IsDirectory()) {
                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_BAD_FILE_SIZE);
                Message->Display("%W", FilePath);
                Dirent->SetFileSize(max_file_size);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }
    } else {
        if (Dirent->IsDirectory() && !Dirent->IsDotDot()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_LINK);
            Message->Display("%W", FilePath);
            Dirent->SetErased();
            UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
            return TRUE;
        }

        if (Dirent->QueryFileSize()) {
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_BAD_FILE_SIZE);
            Message->Display("%W", FilePath);
            Dirent->SetFileSize(0);
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    if (minor_inconsistency_found &&
        Report->ExitStatus == CHKDSK_EXIT_SUCCESS) {
        Report->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
        if (_Verbose) {
            Message->Set((FixLevel == CheckOnly) ?
                            MSG_CHK_MINOR_ERRORS_DETECTED :
                            MSG_CHK_MINOR_ERRORS_FIXED);
            Message->Display();
        }
    }

    return TRUE;
}


BOOLEAN
FAT_SA::EraseEaHandle(
    IN      PEA_INFO    EaInfos,
    IN      USHORT      NumEasLeft,
    IN      USHORT      NumEas,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine erases the EA handle that references ea set beyond the
    number of ea sets that should be left.

Arguments:

    EaInfos             - Supplies the list of current EA information.
    NumEasLeft          - Supplies the number of EA sets that should be in EaInfos.
    NumEas              - Supplies the total number of EA sets.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM        hmem;
    FILEDIR     filedir;
    FAT_DIRENT  other_dirent;
    USHORT      i;

    for (i=NumEasLeft; i<NumEas; i++) {
        if (EaInfos[i].UserFileEntryCn) {
            if (!hmem.Initialize() ||
                !filedir.Initialize(&hmem, _drive, this, _fat,
                                    EaInfos[i].UserFileEntryCn) ||
                !filedir.Read() ||
                !other_dirent.Initialize(filedir.GetDirEntry(
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }
        } else {
            if (!other_dirent.Initialize(_dir->GetDirEntry(
            // Default _dir works because FAT 32 won't have EA's on it to validate
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                return FALSE;
            }
        }

        //
        // Do not follow an EA link to an LFN entry. Zeroing the EA handle in an LFN entry
        // destroys name data. The link is probably just invalid
        //
        if (!other_dirent.IsLongNameEntry()) {

            other_dirent.SetEaHandle(0);

            if (EaInfos[i].UserFileEntryCn && FixLevel != CheckOnly &&
                !filedir.Write()) {
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOLEAN
FAT_SA::ValidateEaHandle(
    IN OUT  PFAT_DIRENT     Dirent,
    IN      ULONG           DirClusterNumber,
    IN      ULONG           DirEntryNumber,
    IN OUT  PEA_INFO        EaInfos,
    IN      USHORT          NumEas,
    IN      PCWSTRING       FilePath,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine validates the EA handle in the directory entry 'Dirent'.
    It ensures that it references an actual EA set.  It also ensures
    that it is the only directory entry which references the EA set.

    If several entries try to reference the same EA set then ties will
    be broken based on the 'OwnerFileName' entry in the EA set.

Arguments:

    Dirent              - Supplies the directory entry to validate.
    DirClusterNumber    - Supplies the cluster number of the directory
                          containing the dirent.
    DirEntryNumber      - Supplies the position of the directory entry in
                          the directory.
    EaInfos             - Supplies the list of current EA information.
    NumEas              - Supplies the number of EA sets.
    FilePath            - Supplies the full path name for the directory entry.
    FixLevel            - Supplies the fix up level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occurred
                          during check only mode.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    USHORT      handle;
    DSTRING     wfilename;
    STR         filename[14];
    BOOLEAN     remove_other_handle;
    HMEM        hmem;
    FILEDIR     filedir;
    FAT_DIRENT  other_dirent;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;


    if (!(handle = Dirent->QueryEaHandle())) {
        return TRUE;
    }
    // The above should exclude any FAT 32 drive.

    if (!EaInfos) {
        NumEas = 0;
    }

    for (i = 0; i < NumEas; i++) {
        if (handle == EaInfos[i].OwnHandle) {
            break;
        }
    }

    if (i == NumEas) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_UNRECOG_EA_HANDLE);
        Message->Display("%W", FilePath);
        Dirent->SetEaHandle(0);
        UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
        return TRUE;
    }

    if (EaInfos[i].UsedCount >= 2) {
        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_SHARED_EA);
        Message->Display("%W", FilePath);
        Dirent->SetEaHandle(0);
        UPDATE_EXIT_STATUS_FIXED(CHKDSK_EXIT_ERRS_FIXED, Report);
        return TRUE;
    }

    Dirent->QueryName(&wfilename);
    if (!wfilename.QuerySTR( 0, TO_END, filename, 14)) {
        return FALSE;
    }

    if (EaInfos[i].UsedCount == 0) {
        memcpy(EaInfos[i].UserFileName, filename, 14);
        EaInfos[i].UserFileEntryCn = DirClusterNumber;
        EaInfos[i].UserFileEntryNumber = DirEntryNumber;
        EaInfos[i].UsedCount = 1;
        return TRUE;
    }


    // UsedCount == 1.

    remove_other_handle = FALSE;

    if (!strcmp(filename, EaInfos[i].OwnerFileName)) {

        remove_other_handle = TRUE;

        if (!strcmp(EaInfos[i].UserFileName,
                    EaInfos[i].OwnerFileName)) {

            EaInfos[i].UsedCount = 2;
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_SHARED_EA);
            Message->Display("%W", FilePath);
            Dirent->SetEaHandle(0);
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

    } else {

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_SHARED_EA);
        Message->Display("%W", FilePath);
        Dirent->SetEaHandle(0);
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (strcmp(EaInfos[i].UserFileName,
                   EaInfos[i].OwnerFileName)) {

            EaInfos[i].UsedCount = 2;
            remove_other_handle = TRUE;
        }
    }


    if (remove_other_handle) {

        if (EaInfos[i].UserFileEntryCn) {
            if (!hmem.Initialize() ||
                !filedir.Initialize(&hmem, _drive, this, _fat,
                                    EaInfos[i].UserFileEntryCn) ||
                !filedir.Read() ||
                !other_dirent.Initialize(filedir.GetDirEntry(
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }
        } else {
            if (!other_dirent.Initialize(_dir->GetDirEntry(
                // Default _dir works because FAT 32 won't have EA's on it to validate
                                         EaInfos[i].UserFileEntryNumber), FAT_TYPE_EAS_OKAY)) {

                return FALSE;
            }
        }

        dofmsg(Message, NeedErrorsMessage);
        Message->Set(MSG_CHK_SHARED_EA);
        Message->Display("%W", FilePath);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        //
        // Do not follow an EA link to an LFN entry. Zeroing the EA handle in an LFN entry
        // destroys name data. The link is probably just invalid
        //
        if (!other_dirent.IsLongNameEntry()) {
            other_dirent.SetEaHandle(0);

            if (EaInfos[i].UserFileEntryCn && FixLevel != CheckOnly &&
                !filedir.Write()) {

                return FALSE;
            }
        }
        strcpy(EaInfos[i].UserFileName, filename);
        EaInfos[i].UserFileEntryCn = DirClusterNumber;
        EaInfos[i].UserFileEntryNumber = DirEntryNumber;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}


BOOLEAN
FAT_SA::CopyClusters(
    IN      ULONG       SourceChain,
    OUT     PULONG      DestChain,
    IN OUT  PBITVECTOR  FatBitMap,
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine copies the cluster chain beginning at 'SourceChain'
    to a free portion of the disk.  The beginning of the copied chain
    will be returned in 'DestChain'.  If there isn't enough free space
    on the disk to copy the chain then 'DestChain' will return 0.

Arguments:

    SourceChain - Supplies the chain to copy.
    DestChain   - Returns the copy of the chain.
    FatBitMap   - Supplies the orphan and cross-link bitmap.
    FixLevel    - Supplies the CHKDSK fix level.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM            hmem;
    CLUSTER_CHAIN   cluster;
    ULONG           src, dst;
    BOOLEAN         changes;
    ULONG           clus;

    if (!hmem.Initialize()) {
        return FALSE;
    }

    if (!(*DestChain = _fat->AllocChain(
                       _fat->QueryLengthOfChain(SourceChain)))) {
        return TRUE;
    }

    changes = FALSE;
    if (FixLevel != CheckOnly && !RecoverChain(DestChain, &changes, 0, TRUE)) {
        if (*DestChain) {
            _fat->FreeChain(*DestChain);
        }
        *DestChain = 0;
        return TRUE;
    }

    if (IsCompressed() && !AllocSectorsForChain(*DestChain)) {
        _fat->FreeChain(*DestChain);
        *DestChain = 0;
        return TRUE;
    }

    // Mark the new chain as "used" in the FAT bitmap.
    for (clus = *DestChain;
         !_fat->IsEndOfChain(clus);
         clus = _fat->QueryEntry(clus)) {

        FatBitMap->SetBit(clus);
    }
    FatBitMap->SetBit(clus);

    src = SourceChain;
    dst = *DestChain;
    for (;;) {
        if (!cluster.Initialize(&hmem, _drive, this, _fat, src, 1)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        cluster.Read();

        if (!cluster.Initialize(&hmem, _drive, this, _fat, dst, 1)) {
            return FALSE;
        }

        if (FixLevel != CheckOnly && !cluster.Write()) {
            return FALSE;
        }

        if (_fat->IsEndOfChain(src)) {
            break;
        }

        src = _fat->QueryEntry(src);
        dst = _fat->QueryEntry(dst);
    }

    return TRUE;
}


BOOLEAN
FAT_SA::PurgeEaFile(
    IN      PEA_INFO        EaInfos,
    IN      USHORT          NumEas,
    IN OUT  PBITVECTOR      FatBitMap,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message,
    IN OUT  PBOOLEAN        NeedErrorsMessage
    )
/*++

Routine Description:

    This routine is executed after the directory tree is walked.  Stored,
    in the EaInfos array, is information concerning which EAs get used
    and by how many files.

    If an EA set is not used, or is used by more than one file, then this
    routine will eliminate it from the EA file.

Arguments:

    EaInfos             - Supplies an array of EA information.
    NumEas              - Supplies the number of EA sets.
    FatBitMap           - Supplies the FAT cross-link detection bitmap.
    FixLevel            - Supplies the CHKDSK fix level.
    Report              - Supplies the fat chkdsk report structures for storing the
                          actions performed by this method.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occured
                          in check only mode.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG        i;
    EA_SET      easet;
    HMEM        hmem;
    PEA_HDR     eahdr;
    ULONG       clus;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    if (!hmem.Initialize()) {
        return FALSE;
    }

    for (i = NumEas - 1; i >= 0; i--) {

        if (EaInfos[i].UsedCount != 1) {
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_UNUSED_EA_SET);
            Message->Display("%d", EaInfos[i].OwnHandle);

            // Mark the FAT entries of the removed chain as "not claimed",
            // for the purposes of orphan recovery.

            for (clus = _fat->QueryEntry(EaInfos[i].PreceedingCn);
                 clus != EaInfos[i].LastCn;
                 clus = _fat->QueryEntry(clus)) {

                FatBitMap->ResetBit(clus);

            }
            FatBitMap->ResetBit(clus);


            //
            // Remove the unused EA chain from the EA file.  Here we also
            // have to examine subsequent EaInfos; we may have to modify
            // several PreceedingCn entries if several adjacent EA chains
            // have been removed.
            //

            _fat->RemoveChain(EaInfos[i].PreceedingCn,
                              EaInfos[i].LastCn);

            for (LONG j = i + 2; j < NumEas; j++) {
                if (EaInfos[j].PreceedingCn == EaInfos[i + 1].PreceedingCn) {

                    EaInfos[j].PreceedingCn = EaInfos[i].PreceedingCn;

                } else {
                    break;
                }
            }

            EaInfos[i + 1].PreceedingCn = EaInfos[i].PreceedingCn;

        } else if (strcmp(EaInfos[i].OwnerFileName,
                          EaInfos[i].UserFileName)) {

            if (!easet.Initialize(&hmem, _drive, this, _fat,
                                  _fat->QueryEntry(EaInfos[i].PreceedingCn),
                                  1) ||
                !easet.Read() ||
                !(eahdr = easet.GetEaSetHeader())) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                return FALSE;
            }

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            dofmsg(Message, NeedErrorsMessage);
            Message->Set(MSG_CHK_NEW_OWNER_NAME);
            Message->Display("%d%s%s", EaInfos[i].OwnHandle,
                    eahdr->OwnerFileName, EaInfos[i].UserFileName);

            memcpy(eahdr->OwnerFileName, EaInfos[i].UserFileName, 14);

            if (FixLevel != CheckOnly && !easet.Write()) {
                return FALSE;
            }
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}

BOOLEAN
FAT_SA::RecoverOrphans(
    IN OUT  PBITVECTOR     FatBitMap,
    IN      FIX_LEVEL      FixLevel,
    IN OUT  PMESSAGE       Message,
    IN OUT  PBOOLEAN       NeedErrorsMessage,
    IN OUT  PFATCHK_REPORT Report
    )
/*++

Routine Description:

    This routine examines the file system for cluster chains which are
    not claimed by any file.  These 'orphans' will then be recovered in
    a subdirectory of the root or removed from the system.

Arguments:

    FatBitMap           - Supplies a bit map marking all currently used
                            clusters.
    FixLevel            - Supplies the CHKDSK fix level.
    Message             - Supplies an outlet for messages.
    NeedErrorsMessage   - Supplies whether or not an error has occured
                            in check only mode.
    Report              - Supplies the fat chkdsk report structures for storing the
                            actions performed by this method.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    //
    // Why the below define placing an artificial limit on the number of orphans?
    // 1.) The format for the file names is "FILE%04d.CHK" starting at 0 so we can
    //     do only 0-9999 before generating a duplicate file name.
    // 2.) Since CHKDSK recovers all of the orphans into a single directory this prevents
    //     it from making a directory with a HUGE file count in it (which is a performance
    //     issue).
    //
    // There used to be a smaller limit on how many orphan files can be recovered in
    // autochk mode.  The limit was 1000 but AaronR found no truth to that anymore
    // and so the limit is changed to be the same as that in chkdsk which is 10000.
    // -DanielCh 3/7/2000
    //

    CONST ULONG maximum_orphans = 10000;

    ULONG       i;
    ULONG       clus;
    BOOLEAN     changes;
    HMEM        hmem;
    FILEDIR     found_dir;
    STR         found_name[14];
    DSTRING     wfound_name;
    STR         filename[14];
    FAT_DIRENT  dirent;
    ULONG       found_cluster;
    ULONG       orphan_count;
    ULONG       orphan_rec_clus_cnt;
    ULONG       cluster_size;
    ULONG       found_length;
    ULONG       next;
    PUCHAR      orphan_track;
    ULONG       cluster_count;
    ULONG       num_orphans;
    ULONG       num_orphan_clusters;
    DSTRING     tmp_string;
    BITVECTOR   tmp_bitvector;
    BOOLEAN     tmp_bool;
    ULONG       tmp_ulong;
    BIG_INT     tmp_big_int;
    MSGID       message_id;
    BOOLEAN     KSize;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    PFATDIR     _fat_dir;
    UCHAR       FatType;
    PVOID       p;
    ULONG       length;
    ULONG       starting_cluster;
    ULONG       num_of_entries;


    cluster_count = QueryClusterCount();

    if (!(orphan_track = NEW UCHAR[cluster_count])) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    memset(orphan_track, 0, cluster_count);

    if (!tmp_bitvector.Initialize(cluster_count)) {
        DELETE(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    cluster_size = _drive->QuerySectorSize()*QuerySectorsPerCluster();

    num_orphans = 0;
    num_orphan_clusters = 0;
    for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
        if (!_fat->IsClusterFree(i) &&
            !FatBitMap->IsBitSet(i) &&
            !_fat->IsClusterBad(i) &&
            !_fat->IsClusterReserved(i)) {

            num_orphans++;

            tmp_bitvector.ResetAll();

            _fat->ScrubChain(i, &tmp_bitvector, &changes,
                             &tmp_bool, &tmp_ulong);

            if (changes) {
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                dofmsg(Message, NeedErrorsMessage);
                Message->Set(MSG_CHK_BAD_LINKS_IN_ORPHANS);
                Message->Display("%d", i);
            }

            num_orphan_clusters++;

            clus = i;
            while (!_fat->IsEndOfChain(clus)) {
                next = _fat->QueryEntry(clus);

                if (orphan_track[next] == 1) {
                    num_orphans--;
                    orphan_track[next] = 2;
                    break;
                }

                if (FatBitMap->IsBitSet(next)) {   // CROSSLINK !!

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                    dofmsg(Message, NeedErrorsMessage);
                    Message->Set(MSG_CHK_CROSS_LINKED_ORPHAN);
                    Message->Display("%d", clus);

                    _fat->SetEndOfChain(clus);

                    break;
                }

                num_orphan_clusters++;

                FatBitMap->SetBit(next);
                orphan_track[next] = 2;

                clus = next;
            }
            FatBitMap->SetBit(i);
            orphan_track[i] = 1;
        }
    }


    // Now scan through the secondary pointers in search of orphans.

    changes = FALSE;
    for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
        if (orphan_track[i]) {
            changes = TRUE;
            break;
        }
    }

    if (!changes) {
        // No orphans to recover.
        DELETE(orphan_track);
        return TRUE;
    }

    // Compute whether reporting size in bytes or kilobytes
    //
    // NOTE: The magic number 4095MB comes from Win9x's GUI SCANDISK utility
    //
    tmp_ulong = cluster_count - FirstDiskCluster;
    tmp_big_int = cluster_size;
    tmp_big_int = tmp_big_int * tmp_ulong;
    if (tmp_big_int.GetHighPart() || (tmp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
        KSize = TRUE;
    } else {
        KSize = FALSE;
    }

    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    dofmsg(Message, NeedErrorsMessage);
    Message->Set(MSG_CONVERT_LOST_CHAINS, NORMAL_MESSAGE, TEXT_MESSAGE);
    Message->Display();

    if (!Message->IsYesResponse(TRUE)) {

        if (FixLevel != CheckOnly) {

            for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
                if (orphan_track[i] == 1) {
                    _fat->FreeChain(i);
                }
            }
            if (KSize) {
                message_id = MSG_KILOBYTES_FREED;
            } else {
                message_id = MSG_BYTES_FREED;
            }
        } else {
            if (KSize) {
                message_id = MSG_KILOBYTES_WOULD_BE_FREED;
            } else {
                message_id = MSG_BYTES_WOULD_BE_FREED;
            }
        }

        tmp_big_int = cluster_size;
        tmp_big_int = tmp_big_int * num_orphan_clusters;
        if (KSize) {
            tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
        } else {
            tmp_ulong = tmp_big_int.GetLowPart();
        }
        Message->Set(message_id);
        Message->Display("%d", tmp_ulong);

        UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

        DELETE(orphan_track);
        return TRUE;
    }


    // Set up for orphan recovery.


    // Establish "FOUND.XXX" directory.
    for (i = 0; i < 1000; i++) {
        sprintf(found_name, "FOUND.%03d", i);
        if (!wfound_name.Initialize(found_name)) {

            DELETE(orphan_track);
            return FALSE;

        }

        if (_dir && !_dir->SearchForDirEntry(&wfound_name)) {

            break;

        } else if (_dirF32 && !_dirF32->SearchForDirEntry(&wfound_name)) {

            break;

        }


    }

    if (i == 1000) {

        tmp_big_int = cluster_size;
        tmp_big_int = tmp_big_int * num_orphan_clusters;
        if (KSize) {
            tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
        } else {
            tmp_ulong = tmp_big_int.GetLowPart();
            message_id = MSG_WOULD_BE_RECOVERED_FILES;
        }
        Message->Set(message_id);
        Message->Display("%d%d", tmp_ulong,
                                 num_orphans);
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE(orphan_track);
        return TRUE;
    }

    found_length = ((min(num_orphans,maximum_orphans)*BytesPerDirent - 1)/cluster_size + 1);

    if (!(found_cluster = _fat->AllocChain(found_length)) &&
        !(found_cluster = _fat->AllocChain(found_length = 1))) {

        Message->Set(MSG_ORPHAN_DISK_SPACE);
        Message->Display();
        tmp_big_int = cluster_size;
        tmp_big_int = tmp_big_int * num_orphan_clusters;
        if (KSize) {
            tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
            message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
        } else {
            tmp_ulong = tmp_big_int.GetLowPart();
            message_id = MSG_WOULD_BE_RECOVERED_FILES;
        }
        Message->Set(message_id);
        Message->Display("%d%d", tmp_ulong,
                                 num_orphans);
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE(orphan_track);
        return TRUE;
    }

    // Check the chain.
    changes = FALSE;
    if (FixLevel != CheckOnly &&
        !RecoverChain(&found_cluster, &changes, 0, TRUE)) {

        Message->Set(MSG_ORPHAN_DISK_SPACE);
        Message->Display();
        Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
        Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                 num_orphans);
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE(orphan_track);
        return TRUE;
    }

    if (!hmem.Initialize() ||
        !found_dir.Initialize(&hmem, _drive, this, _fat, found_cluster)) {

        DELETE(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        DebugAbort( "Initialization failed" );
        return FALSE;
    }

    // Allocate space for the cluster chain in the sector heap (fat_db)

    if (IsCompressed() && !AllocSectorsForChain(found_cluster)) {
        _fat->FreeChain(found_cluster);
        Message->Set(MSG_ORPHAN_DISK_SPACE);
        Message->Display();
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE(orphan_track);
        return TRUE;
    }

    memset(hmem.GetBuf(), 0, (UINT) hmem.QuerySize());

    if (_dir) {
       _fat_dir = _dir;
       FatType = FAT_TYPE_EAS_OKAY;
    }
    else {
       _fat_dir = _dirF32;
       FatType = FAT_TYPE_FAT32;
    }

    p = _fat_dir->GetFreeDirEntry();
    if (p == NULL && _dir == NULL)  {
        starting_cluster = _dirF32->QueryStartingCluster();
        length = _fat->QueryLengthOfChain(starting_cluster);
        num_of_entries = _dirF32->QueryNumberOfEntries();
        if (_fat->ReAllocChain(starting_cluster, ++length) != length ||
            (FixLevel != CheckOnly &&
             !RecoverChain(&starting_cluster, &changes, 0, TRUE))) {
            Message->Set(MSG_NO_ROOM_IN_ROOT);
            Message->Display();
            Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
            Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                     num_orphans);
            Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
            DELETE(orphan_track);
            return TRUE;
        }

        if (FixLevel != CheckOnly && !_dirF32->Write()) {
            DELETE(orphan_track);
            return FALSE;
        }

        if (!_hmem_F32->Initialize() ||
            !_dirF32->Initialize( _hmem_F32, _drive, this,
                                  _fat, starting_cluster) ||
            !_dirF32->Read()) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
            Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                     num_orphans);
            Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
            DELETE(orphan_track);
            return TRUE;
        }
        for (i = num_of_entries; dirent.Initialize(_dirF32->GetDirEntry(i),FatType); i++) {
            dirent.SetEndOfDirectory();
        }

        p = _fat_dir->GetFreeDirEntry();
    }

    if (!dirent.Initialize(p, FatType)) {
        Message->Set(MSG_NO_ROOM_IN_ROOT);
        Message->Display();
        Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
        Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                 num_orphans);
        Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        DELETE(orphan_track);
        return TRUE;
    }

    dirent.Clear();

    if (!dirent.SetName(&wfound_name)) {
        DELETE(orphan_track);
        return FALSE;
    }

    dirent.SetDirectory();
    dirent.SetHidden();
    dirent.SetSystem();

    if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
        !dirent.SetLastAccessTime()) {
        DELETE(orphan_track);
        return FALSE;
    }

    dirent.SetStartingCluster(found_cluster);

    if(_dirF32) {
        if (FixLevel != CheckOnly && !_dirF32->Write()) {
            DELETE(orphan_track);
            return FALSE;
        }
    }


    if (!dirent.Initialize(found_dir.GetDirEntry(0),FatType)) {
        DELETE(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    dirent.Clear();

    if (!tmp_string.Initialize(".")) {
        DELETE(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!dirent.SetName(&tmp_string)) {
        DELETE(orphan_track);
        return FALSE;
    }

    dirent.SetDirectory();

    if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
        !dirent.SetLastAccessTime()) {
        DELETE(orphan_track);
        return FALSE;
    }

    dirent.SetStartingCluster(found_cluster);

    if (!dirent.Initialize(found_dir.GetDirEntry(1),FatType)) {
        DELETE(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    dirent.Clear();

    if (!tmp_string.Initialize("..")) {
        DELETE(orphan_track);
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display();
        return FALSE;
    }

    if (!dirent.SetName(&tmp_string)) {
        DELETE(orphan_track);
        return FALSE;
    }

    dirent.SetDirectory();

    if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
        !dirent.SetLastAccessTime()) {
        DELETE(orphan_track);
        return FALSE;
    }

    dirent.SetStartingCluster(0);


    // OK, now let's recover those orphans.

    orphan_rec_clus_cnt = orphan_count = 0;
    for (i = FirstDiskCluster; _fat->IsInRange(i); i++) {
        if (orphan_track[i] != 1) {
            continue;
        }
        if (orphan_count == maximum_orphans) {
            Message->Set(MSG_TOO_MANY_ORPHANS);
            Message->Display();
            Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
            break;
        }

        if (!dirent.Initialize(found_dir.GetFreeDirEntry(), FatType)) {
            if (_fat->ReAllocChain(found_cluster, ++found_length)
                    != found_length)  {
                Message->Set(MSG_ORPHAN_DISK_SPACE);
                Message->Display();
                tmp_big_int = cluster_size;
                tmp_big_int = tmp_big_int * num_orphan_clusters;
                if (KSize) {
                    tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
                    message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
                } else {
                    tmp_ulong = tmp_big_int.GetLowPart();
                    message_id = MSG_WOULD_BE_RECOVERED_FILES;
                }
                Message->Set(message_id);
                Message->Display("%d%d", tmp_ulong,
                                         num_orphans);
                Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                break;
            }

//XXX.mjb: FATDB: need to get sectors for found_cluster + realloc.

            changes = FALSE;
            if (FixLevel != CheckOnly &&
                !RecoverChain(&found_cluster, &changes, 0, TRUE)) {

                Message->Set(MSG_ORPHAN_DISK_SPACE);
                Message->Display();
                tmp_big_int = cluster_size;
                tmp_big_int = tmp_big_int * num_orphan_clusters;
                if (KSize) {
                    tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
                    message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
                } else {
                    tmp_ulong = tmp_big_int.GetLowPart();
                    message_id = MSG_WOULD_BE_RECOVERED_FILES;
                }
                Message->Set(message_id);
                Message->Display("%d%d", tmp_ulong,
                                         num_orphans);
                Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                DELETE(orphan_track);
                return TRUE;
            }

            if (FixLevel != CheckOnly && !found_dir.Write()) {
                DELETE(orphan_track);
                return FALSE;
            }

            if (!hmem.Initialize() ||
                !found_dir.Initialize(&hmem, _drive, this, _fat,
                                      found_cluster) ||
                !found_dir.Read()) {
                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                Message->Set(MSG_WOULD_BE_RECOVERED_FILES);
                Message->Display("%d%d", cluster_size*num_orphan_clusters,
                                         num_orphans);
                Report->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                DELETE(orphan_track);
                return TRUE;
            }

            if (!dirent.Initialize(found_dir.GetDirEntry(2 + orphan_count), FatType)) {
                DELETE(orphan_track);
                return FALSE;
            }

            dirent.SetEndOfDirectory();

            if (!dirent.Initialize(found_dir.GetFreeDirEntry(),FatType)) {
                DELETE(orphan_track);
                return FALSE;
            }
        }

        sprintf(filename, "FILE%04d.CHK", orphan_count);

        if (!tmp_string.Initialize(filename)) {
            DELETE(orphan_track);
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        dirent.Clear();

        if (!dirent.SetName(&tmp_string)) {
            DELETE(orphan_track);
            return FALSE;
        }

        if (!dirent.SetLastWriteTime() || !dirent.SetCreationTime() ||
            !dirent.SetLastAccessTime()) {
            DELETE(orphan_track);
            return FALSE;
        }

        dirent.SetStartingCluster(i);
        dirent.SetFileSize(cluster_size*_fat->QueryLengthOfChain(i));

        orphan_count++;
        orphan_rec_clus_cnt += _fat->QueryLengthOfChain(i);
    }

    // Set all dirents past the orphan count to end of directory.

    for (i = 2 + orphan_count; dirent.Initialize(found_dir.GetDirEntry(i),FatType); i++)
    {
        dirent.SetEndOfDirectory();
    }

    if (FixLevel != CheckOnly && !found_dir.Write()) {
        DELETE(orphan_track);
        return FALSE;
    }

    if(FixLevel == CheckOnly) {
        if (KSize) {
            message_id = MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES;
        } else {
            message_id = MSG_WOULD_BE_RECOVERED_FILES;
        }
    } else {
        if (KSize) {
            message_id = MSG_KILOBYTES_IN_RECOVERED_FILES;
        } else {
            message_id = MSG_RECOVERED_FILES;
        }

        // Add the recovered data to the report totals

        Report->FileClusters += orphan_rec_clus_cnt;
        Report->FileEntriesCount += orphan_count;
        Report->DirClusters += found_length;
        Report->DirEntriesCount++;
    }
    tmp_big_int = cluster_size;
    tmp_big_int = tmp_big_int * num_orphan_clusters;
    if (KSize) {
        tmp_ulong = (tmp_big_int / 1024ul).GetLowPart();
    } else {
        tmp_ulong = tmp_big_int.GetLowPart();
    }
    Message->Set(message_id);

    Message->Display("%d%d", tmp_ulong,
                             num_orphans);

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    DELETE(orphan_track);
    return TRUE;
}


BOOLEAN
FAT_SA::AllocSectorsForChain(
    ULONG ChainHead
    )
/*++

Routine Description:

    When VerifyAndFix needs to allocate a cluster chain in order
    to create a new directory (such as \FOUND.000), it also needs to
    allocate space in the sector heap for data blocks for those
    clusters.  This routine does that.

Arguments:

    ChainHead - a cluster chain; data blocks are allocated for each
                cluster in this chain.

Return Value:

    TRUE  -   Success.
    FALSE -   Failure - not enough disk space

--*/
{
    ULONG   clus;
    ULONG   next;

    clus = ChainHead;
    for (;;) {
        if (!AllocateClusterData(clus,
                                 (UCHAR)QuerySectorsPerCluster(),
                                 FALSE,
                                 (UCHAR)QuerySectorsPerCluster())) {
            break;
        }

        if (_fat->IsEndOfChain(clus)) {
            return TRUE;
        }

        clus = _fat->QueryEntry(clus);
    }

    // Error: not enough disk space. XXX.mjb

    // Free the sectors we already allocated

    while (ChainHead != clus) {
        FreeClusterData(ChainHead);
        next = _fat->QueryEntry(ChainHead);
        _fat->SetClusterFree(ChainHead);
        ChainHead = next;
    }

    return FALSE;
}

#if defined( _SETUP_LOADER_ )

BOOLEAN
FAT_SA::RecoverFreeSpace(
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message
    )
{
    return TRUE;
}

#else // _SETUP_LOADER_ not defined

BOOLEAN
FAT_SA::RecoverFreeSpace(
    IN OUT  PFATCHK_REPORT  Report,
    IN OUT  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine checks all of the space marked free in the FAT for
    bad clusters.  If any clusters are bad they are marked bad in the
    FAT.

Arguments:

    Report    - Supplies the fat chkdsk report structures for storing the
                actions performed by this method.
    Message   - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       clus, length, max_length;
    ULONG       start_sector, num_sectors, i;
    NUMBER_SET  bad_sectors;
    LBN         lbn;
    ULONG       percent_complete;
    ULONG       num_checked, total_to_check;
    ULONG       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    Message->Set(MSG_CHK_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);
    Message->Display();

    _pvfMessage = Message;
    percent_complete = 0;
    if(!DisplayTwnkPercent(percent_complete)) {
        _pvfMessage = NULL;
        return FALSE;
    }

    num_checked = 0;
    total_to_check = _fat->QueryFreeClusters();
    max_length = QueryClusterCount()/20 + 1;
    for (clus = FirstDiskCluster; _fat->IsInRange(clus); clus++) {

        for (length = 0; _fat->IsInRange(clus + length) &&
                         _fat->IsClusterFree(clus + length) &&
                         length < max_length; length++) {
        }

        if (length) {

            start_sector = QueryStartDataLbn() +
                           (clus - FirstDiskCluster)*QuerySectorsPerCluster();
            num_sectors = length*QuerySectorsPerCluster();

            if (!bad_sectors.Initialize() ||
                !_drive->Verify(start_sector, num_sectors, &bad_sectors)) {

                Message->Set(MSG_CHK_NO_MEMORY);
                Message->Display();
                _pvfMessage = NULL;
                return FALSE;
            }

            if (bad_sectors.QueryCardinality() != 0)
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            for (i = 0; i < bad_sectors.QueryCardinality(); i++) {
                lbn = bad_sectors.QueryNumber(i).GetLowPart();
                _fat->SetClusterBad(((lbn - QueryStartDataLbn())/
                                    QuerySectorsPerCluster()) +
                                    FirstDiskCluster );
            }

            clus += length - 1;
            num_checked += length;

            if (100*num_checked/total_to_check > percent_complete) {
                percent_complete = 100*num_checked/total_to_check;
            }
            if (!DisplayTwnkPercent(percent_complete)) {
                _pvfMessage = NULL;
                return FALSE;
            }
        }
    }

    percent_complete = 100;
    if(!DisplayTwnkPercent(percent_complete)) {
        _pvfMessage = NULL;
        return FALSE;
    }

    if (errFixedStatus == CHKDSK_EXIT_ERRS_FIXED) {
        Message->Set(MSG_CHK_BAD_SECTORS_FOUND);
        Message->Display();
    }

    Message->Set(MSG_CHK_DONE_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);
    Message->Display();

    _pvfMessage = NULL;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, Report);

    return TRUE;
}

#endif // _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\fatsa.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    fatsa.cxx

Author:

    Mark Shavlik (marks) 27-Mar-90
    Norbert Kusters (norbertk) 15-Jan-91

Environment:

        ULIB, User Mode

--*/

#include "pch.cxx"

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "cmem.hxx"
#include "rtmsg.h"
#include "drive.hxx"
#include "bootfat.h"
#include "bootf32.h"
#include "boot98f.h"
#include "boot98f2.h"
extern "C" {
#include <parttype.h>
}
#if !defined(_AUTOCHECK_) && !defined(_SETUP_LOADER_)
#include "timeinfo.hxx"
#endif


// Control-C handling is not necessary for autocheck.
#if !defined( _AUTOCHECK_ ) && !defined(_SETUP_LOADER_)

#include "keyboard.hxx"

#endif

#define CSEC_FAT32MEG                   65536
#define CSEC_FAT16BIT                   32680
#define CSEC_FAT32BIT                  (1024*1024)


#define MIN_CLUS_BIG    4085    // Minimum clusters for a big FAT.
#define MAX_CLUS_BIG    65525   // Maximum + 1 clusters for big FAT.

#define MIN_CLUS_FAT32  65536




DEFINE_EXPORTED_CONSTRUCTOR( FAT_SA, SUPERAREA, UFAT_EXPORT );

VOID
FAT_SA::Construct (
        )
/*++

Routine Description:

    Constructor for FAT_SA.

Arguments:

    None.

Return Value:

        None.

--*/
{
    _fat = NULL;
    _dir = NULL;
    _dirF32 = NULL;
    _hmem_F32 = NULL;

}


UFAT_EXPORT
FAT_SA::~FAT_SA(
    )
/*++

Routine Description:

    Destructor for FAT_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

BOOLEAN
FAT_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine runs through the clusters for the file described by
    'FileName' and takes out bad sectors.

Arguments:

    FullPathFileName    - Supplies a full path name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else // _SETUP_LOADER_


    HMEM        hmem;
    ULONG       clus;
    BOOLEAN     changes;
    PFATDIR     fatdir;
    BOOLEAN     need_delete;
    FAT_DIRENT  dirent;
    ULONG       old_file_size;
    ULONG       new_file_size;

    if ((clus = QueryFileStartingCluster(FullPathFileName,
                                         &hmem,
                                         &fatdir,
                                         &need_delete,
                                         &dirent)) == 1) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", FullPathFileName);
        return FALSE;
    }

    if (clus == 0xFFFFFFFF) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (clus == 0) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", FullPathFileName);
        return FALSE;
    }

    if (dirent.IsDirectory()) {
        old_file_size = _drive->QuerySectorSize()*
                        QuerySectorsPerCluster()*
                        _fat->QueryLengthOfChain(clus);
    } else {
        old_file_size = dirent.QueryFileSize();
    }

    if (!RecoverChain(&clus, &changes)) {
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (dirent.IsDirectory() || changes) {
        new_file_size = _drive->QuerySectorSize()*
                        QuerySectorsPerCluster()*
                        _fat->QueryLengthOfChain(clus);
    } else {
        new_file_size = old_file_size;
    }

    if (changes) {


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ )

        // Disable contol-C handling and

        if (!KEYBOARD::EnableBreakHandling()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

#endif


        // Lock the drive in preparation for writes.

        if (!_drive->Lock()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

        dirent.SetStartingCluster(clus);

        dirent.SetFileSize(new_file_size);

        if (!fatdir->Write()) {
            return FALSE;
        }

        if (!Write(Message)) {
            return FALSE;
        }


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ )

        KEYBOARD::DisableBreakHandling();

#endif


    }

    Message->Set(MSG_RECOV_BYTES_RECOVERED);
    Message->Display("%d%d", new_file_size, old_file_size);


    if (need_delete) {
        DELETE(fatdir);
    }

    return TRUE;

#endif // _SETUP_LOADER_
}


SECTORCOUNT
FAT_SA::QueryFreeSectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number of unused sectors on disk.

Arguments:

    None.

Return Value:

    The number of free sectors on disk.

--*/
{
    if (!_fat) {
        DebugPrintTrace(("UFAT: Failure to QueryFreeSectors in FAT_SA\n"));
        return 0;
    }

    return _fat->QueryFreeClusters()*QuerySectorsPerCluster();
}


FATTYPE
FAT_SA::QueryFatType(
    ) CONST
/*++

Routine Description:

    This routine computes the FATTYPE of the FAT for this volume.

Arguments:

    None.

Return Value:

    The FATTYPE for the FAT.

--*/
{
    return _ft;
}



#if !defined( _AUTOCHECK_ ) && !defined(_SETUP_LOADER_)

BOOLEAN
FAT_SA::QueryLabel(
    OUT PWSTRING    Label
    ) CONST
/*++

Routine Description:

    This routine queries the label from the FAT superarea.
    If the label is not present then 'Label' will return the null-string.
    If the label is invalid then FALSE will be returned.

Arguments:

    Label   - Returns a volume label.

Return Value:

    FALSE   - The label is invalid.
    TRUE    - The label is valid.

--*/
{
    return QueryLabel(Label, NULL);
}


BOOLEAN
FAT_SA::QueryLabel(
    OUT PWSTRING    Label,
    OUT PTIMEINFO   TimeInfo
    ) CONST
/*++

Routine Description:

    This routine queries the label from the FAT superarea.
    If the label is not present then 'Label' will return the null-string.
    If the label is invalid then FALSE will be returned.

Arguments:

    Label   - Returns a volume label.

Return Value:

    FALSE   - The label is invalid.
    TRUE    - The label is valid.

--*/
{
    INT         i;
    FAT_DIRENT  dirent;
    FILETIME    TimeStamp;
    PFATDIR     _fat_dir;
    UCHAR       FatType;

    if (!_dirF32) {

        DebugAssert(_dir);
        _fat_dir = _dir;
        FatType = FAT_TYPE_EAS_OKAY;

    } else {

        _fat_dir = _dirF32;
        FatType = FAT_TYPE_FAT32;
    }

    for (i = 0; ; i++) {
        if (!dirent.Initialize(_fat_dir->GetDirEntry(i), FatType) ||
            dirent.IsEndOfDirectory()) {
            return Label->Initialize("");
        }

        if (!dirent.IsErased() && dirent.IsVolumeLabel()) {
            break;
        }
    }

    dirent.QueryName(Label);

    if ( TimeInfo ) {
        return ( dirent.QueryLastWriteTime( (LARGE_INTEGER *)&TimeStamp ) &&
                 TimeInfo->Initialize( &TimeStamp ) );
    }

    return TRUE;
}

#else // _AUTOCHECK_ or _SETUP_LOADER_ is defined

BOOLEAN
FAT_SA::QueryLabel(
    OUT PWSTRING    Label
    ) CONST
{
    INT         i;
    FAT_DIRENT  dirent;

    PFATDIR     _fat_dir;

    if (!_dirF32) {

        DebugAssert(_dir);
        _fat_dir = _dir;

    } else {

        _fat_dir = _dirF32;
    }

    for (i = 0; ; i++) {
        if (!dirent.Initialize(_fat_dir->GetDirEntry(i)) ||
            dirent.IsEndOfDirectory()) {
            return Label->Initialize("");
        }

        if (!dirent.IsErased() && dirent.IsVolumeLabel()) {
            break;
        }
    }

    dirent.QueryName(Label);

    return TRUE;
}


#endif // _AUTOCHECK_


BOOLEAN
FAT_SA::SetLabel(
    IN  PCWSTRING   NewLabel
    )
/*++

Routine Description:

    This routine sets the label for a FAT partition.

Arguments:

    NewLabel    - Supplies the new volume label.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FAT_DIRENT  dirent;
    INT         i;
    DSTRING     label;
    PFATDIR     _fat_dir;
    UCHAR       FatType;

    if (!_dir) {

        if (!_dirF32) {
            return FALSE;
        }

        _fat_dir = _dirF32;
        FatType = FAT_TYPE_FAT32;

    } else {
        _fat_dir = _dir;
        FatType = FAT_TYPE_EAS_OKAY;
    }

    if (!label.Initialize(NewLabel)) {
        return FALSE;
    }

    if (!label.Strupr()) {
        return FALSE;
    }

    if (!IsValidString(&label)) {
        return FALSE;
    }

    for (i = 0; dirent.Initialize(_fat_dir->GetDirEntry(i), FatType); i++) {

        if (dirent.IsEndOfDirectory()) {
            break;
        }

        if (dirent.IsErased()) {
            continue;
        }

        if (dirent.IsVolumeLabel()) {
            if (!label.QueryChCount()) {
                dirent.SetErased();
                return TRUE;
            }

            return (BOOLEAN) (dirent.SetLastWriteTime() &&
                              dirent.SetName(&label));
        }
    }

    if (!label.QueryChCount()) {
        return TRUE;
    }

    if (!dirent.Initialize(_fat_dir->GetFreeDirEntry(), FatType)) {
        return FALSE;
    }

    dirent.Clear();
    dirent.SetVolumeLabel();

    return (BOOLEAN) (dirent.SetLastWriteTime() && dirent.SetName(&label));
}


UFAT_EXPORT
ULONG
FAT_SA::QueryFileStartingCluster(
    IN  PCWSTRING   FullPathFileName,
    OUT PHMEM       Hmem,
    OUT PPFATDIR    Directory,
    OUT PBOOLEAN    DeleteDirectory,
    OUT PFAT_DIRENT DirEntry
    )
/*++

Routine Description:

    This routine computes the starting cluster number of the file described
    by 'FileName' by tracing through the directories leading to the file.

Arguments:

    FullPathFileName    - Supplies a full path file name that starts with
                            a '\' (i.e. no drive spec).

Return Value:

    The starting cluster for the file or 1 if the file is not found or
    0xFFFFFFFF if there was an error.

--*/
{
    CHNUM       i, j, l;
    DSTRING     component;
    ULONG       clus;
    FAT_DIRENT  the_dirent;
    PFILEDIR    filedir;
    PFAT_DIRENT dirent;
    HMEM        hmem;
    PFATDIR        _fat_dir;
    UCHAR        FatType;

    DebugAssert(_dir || _dirF32);

    if (_dir) {

        _fat_dir = _dir;
        FatType = FAT_TYPE_EAS_OKAY;

    } else {

        _fat_dir = _dirF32;
        FatType = FAT_TYPE_FAT32;
    }

    DebugAssert(_fat);

    filedir = NULL;

    if (!Hmem) {
        Hmem = &hmem;
    }

    if (DirEntry) {
        dirent = DirEntry;
    } else {
        dirent = &the_dirent;
    }

    l = FullPathFileName->QueryChCount();

    for (i = 0; i < l && FullPathFileName->QueryChAt(i) != '\\'; i++) {

        /* NOTHING */
    }

    if (i == l) {
        return 0xFFFFFFFF;
    }

    if (i == l - 1) { // root directory
        return 0;
    }

    j = ++i;
    for (; i < l && FullPathFileName->QueryChAt(i) != '\\'; i++) {
        /* NOTHING */
    }

    if (!component.Initialize(FullPathFileName, j, i - j) ||
        !component.Strupr()) {
        return 1;
    }

    if (!dirent->Initialize(_fat_dir->SearchForDirEntry(&component), FatType)) {
        return 1;
    }

    if (!(clus = dirent->QueryStartingCluster())) {
        return 0;
    }

    while (i < l) {

        if (!filedir &&
            !(filedir = NEW FILEDIR)) {
            return 0xFFFFFFFF;
        }

        if (!Hmem->Initialize() ||
            !filedir->Initialize(Hmem, _drive, this, _fat, clus)) {
            return 0xFFFFFFFF;
        }

        if (!filedir->Read()) {
            return 1;
        }

        j = ++i;
        for (; i < l && FullPathFileName->QueryChAt(i) != '\\'; i++) {
        }

        if (!component.Initialize(FullPathFileName, j, i - j) ||
            !component.Strupr()) {
            return 0xFFFFFFFF;
        }

        if (!dirent->Initialize(filedir->SearchForDirEntry(&component), FatType))
        {
            return 1;
        }

        if (!(clus = dirent->QueryStartingCluster())) {
            return 1;
        }
    }

    if (Directory) {
        if (filedir) {
            *Directory = filedir;
            if (DeleteDirectory) {
                *DeleteDirectory = TRUE;
            }
        } else {
            *Directory = _dir;
            if (DeleteDirectory) {
                *DeleteDirectory = FALSE;
            }
        }
    } else {
        DELETE(filedir);
    }

    return clus;
}


VOID
FAT_SA::Destroy(
    )
/*++

Routine Description:

    This routine cleans up the local data in the fat super area.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_fat);
    DELETE(_dir);
    DELETE(_dirF32);

}


FATTYPE
FAT_SA::ComputeFatType(
    ) CONST
/*++

Routine Description:

    Given the total number of clusters on the disk, this routine computes
    whether the FAT entries will be 12, 16, or 32 bits each.

Arguments:

    ClusterCount    - Supplies the number of clusters on the disk.

Return Value:

    SMALL   - A 12 bit FAT is required.
    LARGE16 - A 16 bit FAT is required.
    LARGE32 - A 32 bit FAT is required.
    
Note:

    THIS ROUTINE MAY NOT WORK IF PARTITION ID IS OEM TO START WITH.

--*/
{
    PARTITION_SYSTEM_ID id;

    id = ComputeSystemId();

    if (id == SYSID_FAT12BIT) {
        return(SMALL);
    } else if (id == SYSID_FAT32BIT) {
        return(LARGE32);
    } else {
        return(LARGE16);
    }
}


PARTITION_SYSTEM_ID
FAT_SA::ComputeSystemId(
    ) CONST
/*++

Routine Description:

    This routine computes the system id for a FAT file system with
    the given number of sectors.

Arguments:

    None.

Return Value:

    The correct system id for this partition.

--*/
{
    SECTORCOUNT           disk_size;
    PARTITION_SYSTEM_ID   partition_id;  // The partition id to be returned.
    GenPartitionClass     partition_class;
    NTSTATUS              status;        // Return status of RegeneratePartitionType.
    ULONG                 DoXInt13;

    switch (_drive->QueryMediaType()) {

        case F3_720_512:
        case F5_360_512:
        case F5_320_512:
        case F5_320_1024:
        case F5_180_512:
        case F5_160_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_720_512:
        case F5_640_512:
        case F3_640_512:
        case F3_1Pt2_512:
        case F8_256_128:
        case F5_1Pt23_1024:
        case F3_1Pt23_1024:
#endif
        case F5_1Pt2_512:
        case F3_1Pt44_512:
        case F3_2Pt88_512:
        case F3_20Pt8_512:
            return SYSID_FAT12BIT;

        case F3_120M_512:
        case F3_200Mb_512:
        case F3_240M_512:
            return SYSID_FAT16BIT;
    }

    disk_size = QueryVirtualSectors();

    if (_ft == INVALID_FATTYPE ) {

        //
        // If the _ft member is not initialized,
        // use the sector count to determine the
        // partition class. Note that this method of
        // determining the partition class is not absolutely
        // fool-proof but this method works at least as good
        // as what we have in the past. The proper way of doing
        // the system id computation is to make sure that
        // the fat type is always computed before the
        // partition id and always uses the fat type and,
        // in some cases, the sector count to determine the
        // partition id.
        //
        if (disk_size < CSEC_FAT32BIT) {
            partition_class = GenPartitionClassFat12Or16;
        } else {
            partition_class = GenPartitionClassFat32;
        }

    } else {

        if (_ft == LARGE32 ) {
            partition_class = GenPartitionClassFat32;
        } else {
            partition_class = GenPartitionClassFat12Or16;
        }
    }

    if (_drive->IsSuperFloppy()) {
        return PARTITION_FAT_16;    // just return something other than SYSID_NONE
    }

    if (_drive->IsSonyMS()) {
        //
        // Override RegeneratePartitionType for memory stick as it will use
        // PARTITION_FAT_16 for FAT12 cases when sector counts >= 32680
        //
        if (_drive->QuerySectors() < SMS_VOLSIZE_SMALL/_drive->QuerySectorSize()) {
            return PARTITION_FAT_12;
        } else {
            return PARTITION_HUGE;
        }
    }

    switch (_drive->QueryPartitionType()) {
      case 0x12:
      case 0xDE:
      case 0xFE:
        // preserve OEM partition id if formatting for FAT
        return _drive->QueryPartitionType();
    }

    if (_drive->IsPrimaryPartition()) {
        DoXInt13 = 0;
    } else {
        DoXInt13 = GENPARTTYPE_DISALLOW_XINT13;
    }

    status = RegeneratePartitionType( NULL,
                                      _drive->QueryDriveHandle(),
                                      partition_class,
                                      DoXInt13,
                                      0,
                                      &partition_id );

    if (!NT_SUCCESS(status)) {
        // Shouldn't fail
        DebugPrintTrace(("RegeneratePartitionType returned the error code 0x%x.\n", status));
    }

    return partition_id;
}

#if !defined(_SETUP_LOADER_)

ULONG
FAT_SA::ComputeRootEntries(
    ) CONST
/*++

Routine Description:

    This routine uses the size of the disk and a standard table in
    order to compute the required number of root directory entries.

Arguments:

    None.

Return Value:

    The required number of root directory entries.

--*/
{
    switch (_drive->QueryMediaType()) {

        case F3_720_512:
        case F5_360_512:
        case F5_320_512:
        case F5_320_1024:
        case F5_180_512:
        case F5_160_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_720_512:
        case F5_640_512:
        case F3_640_512:
#endif
            return 112;

        case F5_1Pt2_512:
        case F3_1Pt44_512:
#if defined(FE_SB) && defined(_X86_)
        case F3_1Pt2_512:
#endif
            return 224;

        case F3_2Pt88_512:
        case F3_20Pt8_512:
            return 240;

#if defined(FE_SB) && defined(_X86_)
        case F5_1Pt23_1024:
        case F3_1Pt23_1024:
             return 192;

        case F8_256_128:
            return 68;

        case RemovableMedia:
            return 512;
#endif
    }

    return 512;
}


USHORT
FAT_SA::ComputeSecClus(
    IN  SECTORCOUNT Sectors,
    IN  FATTYPE     FatType,
#if defined(FE_SB) && defined(_X86_)
    IN  MEDIA_TYPE  MediaType,
    IN  ULONG       SectorSize
#else
    IN  MEDIA_TYPE  MediaType
#endif
    )
/*++

Routine Description:

    This routine computes the number of sectors per cluster required
    based on the actual number of sectors.

Arguments:

    Sectors     - Supplies the total number of sectors on the disk.
    FatType     - Supplies the type of FAT.
    MediaType   - Supplies the type of the media.

Return Value:

    The required number of sectors per cluster.

--*/
{
    USHORT      sec_per_clus;
    SECTORCOUNT threshold;


    if (FatType == LARGE32) {

        if (Sectors >= 64*1024*1024) {
            sec_per_clus = 64;                  /* over 32GB -> 32K */
        } else if (Sectors >= 32*1024*1024) {
            sec_per_clus = 32;                  /* up to 32GB -> 16K */
        } else if (Sectors >= 16*1024*1024) {
            sec_per_clus = 16;                  /* up to 16GB -> 8K */
        } else {
            sec_per_clus = 8;                   /* up to 8GB -> 4K */
        }

        return sec_per_clus;
    }

    if (FatType == SMALL) {
        threshold = MIN_CLUS_BIG;
        sec_per_clus = 1;
    } else {
        threshold = MAX_CLUS_BIG;
        sec_per_clus = 1;
    }

    while (Sectors >= threshold) {
        sec_per_clus *= 2;
        threshold *= 2;
    }

    switch (MediaType) {

        case F5_320_512:
        case F5_360_512:
        case F3_720_512:
        case F3_2Pt88_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_640_512:
        case F3_640_512:
        case F5_720_512:
#endif
            sec_per_clus = 2;
            break;

        case F3_20Pt8_512:
#if defined(FE_SB)
        case F3_128Mb_512:
#if defined(_X86_)
        case F8_256_128:
#endif
#endif
            sec_per_clus = 4;
            break;

#if defined(FE_SB)
        case F3_230Mb_512:
            sec_per_clus = 8;
            break;
#endif

        default:
            break;

    }

    return sec_per_clus;
}

#endif // _SETUP_LOADER_


BOOLEAN
FAT_SA::IsValidString(
    IN  PCWSTRING    String
    )
/*++

Routine Description:

    This routine determines whether or not the given null-terminated string
    has any invalid characters in it.

Arguments:

    String  - Supplies the string to validate.

Return Value:

    FALSE   - The string contains invalid characters.
    TRUE    - The string is free from invalid characters.

Notes:

    The list of invalid characters is stricter than HPFS requires.

--*/
{
    CHNUM   i, l;

    l = String->QueryChCount();

    for (i = 0; i < l; i++) {
        if (String->QueryChAt(i) < 32) {
            return FALSE;
        }

        switch (String->QueryChAt(i)) {
            case '*':
            case '?':
                case '/':
            case '\\':
                case '|':
                case ',':
                case ';':
                case ':':
                case '+':
                case '=':
            case '<':
            case '>':
                case '[':
                case ']':
            case '"':
            case '.':
                return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\pch.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

        pch.cxx

Abstract:

        This module is a precompiled header for ufat.

Author:

        Matthew Bradburn (mattbr)  01-Feb-1994

--*/

#define _NTAPI_ULIB_
#define _UFAT_MEMBER_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "ufat.hxx"

#include "cluster.hxx"
#include "eaheader.hxx"
#include "easet.hxx"
#include "fat.hxx"
#include "fatdir.hxx"
#include "fatsa.hxx"
#include "fatdent.hxx"
#include "fatvol.hxx"
#include "filedir.hxx"
#include "reloclus.hxx"
#include "rfatsa.hxx"
#include "rootdir.hxx"
#include "hashindx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\reloclus.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    reloclus.cxx

Abstract:

    This module contains the definition of the RELOCATION_CLUSTER class.

Author:

    Ramon J. San Andres (ramonsa) 05-Nov-1991


--*/

#include <pch.cxx>



DEFINE_CONSTRUCTOR( RELOCATION_CLUSTER, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( RELOCATION_CLUSTER );




RELOCATION_CLUSTER::~RELOCATION_CLUSTER (
    )

/*++

Routine Description:

    Destructor for the RELOCATION_CLUSTER object

Arguments:

    None.

Return Value:

    None.

--*/

{
}



BOOLEAN
RELOCATION_CLUSTER::Initialize (
    IN  ULONG    Cluster
    )
/*++

Routine Description:

    Initializes a relocation cluster

Arguments:

    Cluster -   Supplies the cluster number

Return Value:

    BOOLEAN -   TRUE

--*/
{
    _Cluster  =   Cluster;

    return TRUE;
}




LONG
RELOCATION_CLUSTER::Compare (
    IN  PCOBJECT    Object
    ) CONST
/*++

Routine Description:

    Compares this relocation cluster against another object

Arguments:

    Object  -   Supplies pointer to other object

Return Value:

    LONG    -   See Compare in OBJECT

--*/
{
    PRELOCATION_CLUSTER     OtherCluster;

    DebugPtrAssert( Object );

    //
    //  If the other object is a relocation cluster, we do the comparison,
    //  otherwise we let someone else do it.
    //
    if ( OtherCluster = RELOCATION_CLUSTER::Cast( Object ) ) {

        if ( _Cluster < OtherCluster->QueryClusterNumber() ) {
            return -1;
        } else if ( _Cluster == OtherCluster->QueryClusterNumber() ) {
            return 0;
        } else {
            return 1;
        }
    } else {

        return OBJECT::Compare( Object );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in $(BASEDIR)\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ufat
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib    \
           $(PROJECT_ROOT)\fs\utils\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
           $(PROJECT_LIB_PATH)\patchbc.lib

USE_MSVCRT=1

DLLENTRY=InitializeUfat
PRECOMPILED_INCLUDE= ..\pch.cxx
MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\hashindx.cxx    \
        ..\cluster.cxx     \
        ..\eaheader.cxx    \
        ..\easet.cxx       \
        ..\entry.cxx       \
        ..\fat.cxx         \
        ..\fatdent.cxx     \
        ..\fatdir.cxx      \
        ..\fatsa.cxx       \
        ..\fatsachk.cxx    \
        ..\fatsacnv.cxx    \
        ..\fatvol.cxx      \
        ..\filedir.cxx     \
        ..\reloclus.cxx    \
        ..\rfatsa.cxx      \
        ..\rootdir.cxx     \
        ..\ufat.cxx        \
        ..\ufat.rc

INCLUDES=..\.;  \
         ..\..\inc;     \
         $(PROJECT_ROOT)\fs\utils\ulib\inc;     \
         $(PROJECT_ROOT)\fs\utils\ifsutil\inc;  \
         $(DDK_INC_PATH)

C_DEFINES=-DUNICODE=1

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console
DLLDEF=..\ufat.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\rfatsa.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    rfatsa.cxx

Author:

    Mark Shavlik (marks) 27-Mar-90
    Norbert Kusters (norbertk) 15-Jan-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "cmem.hxx"
#include "rtmsg.h"
#include "drive.hxx"
#include "bpb.hxx"
#include "bitvect.hxx"

extern "C" {
    #include <stdio.h>
}

#if defined(FE_SB) && defined(_X86_)
// PC98 boot strap code no use disk bios, PC98's boot strap code select.
extern UCHAR PC98FatBootCode[512];
extern UCHAR PC98Fat32BootCode[512*3];
#endif
extern UCHAR FatBootCode[512];
extern UCHAR Fat32BootCode[512*3];

#if !defined(_AUTOCHECK_) && !defined(_SETUP_LOADER_)
#include "timeinfo.hxx"
#endif

// Control-C handling is not necessary for autocheck.
#if !defined( _AUTOCHECK_ ) && !defined(_SETUP_LOADER_)

#include "keyboard.hxx"

#endif

#define CSEC_FAT32MEG            65536
#define CSEC_FAT16BIT            32680

#define MAX_CLUS_SMALL     4086     // Maximum number of clusters for FAT12 2^12 - 8 - 2
#define MAX_CLUS_ENT_SMALL 4087     // Largest fat entry for FAT12
#define MIN_CLUS_BIG       4087
#define MAX_CLUS_BIG       65526    // Maximum number of clusters for FAT16 2^16 - 8 - 2
#define MAX_CLUS_ENT_BIG   65527    // Largest fat entry for FAT16
#define MIN_CLUS_BIG32     65527
#define MAX_CLUS_BIG32     0x0FFFFFF6  // Maximum number of clusters for FAT32 2^28 - 8 - 2
#define MAX_CLUS_ENT_BIG32 0x0FFFFFF7  // Largest fat entry for FAT32
#define sigSUPERSEC1 (UCHAR)0x55    // signature first byte
#define sigSUPERSEC2 (UCHAR)0xAA    // signature second byte

//
// Sony Memory Stick thresholds
//
#define SMS_MIN_CLUS_SIZE   (8*1024)       // Minimum cluster size to use - 8K
#define SMS_MAX_CLUS_SIZE   (16*1024)      // Maximum cluster size to use - 16K
#define SMS_VOLSIZE_MIN_CLUS (10*1024*1024) // Maximum volume size to be formatted using
                                           // 8K instead of 16K cluster size

#define FAT_FIRST_DATA_CLUSTER_ALIGNMENT    (4*1024)    // data clusters starting alignment
#define NUMBER_OF_FATS                      (2)

//
//  The following macro computes the rounded up quotient of a number
//  divided by another number.
//

#define RoundUpDiv(num,div)  ((num) / (div) + ((num) % (div) ? 1 : 0))

//
//  The following macros maps a logical sector number to the corresponding
//  cluster on a volume based on the starting data Lbn and the number of
//  sectors per cluster.
//

#define MapSectorToCluster( sector, sec_per_clus, start_data_lbn ) \
    ((((sector) - (start_data_lbn)) / (sec_per_clus)) + FirstDiskCluster)

//
//  Internal function prototypes
//

ULONG
ComputeClusters(ULONG, ULONG, ULONG, ULONG, ULONG, FATTYPE);

VOID
PrintFormatReport (
    IN ULONG    BadClusters,
    IN PMESSAGE Message,
    IN BIG_INT  SectorSize,
    IN BIG_INT  ClusterSize,
    IN ULONG    ClusterCount,
    IN USHORT   FatType,
    IN PUSHORT  SerialNumber
    );

//
//  Functions for supporting the reduced memory consumption FAT (Reduced FAT)
//  format.
//

VOID SetEarlyEntries( PUCHAR, UCHAR, FATTYPE );
VOID SetEndOfChain( PUCHAR, ULONG, ULONG, FATTYPE );
VOID SetClusterBad( PUCHAR, ULONG, ULONG, FATTYPE );
VOID Set( PUCHAR, ULONG, ULONG, ULONG, FATTYPE );
VOID Set12( PUCHAR, ULONG, ULONG, ULONG);
VOID Set16( PUCHAR, ULONG, ULONG, ULONG);
VOID Set32( PUCHAR, ULONG, ULONG, ULONG);

//
//  End of internal function prototypes
//

DEFINE_EXPORTED_CONSTRUCTOR( REAL_FAT_SA, FAT_SA, UFAT_EXPORT );

BOOLEAN
REAL_FAT_SA::DosSaInit(
    IN OUT PMEM               Mem,
    IN OUT PLOG_IO_DP_DRIVE   Drive,
    IN     SECTORCOUNT        NumberOfSectors,
    IN OUT PMESSAGE           Message
    )
/*++

Routine Description:

    This routine simply initializes the underlying SUPERAREA structure
    and sets up a private pointer to the boot sector signature which is
    the last two bytes of the first sector. Note that the line for
    initializing the boot sector signature assumes that the sector size
    is 512 bytes.

Arguments:

    Mem - Supplies a pointer to a MEM which provides the memory for the
        REAL_FAT_SA object.

    Dive - Supplies a pointer the dirve object in which this super
        area object is found.

    NumberOfSectors - Supplies the total number of sectors on the
        volume.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE - Success.

    FALSE - Failure. The failure is probably caused by a lack of
        memory.

--*/
{

    //
    //  Class inheritance chain for REAL_FAT_SA:
    //  OBJECT<-SECRUN<-SUPERAREA<-FAT_SA<-REAL_FAT_SA
    //

    //
    //  Note that SUPERAREA::Initialize will initialize the
    //  _drive member. SUPERAREA::Initialize itself will call
    //  SECRUN::Initialize which aquires memory from the Mem
    //  object and marks the boundary of the superarea on the
    //  disk.
    //

    if (!SUPERAREA::Initialize(Mem, Drive, NumberOfSectors, Message)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    //
    //  Note that the following line of code depends on a sector size
    //  of twelve but changing the code based on the real sector size
    //  may break the boot code.
    //

    _sector_sig = (UCHAR *)SECRUN::GetBuf() + 510;

    return TRUE;
}


BOOLEAN
REAL_FAT_SA::DosSaSetBpb(
    )
/*++

Routine Description:

    This routine sets up the common fields in the FAT Bpb. More elaborate
    initialization of the Bpb is done in REAL_FAT_SA::SetBpb.

Arguments:

    NONE.

Return Values:

    TRUE - This method cannot fail.

--*/
{
#if defined _SETUP_LOADER_
    return FALSE;
#else
    ULONG Sec32Meg;        // num sectors in 32mb

    DebugAssert(_drive);
    DebugAssert(_drive->QuerySectors().GetHighPart() == 0);
    DebugAssert(_drive->QueryHiddenSectors().GetHighPart() == 0);


    //
    //  Sets up the bytes per sector field in the Bpb.
    //

    _sector_zero.Bpb.BytesPerSector = (USHORT)_drive->QuerySectorSize();

    //
    //  Theoretically, having 32megs of 128 bytes sectors will overflow the
    //  16-bit integer in the Sectors field of the Bpb so the following
    //  code is not absolutely fool-proof.
    //

    Sec32Meg = (32<<20) / _drive->QuerySectorSize();



    if (_drive->QuerySectors() >= Sec32Meg) {

        //
        //  >= 32Mb -- set BPB for large partition
        //

        _sector_zero.Bpb.Sectors = 0;
        _sector_zero.Bpb.LargeSectors = _drive->QuerySectors().GetLowPart();

    } else {

        //
        //  Size of DOS0 partition is < 32Mb
        //

        _sector_zero.Bpb.Sectors = (USHORT)_drive->QuerySectors().GetLowPart();
        _sector_zero.Bpb.LargeSectors = 0;
    }


    //
    //  The following block of code sets up the phycical characterics of the
    //  volume in the bpb.
    //

    _sector_zero.Bpb.Media = _drive->QueryMediaByte();
    _sector_zero.Bpb.SectorsPerTrack = (USHORT)_drive->QuerySectorsPerTrack();
    _sector_zero.Bpb.Heads = (USHORT)_drive->QueryHeads();
#if defined(FE_SB) && defined(_X86_)
    //  PC98 Oct.21.1995 ATAcard add
    //  PC98 Floppy disk should be treated same as PC/AT
    if (IsPC98_N() && !_drive->IsATformat() && !_drive->IsFloppy() && !_drive->IsSuperFloppy()){
        _sector_zero.Bpb.HiddenSectors = _drive->QueryPhysicalHiddenSectors().GetLowPart();
    } else
#endif
    _sector_zero.Bpb.HiddenSectors = _drive->QueryHiddenSectors().GetLowPart();

    return TRUE;
#endif // _SETUP_LOADER_
}

VOID
REAL_FAT_SA::Construct (
    )
/*++

Routine Description:

    Constructor for FAT_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _fat          = NULL;
    _dir          = NULL;
    _dirF32       = NULL;
    _hmem_F32     = NULL;
    _ft           = INVALID_FATTYPE;
    _StartDataLbn = 0;
    _ClusterCount = 0;
    _sysid        = SYSID_NONE;
    _data_aligned = FALSE;
    _AdditionalReservedSectors = MAXULONG;
}


UFAT_EXPORT
REAL_FAT_SA::~REAL_FAT_SA(
    )
/*++

Routine Description:

    Destructor for REAL_FAT_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

UFAT_EXPORT
BOOLEAN
REAL_FAT_SA::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Formatted
    )
/*++

Routine Description:

    This routine initializes the FAT super area to an initial state.  It
    does so by first reading in the boot sector and verifying it with
    the methods of REAL_FAT_SA.  Upon computing the super area's actual size,
    the underlying SECRUN will be set to the correct size.

    If the caller needs to format this volume, then this method should
    be called with the Formatted parameter set to FALSE.

Arguments:

    Drive       - Supplies the drive where the super area resides.
    Message     - Supplies an outlet for messages
    Formatted   - Supplies a boolean which indicates whether or not
                    the volume is formatted.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    BIG_INT     data_offset;

    //
    //  Reset the state of the REAL_FAT_SA object.
    //

    Destroy();

    //
    //  Make sure that the boot sector(s) is(are) at least 512 bytes
    //  in size. Note that the boot area for a FAT32 volume is of size at least
    //  32 * 512 bytes but that adjustment will be made later. The first
    //  512 bytes of a FAT volume should contain the whole Bpb and that is all we
    //  care for the moment.
    //

    _sec_per_boot = max(1, BYTES_PER_BOOT_SECTOR/Drive->QuerySectorSize());

    if (!Formatted) {
        return _mem.Initialize() &&
               DosSaInit(&_mem, Drive, _sec_per_boot, Message);
    }

    //
    //  Do some quick parameter checking, initialize the underlying
    //  SUPERAREA and SECRUN structure, and read in the Bpb.
    //

    if (!Drive ||
        !(Drive->QuerySectorSize()) ||
        !_mem.Initialize() ||
        !DosSaInit(&_mem, Drive, _sec_per_boot, Message) ||
        !SECRUN::Read()) {

        Message->Set(MSG_CANT_READ_BOOT_SECTOR);
        Message->Display("");
        Destroy();
        return FALSE;

    }

    //
    //  Unpack the bpb in the SECRUN buffer into the _sector_zero
    //  member for easier access to the fields within the bpb.
    //

    UnpackExtendedBios(&_sector_zero,
        (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

    //
    //  Have a really quick check on the unpacked Bpb.
    //

    if (!VerifyBootSector() || !_sector_zero.Bpb.Fats) {
        Destroy();
        return FALSE;
    }

    //
    //  Determine the FAT type and the number of clusters on the volume
    //  depending on the
    //

    _ClusterCount = DetermineClusterCountAndFatType ( &_StartDataLbn,
                                                      &_ft );

    //
    // figured out if the data clusters are aligned
    //
    data_offset = QuerySectorsPerFat()*QueryFats()+QueryReservedSectors();
    data_offset = data_offset * Drive->QuerySectorSize();
    data_offset += QueryRootEntries()*BytesPerDirent;
    DebugAssert(FAT_FIRST_DATA_CLUSTER_ALIGNMENT <= MAXULONG);
    _data_aligned = ((data_offset.GetLowPart() & (FAT_FIRST_DATA_CLUSTER_ALIGNMENT - 1)) == 0);

    //
    //  Determine the partition id.
    //

    if (_ft == SMALL) {
        _sysid = SYSID_FAT12BIT;
    } else if (QueryVirtualSectors() < CSEC_FAT32MEG) {
        _sysid = SYSID_FAT16BIT;
    } else if (_ft == LARGE32) {
        _sysid = SYSID_FAT32BIT;
    } else {
        _sysid = SYSID_FAT32MEG;
    }

    //
    //  Adjust the _sector_per_boot member if the volume
    //  is a FAT32 volume and also in the case of a FAT32 drive
    //  only set up the super area to include memory for one FAT.
    //  On FAT32 drives the FAT can be much larger than on a FAT16 drive
    //  and we do not want to carry around the second FAT in memory as
    //  extra baggage.
    //

    if ( _ft == LARGE32 ) {
        //
        // FAT32 drives have a variable reserved area size so we do not want this
        // number hard wired at 32 unless it is not set yet (BPB value is 0 or 1)
        //
        if(_sector_zero.Bpb.ReservedSectors > 1) {
            _sec_per_boot = _sector_zero.Bpb.ReservedSectors;
        } else {
            _sec_per_boot = max((32 * 512)/_drive->QuerySectorSize(), 32);
        }
        if(!_mem.Initialize() || !DosSaInit(&_mem, Drive,
                            _sector_zero.Bpb.ReservedSectors + _sector_zero.Bpb.BigSectorsPerFat,
                            Message)) {
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            Destroy();
            return FALSE;
        }
    } else {
        //
        //  The main idea behind the following code segment is to allocate
        //  memory for the whole super area including the boot area, all copies
        //  of the FAT, and the root directory for FAT12/16 volume and to initialize
        //  the underlying SECRUn object to cover the whole superarea on the
        //  disk.
        //
        if(!_mem.Initialize() || !DosSaInit(&_mem, Drive, _StartDataLbn, Message)) {
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            Destroy();
            return FALSE;
        }
    }
    //
    //  Initialize the root directory of the volume.
    //

    if (!(InitializeRootDirectory(Message))) {
        return FALSE;
    }

    return TRUE;
}

UFAT_EXPORT
BOOLEAN
REAL_FAT_SA::InitFATChkDirty(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine initializes the _fat pointer in the FAT super area
    to point to the first sector of one of the FATs so that the dirty bits in the FAT[1]
    entry can be looked at.

Arguments:

    Drive   - Supplies the drive.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UINT    StartSec;


    UnpackExtendedBios(&_sector_zero,
               (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

    if (!VerifyBootSector() || !_sector_zero.Bpb.Fats) {
        return FALSE;
    }

    _ClusterCount = DetermineClusterCountAndFatType ( &_StartDataLbn,
                                                      &_ft );

    StartSec =  _sector_zero.Bpb.ReservedSectors;

    if(!_mem2.Initialize()) {
    return FALSE;
    }

    DELETE(_fat);
    if (!(_fat = NEW FAT)) {
    return FALSE;
    }

    if (!_fat->Initialize(&_secrun2, &_mem2, Drive, StartSec, _ClusterCount, 1)) {
    DELETE(_fat);
    return FALSE;
    }

    if(!_secrun2.Read()) {
    if(_sector_zero.Bpb.SectorsPerFat == 0) {
        StartSec += _sector_zero.Bpb.BigSectorsPerFat;
    } else {
        StartSec += (UINT)_sector_zero.Bpb.SectorsPerFat;
    }
    if (!_fat->Initialize(&_secrun2, &_mem2, Drive, StartSec, _ClusterCount, 1)) {
        DELETE(_fat);
        return FALSE;
    }
    if(!_secrun2.Read()) {
        DELETE(_fat);
        return FALSE;
    }
    }

    return TRUE;
}

ULONG
REAL_FAT_SA::DetermineClusterCountAndFatType (
    IN OUT  PULONG      StartingDataLbn,
    IN OUT  FATTYPE     *FatType
    )
/*++

Routine Description:

    This routine computes the number of clusters and fat type of a volume
    based on the total number of sectors on the volume and data in the Bpb.

    Note that this method assumes that the _sector_zero member has beeen
    initialized properly.

Arguments:

    StartingDataLbn - Supplies the address at which the starting data
        Lbn should be returned to the caller.

    FatType  - Supplies the address at which the Fat type should be
        returned to the caller.

Return Values:

    Number of clusters on the volume. Note that this number includes the
    first two entries.

--*/
{
    ULONG   cluster_count;      //  Number of clusters on the volume
    ULONG   sectors;            //  Number of sectors on the volume.
    ULONG   starting_data_lbn;  //  The first data sector on the FAT volume.
    FATTYPE fat_type;           //  FAT type.
    ULONG   sector_size;        //  Sector size.

    sectors = QueryVirtualSectors();
    starting_data_lbn = ComputeStartDataLbn();
    sector_size = _drive->QuerySectorSize();

    //
    //  Use the naive formula to compute a preliminary cluster count
    //  on the volume.
    //

    cluster_count = (sectors - starting_data_lbn) / (ULONG)QuerySectorsPerCluster() +
                    FirstDiskCluster;

    //
    //  We can determine the fat type now, note that we are assuming
    //  that subsequent adjustment to the cluster count will not affect the
    //  fat type which is fairly reasonable.
    //

    fat_type = cluster_count > MAX_CLUS_ENT_SMALL ? LARGE16 : SMALL;

    //
    //  It is possible to have a FAT16 volume that doesn't use up all
    //  the space on the disk so we should check whether _sector_zero.Bpb
    //  .SectorsPerfat == 0 in order to make sure that the volume is really
    //  a FAT32 volume.
    //

    if (cluster_count > MAX_CLUS_ENT_BIG) {
        if ( _sector_zero.Bpb.SectorsPerFat == 0 ) {
            fat_type = LARGE32;
        } else {
            cluster_count = MAX_CLUS_ENT_BIG;
        }
    }

    //
    // Check to make sure the FAT size in the BPB is actually big enough to hold this
    //  many clusters, adjust the cluster_count down if it is not.
    //

    switch(fat_type) {
    case SMALL:
        if (RoundUpDiv(cluster_count * 12, sector_size * 8) > _sector_zero.Bpb.SectorsPerFat ) {
        cluster_count = (_sector_zero.Bpb.SectorsPerFat * sector_size * 8) / 12;
        }
        break;
    case LARGE16:
        if (RoundUpDiv(cluster_count * 2, sector_size) > _sector_zero.Bpb.SectorsPerFat ) {
        cluster_count = (_sector_zero.Bpb.SectorsPerFat * sector_size) / 2;
        }
        break;
    case LARGE32:
        if (RoundUpDiv(cluster_count * 4, sector_size) > _sector_zero.Bpb.BigSectorsPerFat ) {
        cluster_count = (_sector_zero.Bpb.BigSectorsPerFat * sector_size) / 4;
        }
        break;
    default:
        DebugPrintTrace(("Bad FAT type.\n"));
    }

    //
    //  Make sure that the caller gets what it wants.
    //

    *FatType = fat_type;
    *StartingDataLbn = starting_data_lbn;
    return cluster_count;

}

BOOLEAN
REAL_FAT_SA::InitializeRootDirectory (
    IN  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine initializes the root directory structure in the
    FAT super area object after the boot sector has been read from the
    disk.

Arguments:

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - The opreation is completed successfully.
    FALSE - This routine fails to complete the intended operation.

--*/
{

    //
    //  Note that the root directory for a FAT32 volume is a cluster
    //  chain while the FAT16/12 root directory is a fixed size area
    //  that comes right after the FATs.
    //

    if ( _ft == LARGE32 ) {

        if (!(_dirF32 = NEW FILEDIR)) {
            Destroy();
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;
        }

        //
        //  Complete initialization of _dirF32 is deffered until
        //  REAL_FAT_SA::read is called because the FAT
        //  is needed.
        //

    } else {

        CONT_MEM    cmem;           //  This CONT_MEM object piggybacks onto the
                                    //  the root directory section of the
                                    //  super area SECRUN buffer.
        ULONG       root_size;      //  Size of the root directory in number of sectors.
        ULONG       sector_size;    //  Well, it's kind of obvious isn't it.

        sector_size = _drive->QuerySectorSize();

        if (!(_dir = NEW ROOTDIR)) {

            Destroy();
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;

        } else {

            ULONG   root_offset;    //  Sector offset of the root directory from the
                                    //  beginning of the disk.

            //
            //  Computes the sector offset of the root directory.
            //

            root_offset = _sector_zero.Bpb.ReservedSectors +
                          _sector_zero.Bpb.SectorsPerFat *
                          _sector_zero.Bpb.Fats;

            //
            //  Size of the root directory in number of bytes. Note that the
            //  result is rounded up to the nearest size size.
            //

            root_size = ((_sector_zero.Bpb.RootEntries * BytesPerDirent - 1)
                         / sector_size + 1) * sector_size;

            //
            //  Now it's time to initialize the root directory. Note that this operation
            //  shouldn't fail because REAL_FAT_SA::Initialize should have allocated
            //  enough memory for the root directory through REAL_FAT_SA::DosSaInit.
            //

            if(!cmem.Initialize((PCHAR) SECRUN::GetBuf() + (root_offset * sector_size), root_size) ||
               !_dir->Initialize(&cmem, _drive, root_offset, _sector_zero.Bpb.RootEntries)) {
                DebugPrintTrace(("The secrun buffer should have enough space, big bug in code.\n"));
                Message->Set(MSG_FMT_NO_MEMORY);
                Message->Display("");
                Destroy();
                return FALSE;
            }
        }
    }

    return TRUE;

}



BOOLEAN
REAL_FAT_SA::CreateBootSector(
    IN  ULONG    ClusterSize,
    IN  ULONG    Flags,
    IN  PMESSAGE Message
    )
/*++

Routine Description:

    This routine updates fields in sector 0.

Arguments:

    ClusterSize - Supplies the desired number of bytes per cluster.
    Flags       - Supplies the flags from format.
    Message - Supplies an outlet for messages.

Return Value:

    TRUE  -   Success.
    FALSE -   Failure.

--*/
{
#if defined _SETUP_LOADER_

    return FALSE;

#else

    SetVolId(ComputeVolId());

    return SetBpb(ClusterSize, Flags, Message) &&
           SetBootCode() &&
           SetPhysicalDriveType(_drive->IsRemovable() ?
                                PHYS_REMOVABLE : PHYS_FIXED) &&
           SetOemData() &&
           SetSignature();

#endif // _SETUP_LOADER_
}

VALIDATION_STATUS
REAL_FAT_SA::ValidateClusterSize(
    IN     ULONG    ClusterSize,
    IN     ULONG    Sectors,
    IN     ULONG    SectorSize,
    IN     ULONG    Fats,
    IN OUT FATTYPE  *FatType,
    OUT    PULONG   FatSize,
    OUT    PULONG   ClusterCount
    )
/*++

Routine Description:

   This routine validates whether a given cluster size is
valid for a particular FAT type. If the fat type provided is
INVALID_FATTYPE, this routine would determine whether FAT12 or
FAT16 should be used.

Arguments:

    ClusterSize - Supplies the cluster size to be validated.

    Sectors - Supplies the total number of sectors on the volume.

    SectorSize - Supplies the number of bytes per sector.

    Fats - Supplies the number of FATs in the volume.

    FatType - Supplies the FAT type that the volume is going to be
        formatted. The caller will supply INVALID_FATTYPE if
        it is unsure whether the volume should be formatted
        as a FAT16 volume or a FAT12 volume and let this function
        to make the descision.

    FatSize - Supplies a location where the size of a fat in number
        of sectors can be passed back to the caller if the
        cluster size is valid.

    ClusterCounter - Supplies a location where the total number
        of clusters can be passed back to the caller if the
        given cluster size is valid.

Return Values:

   VALIDATION_STATUS

   VALID     - The given cluster size is valid.
   TOO_SMALL - The given cluster size is too small (Too many clusters).
   TOO_BIG   - The given cluster size is too big. (Too few clusters).

++*/
{
    ULONG   min_sec_req;    //  Minimum number of sectors required.
    ULONG   min_fat_size;   //  Minimum size of the FATs in number
                            //  of sectors.
    ULONG   fat_entry_size; //  Number of bytes per fat entry.
    ULONG   sec_per_clus;   //  Number of sectors per cluster.
    ULONG   clusters;       //  Number of clusters.
    FATTYPE fat_type;       //  Local fat type.

    ULONG   initial_data_sector_offset;
    ULONG   data_sector_offset;
    ULONG   pad;            // Padding to be added to the reserved sectors
                            // for data alignment

    DebugAssert(ClusterSize);

    //
    // Check for absolute minumum (one sector per cluster)
    //

    if (ClusterSize < SectorSize) {
        return TOO_SMALL;
    }

    //
    //  Compute the number of sectors per cluster.
    //

    sec_per_clus = ClusterSize / SectorSize;

    //
    //  Make sure that sec_per_clus <= 128
    //

    if (sec_per_clus > 128) {
        return TOO_BIG;
    }

    fat_type = *FatType;
    if (fat_type == INVALID_FATTYPE) {

        //  If the caller doesn't specify the fat type,
        //  try FAT16 first unless the volume is > 2Gig bytes
        //  in size (512 byte sectors only).

        if((SectorSize == 512) && (Sectors > (4 * 1024 * 1024))) {
            fat_type = LARGE32;
        } else {
            fat_type = LARGE16;
        }
    }

    //
    //  Compute the minimum number of sectors required by the
    //  FAT(s)
    //  The minimum number of sectors that the fats on a volume will
    //  occupy is given by: RoundUp(Number of fats * (minimum number of
    //  clusters + 2) * bytes per fat entry / sector size).
    //

    if (fat_type == LARGE32) {

        fat_entry_size = 4;
        min_fat_size = RoundUpDiv( Fats * (MIN_CLUS_BIG32 + 2) * fat_entry_size,
                                   SectorSize);
        min_sec_req = min_fat_size + MIN_CLUS_BIG32 * sec_per_clus;

        if (Sectors > min_sec_req) { // Meets the minimum requirement

            //
            //  Compute the number of clusters
            //

            initial_data_sector_offset = max(32, _sec_per_boot);

            for (pad=0; ; pad++) {

                data_sector_offset = initial_data_sector_offset + pad;

                clusters = ComputeClusters( ClusterSize,
                                            Sectors,
                                            SectorSize,
                                            data_sector_offset,
                                            Fats,
                                            fat_type);

                *FatSize = RoundUpDiv((clusters+2) * fat_entry_size , SectorSize);

                data_sector_offset += (*FatSize * Fats);

                if (_drive->IsFloppy() ||
                    ((((BIG_INT)data_sector_offset*SectorSize).GetLowPart() &
                      (FAT_FIRST_DATA_CLUSTER_ALIGNMENT-1)) == 0)) {
                    _AdditionalReservedSectors = pad;
                    break;
                }
            }

            //
            //  Check to see if the cluster size is too small
            //

            if ( clusters > MAX_CLUS_BIG32 ) {
                return TOO_SMALL;
            }

            //
            //  See if this cluster size makes the FAT too big. Win95's FAT32
            //  support does not support FATs > 16Meg - 64k bytes in size because
            //  the GUI version of SCANDISK is a 16-bit windows application that
            //  has this limit on its allocation block size. This value is also
            //  a quite reasonable lid on FAT size.
            //

            if ((clusters * 4) > ((16 * 1024 * 1024) - (64 * 1024))) {
                return TOO_SMALL;
            }

            //
            //  Return the fat type if the caller
            //  doesn't specify it.
            //

            if (*FatType == INVALID_FATTYPE) {
                *FatType = LARGE32;
            }

            //
            //  Compute the fat size and return it to the caller
            //

            *ClusterCount = clusters + FirstDiskCluster;
            return VALID;
        }

        // Volume is too small for FAT32
        return TOO_BIG;

    }

    //
    //  The code in this function may look a bit asymmetrical
    //  but that's because we treat FAT32 separately from
    //  FAT16/12.
    //

    if (fat_type == LARGE16) {

        //
        //  Again, we compute the minimum number of sectors required
        //  if the volume is formatted as a FAT16 volume.
        //

        fat_entry_size = 2;
        min_fat_size = RoundUpDiv( Fats * (MIN_CLUS_BIG + 2) * fat_entry_size, SectorSize);
        min_sec_req = min_fat_size + MIN_CLUS_BIG * sec_per_clus;

        if (Sectors > min_sec_req) { // Meets the minimum requirement

            //
            //  Compute the number of clusters
            //

            initial_data_sector_offset = _sec_per_boot +
                                         (_sector_zero.Bpb.RootEntries * BytesPerDirent - 1) /
                                         SectorSize + 1;

            for (pad=0; ; pad++) {

                data_sector_offset = initial_data_sector_offset + pad;

                clusters = ComputeClusters( ClusterSize,
                                            Sectors,
                                            SectorSize,
                                            data_sector_offset,
                                            Fats,
                                            fat_type );

                *FatSize = RoundUpDiv((clusters + 2) * fat_entry_size, SectorSize);

                data_sector_offset += (*FatSize * Fats);

                if (_drive->IsFloppy() ||
                    ((((BIG_INT)data_sector_offset*SectorSize).GetLowPart() &
                      (FAT_FIRST_DATA_CLUSTER_ALIGNMENT-1)) == 0)) {
                    _AdditionalReservedSectors = pad;
                    break;
                }
            }

            if (clusters > MAX_CLUS_BIG) {

                return TOO_SMALL;

            } else {

                //
                //  Return the fat type if the caller
                //  doesn't specify it.
                //

                if (*FatType == INVALID_FATTYPE) {
                    *FatType = LARGE16;
                }

                //
                //  Compute and return the fat size to the caller.
                //

                *ClusterCount = clusters + FirstDiskCluster;
                return VALID;

            }

        } else {

            //
            //  Don't bother to fall over to the FAT12 section if the
            //  volume has more that 32679 sectors unless it's a sony memory stick.
            //

            if (*FatType == INVALID_FATTYPE &&
                (_drive->IsSonyMS() || Sectors < CSEC_FAT16BIT)) {

                //
                //  Fall over to the FAT12 section
                //

                fat_type = SMALL;

            } else {

                return TOO_BIG;

            }

        }

    }

    //
    //  A volume is never too small for FAT12 so we just
    //  check whether it is too big.
    //

    if (fat_type == SMALL) {

        initial_data_sector_offset = _sec_per_boot +
                                     (_sector_zero.Bpb.RootEntries * BytesPerDirent - 1) /
                                     SectorSize + 1;

        for (pad=0; ; pad++) {

            data_sector_offset = initial_data_sector_offset + pad;

            clusters = ComputeClusters( ClusterSize,
                                        Sectors,
                                        SectorSize,
                                        data_sector_offset,
                                        Fats,
                                        fat_type );

            *FatSize = RoundUpDiv(RoundUpDiv((clusters + 2) * 3, 2), SectorSize);

            data_sector_offset += (*FatSize * Fats);

            if (_drive->IsFloppy() ||
                ((((BIG_INT)data_sector_offset*SectorSize).GetLowPart() &
                  (FAT_FIRST_DATA_CLUSTER_ALIGNMENT-1)) == 0)) {
                _AdditionalReservedSectors = pad;
                break;
            }
        }

        if (clusters > MAX_CLUS_SMALL) {
            return TOO_SMALL;
        }

        //
        //  Return fat type to caller if necessary
        //

        if (*FatType == INVALID_FATTYPE) {
            *FatType = SMALL;
        }

        //
        //  Compute and return the FAT size
        //

        *ClusterCount = clusters + FirstDiskCluster;
        return VALID;

    }

    DebugAbort("This line should never be executed.\n");
    return TOO_BIG;

}

ULONG
ComputeClusters(
    IN  ULONG        ClusterSize,
    IN  ULONG        Sectors,
    IN  ULONG        SectorSize,
    IN  ULONG        ReservedSectors,
    IN  ULONG        Fats,
    IN  FATTYPE      FatType
    )
/*++

Routine Description:

    This routine computes the number of clusters on a volume given
    the cluster size, volume size and the fat type.

Arguments:

    ClusterSize - Supplies the size of a cluster in number of bytes.

    Sectors - Supplies the total number of sectors in the volume.

    SectorSize - Supplies the size of a sector in number of bytes.

    ReservedSectors - Supplies the number of reserved sectors.

    Fats - Supplies the number of copies of fat for this volume.

    FatType - Supplies the fat type.

Return Value:

    ULONG - The total number of clusters for the given configuration.

++*/
{
    ULONG entries_per_sec; //  Number of FAT entries per sector.
    ULONG fat_entry_size;  //  Size of each FAT entry in number of BITS.
    ULONG sectors_left;    //  Number of sectors left for consideration.
    ULONG residue;         //  The residue number of bits per sector.
    ULONG acc_residue = 0; //  The accumulated residue number of FAT entry
                           //  bits.
    ULONG sec_per_clus;    //  Sectors per cluster.
    ULONG increment = 1;   //  Increment step size in number of FAT sectors.
    ULONG additional_clus; //  Number of additional clusters possible due to
                           //  the accumulated residue bits in the fat.
    ULONG clusters = 0;    //  Number of clusters in total.
    ULONG temp;            //  Temporary place-holder for optimizing certain
                           //  computations.

    sectors_left = Sectors - ReservedSectors;

    sec_per_clus = ClusterSize / SectorSize;

    //
    //  Determine the Fat entry size in number of bits based on the
    //  fat type.
    //

    switch (FatType) {
        case SMALL:
            fat_entry_size = 12;
            break;
        case LARGE16:
            fat_entry_size = 16;
            break;
        case LARGE32:
            fat_entry_size = 32;
            break;
    }

    //
    //  Compute the number of FAT entries a sector can hold.
    //    NOTE that fat_entry_size is the size in BITS,
    //    this is the reason for the "* 8" (bits per byte).
    //

    entries_per_sec = (SectorSize * 8) / fat_entry_size;

    //
    //  If the FAT entry size doesn't divide the sector
    //  size evenly, we want to know the residue.
    //

    residue = (SectorSize * 8) % fat_entry_size;

    //
    //  Compute a sensible increment step size to begin with.
    //

    while (Sectors / (increment * entries_per_sec * sec_per_clus) > 1) {
        increment *= 2;
    }

    //
    //  We have to handle the first sector of FAT entries
    //  separately because the first two entries are reserved.
    //  Kind of yucky, isn't it?
    //

    temp = Fats + ((entries_per_sec - 2) * sec_per_clus);
    if (sectors_left < temp) {

        return (sectors_left - Fats) / sec_per_clus;

    } else {

        sectors_left -= temp;
        acc_residue += residue;
        clusters += entries_per_sec - 2;

        while (increment && sectors_left) {

            additional_clus = (acc_residue + (increment * residue)) / fat_entry_size;
            temp = (Fats + entries_per_sec * sec_per_clus) * increment + additional_clus * sec_per_clus;

            if (sectors_left < temp) {

                //
                //  If the increment step is only one, try to utilize the remaining sectors
                //  as much as possible.
                //

                if (increment == 1) {

                    //
                    // Exhaust the residue fat entries first
                    //

                    temp = acc_residue / fat_entry_size;
                    if (temp <= sectors_left / sec_per_clus) {

                        clusters += temp;
                        sectors_left -= temp * sec_per_clus;

                    } else {

                        clusters += sectors_left / sec_per_clus;
                        sectors_left -= sectors_left / sec_per_clus;

                    }

                    //
                    // Additional clusters may be possible after allocating
                    // one more sector of fat.
                    //
                    if ( sectors_left > Fats) {
                        temp = (sectors_left - Fats) / sec_per_clus;
                        if (temp > 0) {
                            clusters += temp;
                        }
                    }

                }

                //
                // Cut the increment step by half if it is too big.
                //

                increment /= 2;

            } else {

                if (additional_clus) {
                    acc_residue = (acc_residue + (increment * residue)) % (additional_clus * fat_entry_size);
                } else {
                    acc_residue += increment * residue;
                }
                sectors_left -= temp;
                clusters += increment * entries_per_sec + additional_clus;

            }

        }
        return clusters;
    }

    DebugAbort("This line should never be executed.");
    return 0;
}

ULONG
REAL_FAT_SA::ComputeDefaultClusterSize(
    IN  ULONG        Sectors,
    IN  ULONG        SectorSize,
    IN  ULONG        ReservedSectors,
    IN  ULONG        Fats,
    IN  MEDIA_TYPE   MediaType,
    IN  FATTYPE      FatType,
    OUT PULONG       FatSize,
    OUT PULONG       ClusterCount
    )
/*++

Routine Description:

    This routine computes a default cluster size given the total number
    of free sectors and fat type.

Arguments:

    Sectors - Supplies the total number of sectors on the volume.

    SectorSize - Supplies the size of a sector in bytes.

    ReservedSectors - Supplies the number of reserved sectors.

    Fats - Supplies the number of fats.

    MediaType - Supplies the media type.

    FatType - Supplies the fat type.

    FatSize - Supplies a location for this routine to pass back the
        size of a FAT in number of sectors back to the caller.

    ClusterCount - Supplies a location for this routine to pass back
        the total number of clusters on the volume.


Return Values:

    ULONG - The number of clusters that should on the volume computed
            by the default algorithm.

++*/
{
    ULONG             fat_size;      //  Number of sectors per fat.
    ULONG             sec_per_clus;  //  Number of sectors per cluster.
    ULONG             cluster_size;  //  Cluster size in number of bytes.
    VALIDATION_STATUS result;        //  Result after validating
                                     //  the cluster size.

    //
    //  Assign a reasonable value to sec_per_clus
    //  base on the number of sectors in total.
    //

    switch (FatType) {
        case LARGE32:
        //
        // The numbers in this may look a bit odd and arbitrary, they are.
        // They match the ones that MS-DOS/Win95 use for FAT32 drives, at least
        // for 512 byte sectors. NOTE than in the case of other sector sizes
        //
        if (Sectors >= 64*1024*1024) {          // >= 32GB
            sec_per_clus = 64;                  //   32k cluster @ 512 byt/sec
        } else if (Sectors >= 32*1024*1024) {   // >= 16GB
            sec_per_clus = 32;                  //   16k cluster @ 512 byt/sec
        } else if (Sectors >= 16*1024*1024) {   // >=  8GB
            sec_per_clus = 16;                  //    8k cluster @ 512 byt/sec
        } else {                                // else
            sec_per_clus = 8;                   //    4k cluster @ 512 byt/sec
        }
            break;

        case LARGE16:
            sec_per_clus = 1;
            break;

        case SMALL:
            sec_per_clus = 1;
            break;

        default:
            sec_per_clus = 0;   // set it to an invalid value
            DebugAbort("This cannot happen.");
    }

    DebugAssert(GetDrive());

    if (GetDrive()->IsSonyMS()) {
        //
        // Select default cluster size based on memory stick size
        //
        sec_per_clus = SMS_MIN_CLUS_SIZE/SectorSize;
        if (Sectors >= (SMS_VOLSIZE_MIN_CLUS/SectorSize)) {
            sec_per_clus = SMS_MAX_CLUS_SIZE/SectorSize;
        }
    }

    //
    //  If this is a floppy disk, we just choose a default value.
    //

    switch (MediaType) {

        case F5_320_512:
        case F5_360_512:
        case F3_720_512:
        case F3_2Pt88_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_640_512:
        case F3_640_512:
        case F5_720_512:
#endif
            sec_per_clus = 2;
            break;

        case F3_20Pt8_512:
#if defined(FE_SB)
        case F3_128Mb_512:
#if defined(_X86_)
        case F8_256_128:
#endif
#endif
            sec_per_clus = 4;
            break;

#if defined(FE_SB)
        case F3_230Mb_512:
            sec_per_clus = 8;
            break;
#endif

        default:
            break;

    }

    //
    // Validate the assigned number of sectors per
    // cluster and readjust them if necessary.
    //

    result = ValidateClusterSize( sec_per_clus * SectorSize,
                                  Sectors,
                                  SectorSize,
                                  Fats,
                                  &_ft,
                                  &fat_size,
                                  ClusterCount);

    switch (result) {

        case TOO_SMALL:

            //
            //  If the cluster size is too small, keep enlarging
            //  it by a factor of 2 until it is valid.
            //

            do {
                sec_per_clus *= 2;
                if ( sec_per_clus > 128 ) {
                    return (sec_per_clus * SectorSize);
                }
            } while (ValidateClusterSize( sec_per_clus * SectorSize,
                                          Sectors,
                                          SectorSize,
                                          Fats,
                                          &_ft,
                                          &fat_size,
                                          ClusterCount) != VALID);

            break;

        case TOO_BIG:

            //
            //  If the cluster size is too big, keep reducing it
            //  by half until it is valid.
            //

            do {
                sec_per_clus /= 2;
                if ( sec_per_clus == 0 ) {
                    return (sec_per_clus * SectorSize);
                }
            } while (ValidateClusterSize( sec_per_clus * SectorSize,
                                          Sectors,
                                          SectorSize,
                                          Fats,
                                          &_ft,
                                          &fat_size,
                                          ClusterCount) != VALID);

            break;

        case VALID:
            break;
        default:
            DebugAbort("This should never happen.");
            break;
    }

    *FatSize = fat_size;
    return (sec_per_clus * SectorSize);

}


BOOLEAN
REAL_FAT_SA::SetBpb(
     )
{
   DebugAbort("This method should never be called.");
   return FALSE;
}

BOOLEAN
REAL_FAT_SA::SetBpb(
    IN  ULONG    ClusterSize,
    IN  ULONG    Flags,
    IN  PMESSAGE Message
    )
/*++

Routine Description:

    This routine sets up the BPB from scratch for the FAT file system.

Arguments:

    ClusterSize - Supplies the desired number of bytes per cluster.
    Flags       - Supplies the flags from format.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else // _SETUP_LOADER_


    BOOLEAN     BackwardCompatible = ((Flags & FORMAT_BACKWARD_COMPATIBLE) ? TRUE : FALSE);
                                  // flag to determine fat 16/12 compatibility

    SECTORCOUNT sectors;          //  Total number of sectors.
    ULONG       sector_size;      //  Size of each sector in bytes.
    USHORT      sec_per_clus = 0; //  Sectors per cluster
    ULONG       cluster_size = 0; //  Size of each cluster in bytes.
    VALIDATION_STATUS result;     //  Return code from ValidateClusterSize.
    ULONG       fat_size;         //  Size of each fat in number of
                                  //  sectors.
#if DBG
    BIG_INT     data_offset;      // the offset to first data cluster
#endif

    //
    //  Call DosSaSeetBpb to perform some very rudimentary bpb setup.
    //

    if (!DosSaSetBpb()) {
        DebugPrintTrace(("Could not do a REAL_FAT_SA::DosSaSetBpb.\n"));
        return FALSE;
    }

    //
    //  A volume cannot have more than 4gig sectors.
    //
    DebugAssert(_drive->QuerySectors().GetHighPart() == 0);

    sectors = _drive->QuerySectors().GetLowPart();
    sector_size = _drive->QuerySectorSize();

    PCHAR fattypestr;
    if (!BackwardCompatible) {

        //
        //  If BackwardCompatible is false, then the user must have
        //  specified the /fs:FAT32 switch or the existing volume
        //  must be a FAT32 volume when a quik format is performed.
        //

        _ft = LARGE32;
        fattypestr = "FAT32";

    } else {

        //
        //  At this moment, we don't know whether FAT16 or FAt12
        //  is appropriate for this volume.
        //

        _ft = INVALID_FATTYPE;
        fattypestr = "FAT16/12";

    }

    if (_drive->QuerySectors().GetHighPart() != 0) {
        Message->Set(MSG_FMT_VOL_TOO_BIG);
        Message->Display("%s", fattypestr);
        return FALSE;
    }

    //
    //  The boot area of a FAt32 volume is at least 32 sectors large
    //  and at least 32 * 512 bytes in size.
    //

    if (_ft == LARGE32) {
        _sec_per_boot = max((32 * 512) / sector_size, 32);
    }

    //
    //  Set up the number of reserved sectors and the number of
    //  FATs in the boot sector. Note that ValidateClusterSize and
    //  ComputeDefaultClusterSize depend on these values so don't move
    //  the following lines to anywhere else.
    //

    _sector_zero.Bpb.ReservedSectors = (USHORT)_sec_per_boot;
    _sector_zero.Bpb.Fats = 2;

    //
    //  Try to honor the cluster size provided by the user.
    //

    if (ClusterSize) {

        //
        //  If the cluster size specified by the user is not
        //  of the form sector_size * 2^n where n is an integer
        //  then choose a cluster size which is of the form 2^n
        //  * sector size and is just bigger than the cluster
        //  size specified by the user.
        //

        USHORT i;
        cluster_size = sector_size;
        sec_per_clus = 1;

        //
        // Check that the user specified cluster size is at least as big as
        // the minimum allowed cluster size as determined by the sector size.
        //

        if (ClusterSize < cluster_size) {
            Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_SMALL_MIN);
            Message->Display("%u", sector_size);
            return FALSE;
        }

        while (cluster_size < ClusterSize && sec_per_clus < 256) {
            cluster_size *= 2;
            sec_per_clus *= 2;
        }

        //
        //  Make sure that the cluster size provided by the user
        //  is not too big.
        //

        if (sec_per_clus > MaxSecPerClus) {

            Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_BIG);
            Message->Display("%s", fattypestr);
            return FALSE;
        }

        //
        //  Issue a warning if the cluster size computed is not
        //  equal to the cluster size provided by the user.
        //

        if (cluster_size != ClusterSize) {
            if (Flags & FORMAT_YES) {
                Message->Set(MSG_FMT_CLUSTER_SIZE_MISMATCH_WARNING);
                Message->Display("%u", cluster_size);
            } else {
                Message->Set(MSG_FMT_CLUSTER_SIZE_MISMATCH);
                Message->Display("%u", cluster_size);
                if (!Message->IsYesResponse(FALSE)) {
                    return FALSE;
                }
            }
        }
    }

    _sector_zero.Bpb.RootEntries = (USHORT)ComputeRootEntries();

    if (cluster_size) {

        //
        //  Make sure that the cluster size is valid for a
        //  FAT volume.
        //

        result = ValidateClusterSize( cluster_size,
                                      sectors,
                                      sector_size,
                                      NUMBER_OF_FATS,
                                      &_ft,
                                      &fat_size,
                                      &_ClusterCount );

        //
        //  Tell the user the cluster size specified is invalid
        //  for the FAT type chosen.
        //

        switch (result) {
            case TOO_SMALL:
                Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_SMALL);
                Message->Display("%s", fattypestr);
                return FALSE;
            case TOO_BIG:
                Message->Set(MSG_FMT_CLUSTER_SIZE_TOO_BIG);
                Message->Display("%s", fattypestr);
                return FALSE;
        }

    }


    if (BackwardCompatible && _ft == INVALID_FATTYPE) {

        //
        //  Use CSEC_16BIT as a cut-off point for determining
        //  whether the FAT should be 16-bit or 12-bit unless
        //  it is a Sony memory stick.
        //  If it is a Sony memory stick, then anything 64MB
        //  or less should be FAT12.

        if (_drive->IsSonyMS()) {
            if (sectors < SMS_VOLSIZE_SMALL/sector_size) {   // use a slightly larger cutoff point
                _ft = SMALL;
            } else {
                _ft = LARGE16;
            }
        } else if (sectors < CSEC_FAT16BIT) {
            _ft = SMALL;
        } else {
            _ft = LARGE16;
        }
    }

    //
    //  If the user doesn't provide a cluster size, we have
    //  to compute a default cluster size.
    //
    if (!cluster_size) {

        cluster_size = ComputeDefaultClusterSize( sectors,
                                                  sector_size,
                                                  _sector_zero.Bpb.ReservedSectors,
                                                  NUMBER_OF_FATS,
                                                  _drive->QueryMediaType(),
                                                  _ft,
                                                  &fat_size,
                                                  &_ClusterCount);
        if (cluster_size == 0) {
            Message->Set(MSG_FMT_VOL_TOO_SMALL);
            Message->Display("%s", fattypestr);
            return FALSE;

        } else if (cluster_size > 128 * sector_size) {
            Message->Set(MSG_FMT_VOL_TOO_BIG);
            Message->Display("%s", fattypestr);
            return FALSE;

        }

    }

    //
    // Check for volume limits.
    //
    //  If volume is > 32Gig, say we won't do FAT
    //  If cluster size is 64k warn about compatibility issues
    //

    if((sectors / ((1024 * 1024) / sector_size)) > (32 * 1024)) {
        Message->Set(MSG_FMT_VOL_TOO_BIG);
        Message->Display("%s", fattypestr);
        return FALSE;
    }

    if(cluster_size >= (64 * 1024)) {
        if (Flags & FORMAT_YES) {
            Message->Set(MSG_FMT_CLUSTER_SIZE_64K_WARNING);
            Message->Display("");
        } else {
            Message->Set(MSG_FMT_CLUSTER_SIZE_64K);
            Message->Display("");
            if (!Message->IsYesResponse(TRUE)) {
                return FALSE;
            }
        }
    }

    //
    //  Compute the number of sectors per clusters.
    //

    _sector_zero.Bpb.SectorsPerCluster = (UCHAR) (cluster_size / sector_size);
    if (_ft == LARGE32) {
        _sector_zero.Bpb.SectorsPerFat = 0;
        _sector_zero.Bpb.BigSectorsPerFat = fat_size;
    } else {
        _sector_zero.Bpb.SectorsPerFat = (USHORT)fat_size;
        _sector_zero.Bpb.BigSectorsPerFat = 0;
    }

    if (_ft == SMALL) {
        memcpy(_sector_zero.SystemIdText, "FAT12   ", cSYSID);
    } else if (_ft == LARGE32) {
        memcpy(_sector_zero.SystemIdText, "FAT32   ", cSYSID);
    } else {
        memcpy(_sector_zero.SystemIdText, "FAT16   ", cSYSID);
    }

    memcpy(_sector_zero.Label, "NO NAME    ", cLABEL);

    _sector_zero.CurrentHead = 0;

    //
    //  Initialize the additional fields in the FAT32 boot
    //  sector.
    //

    if (_ft == LARGE32) {
        //
        // Recompute RootEntries, _sec_per_boot, and ReservedSectors
        // in case _ft changes
        //
        _sector_zero.Bpb.RootEntries = (USHORT)ComputeRootEntries();
        _sec_per_boot = max((32 * 512) / _drive->QuerySectorSize(), 32);
        _sector_zero.Bpb.ReservedSectors = (USHORT)_sec_per_boot;

        _sector_zero.Bpb.ExtFlags = 0;
        _sector_zero.Bpb.FS_Version = 0;
        _sector_zero.Bpb.RootDirStrtClus = 2;
        _sector_zero.Bpb.FSInfoSec = 1;
        _sector_zero.Bpb.BkUpBootSec = max(6, (USHORT)((6 * 512) / sector_size));
    }

    DebugAssert(_AdditionalReservedSectors != MAXULONG);
    //
    // Sony camera assumes memory stick ReservedSectors to be 1 for FAT12/16
    // If not, corruption will occur when camera tries to write to memory stick
    //
    if (!_drive->IsSonyMS()) {
        _sec_per_boot += _AdditionalReservedSectors;
    }
    _sector_zero.Bpb.ReservedSectors = (USHORT)_sec_per_boot;

#if DBG
    if (!_drive->IsSonyMS()) {
        data_offset = ((BIG_INT)(fat_size*NUMBER_OF_FATS + _sec_per_boot))*sector_size +
                      (_sector_zero.Bpb.RootEntries*BytesPerDirent);
        DebugAssert (_drive->IsFloppy() ||
                     ((data_offset.GetLowPart() & (FAT_FIRST_DATA_CLUSTER_ALIGNMENT - 1)) == 0));
    }
#endif

    return TRUE;

#endif // _SETUP_LOADER_
}

#if defined( _AUTOCHECK_ )

#define LOCALE_STHOUSAND              0x0000000F   // thousand separator

typedef unsigned int        UINT;
typedef unsigned int        *PUINT;
typedef unsigned int        *LPUINT;

int
ChkGetLocaleInfoW(
    UINT     Locale,
    UINT     LCType,
    LPWSTR   lpLCData,
    int      cchData)
{
    //
    //  For AUTOCHK we do not do thousand seperators. The NLS APIs are not
    //  around, and the registry isn't really set up either so there is no standard
    //  language place available to determine what the thousand seperator is.
    //
    return 0;
}

UINT
ChkGetUserDefaultLCID(void)
{
    return 0;
}

#else
#define ChkGetLocaleInfoW   GetLocaleInfoW
#define ChkGetUserDefaultLCID   GetUserDefaultLCID
#endif


VOID
InsertSeparators(
    LPCWSTR OutWNumber,
    char * InANumber,
    ULONG  Width
    )
{
    WCHAR szSeparator[10];
    WCHAR Separator;
    LPWSTR lpWNumber;

    lpWNumber = (LPWSTR)OutWNumber;

    if (0 != ChkGetLocaleInfoW(
                   ChkGetUserDefaultLCID(),
                   LOCALE_STHOUSAND,
                   szSeparator,
                   10
                  ))
    {
        Separator = szSeparator[0];
    }
    else
    {
    Separator = L'\0';  // If we can't get the thousand separator, do not use one.
    }

    WCHAR Buffer[100];
    ULONG cchNumber = strlen((LPCSTR)InANumber);
    UINT Triples = 0;

    Buffer[99] = L'\0';
    PWCHAR pch = &Buffer[98];

    while (cchNumber > 0)
    {
    *pch-- = InANumber[--cchNumber];

        ++Triples;
    if ( (Separator != L'\0') && (0 == (Triples % 3)) && (cchNumber > 0) )
        {
            *pch-- = Separator;
        }
    }

    cchNumber = wcslen((pch + 1));
    if(cchNumber < Width) {
    UINT i;

    cchNumber = Width - cchNumber;
    for(i = 0; i < cchNumber; i++) {
        lpWNumber[i] = L' ';
    }
    } else {
    cchNumber = 0;
    }

    wcscpy(lpWNumber + cchNumber, pch + 1); // the Number buffer better be able to handle it!
}

BOOLEAN
REAL_FAT_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      ULONG           Flags,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSize
    )
/*++

Routine Description:

    This routine initializes the FAT file system.

Arguments:

    BadSectors - Supplies a list of the bad sectors on the volume.

    Message - Supplies an outlet for messages.

    Label - Supplies an optional label.

    Flags - Supplies flags from format.

    ClusterSize - Supplies the cluster size specified by the user. If
        the user doesn't specify a cluster size, this parameter will
        be zero.

    VirtualCluster - Not used.

Return Value:

    FALSE   - Failure.

    TRUE    - Success.

Notes: FAT32 root directory uses the FILEDIR structure as
       opposed to the ROOTDIR structure used in FAT16/12.
--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else

    ULONG bad_clusters;

    //
    //  CreateBootSector initializes the private member
    //  _sector_zero which mirrors the boot sector.
    //  Note that the new boot sector has not been written to
    //  the disk yet at this point.
    //

    if (!CreateBootSector(ClusterSize, Flags, Message)) {
        return FALSE;
    }

#if defined(FE_SB) && defined(_X86_)
    //
    //  Set the appropriate boot code according to environment.
    //  This must be here because _ft is fixed at CreateBootSector().
    //
    if (IsPC98_N() && !_drive->IsATformat()) {
    if ( _ft == LARGE32 ) {
        _bootcode = PC98Fat32BootCode;
        _bootcodesize = sizeof(PC98Fat32BootCode);
    }
    else {
        _bootcode = PC98FatBootCode;
        _bootcodesize = sizeof(PC98FatBootCode);
    }
    }
    else {
#endif
    if ( _ft == LARGE32 ) {
        _bootcode = Fat32BootCode;
        _bootcodesize = sizeof(Fat32BootCode);
    }
    else {
        _bootcode = FatBootCode;
        _bootcodesize = sizeof(FatBootCode);
    }
#if defined(FE_SB) && defined(_X86_)
    }
#endif

    //
    //  Check that the REAL_FAT_SA object is initialized
    //  properly before this method is called. Also compute the
    //  appropriate partition id.
    //

    if (!_drive ||
        (_sysid = ComputeSystemId()) == SYSID_NONE) {
        return FALSE;
    }

    //
    //  These "Hidden Status" messages are a hack to allow WinDisk to
    //  cancel a quick format, which ordinarily doesn't send any status
    //  messages, but which might take a while and for which there is a
    //  cancel button.  When using format.com, no message will be displayed
    //  for this.
    //

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  DiskIsUsable will compute the proper value for the _StartDataLbn
    //  member.
    //

    if (!DiskIsUsable(BadSectors, Message)) {
        return FALSE;

    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  WriteNewFats will initialize _sector_zero.Bpb.RootDirStrtClus to the
    //  first error-free cluster on a FAT32 volume.
    //

    if (!WriteNewFats( BadSectors, &bad_clusters, Message)){
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  Initialize new root directory on the disk.
    //

    if (!WriteNewRootDirAndVolumeLabel( Label, Message )) {
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    //
    //  Initialize new boot sector and setup boot code.
    //

    if (!WriteNewBootArea(Message)) {
        return FALSE;
    }

    //
    //  Set file system id in the corresponding PARTITION
    //  TABLE ENTRY.
    //

    if (!SetSystemId()) {

       Message->Set(MSG_WRITE_PARTITION_TABLE);
       Message->Display("");
       return FALSE;

    }

    Message->Set(MSG_FORMAT_COMPLETE);
    Message->Display("");


    //
    //  Print an informative report.
    //

    PrintFormatReport( bad_clusters, Message );

    return TRUE;


#endif
}

BOOLEAN
REAL_FAT_SA::DiskIsUsable (
    IN  PCNUMBER_SET    BadSectors,
    IN  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine checks whether the volume is write-protected and whether there
    are any bad sectors in the critical area(boot sector, fats, and rootdir for FAT16).
    Note that this routine will initialize the _StartDataLbn member to a proper value
    when it is done.


Arguments:

    BadSectors - Supplies the set of bad sectors on the volume.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - The volume is usable.

    FALSE - The volume is either write-protected or one of the sectors
        in the critical area is bad.

--*/
{
    //
    //  Computes the first data sector which also serves as the
    //  boundary of the FAT critical area.
    //

    _StartDataLbn = ComputeStartDataLbn();

    //
    //  Since the set of bad sectors is sorted in ascending order,
    //  we only have to check whether the first bad sectors is in the
    //  critical area.
    //

    if (BadSectors->QueryCardinality().GetLowPart()) {

        if (BadSectors->QueryNumber(0).GetLowPart() < _StartDataLbn ) {

            Message->Set(MSG_UNUSABLE_DISK);
            Message->Display("");
            return FALSE;

        }

    }

    //
    //  Check to see if the disk is write protected by trying to
    //  write to the first sector. Note that REAL_FAT_SA::Initialize
    //  has already allocated memory for the boot sector.
    //

    // wipe out signature so as not to confuse the system when dealing with superfloppy

    *_sector_sig = 0;
    *(_sector_sig+1) = 0;

    if (!_drive->Write( 0, 1, _mem.GetBuf())) {

        if( _drive->QueryLastNtStatus() == STATUS_MEDIA_WRITE_PROTECTED) {

            Message->Set(MSG_FMT_WRITE_PROTECTED_MEDIA);

        } else {

            Message->Set(MSG_UNUSABLE_DISK);

        }

        Message->Display("");
        return FALSE;
    }

    PBYTE   ZeroBuf = (PBYTE)MALLOC(_drive->QuerySectorSize());

    if (ZeroBuf == NULL) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }
    memset(ZeroBuf, 0, _drive->QuerySectorSize());

    if (!_drive->Write( _drive->QuerySectors()-1, 1, ZeroBuf )) {
        DebugPrintTrace(("UFAT: Unable to clean the NTFS mirror boot sector at %x\n", _drive->QuerySectors()-1));
    }

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::WriteNewFats (
    IN     PCNUMBER_SET BadSectors,
    IN OUT PULONG       BadClusters,
    IN     PMESSAGE     Message

)
/*++

Routine Description:

    This routine writes brand new copies of the fat to the disk in
    a piecemeal manner. As a side effect, this routine will also allocate
    the first available cluster to the FAT32 root directory.

Arguments:

    BadSectors  - Supplies the set of bad sectors on the volume.

    BadClusters - Supplies the location where this routine can return
        the number of bad clusters on the volume to the caller.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - Success.

    FALSE - Failure. Probably runs out of memory.

--*/
{
    ULONG    sectors;               //  Total number of sectors on the volume.
    BIG_INT  bad_sector;            //  The current bad sector under consideration.
    ULONG    i,j;                   //  Generic indices.
    ULONG    segment_size;          //  The size of a fat segment in number of sectors.
    ULONG    entries_per_segment;   //  Number of fat entries in each segment.
    ULONG    granularity_factor;    //  The number of sectors required to avoid
                                    //  having fat entries straddling on a
                                    //  segment boundary.
    ULONG    root_dir_strt_clus;    //  The first cluster of the FAT32 root directory.
    HMEM     segment_hmem;          //  Memory object for the fat segment.
    SECRUN   segment_secrun;        //  The run of sectors representing the current
                                    //  fat segment on the disk.
    ULONG    segment_offset;        //  The starting offset of the current fat segment
                                    //  on the volume in sectors.
    ULONG    segment_start_entry;   //  Number of fat entries in each fat segment.
    ULONG    segment_last_entry;    //  The last fat entry in the current segment
    ULONG    curr_bad_clus;         //  The current bad cluster.
    ULONG    prev_bad_clus;
    ULONG    sector_size;
    ULONG    mult_factor;           //  Number of "grains" per segment;
    ULONG    sectors_per_fat;
    ULONG    sectors_per_cluster;
    ULONG    num_of_fats;
    ULONG    num_of_fat_sec_remain; //  Number of sectors remain uninitialized in the current fat.
    ULONG    curr_segment_size;

    DebugAssert(_ft != INVALID_FATTYPE);


    sector_size = _drive->QuerySectorSize();
    sectors     = _drive->QuerySectors().GetLowPart();
    sectors_per_cluster = QuerySectorsPerCluster();
    sectors_per_fat = QuerySectorsPerFat();
    num_of_fats     = _sector_zero.Bpb.Fats;

    //
    //  The more generic way of figuring out the granularity factor
    //  is to use the formula: granularity factor = LCM(sector size in bits, LCM(fat entry size in bits , 8 (bits per byte))
    //  but since it is reasonable to assume that sector size in bytes is divisible by 4, the
    //  granularity factors are hard-coded.
    //

    switch (_ft) {
        case SMALL:
            granularity_factor = 3;
            break;
        case LARGE16:
            granularity_factor = 1;
            break;
        case LARGE32:
            granularity_factor = 1;
            break;
    }

    //
    //  We don't want to be a pig grabbing too much memory from the system
    //  even with virtual memory enabled so we limit ourselves to 512kb
    //  per fat segment.
    //

    mult_factor = min( (sectors_per_fat - 1) / granularity_factor + 1, ((1ul << 19) / sector_size) / granularity_factor);

    if(!segment_hmem.Initialize()){

        DebugPrintTrace(("Unable to initialize hmem object.\n"));
        return FALSE;

    }

    while (!segment_secrun.Initialize( &segment_hmem,
                                       _drive,
                                       _sector_zero.Bpb.ReservedSectors,
                                       mult_factor * granularity_factor)) {


        //
        //  Reduce the segment size util there is enough memory.
        //

        mult_factor /= 2;

        if (!mult_factor) {

            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;

        }

    }

    segment_size = min(sectors_per_fat, mult_factor * granularity_factor);

    //
    // Computes the number of fat entries per fat segment.
    //

    switch (_ft) {
        case SMALL:
            entries_per_segment = (segment_size * sector_size * 2) / 3;
            break;
        case LARGE16:
            entries_per_segment = (segment_size * sector_size) / 2;
            break;
        case LARGE32:
            entries_per_segment = (segment_size * sector_size) / 4;
            break;
    }

    //
    // Allocate the first available cluster for a FAT32 volume root directory.
    //

    if (_ft == LARGE32) {

        root_dir_strt_clus = _sector_zero.Bpb.RootDirStrtClus;

        //
        //  Scan for the first non-bad cluster for the root
        //  directory.
        //

        for (i = 0; i < BadSectors->QueryCardinality().GetLowPart(); i++) {
            bad_sector = BadSectors->QueryNumber(i);


            curr_bad_clus = MapSectorToCluster(bad_sector.GetLowPart(), sectors_per_cluster, _StartDataLbn);

            if (curr_bad_clus == _ClusterCount) {

                //
                //  All clusters are bad, there is no point to go on.
                //

                Message->Set(MSG_UNUSABLE_DISK);
                Message->Display("");
                return FALSE;
            }

            if (curr_bad_clus  == root_dir_strt_clus) {
                root_dir_strt_clus++;
            } else if (curr_bad_clus > root_dir_strt_clus) {
                break;
            }
        }
    }

    //
    //  Preparations for the FAT initialization progress meter.
    //

    ULONG percent = 0;
    ULONG    total_num_fat_sec;     //  Total number of FAT sectors.
    ULONG    num_sec_completed;     //  Number of fat sectors initialized.
    total_num_fat_sec = sectors_per_fat * _sector_zero.Bpb.Fats;
    Message->Set(MSG_FMT_INITIALIZING_FATS);
    Message->Display("");


#if 0 // Remove the extra progress meter.
    Message->Set(MSG_PERCENT_COMPLETE);
    Message->Display("%d", percent);
#endif

    //
    // For each fat...
    //

    *BadClusters = 0;
    for (i = 0; i < _sector_zero.Bpb.Fats; i++) {

        segment_last_entry  = entries_per_segment - 1;
        segment_start_entry = 0;
        segment_offset      = i * sectors_per_fat + _sector_zero.Bpb.ReservedSectors;
        curr_segment_size   = segment_size;
        num_of_fat_sec_remain = sectors_per_fat;
        prev_bad_clus         = 0;

        //
        // Initialize the first two entries of the first segment.
        //
        if (!segment_hmem.Initialize() ||
            !segment_secrun.Initialize( &segment_hmem,
                                        _drive,
                                        segment_offset,
                                        segment_size) ){

            //
            // Shouldn't fail
            //
            DebugPrintTrace(("Unable to initialize secrun object.\n"));
            return FALSE;
        }

        memset(segment_secrun.GetBuf(), 0, segment_size * sector_size);

        SetEarlyEntries( (PUCHAR)segment_secrun.GetBuf(),
                         _sector_zero.Bpb.Media,
                         _ft );

        j = 0;
        while (num_of_fat_sec_remain) {

            //
            //  Mark all the bad clusters in the current segment
            //  and keep track of the bad clusters counter.
            //

            for (;j < BadSectors->QueryCardinality().GetLowPart(); j++) {
                bad_sector = BadSectors->QueryNumber(j);

                curr_bad_clus = MapSectorToCluster( bad_sector.GetLowPart(), sectors_per_cluster, _StartDataLbn );

                if (curr_bad_clus > segment_last_entry) {
                    break; // j is not incremented
                } else if (curr_bad_clus > prev_bad_clus) {
                    prev_bad_clus = curr_bad_clus;
                    SetClusterBad( (PUCHAR)segment_secrun.GetBuf(),
                                   curr_bad_clus,
                                   segment_start_entry,
                                   _ft );
                    (*BadClusters)++;

                }
            }

            if ( _ft == LARGE32 ) {

                //
                //  Allocate the root cluster if it is in the
                //  current segment.
                //

                if (root_dir_strt_clus >= segment_start_entry &&
                    root_dir_strt_clus <= segment_last_entry ) {
                    SetEndOfChain( (PUCHAR)segment_secrun.GetBuf(),
                                   root_dir_strt_clus,
                                   segment_start_entry,
                                   _ft );

                }

            }

            //
            //  Write the current segment to the disk.
            //
            //  We don't care whether the write operation is successful
            //  or not because we can rely on the inherent redundancy
            //  of multiple fats.
            //

            if (!segment_secrun.Write()) {
                DebugPrintTrace(("Unable to write fat segment to disk.\n"));
            }

            //
            //  Decrement the number of fat sectors remain.
            //

            num_of_fat_sec_remain -= curr_segment_size;

#if 0   // No FAT initialization progress meter for now.
            num_sec_completed += curr_segment_size;
            percent = (num_sec_completed * 100) / total_num_fat_sec;

            Message->Display("%d", percent);
#endif
            //
            //  Increment the segment offset, start entry.
            //

            segment_offset += curr_segment_size;
            segment_start_entry += entries_per_segment;

            //
            //  Compute the new segment size.
            //
            curr_segment_size = min( segment_size, num_of_fat_sec_remain );

            //
            //  Increment the last segment entry.
            //
            segment_last_entry += entries_per_segment * curr_segment_size / segment_size;

            //
            //  Reintialize the secrun object to point to the next
            //  fat segment on the disk.
            //

            if (curr_segment_size) {
                if (!segment_hmem.Initialize() ||
                    !segment_secrun.Initialize( &segment_hmem,
                                                _drive,
                                                segment_offset,
                                                curr_segment_size )) {
                    //
                    //  Shouldn't fail.
                    //
                    DebugAbort("Unable to initialize secrun object.\n");
                }

                //
                //  Zero the secrun buffer for the next iteration.
                //

                memset(segment_secrun.GetBuf(), 0, curr_segment_size * sector_size);

            }
        }

    }

#if 0   // No FAT initialization progress meter for now.
    Message->Display("%d", 100);
#endif
    _sector_zero.Bpb.RootDirStrtClus = root_dir_strt_clus;
    (*BadClusters) /= _sector_zero.Bpb.Fats;
    return TRUE;
}


BOOLEAN
REAL_FAT_SA::WriteNewRootDirAndVolumeLabel (
    IN PCWSTRING    Label,
    IN PMESSAGE     Message
)
/*++

Routine Description:

    This routine initializes the root directory as an empty structure
    and then sets up the volume label if neccessary.

Arguments:

    Label   - Supplies the volume label that the user has specified
        at the command line.

    Message - Supplies an outlet for messages.

Return Values:

    TRUE  - The operation is completed successfully.
    FALSE - This routine encounters unrecoverable errors while
            carrying out the operation.
--*/
{
    HMEM    root_dir_hmem;  //  Memory object for the root directory
    ULONG   root_size;      //  Size of the root directory.
    SECRUN  root_secrun;    //  A run of sectors that represents the
                            //  the root directory. Note that the
                            //  FAT32 root directory is initially one
                            //  cluster long which is a contagious run
                            //  of sectors. Note that we don't use the
                            //  the higher level FILEDIR and ROOTDIR
                            //  structures because we don't have the whole
                            //  fat in memory to initialize them.
    ULONG   root_dir_offset;//  The location of the root directory on the
                            //  disk.
    FAT_DIRENT label_dirent;//  Directory entry for the label.
    DSTRING    label;       //  Volume label.
    FAT_DIRENT ms_dirent;   //  Directory entry for the memory stick file.
    DSTRING    ms_name;     //  Volume label.
    PUCHAR     starting_entry;

    DebugAssert(_ft != INVALID_FATTYPE);

    if (!root_dir_hmem.Initialize()) {
        //
        //  Shouldn't fail.
        //
        DebugPrintTrace(("Failed to initialize HMEM object.\n"));
    }

    //
    //  Initialize the root directory secrun according to the Fat type.
    //

    if (_ft == LARGE32) {

        //
        //  Note that the following lines depends on the fact that
        //  WriteNewFats has set up _sector_zero.Bpb.RootDirStrtClus.
        //
        root_size = 0;
        root_dir_offset = QuerySectorFromCluster( _sector_zero.Bpb.RootDirStrtClus,
                                                  (PUCHAR)&root_size);


    } else {

        //
        //  Compute the sector offset of the FAT16/12 root directory.
        //

        root_dir_offset = _sector_zero.Bpb.ReservedSectors +
                          _sector_zero.Bpb.Fats * _sector_zero.Bpb.SectorsPerFat;

        //
        //  Compute the size of the FAT16/12 root direcctory.
        //

        root_size = (_sector_zero.Bpb.RootEntries * BytesPerDirent - 1) /
                    _drive->QuerySectorSize() + 1;


    }

    //
    //  Initialize and zero out the secrun buffer.
    //

    if (!root_secrun.Initialize( &root_dir_hmem,
                                 _drive,
                                 root_dir_offset,
                                 root_size)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    memset( root_secrun.GetBuf(), 0, root_size * _drive->QuerySectorSize());

    starting_entry = (PUCHAR)root_secrun.GetBuf();

    //
    //  Maybe someone should consider breaking the volume label
    //  code out as a separate function.
    //
    //
    //  Prompt the user for a volume label.
    //

    if (_drive->QueryMediaType() != F5_160_512 &&
        _drive->QueryMediaType() != F5_320_512) {

        if (Label) {

            if (!label.Initialize(Label)) {
                Message->Set(MSG_FMT_INIT_LABEL_FAILED);
                Message->Display("");
                return FALSE;
            }

        } else {
            switch (_drive->QueryRecommendedMediaType()) {
                case F5_360_512:
                case F5_320_512:
                case F5_180_512:
                case F5_160_512:
                    //
                    //  These disk drives are poor and can't
                    //  take the spin down without a verify
                    //  so don't prompt for the label.
                    //  This will avoid FORMAT failing.
                    //
                    label.Initialize();
                    break;

                default:
                    Message->Set(MSG_VOLUME_LABEL_PROMPT);
                    Message->Display("");
                    Message->QueryStringInput(&label);
                    break;

            }

        }

        for (;;) {

            if ( IsValidString(&label) &&
                 label.Strupr()) {
                if (label.QueryChCount()) {

                    //
                    //  Now set the volume label into the first directory
                    //  entry of the root directory. Note that the first
                    //  directory entry of the root directory must be free.
                    //

                    if (!(label_dirent.Initialize((PUCHAR)(root_secrun.GetBuf()), _ft))) {

                        //
                        //  Shouldn't fail.
                        //

                        DebugPrintTrace(("Failed to initialize directory entry for volume label.\n"));
                        return FALSE;

                    } else {

                        label_dirent.SetVolumeLabel();

                        if (!(label_dirent.SetLastWriteTime() &&  label_dirent.SetName(&label))) {

                            Message->Set(MSG_FMT_INIT_LABEL_FAILED);
                            Message->Display("");

                        } else {

                            starting_entry += BytesPerDirent;
                            break;
                        }
                    }

                } else {

                    break;

                }

            }

            Message->Set(MSG_INVALID_LABEL_CHARACTERS);
            Message->Display("");

            Message->Set(MSG_VOLUME_LABEL_PROMPT);
            Message->Display("");
            Message->QueryStringInput(&label);

        }
    }

    if (_drive->IsSonyMS() && !_drive->IsSonyMSFmtCmdCapable()) {

        if (!ms_name.Initialize(TEXT("MEMSTICK.IND"))) {
            Message->Set(MSG_FMT_NO_MEMORY);
            Message->Display("");
            return FALSE;
        }

        if (!ms_dirent.Initialize(starting_entry, _ft) ||
            !ms_dirent.SetLastWriteTime() ||
            !ms_dirent.SetName(&ms_name)) {

            Message->Set(MSG_FMT_UNABLE_TO_CREATE_MEMSTICK_FILE);
            Message->Display();
            return FALSE;
        }

        ms_dirent.SetHidden();
        ms_dirent.SetReadOnly();
    }

    //
    //  We can now write the root directory to the disk.
    //

    if (!root_secrun.Write()) {

        Message->Set(MSG_UNUSABLE_DISK);
        Message->Display("");
        return FALSE;

    }

    return TRUE;
}


BOOLEAN
REAL_FAT_SA::WriteNewBootArea (
    IN  PMESSAGE    Message
)
/*++

Routine Description:

    This routine initializes the boot area, which includes the boot code and
    the bpb, of a new volume.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    TRUE  - The operation is completed successfully.

    FALSE - Either the system rans out of memory or the boot area
            cannot be written to the disk.

++*/
{

    ULONG   boot_area_size; // Size of the whole boot area in bytes.
    ULONG   pseudo_sector_size;


    pseudo_sector_size = max(512, _drive->QuerySectorSize());
    boot_area_size = _sector_zero.Bpb.ReservedSectors * _drive->QuerySectorSize();

    //
    //  Call DosSaInit to make sure that the secrun buffer is
    //  large enough to hold the boot sector(s).
    //

    if(!_mem.Initialize() || !DosSaInit(&_mem, _drive, _sector_zero.Bpb.ReservedSectors, Message)) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }


    //
    //  Zero out the reserved area
    //

    memset ( (PUCHAR)SECRUN::GetBuf(), 0,  boot_area_size );


    //
    //  We always assume that the sector size is at least 512 bytes when we copy the
    //  the boot code to the disk. If this is not the case, the boot code has
    //  to be smart enough to load itself up.
    //

    if  (_ft == LARGE32) {

        //
        //  We just copy the whole boot code (which includes the boot sector) directly
        //  into the secrun buffer and then pack the Bpb at a later time.
        //

        //
        //  Copy the first 1k of the bootcode into the secrun buffer.
        //

        memcpy ( SECRUN::GetBuf(), _bootcode, 512);
        memcpy ( (PUCHAR)SECRUN::GetBuf() + pseudo_sector_size, _bootcode + 512, 512);

        //
        //  Copy the last four byte signature onto sector 2 as well
        //
        memcpy ( (PUCHAR)SECRUN::GetBuf() + (3 * pseudo_sector_size - 4),
                 _bootcode + (3 * pseudo_sector_size - 4), 4 );
        //
        //  Copy the last 512 bytes of the boot code into the
        //  12th pseudo sector.
        //

        memcpy ( (PUCHAR)SECRUN::GetBuf() + (12 * pseudo_sector_size), _bootcode + 1024, 512 );


    } else {

        memcpy ( SECRUN::GetBuf(), _bootcode, 512 );

    }


    //
    //  Pack the bpb into the secrun buffer.
    //

    PackExtendedBios( &_sector_zero,
                      (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)(SECRUN::GetBuf()));


    //
    //  Backup the first 3 sectors to sectors 6-8 if the
    //  volume is a FAT32 volume.
    //

    if (_ft == LARGE32) {
        memcpy ((PUCHAR)SECRUN::GetBuf() + 6 * pseudo_sector_size, SECRUN::GetBuf(), 3 * pseudo_sector_size);
    }

    //
    //  Write the boot area to the disk.
    //

    if (!SECRUN::Write()) {
        Message->Set(MSG_UNUSABLE_DISK);
        Message->Display("");
        return FALSE;
    }
    return TRUE;
}

VOID
REAL_FAT_SA::PrintFormatReport (
    IN ULONG    BadClusters,
    IN PMESSAGE Message
    )
/*++

Routine Description:

    This routine prints an informative format report to the console.

Arguments:

    BadClustrers - Supplies the number of bad clusters on the disk.

    Message      - Supplies an outlet for messages.

Return Value:

    None.

--*/
{
    ::PrintFormatReport(BadClusters,
                        Message,
                        _drive->QuerySectorSize(),
                        QuerySectorsPerCluster()*_drive->QuerySectorSize(),
                        _ClusterCount,
                        _ft,
                        QueryVolId() ? (PUSHORT)&_sector_zero.SerialNumber : NULL);
}

VOID
REAL_FAT_SA::PrintFormatReport (
    IN PMESSAGE                         Message,
    IN PFILE_FS_SIZE_INFORMATION        FsSizeInfo,
    IN PFILE_FS_VOLUME_INFORMATION      FsVolInfo
    )
/*++

Routine Description:

    This routine prints an informative format report to the console.

Arguments:

    BadClustrers - Supplies the number of bad clusters on the disk.

    Message      - Supplies an outlet for messages.

Return Value:

    None.

--*/
{
    ULONG cluster_size = FsSizeInfo->SectorsPerAllocationUnit*FsSizeInfo->BytesPerSector;

    BIG_INT volume_size = FsSizeInfo->TotalAllocationUnits*cluster_size;

    FATTYPE volume_type = (volume_size < SMS_VOLSIZE_SMALL) ? SMALL : LARGE16;

    ::PrintFormatReport(0,
                        Message,
                        FsSizeInfo->BytesPerSector,
                        cluster_size,
                        FsSizeInfo->AvailableAllocationUnits.LowPart + FirstDiskCluster,
                        volume_type,
                        (PUSHORT)&FsVolInfo->VolumeSerialNumber);
}

VOID
PrintFormatReport (
    IN ULONG    BadClusters,
    IN PMESSAGE Message,
    IN BIG_INT  SectorSize,
    IN BIG_INT  ClusterSize,
    IN ULONG    ClusterCount,
    IN USHORT   FatType,
    IN PUSHORT  SerialNumber
    )
{

    BIG_INT   free_count;
    BIG_INT   cluster_size;
    BIG_INT   sector_size;
    PUSHORT   serial_number;
    BIG_INT   temp_big_int;
    ULONG     temp_ulong;
    MSGID     message_id;
    BOOLEAN   KSize;
    char      wdAstr[14];
    DSTRING   wdNum1;

    if (!wdNum1.Initialize("             ")) {
        Message->Set(MSG_FMT_NO_MEMORY);
        Message->Display("");
        return;
    }

    sector_size = SectorSize;
    cluster_size = ClusterSize;

    // Compute whether reporting size in bytes or kilobytes
    //
    // NOTE: The magic number 4095MB comes from Win9x's GUI SCANDISK utility
    //
    temp_big_int = cluster_size * (ClusterCount - FirstDiskCluster) ;
    if (temp_big_int.GetHighPart() || (temp_big_int.GetLowPart() > (4095ul*1024ul*1024ul))) {
        KSize = TRUE;
    } else {
        KSize = FALSE;
    }

    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_TOTAL_KILOBYTES;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_TOTAL_DISK_SPACE;
    }

    Message->Set(message_id);

    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    if (BadClusters) {
        temp_big_int = cluster_size * BadClusters;
        if (KSize) {
            temp_ulong = (temp_big_int / 1024ul).GetLowPart();
            message_id = MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB;
        } else {
            temp_ulong = temp_big_int.GetLowPart();
            message_id = MSG_BAD_SECTORS;
        }
        Message->Set(message_id);
        sprintf(wdAstr, "%u", temp_ulong);
        InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
        Message->Display("%ws", wdNum1.GetWSTR());
    }

    free_count = ClusterCount;
    free_count -= BadClusters + FirstDiskCluster;

    if (FatType == LARGE32) {
        free_count -= 1;
    }

    temp_big_int = free_count * cluster_size.GetLowPart();
    if (KSize) {
        temp_ulong = (temp_big_int / 1024ul).GetLowPart();
        message_id = MSG_AVAILABLE_KILOBYTES;
    } else {
        temp_ulong = temp_big_int.GetLowPart();
        message_id = MSG_AVAILABLE_DISK_SPACE;
    }
    Message->Set(message_id);
    sprintf(wdAstr, "%u", temp_ulong);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_ALLOCATION_UNIT_SIZE);
    sprintf(wdAstr, "%u", cluster_size);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_AVAILABLE_ALLOCATION_UNITS);
    sprintf(wdAstr, "%u", free_count);
    InsertSeparators(wdNum1.GetWSTR(), wdAstr,13);
    Message->Display("%ws", wdNum1.GetWSTR());

    Message->Set(MSG_BLANK_LINE);
    Message->Display();

    Message->Set(MSG_FMT_FAT_ENTRY_SIZE);
    switch(FatType) {

      case SMALL:
     Message->Display("%13u", 12ul);
         break;

      case LARGE16:
     Message->Display("%13u", 16ul);
         break;

      case LARGE32:
     Message->Display("%13u", 32ul);
         break;

      default:
         ;
    }

    if (SerialNumber) {
        Message->Set(MSG_BLANK_LINE);
        Message->Display();
        serial_number = SerialNumber;
        Message->Set(MSG_VOLUME_SERIAL_NUMBER);
        Message->Display("%04X%04X", serial_number[1], serial_number[0]);
    }

}

//
// The following routines are slightly modified versions of the
// methods found in fat.hxx
//

//
// Fat macros
//
#define FAT12_MASK      0x00000FFF
#define FAT16_MASK      0x0000FFFF
#define FAT32_MASK      0x0FFFFFFF
#define END_OF_CHAIN    0x0FFFFFFF
#define BAD_CLUSTER     0x0FFFFFF7

VOID
SetEarlyEntries(
    IN OUT PUCHAR   FatBuf,
    IN     UCHAR    MediaByte,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the first two FAT entries as required by the
    FAT file system.  The first byte gets set to the media descriptor.
    The remaining bytes gets set to FF.

Arguments:

    FatBuf - Supplies a pointer to the first FAt segment.

    MediaByte   - Supplies the media byte for the volume.

    FatType - Supplies the FAT type.

Return Value:

    None.

--*/
{
    DebugAssert(FatType != INVALID_FATTYPE);

    FatBuf[0] = MediaByte;
    FatBuf[1] = FatBuf[2] = 0xFF;

    if (FatType != SMALL) {
        FatBuf[3] = 0xFF;
    }

    if (FatType == LARGE32) {
        FatBuf[3] = 0x0F;
        ((PULONG)FatBuf)[1] = FAT32_MASK;
    }
    return;
}

VOID
SetEndOfChain (
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    StartingEntry,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the cluster ClusterNumber to the end of its cluster
    chain.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the cluster to be set to end of chain.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

    FatType - Supplies the Fat type.

Return Value:

    None.

--*/
{
    Set( FatBuf, ClusterNumber, END_OF_CHAIN, StartingEntry, FatType );
    return;
}

VOID
SetClusterBad(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    StartingEntry,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the cluster ClusterNumber to bad on the FAT.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the cluster number to mark bad.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

    FatType - Supplies the Fat type.

Return Value:

    None.

--*/
{
    Set( FatBuf, ClusterNumber, BAD_CLUSTER, StartingEntry, FatType );
    return;
}


VOID
Set(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry,
    IN     FATTYPE  FatType
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 12 bit, 16 bit or 32 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

    FatType - Supplies the Fat type.

Return Value:

    None.

--*/
{

    DebugAssert(FatType != INVALID_FATTYPE);

    switch (FatType) {
        case SMALL:
            Set12( FatBuf, ClusterNumber, Value, StartingEntry );
            break;
        case LARGE16:
            Set16( FatBuf, ClusterNumber, Value, StartingEntry );
            break;
        case LARGE32:
            Set32( FatBuf, ClusterNumber, Value, StartingEntry );
            break;
    }
    return;
}

VOID
Set12(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 12 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

Return Value:

    None.

--*/
{
    ULONG  n;
    UCHAR  value;

    Value = Value & FAT12_MASK;

    n = (ClusterNumber - StartingEntry) * 3;

    if (n%2) {
        FatBuf[n/2] = (FatBuf[n/2]&0x0F) | (((UCHAR)Value&0x000F)<<4);
        FatBuf[n/2 + 1] = (UCHAR)((Value&0x0FF0)>>4);
    } else {
        FatBuf[n/2] = (UCHAR)Value&0x00FF;
        FatBuf[n/2 + 1] = (FatBuf[n/2 + 1]&0xF0) | (UCHAR)((Value&0x0F00)>>8);
    }
    return;
}

VOID
Set16(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 16 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

Return Value:

    None.

--*/
{
    Value = Value & FAT16_MASK;
    ((PUSHORT)FatBuf)[ClusterNumber - StartingEntry] = (USHORT)Value;
    return;
}

VOID
Set32(
    IN OUT PUCHAR   FatBuf,
    IN     ULONG    ClusterNumber,
    IN     ULONG    Value,
    IN     ULONG    StartingEntry
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 16 bit FAT entry to Value.

Arguments:

    FatBuf - Supplies a pointer to a FAT segment.

    ClusterNumber   - Supplies the FAT entry to set.

    Value           - Supplies the value to set the FAT entry to.

    StartingEntry - Supplies the index of the first entry in the
        FAT segment.

Return Value:

    None.

--*/
{
    Value = Value & FAT32_MASK;
    ((PULONG)FatBuf)[ClusterNumber - StartingEntry] = Value;
    return;

}

BOOLEAN
REAL_FAT_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine runs through the clusters for the file described by
    'FileName' and takes out bad sectors.

Arguments:

    FullPathFileName    - Supplies a full path name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if defined( _SETUP_LOADER_ )

    return FALSE;

#else // _SETUP_LOADER_


    HMEM        hmem;
    ULONG       clus;
    BOOLEAN     changes;
    PFATDIR     fatdir;
    BOOLEAN     need_delete;
    FAT_DIRENT  dirent;
    ULONG       old_file_size;
    ULONG       new_file_size;

    if ((clus = QueryFileStartingCluster(FullPathFileName,
                                         &hmem,
                                         &fatdir,
                                         &need_delete,
                                         &dirent)) == 1) {

       Message->Set(MSG_FILE_NOT_FOUND);
       Message->Display("%W", FullPathFileName);
       return FALSE;

    }

    if (clus == 0xFFFFFFFF) {

       Message->Set(MSG_CHK_NO_MEMORY);
       Message->Display("");
       return FALSE;

    }

    if (clus == 0) {

       Message->Set(MSG_FILE_NOT_FOUND);
       Message->Display("%W", FullPathFileName);
       return FALSE;

    }

    if (dirent.IsDirectory()) {
        old_file_size = _drive->QuerySectorSize()*
                        QuerySectorsPerCluster()*
                        _fat->QueryLengthOfChain(clus);
    } else {
        old_file_size = dirent.QueryFileSize();
    }

    if (!RecoverChain(&clus, &changes)) {

       Message->Set(MSG_CHK_NO_MEMORY);
       Message->Display("");
       return FALSE;

    }

    if (dirent.IsDirectory() || changes) {
       new_file_size = _drive->QuerySectorSize()*
                       QuerySectorsPerCluster()*
                       _fat->QueryLengthOfChain(clus);
    } else {
        new_file_size = old_file_size;
    }

    if (changes) {


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ )

        // Disable contol-C handling and

        if (!KEYBOARD::EnableBreakHandling()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

#endif


        // Lock the drive in preparation for writes.
        if (!_drive->Lock()) {
            Message->Set(MSG_CANT_LOCK_THE_DRIVE);
            Message->Display("");
            return FALSE;
        }

        dirent.SetStartingCluster(clus);

        dirent.SetFileSize(new_file_size);

        if (!fatdir->Write()) {
            return FALSE;
        }

        if (!Write(Message)) {
            return FALSE;
        }


// Autochk doesn't need control C handling.
#if !defined( _AUTOCHECK_ )

        KEYBOARD::DisableBreakHandling();

#endif


    }

    Message->Set(MSG_RECOV_BYTES_RECOVERED);
    Message->Display("%d%d", new_file_size, old_file_size);

    if (need_delete) {
        DELETE(fatdir);
    }

    return TRUE;

#endif // _SETUP_LOADER_
}


UFAT_EXPORT
BOOLEAN
REAL_FAT_SA::Read(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine reads the super area.  It will succeed if it can
    read the boot sector, the root directory, and at least one of
    the FATs.

    If the position of the internal FAT has not yet been determined,
    this routine will attempt to map it to a readable FAT on the disk.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SECRUN      secrun;
    CONT_MEM    cmem;
    LBN         fat_lbn;
    ULONG       sector_size;
    PCHAR       fat_pos;
    SECTORCOUNT sec_per_fat;
    SECTORCOUNT num_res;
    ULONG       i;
    PFAT        fat;

    if (!SECRUN::Read()) {

        // Possibly cannot read one of the fats

        // Check to see if super area was allocated as formatted.
        if (QueryLength() <= _sec_per_boot) {

            Message->Set(MSG_CANT_READ_BOOT_SECTOR);
            Message->Display("");
            return FALSE;
        }

        // Check the boot sector.
        if (!secrun.Initialize(&_mem, _drive, 0, _sec_per_boot) ||
            !secrun.Read()) {

            // msliger We just failed to read this.  Why unpack it?

            // I don't see any reason to unpack the buffer either.
            // The buffer probably contains unknown data and unpacking
            // it won't do any good unless the intent is to corrupt
            // the _sector_zero.  If that's the case, why not set
            // it to zeros or 0xff or some other known pattern.
            // -DanielCh 3/8/2000

            // UnpackExtendedBios(&_sector_zero,
            //                    (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

            Message->Set(MSG_CANT_READ_BOOT_SECTOR);
            Message->Display("");
            return FALSE;
        }

        // t-raymak Personally, I think it is safer to re-unpack the bios here

        // I have asked RMak about the above comment but he does not remember
        // any of it and I see no reason to change anything right now.
        // -DanielCh 3/8/2000

        UnpackExtendedBios(&_sector_zero,
                           ((PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)secrun.GetBuf()));

        //
        // Note: Make sure that the fat is initialized
        // before the root directory.
        //

        // Check for one good FAT.
        if (_fat) {

            if (!_fat->Read()) {

                Message->Set(MSG_DISK_ERROR_READING_FAT);
                Message->Display("%d", 1 +
                                 (_fat->QueryStartLbn() - _sector_zero.Bpb.ReservedSectors)/
                                 _sector_zero.Bpb.SectorsPerFat);
                return FALSE;

            } else {

                Message->Set(MSG_SOME_FATS_UNREADABLE);
                Message->Display("");

            }

        } else {

            sector_size = _drive->QuerySectorSize();

            num_res = _sector_zero.Bpb.ReservedSectors;

            fat_pos = (PCHAR) SECRUN::GetBuf() + (num_res * sector_size);

            if ( 0 == _sector_zero.Bpb.SectorsPerFat ) {
                sec_per_fat = _sector_zero.Bpb.BigSectorsPerFat;
            } else {
                sec_per_fat = _sector_zero.Bpb.SectorsPerFat;
            }

            for (i = 0; i < QueryFats(); i++) {
                fat_lbn = num_res + (i * sec_per_fat);

                //
                // The FAT32 super area only has one in memory FAT which is always
                // at fat_pos, computed above, regardless of which FAT it happens to be.
                //
                // FAT12/16 drives have all of the FAT(s) in memory.
                //
                if (LARGE32 == _ft) {
                    if (!cmem.Initialize(fat_pos, sec_per_fat * sector_size)) {
                        Message->Set(MSG_FMT_NO_MEMORY);
                        Message->Display("");
                        return FALSE;
                    }
                } else if (!cmem.Initialize(fat_pos + i * sec_per_fat * sector_size,
                                            sec_per_fat * sector_size)) {
                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;
                }

                if (!(fat = NEW FAT)) {
                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;
                }

                if (!fat->Initialize(&cmem, _drive, fat_lbn, _ClusterCount)) {

                    return FALSE;
                }

                if (!fat->Read()) {

                    Message->Set(MSG_DISK_ERROR_READING_FAT);
                    Message->Display("%d", 1 +
                                     (fat->QueryStartLbn() - _sector_zero.Bpb.ReservedSectors)/
                                     _sector_zero.Bpb.SectorsPerFat);
                    DELETE(fat);
                }

                // Break out as soon as there is a good fat
                if (fat) {

                    _fat = fat;
                    break;

                }
            }

            if (!_fat) {
                Message->Set(MSG_CANT_READ_ANY_FAT);
                Message->Display("");

                return FALSE;
            }
        }

        // Check the root directory.
        if ( _dirF32 ) {

            //
            // If _hmem_F32 has not been allocated, _dirF32 has not been properly
            // initialized.
            //
            if (!_hmem_F32) {

                if (!(_hmem_F32 = NEW HMEM)) {

                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;

                }

                if (!_hmem_F32->Initialize()) {
                    Destroy();
                    return FALSE;
                }

                if (!_dirF32->Initialize( _hmem_F32, _drive,
                                          this, _fat,
                                          _sector_zero.Bpb.RootDirStrtClus)) {
                    Destroy();
                    return FALSE;
                }

            }

            if (!_dirF32->Read()) {

                //
                //  Don't bail out immediately after a bad FAT32 root directory
                //  read. Chkdsk may be able to recover part of a damaged
                //  root directory
                //
                DebugPrintTrace(("The FAT32 root directory is damaged.\n"));
            }

        } else {
            if (!_dir || !_dir->Read()) {

                Message->Set(MSG_BAD_DIR_READ);
                Message->Display("%s","\\");
                return FALSE;
            }
        }

    } else {

        UnpackExtendedBios(&_sector_zero,
                           (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

        // Changed to allow FAT 32 passage, KLUDGE?
        if (!_fat && ( ( _dirF32 ) || (QueryLength() > _sec_per_boot))) {
            fat_lbn = _sector_zero.Bpb.ReservedSectors;
            sector_size = _drive->QuerySectorSize();

            //
            // In the case where the SECRUN::Read works for the whole superarea we
            //  simply initialize _fat to point at the first FAT.
            //
            if (!cmem.Initialize((PCHAR) SECRUN::GetBuf() + fat_lbn*sector_size,
                                 QuerySectorsPerFat()*sector_size)) {

                Message->Set(MSG_FMT_NO_MEMORY);
                Message->Display("");
                return FALSE;
            }

            if (!(_fat = NEW FAT)) {

                Message->Set(MSG_FMT_NO_MEMORY);
                Message->Display("");
                return FALSE;
            }

            if (!_fat->Initialize(&cmem, _drive, fat_lbn, _ClusterCount,
                                  QuerySectorsPerFat())) {

                Message->Set(MSG_FMT_NO_MEMORY);
                Message->Display("");
                return FALSE;
            }

            // Complete "FAT_32_Root" FILEDIR initialization after NEW FAT above
            if (LARGE32 == _ft) {

                if (!(_hmem_F32 = NEW HMEM)) {
                    Message->Set(MSG_FMT_NO_MEMORY);
                    Message->Display("");
                    return FALSE;
                }
                // This is part two of init above, we needed _fat defined first !!!!
                if (!_hmem_F32->Initialize()) {

                    Destroy();
                    return FALSE;

                }
                // This is part two of init above, we needed _fat defined first !!!!
                if (!_dirF32->Initialize( _hmem_F32, _drive,
                                          this, _fat,
                                          _sector_zero.Bpb.RootDirStrtClus)) {
                    //
                    //  Don't bail out immediately after a bad FAT32 root directory
                    //  initialization. Chkdsk may be able to recover part of a damaged
                    //  root directory
                    //
                    DebugPrintTrace(("The FAT32 root directory is damaged.\n"));
                    return TRUE;
                }

                if (!_dirF32->Read()) {
                    //
                    //  Don't bail out immediately after a bad FAT32 root directory
                    //  read. Chkdsk may be able to recover part of a damaged
                    //  root directory
                    //
                    DebugPrintTrace(("The FAT32 root directory is damaged.\n"));
                }
            }
        }
    }
    return TRUE;
}


BOOLEAN
REAL_FAT_SA::Write(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine writes the super area.  It will succeed if it can
    write the boot sector, the root directory, and at least one of
    the FATs.

    This routine will duplicate the working FAT to all other FATs
    in the super area.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SECRUN  secrun;
    CONT_MEM    cmem;
    ULONG   i;
    ULONG   fat_size;
    ULONG   sector_size;
    SECTORCOUNT num_res;
    SECTORCOUNT sec_per_fat;
    BOOLEAN FATok;


    // Dup the first FAT in the in memory superarea into all of the other
    // FATs in the in memory super area.
    if (_ft != LARGE32) {
    DupFats();
    }

    PackExtendedBios(&_sector_zero,
        (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

    // Writing the boot sector.
    if (!SECRUN::Write()) {

       if (!_fat || (!_dir && !_dirF32)) {

          Message->Set(MSG_CANT_WRITE_BOOT_SECTOR);
          Message->Display("");
          return FALSE;

       }

       PackExtendedBios(&_sector_zero,
                        (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)SECRUN::GetBuf());

       // Writing the bootstrap code
       if (!secrun.Initialize(&_mem, _drive, 0, _sec_per_boot) ||
           !secrun.Write()) {

          Message->Set(MSG_CANT_WRITE_BOOT_SECTOR);
          Message->Display("");
          return FALSE;
       }


       // Writing the root directory
       if ( !_dir ) {

          if (!_dirF32->Write()) {

             Message->Set(MSG_CANT_WRITE_ROOT_DIR);
             Message->Display("");
             return FALSE;
          }

       } else {

          if (!_dir->Write()) {

             Message->Set(MSG_CANT_WRITE_ROOT_DIR);
             Message->Display("");
             return FALSE;
          }
       }

       // Write the fat(s).

       FATok = FALSE;

       if (_fat->Write()) {
       FATok = TRUE;
       }
       sector_size = _drive->QuerySectorSize();
       num_res = _sector_zero.Bpb.ReservedSectors;
       sec_per_fat = QuerySectorsPerFat();
       fat_size = sec_per_fat*sector_size;
       for (i = 0; i < QueryFats(); i++) {
       if (num_res + (i*sec_per_fat) != _fat->QueryStartLbn()) {


        if(cmem.Initialize((PCHAR)_fat->GetBuf(),fat_size) &&
           secrun.Initialize(&cmem, _drive, num_res + (i*sec_per_fat), sec_per_fat) &&
           secrun.Write()) {

            FATok = TRUE;
        }
       }
       }
       if (!FATok) {
          Message->Set(MSG_BAD_FAT_WRITE);
          Message->Display("");
          return FALSE;
       } else {
          Message->Set(MSG_SOME_FATS_UNWRITABLE);
          Message->Display("");
       }
    } else if (_ft == LARGE32) {
    // SECRUN::Write doesn't write all of the FATs or the FAT32 root directory.

    // Write out the other FATs. Note that any failures on these writes
    // are basically ignored (except for MSG_SOME_FATS_UNWRITABLE) since
    // we already have the first FAT fully written out via SECRUN::Write

    FATok = TRUE;
    sector_size = _drive->QuerySectorSize();
    num_res = _sector_zero.Bpb.ReservedSectors;
    sec_per_fat = QuerySectorsPerFat();
    fat_size = sec_per_fat*sector_size;
    // NOTE that following loop starts at 1 not 0 as FAT 0 is already written out
    for (i = 1; i < QueryFats(); i++) {
        if(!cmem.Initialize((PCHAR) SECRUN::GetBuf() + (num_res * sector_size),fat_size) ||
           !secrun.Initialize(&cmem, _drive, num_res + (i*sec_per_fat), sec_per_fat) ||
           !secrun.Write()) {

            FATok = FALSE;
        }
    }
    if (!FATok) {
        Message->Set(MSG_SOME_FATS_UNWRITABLE);
        Message->Display("");
    }

    // Write out the FAT32 root directory

    if(_dirF32) {
        if (!_dirF32->Write()) {
        Message->Set(MSG_CANT_WRITE_ROOT_DIR);
        Message->Display("");
        return FALSE;
        }
    }
    }

    return TRUE;
}


UFAT_EXPORT
SECTORCOUNT
REAL_FAT_SA::QueryFreeSectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number of unused sectors on disk.

Arguments:

    None.

Return Value:

    The number of free sectors on disk.

--*/
{
    if (!_fat) {
        DebugPrintTrace(("UFAT: Failure to QueryFreeSectors in REAL_FAT_SA\n"));
        return 0;
    }

    return _fat->QueryFreeClusters()*QuerySectorsPerCluster();
}


FATTYPE
REAL_FAT_SA::QueryFatType(
    ) CONST
/*++

Routine Description:

    This routine computes the FATTYPE of the FAT for this volume.

Arguments:

    None.

Return Value:

    The FATTYPE for the FAT.

--*/
{
    return _ft;
}


VOID
REAL_FAT_SA::Destroy(
    )
/*++

Routine Description:

    This routine cleans up the local data in the fat super area.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_fat);
    DELETE(_dir);
    DELETE(_dirF32);
    _StartDataLbn = 0;
    _ClusterCount = 0;
    _sysid = SYSID_NONE;
    _data_aligned = FALSE;
    _AdditionalReservedSectors = MAXULONG;
}

BOOLEAN
REAL_FAT_SA::DupFats(
    )
/*++

Routine Description:

    This routine will duplicate the current FAT to all other FATs
    in the IN MEMORY super area.

    DO NOT call this on FAT32 drives since there is only one in memory FAT
    on FAT32 drives!!!!!!!

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    PCHAR       fat_pos;
    ULONG       fat_size;
    ULONG       sector_size;
    SECTORCOUNT num_res;
    SECTORCOUNT sec_per_fat;

    num_res = _sector_zero.Bpb.ReservedSectors;
    if (!_fat || !_drive || !(sector_size = _drive->QuerySectorSize())) {
        return FALSE;
    }

    if ( 0 == _sector_zero.Bpb.SectorsPerFat ) {
           sec_per_fat = _sector_zero.Bpb.BigSectorsPerFat;
    } else {
        sec_per_fat = _sector_zero.Bpb.SectorsPerFat;
    }
    fat_size = sec_per_fat*sector_size;
    fat_pos = (PCHAR) SECRUN::GetBuf() + num_res*sector_size;

    for (i = 0; i < QueryFats(); i++) {
        if (num_res + i*sec_per_fat != _fat->QueryStartLbn()) {
            memcpy(fat_pos + i*fat_size, _fat->GetBuf(), (UINT) fat_size);
        }
    }

    return TRUE;
}


LBN
REAL_FAT_SA::ComputeStartDataLbn(
    ) CONST
/*++

Routine Description:

    This routine computes the first LBN of the data part of a FAT disk.
    In other words, the LBN of cluster 2.

Arguments:

    None.

Return Value:

    The LBN of the start of data.

--*/
{

    if ( 0 == _sector_zero.Bpb.SectorsPerFat ) {

       return  _sector_zero.Bpb.ReservedSectors +
               _sector_zero.Bpb.Fats*_sector_zero.Bpb.BigSectorsPerFat;
    } else {

       return  _sector_zero.Bpb.ReservedSectors +
               _sector_zero.Bpb.Fats*_sector_zero.Bpb.SectorsPerFat +
               (_sector_zero.Bpb.RootEntries*BytesPerDirent - 1)/
               _drive->QuerySectorSize() + 1;
    }

}


#if !defined(_SETUP_LOADER_)

ULONG
REAL_FAT_SA::ComputeRootEntries(
    ) CONST
/*++

Routine Description:

    This routine uses the size of the disk and a standard table in
    order to compute the required number of root directory entries.

Arguments:

    None.

Return Value:

    The required number of root directory entries.

--*/
{

    if (_ft == LARGE32) {
        return 0;
    }

    switch (_drive->QueryMediaType()) {

        case F3_720_512:
        case F5_360_512:
        case F5_320_512:
        case F5_320_1024:
        case F5_180_512:
        case F5_160_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_720_512:
        case F5_640_512:
        case F3_640_512:
#endif
            return 112;

        case F5_1Pt2_512:
        case F3_1Pt44_512:
#if defined(FE_SB) && defined(_X86_)
        case F3_1Pt2_512:
#endif
            return 224;

        case F3_2Pt88_512:
        case F3_20Pt8_512:
            return 240;

#if defined(FE_SB) && defined(_X86_)
        case F5_1Pt23_1024:
        case F3_1Pt23_1024:
             return 192;

        case F8_256_128:
            return 68;
#endif
    }

    return 512;
}


USHORT
REAL_FAT_SA::ComputeSecClus(
    IN  SECTORCOUNT Sectors,
    IN  FATTYPE     FatType,
#if defined(FE_SB) && defined(_X86_)
    IN  MEDIA_TYPE  MediaType,
    IN  ULONG       SectorSize
#else
    IN  MEDIA_TYPE  MediaType
#endif
    )
/*++

Routine Description:

    This routine computes the number of sectors per cluster required
    based on the actual number of sectors.

Arguments:

    Sectors     - Supplies the total number of sectors on the disk.
    FatType     - Supplies the type of FAT.
    MediaType   - Supplies the type of the media.

Return Value:

    The required number of sectors per cluster.

--*/
{
    USHORT      sec_per_clus;
    SECTORCOUNT threshold;

    if (FatType == LARGE32) {

        if (Sectors >= 64*1024*1024) {
            sec_per_clus = 64;                  /* over 32GB -> 32K */
        } else if (Sectors >= 32*1024*1024) {
            sec_per_clus = 32;                  /* up to 32GB -> 16K */
        } else if (Sectors >= 16*1024*1024) {
            sec_per_clus = 16;                  /* up to 16GB -> 8K */
        } else {
            sec_per_clus = 8;                   /* up to 8GB -> 4K */
        }

        return sec_per_clus;
    }

    if (FatType == SMALL) {
        threshold = MIN_CLUS_BIG;
        sec_per_clus = 1;
    } else {
        threshold = MAX_CLUS_BIG;
        sec_per_clus = 1;
    }

    while (Sectors >= threshold) {
        sec_per_clus *= 2;
        threshold *= 2;
    }

    switch (MediaType) {

        case F5_320_512:
        case F5_360_512:
        case F3_720_512:
        case F3_2Pt88_512:
#if defined(FE_SB) && defined(_X86_)
        case F5_640_512:
        case F3_640_512:
        case F5_720_512:
#endif
            sec_per_clus = 2;
            break;

        case F3_20Pt8_512:
#if defined(FE_SB)
        case F3_128Mb_512:
#if defined(_X86_)
        case F8_256_128:
#endif
#endif
            sec_per_clus = 4;
            break;

#if defined(FE_SB)
        case F3_230Mb_512:
            sec_per_clus = 8;
            break;
#endif

        default:
            break;

    }

    return sec_per_clus;
}

#endif // _SETUP_LOADER_

extern VOID DoInsufMemory(VOID);

BOOLEAN
REAL_FAT_SA::RecoverChain(
    IN OUT  PULONG      StartingCluster,
    OUT     PBOOLEAN    ChangesMade,
    IN      ULONG       EndingCluster,
    IN      BOOLEAN     Replace,
    IN OUT  PBITVECTOR  FatBitMap
    )
/*++

Routine Description:

    This routine will recover the chain beginning with 'StartingCluster'
    in the following way.  It will verify the readability of every cluster
    until it reaches 'EndingCluster' or the end of the chain.  If a cluster
    is not readable then 'ChangesMade' will be set to TRUE, the FAT will
    be marked to indicate that the cluster is bad, and the cluster will be
    taken out of the chain.  Additionally, if 'Replace' is set to TRUE,
    the FAT will be scanned for a readable free cluster to replace the lost
    ones with.  Failure to accomplish this will result in a return value
    of FALSE being returned.

    If the very first cluster of the chain was bad then then
    'StartingCluster' will be set with the new starting cluster of the
    chain even if this starting cluster is past 'EndingCluster'.  If the
    chain is left empty then 'StartingCluster' will be set to zero.

Arguments:

    StartingCluster - Supplies the first cluster of the chain to recover.
    ChangesMade     - Returns TRUE if changes to the chain were made.
    EndingCluster   - Supplies the final cluster to recover.
    Replace         - Supplies whether or not to replace bad clusters with
                      new ones.
    FatBitmap       - Supplies the volume bitmap if it needs to be updated.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST           max_transfer_bytes  = 65536;
    HMEM            hmem;
    CLUSTER_CHAIN   cluster;
    ULONG           clus, prev;
    ULONG           replacement;
    BOOLEAN         finished;
    ULONG           max_clusters;
    ULONG           chain_length;
    ULONG           i;

    DebugAssert(_fat);
    DebugAssert(ChangesMade);
    DebugAssert(StartingCluster);

    if (!hmem.Initialize()) {
    DoInsufMemory();
        return FALSE;
    }

    *ChangesMade = FALSE;
    finished = TRUE;

    max_clusters = (USHORT)(max_transfer_bytes /
                   QuerySectorsPerCluster() /
                   _drive->QuerySectorSize());

    if (!max_clusters) {
        max_clusters = 1;
    }

    chain_length = _fat->QueryLengthOfChain(*StartingCluster);

    for (i = 0; i < chain_length; i += max_clusters) {

        if (!cluster.Initialize(&hmem, _drive, this, _fat,
                                _fat->QueryNthCluster(*StartingCluster, i),
                                min(max_clusters, chain_length - i))) {

            DebugPrintTrace(("Unable to initialize cluster object. i = %d\n, chain_length = %d\n, max_clusters = %d\n", i, chain_length, max_clusters));
            return FALSE;
        }

        if (!cluster.Read()) {

            // Since the quick analysis detected some errors do the slow
            // analysis to pinpoint them.

            finished = FALSE;
            break;
        }
    }

    prev = 0;
    clus = *StartingCluster;

    if (!clus) {
        return TRUE;
    }

    while (!finished) {
        if (!cluster.Initialize(&hmem, _drive, this, _fat, clus, 1)) {
            DebugPrintTrace(("Unable to initialize cluster object.1\n"));
            return FALSE;
        }

        finished = (BOOLEAN) (_fat->IsEndOfChain(clus) || clus == EndingCluster);

        if (!cluster.Read()) {

            // There is a bad cluster so indicate that changes will be made.

            *ChangesMade = TRUE;

            // Take it out of the bitmap if desired

            if (FatBitMap) {
                FatBitMap->ResetBit(clus);
            }

            // Take the bad cluster out of the cluster chain.

            if (prev) {

               _fat->SetEntry(prev, _fat->QueryEntry(clus));
               _fat->SetClusterBad(clus);
               clus = prev;

            } else {

               *StartingCluster = _fat->IsEndOfChain(clus) ? 0 :
                                  _fat->QueryEntry(clus);
               _fat->SetClusterBad(clus);
               clus = 0;

            }


            // If a replacement cluster is wanted then get one.

            if (Replace) {

                if (!(replacement = _fat->AllocChain(1))) {
                    DebugPrintTrace(("Unable to allocate replacement cluster.\n"));
                    return FALSE;
                }


                // Zero fill and write the replacement.

                cluster.Initialize(&hmem, _drive, this, _fat, replacement, 1);
                memset(hmem.GetBuf(), 0, (UINT) hmem.QuerySize());
                cluster.Write();


                if (finished) {
                    EndingCluster = replacement;
                    finished = FALSE;
                }


                // Link in the replacement.

                if (prev) {
                    _fat->InsertChain(replacement, replacement, prev);
                } else {
                    if (*StartingCluster) {
                        _fat->SetEntry(replacement, *StartingCluster);
                    }
                    *StartingCluster = replacement;
                }

                // Mark it in the bitmap if desired

                if (FatBitMap) {
                    DebugAssert(FatBitMap->IsBitSet(replacement) == 0);
                    FatBitMap->SetBit(replacement);
                }
            }
        }

        prev = clus;
        clus = clus ? _fat->QueryEntry(clus) : *StartingCluster;
    }

    return TRUE;
}

ULONG
REAL_FAT_SA::QueryFat32RootDirStartingCluster (
    )
/*++

Routine Description:

    This routine queries the root directory starting cluster from the FAT32 bpb.

Arguments:

    None.

Return Value:

    ULONG - The FAT32 root directory starting cluster.

--*/

{

    // Only FAT32 related code should call this function.
    DebugAssert(_ft == LARGE32);

    return _sector_zero.Bpb.RootDirStrtClus;

}


VOID
REAL_FAT_SA::SetFat32RootDirStartingCluster (
    IN  ULONG   RootCluster
    )
/*++

Routine Description:

    This routine sets the root directory starting cluster in the FAT32 bpb.

Arguments:

    RootCluster - Supplies the new root directory starting cluster.

Return Value:

    None.

--*/

{

    // Only FAT32 related code should call this function.
    DebugAssert(_ft == LARGE32);

    _sector_zero.Bpb.RootDirStrtClus = RootCluster;

}

ULONG
REAL_FAT_SA::SecPerBoot()
{
    return _sec_per_boot;
}

BOOLEAN
REAL_FAT_SA::SetBootCode(
    )
/*++

Routine Description:

    This routine sets the boot code in the super area.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _sector_zero.IntelNearJumpCommand = 0xEB;
    if (_ft == LARGE32)
    _sector_zero.BootStrapJumpOffset  = 0x9058;
    else
    _sector_zero.BootStrapJumpOffset  = 0x903C;
    SetBootSignature();
    return TRUE;
}

BOOLEAN
REAL_FAT_SA::SetPhysicalDriveType(
    IN  PHYSTYPE    PhysType
    )
/*++

Routine Description:

    This routine sets the physical drive type in the super area.

Arguments:

    PhysType    - Supplies the physical drive type.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _sector_zero.PhysicalDrive = (UCHAR)PhysType;
    return TRUE;
}

INLINE
BOOLEAN
REAL_FAT_SA::SetOemData(
    )
/*++

Routine Description:

    This routine sets the OEM data in the super area.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    memcpy( (void*)_sector_zero.OemData, (void*)OEMTEXT, OEMTEXTLENGTH);
    return TRUE;
}

BOOLEAN
REAL_FAT_SA::SetSignature(
    )
/*++

Routine Description:

    This routine sets the sector zero signature in the super area.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!_sector_sig) {
        DebugPrintTrace(("UFAT: Failure to SetSignature in REAL_FAT_SA\n"));
        return FALSE;
    }

    *_sector_sig = sigSUPERSEC1;
    *(_sector_sig + 1) = sigSUPERSEC2;

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::VerifyBootSector(
    )
/*++

Routine Description:

    This routine checks key parts of sector 0 to insure that the data
    being examined is indeed a zero sector.

Arguments:

    None.

Return Value:

    FALSE   - Invalid sector zero.
    TRUE    - Valid sector zero.

--*/
{
    PUCHAR  p;

// We don't check for 55 AA anymore because we have reason to
// believe that there are versions of FORMAT out there that
// don't put it down.

#if 0
    if (!IsFormatted()) {
        return FALSE;
    }
#endif

    p = (PUCHAR) GetBuf();

#if defined(FE_SB) &&  defined(_X86_)
    return p[0] == 0x49 ||  /* FMR */
           p[0] == 0xE9 ||
          (p[0] == 0xEB && p[2] == 0x90);
#else
    return p[0] == 0xE9 || (p[0] == 0xEB && p[2] == 0x90);
#endif
}

ULONG
REAL_FAT_SA::QuerySectorFromCluster(
    IN  ULONG   Cluster,
    OUT PUCHAR  NumSectors
    )
{
    if (NULL != NumSectors) {
        *NumSectors = (UCHAR)QuerySectorsPerCluster();
    }

    return (Cluster - FirstDiskCluster)*QuerySectorsPerCluster() +
           QueryStartDataLbn();
}

BOOLEAN
REAL_FAT_SA::IsClusterCompressed(
    IN  ULONG
    ) CONST
{
    return FALSE;
}

VOID
REAL_FAT_SA::SetClusterCompressed(
    IN  ULONG,
    IN  BOOLEAN fCompressed
    )
{
    if (fCompressed) {
        DebugAssert("REAL_FAT_SA shouldn't have compressed clusters.");
    }
}

UCHAR
REAL_FAT_SA::QuerySectorsRequiredForPlainData(
        IN      ULONG
        )
{
    DebugAssert("REAL_FAT_SA didn't expect call to QuerySectorsRequiredForPlainData\n");
    return 0;

}

BOOLEAN
REAL_FAT_SA::VerifyFatExtensions(
    FIX_LEVEL, PMESSAGE, PBOOLEAN
    )
{
    //
    // We have no fat extensions, we're real.
    //

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::CheckSectorHeapAllocation(
    FIX_LEVEL, PMESSAGE, PBOOLEAN
    )
{
    //
    // We have no sector heap, we're real.
    //

    return TRUE;
}

BOOLEAN
REAL_FAT_SA::AllocateClusterData(
    ULONG, UCHAR, BOOLEAN, UCHAR
    )
{
    DebugAbort("Didn't expect REAL_FAT_SA::AllocateClusterData to be "
        "called.");
    return FALSE;
}

BOOLEAN
REAL_FAT_SA::FreeClusterData(
    ULONG
    )
{
    DebugAbort("Didn't expect REAL_FAT_SA::FreeClusterData to be "
        "called.");
    return FALSE;
}

BYTE
REAL_FAT_SA::QueryVolumeFlags(
    ) CONST
/*++

Routine Description:

    This routine returns the volume flags byte from the bpb.

Arguments:

    None.

Return Value:

    The flags.

--*/
{
    ULONG clus1;
    BYTE  CurrHd;

    if(_fat) {
    clus1 = _fat->QueryEntry(1);
    } else {
    clus1 = 0x0FFFFFFF;
    }
    CurrHd = _sector_zero.CurrentHead;

    if (_ft == LARGE32) {
        if((!(CurrHd & FAT_BPB_RESERVED_DIRTY)) && (!(clus1 & CLUS1CLNSHUTDWNFAT32))) {
            CurrHd |= FAT_BPB_RESERVED_DIRTY;
        }
        if((!(CurrHd & FAT_BPB_RESERVED_TEST_SURFACE)) && (!(clus1 & CLUS1NOHRDERRFAT32))) {
            CurrHd |= FAT_BPB_RESERVED_TEST_SURFACE;
        }
    } else if (_ft == LARGE16) {
        if((!(CurrHd & FAT_BPB_RESERVED_DIRTY)) && (!(clus1 & CLUS1CLNSHUTDWNFAT16))) {
            CurrHd |= FAT_BPB_RESERVED_DIRTY;
        }
        if((!(CurrHd & FAT_BPB_RESERVED_TEST_SURFACE)) && (!(clus1 & CLUS1NOHRDERRFAT16))) {
            CurrHd |= FAT_BPB_RESERVED_TEST_SURFACE;
        }
    }
    return(CurrHd);
}

VOID
REAL_FAT_SA::SetVolumeFlags(
    BYTE Flags,
    BOOLEAN ResetFlags
    )
/*++

Routine Description:

    This routine sets the volume flags in the bpb.

Arguments:

    Flags       -- flags to set or clear
    ResetFlags  -- if true, Flags are cleared instead of set

Return Value:

    None.

--*/
{
    ULONG clus1;

    if (ResetFlags) {
        _sector_zero.CurrentHead &= ~Flags;
        if(_fat) {
            clus1 = _fat->QueryEntry(1);
            if (_ft == LARGE32) {
            if(Flags & FAT_BPB_RESERVED_DIRTY) {
                clus1 |= CLUS1CLNSHUTDWNFAT32;
            }
            if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
                clus1 |= CLUS1NOHRDERRFAT32;
            }
            } else if (_ft == LARGE16) {
            if(Flags & FAT_BPB_RESERVED_DIRTY) {
                clus1 |= CLUS1CLNSHUTDWNFAT16;
            }
            if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
                clus1 |= CLUS1NOHRDERRFAT16;
            }
            }
            _fat->SetEntry(1, clus1);
        }
    } else {
        _sector_zero.CurrentHead |= Flags;
        if(_fat) {
            clus1 = _fat->QueryEntry(1);
            if (_ft == LARGE32) {
            if(Flags & FAT_BPB_RESERVED_DIRTY) {
                clus1 &= ~CLUS1CLNSHUTDWNFAT32;
            }
            if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
                clus1 &= ~CLUS1NOHRDERRFAT32;
            }
            } else if (_ft == LARGE16) {
            if(Flags & FAT_BPB_RESERVED_DIRTY) {
                clus1 &= ~CLUS1CLNSHUTDWNFAT16;
            }
            if(Flags & FAT_BPB_RESERVED_TEST_SURFACE) {
                clus1 &= ~CLUS1NOHRDERRFAT16;
            }
            }
            _fat->SetEntry(1, clus1);
        }
    }
}

BOOLEAN
REAL_FAT_SA::IsFileContiguous(
    IN      ULONG       StartingCluster
    ) CONST
/*++

Routine Description:

    This routine computes the number of contiguous blocks for the given
    starting cluster.  If the file has only one block then the file is contiguous and
    this function returns TRUE.  Otherwise this function returns FALSE.

Arguments:

    StartingClustere    - Supplies the starting cluster of the file.

Return Value:

    FALSE   - The file is not contiguous.
    TRUE    - The file is contiguous.

--*/
{
    ULONG   num_blocks;

    DebugAssert(_fat);
    DebugAssert(_fat->IsInRange(StartingCluster));

    if (_fat == NULL || !_fat->IsInRange(StartingCluster)) {
        return FALSE;
    }

    for (num_blocks = 1; ; num_blocks++) {
        while (!_fat->IsEndOfChain(StartingCluster) &&
               (ULONG)(StartingCluster + 1) == _fat->QueryEntry(StartingCluster)) {
            StartingCluster++;
        }
        if (_fat->IsEndOfChain(StartingCluster)) {
            return TRUE;
        }
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\rootdir.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    rootdir.cxx

Abstract:

    This class is an implementation of FATDIR for the FAT root directory.

Author:

    Norbert P. Kusters (norbertk) 4-Dec-90

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( ROOTDIR, FATDIR, UFAT_EXPORT );

VOID
ROOTDIR::Construct (
        )
/*++

Routine Description:

    Constructor for ROOTDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
        _number_of_entries = 0;
}

extern VOID DoInsufMemory(VOID);

UFAT_EXPORT
ROOTDIR::~ROOTDIR(
    )
/*++

Routine Description:

    Destructor for ROOTDIR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
ROOTDIR::Initialize(
    IN      PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LBN                 StartingSector,
    IN      LONG                NumberOfEntries
    )
/*++

Routine Description:

    This routine initializes the ROOTDIR object by specifying a drive,
    a position and a size.

Arguments:

    Mem             - Supplies the memory for the run of sectors.
    Drive           - Supplies the drive where the root directory is.
    StartingSector  - Supplies the starting sector of the root directory.
    NumberOfEntries - Supplies the number of entries in the root directory.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG        sector_size;
    SECTORCOUNT n;

    Destroy();

    if (!Drive || !(sector_size = Drive->QuerySectorSize())) {
        DebugPrintTrace(("UFAT: Failure to initialize ROOTDIR\n"));
        Destroy();
        return FALSE;
    }

    _number_of_entries = NumberOfEntries;

    n = (BytesPerDirent*NumberOfEntries - 1)/sector_size + 1;

    if (!_secrun.Initialize(Mem, Drive, StartingSector, n)) {
        DoInsufMemory();
        Destroy();
        return FALSE;
    }

    return TRUE;
}


VOID
ROOTDIR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.  Init must be
    called for this routine to be useful again.  This routine will
    free up memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _number_of_entries = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\memtrace\memtrace.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	memtrace.c

Abstract:

	This function contains an extension to NTSD that allows tracing of
	memory usage when ULIB objects are compiled with the MEMLEAK flag
	defined.

Author:

	Barry Gilhuly (W-Barry) 25-July-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>

#include <string.h>

#include "memtrace.h"


VOID
DumpToFile( char *OutString, ... )
{
	DWORD bytes;

	bytes = strlen( OutString );
	WriteFile( hFile, OutString, bytes, &bytes, NULL );
	return;
}

VOID
MemTrace(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
	the current contents of the Mem list.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        critical section to be dumped (e.g.  ntdll!FastPebLock,
        csrsrv!CsrProcessStructureLock...).


Return Value:

    None.

--*/

{
	DWORD		AddrMem;

	BOOL		b;
	DWORD		i;

	PMEM_BLOCK	MemListNext;
	MEM_BLOCK	MemObject;
	CHAR		Symbol[64];
	CHAR		Buffer[ 128 ];
	DWORD		Displacement;

	PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
	PNTSD_OUTPUT_ROUTINE lpAlternateOutputRoutine;

    PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
    PNTSD_GET_SYMBOL lpGetSymbolRoutine;

    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(dwCurrentPc);
	UNREFERENCED_PARAMETER(lpArgumentString);

    lpOutputRoutine = lpExtensionApis->lpOutputRoutine;
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine;
	lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;

	//
	// Attempt to use the input string as a file name...
	//
	if( ( hFile = CreateFile( lpArgumentString,
							  GENERIC_WRITE,
							  0,
							  NULL,
							  CREATE_ALWAYS,
							  FILE_ATTRIBUTE_NORMAL,
							  0
							) ) == (HANDLE)-1 ) {
		//
		// Unable to open the file - send all output to the screen.
		//
		lpAlternateOutputRoutine = lpExtensionApis->lpOutputRoutine;

	} else {

		lpAlternateOutputRoutine = DumpToFile;

	}



	//
	// Get the address of the head of the memleak list...
	//
	AddrMem = (lpGetExpressionRoutine)("Ulib!pmemHead");
	if ( !AddrMem ) {
		(lpOutputRoutine)( "Unable to find the head of the Mem List!\n" );
		if( hFile != (HANDLE)-1 ) {
			CloseHandle( hFile );
		}
		return;
	}
	if( !ReadProcessMemory(
            hCurrentProcess,
			(LPVOID)AddrMem,
			&MemListNext,
			sizeof( PMEM_BLOCK ),
            NULL
			) ) {
		if( hFile != (HANDLE)-1 ) {
			CloseHandle( hFile );
		}
		return;
	}

	//
	// Traverse the list of Mem blocks stopping when the head hits the
	// tail...At this point, the head of the list should be indicated
	// by MemListHead and the tail by MemListTail.	Since the first element
	// in the list is a dummy entry, it can be skipped...
	//
	do {

		if( !ReadProcessMemory(
				hCurrentProcess,
				(LPVOID)MemListNext,
				&MemObject,
				sizeof( MEM_BLOCK ),
				NULL
				) ) {
			return;
		}

		if( MemObject.memsig != Signature ) {

			//
			// This is an unrecognized memory block - die...
			//
			(lpOutputRoutine)( "Invalid block found!\n" );
			return;
		}

		//
		// Display the stored info - First the File, Line and Size of the
		// memory block allocated.	Then the stack trace...
		//
		sprintf( Buffer, "File: %s, Line: %ld, Size: %ld\n", MemObject.file,
				 MemObject.line, MemObject.size
			   );
		( lpAlternateOutputRoutine )( Buffer );

		//
		// This should dump the stack trace which was stored...
		//
		for( i = 0; ( i < MaxCallStack ) && ( MemObject.call[ i ] != 0 ); i++ ) {

			(lpGetSymbolRoutine)( ( LPVOID )( MemObject.call[ i ] ),
								  Symbol,
								  &Displacement
								);
			sprintf( Buffer, "\t%s\n", Symbol );
			( lpAlternateOutputRoutine )( Buffer );

		}
		( lpAlternateOutputRoutine )( "\n" );


	} while( ( MemListNext = MemObject.pmemNext ) != NULL );



	(lpOutputRoutine)( "\n...End of List...\n" );

	if( hFile != (HANDLE)-1 ) {

		( lpAlternateOutputRoutine )( "\n...End of List...\n" );
		CloseHandle( hFile );

	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\memtrace\memtrace.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	memtrace.h

Abstract:

	This function contains an extension to NTSD that allows tracing of
	memory usage when ULIB objects are compiled with the MEMLEAK flag
	defined.

Author:

	Barry Gilhuly (W-Barry) 25-July-91

Revision History:

--*/

//
// The following was ripped off from ULIBDEF.HXX and NEWDELP.HXX
//
#define CONST		const
typedef ULONG		MEM_BLOCKSIG;

//
// MEM_BLOCK header signature type and value.
//
CONST MEM_BLOCKSIG		Signature		= 0xDEADDEAD;

//
// Maximum length of caller's file name.
//

#define	MaxFileLength	20

//
// Maximum size of call stack recorded.
//

#define	MaxCallStack	20

//
// MEM_BLOCK is the header attached to all allocated memory blocks.
// Do not change the order of these fields without fixing the initialization
// of the dummy MEM_BLOCK in newdel.cxx.
//

typedef struct _MEM_BLOCK {
	struct _MEM_BLOCK*		pmemNext;
	struct _MEM_BLOCK*		pmemPrev;
	MEM_BLOCKSIG			memsig;
	ULONG					line;
	ULONG					size;
	char					file[ MaxFileLength ];
	DWORD					call[ MaxCallStack ];
} MEM_BLOCK, *PMEM_BLOCK;

//
// File handle for data destination...
//
HANDLE		hFile;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ufat\src\ufat.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        ufat.cxx

Abstract:

        This module contains run-time, global support for the
        FAT IFS Utilities library (UFAT).       This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Bill McJohn (billmc) 30-May-1991

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ulib.hxx"
#include "ufat.hxx"

extern "C" {
    #include <patchbc.h>
    #include "rtmsg.h"
}


#ifdef _AUTOCHECK_

BOOLEAN
SimpleFetchMessageTextInOemCharSet(
    IN  ULONG  MessageId,
    OUT CHAR  *Text,
    IN  ULONG  BufferLen
    );

#endif

//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

BOOLEAN
PatchFatAndFat32BootCodeMessages(
    VOID
    );

extern "C"
UFAT_EXPORT
BOOLEAN
InitializeUfat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

UFAT_EXPORT
BOOLEAN
InitializeUfat (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Ufat by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#if defined(FE_SB) && defined(_X86_)
    if (Reason == DLL_PROCESS_ATTACH) {
        //
        // Initialize Machine Id
        //
        InitializeMachineData();
    }
#endif

#if _AUTOCHECK_

    UNREFERENCED_PARAMETER( Reason );

    if(!PatchFatAndFat32BootCodeMessages()) {
        DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
        return(FALSE);
    }

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Ufat initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_UFAT_MEM_LEAK)
    DebugPrint("UFAT.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
            //
            // Get translated boot messages into FAT boot code.
            //
            if(!PatchFatAndFat32BootCodeMessages()) {
                //
                // Internal error only, don't worry about translating it.
                //
                MessageBoxA(
                    NULL,
                    "Internal error: Translated boot messages are too long or missing.",
                    "ULIB.DLL (UFAT.DLL)",
                    MB_ICONERROR | MB_SYSTEMMODAL | MB_OK
                    );

                DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
                return(FALSE);
            }

            // Success, FALL THROUGH to thread attach case

        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrintTrace(("UFAT.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Ufat initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_UFAT_MEM_LEAK)
            DebugPrint("UFAT.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrintTrace(("UFAT.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrint("UFAT.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_UFAT_MEM_LEAK)
                DebugPrint("UFAT.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif _AUTOCHECK_ || _SETUP_LOADER_

    return TRUE;
}



DECLARE_CLASS(  CLUSTER_CHAIN           );
DECLARE_CLASS(  EA_HEADER               );
DECLARE_CLASS(  EA_SET                  );
DECLARE_CLASS(  FAT                     );
DECLARE_CLASS(  FATDIR                  );
DECLARE_CLASS(  FAT_DIRENT              );
DECLARE_CLASS(  FAT_SA                  );
DECLARE_CLASS(  FAT_VOL                 );
#ifdef DBLSPACE_ENABLED
DECLARE_CLASS(  FATDB_VOL               );
#endif // DBLSPACE_ENABLED
DECLARE_CLASS(  FILEDIR                 );
DECLARE_CLASS(  HASH_INDEX              );
DECLARE_CLASS(  ROOTDIR                 );
DECLARE_CLASS(  RELOCATION_CLUSTER      );
#ifdef DBLSPACE_ENABLED
DECLARE_CLASS(  CVF_FAT_EXTENS          );
#endif // DBLSPACE_ENABLED
DECLARE_CLASS(  REAL_FAT_SA             );
#ifdef DBLSPACE_ENABLED
DECLARE_CLASS(  FATDB_SA                );
#endif // DBLSPACE_ENABLED


STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
        if( DEFINE_CLASS_DESCRIPTOR( CLUSTER_CHAIN          ) &&
#ifdef DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( CVF_FAT_EXTENS         ) &&
#endif // DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( EA_HEADER              ) &&
            DEFINE_CLASS_DESCRIPTOR( EA_SET                 ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT                    ) &&
#ifdef DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FATDB_SA               ) &&
#endif // DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FATDIR                 ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT_DIRENT             ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT_SA                 ) &&
            DEFINE_CLASS_DESCRIPTOR( FAT_VOL                ) &&
#ifdef DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FATDB_VOL              ) &&
#endif // DBLSPACE_ENABLED
            DEFINE_CLASS_DESCRIPTOR( FILEDIR                ) &&
            DEFINE_CLASS_DESCRIPTOR( HASH_INDEX             ) &&
            DEFINE_CLASS_DESCRIPTOR( RELOCATION_CLUSTER     ) &&
            DEFINE_CLASS_DESCRIPTOR( REAL_FAT_SA            ) &&
            DEFINE_CLASS_DESCRIPTOR( ROOTDIR                )
        ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR( CLUSTER_CHAIN          );
#ifdef DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( CVF_FAT_EXTENS         );
#endif // DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( EA_HEADER              );
    UNDEFINE_CLASS_DESCRIPTOR( EA_SET                 );
    UNDEFINE_CLASS_DESCRIPTOR( FAT                    );
#ifdef DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FATDB_SA               );
#endif // DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FATDIR                 );
    UNDEFINE_CLASS_DESCRIPTOR( FAT_DIRENT             );
    UNDEFINE_CLASS_DESCRIPTOR( FAT_SA                 );
    UNDEFINE_CLASS_DESCRIPTOR( FAT_VOL                );
#ifdef DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FATDB_VOL              );
#endif // DBLSPACE_ENABLED
    UNDEFINE_CLASS_DESCRIPTOR( FILEDIR                );
    UNDEFINE_CLASS_DESCRIPTOR( HASH_INDEX             );
    UNDEFINE_CLASS_DESCRIPTOR( RELOCATION_CLUSTER     );
    UNDEFINE_CLASS_DESCRIPTOR( REAL_FAT_SA            );
    UNDEFINE_CLASS_DESCRIPTOR( ROOTDIR                );
    return TRUE;
}


BOOLEAN
PatchFatAndFat32BootCodeMessages(
    VOID
    )
{
    CHAR NtldrMissing[100];
    CHAR DiskError[100];
    CHAR PressKey[100];

    extern UCHAR FatBootCode[512];
    extern UCHAR Fat32BootCode[512*3];

    //
    // Get message text.
    //
#ifdef _AUTOCHECK_
    //
    // ntlib.lib, messages are in the binary being run.
    //
    {
        BOOLEAN b;

        b = SimpleFetchMessageTextInOemCharSet(
                MSG_BOOT_FAT_NTLDR_MISSING,
                NtldrMissing,
                sizeof(NtldrMissing)
                );

        if(b) {
            b = SimpleFetchMessageTextInOemCharSet(
                    MSG_BOOT_FAT_IO_ERROR,
                    DiskError,
                    sizeof(DiskError)
                    );

            if(b) {
                b = SimpleFetchMessageTextInOemCharSet(
                        MSG_BOOT_FAT_PRESS_KEY,
                        PressKey,
                        sizeof(PressKey)
                        );
            }
        }

        if(!b) {
            return(FALSE);
        }

    }
#else
    //
    // Win32 case, messages are in ulib.dll.
    //
    {
        HINSTANCE h;
        DWORD d;

        h = LoadLibraryEx(TEXT("ULIB"),NULL,LOAD_LIBRARY_AS_DATAFILE);
        if(!h) {
            return(FALSE);
        }

        d = FormatMessageA(
                FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                h,
                MSG_BOOT_FAT_NTLDR_MISSING,
                0,
                NtldrMissing,
                sizeof(NtldrMissing),
                NULL
                );

        if(d) {

            d = FormatMessageA(
                    FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                    h,
                    MSG_BOOT_FAT_IO_ERROR,
                    0,
                    DiskError,
                    sizeof(DiskError),
                    NULL
                    );

            if(d) {
                d = FormatMessageA(
                        FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                        h,
                        MSG_BOOT_FAT_PRESS_KEY,
                        0,
                        PressKey,
                        sizeof(PressKey),
                        NULL
                        );
            }
        }

        FreeLibrary(h);
        if(!d) {
            return(FALSE);
        }

        CharToOemA(NtldrMissing,NtldrMissing);
        CharToOemA(DiskError,DiskError);
        CharToOemA(PressKey,PressKey);
    }
#endif

    //
    // Call code in patchbc.lib to do the patching now that we've got
    // the translated message text.
    //
    if(!PatchMessagesIntoFatBootCode(FatBootCode,FALSE,NtldrMissing,DiskError,PressKey)
    || !PatchMessagesIntoFatBootCode(Fat32BootCode,TRUE,NtldrMissing,DiskError,PressKey)) {

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\achkmsg.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    achkmsg.ccxx

Abstract:

    This is the message class for autochk.

Author:

    Norbert P. Kusters (norbertk) 3-Jun-91

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "achkmsg.hxx"
#include "basesys.hxx"
#include "rtmsg.h"

extern "C" {
#include <ntddkbd.h>
#include <stdio.h>
}

DEFINE_CONSTRUCTOR(AUTOCHECK_MESSAGE, MESSAGE);

#define KEYBOARD_DEVICE_OBJECT_INCREMENTS   5
#define KEYBOARD_READ_BUFFER_SIZE           (3*sizeof(ULONG)/sizeof(UCHAR))

AUTOCHECK_MESSAGE::~AUTOCHECK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for AUTOCHECK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
AUTOCHECK_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
AUTOCHECK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
AUTOCHECK_MESSAGE::Initialize(
    IN BOOLEAN  DotsOnly
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    DotsOnly    - Autochk should produce only dots instead of messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _dots_only = DotsOnly;
    return MESSAGE::Initialize();
}


BOOLEAN
AUTOCHECK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR            buffer[256];
    DSTRING         display_string;
    UNICODE_STRING  unicode_string;
    PWSTR           dis_str;
    UNICODE_STRING  uDot;

    RtlInitUnicodeString(&uDot, L".");

    if (!BASE_SYSTEM::QueryResourceStringV(&display_string, GetMessageId(), Format,
                                           VarPointer)) {
        return FALSE;
    }

   if (!(dis_str = display_string.QueryWSTR())) {
        return FALSE;
    }

    unicode_string.Length = (USHORT)display_string.QueryChCount()*sizeof(WCHAR);
    unicode_string.MaximumLength = unicode_string.Length;
    unicode_string.Buffer = dis_str;

    if (!_dots_only && MSG_HIDDEN_STATUS != GetMessageId()) {
        NtDisplayString(&unicode_string);
    }

    if (IsLoggingEnabled() && !IsSuppressedMessage()) {
        LogMessage(&display_string);
    }

    // If we're printing dots only, we print a dot for each interesting
    // message.  The interesting messages are those that aren't suppressed
    // except VOLUME_CLEAN and FILE_SYSTEM_TYPE, which we want to print a
    // dot for regardless.

    if (_dots_only && (!IsSuppressedMessage() ||
                       MSG_CHK_VOLUME_CLEAN == GetMessageId() ||
                       MSG_FILE_SYSTEM_TYPE == GetMessageId())) {
        NtDisplayString(&uDot);
    }

    // Send the output to the debug port, too.
    //
    if (MSG_HIDDEN_STATUS != GetMessageId() &&
        display_string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {

        DebugPrint( buffer );
    }

    DELETE(dis_str);

    return TRUE;
}

BOOLEAN
AUTOCHECK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries a response of yes or no.

Arguments:

    Default - Supplies a default in the event that a query is not possible.

Return Value:

    FALSE   - The answer is no.
    TRUE    - The answer is yes.

--*/
{
    PWSTR           dis_str;
    UNICODE_STRING  unicode_string;
    DSTRING         string;

    if (!BASE_SYSTEM::QueryResourceString(&string, Default ? MSG_YES : MSG_NO, "")) {
        return Default;
    }

    if (!(dis_str = string.QueryWSTR())) {
        return Default;
    }

    unicode_string.Length = (USHORT)string.QueryChCount()*sizeof(WCHAR);
    unicode_string.MaximumLength = unicode_string.Length;
    unicode_string.Buffer = dis_str;

    NtDisplayString(&unicode_string);

    if (!IsSuppressedMessage()) {
        LogMessage(&string);
    }

    DELETE(dis_str);

    return Default;
}


PMESSAGE
AUTOCHECK_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    PAUTOCHECK_MESSAGE  p;

    if (!(p = NEW AUTOCHECK_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize()) {
        DELETE(p);
        return NULL;
    }

    return p;
}

BOOLEAN
AUTOCHECK_MESSAGE::SetDotsOnly(
    IN  BOOLEAN         DotsOnlyState
    )
/*++

Routine Description:

    This routine modifies the output mode, changing whether full
    output is printed, or just dots.

Arguments:

    DotsOnlyState   - TRUE if only dots should be printed.

Return Value:

    The previous state.

--*/
{
    BOOLEAN b;

    b = _dots_only;

    _dots_only = DotsOnlyState;

    if (b && !_dots_only) {
        //
        // Going from dots-only to full output, want to reset to the
        // beginning of the next output line.
        //

        DisplayMsg(MSG_BLANK_LINE);
    }
    return b;
}

BOOLEAN
AUTOCHECK_MESSAGE::IsInAutoChk(
    )
/*++

Routine Description:

    This routine returns TRUE if it is in the regular autochk and not related
    to setup.  This relys on setup using the /s or /t option all the time.

Arguments:

    None.

Return Value:

    TRUE    - if in regular autochk

--*/
{
    return TRUE;
}

VOID
STATIC
CloseNHandles(
    IN     ULONG    Count,
    IN     PHANDLE  Handles
    )
{
    if (Handles == NULL)
        return;

    while (Count > 0) {
        NtClose(Handles[--Count]);
    }
}

BOOLEAN
AUTOCHECK_MESSAGE::IsKeyPressed(
    MSGID       MsgId,
    ULONG       TimeOutInSeconds
    )
/*++

Routine Description:

    Check to see if the user has hit any key within the timeout period.

Arguments:

    MsgId            - Supplies the message Id to be displayed
    TimeOutInSeconds - Supplies the count down time in seconds

Return Value:

    TRUE    - A key is pressed within the timeout period.
    FALSE   - No key has been pressed or there is an error

--*/
{
    PHANDLE             e = NULL;
    PHANDLE             h = NULL;
    PIO_STATUS_BLOCK    Iosb = NULL;
    PUCHAR              buf = NULL;
    PHANDLE             e1;
    PHANDLE             h1;
    PIO_STATUS_BLOCK    Iosb1;
    ULONG               i, j;
    NTSTATUS            status;
    LARGE_INTEGER       one_second;
    LARGE_INTEGER       dummy;
    ULONG               timeRemaining;
    BOOLEAN             keyPressed = FALSE;
    BOOLEAN             logging_state;
    WCHAR               dev_name[MAX_PATH];
    BOOLEAN             error = FALSE;

    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   ObjAttr;

#if !defined(RUN_ON_NT4)
    EXECUTION_STATE     prev_state, dummy_state;
    NTSTATUS            es_status;
#endif

    dummy.QuadPart = 0;

    for (i=0; i<100; i++) {

        if ((i % KEYBOARD_DEVICE_OBJECT_INCREMENTS) == 0) {

            // allocate additional elements each time

            if (i == 0) {

                // first time

                KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                           "ULIB: IsKeyPressed: Allocating memory the first time\n"));

                h1 = (PHANDLE)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(HANDLE));
                e1 = (PHANDLE)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(HANDLE));
                Iosb1 = (PIO_STATUS_BLOCK)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(IO_STATUS_BLOCK));

            } else {

                KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                           "ULIB: IsKeyPressed: Allocating additional memory\n"));

                h1 = (PHANDLE)REALLOC(h, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(HANDLE));
                e1 = (PHANDLE)REALLOC(e, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(HANDLE));
                Iosb1 = (PIO_STATUS_BLOCK)REALLOC(Iosb, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(IO_STATUS_BLOCK));
            }

            if (h1 == NULL || Iosb1 == NULL || e1 == NULL) {
                DebugPrintTrace(("ULIB: IsKeyPressed: Out of memory\n"));
                error = TRUE;
                break;
            }

            memset(&(h1[i]), 0, sizeof(HANDLE)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);
            memset(&(e1[i]), 0, sizeof(HANDLE)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);
            memset(&(Iosb1[i]), 0, sizeof(IO_STATUS_BLOCK)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);

            h = h1;
            e = e1;
            Iosb = Iosb1;
        }

        swprintf(dev_name, DD_KEYBOARD_DEVICE_NAME_U L"%d", i);
        RtlInitUnicodeString(&u, dev_name);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: IsKeyPressed: Opening device %ls\n", dev_name));

        InitializeObjectAttributes(&ObjAttr,
                                   &u,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: IsKeyPressed: Initializing handle %d\n", i));

        status = NtCreateFile(&h[i],
                              GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                              &ObjAttr,
                              &Iosb[i],
                              NULL,                                 /* AllocationSize */
                              FILE_ATTRIBUTE_NORMAL,                /* FileAttributes */
                              0,                                    /* ShareAccess */
                              FILE_OPEN,                            /* CreateDisposition */
                              // the directory bit is to tell the keyboard driver to let
                              // this user mode process to open the keyboard
                              FILE_DIRECTORY_FILE,                  /* CreateOptions */
                              NULL,                                 /* EaBuffer */
                              0);                                   /* EaLength */

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_OBJECT_NAME_NOT_FOUND)
                break;  // found all keyboards and exit this loop

            DebugPrintTrace(("ULIB: IsKeyPressed: Unable to open keyboard device %d (%x)\n", i, status));
            h[i] = NULL;
            error = TRUE;
            break;
        }

        InitializeObjectAttributes(&ObjAttr,
                                   NULL,
                                   0L,
                                   NULL,
                                   NULL);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: IsKeyPressed: Initializing event %d\n", i));

        status = NtCreateEvent(&e[i],
                               FILE_ALL_ACCESS,
                               &ObjAttr,
                               SynchronizationEvent,
                               FALSE);

        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("ULIB: IsKeyPressed: Unable to create event %d (%x)\n", i, status));
            error = TRUE;
            e[i] = NULL;
            break;
        }
    }

    if (!error) {
        buf = (PUCHAR)CALLOC(i, KEYBOARD_READ_BUFFER_SIZE);

        if (buf == NULL) {
            DebugPrintTrace(("ULIB: IsKeyPressed: Out of memory\n"));
            error = TRUE;
        }
    }

    if (!error) {

        one_second.QuadPart = -10000000;

        timeRemaining = TimeOutInSeconds;

        logging_state = IsLoggingEnabled();
        SetLoggingEnabled(FALSE);

#if !defined(RUN_ON_NT4)
        es_status = NtSetThreadExecutionState(ES_CONTINUOUS|
                                              ES_DISPLAY_REQUIRED|
                                              ES_SYSTEM_REQUIRED,
                                              &prev_state);
        if (!NT_SUCCESS(es_status)) {
            DebugPrintTrace(("ULIB: IsKeyPressed: Unable to set thread execution state (%x)\n", es_status));
        }
#endif

        DisplayMsg(MsgId, "%d", timeRemaining);

        for (j=0; j<i; j++) {
            status = NtReadFile(h[j], e[j], NULL, NULL,
                                &(Iosb[j]), &(buf[j]), KEYBOARD_READ_BUFFER_SIZE,
                                &dummy, NULL);

            if (!NT_SUCCESS(status)) {
                DebugPrintTrace(("\nULIB: IsKeyPressed: Read failure from keyboard %d (%x)\n", j, status));
                break;
            }
        }

        if (NT_SUCCESS(status)) {
            do {
                status = NtWaitForMultipleObjects(i, e, WaitAny, TRUE, &one_second);

                if (status == STATUS_TIMEOUT) {

                    timeRemaining--;
                    DisplayMsg(MsgId, "%d", timeRemaining);

                } else if (NT_SUCCESS(status)) {

                    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                               "ULIB: IsKeyPressed: NtWaitForMultipleObjects index %d\n", status));

                    DebugAssert(status < i);

                    if (Iosb[status].Information) {
                        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                                   "\nULIB: IsKeyPressed: KeyPressed\n"));
                        keyPressed = TRUE;
                        break;
                    }

                } else {
                    DebugPrintTrace(("ULIB: IsKeyPressed: unknown status %x\n", status));
                    break;
                }
            } while (timeRemaining != 0);
        }

#if !defined(RUN_ON_NT4)
        if (NT_SUCCESS(es_status)) {

            KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                       "ULIB: IsKeyPressed: Restoring power management status\n"));

            es_status = NtSetThreadExecutionState(prev_state, &dummy_state);
            if (!NT_SUCCESS(es_status)) {
                DebugPrintTrace(("ULIB: IsKeyPressed: Unable to reset thread execution state (%x)\n", es_status));
            }
        }
#endif

        SetLoggingEnabled(logging_state);

    }

    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "\nULIB: IsKeyPressed: Cleaning up\n"));

    CloseNHandles(i, h);
    CloseNHandles(i, e);
    FREE(h);
    FREE(e);
    FREE(Iosb);
    FREE(buf);

    return keyPressed;
}

BOOLEAN
AUTOCHECK_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    Open the keyboard directly and wait to read something.

Arguments:

    None:

Return Value:

    TRUE    - Something was successfully read.
    FALSE   - An error occured while attempting to open or read.

--*/
{
    PHANDLE             e = NULL;
    PHANDLE             h = NULL;
    PIO_STATUS_BLOCK    Iosb = NULL;
    PUCHAR              buf = NULL;
    PHANDLE             e1;
    PHANDLE             h1;
    PIO_STATUS_BLOCK    Iosb1;
    ULONG               i, j;
    NTSTATUS            status;
    LARGE_INTEGER       dummy;
    WCHAR               dev_name[MAX_PATH];
    BOOLEAN             error = FALSE;

    UNICODE_STRING      u;
    OBJECT_ATTRIBUTES   ObjAttr;

    dummy.QuadPart = 0;

    for (i=0; i<100; i++) {

        if ((i % KEYBOARD_DEVICE_OBJECT_INCREMENTS) == 0) {

            // allocate additional elements each time

            if (i == 0) {

                // first time

                KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                           "ULIB: WaitForUserSignal: Allocating memory the first time\n"));

                h1 = (PHANDLE)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(HANDLE));
                e1 = (PHANDLE)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(HANDLE));
                Iosb1 = (PIO_STATUS_BLOCK)CALLOC(KEYBOARD_DEVICE_OBJECT_INCREMENTS, sizeof(IO_STATUS_BLOCK));

            } else {

                KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                           "ULIB: WaitForUserSignal: Allocating additional memory\n"));

                h1 = (PHANDLE)REALLOC(h, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(HANDLE));
                e1 = (PHANDLE)REALLOC(e, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(HANDLE));
                Iosb1 = (PIO_STATUS_BLOCK)REALLOC(Iosb, (i+KEYBOARD_DEVICE_OBJECT_INCREMENTS)*sizeof(IO_STATUS_BLOCK));
            }

            if (h1 == NULL || Iosb1 == NULL || e1 == NULL) {
                DebugPrintTrace(("ULIB: WaitForUserSignal: Out of memory\n"));
                error = TRUE;
                break;
            }

            memset(&(h1[i]), 0, sizeof(HANDLE)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);
            memset(&(e1[i]), 0, sizeof(HANDLE)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);
            memset(&(Iosb1[i]), 0, sizeof(IO_STATUS_BLOCK)*KEYBOARD_DEVICE_OBJECT_INCREMENTS);

            h = h1;
            e = e1;
            Iosb = Iosb1;
        }

        swprintf(dev_name, DD_KEYBOARD_DEVICE_NAME_U L"%d", i);
        RtlInitUnicodeString(&u, dev_name);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: WaitForUserSignal: Opening device %ls\n", dev_name));

        InitializeObjectAttributes(&ObjAttr,
                                   &u,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: WaitForUserSignal: Initializing handle %d\n", i));

        status = NtCreateFile(&h[i],
                              GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                              &ObjAttr,
                              &Iosb[i],
                              NULL,                                 /* AllocationSize */
                              FILE_ATTRIBUTE_NORMAL,                /* FileAttributes */
                              0,                                    /* ShareAccess */
                              FILE_OPEN,                            /* CreateDisposition */
                              // the directory bit is to tell the keyboard driver to let
                              // this user mode process to open the keyboard
                              FILE_DIRECTORY_FILE,                  /* CreateOptions */
                              NULL,                                 /* EaBuffer */
                              0);                                   /* EaLength */

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_OBJECT_NAME_NOT_FOUND)
                break;  // found all keyboards and exit this loop

            DebugPrintTrace(("ULIB: WaitForUserSignal: Unable to open keyboard device %d (%x)\n", i, status));
            h[i] = NULL;
            error = TRUE;
            break;
        }

        InitializeObjectAttributes(&ObjAttr,
                                   NULL,
                                   0L,
                                   NULL,
                                   NULL);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "ULIB: WaitForUserSignal: Initializing event %d\n", i));

        status = NtCreateEvent(&e[i],
                               FILE_ALL_ACCESS,
                               &ObjAttr,
                               SynchronizationEvent,
                               FALSE);

        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("ULIB: WaitForUserSignal: Unable to create event %d (%x)\n", i, status));
            error = TRUE;
            e[i] = NULL;
            break;
        }
    }

    if (!error) {
        buf = (PUCHAR)CALLOC(i, KEYBOARD_READ_BUFFER_SIZE);

        if (buf == NULL) {
            DebugPrintTrace(("ULIB: WaitForUserSignal: Out of memory\n"));
            error = TRUE;
        }
    }

    if (!error) {

        for (j=0; j<i; j++) {
            status = NtReadFile(h[j], e[j], NULL, NULL,
                                &(Iosb[j]), &(buf[j]), KEYBOARD_READ_BUFFER_SIZE,
                                &dummy, NULL);

            if (!NT_SUCCESS(status)) {
                DebugPrintTrace(("\nULIB: WaitForUserSignal: Read failure from keyboard %d (%x)\n", j, status));
                error = TRUE;
                break;
            }
        }

        if (NT_SUCCESS(status)) {

            status = NtWaitForMultipleObjects(i, e, WaitAny, TRUE, NULL);
            error = !NT_SUCCESS(status);

        }
    }

    KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
               "\nULIB: WaitForUserSignal: Cleaning up\n"));

    CloseNHandles(i, h);
    CloseNHandles(i, e);
    FREE(h);
    FREE(e);
    FREE(Iosb);
    FREE(buf);

    return !error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\arg.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    argument classes

Abstract:

    These classes implement the command line parsing for all utilities.

Author:

    steve rowe              stever                  2/45/91

Revision History:


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

extern "C" {
    #include <ctype.h>
};

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "wstring.hxx"

#if !defined( _AUTOCHECK_ )

#include "path.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "system.hxx"

#endif

//
//      Prototypes for the matching functions
//
STATIC
BOOLEAN
Match(
    OUT PARGUMENT           Argument,
    OUT PARGUMENT_LEXEMIZER ArgumentLexemizer,
    IN  BOOLEAN             CaseSensitive
    );

STATIC
BOOLEAN
TailMatch(
    IN  PWSTRING Pattern,
    IN  PWSTRING String,
    IN  CHNUM    chn,
    OUT PCHNUM   chnEnd,
    IN  BOOLEAN  CaseSensitive
    );


//
//  Increment size of the _CharPos array
//
#define CHARPOS_INCREMENT   64



DEFINE_EXPORTED_CONSTRUCTOR( ARGUMENT_LEXEMIZER, OBJECT, ULIB_EXPORT );

VOID
ARGUMENT_LEXEMIZER::Construct (
    )
{
    _CharPos = NULL;
}


ULIB_EXPORT
ARGUMENT_LEXEMIZER::~ARGUMENT_LEXEMIZER (
    )
{
    if ( _CharPos ) {
        FREE( _CharPos );
    }
}



ULIB_EXPORT
BOOLEAN
ARGUMENT_LEXEMIZER::Initialize (
    IN PARRAY LexemeArray
    )
/*++

Routine Description:

      Initialization for ARGUMENT_LEXEMIZER. ARGUMENT_LEXEMIZER holds the
    container for lexed parameters from the command line.

Arguments:

    LexemeArray - Supplies pointer to a general array container.

Return Value:

    TRUE  - If initialization succeeds
    FALSE - If failed to construct the different character sets used
            to lex out the argument strings.

--*/
{

    DebugPtrAssert( LexemeArray );

    //
    //  Initialize our counts and pointer to the array of lexemes
    //
    _ConsumedCount = 0;
    _LexemeCount   = 0;
    _parray        = LexemeArray;
    _CharPosSize   = CHARPOS_INCREMENT;

    if ( !(_CharPos = (PCHNUM)MALLOC( (unsigned int)(_CharPosSize * sizeof(CHNUM)) ))) {
        return FALSE;
    }

    //
    // Setup the character sets used in lexing.
    //
    // Switch defines the general character used to a switch. This
    // is needed to seperate /a/b into /a /b
    //
    // White space is all characters that are not of interest
    //
    // MultipleSwitches are specific switch values that can be grouped
    // together under 1 switch. Appear as /a/b or /ab
    //
    // EscapeChars are chars that negate any special meaning of a char.
    //
    // StartQuote and EndQuote define the opening and closing of quoted strings
    //
    if ((_SwitchChars.Initialize( (PWSTR) L"/" ))      &&
        (_WhiteSpace.Initialize( (PWSTR) L" \t"))      &&
        (_MultipleSwitches.Initialize())  &&
        (_StartQuote.Initialize())        &&
        (_EndQuote.Initialize())          &&
        (_MetaChars.Initialize())) {

        //
        // Separator is a combo of other characters that can terminate
        // a token.
        //
        _Separators.Initialize();
        _SeparatorString.Initialize( &_Separators );
        _SeparatorString.Strcat(&_WhiteSpace);
        _SeparatorString.Strcat(&_SwitchChars);
        _SeparatorString.Strcat(&_StartQuote);

        _CaseSensitive = TRUE;
        _AllowGlomming = FALSE;
        _NoSpcBetweenDstAndSwitch = FALSE;

        return TRUE;
    }

    //
    //  Something went wrong
    //
    return FALSE;
}

VOID
ARGUMENT_LEXEMIZER::PutMetaChars (
    IN PCSTR   MetaChars
    )
/*++

Routine Description:

    Initializes Meta-characters

Arguments:

    MetaChars - Supplies pointer to string of metacharacters

Return Value:

    none
--*/
{
    DebugPtrAssert( MetaChars );
    _MetaChars.Initialize(MetaChars);
}

VOID
ARGUMENT_LEXEMIZER::PutMetaChars (
    IN PCWSTRING MetaChars
    )
/*++

Routine Description:

    Initializes Meta-characters

Arguments:

    MetaChars - Supplies pointer to string of metacharacters

Return Value:

    none
--*/
{
    DebugPtrAssert( MetaChars );
    _MetaChars.Initialize(MetaChars);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutMultipleSwitch (
    IN PCSTR   MultipleSwitches
    )
/*++

Routine Description:

    initializes Multiple-switches

Arguments:

    MultipleSwitches - Supplies pointer to string of multiple switches

Return Value:

    none
--*/
{
    DebugPtrAssert( MultipleSwitches );
    _MultipleSwitches.Initialize(MultipleSwitches);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutMultipleSwitch (
    IN PCWSTRING MultipleSwitches
    )
/*++

Routine Description:

    initializes Multiple-switches

Arguments:

    MultipleSwitches - Supplies pointer to string of multiple switches

Return Value:

    none
--*/
{
    DebugPtrAssert( MultipleSwitches );
    _MultipleSwitches.Initialize(MultipleSwitches);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutSeparators (
    IN PCSTR   Separators
    )
/*++

Routine Description:

    Initializes Separators

Arguments:

    pSeparators - Supplies pointer to string of separators

Return Value:

    none
--*/
{
    DebugPtrAssert( Separators );
    _Separators.Initialize(Separators);
    _SeparatorString.Initialize( &_Separators );
    //_SeparatorString += _WhiteSpace;
    //_SeparatorString += _SwitchChars;
}

VOID
ARGUMENT_LEXEMIZER::PutSeparators (
    IN PCWSTRING Separators
    )
/*++

Routine Description:

    Initializes Separators

Arguments:

    Separators - Supplies pointer to string of separators

Return Value:

    none
--*/
{
    DebugPtrAssert( Separators );
    _Separators.Initialize(Separators);
    _SeparatorString.Initialize( &_Separators );
    _SeparatorString.Strcat(&_WhiteSpace);
    _SeparatorString.Strcat(&_SwitchChars);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutSwitches (
    IN PCSTR   Switches
    )
/*++

Routine Description:

    Initializes Switches

Arguments:

    Switches - Supplies pointer to string of switches

Return Value:

    none
--*/
{
    DebugPtrAssert( Switches );
    _SwitchChars.Initialize(Switches);
    _SeparatorString.Initialize( &_Separators );
    _SeparatorString.Strcat(&_WhiteSpace);
    _SeparatorString.Strcat(&_SwitchChars);
}

ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::PutSwitches (
    IN PCWSTRING Switches
    )
/*++

Routine Description:

    Initializes Switches

Arguments:

    Switches - Supplies pointer to string of switches

Return Value:

    none
--*/
{
    DebugPtrAssert( Switches );
    _SwitchChars.Initialize(Switches);
    _SeparatorString.Initialize( &_Separators );
    _SeparatorString.Strcat(&_WhiteSpace);
    _SeparatorString.Strcat(&_SwitchChars);
}

ULIB_EXPORT
PWSTRING
ARGUMENT_LEXEMIZER::QueryInvalidArgument (
    )
/*++

Routine Description:

    Returns the lexeme tha could not be matched against any argument

Arguments:

    none

Return Value:

    pointer to string initialized with the offending lexeme

--*/
{
    PWSTRING String;

    if ( _ConsumedCount == _LexemeCount) {
        //
        //      There was no error
        //
        return NULL;
    }

    if ( ((String = NEW DSTRING) == NULL)   ||
        !String->Initialize( GetLexemeAt( _ConsumedCount )) ) {
        DebugAssert( FALSE );

        DELETE( String );
        return NULL;
    }

    return String;

}

BOOLEAN
ARGUMENT_LEXEMIZER::PutCharPos (
     IN  ULONG   Index,
     IN  CHNUM   CharPos
     )
/*++

Routine Description:

    Puts a character position into the character position array

Arguments:

    Index       -   Supplies the Index within the CharPos array

    CharPos     -   Supplies the character

Return Value:

    TRUE  - If done, FALSE otherwise

--*/

{
    PCHNUM  pTmp;
    ULONG   NewSize = _CharPosSize;

    if ( Index >= _CharPosSize ) {

        NewSize += CHARPOS_INCREMENT;

        if ( !(pTmp = (PCHNUM)REALLOC( _CharPos, (unsigned int)(NewSize * sizeof(CHNUM))  ))) {
            return FALSE;
        }

        _CharPos     = pTmp;
        _CharPosSize = NewSize;
    }

    _CharPos[ Index ] = CharPos;

    return TRUE;
}



ULIB_EXPORT
BOOLEAN
ARGUMENT_LEXEMIZER::PrepareToParse (
    IN PWSTRING CommandLine
    )
/*++

Routine Description:

    Lexes command line into strings and puts in array container held
    with object.

Arguments:

    CommandLine - Supplies command line

Return Value:

    TRUE  - If Command line lex'd correctly
    FALSE - If error in lexing.  FALSE will be returned if there are
            quote characters defined and the user types a command line with
            an open quote without a corresponding close quote.

--*/

{
    PWSTRING    pEndSet;                //      End Set for token
    PWSTRING    pCur;                   //      Current token
    PWSTRING    pTmp;                   //      Temporary string
    CHNUM       chnStart;               //      Start of token
    CHNUM       chnEnd;                 //      End of token
    CHNUM       SwitchAt;               //      Switch character position
    CHNUM       SwitchSpan;             //      Switches expand up to this position
    CHNUM       QuoteOffset;            //      Offset of beg. quote char in _StartQuote
    WCHAR       EndQuoteChar;           //      end of quote char
    CHNUM       NextMeta;
    CHNUM       NextSeparator;


    if ( CommandLine == NULL ) {

#if defined( _AUTOCHECK_ )

        return FALSE;
#else
        if (!_CmdLine.Initialize( GetCommandLine() )) {
                        DebugAssert( FALSE );
                        return FALSE;
        }
#endif

    } else {

        if (!_CmdLine.Initialize( CommandLine )) {
            DebugAssert( FALSE );
            return FALSE;
        }
    }

    chnStart = 0;

    //
    //      Set _Switch to any permissible switch character
    //
    DebugAssert( _SwitchChars.QueryChCount() > 0 );
    _Switch = _SwitchChars.QueryChAt( 0 );

    //
    //      If we are case-insensitive, then we expand our multiple switches
    //      to include lower and upper case.
    //
    if (!_CaseSensitive && _MultipleSwitches.QueryChCount() > 0) {

        pTmp = NEW DSTRING;

        if (pTmp == NULL) {
            DebugPrint("ULIB: Out of memory\n");
            return FALSE;
        }

        _MultipleSwitches.Strupr();

        if (!pTmp->Initialize(&_MultipleSwitches)) {
            DebugPrint("ULIB: Out of memory\n");
            return FALSE;
        }
        pTmp->DeleteChAt(0);
        pTmp->Strlwr();

        if (!_MultipleSwitches.Strcat(pTmp)) {
            DebugPrint("ULIB: Out of memory\n");
            return FALSE;
        }

        DELETE( pTmp );
    }

    //
    // Loop till Command line is exhausted of tokens.
    //
    while ( TRUE ) {

        //
        // move to first character not part of white space. This will
        // always be the case for the start char. position since lexing
        // will always be interested in anything that is not white space.
        //
        chnStart = _CmdLine.Strspn( &_WhiteSpace, chnStart );

        //
        // Check of any tokens left to lex. Note that we have to
        // recheck the actual char. count each time through since
        // we may have deleted meta characters
        //
        if (chnStart == INVALID_CHNUM) {

            //
            // Have exhausted the command line of tokens. Get out of here
            //
            break;
        }

        //
        // if escape character, skip it and try again
        //
        if (_MetaChars.Strchr( _CmdLine.QueryChAt( chnStart)) != INVALID_CHNUM) {

            chnStart++;
            continue;
        }

        //
        // we've skipped over the leading whitespace so we're at the
        // beginning of the token.
        //
        chnEnd  = chnStart;

        if ( chnEnd < _CmdLine.QueryChCount() ) {

            pEndSet = &_SeparatorString;

            while ( chnEnd < _CmdLine.QueryChCount() ) {

                // if the current character is a separator and not
                // the first character in the token, we're done.
                // It can also be that there is no space between switches
                if( chnEnd != chnStart &&
                    ((_SeparatorString.Strchr(_CmdLine.QueryChAt(chnEnd)) != INVALID_CHNUM) ||
                     (_NoSpcBetweenDstAndSwitch &&
                      (_SwitchChars.Strchr(_CmdLine.QueryChAt(chnEnd)) != INVALID_CHNUM) &&
                      ((chnEnd+1) < _CmdLine.QueryChCount()) &&
                      !isdigit(_CmdLine.QueryChAt(chnEnd+1))))) {

                    // If this token so far is two consecutive separators,
                    // keep going.  Otherwise, it's the end of the token.
                    //
                    if( chnStart + 1 == chnEnd &&
                        (_SwitchChars.Strchr( _CmdLine.QueryChAt( chnStart ) ) != INVALID_CHNUM ) &&
                        (_SwitchChars.Strchr( _CmdLine.QueryChAt( chnEnd ) )   != INVALID_CHNUM ) ) {

                        chnEnd++;
                        continue;
                    }

                    break;
                }

                // if the current character is a meta character, delete
                // the meta character and accept the following character
                // without reservation.
                //
                if( _MetaChars.Strchr( _CmdLine.QueryChAt(chnEnd) ) != INVALID_CHNUM ) {

                    _CmdLine.DeleteChAt(chnEnd);

                    if( chnEnd < _CmdLine.QueryChCount() ) {
                        chnEnd++;
                    }
                    continue;
                }

                // if the current character is a start-quote, accept everything
                // until an end-quote is found (or we run out of string).
                //
                if( (QuoteOffset = _StartQuote.Strchr( _CmdLine.QueryChAt(chnEnd) )) != INVALID_CHNUM ) {

                    //
                    //  Set the end of quote char to the corresponding char in
                    //  the _EndQuote string.  (ie. if the opening quote char
                    //  is the first char in _StartQuote then use the first
                    //  char in _EndQuote)
                    //
                    EndQuoteChar = _EndQuote.QueryChAt(QuoteOffset);
                    chnEnd++;

                    while( TRUE ) {
                        //
                        // locate potential end of token by looking for the
                        // EndQuoteChar.
                        //
                        //  check if next char is the EndQuoteChar--if it is,
                        //  then the user is 'quoting' the endquotechar, so
                        //  remove the 'quoting' char.  Otherwise, this is
                        //  the end of the quoted string.
                        //
                        if( (chnEnd = _CmdLine.Strchr(EndQuoteChar, chnEnd ))
                            != INVALID_CHNUM ) {

                            //
                            // bump up chnEnd to check the character
                            // after the quote char.  If it's another
                            // quote char then, delete the first quote.
                            // Otherwise, we're at the end of the quoted
                            // string.
                            //
                            if( _CmdLine.QueryChAt(++chnEnd) == EndQuoteChar ) {

                                _CmdLine.DeleteChAt(chnEnd - 1);
                                continue;

                            } else {

                                break;
                            }

                        } else {

                            //
                            // we reached the end of the string w/o finding the
                            // endQuoteChar (chnEnd == INVALID_CHNUM)
                            //
                            // return FALSE because an open quote is being
                            // considered a lex error because this is easier and
                            // does what is required.  If someone wants to
                            // handle quote characters they could change this
                            // by setting chnEnd to the last char of the first
                            // token, ignoring the quote. eg: if cmd line was
                            //      cmd "arg1 arg2 arg3
                            //
                            // chnEnd could be set to the position of '1'.
                            //
                            return FALSE;

                        }
                    }

                    // Keep accepting characters.
                    //
                    continue;
                }

                // It's not a separator, a meta-character, or a start quote;
                // accept it.
                //
                chnEnd++;
            }
        }


                //
                // we have a valid token to put in string array.
                //
        if ((pCur = _CmdLine.QueryString(chnStart, chnEnd - chnStart)) == NULL) {

                        //
            // Could not create a new substring. Error out.
                        //
                        return FALSE;
                }

                SwitchSpan = pCur->Strspn( &_MultipleSwitches, 1 );

                //
                //      Ramonsa - We must not replace the original switch character used,
                //                        because if we do then we won't be able to retrieve it.
                //
                //if ((SwitchAt = _SwitchChars.Strchr( pCur->QueryChAt(0))) != INVALID_CHNUM ) {
                //
                //      //
                //      //      The first character is a switch
                //      //
                //      pCur->SetChAt( _Switch, 0);
                //
                //
                //}
                SwitchAt = _SwitchChars.Strchr( pCur->QueryChAt(0) );

                //
                // Check for multiple switch arguments by seeing if any of the
        // characters in the token are not in the multiple switch set.
        // Also, if the token is only one character then it can't be
        // multiple switches.
        if (( SwitchAt == INVALID_CHNUM ) ||
            ( SwitchSpan != INVALID_CHNUM ) ||
            pCur->QueryChCount() == 1) {

                        //
                        // Non-multiple characters were found, throw the entire
                        // thing into the string array container
                        //

            if (!_parray->Put( pCur ) ||
                !PutCharPos( _LexemeCount, chnStart )
               ) {

                                //
                                // Error out we could not insert the value
                                //
                                return FALSE;

                        } else {

                                //
                                // Setup to fetch next token and go to outer loop
                //
                _LexemeCount++;
                                chnStart = chnEnd;
                                continue;
                        }

                } else {

                        //
                        //  All characters in the string are multiple switches.
                        //
                        for ( CHNUM chn = 1; chn < pCur->QueryChCount(); chn++ ) {

                            //
                            // If glomming is allowed then we want to handle pCur when
                            // it looks like "/s/f/i/d" by splitting up each argument.
                            // We skip over the slashes and treat this string the same
                            // as "/sfid".  (See arg.hxx at "GLOMMING".)
                            //

                            if (_AllowGlomming && chn >= 2 &&
                                pCur->QueryChAt(chn) == pCur->QueryChAt(0)) {
                                continue;
                }

                                //
                                //      Pull out a switch and put in new switch string.
                                //
                pTmp = NEW DSTRING();

                if (pTmp == NULL ||
                    !pTmp->Initialize((PWSTR) L"  ")) {
                    DebugPrint("ULIB: Out of memory\n");
                    return FALSE;
                }

                pTmp->SetChAt( pCur->QueryChAt(0), 0 );
                pTmp->SetChAt( pCur->QueryChAt(chn), 1 );

                if (!_parray->Put( pTmp )                   ||
                    !PutCharPos( _LexemeCount, chnStart )
                   ) {

                                        //
                                        // ERROR out we could not put the token
                                        //
                                        DELETE( pTmp );
                                        return FALSE;

                                } else {

                                        _LexemeCount++;
                                }
                        }

                        //
                        //      pCur not needed anymore
                        //
                        DELETE( pCur );

                        //
                        // Setup to fetch next token and go to outer loop
                        //
                        chnStart = chnEnd;
                        continue;
                }
        }

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
ARGUMENT_LEXEMIZER::DoParsing (
    IN PARRAY           ArgumentArray
    )
/*++

Routine Description:

    Parses the arguments passed.

Arguments:

        ArgumentArray  -   Supplies pointer to array of arguments to set


Return Value:

        TRUE if all argument strings matched
        FALSE otherwise.


--*/
{

        PARRAY_ITERATOR Iterator;
        PARGUMENT               arg;
        BOOLEAN         DoAgain = TRUE;

        DebugPtrAssert( ArgumentArray );

        while (DoAgain) {

                DoAgain   = FALSE;

                Iterator = (PARRAY_ITERATOR)ArgumentArray->QueryIterator();

                DebugAssert( Iterator );

                if ( Iterator ) {

                        arg = (PARGUMENT)Iterator->GetNext();

                        while( arg ) {

                                //
                                //      Check that the argument hasn't already found its
                                //      match.
                                //
                                if (!arg->IsValueSet()) {

                                        //
                                        //      If the first character of the pattern is a switch,
                                        //      we change the switch character.
                                        //
                                        if (( _SwitchChars.Strchr(arg->GetPattern()->QueryChAt(0))) != INVALID_CHNUM) {

                                                arg->GetPattern()->SetChAt( _Switch, 0);

                                        }

                                        //
                                        //      Try to match it
                                        //
                                        if (arg->SetIfMatch( this, _CaseSensitive )) {

                                                //
                                                //      Found a match, start over with first argument
                                                //      if there are more lexemes to match.
                                                //
                                                DoAgain = (BOOLEAN)( _ConsumedCount != _LexemeCount );

                                                break;
                                        }
                                }

                                arg = (PARGUMENT)Iterator->GetNext();
                        }

                        DELETE( Iterator );
                }
        }

        return  ( _ConsumedCount == _LexemeCount );
}

ULIB_EXPORT
PWSTRING
ARGUMENT_LEXEMIZER::GetLexemeAt (
    IN  ULONG   Index
        )
/*++

Routine Description:

        Gets the Lexeme at the specified index

Arguments:

    Index   -   Supplies the index of the lexeme desired

Return Value:

    Pointer to the lexeme

--*/
{
        return (PWSTRING)_parray->GetAt(Index);
}


CHNUM
ARGUMENT_LEXEMIZER::QueryCharPos (
    IN  ULONG   LexemeNumber
    )
/*++

Routine Description:

    Queries the character position of a particular lexeme

Arguments:

    LexemeNumber    -   Supplies the lexeme number

Return Value:

    Returns the character position of the lexeme

--*/
{
    DebugAssert( LexemeNumber < _LexemeCount );
    DebugAssert( LexemeNumber < _CharPosSize );

    return _CharPos[ LexemeNumber ];
}


ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::SetCaseSensitive (
        IN BOOLEAN CaseSensitive
    )
/*++

Routine Description:

        Sets case sensitivity ON/OFF

Arguments:

        CaseSensitive   -       Supplies case sensitivity flag

Return Value:

        none

--*/
{
        _CaseSensitive = CaseSensitive;
}


ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::SetAllowSwitchGlomming (
    IN BOOLEAN AllowGlomming
    )
/*++

Routine Description:

    Sets whether swith glomming (as in "/s/f/i/d") is allowed
    or not.  See note in <arg.hxx> at "GLOMMING".

Arguments:

    AllowGlomming   -   Supplies glomming allowed flag.

Return Value:

    none

--*/
{
    _AllowGlomming = AllowGlomming;
}


ULIB_EXPORT
VOID
ARGUMENT_LEXEMIZER::SetNoSpcBetweenDstAndSwitch (
    IN BOOLEAN NoSpcBetweenDstAndSwitch
    )
/*++

Routine Description:

    Sets whether a separator is required between
    tokens.  This is specifically for xcopy that
         a space should not be required to separate the
         destination and the specified options.

Arguments:

    NoSpcBetweenDstAndSwitch - Supplies the flag

Return Value:

    none

--*/
{
    _NoSpcBetweenDstAndSwitch = NoSpcBetweenDstAndSwitch;
}


DEFINE_CONSTRUCTOR( ARGUMENT, OBJECT );

VOID
ARGUMENT::Construct (
    )
{
        UNREFERENCED_PARAMETER( (void)this);
        _Lexeme = NULL;
}

BOOLEAN
ARGUMENT::Initialize (
        IN      PSTR Pattern
    )
/*++

Routine Description:

    Create an ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                 parameter

Return Value:

        TRUE - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
        //  Make sure that we have an associated pattern
        //
        DebugAssert(Pattern);

        //
        //  Initially we don't have a value
        //
        _fValueSet = FALSE;

        //
        //  Initialize the pattern
        //
        return _Pattern.Initialize(Pattern);
}

BOOLEAN
ARGUMENT::Initialize (
    IN  PWSTRING Pattern
    )
/*++

Routine Description:

    Create an ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                 parameter

Return Value:

        TRUE - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
        //  Make sure that we have an associated pattern
        //
        DebugAssert(Pattern);

        //
        //  Initially we don't have a value
        //
        _fValueSet = FALSE;

        //
        //  Initialize the pattern
        //
        return _Pattern.Initialize(Pattern);
}

ULIB_EXPORT
PWSTRING
ARGUMENT::GetLexeme (
        )
/*++

Routine Description:

        Gets the lexeme matched by this Argument.

Arguments:

    none

Return Value:

        Pointer to Lexeme

--*/
{
    //DebugAssert( _fValueSet );

        return _Lexeme;
}

ULIB_EXPORT
PWSTRING
ARGUMENT::GetPattern (
        )
/*++

Routine Description:

    Gets the pattern associated with this Argument.

Arguments:

    none

Return Value:

    Pointer to pattern

--*/
{
        return &_Pattern;
}

BOOLEAN
ARGUMENT ::SetIfMatch(
        OUT PARGUMENT_LEXEMIZER ArgumentLexemizer,
        IN      BOOLEAN                         CaseSensitive
    )
/*++

Routine Description:

        Determines if the current argument string is recognized by
    this ARGUMENT object, and setst the value if there is a match.

Arguments:

        ArgumentLexemizer - Supplies container holding command line
                                                 lex'd into strings
        CaseSensitive     - Supplies case sensitivity flag

Return Value:

    TRUE  - argument recognized and value set.
        FALSE - argument not recognized and/or value not set.

--*/
{
        //
        // Match will try to match the current argument pattern (Pattern)
        // with one of the string from the lexemizer. If a match occurs
        // then it will callback through the this pointer passed to
        // the SetValue routine for this argument object.
        //
        return Match( this, ArgumentLexemizer,  CaseSensitive );
};

ULIB_EXPORT
BOOLEAN
ARGUMENT::IsValueSet (
        )
/*++

Routine Description:

    Checks if the argument has been found and set.

    This method is used to determine if the ARGUMENT object has had
    its value set without having to know what type of ARGUMENT object
        it is. This is used mainly in ARGUMENT_LIST to avoid repeated calling
    IsArgument once the argument has been recognized and the value
        set.

Arguments:

Return Value:

        TRUE - if value has already been set.
    FALSE - if the value has not been set and it is ok to call IsArgument

--*/
{
    return _fValueSet;
};

BOOLEAN
ARGUMENT::SetValue(
        IN PWSTRING                     Arg,
        IN CHNUM                                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )
/*++

Routine Description:

        Default method for setting the value of an argument. Sets
    fValueSet to false.

Arguments:

        Arg                              -       Supplies current argument string
        chnIdx                           -       Supplies index within Arg
        ArgumentLexemizer        -       Supplies list of lexed strings

Return Value:

        FALSE

--*/
{

    UNREFERENCED_PARAMETER( this );
    UNREFERENCED_PARAMETER( (void)Arg );
    UNREFERENCED_PARAMETER( (void)chnIdx );
    UNREFERENCED_PARAMETER( (void)ArgumentLexemizer );
    UNREFERENCED_PARAMETER( (void)chnEnd );


    return _fValueSet = FALSE ;
}








DEFINE_EXPORTED_CONSTRUCTOR( FLAG_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
FLAG_ARGUMENT::Construct (
        )
{
        UNREFERENCED_PARAMETER( this );
}

ULIB_EXPORT
BOOLEAN
FLAG_ARGUMENT::Initialize (
        IN      PSTR Pattern
        )
/*++

Routine Description:

        Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                                 parameter

Return Value:

        TRUE - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

    //
    //      Set our initial value
    //
    _flag = FALSE;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

ULIB_EXPORT
BOOLEAN
FLAG_ARGUMENT::Initialize (
    IN  PWSTRING Pattern
        )
/*++

Routine Description:

        Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                                 parameter

Return Value:

        TRUE - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
    //      Set our initial value
    //
    _flag = FALSE;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
FLAG_ARGUMENT::SetValue(
        IN PWSTRING                     Arg,
    IN CHNUM                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )
/*++

Routine Description:

    Sets the flag to TRUE

Arguments:

        Arg                              -       Supplies current argument string
        chnIdx                                  -       Supplies index within Arg
        ArgumentLexemizer          -   Supplies list of lexed strings

Return Value:

    FALSE

--*/
{

    UNREFERENCED_PARAMETER( this );
    UNREFERENCED_PARAMETER( (void)Arg );
    UNREFERENCED_PARAMETER( (void)chnIdx );
    UNREFERENCED_PARAMETER( (void)ArgumentLexemizer );

    _Lexeme = Arg;
    _LastConsumedCount = ArgumentLexemizer->QueryConsumedCount();
    return _flag = _fValueSet = TRUE;

}



DEFINE_EXPORTED_CONSTRUCTOR( STRING_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
STRING_ARGUMENT::Construct (
        )
{
        _String = NULL;
}

ULIB_EXPORT
STRING_ARGUMENT::~STRING_ARGUMENT (
        )
/*++

Routine Description:

    Destructor for String Arguments

Arguments:


Return Value:

    none

--*/
{
        DELETE( _String );
}

ULIB_EXPORT
BOOLEAN
STRING_ARGUMENT::Initialize (
        IN      PSTR Pattern
    )
/*++

Routine Description:

    Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                                 parameter

Return Value:

    TRUE  - If arg. initialized.
    FALSE - If failed to initialize.

--*/
{
        //
    //      Set our initial value
        //
        _String = NULL;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
STRING_ARGUMENT::Initialize (
    IN  PWSTRING Pattern
    )
/*++

Routine Description:

    Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                                 parameter

Return Value:

    TRUE  - If arg. initialized.
    FALSE - If failed to initialize.

--*/
{
        //
    //      Set our initial value
        //
        _String = NULL;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
STRING_ARGUMENT::SetValue(
        IN PWSTRING                     Arg,
    IN CHNUM                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )

/*++

Routine Description:

    Sets the value of a STRING_ARGUMENT argument

Arguments:

        Arg                      -       Supplies current argument string
        chnIdx                          -       Supplies index within Arg
        ArgumentLexemizer  -   Supplies list of lexed strings

Return Value:

    TRUE if value set
    FALSE otherwise

--*/
{

        DebugPtrAssert( Arg );

    _fValueSet = FALSE;

        DebugAssert( Arg->QueryChCount() >= chnEnd );

    if ((_String=Arg->QueryString(chnIdx, chnEnd - chnIdx )) != NULL) {
                  ArgumentLexemizer->IncrementConsumedCount( );

                _Lexeme    = Arg;
        _fValueSet = TRUE;
    }

    return _fValueSet;
}






DEFINE_EXPORTED_CONSTRUCTOR( LONG_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
LONG_ARGUMENT::Construct (
        )
{
        UNREFERENCED_PARAMETER( this );
}

ULIB_EXPORT
BOOLEAN
LONG_ARGUMENT::Initialize (
        IN      PSTR Pattern
        )
/*++

Routine Description:

    Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                 parameter

Return Value:

    TRUE  - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
    //      Set our initial value
    //
    _value = 0;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
LONG_ARGUMENT::Initialize (
    IN  PWSTRING Pattern
        )
/*++

Routine Description:

    Create a FLAG_ARGUMENT object and setup for parsing

Arguments:

        Pattern - Supplies string used in matching argument with command line
                 parameter

Return Value:

    TRUE  - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
    //      Set our initial value
    //
    _value = 0;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
LONG_ARGUMENT::SetValue (
        IN PWSTRING                     Arg,
        IN CHNUM                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )

/*++

Routine Description:

    Sets the value of a LONG_ARGUMENT argument

Arguments:

        Arg      -       Supplies current argument string
        chnIdx          -       Supplies index within Arg
        ArgStrings -   Supplies list of lexed strings

Return Value:

    TRUE if value set
    FALSE otherwise

--*/
{
        DebugPtrAssert( Arg );

        DebugAssert( Arg->QueryChCount() >= chnEnd );

    if ( Arg->QueryNumber( &_value, chnIdx,  chnEnd - chnIdx )) {
                ArgumentLexemizer->IncrementConsumedCount();

                _Lexeme = Arg;
                return _fValueSet = TRUE;
        }

        return FALSE;
}



#if !defined( _AUTOCHECK_ )



DEFINE_EXPORTED_CONSTRUCTOR( TIMEINFO_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
TIMEINFO_ARGUMENT::Construct (
        )
{
        UNREFERENCED_PARAMETER( this );
}

ULIB_EXPORT
TIMEINFO_ARGUMENT::~TIMEINFO_ARGUMENT (
        )
/*++

Routine Description:

        Destructor for Timeinfo Arguments

Arguments:


Return Value:

    none

--*/
{
        DELETE( _TimeInfo );
}

ULIB_EXPORT
BOOLEAN
TIMEINFO_ARGUMENT::Initialize (
    IN      PSTR Pattern
    )
/*++

Routine Description:

    Create a TIMEINFO_ARGUMENT object and setup for parsing

Arguments:

    Pattern - Supplies string used in matching argument with command line
             parameter

Return Value:

    TRUE  - If arg. initialized.
    FALSE - If failed to initialize.

--*/
{

    _TimeInfo = NULL;

    return ARGUMENT::Initialize(Pattern);
}

BOOLEAN
TIMEINFO_ARGUMENT::Initialize (
    IN  PWSTRING Pattern
    )
/*++

Routine Description:

    Create a TIMEINFO_ARGUMENT object and setup for parsing

Arguments:

    Pattern - Supplies string used in matching argument with command line
              parameter

Return Value:

    TRUE  - If arg. initialized.
    FALSE - If failed to initialize.

--*/
{
    _TimeInfo = NULL;

    return ARGUMENT::Initialize(Pattern);
}

BOOLEAN
TIMEINFO_ARGUMENT::SetValue (
    IN PWSTRING             Arg,
    IN CHNUM                chnIdx,
    IN CHNUM                chnEnd,
    IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
    )

/*++

Routine Description:

    Sets the value of a TIMEINFO_ARGUMENT argument

Arguments:

    Arg             -       Supplies current argument string
    chnIdx          -       Supplies index within Arg
    ArgStrings      -       Supplies list of lexed strings

Return Value:

    TRUE if value set
    FALSE otherwise

--*/
{

    DSTRING String;

    DebugPtrAssert( Arg );

    if ( ( Arg) &&
        String.Initialize( Arg, chnIdx, chnEnd - chnIdx )     &&
        ((_TimeInfo = NEW TIMEINFO) != NULL)                  &&
        _TimeInfo->Initialize()                               &&
        _TimeInfo->SetDateAndTime( &String ) ) {

        ArgumentLexemizer->IncrementConsumedCount();

        _Lexeme = Arg;
        return _fValueSet = TRUE;
    }

    return FALSE;
}

#endif  // _AUTOCHECK_


#if !defined( _AUTOCHECK_ )

DEFINE_EXPORTED_CONSTRUCTOR( PATH_ARGUMENT, ARGUMENT, ULIB_EXPORT);

VOID
PATH_ARGUMENT::Construct (
        )
{
        _Path = NULL;
}

ULIB_EXPORT
PATH_ARGUMENT::~PATH_ARGUMENT(
        )
/*++

Routine Description:

    Destructor for Path Arguments

Arguments:

    none

Return Value:

        none

--*/
{
        Destroy();
}

VOID
PATH_ARGUMENT::Destroy(
        )
/*++

Routine Description:

        Destroys a path argument

Arguments:

    none

Return Value:

        none

--*/
{
        DELETE( _Path );
}

ULIB_EXPORT
BOOLEAN
PATH_ARGUMENT::Initialize (
        IN      PSTR    Pattern,
        IN      BOOLEAN Canonicalize
        )
/*++

Routine Description:

        Create a PATH_ARGUMENT object and setup for parsing

Arguments:

        Pattern                 -       Supplies string used in matching argument with
                                                command line parameter
        Canonicalize    -       Supplies the canonicalization flag

Return Value:

    TRUE  - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
        //      Destroy the path, in case we are re-initializing
        //
        Destroy();

        _Canonicalize = Canonicalize;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
PATH_ARGUMENT::Initialize (
    IN  PWSTRING Pattern,
        IN      BOOLEAN                 Canonicalize
        )
/*++

Routine Description:

        Create a PATH_ARGUMENT object and setup for parsing

Arguments:

        Pattern                 -       Supplies string used in matching argument with
                                                command line parameter
        Canonicalize    -       Supplies the canonicalization flag

Return Value:

    TRUE  - If arg. initialized.
        FALSE - If failed to initialize.

--*/
{

        //
        //      Destroy the path, in case we are re-initializing
        //
        Destroy();

        _Canonicalize = Canonicalize;

    //
    //      Initialize the pattern
    //
        return ARGUMENT::Initialize(Pattern);

}

BOOLEAN
PATH_ARGUMENT::SetValue(
        IN PWSTRING                             Arg,
        IN CHNUM                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
        )
/*++

Routine Description:

        Sets the value of a PATH_ARGUMENT argument

Arguments:

        Arg                             -       Supplies current argument string
        chnIdx          -   Supplies index within Arg
    ArgumentLexemizer - Supplies list of lexed strings

Return Value:

        TRUE if value set
        FALSE otherwise

--*/
{

        PWSTRING pT;

        DebugPtrAssert( Arg );


        _fValueSet = FALSE;

        DebugAssert( Arg->QueryChCount() >= chnEnd );

        pT = Arg->QueryString(chnIdx, chnEnd - chnIdx);

        if (NULL != pT) {

        //
        // Remove double quotes from the path string.  We assume
        // that there will never be a valid double-quote in an
        // actual path.
        //

        for (ULONG i = 0; i < pT->QueryChCount(); ++i) {
            if ('\"' == pT->QueryChAt(i)) {
                pT->DeleteChAt(i);
                i--;
                continue;
            }
        }

                if( (_Path = NEW PATH) != NULL) {
                        if ( _Path->Initialize( pT, _Canonicalize )) {

                                //
                                // check the first char to see if it's a switch char
                                // (it can't be if it's a path)
                                //
                if( (ArgumentLexemizer->GetSwitches()->Strchr(pT->QueryChAt(0))
                                         == INVALID_CHNUM)  ) {
                                        ArgumentLexemizer->IncrementConsumedCount();

                                        _Lexeme         =       Arg;
                                        _fValueSet      =       TRUE;
                                }

                        } else {

                                DebugAssert( FALSE );
                                DELETE( _Path );
                        }
                }

                DELETE( pT );

        }

        return _fValueSet;
}


#endif  // _AUTOCHECK_



#if !defined( _AUTOCHECK_ )


DEFINE_EXPORTED_CONSTRUCTOR( MULTIPLE_PATH_ARGUMENT, PATH_ARGUMENT, ULIB_EXPORT);

VOID
MULTIPLE_PATH_ARGUMENT::Construct (
        )
{
        _PathArray = NULL;
}

ULIB_EXPORT
MULTIPLE_PATH_ARGUMENT::~MULTIPLE_PATH_ARGUMENT(
        )

/*++

Routine Description:

        Destructor for Path Arguments

Arguments:

        none


Return Value:

        none

--*/

{
        Destroy();
}

VOID
MULTIPLE_PATH_ARGUMENT::Destroy(
        )

/*++

Routine Description:

        Destroys a multiple-path argument

Arguments:

        none


Return Value:

        none

--*/

{
        DELETE( _PathArray );
}

ULIB_EXPORT
BOOLEAN
MULTIPLE_PATH_ARGUMENT::Initialize (
        IN PSTR         Pattern,
    IN BOOLEAN  Canonicalize,
    IN BOOLEAN  ExpandWildCards
    )
/*++

Routine Description:

        Initializes a MULTIPLE_PATH_ARGUMENT

Arguments:

        Pattern                 -       Supplies the argument pattern
    Canonicalize    -   Supplies canonicalization flag
    ExpandWildCards -   Supplies wildcard expansion flag

Return Value:

        TRUE if correctly initialized
        FALSE otherwise

--*/

{

        //
        //      Destroy, in case we are re-initializing
        //
        Destroy();

        //
        //      Initialize the argument
        //
        if (PATH_ARGUMENT::Initialize( Pattern, Canonicalize ) ) {

                //
                //      Argument correctly initialized, create our array object
                //
                if ((_PathArray = NEW ARRAY) != NULL) {

                        //
                        //      Ok, so initialize it
                        //
                        if (_PathArray->Initialize() ) {

                                //
                                //      Everything's cool
                                //
                _PathCount          = 0;
                _ExpandWildCards    = ExpandWildCards;
                _WildCardExpansionFailed  = FALSE;
                return TRUE ;
                        }

                        DELETE( _PathArray );
        }
    }

    return FALSE;
}

BOOLEAN
MULTIPLE_PATH_ARGUMENT::Initialize (
    IN PWSTRING  Pattern,
    IN BOOLEAN          Canonicalize,
    IN BOOLEAN          ExpandWildCards
    )
/*++

Routine Description:

        Initializes a MULTIPLE_PATH_ARGUMENT

Arguments:

        Pattern                 -       Supplies the argument pattern
    Canonicalize    -   Supplies canonicalization flag
    ExpandWildCards -   Supplies wildcard expansion flag

Return Value:

        TRUE if correctly initialized
        FALSE otherwise

--*/

{
        //
        //      Destroy, in case we are re-initializing
        //
        Destroy();

        //
        //      Initialize the argument
        //
        if (PATH_ARGUMENT::Initialize( Pattern, Canonicalize ) ) {

                //
                //      Argument correctly initialized, create our array object
                //
                if ((_PathArray = NEW ARRAY) != NULL) {

                        //
                        //      Ok, so initialize it
                        //
                        if (_PathArray->Initialize() ) {

                                //
                                //      Everything's cool
                                //
                _PathCount          = 0;
                _ExpandWildCards    = ExpandWildCards;
                _WildCardExpansionFailed  = FALSE;
                return TRUE ;
                        }

                        DELETE( _PathArray );
        }
    }

    return FALSE;
}

BOOLEAN
MULTIPLE_PATH_ARGUMENT::SetValue (
        IN PWSTRING                         pwcArg,
        IN CHNUM                                chnIdx,
        IN CHNUM                                chnEnd,
        IN PARGUMENT_LEXEMIZER  ArgumentLexemizer
        )
/*++

Routine Description:

        Sets the value of a MULTIPLE_PATH_ARGUMENT argument

Arguments:

        pwcArg                          -       Supplies current argument string
        chnIdx                          -       Supplies index within pwcArg
        ArgumentLexemizer       -       Supplies list of lexed strings

Return Value:

        TRUE if value set
        FALSE otherwise

--*/
{

    PPATH               FullPath    = NULL;
    PWSTRING TmpName     = NULL;
    PFSN_DIRECTORY      Directory   = NULL;
    PARRAY              NodeArray   = NULL;
    PARRAY_ITERATOR     Iterator    = NULL;
    PFSNODE             Node;
    PPATH               Path;
    CHNUM               BaseLength;
    DSTRING             Name;
    FSN_FILTER          Filter;
    CHNUM               PrefixLength;
    BOOLEAN             Ok          = FALSE;

    DebugPtrAssert( _PathArray );

        //
        //      Try to set the path value
        //
        if (PATH_ARGUMENT::SetValue(pwcArg, chnIdx, chnEnd, ArgumentLexemizer)) {

        //
        //  If we have to expand wildcards, we get an array of paths and put
        //  the elements in our array, otherwise we just put the path that we
        //  have.
        //
        if ( _ExpandWildCards && PATH_ARGUMENT::_Path->HasWildCard() ) {

            //
            //  Expand the path that we have, remember its name portion
            //  and truncate it so that we are left with a directory
            //  path. Then get a directory object from the path and a filter
            //  for the wildcard.
            //
            //  Then do the wildcard expansion.
            //
            if ( ( FullPath = PATH_ARGUMENT::_Path->QueryFullPath() )        &&
                 ( TmpName  = FullPath->QueryName() )                        &&
                 Name.Initialize( TmpName )                                  &&
                 FullPath->TruncateBase()                                    &&
                 (Directory = SYSTEM::QueryDirectory( FullPath ))            &&
                 Filter.Initialize()                                         &&
                 Filter.SetFileName( &Name )                                 &&
                 ( NodeArray = Directory->QueryFsnodeArray( &Filter ))       &&
                 ( Iterator  = (PARRAY_ITERATOR)NodeArray->QueryIterator() )
               ) {

                Ok = TRUE;


                //
                //  If no files matched the wildcard, we remember the pattern
                //  and set the failure flag.
                //
                if ( !_WildCardExpansionFailed &&
                     (NodeArray->QueryMemberCount() == 0 ) ) {

                    _WildCardExpansionFailed = TRUE;
                    _LexemeThatFailed.Initialize( pwcArg );

                } else {

                    //
                    //  Now that we have done the wildcard expansion, extract
                    //  all the paths and put them in our array
                    //
                    while ( Node = (PFSNODE)Iterator->GetNext() ) {

                        Path = NULL;

                        DELETE( TmpName );

                        if ( (Path = NEW PATH)                                          &&
                             Path->Initialize( PATH_ARGUMENT::_Path )                   &&
                             Path->TruncateBase()                                       &&
                             (TmpName = ((PPATH) Node->GetPath())->QueryName())                   &&
                             Path->AppendBase( TmpName )                                &&
                             _PathArray->Put( Path )
                           ) {

                            DELETE( TmpName );

                            _PathCount++;

                        } else {

                            DELETE( Path );
                            Ok = FALSE;
                            break;

                        }
                    }
                }

                DELETE( TmpName  );
                DELETE( FullPath );
                DELETE( Directory );
                DELETE( Iterator );
                if ( NodeArray ) {
                    NodeArray->DeleteAllMembers();
                }
                DELETE( NodeArray );
                DELETE( FullPath );
            }


        } else {

                        if (_PathArray->Put(PATH_ARGUMENT::_Path)) {

                                _PathCount++;

                Ok = TRUE;

                        }
        }

        //
        //  We reset the _fValueSet flag, because we can
        //  always take another path.
        //
        ARGUMENT::_fValueSet = FALSE;
    }

    return Ok;
}


#endif //   _AUTOCHECK_



//
//      Macro for handling case-sensitivity
//
#define CASESENS(c)     ( CaseSensitive ? (c) : towupper((c)) )

STATIC
BOOLEAN
Match(
        OUT PARGUMENT                   Argument,
        OUT PARGUMENT_LEXEMIZER ArgumentLexemizer,
        IN      BOOLEAN                         CaseSensitive
        )
/*++

Routine Description:

    Tries to match a pattern, and if there is a match it
        sets the value of the corresponding argument.

Arguments:

        Argument                        -       Supplies pointer to argument
        ArgumentLexemizer       -       Supplies pointer to lexed string list
        CaseSensitive           -       Supplies case sensitivity flag

Return Value:

    TRUE  - argument recognized and value set.
    FALSE - argument not recognized and/or value not set.

--*/
{

    BOOLEAN         fFound;
        CHNUM                   chnCurrent = 0;
        CHNUM                   chnEnd = 0;
        PWSTRING                Lexeme;
        PWSTRING                Pattern;
        CHNUM                   chn;


        if (!(Lexeme = ArgumentLexemizer->GetLexemeAt( ArgumentLexemizer->QueryConsumedCount()))) {
                return FALSE;
        }

        Pattern = Argument->GetPattern();

        fFound = FALSE;

        //
        //      If first character in the pattern is a switch, see if the
        //      first character in the Lexeme is also a switch.
        //
        if ( Pattern->QueryChCount() > 0 &&
                 Lexeme->QueryChCount() > 0 &&
                 ArgumentLexemizer->GetSwitches()->Strchr( Pattern->QueryChAt(0)) != INVALID_CHNUM ) {

                if ( ArgumentLexemizer->GetSwitches()->Strchr( Lexeme->QueryChAt(0)) != INVALID_CHNUM ) {
                        //
                        //      Switch, advance pointer
                        //
                        chn = 1;

                } else {
                        //
                        //      No switch, no match
                        //
                        return FALSE;
                }

        } else {
                //
                //      This is not a switch pattern, match from the beginning
                //
                chn = 0;
        }

        for ( ; ; chn++ ) {

                switch( Pattern->QueryChAt( chn ) ) {

                case (WCHAR)'#':

                        //
                        //  Optional space between flag and argument
                        //
                        if ( Lexeme->QueryChAt( chn ) == INVALID_CHAR ) {

                                //
                                // At the end of the Argument string.  Must get the next.
                                //
                                ArgumentLexemizer->IncrementConsumedCount();
                                Lexeme = ArgumentLexemizer->GetLexemeAt( ArgumentLexemizer->QueryConsumedCount() );

                                if (!Lexeme) {
                                        goto FAIL;
                                }

                                chn = 0;

                        }

                        chnCurrent = chn;
                        chnEnd     = Lexeme->QueryChCount();
                        fFound     = TRUE;
                        break;


                case (WCHAR)'*':

                        //
                        //  No space allowed between flag and argument
                        //
                        if ( !(Lexeme->QueryChAt( chn )) ||
                                 !(TailMatch( Pattern, Lexeme, chn, &chnEnd, CaseSensitive ))) {

                                goto FAIL;
                        }

                        chnCurrent = chn;
                        fFound     = TRUE;
                        break;


                case INVALID_CHAR:

                        //
                        //  Space required beteen flag and argument
                        //
                        if( Lexeme->QueryChAt( chn ) != INVALID_CHAR) {
                                goto FAIL;

                        }

                        Lexeme = ArgumentLexemizer->GetLexemeAt( ArgumentLexemizer->QueryConsumedCount() );
                        ArgumentLexemizer->IncrementConsumedCount();
                        fFound = TRUE;
                        chnEnd++;
                        break;



                default:

                        if ( CASESENS(Lexeme->QueryChAt( chn )) != CASESENS(Pattern->QueryChAt( chn )) ) {
                                goto FAIL;
                        }
                        chnEnd++;
                }

                if (fFound) {
                        break;
                }

        }

        //
        // The patterns matched, see if the argument is recognized.
        //
        if (Argument->SetValue( Lexeme, chnCurrent, chnEnd, ArgumentLexemizer ) == FALSE ) {
                goto FAIL;
        }

        //DELETE( Lexeme );

        return TRUE;

FAIL:
        //DELETE( Lexeme );
        return FALSE;
}


STATIC
BOOLEAN
TailMatch(
    IN  PWSTRING Pattern,
    IN  PWSTRING String,
        IN      CHNUM                   chn,
        OUT PCHNUM                      chnEnd,
        IN      BOOLEAN                 CaseSensitive
        )
/*++

Routine Description:

    Performs tailmatching of a pattern and a string

Arguments:

        Pattern                 -       Supplies pointer to pattern
        String                  -       Supplies pointer to string
        chn                     -       Supplies index of current char
        chnEnd                  -       Supplies pointer to index of first character to
                                                match in tail;
        CaseSensitive   -       Supplies case sensitivity flag

Return Value:

    TRUE  if match
    FALSE otherwise

--*/
{
    CHNUM PatternIndex;
    CHNUM StringIndex;

        PatternIndex = Pattern->QueryChCount() - 1;
        StringIndex  = String->QueryChCount() - 1;


    if (chn == PatternIndex) {

        //
        // wild card is the last thing in the format, it matches.
        //
                *chnEnd = StringIndex + 1 ;
                return TRUE;
    }

    //
    //  Check characters walking towards front
    //
        while( CASESENS(Pattern->QueryChAt(PatternIndex)) == CASESENS(String->QueryChAt(StringIndex)) ) {

        if ( chn == PatternIndex ) {
            break;
        }

        PatternIndex--;
        StringIndex--;

    }

    //
    // If we're back at the beginning of the Pattern and the string is
    // either at the beginning or somewhere inside then we have a match.
        //
        *chnEnd = StringIndex + 1;

        return( (PatternIndex == chn ) && ( StringIndex != INVALID_CHNUM ) );
}


#if !defined( _AUTOCHECK_ )


DEFINE_EXPORTED_CONSTRUCTOR( REST_OF_LINE_ARGUMENT, ARGUMENT, ULIB_EXPORT );

ULIB_EXPORT
BOOLEAN
REST_OF_LINE_ARGUMENT::Initialize(
    )
{
    return ARGUMENT::Initialize("*");
}

BOOLEAN
REST_OF_LINE_ARGUMENT::SetIfMatch(
    IN OUT  PARGUMENT_LEXEMIZER    ArgumentLexemizer,
    IN      BOOLEAN                CaseSensitive
    )
/*++

Routine Description:

    This routine computes whether or not the current state of the argument lexemizer
    lends itself to a MACRO argument as described by DOS 5's DOSKEY function.  If the
    current state of the argument lexemizer is indeed in such a state then this routine
    will grab all of the remaining tokens on the line and copy the contents of the
    command line from the current token to the end of the line in this class's argument.

Arguments:

    ArgumentLexemizer   - Supplies the argument lexemizer.
    CaseSensitive       - Supplies whether or not to distinguish letters based solely on case.

Return Value:

    FALSE   - argument not recognized and/or value not set.
    TRUE    - argument recognized and value set.

--*/
{
    CHNUM   char_pos;
    ULONG   consumed_count;

    consumed_count = ArgumentLexemizer->QueryConsumedCount();
    char_pos = ArgumentLexemizer->QueryCharPos(consumed_count);

    if (!_RestOfLine.Initialize(ArgumentLexemizer->GetCmdLine(), char_pos)) {
        _fValueSet = FALSE;
        return FALSE;
    }


    // Consume all of the remaining tokens.

    ArgumentLexemizer->IncrementConsumedCount(
            ArgumentLexemizer->QueryLexemeCount() - consumed_count);

    _fValueSet = TRUE;

    return TRUE;
}


#endif // _AUTOCHECK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\inc\cstring.h ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	wstring.h

Abstract:

	This module contains the prototypes for the wide character
	C-runtime support. Since there is no C-runtime support for
	wide characters, the functions here are wrappers to the
	single-byte counterparts

Author:

	Ramon San Andres (Ramonsa)	07-Jun-1991

Revision History:

--*/

typedef char	wchar;
typedef WCHAR	wchar_t;
typedef size_t	wsize_t;

long	watol( const wchar *);
wchar * wcschr(const wchar *, int);
wchar * wcslwr(wchar *);
wchar * wcsrchr(const wchar *, int);
wchar * wcsupr(wchar *);
wsize_t wcscspn(const wchar *, const wchar *);
wsize_t wcsspn(const wchar *, const wchar *);
wchar * wcsstr(const wchar *, const wchar *);
int 	wctomb( char *s, wchar_t wchar );
int 	mbtowc(wchar_t *pwc, const char *s, size_t n);
wchar_t towupper( wchar_t wc);

INLINE
long
watol(
	const wchar * p
	)
{
	return atol( (char *)p );
}


INLINE
wchar *
wcschr (
	const wchar * p,
	int 		  c
	)
{
	return (wchar *)strchr( (char *)p, c);
}


INLINE
wchar *
wcslwr (
	wchar * p
	)
{
	return (wchar *)strlwr( (char *)p );
}

INLINE
wchar *
wcsrchr (
	const wchar * p,
	int 		  c
	)
{
	return (char *)strrchr( (char *)p, c);
}

INLINE
wchar *
wcsupr (
	wchar * p
	)
{
	return (char *)strupr( (char *)p );
}


INLINE
wsize_t
wcscspn (
	const wchar *p1,
	const wchar *p2
	)
{

	return (wsize_t)strcspn( (char *)p1, (char *)p2);

}

INLINE
wsize_t
wcsspn (
	const wchar *p1,
	const wchar *p2
	)
{

	return (wsize_t)strspn( (char *)p1, (char *)p2);

}


INLINE
wchar *
wcsstr (
	const wchar *p1,
	const wchar *p2
	)
{

	return (wchar *)strstr( (char *)p1, (char *)p2);

}


INLINE
int
wctomb (
	char *s,
	wchar_t wchar
	)
{

	if (s) {
		*s = (char)wchar;
		return 1;
	} else {
		return 0;
	}
}


INLINE
int
mbtowc (
	wchar_t *pwc,
	const char *s,
	size_t n
	)
{
	UNREFERENCED_PARAMETER( n );

	if ( s && *s && (n > 0) ) {
		*pwc = (wchar_t)(*s);
		return 1;
	} else {
		return 0;
	}

}


INLINE
wchar_t
towupper(
	wchar_t wc
	)
{

	return (wchar_t)toupper( (char)wc );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\array.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        array.cxx

Abstract:

        This module contains the definition for the ARRAY class. ARRAY is a
        concrete implementation of a SORTABLE_CONTAINER. It extends the interface
        to allow for easy access uswing a simple ULONG as an index. It is
        dynamically growable and supports bases other than zero.

Author:

        David J. Gilman (davegi) 02-Nov-1990

Environment:

        ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( ARRAY, SORTABLE_CONTAINER, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( ARRAY );

VOID
ARRAY::Construct (
        )

/*++

Routine Description:

        Construct an ARRAY by setting the initial value of of the OBJECT array
        pointer to NULL.

Arguments:

        None.

Return Value:

        None.

--*/

{
        _ObjectArray    = NULL;
}





ULIB_EXPORT
ARRAY::~ARRAY (
        )

/*++

Routine Description:

        Destroy an ARRAY by freeing it's internal storage. Note that this
    deletes the array, not the objects themselves.

Arguments:

        None.

Return Value:

        None.

--*/

{
        if ( _ObjectArray ) {
                FREE( _ObjectArray );
        }
}



ULIB_EXPORT
BOOLEAN
ARRAY::Initialize (
        IN ULONG        Capacity,
        IN ULONG        CapacityIncrement
        )

/*++

Routine Description:

        Initialize an ARRAY object by setting it's internal state to supplied
        or default values. In addition allocate an initial chunk of memory for
        the actual storage of POBJECTs.

Arguments:

        Capacity                        - Supplies the total number of OBJECTs the ARRAY
                                                  can contain
        CapacityIncrement       - Supplies the number of OBJECTs to make room for
                                                  when growing the ARRAY

Return Value:

        BOOLEAN - TRUE if the ARRAY is successfully initialized.

--*/

{
        DebugAssert( Capacity != 0 );

    //
    //  If re-initializing, se reuse the current array
    //
    if ( _ObjectArray ) {
        _Capacity = SetArrayCapacity( Capacity );
    } else {
        _ObjectArray = (PPOBJECT)CALLOC( (UINT)Capacity,
                                         sizeof( POBJECT ) );
        _Capacity    = Capacity;
    }

        _CapacityIncrement      = CapacityIncrement;
    _PutIndex           = 0;

#if DBG==1
    _IteratorCount      = 0;
#endif

    if ( _ObjectArray ) {
        DebugCheckHeap();
        return TRUE;
    } else {
        return FALSE;
    }
}

ULIB_EXPORT
BOOLEAN
ARRAY::DeleteAllMembers (
        )

/*++

Routine Description:

    Deletes all the members of the array

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if all members deleted

--*/

{
    PPOBJECT    PObject;

    if ( _PutIndex > 0 ) {

#if 0   // Bogus assert due to compiler error.  Put it back in when compiler fixed
#if DBG==1
        DebugAssert( _IteratorCount == 0 );
#endif
#endif

        PObject = &_ObjectArray[ _PutIndex - 1 ];

        while ( PObject >= _ObjectArray ) {
            DELETE( *PObject );
            PObject--;
        }

        _PutIndex = 0;
    }

    return TRUE;
}




POBJECT
ARRAY::GetAt (
        IN ULONG                Index
        ) CONST

/*++

Routine Description:

        Retrieves the OBJECT at the specified Index.

Arguments:

        Index - Supplies the index of the OBJECT in question.

Return Value:

        POBJECT - A constant pointer to the requested OBJECT.

--*/

{
        DebugPtrAssert( _ObjectArray );

    if ( (_PutIndex > 0) && (Index < _PutIndex) ) {
        return _ObjectArray[ Index ];
    } else {
        return NULL;
    }
}



ULONG
ARRAY::GetMemberIndex (
    IN POBJECT      Object
    ) CONST

/*++

Routine Description:

    Returns the position (index) of an object in the array.

Arguments:

    POBJECT - Pointer to the OBJECT in question.

Return Value:

    ULONG - The position of the OBJECT in the array. If the OBJECT is not
            in the array, returns INVALID_INDEX.

--*/

{
    ULONG   Index;

    DebugPtrAssert( _ObjectArray );
    DebugPtrAssert( Object );

    if( Object == NULL ) {
        return( INVALID_INDEX );
    }

    Index = 0;
    while( ( Index < QueryMemberCount() ) &&
           ( _ObjectArray[ Index ] != Object ) ) {
        Index++;
    }
    return( ( Index < QueryMemberCount() )? Index : INVALID_INDEX );
}



ULIB_EXPORT
BOOLEAN
ARRAY::Put (
        IN OUT  POBJECT Member
        )

/*++

Routine Description:

        Puts an OBJECT at the next available location in the array.

Arguments:

        Member  -   Supplies the OBJECT to place in the array

Return Value:

    BOOLEAN -   TRUE if member put, FALSE otherwise

--*/

{
    DebugPtrAssert( Member );
    DebugPtrAssert( _PutIndex <= _Capacity );

    //
    //  Grow the array if necessary
    //
    if ( _PutIndex >= _Capacity ) {
        if ( _PutIndex >= SetArrayCapacity( _Capacity + _CapacityIncrement ) ) {
            //
            //  Could not grow the array
            //

            return FALSE;
        }
    }

    _ObjectArray[ _PutIndex++ ] = Member;

    return TRUE;

}



BOOLEAN
ARRAY::PutAt (
        IN OUT  POBJECT Member,
    IN      ULONG   Index
        )

/*++

Routine Description:

    Puts an OBJECT at a particular location in the ARRAY.
    The new object has to replace an existing object, i.e. the
    index has to be smaller than the member count.

Arguments:

        Member  - Supplies the OBJECT to place in the ARRAY
    Index   - Supplies the index where the member is to be put

Return Value:

    BOOLEAN -   TRUE if member put, FALSE otherwise


--*/

{
    DebugPtrAssert( Member );
    DebugPtrAssert( Index < _PutIndex );

    if ( Index < _PutIndex ) {
        _ObjectArray[ Index ] = Member;
        return TRUE;
    }

    return FALSE;
}


ULIB_EXPORT
PITERATOR
ARRAY::QueryIterator (
        ) CONST

/*++

Routine Description:

        Create an ARRAY_ITERATOR object for this ARRAY.

Arguments:

        None.

Return Value:

        PITERATOR - Pointer to an ITERATOR object.

--*/

{
    PARRAY_ITERATOR   Iterator;

    //
    //  Create new iterator
    //
    if ( Iterator = NEW ARRAY_ITERATOR ) {

        //
        //  Initialize the iterator
        //
        if ( !Iterator->Initialize( (PARRAY)this ) ) {
            DELETE( Iterator );
        }
    }

    return Iterator;
}



ULONG
ARRAY::QueryMemberCount (
        ) CONST

/*++

Routine Description:

    Obtains the number of elements in the array

Arguments:

    None

Return Value:

    ULONG   -   The number of members in the array


--*/

{
    return _PutIndex;
}


ULIB_EXPORT
POBJECT
ARRAY::Remove (
        IN OUT  PITERATOR   Position
        )

/*++

Routine Description:

    Removes a member from the array

Arguments:

    Position    -   Supplies an iterator whose currency is to be removed

Return Value:

    POBJECT -   The object removed


--*/

{
    PARRAY_ITERATOR Iterator;

    DebugPtrAssert( Position );
    DebugPtrAssert( ARRAY_ITERATOR::Cast( Position ));

    Iterator = (PARRAY_ITERATOR)Position;

    return RemoveAt( Iterator->QueryCurrentIndex() );
}


POBJECT
ARRAY::RemoveAt (
    IN  ULONG   Index
        )

/*++

Routine Description:

    Removes a member from the array

Arguments:

    Index   -   Supplies the index of the member to be removed

Return Value:

    POBJECT -   The object removed


--*/

{
    POBJECT    Object = NULL;

    if ( Index < _PutIndex ) {

        // DebugAssert( _IteratorCount <= 1 );

        //
        //  Get the object
        //
        Object = (POBJECT)_ObjectArray[ Index ];

        //
        //  Shift the rest of the array
        //
        memmove ( &_ObjectArray[ Index ],
                  &_ObjectArray[ Index + 1 ],
                  (UINT)(_PutIndex - Index - 1) * sizeof( POBJECT ) );

       //
       //   Update the _PutIndex
       //
       _PutIndex--;

    }

    return Object;
}



ULONG
ARRAY::SetCapacity (
    IN  ULONG   Capacity
        )

/*++

Routine Description:

    Sets the capacity of the array. Will not shrink the array if the
    capacity indicated is less than the number of members in the array.

Arguments:

    Capacity -   New capacity of the array

Return Value:

    ULONG   -   The new capacity of the array


--*/

{
    if ( Capacity >= _PutIndex ) {

        SetArrayCapacity( Capacity );

    }

    return _Capacity;
}


BOOLEAN
ARRAY::Sort (
    IN  BOOLEAN Ascending
        )

/*++

Routine Description:

    Sorts the array

Arguments:

    Ascending   -   Supplies ascending flag

Return Value:

    BOOLEAN -   TRUE if array sorted, FALSE otherwise


--*/

{
        int (__cdecl *CompareFunction)(const void *, const void*);

        CompareFunction = Ascending ?
                      &ARRAY::CompareAscending :
                      &ARRAY::CompareDescending;

        qsort( _ObjectArray,
                  (size_t)_PutIndex,
                  sizeof(POBJECT),
                  CompareFunction );

        return TRUE;
}


BOOLEAN
ARRAY::Insert(
    IN OUT  POBJECT     Member,
    IN      ULONG       Index
    )
/*++

Routine Description:

    Inserts an element in the array at the specified position, shifting
    elements to the right if necessary.

Arguments:

    Member  -   Supplies pointer to object to be inserted in the array

    Index   -   Supplies the index where the element is to be put

Return Value:

    BOOLEAN -   TRUE if new element inserted, FALSE otherwise


--*/

{
    DebugPtrAssert( Member );
    DebugPtrAssert( Index <= _PutIndex );

    //
    //  Make sure that there will be enough space in the array for the
    //  new element
    //
    if ( _PutIndex >= _Capacity ) {

        if ( _PutIndex >= SetArrayCapacity( _Capacity + _CapacityIncrement ) ) {
            //
            //  Could not grow the array
            //
            return FALSE;
        }
    }

    //
    //  If required, shift the array to the right to make space for the
    //  new element.
    //
    if ( Index < _PutIndex ) {

        memmove ( &_ObjectArray[ Index + 1 ],
                  &_ObjectArray[ Index ],
                  (UINT)( _PutIndex - Index ) * sizeof( POBJECT ) );
    }

    //
    //  Insert the element
    //
    _ObjectArray[ Index ] = Member;

    //
    //  Increment the number of elements in the array
    //
    _PutIndex++;

    return TRUE;
}



ULONG
ARRAY::SetArrayCapacity (
    IN  ULONG   NumberOfElements
        )

/*++

Routine Description:

    Sets the capacity of the array. Allways reallocs the array.

Arguments:

    NewSize -   New capacity of the array

Return Value:

    ULONG   -   The new capacity of the array


--*/

{
    PPOBJECT   Tmp;

    Tmp = (PPOBJECT)REALLOC( _ObjectArray,
                             (UINT)NumberOfElements * sizeof(POBJECT) );

    if ( Tmp ) {
        _ObjectArray = Tmp;
        _Capacity    = NumberOfElements;
    }

    return _Capacity;
}


int __cdecl
ARRAY::CompareAscending (
    IN const void * Object1,
    IN const void * Object2
        )

/*++

Routine Description:

    Compares two objects.

Arguments:

    Object1 -   Supplies pointer to first object
    Object2 -   Supplies pointer to second object

Return Value:

        Returns:

                    <0  if Object1 is less that    Object2
                         0      if Object1 is equal to     Object2
                        >0      if Object1 is greater than Object2


--*/

{
    return  (*(POBJECT *)Object1)->Compare( *(POBJECT *)Object2 );
}



int __cdecl
ARRAY::CompareDescending (
    IN const void * Object1,
    IN const void * Object2
        )

/*++

Routine Description:

    Compares two objects

Arguments:

    Object1 -   Supplies pointer to first object
    Object2 -   Supplies pointer to second object

Return Value:

        Returns:

                        <0      if Object2 is less that    Object1
                         0      if Object2 is equal to     Object1
                        >0      if Object2 is greater than Object1

--*/

{
    return  (*(POBJECT *)Object2)->Compare( *(POBJECT *)Object1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\arrayit.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	arrayit.cxx

Abstract:

	This file contains the definitions for the ARRAY_ITERATOR class. 
	ARRAY_ITERATOR is a concrete implementation of the abstract ITERATOR
	class.

Author:

	David J. Gilman (davegi) 03-Dec-1990

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"


DEFINE_CAST_MEMBER_FUNCTION( ARRAY_ITERATOR );

DEFINE_CONSTRUCTOR( ARRAY_ITERATOR, ITERATOR );


VOID
ARRAY_ITERATOR::Construct (
	)

/*++

Routine Description:

	Construct an ARRAY_ITERATOR by setting it's current index to 0 and it's
	associated ARRAY to NULL.

Arguments:

	None.

Return Value:

	None.

--*/

{
	_Array = NULL;
}



ARRAY_ITERATOR::~ARRAY_ITERATOR (
    )
/*++

Routine Description:

    Destructor for the ARRAY_ITERATOR class

Arguments:

    None

Return Value:

    None

--*/

{
#if DBG==1
    if ( _Array ) {
        _Array->_IteratorCount--;
    }
#endif
}




VOID
ARRAY_ITERATOR::Reset(
    )

/*++

Routine Description:

    Resets the iterator

Arguments:

    None

Return Value:

    None

--*/

{
    _CurrentIndex = INVALID_INDEX;
}



POBJECT
ARRAY_ITERATOR::GetCurrent(
	)
/*++

Routine Description:

    Gets current member

Arguments:

    None

Return Value:

    POBJECT -   Pointer to current member in  the array

--*/

{
    if ( _CurrentIndex == INVALID_INDEX ) {
        return NULL;
    } else {
        return _Array->GetAt( _CurrentIndex );
    }
}




POBJECT
ARRAY_ITERATOR::GetNext(
	)
/*++

Routine Description:

    Gets next member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to next member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that INVALID_INDEX + 1 == 0
    //
    _CurrentIndex++;

    if ( _CurrentIndex >= _Array->QueryMemberCount() ) {
        _CurrentIndex = INVALID_INDEX;
    }

    //
    //  Get next
    //
    return _Array->GetAt( _CurrentIndex );
}


POBJECT
ARRAY_ITERATOR::GetPrevious(
	)
/*++

Routine Description:

    Gets previous member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to previous member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that 0 - 1 == INVALID_INDEX
    //

    if ( _CurrentIndex == INVALID_INDEX ) {
        _CurrentIndex = _Array->QueryMemberCount() - 1;
    } else {
        _CurrentIndex--;
    }

    //
    //  Get next
    //
    return _Array->GetAt( _CurrentIndex );
}




BOOLEAN
ARRAY_ITERATOR::Initialize (
	IN PARRAY	Array
	)

/*++

Routine Description:

	Associate an ARRAY with this ARRAY_ITERATOR and reset the current index

Arguments:

    Array   -   Supplies pointer to the array object

Return Value:

	BOOLEAN - Returns TRUE if the initialization was succesful.

--*/

{
	DebugPtrAssert( Array );

#if DBG==1
    if ( _Array ) {
        _Array->_IteratorCount--;
    }
    Array->_IteratorCount++;
#endif
    _Array          = Array;
    _CurrentIndex   = INVALID_INDEX;


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\bitvect.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	bitvect.cxx

Abstract:

	This module contains the definition for thje BITVECTOR class.

Author:

	David J. Gilman (davegi) 01-Feb-1991
	Barry Gilhuly (w-barry)
	Norbert P. Kusters (norbertk)

Environment:

	ULIB, User Mode

[Notes:]

	optional-notes

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include    "ulib.hxx"
#include    "bitvect.hxx"
#include    <limits.h>

//
// Invalid bit count
//

CONST PT	InvalidBitCount = (PT)(-1);

//
// Static member data.
//

//
// Bits per byte value table e.g. 27->4 bits
//
// Algorithm:
//
//	_BitsSetLookUp[0] = 0;
//
// 		For the ranges [1,1],[2,3],[4,7],[8,15],...,[128,255].
//
//		for (n = (( PT ) 1 ); n <= 8; n++) {
//
//
//			Compute range for loop.
//
//			r = (( PT ) 1 ) << (n - (( PT ) 1 ));
//
//
// 			[r, 2*r - 1 ] = [0, r - 1] + 1;
//
//			for (i = 0; i < r; i++) {
//				_BitsSetLookUp[i + r] = _BitsSetLookUp[i] + (( PT ) 1 );
//			}
//		}
//    }
//

CONST BYTE	BITVECTOR::_BitsSetLookUp[ 256 ] = {

	0, 1, 1, 2, 1, 2, 2, 3,
	1, 2, 2, 3, 2, 3, 3, 4,
	1, 2, 2, 3, 2, 3, 3, 4,
	2, 3, 3, 4, 3, 4, 4, 5,
	1, 2, 2, 3, 2, 3, 3, 4,
	2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	1, 2, 2, 3, 2, 3, 3, 4,
	2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6,
	4, 5, 5, 6, 5, 6, 6, 7,
	1, 2, 2, 3, 2, 3, 3, 4,
	2, 3, 3, 4, 3, 4, 4, 5,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6,
	4, 5, 5, 6, 5, 6, 6, 7,
	2, 3, 3, 4, 3, 4, 4, 5,
	3, 4, 4, 5, 4, 5, 5, 6,
	3, 4, 4, 5, 4, 5, 5, 6,
	4, 5, 5, 6, 5, 6, 6, 7,
	3, 4, 4, 5, 4, 5, 5, 6,
	4, 5, 5, 6, 5, 6, 6, 7,
	4, 5, 5, 6, 5, 6, 6, 7,
	5, 6, 6, 7, 6, 7, 7, 8
};


DEFINE_EXPORTED_CONSTRUCTOR( BITVECTOR, OBJECT, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( BITVECTOR );

VOID
BITVECTOR::Construct (
	)

/*++

Routine Description:

	Construct a BITVECTOR.

Arguments:

	None.

Return Value:

	None.

--*/

{
	REGISTER PT	pt;

	//
	//  Find the number of bits per PTs
	//

	_BitsPerPT	 = sizeof( PT ) * CHAR_BIT;

	//
	// Set the smallest number of PTs needed
	//

	_PTCount	 = (( PT ) 1 );

	//
	//  Create the mask used to separate the array index from the bit index
	//

	_BitPositionMask = _BitsPerPT - (( PT ) 1 );

	//
	//  Count the number of bits required to make the shift count for
	//  accessing the Primitive Type.
	//

	for( _IndexShiftCount = 0, pt = _BitPositionMask; pt;
	pt >>= (( PT ) 1 ), _IndexShiftCount++ );

	//
	// Initialize BITVECTOR state.
	//

	_BitVector		= NULL;
	_PTCount		= 0;
	_FreeBitVector	= FALSE;
}

ULIB_EXPORT
BOOLEAN
BITVECTOR::Initialize (
	IN PT	Size,
	IN BIT	InitialValue,
	IN PPT 	Memory
	)

/*++

Routine Description:

	Construct a BITVECTOR with at least the size specified and
	initialize all bits to SET or RESET.

Arguments:

	Size			- Supplies the number of bits in the vector
	InitialValue	- Supplies the initial value for the bits
	Memory			- Supplies a memory buffer to use for the vector

Return Value:

	BOOLEAN - Returns TRUE if the BITVECTOR was succesfully initialized.

Notes:

	Minimum and default BITVECTOR size is the number of bits in
	one PT.  Default initializer is RESET.	The size of a BITVECTOR
	is rounded up to the nearest whole multiple of (_BitsPerPT * CHAR_BIT).

	If the client supplies the buffer it is the client's responsibility
	to ensure that Size and the size of the buffer are in sync.
	Also SetSize will not change the size of a client supplied
	buffer.

--*/

{
	//
	// Destroy the internals of a previous BITVECTOR.
	//

	Destroy( );

	//
	//  Find the number of PTs that will be required for this BITVECTOR
	//  (handles smallest size case (Size = 0) ).
	//

	_PTCount	 = Size ? (( Size + _BitsPerPT - (( PT ) 1 )) / _BitsPerPT ) : (( PT ) 1 );

	//
	//  If Memory was supplied use that for the vector else allocate
	// the vector.
	//

	if( Memory ) {

		_BitVector = Memory;

    } else {
		_FreeBitVector = TRUE;
		if( !( _BitVector = ( PT* ) MALLOC(( size_t ) ( _PTCount * sizeof( PT ))))) {

			return FALSE;
		}
    }

	//
	//  Set the bitvector to the supplied value ( SET | RESET )
	//

	( InitialValue == SET ) ? SetAll( ) : ResetAll( );

    return TRUE;
}

ULIB_EXPORT
BITVECTOR::~BITVECTOR (
	)

/*++

Routine Description:

	Destroy a BITVECTOR by calling it's Destroy function.

Arguments:

	None.

Return Value:

	None.

--*/

{
	Destroy( );
}

VOID
BITVECTOR::Destroy (
	)

/*++

Routine Description:

	Destroy a BITVECTOR by possibly freeing it's internal storage.

Arguments:

	None.

Return Value:

	None.

--*/
{
	if( _FreeBitVector ) {

		DebugAssert( _BitVector != NULL );
		FREE( _BitVector );
	}
}

ULIB_EXPORT
PT
BITVECTOR::SetSize (
	IN PT	Size,
	IN BIT	InitialValue
	)

/*++

Routine Description:

	Set the number of bits in the vector

Arguments:

	Size 		- Supplies the number of bits to set the vector size to
	InitialValue- Supplies the initial value for the bits

Return Value:

	PT - Returns the new size of this BITVECTOR in bits.

Notes:

	SetSize will merrily truncate the vector with no warning.

	Minimum and default BITVECTOR size is the number of bits in
	one PT. Default initializer is RESET.  The size of a BITVECTOR
	is rounded up to the nearest whole multiple of (_BitsPerPT * CHAR_BIT).

	If the client supplied the buffer refuse to change it's size

--*/

{
	REGISTER	PT	PTCountNew;
				PT	cbitsNew;
				PT	cbitsOld;

	//
	//  Check that the bitvector was created...
	//

	DebugPtrAssert( _BitVector );
	if( _BitVector == NULL ) {
		return( 0 );
    }

	//
	//	If the client supplied the buffer, refuse to change it's size.
	//

	if( ! _FreeBitVector ) {
		return( _PTCount * _BitsPerPT );
    }


	//
	//  Compute the number of PTs and bits required for the new size
	//

	PTCountNew = Size ? (( Size + _BitsPerPT - (( PT ) 1 ) ) / _BitsPerPT ) : (( PT ) 1 );
	cbitsNew = PTCountNew * _BitsPerPT;

	if( PTCountNew != _PTCount ) {

		//
		//	The new size requires a different number of PTs then the old
		//

		if( !( _BitVector = ( PT* ) REALLOC(( VOID* ) _BitVector,
		( size_t ) ( PTCountNew * sizeof( PT ))))) {

			return( 0 );
		}
    }

	//
	//  If the new size contains more bits, initialize them to the supplied
	//  value
	//

	cbitsOld = _PTCount * _BitsPerPT;
	_PTCount = PTCountNew;

	if( cbitsNew > cbitsOld ) {
		if( InitialValue == SET ) {
			SetBit( cbitsOld, cbitsNew - cbitsOld );
		} else {
			ResetBit( cbitsOld, cbitsNew - cbitsOld );
		}
    }

	return( _PTCount * _BitsPerPT );
}

ULIB_EXPORT
VOID
BITVECTOR::SetBit (
	IN PT	Index,
	IN PT	Count
	)

/*++

Routine Description:

	SET the supplied range of bits

Arguments:

	Index - Supplies the index at which to start setting bits.
	Count - Supplies the number of bits to set.

Return Value:

    None.

Notes:

	It may be faster to compute masks for setting sub-ranges.

--*/

{
    REGISTER    PT  ptCurBit;

	DebugAssert( _BitVector != NULL );
	DebugAssert(( Index + Count ) <= ( _PTCount * _BitsPerPT ));

    // Set count to be the max instead.
    Count += Index;

    for (ptCurBit = Index; (ptCurBit < Count) &&
                           (ptCurBit & _BitPositionMask); ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] |=
            (1 << (ptCurBit & _BitPositionMask));
    }

    for (; ptCurBit + 8*sizeof(PT) <= Count; ptCurBit += 8*sizeof(PT)) {
        _BitVector[ptCurBit >> _IndexShiftCount] = 0xffffffff;
    }

    for (; ptCurBit < Count; ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] |=
            (1 << (ptCurBit & _BitPositionMask));
    }
}

ULIB_EXPORT
VOID
BITVECTOR::ResetBit (
	IN PT	Index,
	IN PT	Count
	)

/*++

Routine Description:

	RESET the supplied range of bits

Arguments:

	Index - Supplies the index at which to start resetting bits.
	Count - Supplies the number of bits to reset.

Return Value:

    None.

Notes:

	It may be faster to compute masks for resetting sub-ranges.

--*/

{
    REGISTER    PT  ptCurBit;

	DebugAssert( _BitVector != NULL );
	DebugAssert(( Index + Count ) <= ( _PTCount * _BitsPerPT ));

    // Set count to be the max instead.
    Count += Index;

    for (ptCurBit = Index; (ptCurBit < Count) &&
                           (ptCurBit & _BitPositionMask); ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] &=
            ~(1 << (ptCurBit & _BitPositionMask));
    }

    for (; ptCurBit + 8*sizeof(PT) <= Count; ptCurBit += 8*sizeof(PT)) {
        _BitVector[ptCurBit >> _IndexShiftCount] = 0;
    }

    for (; ptCurBit < Count; ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] &=
            ~(1 << (ptCurBit & _BitPositionMask));
    }
}

VOID
BITVECTOR::ToggleBit (
	IN PT	Index,
	IN PT	Count
	)

/*++

Routine Description:

	Toggle the supplied range of bits.

Arguments:

	Index - Supplies the index at which to start toggling bits.
	Count - Supplies the number of bits to toggle.

Return Value:

	None.

--*/

{
	REGISTER	PT  ptCurBit;

	DebugAssert( _BitVector != NULL );
	DebugAssert( Index + Count <= _PTCount * _BitsPerPT);

	while( Count-- ) {
		ptCurBit = Index + Count;
		if( IsBitSet( ptCurBit )) {
			ResetBit( ptCurBit );
		} else {
			SetBit( ptCurBit );
		}
	}
}

ULIB_EXPORT
PT
BITVECTOR::ComputeCountSet(
	) CONST

/*++

Routine Description:

	Compute the number of bits that are set in the bitvector using a table
	look up.

Arguments:

	None.

Return Value:

	PT - Returns the number of set bits.

--*/

{
	REGISTER PCBYTE 	pbBV;
	REGISTER PT		 	i;
	REGISTER PT         BitsSet;

	//
	// Cast the bitvector into a string of bytes.
	//

	pbBV = ( PCBYTE ) _BitVector;

	//
	// Initialize the count to zero.
	//

	BitsSet = 0;

	//
	// For all of the bytes in the bitvector.
	//

	for (i = 0; i < _PTCount * sizeof( PT ); i++) {

		//
		// Add the number of bits set in this byte to the total.
		//

		BitsSet += _BitsSetLookUp[pbBV[ i ]];
	}

	return( BitsSet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\basesys.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    basesys.cxx

Abstract:

    This is the implementation of BASE_SYSTEM class.

Author:

    David J. Gilman (davegi) 13-Jan-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "basesys.hxx"

extern "C" {
    #include <stdio.h>
#if defined( _AUTOCHECK_ )

    #include "ntos.h"
//
// This stuff is lifted from winuser.h, because with _AUTOCHECK_ we
// shouldn't include windows header files.
//

#define MAKEINTRESOURCEW(i) (LPWSTR)((ULONG_PTR)((USHORT)(i)))
#define MAKEINTRESOURCE  MAKEINTRESOURCEW
#define RT_MESSAGETABLE     MAKEINTRESOURCE(11)

#endif // _AUTOCHECK_

};

ULIB_EXPORT
BOOLEAN
BASE_SYSTEM::QueryResourceString(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format ...
    )
/*++

Routine Description:

    This routine computes the resource string identified by the resource
    identifier 'MsgId'.  In addition to the 'printf' format strings
    supported, 'QueryResourceString' supports :

        1. '%W' - Expects a pointer to a WSTRING.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    ...             - Supplies the arguments to the resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    va_start(ap, Format);
    r = QueryResourceStringV(ResourceString, MsgId, Format, ap);
    va_end(ap);

    return r;
}


ULIB_EXPORT
BOOLEAN
BASE_SYSTEM::QueryResourceStringV(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format,
    IN  va_list     VarPointer
    )
/*++

Routine Description:

    This is a 'varargs' implementation of 'QueryResourceString'.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    VarPointer      - Supplies a varargs pointer to the arguments of the
                        resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

#define NUMBER_OF_ARGS      20
    STATIC LONG     InitializingHandle = 0;
    STATIC HANDLE   lib_handle = 0;

    PWSTR           args[NUMBER_OF_ARGS];
    WSTR            fmt[20];
    INT             i, j;
    PWSTR           p;
    PWSTRING        gstring;
    DSTRING         UnicodeFormat;
    WSTR            display_buffer[4096];
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingHandle, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

#if !defined( _AUTOCHECK_ )
    if (!lib_handle) {
        lib_handle = GetModuleHandle((LPWSTR)L"ulib.dll");
        DebugAssert(lib_handle);
        if (!lib_handle) {
            status = InterlockedDecrement(&InitializingHandle);
            DebugAssert(status == 0);
            return FALSE;
        }
    }
#else
    NTSTATUS        Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    PWSTR           MessageFormat;
    ULONG           Result;
    ANSI_STRING     AnsiString;
    UNICODE_STRING  UnicodeString;

    if (!lib_handle) {
        lib_handle = (PVOID)NtCurrentPeb()->ImageBaseAddress;
        DebugAssert(lib_handle);
        if (!lib_handle) {
            status = InterlockedDecrement(&InitializingHandle);
            DebugAssert(status == 0);
            return FALSE;
        }
    }
#endif

    status = InterlockedDecrement(&InitializingHandle);
    DebugAssert(status == 0);

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        args[i] = NULL;
    }

    if (!UnicodeFormat.Initialize(Format)) {
        return FALSE;
    }

    i = 0;
    for (p = (PWSTR) UnicodeFormat.GetWSTR(); *p; p++) {
        if (*p == '%') {
            if (*(p + 1) == 'W') {
                p++;
                gstring = va_arg(VarPointer, PWSTRING);
                gstring->QueryWSTR(0, TO_END, display_buffer, 4096);
            } else {
                j = 0;
                fmt[j++] = *p++;
                while (*p && *p != '%') {
                    if ((*p == 's' || *p == 'c') && *(p - 1) != 'w') {
                        fmt[j++] = 'h';
                    }
                    fmt[j++] = *p++;
                }
                p--;
                fmt[j] = 0;
                if (wcsncmp(fmt, L"%I64", 4) == 0)
                    swprintf(display_buffer, fmt, va_arg(VarPointer, LARGE_INTEGER));
                else
                    swprintf(display_buffer, fmt, va_arg(VarPointer, PVOID));
            }
            args[i] = (PWSTR)MALLOC(wcslen(display_buffer) * sizeof(WCHAR) +
                sizeof(WCHAR));
            if (NULL == args[i]) {
                return FALSE;
            }
            wcscpy( args[i++], display_buffer);
        }
    }

#if !defined( _AUTOCHECK_ )
    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  (LPVOID)lib_handle,
                  (ULONG)MsgId,
                  0L,
                  display_buffer,
                  4096,
                  (va_list *)args);

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        FREE(args[i]);
    }

    return ResourceString->Initialize(display_buffer);

#else
    Status = RtlFindMessage( lib_handle,
                             (ULONG_PTR)RT_MESSAGETABLE,

#if defined JAPAN   // v-junm - 08/03/93
// The default TEB's value for NT-J is set to 0x411(JP) in the hives.  Since
// we do not want Japanese messages to come out in the boot screen, we have to
// force autochk.exe to pick up the English text rather than the Japanese.
//
// NOTE:  This has to be done because the current version of autochk.exe has
//      bilingual messages.  It's more efficient to make a US version rather
//      than a bilingual version to save space.
                             0x409,
#else
                             0,
#endif
                             (ULONG)MsgId,
                             &MessageEntry
                           );

    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    if (!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {
        RtlInitAnsiString( &AnsiString, (PCSZ)&MessageEntry->Text[ 0 ] );
        Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
        }

        MessageFormat = UnicodeString.Buffer;
    } else {
        MessageFormat = (PWSTR)MessageEntry->Text;
        UnicodeString.Buffer = NULL;
    }

    Status = RtlFormatMessage( MessageFormat,
                               0,
                               FALSE,
                               FALSE,
                               TRUE,
                               (va_list *)args,
                               (PWSTR)display_buffer,
                               sizeof( display_buffer ),
                               &Result
                             );

    if (UnicodeString.Buffer != NULL) {
        RtlFreeUnicodeString( &UnicodeString );
    }

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        FREE(args[i]);
    }

    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    return ResourceString->Initialize(display_buffer);

#endif // _AUTOCHECK_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\bstring.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    bstring.cxx

Author:

    Norbert P. Kusters (norbertk) 6-Aug-92

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "bstring.hxx"

#include <stdio.h>


INLINE
VOID
BSTRING::Construct(
    )
{
    _s = NULL;
    _l = 0;
}



DEFINE_CONSTRUCTOR( BSTRING, OBJECT );


BOOLEAN
BSTRING::Initialize(
    IN  PCSTR   InitialString,
    IN  CHNUM   StringLength
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (StringLength == TO_END) {
        StringLength = MBSTR::Strlen((PSTR)InitialString);
    }

    if (!NewBuf(StringLength)) {
        return FALSE;
    }

    memcpy(_s, InitialString, (UINT) StringLength*sizeof(CHAR));

    return TRUE;
}


VOID
BSTRING::DeleteChAt(
    IN  CHNUM   Position,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine removes the character at the given position.

Arguments:

    Position    - Supplies the position of the character to remove.
    Length      - Supplies the number of characters to remove.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    memmove(_s + Position, _s + Position + Length,
            (UINT) (_l - Position - Length)*sizeof(CHAR));

    Resize(_l - Length);
}



NONVIRTUAL
BOOLEAN
BSTRING::ReplaceWithChars(
    IN CHNUM        AtPosition,
    IN CHNUM        AtLength,
    IN CHAR         Character,
    IN CHNUM        FromLength
    )
/*++

Routine Description:

    This routine replaces the contents of this string from
    AtPosition of AtLength with the string formed by Character
    of FromLength.

Arguments:

    AtPosition      - Supplies the position to replace at.
    AtLength        - Supplies the length to replace at.
    Character       - Supplies the character to replace with.
    FromLength      - Supplies the total number of new characters to replace the old one with.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;
    PSTR    currptr, endptr;

    DebugAssert(AtPosition <= _l);

    AtLength = min(AtLength, _l - AtPosition);

    // Make sure up front that we have the room but don't disturb
    // the string.

    if (FromLength > AtLength) {
        old_length = _l;
        if (!Resize(_l + FromLength - AtLength)) {
            return FALSE;
        }
        Resize(old_length);
    }

    DeleteChAt(AtPosition, AtLength);
    old_length = _l;

    if (!Resize(_l + FromLength)) {
        DebugPrint("This should not fail\n");
        return FALSE;
    }

    memmove(_s + AtPosition + FromLength, _s + AtPosition,
            (UINT) (old_length - AtPosition)*sizeof(CHAR));

    for (currptr = _s + AtPosition, endptr = currptr + FromLength;
         currptr < endptr;
         currptr++) {
        *currptr = Character;
    }

    return TRUE;
}


PSTR
BSTRING::QuerySTR(
    IN  CHNUM   Position,
    IN  CHNUM   Length,
    OUT PSTR    Buffer,
    IN  CHNUM   BufferLength,
    IN  BOOLEAN ForceNull
    ) CONST
/*++

Routine Description:

    This routine makes a copy of this string into the provided
    buffer.  If this string is not provided then a buffer is
    allocated on the heap.

Arguments:

    Position        - Supplies the position within this string.
    Length          - Supplies the length of this string to take.
    Buffer          - Supplies the buffer to convert into.
    BufferLength    - Supplies the number of characters in this buffer.
    ForceNull       - Specifies whether or not to force a NULL even
                        when the buffer is too small for the string.

Return Value:

    A pointer to a NULL terminated multi byte string.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    if (!Buffer) {
        BufferLength = Length + 1;
        if (!(Buffer = (PSTR) MALLOC(BufferLength*sizeof(CHAR)))) {
            return NULL;
        }
    }

    if (BufferLength > Length) {
        memcpy(Buffer, _s + Position, (UINT) Length*sizeof(CHAR));
        Buffer[Length] = 0;
    } else {
        memcpy(Buffer, _s + Position, (UINT) BufferLength*sizeof(CHAR));
        if (ForceNull) {
            Buffer[BufferLength - 1] = 0;
        }
    }

    return Buffer;
}



INLINE
VOID
BDSTRING::Construct(
    )
/*++

Routine Description:

    This routine initializes the string to a valid initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _length = 0;
}



#define     DUMMY_ULIB_EXPORT

DEFINE_EXPORTED_CONSTRUCTOR( BDSTRING, BSTRING, DUMMY_ULIB_EXPORT );


BDSTRING::~BDSTRING(
    )
/*++

Routine Description:

    Destructor for BDSTRING.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_buf);
}


BOOLEAN
BDSTRING::Resize(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTR   new_buf;

    if (NewStringLength >= _length) {

        if (_buf) {
            if (!(new_buf = (PSTR)
                  REALLOC(_buf, (NewStringLength + 1)*sizeof(CHAR)))) {

                return FALSE;
            }
        } else {
            if (!(new_buf = (PSTR)
                  MALLOC((NewStringLength + 1)*sizeof(CHAR)))) {

                return FALSE;
            }
        }

        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}


BOOLEAN
BDSTRING::NewBuf(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTR   new_buf;

    if (NewStringLength >= _length) {

        if (!(new_buf = (PSTR)
              MALLOC((NewStringLength + 1)*sizeof(CHAR)))) {

            return FALSE;
        }

        if (_buf) {
            FREE(_buf);
        }
        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\buffer.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    This contains all buffer class definition.
    Buffers do not have implicit terminations. Sizes on construction
    should include any termination bytes.

Author:

    steve rowe	    stever	27-Nov-90

Environment:

    ULIB, User Mode

Notes:



Revision History:

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "buffer.hxx"

#if defined( __BCPLUSPLUS__ )

	#include <mem.h>
#else
	
	extern "C" {
		#include <memory.h>
	}; 

#endif // __BCPLUSPLUS__

//
// _ThresHold is the constant used by ReAllocate to determine when
// to actually call realloc to shrink the buffer.
//

ULONG BUFFER::_ThresHold = 129;

DEFINE_CONSTRUCTOR( BUFFER, OBJECT );

VOID
BUFFER::Construct (
	)

/*++

Routine Description:

	Construct a BUFFER by initializing it's internal state.

Arguments:

	None.

Return Value:

	None.

--*/

{
	cb			= 0;
	_BufSize	= 0;
	pBuffer 	= NULL;
}

BUFFER::~BUFFER (
	)

/*++

Routine Description:

    Destructor for general buffer class

Arguments:

    None

Return Value:

    None.

--*/

{
	if( pBuffer ) {
		FREE(pBuffer);
	}
}

BOOLEAN
BUFFER::BuffCat (
	IN PCBUFFER  Buffer2
	)

/*++

Routine Description:

    Concatenates a buffer with this buffer.

Arguments:

	Buffer2 - Buffer to add to current buffer.

Return Value:

	TRUE - success
	FALSE - failed to reallocate memory.

--*/

{
	REGISTER ULONG	cbT;
	PCHAR			pTmp;

    // Note W-Barry   11-JUN-91   Needed to add a variable to hold the
	//	current value of cb since the reallocate routine has been changed
	//	to update 'cb' when called...
	//
	ULONG			CurrentCount;

	cbT = cb + Buffer2->QueryBytesInBuffer();
	CurrentCount = cb;
	if ((pTmp = (char *)ReAllocate( cbT )) != NULL) {
		memcpy( pTmp + CurrentCount, Buffer2->GetBufferPtr(), (size_t)(cbT - CurrentCount) );
		pBuffer = pTmp;
		cb = cbT;
		return( TRUE );
	}
	return( FALSE );
}

BOOLEAN
BUFFER::BufferCopyAt (
	IN	PCVOID	BufferToCopy,
	IN	ULONG	cbToCopy,
	IN	ULONG	oStart
	)

/*++

Routine Description:

    Copies a number of bytes from a buffer to a particular location.
    Note that the total buffer size my increase, it will not decrease.
    This way replaces can be done. StartingByte can be past end of
    current buffer. What would lie between end of buffer and
	startingbyte would be undefined.

	WARNING: BufferToCopy cannot point into this buffer.

Arguments:

    BufferToCopy  - Supplies the buffer to copy
    SizeOfBuffer  - Supplies the number of bytes to copy

Return Value:

    ULONG - number of bytes copied.
	0 - if error. check error stack.

--*/

{


	ULONG 	cbT;
	PCHAR   pBufferNew;

	//
	// Enforce warning
	//

/*** Note davegi What does warning mean?

	DebugAssert(((( PCHAR ) pBuffer + cb ) <= BufferToCopy ) &&
		( BufferToCopy < (PCHAR ) pBuffer ));

***/
	/*
	Copies to yourself are rare and will fall through the code so
	no special action is taken.

	Copes of a null will fall through since realloc will free the
	buffer for a size of 0.

	If the new buffer will fit in the old the size is not reduced to
	the end of the new buffer. This is to support sub-string replacement.
	The caller then must be aware of how the copy effects buffer size.
	*/

	cbT = oStart + cbToCopy;
	pBufferNew = (PCHAR) pBuffer;
	// will it fit in current buffer
	if (cb < cbT) {
		if ((pBufferNew = (char *)ReAllocate( cbT )) != NULL) {
			cb = cbT;
		} else {
			return( FALSE );
		}
	}

	memcpy (pBufferNew + oStart, BufferToCopy, (size_t)cbToCopy);
	pBuffer = pBufferNew;
	return( TRUE );
}

BOOLEAN
BUFFER::DeleteAt(
	IN ULONG cbToDelete,
	IN ULONG oStartDelete
	)

/*++

Routine Description:

	Deletes the specificied section of the current buffer

Arguments:

	cbToDelete      - Supplies the number of bytes to delete
	oStartDelete    - Supplies the offset for the delete

Return Value:

	TRUE  - insert success
	FALSE - This can happen when cbToDelete is larger then
			the size of the buffer, oStartDelete is past the
			end of the buffer.
--*/


{
	if (oStartDelete < cb) {
		if (cbToDelete <= cb) {
			cb = cb - cbToDelete;
			pBuffer = ( PCCHAR )ReAllocate( cb );
			DebugPtrAssert( pBuffer );
			memmove(( PCCHAR )pBuffer + oStartDelete ,
					 ( PCCHAR )pBuffer + (oStartDelete + cbToDelete),
					 (size_t)(cb - oStartDelete) );
			return( TRUE );
		}
	}
	return( FALSE );
}

BOOLEAN
BUFFER::InsertAt (
	IN PCVOID	BufferToCopy,
	IN ULONG	cbToCopy,
	IN ULONG    oStartCopy
	)

/*++

Routine Description:

	Inserts the specificied buffer of bytes at the specified
	location.

Arguments:

	BufferToCopy  - Supplies the buffer to insert
	cbToCopy      - Supplies the number of bytes to insert
	oStartCopy	  - Supplies the offset for the insertion

Return Value:

	TRUE  - insert success
	FALSE - This can happen for memory allocation failure
			or oStartCopy is past end of buffer.
--*/

{
	ULONG	cbT;

    // Note W-Barry   11-JUN-91   Necessary to add since cb is currently
	// being updated by ReAllocate().
	size_t	CountToMove;
	PCHAR	pTmp;

	CountToMove = (size_t)( cb - oStartCopy );
	if (oStartCopy < cb ) {
		cbT = cb + cbToCopy;
		if ((pTmp = (char *)ReAllocate( cbT )) != NULL) {
			memmove( pTmp + (oStartCopy + cbToCopy),
					 pTmp + oStartCopy,
					 CountToMove );
			memcpy( pTmp + oStartCopy, BufferToCopy, (size_t)cbToCopy );
			pBuffer = pTmp;
			cb = cbT;
			return( TRUE );
		}
	}
	return( FALSE );
}

BOOLEAN
BUFFER::PutBuffer (
	IN PCBUFFER		BufferToCopy
	)

/*++

Routine Description:

    Constructor for Buffer object. The buffer held in BufferToCopy
    is not moved but copied to this object. If failed to init orginal
    buffer state retained.

Arguments:

	BufferToCopy - pointer to BUFFER object to copy

Return Value:

	BOOLEAN - Returns TRUE if supplied buffer was succesfully copied

--*/

{

    ULONG   cbNew;
	PVOID   pBufferNew;

	cbNew = BufferToCopy->QueryBytesInBuffer ();

	if (( pBufferNew = MALLOC( (size_t)cbNew )) != NULL) {
		if( SetBuffer( pBufferNew, cbNew) ) {
            // Note the buffer is not shortened on this?
			pBuffer = BufferToCopy->GetBufferPtr();
			BufferCopyAt( pBuffer, cbNew );
			return( TRUE );
		}
    }

    return( FALSE );
}

BOOLEAN
BUFFER::SetBuffer (
	IN PVOID InitialBuffer,
	IN ULONG SizeOfBuffer
	)

/*++

Routine Description:

    Constructor for Buffer object. The buffer passed in should not be
    freed by the caller. BUFFER will free in upon deletion.

Arguments:

    InitialBuffer - pointer to buffer
    SizeOfBuffer  - size of buffer in bytes.

Return Value:

    None.

--*/

{
	if (cb) {
		FREE (pBuffer);
	}

	pBuffer = InitialBuffer;
	cb = SizeOfBuffer;
	_BufSize = SizeOfBuffer;

    return( TRUE );
}

PVOID
BUFFER::ReAllocate (
	IN ULONG	NewCount
	)

/*++

Routine Description:

	Reallocates the private data member pBuffer if required. ReAllocate
	supports the concept that BUFFER's internal buffer can be larger
	than the number of bytes actually in use.


Arguments:

	NewCount - Supplies the new size of pBuffer in bytes.


Return Value:

	PVOID - Returns a pointer to the 'newly allocated' pBuffer.

--*/

{
	REGISTER PVOID	pv;

	//
	// If the new buffer size is greater than what we currently have
	// in reserve, or it is smaller than the threshold, realloc the
	// buffer.
	//

	if( ( NewCount > _BufSize )			||
		( ( _BufSize - NewCount ) >= _ThresHold )
	  ) {

		//
		// If the realloc of the buffer succeeds, record it's actual size.
		//

		if(( pv = REALLOC( pBuffer, (size_t)NewCount )) != NULL ) {

			pBuffer  = pv;
			_BufSize = cb = NewCount;

		}
	} else {

		//
		// Enough storage is available in reserve, just return the
		// existing pointer.
		//

		_BufSize = cb = NewCount;
		pv = pBuffer;
	}

	return( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\bytestrm.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

    bytestrm.cxx

Abstract:

	This module contains the definitions of the member functions
    of BYTE_STREAM class.

Author:

    Ramon J. San Andres (ramonsa) 28-Feb-1992

Environment:

	ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "stream.hxx"
#include "bytestrm.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( BYTE_STREAM, OBJECT, ULIB_EXPORT );

VOID
BYTE_STREAM::Construct (
    )

/*++

Routine Description:

    Constructs a BYTE_STREAM object

Arguments:

    None.

Return Value:

    None.


--*/

{
    _Stream         = NULL;
    _Buffer         = NULL;
    _NextByte       = NULL;
    _BufferSize     = 0;
    _BytesInBuffer  = 0;
}



ULIB_EXPORT
BYTE_STREAM::~BYTE_STREAM (
	)

/*++

Routine Description:

    Destroy a BYTE_STREAM.

Arguments:

	None.

Return Value:

	None.

--*/

{
    FREE( _Buffer );
}






ULIB_EXPORT
BOOLEAN
BYTE_STREAM::Initialize (
    IN  PSTREAM Stream,
    IN  DWORD   BufferSize
    )

/*++

Routine Description:

    Initializes a BYTE_STREAM

Arguments:

    Stream      -   Supplies the stream to be used
    BufferSize  -   Supplies the size of the buffer to use

Return Value:

    BOOLEAN -   TRUE if successful.

--*/

{
    STREAMACCESS    Access;

    DebugPtrAssert( Stream );
    DebugAssert( BufferSize > 0 );

    FREE( _Buffer );

    Access = Stream->QueryAccess();

    if ( (Access == READ_ACCESS) || (Access == READ_AND_WRITE_ACCESS)) {

        if ( _Buffer = (PBYTE)MALLOC( BufferSize ) ) {

            _Stream         = Stream;
            _NextByte       = _Buffer;
            _BufferSize     = BufferSize;
            _BytesInBuffer  = 0;

            return TRUE;

        }
    }

    return FALSE;
}



ULIB_EXPORT
BOOLEAN
BYTE_STREAM::FillAndReadByte(
    IN  PBYTE   Byte
    )
/*++


Routine Description:

    Fills the buffer and reads next byte

Arguments:

    Byte    -   Supplies pointer to where to put the byte

Return Value:

    BOOLEAN -   TRUE if byte read.

--*/

{
    ULONG   BytesRead;

    DebugAssert( _BytesInBuffer == 0 );

    if ( _Stream->Read( _Buffer, _BufferSize, &BytesRead ) &&
         (BytesRead > 0) ) {

        _NextByte       = _Buffer;
        _BytesInBuffer  = (DWORD)BytesRead;

        *Byte = *_NextByte++;
        _BytesInBuffer--;

        return TRUE;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\clasdesc.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	clasdesc.cxx

Abstract:

	This module contains the definition for the CLASS_DESCRIPTOR class. 
	CLASS_DESCRIPTOR classes are special concrete classes derived from 
	OBJECT. They are special in that a single staic object of this class
	exists for every other concrete class in the Ulib hierarchy. 
	CLASS_DESCRIPTORs allocate and maintain information that can be used
	at run-time to determine the actual type of an object.

Author:

	David J. Gilman (davegi) 30-Oct-1990

Environment:

	ULIB, User Mode

Notes:

	The definitions for all concrete class' CLASS_DESCRIPTORs can be found
	in the file ulib.cxx.

	See the Cast member function in ulibdef.hxx to see how dynamic casting
	and CLASS_DESCRIPTORs work.

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"


ULIB_EXPORT
CLASS_DESCRIPTOR::CLASS_DESCRIPTOR (
	)
{
}

#if DBG==1

//
// For debugging purposes CLASS_DESCRIPTORs maintain the name of the class
// that they describe.
//

#include <string.h>
 
ULIB_EXPORT
BOOLEAN
CLASS_DESCRIPTOR::Initialize (
	IN PCCLASS_NAME 	ClassName
	)

/*++

Routine Description:

	Initialize a CLASS_DESCRIPTOR object by initializing the classname
	and class ids.

Arguments:

	ClassName - Supplies the name of the class being described.

Return Value:

    None.

--*/

{
	DebugPtrAssert( ClassName );
	strncpy(( PCCHAR ) _ClassName,
		( PCCCHAR ) ClassName,
		( INT ) _MaxClassNameLength );

	//
	// Note that this guarantees that the CLASS_ID is unique for all classes
	// at the expense of not being able to recognize a class based on it's
	// CLASS_ID. The benefit is that IDs are guaranteed to be unique and
	// do not have to be cleared or registered.
	//

	_ClassID = ( ULONG_PTR ) &_ClassID;
	return( TRUE );
}

#else  // DBG==0

ULIB_EXPORT
BOOLEAN
CLASS_DESCRIPTOR::Initialize (
	)

/*++

Routine Description:

	Initialize a CLASS_DESCRIPTOR object by initializing the class id.

Arguments:

Return Value:

    None.

--*/

{
	_ClassID = ( ULONG_PTR ) &_ClassID;
	return( TRUE );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\chkmsg.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "chkmsg.hxx"
#include "array.hxx"
#include "arg.hxx"
#include "iterator.hxx"
#include "system.hxx"
#include "stream.hxx"
#include "keyboard.hxx"
#include "rtmsg.h"
#include "screen.hxx"


DEFINE_EXPORTED_CONSTRUCTOR(CHKDSK_MESSAGE, MESSAGE, ULIB_EXPORT)

VOID
CHKDSK_MESSAGE::Construct(
    )
/*++

Routine Description:

    Constructor for CHKDSK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _msgtype = NORMAL_MESSAGE;
    _out_stream = NULL;
    _in_stream = NULL;
    _err_stream = NULL;
    _case_sensitive = FALSE;
    _copy_input = FALSE;
}


ULIB_EXPORT
CHKDSK_MESSAGE::~CHKDSK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for CHKDSK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
CHKDSK_MESSAGE::Initialize(
    IN OUT  PSTREAM OutputStream,
    IN OUT  PSTREAM InputStream,
    IN OUT  PSTREAM ErrorStream
    )
/*++

Routine Description:

    This routine initializes the CHKDSK_MESSAGE object to the specified stream.

Arguments:

    OutputStream    - Supplies the output stream for the object.
    InputStream     - Supplies the input stream for the object.
    ErrorStream     - Supplies the error stream for the object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (OutputStream == NULL ||
        InputStream == NULL) {
        return FALSE;
    }

    _out_stream = OutputStream;
    _in_stream = InputStream;
    _err_stream = ErrorStream;
    _copy_input = SCREEN::Cast(OutputStream) ? FALSE : TRUE;


#ifdef FE_SB
    LANGID LangId;

    switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
#endif

    return MESSAGE::Initialize();
}

ULIB_EXPORT
BOOLEAN
CHKDSK_MESSAGE::Set(
    IN  MSGID           MsgId,
    IN  MESSAGE_TYPE    MessageType,
    IN  ULONG           MessageVisual
    )
/*++

Routine Description:

    This routine sets up the class to display the message with the
    'MsgId' resource identifier.

Arguments:

    MsgId       - Supplies the resource id of the message.
    MessageType - Supplies the type of the message.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SetMessageId(MsgId);
    _msgtype = MessageType;
    _msgvisual = MessageVisual;
    return TRUE;
}


BOOLEAN
CHKDSK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style list format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (! (_msgvisual & TEXT_MESSAGE) )
    {
        return TRUE;
    }

    if (!SYSTEM::QueryResourceStringV(&_display_string,
                                      GetMessageId(),
                                      Format,
                                      VarPointer)) {
        return FALSE;
    }

    return DisplayString();
}


ULIB_EXPORT
BOOLEAN
CHKDSK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries either a "yes" or "no" from the input stream.

Arguments:

    Default - Supplies the default answer if neither "yes" nor "no" is the
                recognized input.

Return Value:

    FALSE   - A "no" response.
    TRUE    - A "yes" response.

--*/
{
    DSTRING     input;
    DSTRING     yes_message;
    DSTRING     no_message;
    WCHAR       w;

    Flush();

    if (!SYSTEM::QueryResourceString(&yes_message, MSG_YES, "")) {
        return Default;
    }

    if (!SYSTEM::QueryResourceString(&no_message, MSG_NO, "")) {
        return Default;
    }

    for (;;) {
        if (!ReadLine(&input)) {
            return Default;
        }

        if (!input.Strupr()) {
            return Default;
        }

        w = input.QueryChAt(0);

        if (w == no_message.QueryChAt(0) || w == '0') {
            return FALSE;
        }

        if (w == yes_message.QueryChAt(0) || w == '1') {
            return TRUE;
        }

        DisplayString();
    }
}


BOOLEAN
CHKDSK_MESSAGE::QueryStringInput(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine queries a string from the user.

Arguments:

    String  - Supplies a buffer to return the string into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return ReadLine(String);
}


BOOLEAN
CHKDSK_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    This routine waits for a signal from the user.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING string;

    return (BOOLEAN) (Flush() && ReadLine(&string));
}


MSGID
CHKDSK_MESSAGE::SelectResponse(
    IN  ULONG   NumberOfSelections ...
    )
/*++

Routine Description:

    This routine queries input from the user in order to determine which
    message was entered.  It then returns the message id of the message
    entered.

Arguments:

    NumberOfSelections  - Supplies the number of message ids.
    ...                 - Supplies the message ids.

Return Value:

    The message id of the message entered, or the first message id.

--*/
{
    va_list             ap;
    ARRAY               lex_array;
    ARRAY               arg_array;
    PFLAG_ARGUMENT      flag_arg;
    ARGUMENT_LEXEMIZER  arg;
    DSTRING             input_string;
    MSGID               first;
    PITERATOR           arg_it;
    ULONG               i;
    DSTRING             match_string;
    DSTRING             del;

    va_start(ap, NumberOfSelections);
    first = va_arg(ap, MSGID);
    va_end(ap);

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return first;
    }

    if (!arg.Initialize(&lex_array)) {
        return first;
    }

    arg.SetCaseSensitive(_case_sensitive);

    va_start(ap, NumberOfSelections);
    for (i = 0; i < NumberOfSelections; i++) {
        SYSTEM::QueryResourceString(&match_string, va_arg(ap, MSGID), "");

        if (!(flag_arg = NEW FLAG_ARGUMENT) ||
            !flag_arg->Initialize(&match_string) ||
            !arg_array.Put(flag_arg)) {
            va_end(ap);
            return first;
        }
    }
    va_end(ap);

    Flush();

    if (!ReadLine(&input_string)) {
        return first;
    }

    if (!arg.PrepareToParse(&input_string)) {
        return first;
    }

    if (!arg.DoParsing(&arg_array)) {
        return first;
    }

    arg_it = arg_array.QueryIterator();
    va_start(ap, NumberOfSelections);
    for (i = 0; i < NumberOfSelections; i++) {
        flag_arg = (PFLAG_ARGUMENT) arg_it->GetNext();
        if (flag_arg->QueryFlag()) {
            first = va_arg(ap, MSGID);
        } else {
            va_arg(ap, MSGID) ? 1 : 0;
        }
        DELETE(flag_arg);
    }
    va_end(ap);

    DELETE(arg_it);

    return first;
}


PMESSAGE
CHKDSK_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MSG object.

--*/
{
    PCHKDSK_MESSAGE   p;

    if (!(p = NEW CHKDSK_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize(_out_stream, _in_stream)) {
        DELETE(p);
        return NULL;
    }

    return p;
}


VOID
CHKDSK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns an CHKDSK_MESSAGE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _msgtype = NORMAL_MESSAGE;
    _out_stream = NULL;
    _in_stream = NULL;
    _err_stream = NULL;
    _case_sensitive = FALSE;
    _copy_input = FALSE;
}


BOOLEAN
CHKDSK_MESSAGE::ReadLine(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine reads a line from the input stream.

Arguments:

    String  - Returns the read in string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING del;
    WCHAR   w;

    if (!del.Initialize("\r\n")) {
        return FALSE;
    }

    if (_in_stream->IsAtEnd()) {
        return FALSE;
    }

    String->Initialize( "" );

    if (!_in_stream->ReadString(String, &del)) {
        return FALSE;
    }

    // Line feed is the last character on the line.

    for (;;) {
        if (_in_stream->IsAtEnd()) {
            return TRUE;
        }

        if (!_in_stream->ReadChar(&w)) {
            return FALSE;
        }

        if (w == '\n') {
            break;
        }
    }

    if (_copy_input) {
        _out_stream->WriteString(String, 0, String->QueryChCount());
        _out_stream->WriteString(&del, 0, del.QueryChCount());
        if (IsLoggingEnabled()) {
            LogMessage(String);
            LogMessage(&del);
        }
    }

    return TRUE;
}


BOOLEAN
CHKDSK_MESSAGE::Flush(
    )
/*++

Routine Description:

    This routine flushes the input stream of all previously typed input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PKEYBOARD   key;

    if (key = KEYBOARD::Cast(_in_stream)) {
        return key->Flush();
    }

    return TRUE;
}


BOOLEAN
CHKDSK_MESSAGE::DisplayString(
    )
/*++

Routine Description:

    This routine prints this objects current string to the
    appropriate output.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTREAM stream;

    if (! (_msgvisual & TEXT_MESSAGE) )
    {
        return TRUE;
    }

    if (_msgtype == ERROR_MESSAGE && _err_stream) {
        stream = _err_stream;
    } else {
        stream = _out_stream;
    }

    if (!stream->WriteString(&_display_string, 0, TO_END, 40)) {
        return FALSE;
    }

    if (IsLoggingEnabled() && !IsSuppressedMessage()) {
        LogMessage(&_display_string);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\cmem.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    cmem.cxx

Abstract:

    Implementation of class CMEM.

Author:

    Norbert P. Kusters (norbertk) 26-Nov-90

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "cmem.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( CONT_MEM, MEM, ULIB_EXPORT );

VOID
CONT_MEM::Construct (
    )
/*++

Routine Description:

    Constructor for CONT_MEM.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _size = 0;
}


ULIB_EXPORT
BOOLEAN
CONT_MEM::Initialize(
    IN  PVOID   Buffer,
    IN  ULONG   Size
    )
/*++

Routine Description:

    This routine supplies the object with a store of memory from which to
    work with.

Arguments:

    Buffer  - Supplies a pointer to memory.
    Size    - Supplies the number of bytes of memory addressable through
                the pointer.

Return Value:

    None.

--*/
{
    _buf = Buffer;
    _size = Size;

    return TRUE;
}


ULIB_EXPORT
PVOID
CONT_MEM::Acquire(
    IN  ULONG   Size,
    IN  ULONG   AlignmentMask
    )
/*++

Routine Description:

    This routine takes size bytes of memory from the current memory
    pool and returns it to the user.  If size bytes of memory are not
    available then this routine return NULL.  After a call to this routine
    the local pool of memory is decreased by Size bytes.  Successive requests
    will be granted as long as there is sufficient memory to grant them.

    This method will fail if the memory is not at the alignment requested.

Arguments:

    Size        - Supplies the number of bytes of memory requested.
    Alignment   - Supplies the necessary alignment for the memory.

Return Value:

    A pointer to size bytes of memory or NULL.

--*/
{
    PVOID   rv;

    if (Size > _size ||
        ((ULONG_PTR) _buf)&AlignmentMask) {
        return NULL;
    }

    _size -= Size;
    rv = _buf;
    _buf = (PCHAR) _buf + Size;
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\bufstrm.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bufstrm.cxx

Abstract:

    This module contains the definitions of the member functions
    of BUFFER_STREAM class.

Author:

    Jaime Sasson (jaimes) 14-Apr-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "bufstrm.hxx"
#include "mbstr.hxx"
#include "system.hxx"
#include "wstring.hxx"

extern "C" {
    #include <ctype.h>
}

DEFINE_CONSTRUCTOR ( BUFFER_STREAM, STREAM );



BUFFER_STREAM::~BUFFER_STREAM (
    )

/*++

Routine Description:

    Destroy a BUFFER_STREAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
    FREE( _Buffer );
}



VOID
BUFFER_STREAM::Construct (
    )

/*++

Routine Description:

    Constructs a BUFFER_STREAM object

Arguments:

    None.

Return Value:

    None.


--*/

{
    _Buffer = NULL;
    _BufferSize = 0;
    _CurrentByte = NULL;
    _BytesInBuffer = 0;
    _BufferStreamType = -1;
}


BOOLEAN
BUFFER_STREAM::Initialize (
    ULONG   BufferSize
    )

/*++

Routine Description:

    Initialize an object of type BUFFER_STREAM.
    A BUFFER_STREAM object cannot be reinitialized.

Arguments:

    BufferSize - Size of the buffer to be allocated.
                 The size of the buffer can be zero, but in this case no
                 memory will be allocated. This initialization should be used
                 only by FILE_STREAM when it is mapping a file in memory. In
                 this case, all methods that read from the buffer or test
                 the end of the file will be overloaded by methods defined
                 in FILE_STREAM.

Return Value:

    BOOLEAN - Returns TRUE if the initialization succeed.

--*/

{
    BOOLEAN Result;

    Result = FALSE;
    if( BufferSize != 0 ) {
        //
        //      The +2 is needed becase the buffer needs to be
        //      double NUL terminated
        //
        _Buffer = ( PBYTE ) MALLOC( ( size_t )( BufferSize + 2 ) );
        if( _Buffer != NULL ) {
            *( _Buffer + BufferSize ) = 0;
            *( _Buffer + BufferSize + 1 ) = 0;
            _BufferSize = BufferSize;
            _CurrentByte = NULL;
            _BytesInBuffer = 0;
            Result = TRUE;
        }
    } else {
        _Buffer = NULL;
        _BufferSize = 0;
        _CurrentByte = NULL;
        _BytesInBuffer = 0;
        Result = TRUE;
    }
    return( ( STREAM::Initialize() ) && Result );
}



ULONG
BUFFER_STREAM::FlushBuffer (
    )

/*++

Routine Description:

    Empty the buffer. The contents of the buffer is lost, and the
    buffer is reinitialized.

Arguments:

    None.

Return Value:

    ULONG - Returns the number of bytes lost in the buffer.

--*/

{
    ULONG   BytesLost;

    BytesLost = _BytesInBuffer;
    _CurrentByte = NULL;
    _BytesInBuffer = 0;
    return( BytesLost );
}



BOOLEAN
BUFFER_STREAM::IsAtEnd(
    ) CONST

/*++

Routine Description:

    Informs the caller if all bytes were read (the buffer is empty and
    end of file has occurred.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE indicates that there is no more byte to read.


--*/

{
    return( ( _BytesInBuffer == 0 ) && EndOfFile() );
}

VOID
BUFFER_STREAM::SetStreamTypeANSI()
{
     _BufferStreamType = 0;
}

BOOLEAN
BUFFER_STREAM::DetermineStreamType(
     IN OUT PBYTE        *Buffer,
     IN ULONG        BufferSize
     )
/*++
Routine Description:
    Sets _BufferStreamType for memory mapped files, called from
    file_stream.

Arguments:
    Pointer to data & byte count.

Return Value:
    True always.
--*/
{
    BOOL bUnicode;

    if (_BufferStreamType < 0) {
#ifdef FE_SB
        //
        // We would like to check the possibility of IS_TEXT_UNICODE_DBCS_LEADBYTE.
        //
        INT     iResult = ~0x0;

        __try {
            bUnicode = IsTextUnicode((LPTSTR)*Buffer, (INT)BufferSize, &iResult);
        } __except ( EXCEPTION_EXECUTE_HANDLER ) {
            DebugPrintTrace(("ULIB: Exception code %08x in IsTextUnicode\n", GetExceptionCode()));
            return FALSE;
        }

        _BufferStreamType = 0;

        //
        // if the text contains ByteOrderMark. It is unicode text.
        //
        if ((iResult & IS_TEXT_UNICODE_SIGNATURE) != 0) {

            _BufferStreamType = 1;
            *Buffer+=2;

        } else if (bUnicode &&
                   (((iResult & IS_TEXT_UNICODE_UNICODE_MASK) != 0) ||
                    ((iResult & IS_TEXT_UNICODE_REVERSE_MASK) != 0)) &&
                   !(iResult & IS_TEXT_UNICODE_NOT_UNICODE_MASK)) {
            //
            // If the result depends only upon statistics, check
            // to see if there is a possibility of DBCS.
            //
            LPSTR pch = (LPSTR)*Buffer;
            UINT   cb = BufferSize;

            while (cb > 0) {
                __try {
                    if (IsDBCSLeadByte(*pch)) {
                        bUnicode = FALSE;
                        break;
                    }
                } __except ( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                    _BufferStreamType = -1;
                    return FALSE;
                }
                cb--;
                pch++;
            }

            if (bUnicode)
                _BufferStreamType = 1;
        }
#else
        __try {
            bUnicode = IsTextUnicode((LPTSTR)*Buffer, (INT)BufferSize, NULL);
        } __except ( EXCEPTION_EXECUTE_HANDLER ) {
            DebugPrintTrace(("ULIB: Exception code %08x in IsTextUnicode\n", GetExceptionCode()));
            return FALSE;
        }

        if (bUnicode) {
           _BufferStreamType = 1;
           if (*((LPWCH)*Buffer) == (WCHAR)0xfeff)
               *Buffer+= 2 ; // eat the Byte Order Mark
        } else
           _BufferStreamType = 0;
#endif // FE_SB
    }
    return TRUE;
}


BOOLEAN
BUFFER_STREAM::Read(
    OUT PBYTE       Buffer,
    IN  ULONG       BytesToRead,
    OUT PULONG      BytesRead
    )

/*++

Routine Description:

    Reads data from the buffer.

Arguments:

    Buffer - Points to the buffer where the data will be put.

    BytesToRead - Indicates total number of bytes to read.

    BytesRead - Points to the variable that will contain the number of
                bytes read.


Return Value:

    BOOLEAN - Returns TRUE if the read operation succeeded. If there was no
              data to be read, the return value will be TRUE (to indicate
              success), but BytesRead will be zero.


--*/

{
    ULONG   BytesReadSoFar;

    DebugPtrAssert( Buffer );

    if( BytesToRead <= _BytesInBuffer ) {
        //
        //  If the buffer contains more bytes than requested, then
        //  just transfer bytes from one buffer to the other
        //
        memmove( Buffer, _CurrentByte, ( size_t )BytesToRead );
        _BytesInBuffer -= BytesToRead;
        if( _BytesInBuffer != 0 ) {
            _CurrentByte += BytesToRead;
        } else {
            _CurrentByte = NULL;
        }
        *BytesRead = BytesToRead;
        return( TRUE );
    }

    //
    //  Buffer contains less bytes than the total number requested.
    //  Transfer all bytes in the buffer to the caller's buffer
    //
    memmove( Buffer, _CurrentByte, ( size_t )_BytesInBuffer );
    BytesReadSoFar = _BytesInBuffer;
    _CurrentByte = _Buffer;
    BytesToRead -= _BytesInBuffer;
    _BytesInBuffer = 0;
    //
    //  Refill the buffer and transfer bytes to the caller's buffer
    //  until all bytes are read or end of file occurs.
    //
    while( ( BytesToRead > 0 ) && !EndOfFile() ) {
        if( !FillBuffer( _Buffer, _BufferSize, &_BytesInBuffer ) ) {
            _BytesInBuffer = 0;
            return( FALSE );
        }
        if( BytesToRead >= _BytesInBuffer ) {
            memmove( Buffer, _Buffer, ( size_t )_BytesInBuffer );
            Buffer += _BytesInBuffer;
            BytesReadSoFar += _BytesInBuffer;
            BytesToRead -= _BytesInBuffer;
            _BytesInBuffer = 0;
        } else {
            memmove( Buffer, _Buffer, ( size_t )BytesToRead );
            BytesReadSoFar += BytesToRead;
            _CurrentByte += BytesToRead;
            _BytesInBuffer -= BytesToRead;
            BytesToRead = 0;
        }
    }
    *BytesRead = BytesReadSoFar;
    return( TRUE );
}


BOOLEAN
BUFFER_STREAM::AdvanceBufferPointer(
    IN  ULONG   Offset
    )

/*++

Routine Description:

    Adds an offset to the pointer to the current byte.
    (It has the effect of removing the first 'offset' bytes from the
    buffer.)

Arguments:

    Offset  - Number of bytes to remove from the buffer.

Return Value:

    BOOLEAN - Returns TRUE if the pointer was advanced, or FALSE if the
              offset was greater than the number of bytes in the buffer.


--*/

{
    BOOLEAN Result;

    if( Offset <= _BytesInBuffer ) {
        _BytesInBuffer -= Offset;
        _CurrentByte = ( _BytesInBuffer == 0 ) ? NULL : _CurrentByte + Offset;
        Result = TRUE;
    } else {
        Result = FALSE;
    }
    return( Result );
}



PCBYTE
BUFFER_STREAM::GetBuffer(
    PULONG  BytesInBuffer
    )

/*++

Routine Description:

    Returns to the caller the pointer to the buffer. If the buffer
    is empty, then it fills the buffer.

Arguments:

    BytesInBuffer - Points to the variable that will contain the number
                    of bytes added to the buffer.


Return Value:

    PCBYTE - Pointer to the buffer.

--*/

{
    BOOL    bUnicode;

    if( _BytesInBuffer == 0 ) {
        if( !EndOfFile() ) {
            FillBuffer( _Buffer, _BufferSize, &_BytesInBuffer );
            _CurrentByte = _Buffer;
        } else {
            _CurrentByte = NULL;
        }
    } else if (_BufferStreamType == 1 && _BytesInBuffer == 1) {
        if ( !EndOfFile() ) {
            FillBuffer( _Buffer, _BufferSize - 1, &_BytesInBuffer );
            _BytesInBuffer++;
            _CurrentByte = _Buffer;
        } else {
            _BytesInBuffer = 0;
            _CurrentByte = NULL;
        }
    }

    if (_BufferStreamType < 0) {
#ifdef FE_SB
        //
        // Set default as ANSI text.
        //
        _BufferStreamType = 0;

        if (_BufferSize > 1) {
            //
            // We would like to check the possibility of IS_TEXT_UNICODE_DBCS_LEADBYTE.
            //
            INT     iResult = ~0x0;

            __try {
                bUnicode = IsTextUnicode((LPTSTR)_CurrentByte, (INT)_BytesInBuffer, &iResult);
            } __except ( EXCEPTION_EXECUTE_HANDLER ) {
                DebugPrintTrace(("ULIB: Exception code %08x in IsTextUnicode\n", GetExceptionCode()));
                return NULL;
            }
            //
            // if the text contains ByteOrderMark. It is unicode text.
            //
            if ((iResult & IS_TEXT_UNICODE_SIGNATURE) != 0) {

            _BufferStreamType = 1;
            _CurrentByte += 2;

            } else if (bUnicode                                          &&
                       ((iResult & IS_TEXT_UNICODE_STATISTICS)    != 0 ) &&
                       ((iResult & (~IS_TEXT_UNICODE_STATISTICS)) == 0 )    ) {
                //
            // If the result depends only upon statistics, check
            // to see if there is a possibility of DBCS.
            //
                LPSTR pch = (LPSTR)_CurrentByte;
                UINT   cb = (UINT)_BytesInBuffer;

                while (cb > 0) {
                    if (IsDBCSLeadByte(*pch)) {
                        bUnicode = FALSE;
                        break;
                    }
                    cb--;
                    pch++;
                }

                if (bUnicode)
                    _BufferStreamType = 1;
            }
        }
#else
        __try {
            bUnicode = IsTextUnicode((LPTSTR)_CurrentByte, (INT)_BytesInBuffer, NULL);
        } __except ( EXCEPTION_EXECUTE_HANDLER ) {
            DebugPrintTrace(("ULIB: Exception code %08x in IsTextUnicode\n", GetExceptionCode()));
            return NULL;
        }

        if (bUnicode && (_BufferSize > 1) ) {

            _BufferStreamType = 1;

            if (*((LPWCH)_CurrentByte)==0xfeff) {
                _CurrentByte+=2; // eat the Byte Order Mark
            }
        } else {
            _BufferStreamType = 0;
        }
#endif // FE_SB
    }
    *BytesInBuffer = _BytesInBuffer;
    return( _CurrentByte );
}


BOOLEAN
BUFFER_STREAM::ReadChar(
    OUT PWCHAR      Char,
    IN BOOLEAN  Unicode
    )

/*++

Routine Description:

    Reads a character off the stream

Arguments:

    Char - Supplies pointer to wide character.

Return Value:

    TRUE if a character was read,
    FALSE otherwise

Notes:

    We always read the character from the stream as a multibyte character
    and do the multibyte to wide character conversion.

--*/

{

    PBYTE   Buffer;
    ULONG   BytesInBuffer;
    USHORT  BytesInChar;

    if (!Char || ((Buffer = (PBYTE)GetBuffer( &BytesInBuffer)) == NULL )) {
        return FALSE;
    }
    //
    //  Buffer may be a pointer to a file mapped in memory. For this
    //  reason we have to be aware of exception while accessing it.
    //
    DebugAssert( _BufferStreamType >= 0 );
    if (_BufferStreamType == 0 && !Unicode) {
       __try {
           if( !( *Buffer ) ) {
               //
               // The first character in the buffer is a NULL. Return ZERO
               // as the character read.
               //
               BytesInChar = 1;
               Char = 0;
           } else {
               BytesInChar = (USHORT)mbtowc( (wchar_t *)Char, (char *)Buffer, (size_t)BytesInBuffer );
           }
       }
       __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
           return( FALSE );
       }
    } else {
       __try {
           if( !( *((wchar_t *)Buffer) ) ) {
               //
               // The first character in the buffer is a NULL. Return ZERO
               // as the character read.
               //
               BytesInChar = 2;
               Char = 0;
           } else {
               BytesInChar = 2;
               Char = (wchar_t *)Buffer;
           }
       }
       __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
           return( FALSE );
       }
    }

    if ( BytesInChar == 0 ) {
        return FALSE;
    }

    AdvanceBufferPointer( BytesInChar );

    return TRUE;

}

//disable C4509 warning about nonstandard ext: SEH + destructor
#pragma warning(disable:4509)


BOOLEAN
BUFFER_STREAM::ReadString(
    OUT PWSTRING    String,
    IN  PWSTRING    Delimiters,
    IN BOOLEAN  Unicode
    )

/*++

Routine Description:

    Reads a string off the stream

Arguments:

    String      -   Supplies pointer to string. The string must have been
                    previously initialized.
    Delimiter   -   Supplies the set of characters that constitute a
                    string delimiter.

Return Value:

    TRUE if a string was read,
    FALSE otherwise

--*/

{
    PCVOID  pBuffer;
    ULONG   BytesInBuffer;
    ULONG   BytesConsumed;
    BOOLEAN EndOfString;
    PSTR    delim;
    PWSTR   delim_U;
    BOOLEAN r;
    FSTRING fstring;
    CHNUM   old_string_length;

    DebugPtrAssert( String );

    String->Truncate();

    EndOfString = FALSE;

    //
    //  Since the buffer might not contain the entire string, we keep
    //  converting the buffer and concatenating to the string, until
    //  we reach a delimiter (or there is no more input).
    //
    while ( !EndOfString ) {

        //
        //  Get pointer into buffer
        //
        pBuffer = (PCVOID)GetBuffer( &BytesInBuffer );

        if (pBuffer == NULL)
            return FALSE;

        if ( BytesInBuffer == 0 ) {
            //
            //  No more input
            //
            break;
        }

        //
        //  Concatenate the buffer obtained to the one we have
        //
        //
        //  pBuffer may be a pointer to a file mapped in memory. For this
        //  reason we have to be aware of exception while accessing it.
        //
        DebugAssert( _BufferStreamType >= 0 );
        if ( _BufferStreamType == 0 && !Unicode) {
          __try {
            if (delim = Delimiters->QuerySTR()) {
                //
                //  If pBuffer points to a file mapped in memory, and the
                //  end of the file is in a page boundary, and the last
                //  byte in the file is neither NUL nor one of the delimiters,
                //  we get an access violation.
                //  For this reason we call strcspn inside a try-except, and
                //  if an access violation occurs we consume all bytes in
                //  the buffer.
                //  The access violation will not occur if the end of the file
                //  is not in a page boundary. In this case, it is guaranteed that
                //  the remaining bytes on the last page will be 0s.
                //
                //  The access violation will not occur if pBuffer points to the
                //  buffer defined in this class. In this case, it is guaranteed
                //  that the byte immediately after the end of the buffer is NUL
                //  (see the initialization of this object).
                //

                __try {
                    BytesConsumed = strcspn((PCSTR) pBuffer, delim);
                }
                __except( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                    BytesConsumed = BytesInBuffer;
                }
                DELETE(delim);
                old_string_length = String->QueryChCount();
                if (r = String->Resize(old_string_length + BytesConsumed)) {
                    fstring.Initialize((PWSTR) String->GetWSTR() +
                                       old_string_length, BytesConsumed + 1);
                    r = fstring.WSTRING::Initialize((PCSTR) pBuffer,
                                                    BytesConsumed);
                    String->SyncLength();
                }
            } else {
                r = FALSE;
            }
          }
          __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            return( FALSE );
          }

          EndOfString = (BytesConsumed < BytesInBuffer);

        } else {
           __try {
               if (delim_U = Delimiters->QueryWSTR()) {
                   __try {
                       BytesConsumed = wcscspn((wchar_t *) pBuffer, delim_U)*sizeof(WCHAR);
                   }
                   __except( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                       BytesConsumed = BytesInBuffer;
                   }
                   if((BytesInBuffer & 0xfffe) != BytesInBuffer){
                      BytesInBuffer++;
                   }

                   DELETE(delim_U);
                   old_string_length = String->QueryChCount();
                   if (r = String->Resize(old_string_length + BytesConsumed/sizeof(WCHAR))) {
                       fstring.Initialize((PWSTR)String->GetWSTR() +
                                       old_string_length, BytesConsumed/sizeof(WCHAR) + 1);
                       r = fstring.WSTRING::Initialize((PCWSTR) pBuffer,
                                                       BytesConsumed/sizeof(WCHAR));
                       String->SyncLength();
                   }
               } else {
                   r = FALSE;
               }
           }
           __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
               return( FALSE );
              }
           EndOfString = (BytesConsumed < BytesInBuffer);
        }

        //EndOfString = (BytesConsumed < BytesInBuffer);

        DebugAssert( (BytesConsumed > 0) || EndOfString  );

        //
        //  Advance the buffer pointer the ammount consumed
        //
        if (r) {
            if (!AdvanceBufferPointer( BytesConsumed )) {
                break;
            }
        }
    }

    return TRUE;

}




BOOLEAN
BUFFER_STREAM::ReadMbString(
    IN      PSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:

Arguments:


Return Value:

--*/

{

    DWORD   StrSize;
    BOOLEAN EndOfString;
    PCVOID  pBuffer;
    ULONG   BytesInBuffer;
    ULONG   BytesConsumed;
    BYTE    Byte;
    DWORD   NumBytes;
    DWORD   ChunkSize;
    DWORD   Spaces;
    PBYTE   pBuf;

    DebugPtrAssert( String );
    DebugPtrAssert( BufferSize );
    DebugPtrAssert( Delimiters );

    *String         = '\0';
    StrSize         = 0;
    EndOfString     = FALSE;

    //
    //  Since the buffer might not contain the entire string, we keep
    //  converting the buffer and concatenating to the string, until
    //  we reach a delimiter (or there is no more input).
    //
    while ( !EndOfString ) {

        //
        //  Get pointer into buffer
        //
        pBuffer = (PCVOID)GetBuffer( &BytesInBuffer );

        if (pBuffer == NULL)
            return FALSE;

        if ( BytesInBuffer == 0 ) {
            //
            //  No more input
            //
            break;
        }

        //
        //  Concatenate the buffer obtained to the one we have
        //
        //
        //  pBuffer may be a pointer to a file mapped in memory. For this
        //  reason we have to be aware of exception while accessing it.
        //
        __try {
            //
            //  If pBuffer points to a file mapped in memory, and the
            //  end of the file is in a page boundary, and the last
            //  byte in the file is neither NUL nor one of the delimiters,
            //  we get an access violation.
            //  For this reason we call strcspn inside a try-except, and
            //  if an access violation occurs we consume all bytes in
            //  the buffer.
            //  The access violation will not occur if the end of the file
            //  is not in a page boundary. In this case, it is guaranteed that
            //  the remaining bytes on the last page will be 0s.
            //
            //  The access violation will not occur if pBuffer points to the
            //  buffer defined in this class. In this case, it is guaranteed
            //  that the byte immediately after the end of the buffer is NUL
            //  (see the initialization of this object).
            //
            __try {
                BytesConsumed = MBSTR::Strcspn( (PSTR)pBuffer, Delimiters );
            }
            __except( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                BytesConsumed = BytesInBuffer;
            }

            if ( BytesConsumed < BytesInBuffer ) {
                EndOfString = TRUE;
            }

            if ( ExpandTabs ) {

                //
                //  Expand tabs
                //
                ChunkSize = BytesConsumed;
                NumBytes  = BufferSize - StrSize - 1;

                pBuf     = (PBYTE)pBuffer;

                while ( ChunkSize-- && NumBytes ) {

                    Byte = *pBuf++;

                    if ( Byte != '\t' ) {

                        String[StrSize++] = Byte;
                        NumBytes--;

                    } else {

                        Spaces = min (TabExp - (StrSize % TabExp), NumBytes);
                        MBSTR::Memset( &String[StrSize], ' ', Spaces );
                        StrSize  += Spaces;
                        NumBytes -= Spaces;
                    }
                }
                ChunkSize++;

                if ( ChunkSize > 0 ) {
                    EndOfString     = TRUE;
                    BytesConsumed  -= ChunkSize;
                }

            } else {

                //
                //  Just copy string
                //
                if ( BytesConsumed >= (BufferSize-StrSize) ) {
                    BytesConsumed = BufferSize - StrSize - 1;
                    EndOfString   = TRUE;
                }

                MBSTR::Memcpy( &String[StrSize], (PVOID) pBuffer, BytesConsumed );
                StrSize += BytesConsumed;
            }

        }
        __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            return( FALSE );
        }

        DebugAssert( (BytesConsumed > 0) || EndOfString  );

        //
        //  Advance the buffer pointer the ammount consumed
        //
        if( BytesConsumed < BytesInBuffer ) {
            //
            //  Get rid of the delimiter
            //  This is to improve the performance of FC, who calls
            //  STREAM::ReadMbLine several times
            //
            BytesConsumed++;
        }
        AdvanceBufferPointer( BytesConsumed );

    }

    String[StrSize] = '\0';

    *StringSize = StrSize;

    return TRUE;
}


BOOLEAN
BUFFER_STREAM::ReadWString(
    IN      PWSTR    String,
    IN      DWORD   BufferSize, // char count
    INOUT   PDWORD  StringSize, // char count
    IN      PWSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:

Arguments:


Return Value:

--*/

{

    DWORD   StrSize;
    BOOLEAN EndOfString;
    PCVOID  pBuffer;
    ULONG   BytesInBuffer;
    ULONG   BytesConsumed;
    WCHAR    Byte;
    DWORD   NumBytes;
    DWORD   ChunkSize;
    DWORD   Spaces;
    PWCHAR   pBuf;

    DebugPtrAssert( String );
    DebugPtrAssert( BufferSize );
    DebugPtrAssert( Delimiters );

    *String         = L'\0';
    StrSize         = 0;
    EndOfString     = FALSE;

    //
    //  Since the buffer might not contain the entire string, we keep
    //  converting the buffer and concatenating to the string, until
    //  we reach a delimiter (or there is no more input).
    //
    while ( !EndOfString ) {

        //
        //  Get pointer into buffer
        //
        pBuffer = (PCVOID)GetBuffer( &BytesInBuffer );

        if (pBuffer == NULL)
            return FALSE;

        if ( BytesInBuffer == 0 ) {
            //
            //  No more input
            //
            break;
        }

        //
        //  Concatenate the buffer obtained to the one we have
        //
        //
        //  pBuffer may be a pointer to a file mapped in memory. For this
        //  reason we have to be aware of exception while accessing it.
        //
        __try {
            //
            //  If pBuffer points to a file mapped in memory, and the
            //  end of the file is in a page boundary, and the last
            //  byte in the file is neither NUL nor one of the delimiters,
            //  we get an access violation.
            //  For this reason we call strcspn inside a try-except, and
            //  if an access violation occurs we consume all bytes in
            //  the buffer.
            //  The access violation will not occur if the end of the file
            //  is not in a page boundary. In this case, it is guaranteed that
            //  the remaining bytes on the last page will be 0s.
            //
            //  The access violation will not occur if pBuffer points to the
            //  buffer defined in this class. In this case, it is guaranteed
            //  that the byte immediately after the end of the buffer is NUL
            //  (see the initialization of this object).
            //
            __try {
                BytesConsumed = wcscspn( (PWSTR)pBuffer, Delimiters )*sizeof(WCHAR);
            }
            __except( GetExceptionCode() == STATUS_ACCESS_VIOLATION ) {
                BytesConsumed = BytesInBuffer&0xFFFE;
            }

            if ( BytesConsumed < BytesInBuffer ) {
                EndOfString = TRUE;
            }

            if ( ExpandTabs ) {

                //
                //  Expand tabs
                //
                ChunkSize = BytesConsumed/sizeof(WCHAR);
                NumBytes  = BufferSize - StrSize - 1;

                pBuf     = (PWCHAR)pBuffer;

                while ( (ChunkSize--) && NumBytes ) {

                    Byte = *pBuf++;

                    if ( Byte != L'\t' ) {

                        String[StrSize++] = Byte;
                        NumBytes--;

                    } else {

                        Spaces = min (TabExp - (StrSize % TabExp), NumBytes);
                     //  wcsnset( (wchar_t *)&String[StrSize], L' ', Spaces );
                        for (DWORD ii=0;ii<Spaces;ii++) {
                           String[StrSize+ii] = L' ';
                        }
                        StrSize  += Spaces;
                        NumBytes -= Spaces;
                    }
                }
                ChunkSize++;

                if ( ChunkSize > 0 ) {
                    EndOfString     = TRUE;
                    BytesConsumed  = BytesConsumed - sizeof(WCHAR)*ChunkSize;
                }

            } else {

                //
                //  Just copy string
                //
                if ( BytesConsumed >= (BufferSize-StrSize)*sizeof(WCHAR) ) {
                    BytesConsumed = (BufferSize - StrSize - 1)*sizeof(WCHAR);
                    EndOfString   = TRUE;
                }

                MBSTR::Memcpy( &String[StrSize], (PVOID) pBuffer, BytesConsumed );
                StrSize += BytesConsumed/sizeof(WCHAR);
            }

        }
        __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            return( FALSE );
        }

        DebugAssert( (BytesConsumed > 0) || EndOfString  );

        //
        //  Advance the buffer pointer the ammount consumed
        //
        if( BytesConsumed < BytesInBuffer ) {
            //
            //  Get rid of the delimiter
            //  This is to improve the performance of FC, who calls
            //  STREAM::ReadWLine several times
            //
            BytesConsumed+=2;
        }
        AdvanceBufferPointer( BytesConsumed );

    }

    String[StrSize] = 0;

    *StringSize = StrSize;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\contain.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	contain.cxx

Abstract:

	This module contains the definition for the CONTAINER class, the most
	primitive, abstract class in the container sub-hierarchy. Given it's
	abstract, prmitive nature there is minimal implementation at this point
	in the hierarchy.

Author:

	David J. Gilman (davegi) 02-Nov-1990

Environment:

	ULIB, User Mode

--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "contain.hxx"


DEFINE_CONSTRUCTOR( CONTAINER, OBJECT );

CONTAINER::~CONTAINER(
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\comm.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    COMM_DEVICE

Abstract:

    This module contains the implementation for the COMM_DEVICE class.

Author:

    Ramon J. San Andres (ramonsa)   08-Jul-1991


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "comm.hxx"
#include "file.hxx"


//
//  Default timeout is one minute
//
#define DEFAULT_TIMEOUT 60000



DEFINE_EXPORTED_CONSTRUCTOR( COMM_DEVICE, OBJECT, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( COMM_DEVICE );

ULIB_EXPORT
COMM_DEVICE::~COMM_DEVICE(
    )
{
    Destroy();
}

VOID
COMM_DEVICE::Construct (
    )

/*++

Routine Description:

    Constructs a COMM_DEVICE object

Arguments:

    None.

Return Value:

    None.


--*/

{
    _Handle = NULL;

#if DBG==1

    _Initialized = FALSE;

#endif

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::Initialize (
    IN  PCPATH      PortName,
    OUT PBOOLEAN    OpenError
    )

/*++

Routine Description:

    Phase 2 of construction for a COMM_DEVICE.

Arguments:

    Port        -   Supplies pointer to the FSN_FILE object of the port.
    OpenError   -   Supplies pointer to flag which if TRUE means that
                    the port could not be openend.

Return Value:

    BOOLEAN -   TRUE if the serial port was successfully initialized,
                FALSE otherwise.

--*/

{
    DSTRING     QualifiedName;
    BOOLEAN     InitOk;

    DebugPtrAssert( PortName );

    Destroy();

    if( !QualifiedName.Initialize( L"\\\\.\\" ) ||
        !QualifiedName.Strcat( PortName->GetPathString() ) ) {

        if( OpenError ) {
            *OpenError = FALSE;
        }
        return FALSE;
    }

    //
    //  Open the Port and get a handle to it.
    //
    _Handle = CreateFile(   QualifiedName.GetWSTR(),
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                            NULL );


    if ( _Handle != INVALID_HANDLE_VALUE ) {

        if ( OpenError ) {
            *OpenError = FALSE;
        }

        //
        //  Get the current port state
        //
        InitOk = GetCommState( _Handle, &_Dcb ) != FALSE;

#if DBG==1
        GetLastError();
#endif

#if DBG==1

        _Initialized = InitOk;

#endif

    } else if ( OpenError ) {
        *OpenError = TRUE;
    }

    return InitOk;
}

VOID
COMM_DEVICE::Destroy (
    )

/*++

Routine Description:

    Brings the object to a point at which it can be initialized.

Arguments:

    none

Return Value:

    none

--*/

{

    if ( _Handle != INVALID_HANDLE_VALUE ) {

        CloseHandle( _Handle );

        _Handle = INVALID_HANDLE_VALUE;

    }

#if DBG==1

    _Initialized = FALSE;

#endif

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::CommitState (
    )

/*++

Routine Description:

    Sets the port state.

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if state set
                FALSE otherwise.

--*/

{

    DebugAssert( _Initialized );

    return SetCommState( _Handle, &_Dcb ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::QueryTimeOut (
    ) CONST

/*++

Routine Description:

    Queries whether infinite timeouts are enabled or not.

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if infinite timeouts are enabled
                FALSE otherwise.

--*/

{
    COMMTIMEOUTS    TimeOut;

    DebugAssert( _Initialized );

    GetCommTimeouts( _Handle, &TimeOut );

    return ( (TimeOut.ReadTotalTimeoutConstant == 0) &&
             (TimeOut.WriteTotalTimeoutConstant == 0) );

}

BOOLEAN
COMM_DEVICE::ReadState (
    )

/*++

Routine Description:

    Gets the current port state.

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if state read
                FALSE otherwise.

--*/

{

    DebugAssert( _Initialized );

    return GetCommState( _Handle, &_Dcb ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetBaudRate (
    IN  ULONG   BaudRate
    )

/*++

Routine Description:

    Sets the baud rate. Note that all changes take effect only after the
    CommitState() method is called.

Arguments:

    BaudRate    -   Supplies the baud rate

Return Value:

    BOOLEAN -   TRUE if valid baud rate
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    _Dcb.BaudRate = BaudRate;

    return TRUE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetDataBits (
    IN  ULONG   DataBits
    )

/*++

Routine Description:

    Sets the number of data bits. Note that all changes take effect only
    after the CommitState() method is called.

Arguments:

    DataBits    -   Supplies the number of data bits

Return Value:

    BOOLEAN -   TRUE if valid number of data bits
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    _Dcb.ByteSize = (BYTE)DataBits;

    return TRUE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetDtrControl (
    IN  DTR_CONTROL     DtrControl
    )

/*++

Routine Description:

    Sets the DTR control. Note that all changes take effect only
    after the CommitState() method is called.

Arguments:

    DtrControl  -   Supplies the DTR control value

Return Value:

    BOOLEAN -   TRUE if valid DTR control
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    if ( (DtrControl == DTR_ENABLE)     ||
         (DtrControl == DTR_DISABLE)    ||
         (DtrControl == DTR_HANDSHAKE) ) {

        _Dcb.fDtrControl = (DWORD)DtrControl;
        return TRUE;
    }

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetIdsr (
    IN  BOOLEAN     Idsr
    )

/*++

Routine Description:

    Enables/disables DSR sensitivity

Arguments:

    Odsr    -   Supplies a flag which if TRUE, enables DSR  sensitivity
                if FALSE, it disables it.

Return Value:

    BOOLEAN -   TRUE if DSR sensitivity enabled/disabled, FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    if ( Idsr ) {
        _Dcb.fDsrSensitivity = TRUE;
    } else {
        _Dcb.fDsrSensitivity = FALSE;
    }

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetOcts (
    IN  BOOLEAN     Octs
    )

/*++

Routine Description:

    Sets/resets CTS handshaking

Arguments:

    Octs    -   Supplies a flag which if TRUE, enables CTS handshaking,
                if FALSE, it disables it.

Return Value:

    BOOLEAN -   TRUE if handshaking enabled/disabled, FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    if ( Octs ) {
        _Dcb.fOutxCtsFlow = TRUE;
    } else {
        _Dcb.fOutxCtsFlow = FALSE;
    }

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetOdsr (
    IN  BOOLEAN     Odsr
    )

/*++

Routine Description:

    Sets/resets DSR handshaking

Arguments:

    Odsr    -   Supplies a flag which if TRUE, enables DSR  handshaking,
                if FALSE, it disables it.

Return Value:

    BOOLEAN -   TRUE if handshaking enabled/disabled, FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    if ( Odsr ) {
        _Dcb.fOutxDsrFlow = TRUE;
    } else {
        _Dcb.fOutxDsrFlow = FALSE;
    }

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetParity (
    IN  PARITY  Parity
    )

/*++

Routine Description:

    Sets the parity. Note that all changes take effect only after the
    CommitState() method is called.

Arguments:

    Parity  -   Supplies the parity value

Return Value:

    BOOLEAN -   TRUE if valid parity
                FALSE otherwise

--*/

{


    DebugAssert( _Initialized );

    DebugAssert( (Parity == COMM_PARITY_NONE)     ||  (Parity == COMM_PARITY_ODD) ||
               (Parity == COMM_PARITY_EVEN)     ||  (Parity == COMM_PARITY_MARK)    ||
               (Parity == COMM_PARITY_SPACE));

    _Dcb.Parity = (BYTE)Parity;

    return TRUE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetRtsControl (
    IN  RTS_CONTROL     RtsControl
    )

/*++

Routine Description:

    Sets the RTS control. Note that all changes take effect only
    after the CommitState() method is called.

Arguments:

    RtsControl  -   Supplies the RTS control value

Return Value:

    BOOLEAN -   TRUE if valid RTS control
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    if ( (RtsControl == RTS_ENABLE)     ||
         (RtsControl == RTS_DISABLE)    ||
         (RtsControl == RTS_HANDSHAKE)  ||
         (RtsControl == RTS_TOGGLE )
       ) {

        _Dcb.fRtsControl = (DWORD)RtsControl;
        return TRUE;
    }

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetStopBits (
    IN  STOPBITS StopBits
    )

/*++

Routine Description:

    Sets the number of stop bits. Note that all changes take effect
    only after the CommitState() method is called.

Arguments:

    StopBits    -   Supplies the number of stop bits

Return Value:

    BOOLEAN -   TRUE if valid number of stop bits
                FALSE otherwise

--*/

{

    DebugAssert( _Initialized );

    DebugAssert( (StopBits == COMM_STOPBITS_1) || (StopBits == COMM_STOPBITS_15) ||
               (StopBits == COMM_STOPBITS_2) );

    _Dcb.StopBits = (BYTE)StopBits;

    return TRUE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetTimeOut (
    IN  BOOLEAN     TimeOut
    )

/*++

Routine Description:

    Sets/resets infinite timeouts.

Arguments:

    TimeOut -   Supplies a flag which if TRUE means that infinite timeout
                is to be set. if FALSE, a 1-minute timeout is set for
                both reading and writting.

Return Value:

    BOOLEAN =   TRUE if timeout set, FALSE otherwise

--*/

{
    COMMTIMEOUTS    Time;

    DebugAssert( _Initialized );

    GetCommTimeouts( _Handle, &Time );

    if ( TimeOut ) {
        Time.ReadTotalTimeoutConstant  = 0;
        Time.WriteTotalTimeoutConstant = 0;
    } else {
        Time.ReadTotalTimeoutConstant  = DEFAULT_TIMEOUT;
        Time.WriteTotalTimeoutConstant = DEFAULT_TIMEOUT;
    }

    return SetCommTimeouts( _Handle, &Time ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
COMM_DEVICE::SetXon (
    IN  BOOLEAN     Xon
    )

/*++

Routine Description:

    Sets/resets XON/XOFF data-flow protocol.

Arguments:

    Xon -   Supplies flag which if TRUE, enables XON/XOFF protocol,
            if FALSE, disables it.

Return Value:

    BOOLEAN =   TRUE if protocol set/reset, FALSE otherwise

--*/

{
    DebugAssert( _Initialized );

    if ( Xon ) {
        _Dcb.fInX   = TRUE;
        _Dcb.fOutX  = TRUE;
    } else {
        _Dcb.fInX   = FALSE;
        _Dcb.fOutX  = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\filter.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    filter.cxx

Abstract:

    This module contains the definition for the FSN_FILTER class.
    FSN_FILTER essentially maintains the state information needed to
    establish the criteria by which other 'file' or FSNODE objects are
    compared against.

Author:

    David J. Gilman (davegi) 09-Jan-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filter.hxx"
#include "wstring.hxx"

extern "C" {
    #include <string.h>
    #include <ctype.h>
}




//
//  Pattern that matches all files
//
#define MATCH_ALL_FILES     "*.*"



DEFINE_EXPORTED_CONSTRUCTOR( FSN_FILTER, OBJECT, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( FSN_FILTER );




ULIB_EXPORT
FSN_FILTER::~FSN_FILTER (
    )
/*++

Routine Description:

    Destructs an FSN_FILTER objtect

Arguments:

    None.

Return Value:

    None.

--*/
{
}



VOID
FSN_FILTER::Construct (
    )

/*++

Routine Description:

    Construct a FSN_FILTER by setting it's internal data to a known state.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _AttributesSet  =   FALSE;
    _FileNameSet    =   FALSE;

    //
    //  Note that even though _FileNameSet is false, we initialize
    //  the _FileName criteria with a match-all pattern. having the
    //  _FileNameSet flag set to FALSE saves us time because we don't
    //  have to do pattern-matching, since we know that everything will
    //  match anyway.
    //
    _FileName.Initialize( MATCH_ALL_FILES );
    _TimeInfoSet[FSN_TIME_MODIFIED] = FALSE;
    _TimeInfoSet[FSN_TIME_CREATED]  = FALSE;
    _TimeInfoSet[FSN_TIME_ACCESSED] = FALSE;

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::Initialize (
    )

/*++

Routine Description:

    Initializes the FSN_FILTER

Arguments:

    none

Return Value:

    TRUE if the filter was succesfully initialized.

--*/

{

    return  _TimeInfo[FSN_TIME_MODIFIED].Initialize()   &&
            _TimeInfo[FSN_TIME_CREATED].Initialize()    &&
            _TimeInfo[FSN_TIME_ACCESSED].Initialize();

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::DoesNodeMatch (
    IN  PFSNODE FsNode
    )
/*++

Routine Description:

    Determine if the supplied node matches the criteria established
    in this FSN_FILTER.

Arguments:

    Node    -   Node to match

Return Value:

    TRUE if match, FALSE otherwise

--*/

{
    FSTRING  FileName;

    if (!FsNode) {
        return FALSE;
    }

    if (FilterFileName(FileName.Initialize(FsNode->_FileData.cFileName)) ||
        (FsNode->_FileData.cAlternateFileName[0] &&
         FilterFileName(FileName.Initialize(FsNode->_FileData.cAlternateFileName)))) {

        if (FilterAttributes(FsNode->QueryAttributes()) &&
            FilterTimeInfo( FsNode->GetCreationTime(),
                            FsNode->GetLastAccessTime(),
                            FsNode->GetLastWriteTime())) {

            return TRUE;
        }
    }

    return FALSE;
}

BOOLEAN
FSN_FILTER::FilterAttributes (
    IN FSN_ATTRIBUTE    Attributes
    )

/*++

Routine Description:

    Determines if the supplied data matches the attribute criteria.

Arguments:

    FindData    - Supplies the system data which represents a found file.

Return Value:

    TRUE if data matches attribute criteria.
    FALSE otherwise

--*/

{
    if ( _AttributesSet ) {
        return  ( ((Attributes & _AttributesAll) == _AttributesAll)         &&
                  ((_AttributesAny == 0) || (Attributes & _AttributesAny))  &&
                  !(Attributes & _AttributesNone) );
    }

    return TRUE;

}

BOOLEAN
FSN_FILTER::FilterFileName (
    IN PCWSTRING     FileName
    )

/*++

Routine Description:

    Determines if the supplied data matches the path criteria. We never
    return "." or ".." entries.

Arguments:

    FindData    - Supplies the system data which represents a found file.

Return Value:

    TRUE if data matches the path criteria.
    FALSE otherwise

--*/

{
    CHNUM   ChCount;
    WCHAR   c;

    ChCount = FileName->QueryChCount();

    //
    //  We never return the "." or ".." entries
    //
    if  ( ( FileName->QueryChAt(0) == (WCHAR)'.') &&
          (     (ChCount == 1) ||
                ((FileName->QueryChAt(1) == (WCHAR)'.') && (ChCount == 2))) ) {

        return FALSE;
    }


    if ( _FileNameSet ) {
        //
        //  We only match the base portion of the name
        //
        ChCount = FileName->QueryChCount()-1;
        while (ChCount < ~0 ) {
            c = FileName->QueryChAt( ChCount );

            if ( c == (WCHAR)':' || c == (WCHAR)'\\' ) {
                break;
            }
            ChCount--;
        }
        ChCount++;

        return PatternMatch( &_FileName, 0, FileName, ChCount );
    }

    return TRUE;

}

BOOLEAN
FSN_FILTER::FilterTimeInfo (
    IN PFILETIME    CreationTime,
    IN PFILETIME    LastAccessTime,
    IN PFILETIME    LastWriteTime
    )

/*++

Routine Description:

    Determines if the supplied data matches the TimeInfo criteria.

Arguments:

    FindData    - Supplies the system data which represents a found file.

Return Value:

    TRUE if data matches TimeInfo criteria.
    FALSE otherwise

--*/

{

    BOOLEAN Match = TRUE;

    if ( _TimeInfoSet[FSN_TIME_MODIFIED] ) {
        Match = TimeInfoMatch( &_TimeInfo[FSN_TIME_MODIFIED],
                               LastWriteTime,
                               _TimeInfoMatch[FSN_TIME_MODIFIED] );
    }

    if ( Match && _TimeInfoSet[FSN_TIME_CREATED] ) {
        Match = TimeInfoMatch( &_TimeInfo[FSN_TIME_CREATED],
                               CreationTime,
                               _TimeInfoMatch[FSN_TIME_CREATED] );
    }

    if ( Match && _TimeInfoSet[FSN_TIME_ACCESSED] ) {
        Match = TimeInfoMatch( &_TimeInfo[FSN_TIME_ACCESSED],
                               LastAccessTime,
                               _TimeInfoMatch[FSN_TIME_ACCESSED] );
    }

    return Match;

}

BOOLEAN
IsThereADot(
    IN  PCWSTRING   String
    )
{
    PATH        path;
    PWSTRING    p;
    BOOLEAN     r;

    if (!path.Initialize(String) ||
        !(p = path.QueryName())) {

        return FALSE;
    }

    r = (p->Strchr('.') != INVALID_CHNUM);

    DELETE(p);

    return r;
}


BOOLEAN
FSN_FILTER::PatternMatch (
    IN  PCWSTRING    Pattern,
    IN  CHNUM       PatternPosition,
    IN  PCWSTRING    FileName,
    IN  CHNUM       FileNamePosition
    )

/*++

Routine Description:

    Determines if a file name matches a pattern.

Arguments:

    Pattern             -   Supplies the pattern to compare against.
    PatternPosition     -   Supplies first position within pattern.
    FileName            -   Supplies the name to match. Cannot contain
                            wildcards.
    FileNamePosition    -   Supplies first position within FileName.


Return Value:

    TRUE if name matches

--*/

{
    if ( PatternPosition == Pattern->QueryChCount() ) {

        return (FileNamePosition == FileName->QueryChCount());

    }

    switch( Pattern->QueryChAt( PatternPosition )) {

    case (WCHAR)'?':
        if ((FileNamePosition == FileName->QueryChCount()) ||
            (FileName->QueryChAt( FileNamePosition ) == (WCHAR)'.' )) {
            return PatternMatch( Pattern, PatternPosition + 1,
                                 FileName, FileNamePosition );
        } else {
            return PatternMatch( Pattern, PatternPosition + 1,
                                 FileName, FileNamePosition + 1 );
        }

    case (WCHAR) '*':
        do {
            if (PatternMatch( Pattern, PatternPosition+1,
                              FileName, FileNamePosition )) {
                return TRUE;
            }
            FileNamePosition++;
        } while (FileNamePosition <= FileName->QueryChCount());

        return FALSE;

    case (WCHAR)'.':
        if (FileNamePosition == FileName->QueryChCount() &&
            !IsThereADot(FileName) &&
            Pattern->Strchr('.') == PatternPosition) {

            return PatternMatch( Pattern, PatternPosition+1,
                                 FileName, FileNamePosition );
        }

    default:
        return ( (WCHAR)CharUpper((LPTSTR)Pattern->QueryChAt( PatternPosition )) ==
                 (WCHAR)CharUpper((LPTSTR)FileName->QueryChAt( FileNamePosition ))) &&
                 PatternMatch( Pattern, PatternPosition + 1,
                               FileName, FileNamePosition + 1 );

    }
}

PFSNODE
FSN_FILTER::QueryFilteredFsnode (
    IN PCFSN_DIRECTORY  ParentDirectory,
    IN PWIN32_FIND_DATA FindData
    )

/*++

Routine Description:

    Determine if the supplied system data matches the criteria established
    in this FSN_FILTER. If it is create the appropriate FSNODE (i.e. FSN_FILE
    or FSN_DIRECTORY) and return it to the caller.

Arguments:

    ParentDirectory -   Supplies pointer to the parent directory object
    FindData        -   Supplies the system data which represents a found file.

Return Value:

    Pointer to an FSNODE if the criteria was met. NULL otherwise.

--*/

{
    PFSNODE     FsNode = NULL;
    FSTRING     FileName;


    if ( (FindData != NULL)                                             &&
         ((FileName.Initialize( FindData->cFileName )          &&
           FilterFileName( &FileName ))                          ||
          (FindData->cAlternateFileName[0]                     &&
           FileName.Initialize( FindData->cAlternateFileName ) &&
           FilterFileName( &FileName )))                                &&
         FilterAttributes( (FSN_ATTRIBUTE)FindData->dwFileAttributes )  &&
         FilterTimeInfo( &FindData->ftCreationTime,
                         &FindData->ftLastAccessTime,
                         &FindData->ftLastWriteTime )
       ) {

        //
        //  The data matches the filter criteria.
        //
        if ( FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

            //
            //  We have to create a directory object
            //
            FsNode = NEW FSN_DIRECTORY;

        } else {

            //
            //  We have to create a file object
            //
            FsNode = NEW FSN_FILE;
        }

        if ( FsNode ) {

            if ( !(FsNode->Initialize( (LPWSTR)FindData->cFileName,   ParentDirectory, FindData )) ) {

                DELETE( FsNode );

            }
        }
    }

    return FsNode;
}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::SetAttributes (
    IN FSN_ATTRIBUTE    All,
    IN FSN_ATTRIBUTE    Any,
    IN FSN_ATTRIBUTE    None
    )

/*++

Routine Description:

    Sets the attributes criteria

Arguments:

    All     -   Supplies the mask for the ALL attributes
    Any     -   Supplies the mask for the ANY attributes
    None    -   Supplies the mask for the NONE attributes

Return Value:

    TRUE if the Attributes criteria was set.

--*/

{

    //
    //  Verify that no attribute is set in more than one mask
    //
    if ((All | Any | None) != ( All ^ Any ^ None )) {
        return FALSE;
    }

    _AttributesAll  =   All;
    _AttributesAny  =   Any;
    _AttributesNone =   None;

    return (_AttributesSet  = TRUE);

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::SetFileName (
    IN  PCSTR   FileName
    )

/*++

Routine Description:

    Sets the FileName criteria

Arguments:

    FileName    -   Supplies the filename to match against

Return Value:

    TRUE if the filename criteria was set.

--*/

{

    if ( _FileName.Initialize( FileName ) ) {

        return ( _FileNameSet = TRUE );

    }

    return FALSE;

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::SetFileName (
    IN  PCWSTRING    FileName
    )

/*++

Routine Description:

    Sets the FileName criteria

Arguments:

    FileName    -   Supplies the filename to match against

Return Value:

    TRUE if the filename criteria was set.

--*/

{

    if ( _FileName.Initialize( FileName ) ) {

        return ( _FileNameSet = TRUE );

    }

    return FALSE;

}

ULIB_EXPORT
BOOLEAN
FSN_FILTER::SetTimeInfo (
        IN PCTIMEINFO       TimeInfo,
        IN FSN_TIME         TimeInfoType,
        IN USHORT           TimeInfoMatch
    )

/*++

Routine Description:

    Sets a TimeInfo criteria

Arguments:

    TimeInfo        -   Supplies the timeinfo
    TimeinfoType    -   Supplies the type of timeinfo to set
    TimeInfoMatch   -   Supplies the match criteria

Return Value:

    TRUE if the timeinfo criteria was set.

--*/

{

    //
    //  Verify the parameters
    //
    if ((TimeInfoType < FSN_TIME_MODIFIED)                              ||
        (TimeInfoType > FSN_TIME_ACCESSED)                              ||
        (TimeInfoMatch == 0)                                            ||
        (TimeInfoMatch &  ~(TIME_BEFORE | TIME_AT | TIME_AFTER))        ||
        ((TimeInfoMatch & TIME_BEFORE) && (TimeInfoMatch & TIME_AFTER))
        ) {

        return FALSE;
    }

    _TimeInfo[TimeInfoType].Initialize( (TIMEINFO *)TimeInfo );

    _TimeInfoMatch[TimeInfoType]    = TimeInfoMatch;

    return (_TimeInfoSet[TimeInfoType] = TRUE);

}

BOOLEAN
FSN_FILTER::TimeInfoMatch (
    IN  PTIMEINFO       TimeInfo,
    IN  PFILETIME       FileTime,
    IN  USHORT          Criteria
    )

/*++

Routine Description:

    Determines if the supplied file time matches the criteria for a certain
    time

Arguments:

    TimeInfo    -   Supplies pointer to Timeinfo object to match against
    FileTime    -   Supplies the file time to match
    Criteria    -   Supplies the match criteria

Return Value:

    TRUE if criteria met
    FALSE otherwise

--*/

{
    USHORT Compare;

    UNREFERENCED_PARAMETER( (void)this );

    //
    //  Compare and set in range 0 - 2
    //
    Compare = (USHORT)(-TimeInfo->CompareTimeInfo( FileTime ) + 1);

    //
    //  Our crietria is a bit mask, so we transform the result of the
    //  comparison to something that we can compare our mask against.
    //
    //  i.e. {0,1,2} to {1,2,4}
    //
    Compare = (USHORT)((Compare * 2) + ( (Compare == 0) ? 1 : 0));

    return BOOLEAN( (USHORT)Compare & Criteria );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\file.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    file.cxx

Abstract:

    This module contains the definition for the FSN_FILE class.

Author:

    David J. Gilman (davegi) 09-Jan-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "system.hxx"
#include "file.hxx"
#include "timeinfo.hxx"

extern "C" {
   #include "winbasep.h"
}


DEFINE_CONSTRUCTOR( FSN_FILE, FSNODE );

DEFINE_CAST_MEMBER_FUNCTION( FSN_FILE );



ULIB_EXPORT
BOOLEAN
FSN_FILE::Copy (
    IN OUT  PPATH               NewFile,
    OUT     PCOPY_ERROR         CopyError,
    IN      ULONG               CopyFlags,
    IN      LPPROGRESS_ROUTINE  CallBack,
    IN      VOID *              Data,
    IN      PBOOL               Cancel
    ) CONST

/*++

Routine Description:

    Copies this file to another path.  If appropriate the NewFile
    will be altered to its "short" (FAT) form before the copy.

Arguments:

    NewFile         -   Supplies path of new file. All the subdirectories must
                        exist.

    CopyError       -   Supplies pointer to variable that receives the
                        error code.

    CopyFlags       -   Supplies the following flags:
                        FSN_FILE_COPY_OVERWRITE_READ_ONLY
                            - read-only files should be overwritten.
                        FSN_FILE_COPY_RESET_READ_ONLY
                            - readonly flag in the target to be reset.
                        FSN_FILE_COPY_RESTARTABLE
                            - copy is restartable.
                        FSN_FILE_COPY_COPY_OWNER
                            - copy the ownership of the file.
                        FSN_FILE_COPY_COPY_ACL
                            - copy the security information of the file

    Callback        -   Pointer to callback routine passed to CopyFileEx.

    Data            -   Pointer to opaque data passed to CopyFileEx.

    Cancel          -   Pointer to cancel flag passed to CopyFileEx.

Return Value:

    BOOLEAN -   TRUE if the file was successfully copied,
                FALSE otherwise.

--*/

{

    PCWSTR          Source;
    PCWSTR          Destination;
    BOOLEAN         CopiedOk = FALSE;
    FSN_FILE        File;
    DWORD           Attr;
    WIN32_FIND_DATA FindData;
    FSTRING         AlternateFileName;


    Source      = GetPath()->GetPathString()->GetWSTR();
    DebugPtrAssert( Source );

    if ( Source ) {

        Destination = NewFile->GetPathString()->GetWSTR();
        DebugPtrAssert( Destination );

        if ( Destination ) {

            CopiedOk = TRUE;

            //
            //  If we must overwrite read-only files, we must
            //  get the file attributes and change to writeable.
            //
            //  What we should do here is do
            //  a SYSTEM::QueryFile of the destination file and
            //  use the FILE methods for resetting the read-only
            //  attribute. However this is faster!
            //
            if ( CopyFlags & FSN_FILE_COPY_OVERWRITE_READ_ONLY ) {

                Attr = GetFileAttributes( (LPWSTR) Destination );

                if (Attr != -1 &&
                    (Attr & (FILE_ATTRIBUTE_READONLY |
                             FILE_ATTRIBUTE_HIDDEN |
                             FILE_ATTRIBUTE_SYSTEM))) {

                    Attr &= ~( FILE_ATTRIBUTE_READONLY |
                               FILE_ATTRIBUTE_HIDDEN |
                               FILE_ATTRIBUTE_SYSTEM );

                    if ( !SetFileAttributes( (LPWSTR) Destination, Attr ) ) {
                        CopiedOk = FALSE;
                    }
                }
            }

            //
            //  Copy the file
            //
            if ( CopiedOk ) {

                ULONG   flags;

                flags = (FSN_FILE_COPY_RESTARTABLE & CopyFlags) ? COPY_FILE_RESTARTABLE : 0;
                flags |= (FSN_FILE_COPY_COPY_OWNER & CopyFlags) ? PRIVCOPY_FILE_OWNER_GROUP | PRIVCOPY_FILE_METADATA : 0;
                flags |= (FSN_FILE_COPY_COPY_ACL & CopyFlags) ? PRIVCOPY_FILE_SACL : 0;
                flags |= (FSN_FILE_COPY_ALLOW_DECRYPTED_DESTINATION & CopyFlags) ? COPY_FILE_ALLOW_DECRYPTED_DESTINATION : 0;

#if !defined(RUN_ON_NT4)

                CopiedOk = PrivCopyFileExW(  (LPWSTR) Source,
                                             (LPWSTR) Destination,
                                             CallBack,
                                             Data,
                                             (LPBOOL) Cancel,
                                             flags) != FALSE;
#else
                CopiedOk = FALSE;
                SetLastError(ERROR_NOT_SUPPORTED);
#endif
            }

            if ( CopiedOk && (CopyFlags & FSN_FILE_COPY_RESET_READ_ONLY ) ) {

                FindData = _FileData;

                NewFile->GetPathString()->QueryWSTR( 0,
                                                     TO_END,
                                                     FindData.cFileName,
                                                     MAX_PATH );
                FindData.cAlternateFileName[ 0 ] = ( WCHAR )'\0';
                //
                // Ok, the right thing to do here is to actually query the
                // attributes of the NewFile (coz they might not exactly the
                // same as the source file, even though the Copy function
                // seems to think so) and then do a SetAttributes on the new file
                // using these. Currently the only attribute I'm concerned about
                // is FILE_ATTRIBUTE_OFFLINE which should be turned off on the
                // destination, but there might be others in the future.
                //
                Attr = GetFileAttributes((LPWSTR) FindData.cFileName);

                if (Attr != 0xFFFFFFFF) {

                    FindData.dwFileAttributes = Attr;

                } else {
                    //
                    // For some reason, couldn't get the attributes.
                    // Turn off OFFLINE bit in any case
                    //
                    FindData.dwFileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
                }

                if( File.Initialize( NewFile->GetPathString(),
                                     &FindData ) ) {

                    File.ResetReadOnlyAttribute();

                } else {

                    //
                    //  The file is no longer there, we fail the copy
                    //
                    CopiedOk   = FALSE;
                    *CopyError = (COPY_ERROR) ERROR_FILE_NOT_FOUND;
                }



            } else if ( !CopiedOk && CopyError ) {

                *CopyError = (COPY_ERROR)GetLastError();

            }
        }
    }

    return CopiedOk;

}


BOOLEAN
FSN_FILE::DeleteFromDisk(
    IN BOOLEAN      Force
    )
{
    PCWSTR      FileName;
    PWSTRING    FullPath;

    UNREFERENCED_PARAMETER( Force );

    FullPath = _Path.QueryFullPathString();
    if (FullPath == NULL)
        return FALSE;

    if ( FileName = FullPath->GetWSTR() ) {

        if ( FileName[0] != (WCHAR)'\0' ) {
            return DeleteFile( (LPWSTR) FileName ) != FALSE;
        }
    }

    return FALSE;
}




ULIB_EXPORT
PFILE_STREAM
FSN_FILE::QueryStream (
    STREAMACCESS    Access,
    DWORD        Attributes
    )

/*++

Routine Description:

    Creates a FILE_STREAM object associated with the file described
    by FSN_FILE, and returns the pointer to the FILE_STREAM.


Arguments:

    Access      - Desired access to the stream

    Attributes  - Desired attributes for the stream. 0 means no special attributes.

Return Value:

    PFILE_STREAM - Returns a pointer to a FILE_STREAM, or NULL
                   if the FILE_STREAM couldn't be created.

--*/

{
    PFILE_STREAM    FileStream;

    if( IsReadOnly() && ( Access != READ_ACCESS ) ) {
        return( NULL );
    }
    FileStream = NEW( FILE_STREAM );
    DebugPtrAssert( FileStream );
    if( FileStream && !FileStream->Initialize( this, Access, Attributes ) ) {
        DELETE( FileStream );
        return( NULL );
    }
    return( FileStream );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\filestrm.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    filestrm.cxx

Abstract:

    This module contains the definitions of the member functions
    of FILE_STREAM class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define BUFFER_SIZE 256
#define BIG_BUFFER_SIZE (64 * 1024)

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "file.hxx"
#include "wstring.hxx"
#include "stream.hxx"
#include "bufstrm.hxx"
#include "filestrm.hxx"


DEFINE_CONSTRUCTOR ( FILE_STREAM, BUFFER_STREAM );

DEFINE_EXPORTED_CAST_MEMBER_FUNCTION( FILE_STREAM , ULIB_EXPORT );


FILE_STREAM::~FILE_STREAM (
    )

/*++

Routine Description:

    Destroy a FILE_STREAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if( ( _MemoryMappedFile ) && !_EmptyFile ) {
        if( _FileBaseAddress != 0 ) {
            UnmapViewOfFile( _FileBaseAddress );
        }
        if( _FileMappingHandle != NULL ) {
            CloseHandle( _FileMappingHandle );
            _FileMappingHandle = NULL;
        }
    }
    if( _ShouldCloseHandle ) {
        if( _FileHandle != NULL ) {
            CloseHandle( _FileHandle );
            _FileHandle = NULL;
        }
    }
}



VOID
FILE_STREAM::Construct (
    )

/*++

Routine Description:

    Constructs a FILE_STREAM object

Arguments:

    None.

Return Value:

    None.


--*/

{
    _FileHandle = NULL;
    _FileMappingHandle = NULL;
    _EndOfFile = FALSE;
    _ShouldCloseHandle = FALSE;
    _FileBaseAddress = 0;
    _MemoryMappedFile = FALSE;
    _EmptyFile = FALSE;
}







BOOLEAN
FILE_STREAM::Initialize(
    IN PCFSN_FILE   File,
    IN STREAMACCESS Access,
    IN DWORD        Attributes
    )

/*++

Routine Description:

    Initializes an object of type FILE_STREAM.

Arguments:

    PCFSN_FILE - Pointer to a FSN_FILE object (will provide the filename).

    STREAMACCESS - Access allowed in the stream.


Return Value:

    None.


--*/


{
    ULONG       CreationAttributes;
    ULONG       DesiredAccess;
    ULONG       CreationDisposition;
    ULONG       ShareMode;
    PCPATH      Path;
    PCWSTRING   String;
//  PCWC_STRING String;
    PCWSTR      FileName;
    BOOLEAN     MappingFailed = FALSE;

    DebugPtrAssert( File );

    if (0 == Attributes) {
        CreationAttributes = FILE_ATTRIBUTE_NORMAL;
    } else {
        CreationAttributes = Attributes;
    }

    _Access = Access;
    _EndOfFile = FALSE;
    _ShouldCloseHandle = TRUE;
    _EmptyFile = FALSE;
    if (_Access == READ_ACCESS) {
        _MemoryMappedFile = TRUE;
    } else {
        _MemoryMappedFile = FALSE;
    }

    Path = File->GetPath();
    String = Path->GetPathString();
    FileName = String->GetWSTR();

    if( Access == READ_ACCESS ) {
        DesiredAccess = GENERIC_READ;
        CreationDisposition = OPEN_EXISTING;
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    } else if( Access == WRITE_ACCESS ) {
        DesiredAccess = GENERIC_WRITE;
        CreationDisposition = OPEN_ALWAYS;
        ShareMode = FILE_SHARE_READ;
    } else {
        DesiredAccess = GENERIC_READ | GENERIC_WRITE;
        CreationDisposition = OPEN_EXISTING;
        ShareMode = FILE_SHARE_READ;
    }

    _FileHandle = CreateFile( (LPWSTR) FileName,
                              DesiredAccess,
                              ShareMode,
                              NULL,                 // Security attributes
                              CreationDisposition,
                              CreationAttributes,
                              NULL );
    if( _FileHandle == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    //
    //  If stream is to be created with READ_ACCESS, then map file
    //  in memory
    //

    if( _MemoryMappedFile ) {
        if( ( _FileSize = File->QuerySize() ) == 0 ) {
            //
            //  Empty file that is also read-only, cannot be mapped in
            //  memory, but we pretend we do it
            //
            _FileBaseAddress = NULL;
            _EmptyFile = TRUE;
            _EndOfFile = TRUE;
        } else {
            _FileMappingHandle = CreateFileMapping( _FileHandle,
                                                    NULL,
                                                    PAGE_READONLY,
                                                    0,
                                                    0,NULL );
            if( _FileMappingHandle == NULL ) {
                DebugPrintTrace(( "Create file mapping failed with %d\n", GetLastError() ));
                _MemoryMappedFile = FALSE;
                MappingFailed = TRUE;
            }

            if (_FileMappingHandle) {
                _FileBaseAddress = ( PBYTE )MapViewOfFile( _FileMappingHandle,
                                                           FILE_MAP_READ,
                                                           0,
                                                           0,
                                                           0 );

                if( _FileBaseAddress == NULL ) {
                    DebugPrintTrace(("map view of file failed with %d\n", GetLastError()));
                    CloseHandle( _FileMappingHandle );
                    _FileMappingHandle = NULL;
                    _MemoryMappedFile = FALSE;
                    MappingFailed = TRUE;
                }
            }
        }

        if (_MemoryMappedFile) {
            _CurrentByte = _FileBaseAddress;
            //
            // If the file is maped in memory then we don't need
            // a buffer. For this reason BUFFER_STREAM is initialized
            // with zero
            //
            return( BUFFER_STREAM::Initialize( 0 ) );
        }
    }

    if (!_MemoryMappedFile) {

        //
        // If the stream is to be created with WRITE or READ_AND_WRITE
        // access, then allocate a buffer.  If we attempted to map
        // the file and failed, it must be very large--use a big
        // buffer.
        //
        return( BUFFER_STREAM::Initialize( MappingFailed ?
                                               BIG_BUFFER_SIZE :
                                               BUFFER_SIZE ) );
    }

    return FALSE;  // Keep compiler happy.
}




BOOLEAN
FILE_STREAM::Initialize(
    IN HANDLE       FileHandle,
    IN STREAMACCESS Access
    )

/*++

Routine Description:

    Initializes an object of type FILE_STREAM.

Arguments:

    FileHandle - File handle.

    Access - Access allowed in the stream.


Return Value:

    BOOLEAN - Returns TRUE if the initialization succeeded.


--*/


{
    BOOLEAN MappingFailed = FALSE;

    _Access = Access;
    _EndOfFile = FALSE;
    _ShouldCloseHandle = FALSE;
    _FileHandle = FileHandle;

    if (_Access == READ_ACCESS) {
        _MemoryMappedFile = TRUE;
    } else {
        _MemoryMappedFile = FALSE;
    }

    //
    // If stream is to be creadted with READ access, then map file in
    // memory
    //
    if( _MemoryMappedFile ) {

        LARGE_INTEGER   x = {0,0};

        if (!SetFilePointerEx( _FileHandle, x, (PLARGE_INTEGER)&_FileSize, FILE_END )) {
            return( FALSE );
        }
        if( _FileSize == 0 ) {
            //
            //  Empty file that is also read only cannot be mapped in
            //  memory, but we pretend we do it.
            //
            _FileBaseAddress = NULL;
            _EmptyFile = TRUE;
            _EndOfFile = TRUE;
        } else {
            _FileMappingHandle = CreateFileMapping( _FileHandle,
                                                    NULL,
                                                    PAGE_READONLY,
                                                    0,
                                                    0,NULL );
            if( _FileMappingHandle == NULL ) {
                return( FALSE );
            }
            _FileBaseAddress = ( PBYTE )MapViewOfFile( _FileMappingHandle,
                                                       FILE_MAP_READ,
                                                       0,
                                                       0,
                                                       0 );

            if( _FileBaseAddress == NULL ) {
                CloseHandle( _FileMappingHandle );
                _FileMappingHandle = NULL;
                MappingFailed = TRUE;
                _MemoryMappedFile = FALSE;
            }
        }

        if (_MemoryMappedFile) {
            _CurrentByte = _FileBaseAddress;
            return( BUFFER_STREAM::Initialize( 0 ) );
        }
    }
    //
    // If stream is to be created with WRITE and READ_AND_WRITE access,
    // then allocate a buffer.  Or the file was so big that it couldn't
    // be mapped into memory.  If the mapping failed, use a big buffer.

    return( BUFFER_STREAM::Initialize( MappingFailed ?
                                           BIG_BUFFER_SIZE :
                                           BUFFER_SIZE ) );
}



BOOLEAN
FILE_STREAM::AdvanceBufferPointer(
    IN  ULONG   Offset
    )

/*++

Routine Description:

    Advance the buffer pointer by an offset. (Removes bytes from
    the buffer)

Arguments:

    Offset  - Number of bytes to remove from the buffer.

Return Value:

    BOOLEAN - Returns TRUE if the pointer was advanced, or FALSE if the
              offset was greater than the number of bytes in the buffer.


--*/

{
    if( _MemoryMappedFile ) {
        return( MovePointerPosition( (LONGLONG)Offset, STREAM_CURRENT ));
    } else {
        return( BUFFER_STREAM::AdvanceBufferPointer( Offset ) );
    }
}



BOOLEAN
FILE_STREAM::FillBuffer(
    IN  PBYTE   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Fills a buffer with bytes read from a file.
    This function will fill the buffer only if the stream has
    READ_AND_WRITE access.
    It won't do anything if the stream has READ access. (In this case
    the file was mapped in memory and the buffer was not defined).


Arguments:

    Buffer - Buffer where the bytes are to be stored.

    BufferSize - Size of the buffer.

    BytesRead - Pointer to the variable that will contain the number of bytes
                put in the buffer.


Return Value:

    BOOLEAN - Returns TRUE if the buffer was filled. FALSE otherwise.


--*/

{
    BOOLEAN Result;

    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesRead );

    Result = FALSE;
    if( _Access != WRITE_ACCESS ) {
        Result = ReadFile( _FileHandle,
                           Buffer,
                           BufferSize,
                           BytesRead,
                           NULL ) != FALSE;
        if( Result && ( *BytesRead == 0 ) ) {
            _EndOfFile = TRUE;
        }
    }
    return( Result );
}



PCBYTE
FILE_STREAM::GetBuffer(
    PULONG  BytesInBuffer
    )

/*++

Routine Description:

    Returns the pointer to the buffer, and the number of bytes in
    the buffer.

Arguments:

    BytesInBuffer - Points to the variable that will contain the number
                    of bytes in the buffer being returned.


Return Value:

    PCBYTE - Pointer to the buffer.

--*/


{
    if( _MemoryMappedFile ) {
        *BytesInBuffer = (ULONG)(_FileSize - ( _CurrentByte - _FileBaseAddress ));
        if (!BUFFER_STREAM::DetermineStreamType(&_CurrentByte,*BytesInBuffer))
            return NULL;
        else
            return( _CurrentByte );
    } else {
        return( BUFFER_STREAM::GetBuffer( BytesInBuffer ));
    }
}


BOOLEAN
FILE_STREAM::MovePointerPosition(
    IN LONGLONG     Position,
    IN SEEKORIGIN   Origin
    )

/*++

Routine Description:

    Sets the file pointer to a particular position.

Arguments:

    Position    - Indicates the displacement in relation to the Origin
                  where the file pointer is to be moved.

    Origin  - Defines the origin of the stream.


Return Value:

    BOOLEAN - Indicates if the seek operation succeeded.


--*/


{
    LARGE_INTEGER   NewPosition;
    ULONG           MoveMethod;
    PBYTE           Pointer;

    if( _MemoryMappedFile ) {
        //
        // The file IS mapped on memory
        //
        if( Origin == STREAM_BEGINNING ) {
            Pointer = _FileBaseAddress;
        } else if( Origin == STREAM_CURRENT ) {
            Pointer = _CurrentByte;
        } else {
            Pointer = _FileBaseAddress + _FileSize - 1;
        }
        Pointer += Position;
        if( ( Pointer < _FileBaseAddress ) ||
            ( Pointer > _FileBaseAddress + _FileSize ) ) {
            _CurrentByte = Pointer;
            _EndOfFile = ( BOOLEAN )( Pointer >= _FileBaseAddress + _FileSize );
            return( FALSE );
        }
        _CurrentByte = Pointer;
        _EndOfFile = ( BOOLEAN )( Pointer == _FileBaseAddress + _FileSize );

    } else {
        //
        // The file IS NOT mapped in memory, so access to the file
        // must be through APIs.
        //
        if( Origin == STREAM_BEGINNING ) {
            MoveMethod = FILE_BEGIN;
        } else if( Origin == STREAM_CURRENT ) {
            MoveMethod = FILE_CURRENT;
        } else {
            MoveMethod = FILE_END;
        }
        if (0 == SetFilePointerEx( _FileHandle,
                                   *(PLARGE_INTEGER)&Position,
                                   &NewPosition,
                                   MoveMethod )) {
            return( FALSE );
        }
        //
        // Since the file is buffered, we have to flush the buffer.
        // The return value of FlushBuffer can be ignored because
        // the file pointer was already moved to the right position.
        //
        BUFFER_STREAM::FlushBuffer();
        _EndOfFile = FALSE;
    }
    return( TRUE );
}



BOOLEAN
FILE_STREAM::QueryPointerPosition(
    OUT PULONGLONG      Position
    )

/*++

Routine Description:

    Returns the position of the file pointer in relation to the beginning of
    the stream.

Arguments:

    Position - Address of the variable that will contain the position of the
               file pointer.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    ULONG   BytesInBuffer;
    LARGE_INTEGER   zero = {0, 0};

    if( _MemoryMappedFile ) {
        *Position = (ULONGLONG)( _CurrentByte - _FileBaseAddress );
    } else {
        if (0 == SetFilePointerEx( _FileHandle,
                                   zero,
                                   (PLARGE_INTEGER)Position,
                                   FILE_CURRENT )) {
            return( FALSE );
        }
        //
        //  Needs to subtract the number of bytes in the buffer
        //  to obtain the position where the client thinks that
        //  the pointer is.
        //
        if (BUFFER_STREAM::GetBuffer( &BytesInBuffer ) == NULL) {
            return FALSE;
        }
        *Position -= BytesInBuffer;
    }
    return( TRUE );
}



BOOLEAN
FILE_STREAM::Read(
    OUT PBYTE   Buffer,
    IN  ULONG   BytesToRead,
    OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Reads data from the file.

Arguments:

    Buffer  - Points to the buffer where the data will be put.

    BytesToRead - Indicates total number of bytes to read from the stream.

    BytesRead   - Points to the variable that will contain the number of
                  bytes read.

Return Value:

    BOOLEAN - Indicates if the read operation succeeded. If there was no
              data to be read (end of stream), the return value will be
              TRUE (to indicate success), but NumberOfBytesRead will be
              zero.


--*/

{
    if( _MemoryMappedFile ) {
        if( ( _CurrentByte + BytesToRead ) > _FileBaseAddress + _FileSize ) {
            BytesToRead = (ULONG)(_FileBaseAddress + _FileSize - _CurrentByte);
        }
        __try {
            memcpy( Buffer, _CurrentByte, ( size_t )BytesToRead );
        }
        __except( GetExceptionCode() == EXCEPTION_IN_PAGE_ERROR ) {
            return( FALSE );
        }
        *BytesRead = BytesToRead;
        _CurrentByte += BytesToRead;
        if( _CurrentByte >= _FileBaseAddress + _FileSize ) {
            _EndOfFile = TRUE;
        }
        return( TRUE );
    } else {
        return( BUFFER_STREAM::Read( Buffer, BytesToRead, BytesRead ) );
    }
}



ULIB_EXPORT
BOOLEAN
FILE_STREAM::ReadAt(
    OUT PBYTE       Buffer,
    IN  ULONG       BytesToRead,
    IN  LONGLONG    Position,
    IN  SEEKORIGIN  Origin,
    OUT PULONG      BytesRead
    )

/*++

Routine Description:

    Reads data from the file stream at a specified position.

Arguments:

    Buffer - Points to the buffer where the data will be put.

    BytesToRead - Indicates total number of bytes to read from the stream.

    Position - Position in the stream where data is to be read from,
               relative to the origin of the stream.

    Origin - Indicates what position in the stream should be used
                 as origin.

    BytesRead - Points to the variable that will contain the number of
                bytes read.


Return Value:

    BOOLEAN - Indicates if the read operation succeeded. If there was no
              data to be read (end of stream), the return value will be
              TRUE (to indicate success), but BytesRead will be zero.


--*/

{
    BOOLEAN     Result;
    ULONGLONG   SavedPosition;

    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesRead );

    Result = FALSE;
    if( QueryPointerPosition( &SavedPosition ) &&
        MovePointerPosition( Position, Origin ) &&
        Read( Buffer, BytesToRead, BytesRead ) ) {
            DebugAssert(SavedPosition <= MAXLONGLONG);
            Result = MovePointerPosition( SavedPosition, STREAM_BEGINNING );
    }
    return( Result );
}



BOOLEAN
FILE_STREAM::Write(
    IN  PCBYTE      Buffer,
    IN  ULONG       BytesToWrite,
    OUT PULONG      BytesWritten
    )

/*++

Routine Description:

    Writes data a file stream with WRITE_ACCESS or READ_AND_WRITE_ACCESS.

Arguments:

    Buffer - Points to the buffer that contains the data to be written.

    BytesToWrite - Indicates total number of bytes to write to the stream.

    BytesWritten - Points to the variable that will contain the number of
                   bytes written.

Return Value:

    BOOLEAN - Indicates if the write operation succeeded.


--*/

{
    LONG    Offset;

    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesWritten );

    //
    // If the stream have READ_AND_WRITE_ACCESS, we have to flush the
    // buffer before we write to the file, and move the file pointer
    // to the right place.
    //
    if( _Access == READ_AND_WRITE_ACCESS ) {
        Offset = FlushBuffer();
        if( !MovePointerPosition( -Offset, STREAM_CURRENT ) ) {
            return( FALSE );
        }
    }
    return( STREAM::Write( Buffer, BytesToWrite, BytesWritten ) );
}



BOOLEAN
FILE_STREAM::WriteAt(
    IN  PBYTE       Buffer,
    IN  ULONG       BytesToWrite,
    IN  LONGLONG    Position,
    IN  SEEKORIGIN  Origin,
    OUT PULONG      BytesWritten
    )

/*++

Routine Description:

    Writes data to the stream at a specified position.

Arguments:

    Buffer - Points to the buffer that contains the data to be written.

    BytesToWrite - Indicates total number of bytes to write to the stream.

    Position - Position in the stream where data is to be written to,
               relative to the origin of the stream.

    Origin - Indicates what position in the stream should be used
                 as origin.

    BytesWritten - Points to the variable that will contain the number of
                   bytes written.

Return Value:

    BOOLEAN - Returns TRUE to indicate that the operation succeeded.
              Returns FALSE otherwise.


--*/

{
    BOOLEAN     Result;
    ULONGLONG   SavedPosition;

    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesWritten );

    Result = FALSE;
    if( QueryPointerPosition( &SavedPosition ) &&
        MovePointerPosition( Position, Origin ) &&
        Write( Buffer, BytesToWrite, BytesWritten ) ) {
            Result = MovePointerPosition( SavedPosition, STREAM_BEGINNING );
    }
    return( Result );
}


BOOLEAN
FILE_STREAM::EndOfFile(
    ) CONST

/*++

Routine Description:

    Informs the caller if end of file has occurred. End of file happens
    when all bytes from the file were read, and there is no more bytes
    to read (the API returns zero bytes read).

Arguments:

    None.

Return Value:

    A boolean value that indicates if end of file was detected.


--*/


{
    return( _EndOfFile );
}



STREAMACCESS
FILE_STREAM::QueryAccess(
    ) CONST

/*++

Routine Description:

    Returns the type of access of the file stream

Arguments:

    None.

Return Value:

    The stream access.


--*/


{
    return( _Access );
}



HANDLE
FILE_STREAM::QueryHandle(
    ) CONST

/*++

Routine Description:

    Returns the file handle

Arguments:

    None.

Return Value:

    The file handle.


--*/


{
    return( _FileHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\dir.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    dir.cxx

Abstract:

    This module contains the defintion for the FSN_DIRECTORY class.

Author:

    David J. Gilman (davegi) 09-Jan-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "dir.hxx"
#include "filter.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "system.hxx"

BOOLEAN
IsDot (
    IN WCHAR *p
    );

INLINE
BOOLEAN
IsDot (
    IN WCHAR *p
    )
/*++

Routine Description:

    Determines if a name is a '.' or '..' entry in a directory.

    It is only intended to be used when processing a WIN32_FIND_DATA
    structure.

Arguments:

    p   -   Supplies pointer to char array

Return Value:

    BOOLEAN - Returns TRUE if the name is a '.' or '..' entry.

--*/
{


    return ( (p[0] == '.' && p[1] == '\0') ||
             (p[0] == '.' && p[1] == '.' && p[2] == '\0' ) );
}




DEFINE_CONSTRUCTOR( FSN_DIRECTORY, FSNODE );

DEFINE_CAST_MEMBER_FUNCTION( FSN_DIRECTORY );

BOOLEAN
FSN_DIRECTORY::Copy (
    IN  PFSN_FILTER             FsnFilter,
    IN  PCFSN_DIRECTORY         DestinationDir,
    IN  BOOLEAN                 Recurse,
    IN  BOOLEAN                 OverWrite
    ) CONST

/*++

Routine Description:

    Copies a set of FSNODEs to a destination directory.

Arguments:

    FsnFilter       - Supplies a pointer top a constant FSN_FILTER, which
        describes the set of FSNODEs to be copied.

    DestinationDir  - Supplies a pointer to a constant FSN_DIRECTORY which is
        the destination of the copy.

    Recurse         - Supplies a flag which if TRUE causes Copy to perform
        a recursive copy if it encounters a FSN_DIRECTORY.

    OverWrite       - Supplies a flag which if TRUE, allows Copy to over
        write an existing destination file.

Return Value:

    BOOLEAN - Returns TRUE if the entire Copy operation was succesful.

--*/


{

    ULONG               Files       = 0;
    DWORD               ErrorStatus = 0;
    PARRAY              SrcFiles;
    PARRAY_ITERATOR     Iterator;
    PPATH               SourcePath              = NULL;
    LPWSTR              SourcePathString        = NULL;
    ULONG               SourceBufferSize        = 0;
    PPATH               DestinationPath         = NULL;
    LPWSTR              DestinationPathString   = NULL;
    ULONG               DestinationBufferSize   = 0;
    ULONG               BufferSize;
    PFSNODE             FsNode;
    PWSTRING            Name;
    BOOLEAN             ReturnValue = TRUE;
    PFSN_DIRECTORY      SourceDirectory         = NULL;
    PFSN_DIRECTORY      DestinationDirectory    = NULL;

    DebugPtrAssert( FsnFilter );
    DebugPtrAssert( DestinationDir );
    if ( //
         // Verify arguments
         //
         ( FsnFilter != NULL )                                                  &&
         ( DestinationDir != NULL )                                             &&
         //
         // Get array of nodes for files in the directory
         //
         (( SrcFiles = QueryFsnodeArray( FsnFilter )) != NULL )                     &&
         //
         // Get an iterator for processing the nodes
         //
         (( Iterator = ( PARRAY_ITERATOR ) SrcFiles->QueryIterator( )) != NULL )    &&
         //
         // Get paths
         //
         ((SourcePath = NEW PATH) != NULL)                                          &&
         ((DestinationPath = DestinationDir->GetPath( )->QueryFullPath( )) != NULL) ) {

        //
        // For each FSNODE in the ARRAY either:
        //
        //  - set up and call Copy on the sub directory (based on Recurse)
        //  - or copy the file
        //
        while (( FsNode = (PFSNODE)Iterator->GetNext( )) != NULL ) {

            //
            //  Append the name portion of the source to the
            //  destination path.
            //
            if ( ((Name = FsNode->QueryName()) == NULL) ||
                 !DestinationPath->AppendBase( Name ) ) {
                break;
            }


            //
            //  Get paths and strings
            //
            SourcePath->Initialize( FsNode->GetPath() );

            BufferSize = (SourcePath->GetPathString()->QueryChCount() + 1) * 2;
            if ( BufferSize > SourceBufferSize ) {
                if (SourceBufferSize == 0) {
                    SourcePathString = (LPWSTR)MALLOC((size_t)BufferSize);
                } else {
                    SourcePathString = (LPWSTR)REALLOC( SourcePathString, (size_t)BufferSize);
                }
                SourceBufferSize = BufferSize;
            }

            BufferSize = (DestinationPath->GetPathString()->QueryChCount() + 1) * 2;
            if ( BufferSize > DestinationBufferSize ) {
                if (DestinationBufferSize == 0) {
                    DestinationPathString = (LPWSTR)MALLOC((size_t)BufferSize);
                } else {
                    DestinationPathString = (LPWSTR)REALLOC( DestinationPathString, (size_t)BufferSize);
                }
                DestinationBufferSize = BufferSize;
            }

            if ( (SourcePathString == NULL) || (DestinationPathString == NULL)) {
                break;
            }

            SourcePath->GetPathString()->QueryWSTR(0,
                                                   TO_END,
                                                   SourcePathString,
                                                   SourceBufferSize/sizeof(WCHAR));
            DestinationPath->GetPathString()->QueryWSTR(0,
                                                        TO_END,
                                                        DestinationPathString,
                                                        DestinationBufferSize/sizeof(WCHAR));

            if ( FsNode->IsDirectory() ) {

                //
                //  Copy directory
                //

                CreateDirectoryEx( SourcePathString, DestinationPathString, NULL );

                if ( Recurse ) {

                    if ( ((SourceDirectory = SYSTEM::QueryDirectory( SourcePath )) != NULL)  &&
                         ((DestinationDirectory = SYSTEM::QueryDirectory( DestinationPath )) != NULL)) {

                        if ( SourceDirectory->Copy( FsnFilter,
                                                    DestinationDirectory,
                                                    Recurse,
                                                    OverWrite )) {

                            DELETE( SourceDirectory );
                            DELETE( DestinationDirectory );

                            SourceDirectory         =   NULL;
                            DestinationDirectory    =   NULL;

                        } else {

                            break;

                        }

                    } else {

                        break;

                    }

                }

            } else {

                //
                //  Copy file
                //
                if (!CopyFile( SourcePathString, DestinationPathString, !OverWrite)) {

                    ReturnValue = FALSE;
                    break;
                }

            }

            DELETE( Name );

            DestinationPath->TruncateBase();

        }


        if (SourcePathString != NULL) {
            FREE( SourcePathString );
        }

        if (DestinationPathString != NULL) {
            FREE( DestinationPathString );
        }

        if (SourceDirectory != NULL ) {
            DELETE( SourceDirectory );
        }

        if (DestinationDirectory != NULL) {
            DELETE( DestinationDirectory );
        }

        DELETE( DestinationPath );
        DELETE( SourcePath );
        DELETE( Iterator );
        DELETE( SrcFiles );

    }

    return ReturnValue;

}

ULIB_EXPORT
PFSN_DIRECTORY
FSN_DIRECTORY::CreateDirectoryPath (
    IN  PCPATH  Path
    ) CONST

/*++

Routine Description:

    Creates all the directories along a path and returns the directory
    of the deepest one.

Arguments:

    Path    -   Supplies pointer to the path

Return Value:

    PFSN_DIRECTORY  -   Returns pointer to the directory object of the
                        deepest directory created.

--*/

{

    PARRAY          DesiredComponentArray;
    PARRAY          ExistingComponentArray;
    PITERATOR       IteratorDesired;
    PITERATOR       IteratorExisting;
    PPATH           PathToCreate;
    PWSTRING        DesiredComponent;
    PWSTRING        ExistingComponent;
    BOOLEAN         OkSoFar     = TRUE;
    PFSN_DIRECTORY  Directory   = NULL;
    LPWSTR          Buffer      = NULL;
    ULONG           BufferSize  = 0;
    ULONG           Size;


    DebugPtrAssert( Path );

    //
    //  Split both paths in their component parts
    //
    DesiredComponentArray  = Path->QueryComponentArray();
    ExistingComponentArray = GetPath()->QueryComponentArray();

    DebugPtrAssert( DesiredComponentArray );
    DebugPtrAssert( ExistingComponentArray );

    if ( DesiredComponentArray && ExistingComponentArray ) {

        IteratorDesired  = DesiredComponentArray->QueryIterator();
        IteratorExisting = ExistingComponentArray->QueryIterator();

        DebugPtrAssert( IteratorDesired );
        DebugPtrAssert( IteratorExisting );

        if ( IteratorDesired && IteratorExisting ) {

            //
            //  Make sure that the existing components are a subset of the
            //  desired components.
            //
            while (TRUE) {

                if (!(ExistingComponent = (PWSTRING)(IteratorExisting->GetNext()))) {
                    break;
                }

                DesiredComponent  = (PWSTRING)(IteratorDesired->GetNext());

                DebugPtrAssert( DesiredComponent );

                if ( !DesiredComponent ||  ( *DesiredComponent != *ExistingComponent )) {

                    DebugAssert( FALSE );
                    OkSoFar = FALSE;
                    break;

                }
            }

            if ( OkSoFar ) {

                //
                //  Now we can start creating directories
                //
                // PathToCreate = GetPath()->QueryFullPath();
                PathToCreate = GetPath()->QueryPath();

                if (PathToCreate) {
                    while ( DesiredComponent = (PWSTRING)(IteratorDesired->GetNext()) ) {

                        //
                        //  One directory to create
                        //
                        PathToCreate->AppendBase( DesiredComponent, TRUE );

                        Size = (PathToCreate->GetPathString()->QueryChCount() + 1) * 2;
                        if ( Size > BufferSize ) {
                            if ( Buffer ) {
                                Buffer = (LPWSTR)REALLOC( Buffer, (unsigned int)Size );
                            } else {
                                Buffer = (LPWSTR)MALLOC( (unsigned int)Size );
                            }
                            if (Buffer == NULL) {
                                OkSoFar = FALSE;
                                break;
                            }
                            DebugPtrAssert( Buffer );
                            BufferSize = Size;
                        }
                        PathToCreate->GetPathString()->QueryWSTR( 0,
                                                                  TO_END,
                                                                  (LPWSTR)Buffer,
                                                                  BufferSize/sizeof(WCHAR) );

                        OkSoFar = CreateDirectory( (LPWSTR)Buffer, NULL ) != FALSE;

                        // DebugAssert( OkSoFar );

                    }

                    if ( OkSoFar ) {

                        //
                        //  Create directory object
                        //
                        Directory = SYSTEM::QueryDirectory( Path );
                    }

                    DELETE( PathToCreate );
                }
            }
        }

        DELETE( IteratorDesired );
        DELETE( IteratorExisting );

    }

    DesiredComponentArray->DeleteAllMembers();
    ExistingComponentArray->DeleteAllMembers();

    DELETE( DesiredComponentArray );
    DELETE( ExistingComponentArray );

    return Directory;

}

ULIB_EXPORT
BOOLEAN
FSN_DIRECTORY::DeleteDirectory (
    )

/*++

Routine Description:

    Deltes this directory and everything underneath it.

    Note that after this, the directory object must be deleted!

Arguments:

    none

Return Value:

    BOOLEAN -   Return TRUE if everything was deleted

--*/

{

    FSN_FILTER  Filter;
    PARRAY      Array;
    ULONG       Size;
    LPWSTR      Buffer      = NULL;
    ULONG       BufferSize  = 0;
    BOOLEAN     Ok          = TRUE;
    PITERATOR   Iterator;
    PFSNODE     FsNode;

    Filter.Initialize();
    Filter.SetFileName( "*.*" );

    Array = QueryFsnodeArray( &Filter );

    if ( Array ) {

        Iterator = ( PARRAY_ITERATOR ) Array->QueryIterator( );
        DebugPtrAssert( Iterator );

        //
        //  Delete everything underneath us.
        //
        while ( Ok && (( FsNode = (PFSNODE)Iterator->GetNext( )) != NULL )) {

            if ( FsNode->IsDirectory() ) {

                //
                //  Directory, just recurse.
                //
                Ok = ((PFSN_DIRECTORY)FsNode)->DeleteDirectory();

            } else {

                //
                //  File, delete it.
                //
                Size = (FsNode->GetPath()->GetPathString()->QueryChCount() + 1) * 2;
                if (Size > BufferSize) {
                    if (Buffer == NULL) {
                        Buffer = (LPWSTR)MALLOC((unsigned int)Size );
                    } else {
                        Buffer = (LPWSTR)REALLOC(Buffer, (unsigned int)Size );
                    }
                    if (Buffer == NULL) {
                        DebugPtrAssert(Buffer);
                        DELETE(Array);
                        return FALSE;
                    }
                    BufferSize = Size;
                }

                FsNode->GetPath()->GetPathString()->QueryWSTR( 0,
                                                               TO_END,
                                                               Buffer,
                                                               BufferSize/sizeof(WCHAR) );

                Ok = DeleteFile( (LPWSTR)Buffer ) != FALSE;

            }
        }

        DELETE( Array );

    }

    if ( Ok ) {
        //
        //  Commit suicide
        //
        Size = (GetPath()->GetPathString()->QueryChCount() + 1) * 2;
        if (Size > BufferSize) {
            if (Buffer == NULL) {
                Buffer = (LPWSTR)MALLOC( (unsigned int)Size );
            } else {
                Buffer = (LPWSTR)REALLOC(Buffer, (unsigned int)Size );
            }
            if (Buffer == NULL) {
                DebugPtrAssert(Buffer);
                return FALSE;
            }
            BufferSize = Size;
        }

        GetPath()->GetPathString()->QueryWSTR( 0,
                                               TO_END,
                                               Buffer,
                                               BufferSize/sizeof(WCHAR) );

        Ok = RemoveDirectory( (LPWSTR)Buffer ) != FALSE;

        FREE( Buffer );

    }

    return Ok;

}

ULIB_EXPORT
BOOLEAN
FSN_DIRECTORY::IsEmpty (
    ) CONST

/*++

Routine Description:

    Determines if a directory is empty (A directory is empty if has
    no entries other than "." and ".."

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if directory is empty
                FALSE otherwise

--*/

{


    PATH            Path;
    FSTRING         Base;
    WIN32_FIND_DATA FindData;
    HANDLE          Handle;
    BOOLEAN         IsEmpty;
    PFSN_DIRECTORY  SubDirectory;
    PATH            SubPath;
    DSTRING         SubBase;
    BOOLEAN         SubEmpty;


    IsEmpty = FALSE;

    if ( Path.Initialize( GetPath() )       &&
         Base.Initialize((PWSTR) L"*.*")    &&
         Path.AppendBase( &Base ) ) {

        //
        //  Get the first entry
        //
        Handle = FindFirstFile( &Path, &FindData );

        if ( Handle == INVALID_HANDLE_VALUE ) {

            //
            //  If we fail we assume that the directory
            //  is empty.
            //
            IsEmpty = TRUE;

        } else {

            if ( IsDot(FindData.cFileName) ) {

                while ( TRUE ) {

                    if ( !FindNextFile( Handle, &FindData ) ) {
                        IsEmpty = TRUE;
                        break;
                    }

                    if ( !IsDot( FindData.cFileName ) ) {

                        // If this file is a sub-directory check to
                        // see whether or not it is empty.  If it is
                        // empty then we still do not know whether or
                        // not this directory is empty.

                        if (FindData.dwFileAttributes &
                            FILE_ATTRIBUTE_DIRECTORY) {

                            if (!SubPath.Initialize(GetPath()) ||
                                !SubBase.Initialize(FindData.cFileName) ||
                                !SubPath.AppendBase(&SubBase) ||
                                !(SubDirectory =
                                  SYSTEM::QueryDirectory(&SubPath))) {

                                break;
                            }

                            SubEmpty = SubDirectory->IsEmpty();
                            DELETE(SubDirectory);

                            if (!SubEmpty) {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }
            }

            FindClose( Handle );
        }
    } else {

        DebugAssert( FALSE );

    }

    return IsEmpty;

}


ULIB_EXPORT
PARRAY
FSN_DIRECTORY::QueryFsnodeArray (
    IN PFSN_FILTER  FsnFilter
    ) CONST

/*++

Routine Description:

    Construct and fill an ARRAY object with FSNODE object that meet the
    criteria maintained by the supplied FSN_FILTER.

Arguments:

    FsnFilter - Supplies a constant pointer to an FS_FILTER which will be
        used to determine if a found 'file' should be constructed and
        included in the ARRAY.

Return Value:

    PARRAY - Returns a pointer to an ARRAY of FSNODEs. If no 'file' meets
        the FSN_FILTER criteria returns a pointer to an empy array.
        Returns NULL if the array couldn't be constructed or initialized.

--*/

{
    REGISTER PARRAY             parr;
    REGISTER PFSNODE            pfsn;
    WIN32_FIND_DATA             ffd;
    PATH                        Path;
    HANDLE                      hndl;
    PFSN_FILTER                 Filter;
    BOOLEAN                     DeleteFilter;
    DWORD                       FindNextError;
    BOOLEAN                     CheckError = TRUE;


    //
    //  If a filter was not provided, we use a default match-all
    //  filter.
    //
    if ( FsnFilter ) {

        Filter       = FsnFilter;
        DeleteFilter = FALSE;

    } else {

        Filter = NEW FSN_FILTER;
        DebugPtrAssert( Filter );
        if (!Filter) {
            return NULL;
        }
        Filter->Initialize();
        DeleteFilter = TRUE;
    }

    //
    // Initialize the ARRAY pointer
    //

    parr = NULL;

    //
    // Append the filter name to this DIRECTORY's name
    //

    Path.Initialize( (PCPATH)&_Path, TRUE);
    Path.AppendBase( Filter->GetFileName() );

    //
    // If there are found files and the ARRAY is succesfully
    // constructed and initialized...
    //

    if((( parr = NEW ARRAY ) != NULL )                                      &&
    ( parr->Initialize( ))) {

        if( ( hndl = FindFirstFile( &Path, &ffd )) != INVALID_HANDLE_VALUE ) {
            //
            // if there is at least one file that meetes the filter
            // criteria, put the fsnodes in the array. Otherwise, leave
            // the array empty
            //
            do {

                //
                // If the found 'file' meets the filter criteria, put the
                // returned FSNODE in the ARRAY
                //

                if(( pfsn = Filter->QueryFilteredFsnode( this, &ffd )) != NULL ) {

                    //
                    // If the FSNODE can not be put in the ARRAY
                    // delete it and exit the loop.
                    //

                    if( ! ( parr->Put( pfsn ))) {
                        DELETE( pfsn );
                        CheckError = FALSE;
                        break;
                    }
                }

            //
            // Loop while there are still more files to find.
            //

            } while( FindNextFile( hndl, &ffd ));

            if (CheckError)  {
            
                FindNextError = GetLastError();

                if ((ERROR_NO_MORE_FILES != FindNextError) && (ERROR_SUCCESS != FindNextError))  {

                    //
                    //  We can't exit here,   because we don't know who's calling
                    //  us,  etc.  Without major changes to percolate an error back
                    //  up,  the best we can do is display an error.
                    //
                    
                    SYSTEM::DisplaySystemError( FindNextError, FALSE);
                }
            }

            //
            // Close the search.
            //

            FindClose( hndl );

        }
        //
        // There is no file that meets the filter criteria.
        // Return pointer to an empty array
        //

    } else {

        //
        // There were no found files or the construction or
        // initialization of the ARRAY failed, delete the ARRAY in case
        // it was constructed and setup to return a NULL pointer i.e. no ARRAY
        //

        if( parr != NULL ) {
            DELETE( parr );
        }
        parr = NULL;
    }

    //
    // Return the pointer to the ARRAY (which may be NULL)
    //

    if ( DeleteFilter ) {
        DELETE( Filter );
    }

    return( parr );
}



ULIB_EXPORT
BOOLEAN
FSN_DIRECTORY::Traverse (
    IN      PVOID                   Object,
    IN      PFSN_FILTER             FsnFilter,
    IN  OUT PPATH                   DestinationPath,
    IN      CALLBACK_FUNCTION       CallBackFunction
    ) CONST

/*++

Routine Description:

    Traverses a directory, calling the callback function for each node
    (directory of file) visited.  The traversal may be finished
    prematurely when the callback function returnes FALSE.

    The destination path is modified to reflect the directory structure
    being traversed.

Arguments:

    Object          - Supplies pointer to the object

    FsnFilter       - Supplies a pointer to the filter that determines the
                      nodes to be visited.

    DestinationPath - Supplies pointer to path to be used with the callback
                      function.

    CallBackFunction- Supplies pointer to the function to be called back
                      with the node to be visited.

Return Value:

    BOOLEAN - Returns TRUE if the entire traversal was successful.

--*/


{

    PARRAY              SrcFiles;
    PARRAY_ITERATOR     Iterator;
    PFSNODE             FsNode;
    PPATH               SubDirectoryPath    = NULL;
    PFSN_DIRECTORY      SubDirectory        = NULL;
    BOOLEAN             StatusOk            = TRUE;
    PWSTRING Name;


    DebugPtrAssert( FsnFilter );
    DebugPtrAssert( CallBackFunction );

    //
    // Get array of nodes for files in the directory
    //
    SrcFiles = QueryFsnodeArray( FsnFilter );
    DebugPtrAssert( SrcFiles );

    //
    // Get an iterator for processing the nodes
    //
    Iterator = ( PARRAY_ITERATOR ) SrcFiles->QueryIterator( );
    DebugPtrAssert( Iterator );

    //
    // Get path
    //
    SubDirectoryPath = NEW PATH;
    DebugPtrAssert( SubDirectoryPath );


    //
    //  Visit all the nodes in the array. We recurse if the node is
    //  a directory.
    //
    while ( StatusOk && (( FsNode = (PFSNODE)Iterator->GetNext( )) != NULL )) {


        if ( DestinationPath ) {

            //
            //  Append the name portion of the node to the destination path.
            //
            Name = FsNode->QueryName();
            DebugPtrAssert( Name );

            StatusOk = DestinationPath->AppendBase( Name );
            DebugAssert( StatusOk );

            DELETE( Name );
        }

        //
        //  Visit the node
        //
        if ( StatusOk = CallBackFunction( Object, FsNode, DestinationPath )) {

            if ( FsNode->IsDirectory() ) {

                //
                //  Recurse
                //
                SubDirectoryPath->Initialize( FsNode->GetPath() );

                SubDirectory = SYSTEM::QueryDirectory( SubDirectoryPath );

                DebugPtrAssert( SubDirectory );

                StatusOk = SubDirectory->Traverse( Object,
                                                   FsnFilter,
                                                   DestinationPath,
                                                   CallBackFunction );
                DELETE( SubDirectory );

            }

        }

        if ( DestinationPath ) {

            //
            //  Restore the destination path
            //
            DestinationPath->TruncateBase();
        }
    }

    DELETE( SrcFiles );
    DELETE( Iterator );
    DELETE( SubDirectoryPath );

    return StatusOk;
}


ULIB_EXPORT
PFSNODE
FSN_DIRECTORY::GetNext (
    IN OUT HANDLE       *hndl,
    OUT PDWORD          error
    )

/*++

Routine Description:

    This routine returns the files and directories found within the
    directory object.

Arguments:

    hndl - Supplies & receives a handle of the directory object.
           Initialize to NULL to start with.

    error - if result is NULL,  receives win32 error code (for
            end of directory will be ERROR_NO_MORE_FILES)

Return Value:

    NULL if error or end of directory

--*/

{
    REGISTER PFSNODE            pfsn;
    WIN32_FIND_DATA             ffd;
    PATH                        Path;
    FSN_FILTER                  Filter;

    if (!Filter.Initialize()) {
        return NULL;
    }

    //
    // Append the filter name to this DIRECTORY's name
    //

    Path.Initialize((PCPATH)&_Path, TRUE);
    Path.AppendBase(Filter.GetFileName());

    *error = ERROR_SUCCESS;
    
    if (*hndl == NULL) {
        if (INVALID_HANDLE_VALUE ==
            (*hndl = FindFirstFile(&Path, &ffd))) {
            *error = GetLastError();
            return NULL;
        }
    } else {
        if (!FindNextFile(*hndl, &ffd)) {
            *error = GetLastError();
            FindClose(*hndl);
            return NULL;
        }
    }

    do {
        if((pfsn = Filter.QueryFilteredFsnode(this, &ffd)) != NULL) {
            return pfsn;
        }
    } while (FindNextFile(*hndl, &ffd));

    *error = GetLastError();

    FindClose(*hndl);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\fsnode.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    fsnode.cxx

Abstract:

    This module contains the definition for the FSNODE class, the most
    primitive, abstract class in the file system sub-hierarchy. Given it's
    abstract, prmitive nature it contains very minimal implementation. It's
    primary intent is to support a polymorphic base class for file system
    objects.

Author:

    David J. Gilman (davegi) 02-Jan-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "dir.hxx"
#include "fsnode.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "timeinfo.hxx"
#include "system.hxx"

DEFINE_CONSTRUCTOR( FSNODE, OBJECT );

FSNODE::~FSNODE (
    )

/*++

Routine Description:

    Destroy an FSNODE.

Arguments:

    None.

Return Value:

    None.

--*/

{
}

BOOLEAN
FSNODE::Initialize (
    IN PCWSTR           PathName,
    IN PCFSN_DIRECTORY  ParentDirectory,
    IN PWIN32_FIND_DATA FileData
    )

/*++

Routine Description:

    Initialize an FSNODE by constructing and initializing it's contained
    PATH object.

Arguments:

    PathName - Supplies a name used to initialize the contained PATH

    FileData - Points to the structure that contains all file information.

Return Value:

    BOOLEAN - TRUE if the contained PATH was succesfully constructed and
        initialized.

--*/

{

    FSTRING     wcs;

    DebugPtrAssert( PathName );
    DebugPtrAssert( ParentDirectory );
    if( ( PathName != NULL )                    &&
        ( ParentDirectory != NULL )                 &&
        _Path.Initialize((( PFSN_DIRECTORY )
        ParentDirectory )->GetPath( ), FALSE)               &&
        wcs.Initialize( (PWSTR) PathName )                      &&
        _Path.AppendBase( &wcs ) ) {
        memcpy( &_FileData, FileData, sizeof( WIN32_FIND_DATA ) );
        _Path.GetPathString( )->QueryWSTR( 0, TO_END,
                                           ( LPWSTR )_FileData.cFileName,
                                           sizeof( _FileData.cFileName )/sizeof(WCHAR));
        return( TRUE );

    } else {

        DebugAbort( "Could not construct/initialize PATH" );
        return( FALSE );

    }
}

BOOLEAN
FSNODE::Initialize (
    IN PCWSTRING        PathName,
    IN PWIN32_FIND_DATA FileData
    )

/*++

Routine Description:

    Initialize an FSNODE by constructing and initializing it's contained
    PATH object.

Arguments:

    PathName - Supplies a name used to initialize the contained PATH

    FileData - Points to the structure that contains all file information.

Return Value:

    BOOLEAN - TRUE if the contained PATH was succesfully constructed and
        initialized.

--*/

{

    DebugPtrAssert( PathName );
    if( ( PathName != NULL )            &&
        _Path.Initialize( PathName, FALSE ) ) {
        memcpy( &_FileData, FileData, sizeof( WIN32_FIND_DATA ) );
        PathName->QueryWSTR( 0, TO_END,
                            ( LPWSTR )_FileData.cFileName,
                            sizeof( _FileData.cFileName )/sizeof(WCHAR));
        return( TRUE );

    } else {

        DebugAbort( "Could not construct/initialize PATH" );
        return( FALSE );

    }
}

PFSN_DIRECTORY
FSNODE::QueryParentDirectory (
    ) CONST

/*++

Routine Description:

    Construct and return the FSN_DIRECTORY object which represents this
    FSNODE's parent.

Arguments:

    None.

Return Value:

    PFSN_DIRECTORY - Returns a pointer the the parent FSN_DIRECTORY.

--*/

{
    REGISTER PFSN_DIRECTORY pfsnDir;
    PATH                    path;
    PWSTRING                pstr;

    pstr = ((PFSNODE)this)->_Path.QueryPrefix();

    if( pstr &&
        path.Initialize( pstr ) &&
        (( pfsnDir = SYSTEM::QueryDirectory( &path )) != NULL )) {

        DELETE(pstr);
        return( pfsnDir );
    } else {

        DELETE(pstr);
        DebugAbort( "Can't construct parent directory" );
        return( NULL );
    }
}

PTIMEINFO
FSNODE::QueryTimeInfo (
    IN FSN_TIME FsnTime
    ) CONST

/*++

Routine Description:

    Query the time imformation pertaining to this FSNODE.

Arguments:

    None.

Return Value:

    PTIMEINFO - Returns a pointer to the TIMEINFO object.

--*/

{
    PTIMEINFO   TimeInfo;
    PFILETIME   DesiredFileTime;

    TimeInfo = NEW TIMEINFO;
    if (TimeInfo == NULL)
        return NULL;

    switch( FsnTime ) {

    case FSN_TIME_MODIFIED:
        DesiredFileTime = &( ((PFSNODE) this)->_FileData.ftLastWriteTime );
        break;

    case FSN_TIME_CREATED:
        DesiredFileTime = &( ((PFSNODE) this)->_FileData.ftCreationTime );
        break;

    case FSN_TIME_ACCESSED:
        DesiredFileTime = &( ((PFSNODE) this)->_FileData.ftLastAccessTime );
        break;

    default:
        DebugAbort( "Invalid value of FsnTime \n" );
        return( NULL );
    }

    if( !TimeInfo->Initialize( DesiredFileTime ) ) {
        DebugAbort( "TimeInfo->Initialize() failed \n" );
        return( NULL );
    }
    return( TimeInfo );
}

BOOLEAN
FSNODE::SetTimeInfo (
    IN PCTIMEINFO       TimeInfo,
    IN FSN_TIME         TimeInfoType
    )

/*++

Routine Description:

    Change the time information of an FSNODE.

Arguments:

    TimeInfo - Pointer to a TIMEINFO object that contains the new time.

    TimeInfoType - Indicates the time to be modified (creation time,
                   last access time, or last modified time )


Return Value:

    BOOLEAN - Returns TRUE if the operation succeeds. FALSE otherwise.


--*/

{
    PFILETIME   DesiredFileTime;
    HANDLE      FileHandle;
    BOOLEAN     TimeSet;

    DebugPtrAssert( TimeInfo );

    switch( TimeInfoType ) {

    case FSN_TIME_MODIFIED:
        DesiredFileTime = &( _FileData.ftLastWriteTime );
        break;

    case FSN_TIME_CREATED:
        DesiredFileTime = &( _FileData.ftCreationTime );
        break;

    case FSN_TIME_ACCESSED:
        DesiredFileTime = &( _FileData.ftLastAccessTime );
        break;

    default:
        DebugAbort( "Invalid value of FsnTime \n" );
        return( NULL );
    }

    *DesiredFileTime = *( TimeInfo->GetFileTime() );
    if( DesiredFileTime == NULL ) {
        return( FALSE );
    }

    FileHandle = CreateFile( &_FileData.cFileName[0],
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );
    if( FileHandle == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    TimeSet = SetFileTime( FileHandle,
                           &( _FileData.ftCreationTime ),
                           &( _FileData.ftLastAccessTime ),
                           &( _FileData.ftLastWriteTime ) ) != FALSE;

    CloseHandle( FileHandle );
    return( TimeSet );
}



BOOLEAN
FSNODE::Rename(
    IN PCPATH       NewName
    )
/*++

Routine Description:

    Renames a file and updates its FSNODE

Arguments:

    NewName - New name for the file.

Return Value:

    BOOLEAN - Returns TRUE if the operation succeeds. FALSE otherwise.

--*/

{

    PCWSTRING   NewNameWstring;
    PCWSTR      NewNameString;


    DebugPtrAssert( NewName );
    NewNameWstring = NewName->GetPathString();
    if( NewNameWstring == NULL ) {
        return( FALSE );
    }
    NewNameString = NewNameWstring->GetWSTR();
    if( NewNameString == NULL ) {
        return( FALSE );
    }
    if( !MoveFile( _FileData.cFileName,
                   (LPWSTR) NewNameString ) ) {
        return( FALSE );
    }
    memmove( _FileData.cFileName,
             NewNameString,
             (NewNameWstring->QueryChCount() + 1) * sizeof( WCHAR ) );
    if( !_Path.Initialize( NewName ) ) {
        return( FALSE );
    }
    return( TRUE );
}


BOOLEAN
FSNODE::DeleteFromDisk(
    IN BOOLEAN      Force
    )
{
    UNREFERENCED_PARAMETER( Force );
    return( FALSE );
}



BOOLEAN
FSNODE::UpdateFsNode (
    )

/*++

Routine Description:

    Update the file attributes in this FSNODE object.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if the attributes were updated.

--*/

{
    HANDLE          Handle;
    WIN32_FIND_DATA Data;

    if( ( Handle = FindFirstFile( &_Path, &Data ) ) == INVALID_HANDLE_VALUE ) {
        DebugPrint( "FindFirstFile() failed \n" );
        return( FALSE );
    }
    _FileData = Data;
    FindClose( Handle );
    return( TRUE );
}


ULIB_EXPORT
BOOLEAN
FSNODE::UseAlternateName(
    )
/*++

Routine Description:

    This routine set the last component of the path for this object to
    the alternate name if it is available.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FSTRING f;

    // If there is no alternate then we are already DOS compatible.

    if (!_FileData.cAlternateFileName[0]) {
        return TRUE;
    }

    return _Path.SetName(f.Initialize(_FileData.cAlternateFileName));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\hmem.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    hmem.cxx

Abstract:

    Implementation of HMEM class.
    
Author:

    Norbert P. Kusters (norbertk) 26-Nov-90

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "hmem.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( HMEM, MEM, ULIB_EXPORT );

VOID
HMEM::Construct (
    )
/*++

Routine Description:

    The is the contructor of HMEM.  It initializes the private data
    to reasonable default values.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _size = 0;
    _real_buf = NULL;
    _buf = NULL;
}


ULIB_EXPORT
HMEM::~HMEM(
    )
/*++

Routine Description:

    Destructor for HMEM.  Frees up any memory used.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
HMEM::Initialize(
    )
/*++

Routine Description:

    This routine initializes HMEM to an initial state.  All pointers or
    information previously aquired from this object will become invalid.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    return TRUE;
}


ULIB_EXPORT
PVOID
HMEM::Acquire(
    IN  ULONG   Size,
    IN  ULONG   AlignmentMask
    )
/*++

Routine Description:

    This routine acquires the memory resources of this object for
    the client to use.  'Size' bytes of data are guaranteed by
    this routine or this routine will return NULL.  After one call
    of 'Acquire' has succeeded, all subsequent calls will return the
    same memory, provided that the Size requested is within bounds
    specified in the first successful call.  The first successful call
    will dictate the size and location of the memory which will be
    available by calls to 'QuerySize' and 'GetBuf' respectively.

    A call to Initialize will invalidate all memory previously granted
    by this object and enable the next call to Acquire to specify
    any size.

Arguments:

    Size            - The number of bytes of memory expected.
    AlignmentMask   - Supplies the alignment required on the memory.

Return Value:

    A valid pointer to 'Size' bytes of memory or NULL.

--*/
{
    if (_buf) {
        if (Size <= _size && !(((ULONG_PTR) _buf)&AlignmentMask)) {
            return _buf;
        } else {
            return NULL;
        }
    }

    _size = Size;

    if (!(_real_buf = MALLOC((UINT) (_size + AlignmentMask)))) {
        return NULL;
    }

    _buf = (PVOID) ((ULONG_PTR) ((PCHAR) _real_buf + AlignmentMask) &
                            (~(ULONG_PTR)AlignmentMask));

    return _buf;
}


ULIB_EXPORT
BOOLEAN
HMEM::Resize(
    IN  ULONG   NewSize,
    IN  ULONG   AlignmentMask
    )
/*++

Routine Description:

    This method reallocates the object's buffer to a larger
    chunk of memory.

Arguments:

    NewSize         -- supplies the new size of the buffer.
    AlignmentMask   -- supplies the alignment requirements on the memory.

Return Value:

    TRUE upon successful completion.

Notes:

    This method allocates a new buffer, copies the appropriate
    amount of data to it, and then frees the old buffer.  Clients
    who use Resize must avoid caching pointers to the memory, but
    must use GetBuf to find out where the memory is.

    If NewSize is smaller than the current buffer size, we keep
    the current buffer.

    If this method fails, the object is left unchanged.

--*/
{
    PVOID NewBuffer;
    PVOID NewRealBuffer;

    // First, check to see if our current buffer is big enough
    // and has the correct alignment
    // to satisfy the client.

    if( _buf &&
        NewSize <= _size &&
        !(((ULONG_PTR) _buf)&AlignmentMask)) {

            return TRUE;
    }

    // We need to allocate a new chunk of memory.

    if( (NewRealBuffer = MALLOC((UINT) (NewSize + AlignmentMask))) == NULL ) {

        return FALSE;
    }

    NewBuffer = (PVOID) ((ULONG_PTR) ((PCHAR) NewRealBuffer + AlignmentMask) &
                                 (~(ULONG_PTR)AlignmentMask));

    // Copy data from the old buffer to the new.  Since we know
    // that NewSize is greater than _size, we copy _size bytes.

    memset( NewBuffer, 0, (UINT) NewSize );
    memcpy( NewBuffer, _buf, (UINT) min(_size, NewSize) );

    // Free the old buffer and set the object's private variables.

    FREE( _real_buf );
    _real_buf = NewRealBuffer;
    _buf = NewBuffer;
    _size = NewSize;

    return TRUE;
}


VOID
HMEM::Destroy(
    )
/*++

Routine Description:

    This routine frees the memory of a previous call to Acquire thus
    invalidating all pointers to that memory and enabling future
    Acquires to succeed.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _size = 0;
    if (_real_buf) {
        FREE(_real_buf);
        _real_buf = NULL;
    }
    _buf = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\iterator.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	iterator.cxx

Abstract:

	This contains the definitions for the non-inline member functions
	for the abstract ITERATOR class. The only interesting aspect of this
	implementation is that the destructor decrements the iterator count in
	it's associated CONTAINER. This count, increment by the CONTAINER when
	the ITERATOR is constructed, allows the associated CONTAINER to watch
	for outstanding ITERATORs when it is destroyed - a situation which is
	dangerous and surely a bug.

Author:

	David J. Gilman (davegi) 03-Dec-1990

Environment:

	ULIB, User Mode

[Notes:]

	optional-notes

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR( ITERATOR, OBJECT );

ITERATOR::~ITERATOR(
    )
{
}


POBJECT
ITERATOR::FindNext(
    IN      PCOBJECT    Key
    )
{
    POBJECT p;

    for (p = GetNext(); p; p = GetNext()) {
        if (!Key->Compare(p)) {
            break;
        }
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\listit.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "listit.hxx"


DEFINE_CONSTRUCTOR( LIST_ITERATOR, ITERATOR );


DEFINE_CAST_MEMBER_FUNCTION( LIST_ITERATOR );


VOID
LIST_ITERATOR::Reset(
    )
{
    _current = NULL;
}


POBJECT
LIST_ITERATOR::GetCurrent(
	)
{
    return _current ? _current->data : NULL;
}


POBJECT
LIST_ITERATOR::GetNext(
	)
{
    _current = _current ? _current->next : _list->_head;
    return _current ? _current->data : NULL;
}


POBJECT
LIST_ITERATOR::GetPrevious(
	)
{
    _current = _current ? _current->prev : _list->_tail;
    return _current ? _current->data : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\keyboard.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    keyboard.cxx

Abstract:

    This module contains the definitions of the member functions
    of KEYBOARD class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "stream.hxx"
#include "bufstrm.hxx"
#include "keyboard.hxx"


BOOL KEYBOARD::_FlagBreak;


#define     CTRL_Z      0x1a

DEFINE_EXPORTED_CONSTRUCTOR ( KEYBOARD, BUFFER_STREAM, ULIB_EXPORT );


DEFINE_EXPORTED_CAST_MEMBER_FUNCTION( KEYBOARD, ULIB_EXPORT );


VOID
KEYBOARD::Construct (
    )
/*++

Routine Description:

    This routine initializes the keyboard to a valid initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DoNotRestoreConsoleMode = FALSE;
}


KEYBOARD::~KEYBOARD (
    )

/*++

Routine Description:

    Destroy a KEYBOARD (close a keyboard handle).

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (!_DoNotRestoreConsoleMode)
        SetConsoleMode( _KeyboardHandle, _PreviousMode );
    CloseHandle( _KeyboardHandle );
}



ULIB_EXPORT
VOID
KEYBOARD::DoNotRestoreConsoleMode(
    )
/*++

Routine Description:

    Set the flag such that on destruction of the keyboard class,
    the console mode will not be restored.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    _DoNotRestoreConsoleMode = TRUE;
}


ULIB_EXPORT
BOOLEAN
KEYBOARD::Initialize(
    BOOLEAN LineMode,
    BOOLEAN EchoMode
    )

/*++

Routine Description:

    Initializes a KEYBOARD class.

Arguments:

    LineMode - Indicates if the keyboard is to be set in line mode.

    EchoMode - Indicates if the keyboard is to be set in the echo mode
               (characters are echoed to the current active screen)

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.

--*/

{
    ULONG   KeyboardMode;

    _KeyboardHandle = CreateFile( (LPWSTR)L"CONIN$",
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL );
    if( _KeyboardHandle ==INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }
    if( !GetConsoleMode( _KeyboardHandle, &_PreviousMode ) ) {
        return( FALSE );
    }
    KeyboardMode = _PreviousMode;
    if( LineMode ) {
        KeyboardMode |= ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT;
    } else {
        KeyboardMode &= ~(ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT);
    }
    if( EchoMode ) {
        KeyboardMode |= ENABLE_ECHO_INPUT;
    } else {
        KeyboardMode &= ~ENABLE_ECHO_INPUT;
    }
    if( !SetConsoleMode( _KeyboardHandle, KeyboardMode ) ) {
        return( FALSE );
    }
    _FlagCtrlZ = FALSE;
    return( BUFFER_STREAM::Initialize( 256 ) );
}


BOOL
KEYBOARD::BreakHandler (
    IN  ULONG   CtrlType
    )

/*++

Routine Description:

    Handles Break events. Sets up the static data so that it can be
    queried later on.

Arguments:

    CtrlType    -   Supplies the type of Ctrl

Return Value:

    none

--*/

{
    UNREFERENCED_PARAMETER( CtrlType );

    _FlagBreak  =   TRUE;
    return TRUE;
}


ULIB_EXPORT
BOOLEAN
KEYBOARD::GotABreak (
    )

/*++

Routine Description:

    Determines if a Break event (e.g Ctrl-C) was caught and handled.

    The static data that contains the Break information is set to a
    "FALSE" state.  Note that this means that if there is no Break
    between two consecutive calls to this method, then the second
    one will always return FALSE.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE if a Break event happened, FALSE otherwise.

--*/

{
    BOOLEAN GotBreak = _FlagBreak != FALSE;

    _FlagBreak = FALSE;

    return GotBreak;

}

ULIB_EXPORT
BOOLEAN
KEYBOARD::EnableBreakHandling(
    )

/*++

Routine Description:

    Enables Break events handling (E.g. Ctrl-C).

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    _FlagBreak = FALSE;

    return SetConsoleCtrlHandler( KEYBOARD::BreakHandler, TRUE ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
KEYBOARD::EnableLineMode(
    )

/*++

Routine Description:

    Set the keyboard in line mode.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    ULONG   Mode;

    if( !GetConsoleMode( _KeyboardHandle, &Mode ) ) {
        return( FALSE );
    }

    Mode |= ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT;
    return( SetConsoleMode( _KeyboardHandle, Mode ) != FALSE);
}



ULIB_EXPORT
BOOLEAN
KEYBOARD::DisableBreakHandling(
    )

/*++

Routine Description:

    Disables Break event handling (E.g. Ctrl-C).

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    _FlagBreak = FALSE;

    return SetConsoleCtrlHandler( KEYBOARD::BreakHandler, FALSE ) != FALSE;

}

ULIB_EXPORT
BOOLEAN
KEYBOARD::DisableLineMode(
    )

/*++

Routine Description:

    Set the keyboard in character mode.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    ULONG   Mode;

    // unreferenced parameters
    (void)(this);

    if( !GetConsoleMode( _KeyboardHandle, &Mode ) ) {
        return( FALSE );
    }
    Mode &= ~(ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT);
    return( SetConsoleMode( _KeyboardHandle, Mode ) != FALSE );
}




BOOLEAN
KEYBOARD::IsLineModeEnabled(
    OUT PBOOLEAN    LineMode
    ) CONST

/*++

Routine Description:

    Finds out if the keyboard is in line mode.

Arguments:

    LineMode - Returns TRUE if in LineMode; otherwise, FALSE.

Return Value:

    Returns TRUE if successful

--*/

{
    ULONG   Mode;

    if (GetConsoleMode( _KeyboardHandle, &Mode )) {
        *LineMode = (( Mode & ENABLE_LINE_INPUT ) ? TRUE : FALSE );
        return TRUE;
    } else {
        return FALSE;
    }
}



BOOLEAN
KEYBOARD::EnableEchoMode(
    )

/*++

Routine Description:

    Set the keyboard in echo mode.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    ULONG   Mode;

    if( !GetConsoleMode( _KeyboardHandle, &Mode ) ) {
        return( FALSE );
    }
    Mode |= ENABLE_ECHO_INPUT;
    return( SetConsoleMode( _KeyboardHandle, Mode ) != FALSE );
}



BOOLEAN
KEYBOARD::DisableEchoMode(
    )

/*++

Routine Description:

    Does not echo characters read from keyboard.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.

--*/

{
    ULONG   Mode;

    if( !GetConsoleMode( _KeyboardHandle, &Mode ) ) {
        return( FALSE );
    }
    Mode &= ~ENABLE_ECHO_INPUT;
    return( SetConsoleMode( _KeyboardHandle, Mode ) != FALSE );
}



BOOLEAN
KEYBOARD::IsEchoModeEnabled(
    OUT PBOOLEAN    EchoInput
    ) CONST

/*++

Routine Description:

    Finds out if characters read from keyboard echoed to the screen.

Arguments:

    EchoInput - Returns TRUE if Echo Input is enabled; otherwise, FALSE.

Return Value:

    Returns TRUE if successful; otherwise, FALSE.

--*/

{
    ULONG   Mode;

    if (GetConsoleMode( _KeyboardHandle, &Mode )) {
        *EchoInput = (( Mode | ENABLE_ECHO_INPUT ) ? TRUE : FALSE);
        return TRUE;
    } else {
        return FALSE;
    }
}



BOOLEAN
KEYBOARD::CheckForAsciiKey(
    IN PINPUT_RECORD    InputRecord,
    IN ULONG            NumberOfInputRecords
    ) CONST

/*++

Routine Description:

    Examines an array of input records in order to find out if at least
    one ascii key was pressed.

Arguments:

    InputRecord - Pointer to an array of INPUT_RECORDS.

    NumberOfInputRecords - Number of elements in the array


Return Value:

    BOOLEAN - Indicates if the input buffer contains at least one
              ASCII key.


--*/

{
    BOOLEAN Result;

    // unreferenced parameters
    (void)(this);

    Result = FALSE;
    while( !Result && NumberOfInputRecords ) {
        if( ( InputRecord->EventType == KEY_EVENT ) &&
            ( InputRecord->Event ).KeyEvent.bKeyDown &&

#if defined(FE_SB)
            ( ( InputRecord->Event ).KeyEvent.uChar.UnicodeChar > 0 ) &&
            ( ( InputRecord->Event ).KeyEvent.uChar.UnicodeChar <= 0x7e ) ) {
#else
            ( ( InputRecord->Event ).KeyEvent.uChar.AsciiChar > 0 ) &&
            ( ( InputRecord->Event ).KeyEvent.uChar.AsciiChar <= 0x7e ) ) {
#endif

            Result = TRUE;
        } else {
            NumberOfInputRecords--;
            InputRecord++;
        }
    }
    return( Result );
}



ULIB_EXPORT
BOOLEAN
KEYBOARD::IsKeyAvailable(
    OUT PBOOLEAN    Available
    ) CONST

/*++

Routine Description:

    Determines if there is at least one key to be read.

Arguments:

    Available - Pointer to the variable that will contain the result of
                the query (if there is a key in the keyboard buffer).

Return Value:

    BOOLEAN - A boolean value that indicates if the operation succeeded
              If this value is FALSE, the contets of 'Available' has no
              meaning (the calls to the APIs failed).


--*/


{
    BOOLEAN         Result;
    ULONG           NumberOfInputEvents;
    PINPUT_RECORD   Event;
    ULONG           NumberOfEventsRead;

    //
    // Keys read, but not yet consumed, are kept are in a buffer.
    // So, we have to check first if there is at least one key
    // in this buffer.
    //
    if( BUFFER_STREAM::QueryBytesInBuffer() != 0 ) {
        *Available = TRUE;
        return( TRUE );
    }
    //
    // If there was no key previously read, we have to check the
    // keyboard buffer for key events.
    //
    Result = FALSE;
    if ( GetNumberOfConsoleInputEvents( _KeyboardHandle,
                                        &NumberOfInputEvents ) ) {

        if( NumberOfInputEvents == 0 ) {
            *Available = FALSE;
            Result = TRUE;
        } else {
            Event = ( PINPUT_RECORD ) MALLOC( ( size_t )( sizeof( INPUT_RECORD ) * NumberOfInputEvents ) );
            if (Event == NULL) {
                DebugPrint("ULIB: Out of memory\n");
                return FALSE;
            }
            if( PeekConsoleInput( _KeyboardHandle,
                                  Event,
                                  NumberOfInputEvents,
                                  &NumberOfEventsRead ) &&
                NumberOfEventsRead != 0 ) {

                *Available = CheckForAsciiKey( Event, NumberOfInputEvents );
                Result = TRUE;
            }
            FREE( Event );
        }

    }
    return( Result );
}




BOOLEAN
KEYBOARD::FillBuffer(
    OUT PBYTE   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Fills a buffer with data read from the keyboard.

Arguments:

    Buffer  - Points to the buffer where the data will be put.

    BufferSize  - Indicates total number of bytes to read from the stream.

    BytesRead   - Points to the variable that will contain the number of
                  bytes read.

Return Value:

    BOOLEAN - Indicates if the read operation succeeded.


--*/


{
    BOOLEAN     Result;
    ULONG       Count;
    BOOLEAN     LineMode;


    Result = ReadFile( _KeyboardHandle,
                       Buffer,
                       BufferSize,
                       BytesRead,
                       NULL ) != FALSE;
    if( !Result ) {
        return( Result );
    }
    if (*BytesRead == 0) {
        _FlagCtrlZ = TRUE;
    } else {
        if (!IsLineModeEnabled(&LineMode))
            return FALSE;

        if (LineMode) {
            Count = *BytesRead;
            while( Count > 0 ) {
                if( *Buffer != CTRL_Z ) {
                    Count--;
                    Buffer++;
                } else {
                    *Buffer = 0;
                    *BytesRead -= Count;
                    _FlagCtrlZ = TRUE;
                    Count = 0;          // To get out of while() loop
                }
            }
        }
    }
    BUFFER_STREAM::SetStreamTypeANSI();
    return( Result );
}


ULIB_EXPORT
BOOLEAN
KEYBOARD::Flush(
    )

/*++

Routine Description:

    Discards all keys in the buffer in BUFFER_STREAM, and flushes the
    console input buffer.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    BUFFER_STREAM::FlushBuffer();
    return( FlushConsoleInputBuffer( _KeyboardHandle ) != FALSE );
}



BOOLEAN
KEYBOARD::EndOfFile(
    ) CONST

/*++

Routine Description:

    Indicates if end-of-file has occurred when the keyboard was read.
    End-of-file for a keyboard means that the keyboard was in line
    mode and a Ctrl-Z was read from the keyboard.

Arguments:

    None.

Return Value:

    BOOLEAN - returns TRUE if the keyboard is in the line mode and a
              CTRL-Z was read. Returns FALSE otherwise.

--*/

{
    BOOLEAN     CtrlZ;
    BOOLEAN     MoreKeys;
    PBOOLEAN    Pointer;

    CtrlZ = _FlagCtrlZ;
    if( CtrlZ ) {
        if( IsKeyAvailable( &MoreKeys ) ) {
            //
            // Enables client to read again from the keyboard
            //
            // This method is CONST and shouldn't modify
            // _FlagCtrlZ, but here is the place to do it.
            // I cannot define the method as non-const because it was
            // defined as CONST in the base class
            //
            Pointer = &(((PKEYBOARD) this)->_FlagCtrlZ);
            *Pointer = !MoreKeys;
        }
    }
    return( CtrlZ );
}

STREAMACCESS
KEYBOARD::QueryAccess(
    ) CONST

/*++

Routine Description:

    Informs the caller about the access to the keyboard.

Arguments:

    None.

Return Value:

    STREAMACCESS - Returns READ_ACCESS always.

--*/

{
    // unreferenced parameters
    (void)(this);

    return( READ_ACCESS );
}




ULONG
KEYBOARD::QueryDelay(
    ) CONST

/*++

Routine Description:

    Obtains the delay value of the keyboard.

Arguments:

    None.

Return Value:

    ULONG   -   The delay value.

--*/

{
    INT Delay;

    SystemParametersInfo( SPI_GETKEYBOARDDELAY, 0, &Delay, 0 );

    return Delay;
}

HANDLE
KEYBOARD::QueryHandle(
    ) CONST

/*++

Routine Description:

    Returns to the caller the keyboard handle.

Arguments:

    None.

Return Value:

    HANDLE - Returns the keyboard handle.

--*/

{
    return( _KeyboardHandle );
}


ULONG
KEYBOARD::QuerySpeed(
    ) CONST

/*++

Routine Description:

    Obtains the speed rate of the keyboard.

Arguments:

    None.

Return Value:

    ULONG   -   The speed value.

--*/

{
    WORD    Speed;

    SystemParametersInfo( SPI_GETKEYBOARDSPEED, 0, &Speed, 0 );

    return Speed;

}


BOOLEAN
KEYBOARD::SetDelay(
    IN ULONG    Delay
    ) CONST

/*++

Routine Description:

    Sets the delay value of the keyboard.

Arguments:

    Delay   -   Supplies the delay value

Return Value:

    BOOLEAN -   TRUE if delay set, FALSE otherwise

--*/

{

    // return SystemParametersInfo( SPI_SETKEYBOARDDELAY, (UINT)Delay, NULL, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );
    return TRUE;

}


BOOLEAN
KEYBOARD::SetSpeed (
    IN ULONG    Speed
    ) CONST

/*++

Routine Description:

    Sets the speed  rate of the keyboard.

Arguments:

    Speed   -   Supplies the speed value

Return Value:

    BOOLEAN -   TRUE if speed set, FALSE otherwise

--*/

{

    // return SystemParametersInfo( SPI_SETKEYBOARDSPEED, (UINT)Speed, NULL, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );
    return TRUE;

}

ULIB_EXPORT
CONST
PBOOL
KEYBOARD::GetPFlagBreak (
    VOID
    ) CONST

/*++

Routine Description:

    Returns pointer to _FlagBreak.  Used by xcopy to pass pointer to _FlagBreak
    as the lpCancel flag to CopyFileEx.  When the user hits a Ctrl-C, this flag
    becomes TRUE and CopyFileEx will stop copying the current file.

Arguments:

    none

Return Value:

    Pointer to _Flagbreak
--*/

{
    return (&_FlagBreak);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\makefile.inc ===
..\..\inc\rtmsg.h msg00001.bin rtmsg.rc: ..\rtmsg.mc ..\ulib.rc
    mc -v -h ..\..\inc\ ..\rtmsg.mc
    copy rtmsg.rc + ..\ulib.rc rtmsg.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\list.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "list.hxx"
#include "listit.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( LIST, SEQUENTIAL_CONTAINER, ULIB_EXPORT );

VOID
LIST::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _head = NULL;
    _tail = NULL;
    _count = 0;
}


VOID
LIST::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _head = NULL;
    _tail = NULL;
    _count = 0;
}


ULIB_EXPORT
LIST::~LIST(
    )
/*++

Routine Description:

    Destructor for LIST.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
LIST::Initialize(
    )
/*++

Routine Description:

    This routine initializes the object to a valid initial state.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!_mem_block_mgr.Initialize(sizeof(OBJECT_LIST_NODE))) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}


ULONG
LIST::QueryMemberCount(
    ) CONST
/*++

Routine Description:

    This routine computes the number of members in the list.

Arguments:

    None.

Return Value:

    The number of members in the list.

--*/
{
    return _count;
}


ULIB_EXPORT
BOOLEAN
LIST::Put(
	IN  POBJECT	Member
	)
/*++

Routine Description:

    This routine adds a new member to the end of the list.

Arguments:

    Member  - Supplies the element to add to the list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!_tail) {

        if (!(_head = _tail = (POBJECT_LIST_NODE) _mem_block_mgr.Alloc())) {
            return FALSE;
        }

        _head->next = _head->prev = NULL;
        _head->data = Member;

        _count++;
        return TRUE;
    }

    if (!(_tail->next = (POBJECT_LIST_NODE) _mem_block_mgr.Alloc())) {
        return FALSE;
    }

    _tail->next->prev = _tail;
    _tail = _tail->next;

    _tail->next = NULL;
    _tail->data = Member;

    _count++;
    return TRUE;
}


POBJECT
LIST::Remove(
	IN OUT  PITERATOR   Position
	)
/*++

Routine Description:

    This routine removes the element at the specified position from the
    list.  The iterator is left pointing at the following element in
    the list.

Arguments:

    Position    - Supplies a pointer to the element to remove.

Return Value:

    A pointer to the element removed.

--*/
{
    POBJECT_LIST_NODE   p;
    PLIST_ITERATOR      piter;
    POBJECT             pobj;

    DebugAssert(LIST_ITERATOR::Cast(Position));

    if (!(piter = (PLIST_ITERATOR) Position) || !(p = piter->_current)) {
        return NULL;
    }

    if (p->next) {
        p->next->prev = p->prev;
    }

    if (p->prev) {
        p->prev->next = p->next;
    }

    if (_head == p) {
        _head = p->next;
    }

    if (_tail == p) {
        _tail = p->prev;
    }

    piter->_current = p->next;

    pobj = p->data;

    _mem_block_mgr.Free(p);

    _count--;

    return pobj;
}


ULIB_EXPORT
PITERATOR
LIST::QueryIterator(
	) CONST
/*++

Routine Description:

    This routine returns an iterator for this list.

Arguments:

    None.

Return Value:

    A valid iterator.

--*/
{
    PLIST_ITERATOR  p;

    if (!(p = NEW LIST_ITERATOR)) {
        return NULL;
    }

    p->Initialize(this);

    return p;
}


ULIB_EXPORT
BOOLEAN
LIST::Insert(
    IN OUT  POBJECT     Member,
    IN OUT  PITERATOR   Position
    )
/*++

Routine Description:

    This routine inserts a new element before the specified position.
    The 'Position' continues to point to the same element.

Arguments:

    Member      - Supplies the element to insert.
    Position    - Supplies the point at which to insert this member.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    POBJECT_LIST_NODE   p, current;

    DebugAssert(LIST_ITERATOR::Cast(Position));

    current = ((PLIST_ITERATOR) Position)->_current;

    if (!current) {
        return Put(Member);
    }

    if (!(p = (POBJECT_LIST_NODE) _mem_block_mgr.Alloc())) {
        return FALSE;
    }

    _count++;
    p->data = Member;

    if (current == _head) {
        _head = p;
    }

    p->next = current;
    p->prev = current->prev;
    current->prev = p;

    if (p->prev) {
        p->prev->next = p;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\machine.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_

#if defined(_AUTOCHECK_)
extern "C" {
    #include "nt.h"
    #include "ntrtl.h"
    #include "nturtl.h"
}
#endif // defined(_AUTOCHECK_)

#include "ulib.hxx"
#include "machine.hxx"

extern "C" {
    #include "windows.h"
}

#if defined(FE_SB) && defined(_X86_)

extern "C" {

#ifndef _MACHINEP_ID_
#define _MACHINEP_ID_

//
// Registry Key
//

//
// UNICODE
//

#define REGISTRY_HARDWARE_DESCRIPTION_W \
        L"\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_W      \
        L"Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_W   \
        L"Identifier"

#define FUJITSU_FMR_NAME_W    L"FUJITSU FMR-"
#define NEC_PC98_NAME_W       L"NEC PC-98"

//
// ANSI
//

#define REGISTRY_HARDWARE_DESCRIPTION_A \
        "\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_A      \
        "Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_A   \
        "Identifier"

#define FUJITSU_FMR_NAME_A    "FUJITSU FMR-"
#define NEC_PC98_NAME_A       "NEC PC-98"

//
// Automatic
//

#define REGISTRY_HARDWARE_DESCRIPTION \
        TEXT("\\Registry\\Machine\\Hardware\\DESCRIPTION\\System")

#define REGISTRY_HARDWARE_SYSTEM      \
        TEXT("Hardware\\DESCRIPTION\\System")

#define REGISTRY_MACHINE_IDENTIFIER   \
        TEXT("Identifier")

#define FUJITSU_FMR_NAME    TEXT("FUJITSU FMR-")
#define NEC_PC98_NAME       TEXT("NEC PC-98")

//
// These definition are only for Intel platform.
//
//
// Hardware platform ID
//

#define PC_AT_COMPATIBLE      0x00000000
#define PC_9800_COMPATIBLE    0x00000001
#define FMR_COMPATIBLE        0x00000002

//
// NT Vendor ID
//

#define NT_MICROSOFT          0x00010000
#define NT_NEC                0x00020000
#define NT_FUJITSU            0x00040000

//
// Vendor/Machine IDs
//
// DWORD MachineID
//
// 31           15             0
// +-------------+-------------+
// |  Vendor ID  | Platform ID |
// +-------------+-------------+
//

#define MACHINEID_MS_PCAT     (NT_MICROSOFT|PC_AT_COMPATIBLE)
#define MACHINEID_MS_PC98     (NT_MICROSOFT|PC_9800_COMPATIBLE)
#define MACHINEID_NEC_PC98    (NT_NEC      |PC_9800_COMPATIBLE)
#define MACHINEID_FUJITSU_FMR (NT_FUJITSU  |FMR_COMPATIBLE)

//
// Macros
//

#define ISNECPC98(x)    (x == MACHINEID_NEC_PC98)
#define ISFUJITSUFMR(x) (x == MACHINEID_FUJITSU_FMR)
#define ISMICROSOFT(x)  (x == MACHINEID_MS_PCAT)

#endif // _MACHINE_ID_

}

#if defined( _AUTOCHECK_ )

DWORD _dwMachineId = MACHINEID_MICROSOFT;

//
//  Local Support routine
//

#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + \
                        sizeof(ULONG)) + 64)


InitializeMachineId(
    VOID
)
/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the machine identifier information and get the
    value.

Return Value:

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING ValueName;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    STATIC BOOLEAN bInitialized = FALSE;

    if( bInitialized ) {
        return TRUE;
    } else {
        bInitialized = TRUE;
    }

    //
    //  Read the registry to determine of machine type.
    //

    ValueName.Buffer = REGISTRY_MACHINE_IDENTIFIER;
    ValueName.Length = sizeof(REGISTRY_MACHINE_IDENTIFIER) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(REGISTRY_MACHINE_IDENTIFIER);

    KeyName.Buffer = REGISTRY_HARDWARE_DESCRIPTION;
    KeyName.Length = sizeof(REGISTRY_HARDWARE_DESCRIPTION) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(REGISTRY_HARDWARE_DESCRIPTION);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return FALSE;
    }

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    Status = NtQueryValueKey(Handle,
                             &ValueName,
                             KeyValueFullInformation,
                             KeyValueInformation,
                             RequestLength,
                             &ResultLength);

    ASSERT( Status != STATUS_BUFFER_OVERFLOW );

    if (Status == STATUS_BUFFER_OVERFLOW) {

        return FALSE;

    }

    NtClose(Handle);

    if (NT_SUCCESS(Status)) {

        if (KeyValueInformation->DataLength != 0) {

            PWCHAR DataPtr;
            UNICODE_STRING DetectedString, TargetString1, TargetString2;

            //
            // Return contents to the caller.
            //

            DataPtr = (PWCHAR)
              ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);

            //
            // Initialize strings.
            //

            RtlInitUnicodeString( &DetectedString, DataPtr );
            RtlInitUnicodeString( &TargetString1, FUJITSU_FMR_NAME_W );
            RtlInitUnicodeString( &TargetString2, NEC_PC98_NAME_W );

            //
            // Check the hardware platform
            //

            if (RtlPrefixUnicodeString( &TargetString1 , &DetectedString , TRUE)) {

                //
                // Fujitsu FMR Series.
                //

                _dwMachineId = MACHINEID_FUJITSU_FMR;

#if 0
            } else if (RtlPrefixUnicodeString( &TargetString2 , &DetectedString , TRUE)) {
#else
            } else if (IsNEC_98) {
#endif
                //
                // NEC PC-9800 Seriss
                //

                _dwMachineId = MACHINEID_NEC_PC98;

            } else {

                //
                // Standard PC/AT comapatibles
                //

                _dwMachineId = MACHINEID_MS_PCAT;

            }

            return TRUE;

        } else {

            //
            // Treat as if no value was found
            //

            return FALSE;

        }
    }

    return FALSE;
}

#else // _AUTOCHECK_

DEFINE_EXPORTED_CONSTRUCTOR( MACHINE, OBJECT, ULIB_EXPORT );

DWORD MACHINE::_dwMachineId = MACHINEID_MICROSOFT;

ULIB_EXPORT MACHINE MachinePlatform;

NONVIRTUAL
ULIB_EXPORT
BOOLEAN
MACHINE::Initialize(
    VOID
    )
{
    HKEY           hkeyMap;
    int            ret;
    DWORD          cb;
    WCHAR          szBuff[80];
    UNICODE_STRING DetectedString,
                   TargetString1,
                   TargetString2;

    STATIC LONG InitializingMachine = 0;
    STATIC BOOLEAN bInitialized = FALSE;
    LONG           status;
    LARGE_INTEGER  timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingMachine, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

    if( bInitialized ) {
        status = InterlockedDecrement(&InitializingMachine);
        DebugAssert(status == 0);
        return TRUE;
    } else {
        bInitialized = TRUE;    // not sure why it is set to TRUE so soon
    }

    if ( RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                       REGISTRY_HARDWARE_SYSTEM,
                       0,
                       KEY_READ,
                       &hkeyMap) !=  ERROR_SUCCESS ) {

        status = InterlockedDecrement(&InitializingMachine);
        DebugAssert(status == 0);
        return( FALSE );
    }

    //
    // Reg functions deal with bytes, not chars
    //

    cb = sizeof(szBuff);

    ret = RegQueryValueExW(hkeyMap,
                           REGISTRY_MACHINE_IDENTIFIER,
                           NULL, NULL, (LPBYTE)szBuff, &cb);

    RegCloseKey(hkeyMap);

    if (ret != ERROR_SUCCESS) {
        status = InterlockedDecrement(&InitializingMachine);
        DebugAssert(status == 0);
        return( FALSE );
    }

    //
    // Initialize strings.
    //

    RtlInitUnicodeString( &DetectedString, szBuff );
    RtlInitUnicodeString( &TargetString1, FUJITSU_FMR_NAME_W );
    RtlInitUnicodeString( &TargetString2, NEC_PC98_NAME_W );

    //
    // Check the hardware platform
    //

    if (RtlPrefixUnicodeString( &TargetString1 , &DetectedString , TRUE)) {

        //
        // Fujitsu FMR Series.
        //

        _dwMachineId = MACHINEID_FUJITSU_FMR;

#if 0
    } else if (RtlPrefixUnicodeString( &TargetString2 , &DetectedString , TRUE)) {
#else
    } else if (IsNEC_98) {
#endif

        //
        // NEC PC-9800 Seriss
        //

        _dwMachineId = MACHINEID_NEC_PC98;

    } else {

        //
        // Standard PC/AT comapatibles
        //

        _dwMachineId = MACHINEID_MS_PCAT;

    }

    status = InterlockedDecrement(&InitializingMachine);
    DebugAssert(status == 0);

    return( TRUE );
}

NONVIRTUAL
ULIB_EXPORT
BOOLEAN
MACHINE::IsFMR(
    VOID
)
{
    return( ISFUJITSUFMR( _dwMachineId ) );
}

NONVIRTUAL
ULIB_EXPORT
BOOLEAN
MACHINE::IsPC98(
    VOID
)
{
    return( ISNECPC98( _dwMachineId ) );
}

NONVIRTUAL
ULIB_EXPORT
BOOLEAN
MACHINE::IsPCAT(
    VOID
)
{
    return( ISMICROSOFT( _dwMachineId ) );
}

#endif // defined( _AUTOCHECK_ )
#endif // defined(FE_SB) && defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\mbstr.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    mbstr.cxx

Abstract:

    This module contains the implementation of the MBSTR class. The MBSTR
    class is a module that provides static methods for operating on
    multibyte strings.


Author:

    Ramon J. San Andres (ramonsa) 21-Feb-1992

Environment:

    ULIB, User Mode

Notes:



--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "mbstr.hxx"

extern "C" {
    #include <string.h>
    #include <ctype.h>
}

#ifdef FE_SB

STATIC WORD wDBCSFullSpace  = 0xFFFF;
STATIC BOOL bIsDBCSCodePage = FALSE;

BOOL IsDBCSCodePage()
{
    STATIC WCHAR wFullSpace= 0x3000;
    STATIC LONG  InitializingDBCS = 0;

    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingDBCS, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

    if (wDBCSFullSpace == 0xFFFF) {

        if (WideCharToMultiByte(
                CP_ACP,
                0,
                &wFullSpace,
                1,
                (LPSTR) &wDBCSFullSpace,
                sizeof(wDBCSFullSpace),
                NULL,
                NULL) == 2) { // only FE code page can return 2 bytes for 0x3000
            bIsDBCSCodePage = TRUE;
        }
        else {
            wDBCSFullSpace = 0x0000;
        }
    }

    status = InterlockedDecrement(&InitializingDBCS);
    DebugAssert(status == 0);

    return bIsDBCSCodePage;
}
#endif


PSTR*
MBSTR::MakeLineArray (
    INOUT   PSTR*   Buffer,
    INOUT   PDWORD  BufferSize,
    INOUT   PDWORD  NumberOfLines
    )
/*++

Routine Description:

    Constructs an array of strings into a buffer, one string per line.
    Adds nulls in the buffer.

Arguments:

    Buffer          -   Supplies the buffer.
                        Receives pointer remaining buffer

    BufferSize      -   Supplies the size of the buffer.
                        Receives the size of the remaining buffer

    NumberOfLines   -   Supplies number of lines wanted.
                        Receives number of lines obtained. If BufferSize is
                        0 on output, the last line is partial (i.e. equal
                        to Buffer).

Return Value:

    Pointer to array of string pointers.


--*/
{

#if 0
    PSTR   *Array = NULL;
    DWORD   NextElement;
    DWORD   ArraySize;
    DWORD   ArrayLeft;
    DWORD   Lines = 0;
    DWORD   LinesLeft;
    DWORD   Size, Size1;
    PSTR    Buf, Buf1;
    PSTR    p;
    DWORD   Idx;

    if ( Buffer && BufferSize && NumberOfLines ) {

        Buf         = *Buffer;
        Size        = *BufferSize;
        Linesleft   = *NumberOfLines;

        if ( Buf && (Array = (PSTR *)MALLOC( CHUNK_SIZE * sizeof( PSTR *)) ) ) {

            ArrayLeft   = CHUNK_SIZE;
            ArraySize   = CHUNK_SIZE;

            //
            //  Linearize the buffer and get pointers to all the lines
            //
            while ( Size && LinesLeft ) {

                //
                //  If Array is full, reallocate it.
                //
                if ( ArrayLeft == 0 ) {

                    if ( !(Array = (PSTR *)REALLOC( Array, (ArraySize+CHUNK_SIZE) * sizeof( PSTR * ) ) )) {

                        Buf     = *Buffer;
                        Size    = *BufferSize;
                        Lines   = 0;
                        break;
                    }

                    ArraySize += CHUNK_SIZE;
                    ArrayLeft += CHUNK_SIZE;

                }


                //
                //  Get one line and add it to the array
                //
                Buf1    = Buf;
                Size1   = Size;

                while ( TRUE ) {

                    //
                    //  Look for end of line
                    //
                    Idx = Strcspn( Buf1, "\r\n" );


                    //
                    //  If end of line not found, we add the last chunk to the list and
                    //  increment the line count, but to not update the size.
                    //
                    if ( Idx > Size1 ) {
                        //
                        //  End of line not found, we add the last chunk
                        //  to the list and stop looking for strings, but
                        //  we do not update the size.
                        //
                        LinesLeft = 0;
                        Size1     = Size;
                        Buf1      = Buf;
                        break;

                    } else {
                        //
                        //  If this is really the end of a line we stop.
                        //
                        Buf1    += Idx;
                        Size1   -= Idx;

                        //
                        //  If '\r', see if this is really the end of a line.
                        //
                        if ( *Buf1 == '\r' ) {

                            if ( Size1 == 0 ) {

                                //
                                //  Cannot determine if end of line because
                                //  ran out of buffer
                                //
                                LinesLeft   = 0;
                                Size1       = Size;
                                Buf1        = Buf;
                                break;

                            } else if ( *(Buf+1) == '\n' ) {

                                //
                                //  End of line is \r\n
                                //
                                *Buf1++ = '\0';
                                *Buf1++ = '\0';
                                Size1--;
                                break;

                            } else {

                                //
                                //  Not end of line
                                //
                                Buf1++;
                                Size1--;

                            }

                        } else {

                            //
                            //  End of line is \n
                            //
                            Buf1++;
                            Size1--;
                            break;
                        }

                    }
                }

                //
                //  Add line to array
                //
                Array[Lines++] = Buf;

                Buf     = Buf1;
                Size    = Size1;

            }
        }

        *Buffer         = Buf;
        *BufferSize     = Size;
        *NumberOfLines  = Lines;
    }

    return Array;
#endif

    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( BufferSize );
    UNREFERENCED_PARAMETER( NumberOfLines );

    return NULL;
}



DWORD
MBSTR::Hash(
    IN      PSTR    String,
    IN      DWORD   Buckets,
    IN      DWORD   BytesToSum
    )
{

    DWORD   HashValue = 0;
    DWORD   Bytes;

    if ( !String ) {

        HashValue = (DWORD)-1;

    } else {

        if ( (Bytes = (DWORD)Strlen( String )) > BytesToSum ) {
            Bytes = BytesToSum;
        }

        while ( Bytes > 0 ) {
            HashValue += *(String + --Bytes);
        }

        HashValue = HashValue % Buckets;
    }

    return HashValue;
}



PSTR
MBSTR::SkipWhite(
    IN  PSTR    p
    )
{

#ifdef FE_SB
    if (bIsDBCSCodePage) {
        while (*p) {

            if (*p == LOBYTE(wDBCSFullSpace) && *(p+1) == HIBYTE(wDBCSFullSpace)) {
                *p++ = ' ';
                *p++ = ' ';
            } else if (!IsDBCSLeadByte(*p) && isspace(*(BYTE*)p)) {
                p++;
            } else {
                break;
            }
        }
    }
    else { // according to original logic
        while (isspace(*(BYTE*)p)) {
            p++;
        }
    }
#else
    while (isspace(*(BYTE*)p)) {
        p++;
    }
#endif


    return p;

}



/**************************************************************************/
/* Compare two strings, ignoring white space, case is significant, return */
/* 0 if identical, <>0 otherwise.  Leading and trailing white space is    */
/* ignored, internal white space is treated as single characters.         */
/**************************************************************************/
ULIB_EXPORT
INT
MBSTR::Strcmps (
    IN  PSTR    p1,
    IN  PSTR    p2
    )
{
  char *q;
#ifdef FE_SB
  IsDBCSCodePage();
#endif

  p1 = MBSTR::SkipWhite(p1);                /* skip any leading white space */
  p2 = MBSTR::SkipWhite(p2);

  while (TRUE)
  {
    if (*p1 == *p2)
    {
      if (*p1++ == 0)             /* quit if at the end */
        return (0);
      else
        p2++;

#ifdef FE_SB
      if (CheckSpace(p1))
#else
      if (isspace(*(BYTE*)p1))           /* compress multiple spaces */
#endif
      {
        q = MBSTR::SkipWhite(p1);
        p1 = (*q == 0) ? q : q - 1;
      }

#ifdef FE_SB
      if (CheckSpace(p2))
#else
      if (isspace(*(BYTE*)p2))
#endif
      {
        q = MBSTR::SkipWhite(p2);
        p2 = (*q == 0) ? q : q - 1;
      }
    }
    else
      return *p1-*p2;
  }
}





/**************************************************************************/
/* Compare two strings, ignoring white space, case is not significant,    */
/* return 0 if identical, <>0 otherwise.  Leading and trailing white      */
/* space is ignored, internal white space is treated as single characters.*/
/**************************************************************************/
ULIB_EXPORT
INT
MBSTR::Strcmpis (
    IN  PSTR    p1,
    IN  PSTR    p2
    )
{
#ifndef FE_SB
  char *q;

  p1 = MBSTR::SkipWhite(p1);                  /* skip any leading white space */
  p2 = MBSTR::SkipWhite(p2);

  while (TRUE)
  {
      if (toupper(*(BYTE *)p1) == toupper(*(BYTE *)p2))
      {
          if (*p1++ == 0)                /* quit if at the end */
              return (0);
          else
              p2++;

          if (isspace(*(BYTE*)p1))              /* compress multiple spaces */
          {
              q = SkipWhite(p1);
              p1 = (*q == 0) ? q : q - 1;
          }

          if (isspace(*(BYTE *)p2))
          {
              q = MBSTR::SkipWhite(p2);
              p2 = (*q == 0) ? q : q - 1;
          }
      }
      else
          return *p1-*p2;
  }
#else   // FE_SB
// MSKK KazuM Jan.28.1993
// Unicode DBCS support
  PSTR q;

  IsDBCSCodePage();

  p1 = MBSTR::SkipWhite(p1);                  /* skip any leading white space */
  p2 = MBSTR::SkipWhite(p2);

  while (TRUE)
  {
      if (toupper(*(BYTE*)p1) == toupper(*(BYTE*)p2))
      {
        if (*p1++ == 0)                /* quit if at the end */
          return (0);
        else
          p2++;

        if (CheckSpace(p1))
        {
          q = SkipWhite(p1);
          p1 = (*q == 0) ? q : q - 1;
        }

        if (CheckSpace(p2))
        {
          q = MBSTR::SkipWhite(p2);
          p2 = (*q == 0) ? q : q - 1;
        }
      }
      else
        return *p1-*p2;
  }
#endif // FE_SB
}

#ifdef FE_SB

/**************************************************************************/
/* Routine:  CheckSpace                                                   */
/* Arguments: an arbitrary string                                         */
/* Function: Determine whether there is a space in the string.            */
/* Side effects: none                                                     */
/**************************************************************************/
INT
MBSTR::CheckSpace(
    IN  PSTR    s
    )
{
    if (bIsDBCSCodePage) {
        if (isspace(*(BYTE*)s) || (*s == LOBYTE(wDBCSFullSpace) && *(s+1) == HIBYTE(wDBCSFullSpace)))
            return (TRUE);
        else
            return (FALSE);
    }
    else {
        return isspace(*(BYTE*)s);
    }
}

#endif





#if 0
/**************************************************************************/
/*        strcmpi will compare two string lexically and return one of     */
/*  the following:                                                        */
/*    - 0    if the strings are equal                                     */
/*    - 1    if first > the second                                        */
/*    - (-1) if first < the second                                        */
/*                                                                        */
/*      This was written to replace the run time library version of       */
/*  strcmpi which does not correctly compare the european character set.  */
/*  This version relies on a version of toupper which uses IToupper.      */
/**************************************************************************/

int FC::_strcmpi(unsigned char *str1, unsigned char *str2)
{
  unsigned char c1, c2;

#ifdef FE_SB
  IsDBCSCodePage();

  if (bIsDBCSCodePage) {
      while (TRUE)
      {
        c1 = *str1++;
        c2 = *str2++;
        if (c1 == '\0' || c2 == '\0')
            break;
        if (IsDBCSLeadBYTE(c1) && IsDBCSLeadBYTE(c2))
        {
          if (c1 == c2)
          {
              c1 = *str1++;
              c2 = *str2++;
              if (c1 != c2)
                  break;
          }
          else
            break;
        }
        else if (IsDBCSLeadBYTE(c1) || IsDBCSLeadBYTE(c2))
            return (IsDBCSLeadBYTE(c1) ? 1 : -1);
        else
            if ((c1 = toupper(c1)) != (c2 = toupper(c2)))
                break;
      }
      return (c1 == c2 ? 0 : (c1 > c2 ? 1 : -1));
  }
  else {
      while ((c1 = toupper(*str1++)) == (c2 = toupper(*str2++)))
      {
        if (c1 == '\0')
          return (0);
      }

      if (c1 > c2)
        return (1);
      else
        return (-1);
  }
#else
  while ((c1 = toupper(*str1++)) == (c2 = toupper(*str2++)))
  {
    if (c1 == '\0')
      return (0);
  }

  if (c1 > c2)
    return (1);
  else
    return (-1);
#endif // FE_SB
}
#endif // if 0

#ifdef FE_SB
//fix kksuzuka: #930
//Enabling strcmpi disregarding the case of DBCS letters.

ULIB_EXPORT
INT
MBSTR::Stricmp (
    IN  PSTR    p1,
    IN  PSTR    p2
    )
{
  BYTE c1,c2;

    while (TRUE)
    {
        c1 = *p1++;
        c2 = *p2++;

        if (c1=='\0' || c2 == '\0')
            break;

        if (IsDBCSLeadByte(c1) && IsDBCSLeadByte(c2) && c1 == c2)
        {
            if (c1==c2)
            {
                c1 = *p1++;
                c2 = *p2++;
                if (c1 != c2)
                    break;
            }
            else
                break;
        }

        else if (IsDBCSLeadByte(c1) || IsDBCSLeadByte(c2))
            return (IsDBCSLeadByte(c1) ? 1: -1);

        else
            if ((c1 = (char)toupper(c1)) != (c2 = (char)toupper(c2)))
                break;

    }
    return (c1 == c2 ? 0 : (c1 > c2 ? 1: -1));
}

//fix kksuzuka: #926
//Enabling strstr disregarding the case of DBCS letters.
ULIB_EXPORT
PSTR
MBSTR::Strstr (
    IN  PSTR    p1,
    IN  PSTR    p2
    )
{
    DWORD   dLen;
    PSTR    pEnd;

    dLen = Strlen(p2);
    pEnd = p1+ Strlen(p1);

    while ((p1+dLen)<=pEnd) {
        if ( !memcmp(p1,p2,dLen) ) {
            return(p1);
        }
        if ( IsDBCSLeadByte(*p1) ) {
            p1 += 2;
        } else {
            p1++;
        }
    }

    return( NULL );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\mem.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "mem.hxx"


DEFINE_CONSTRUCTOR( MEM, OBJECT );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\object.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    object.cxx

Abstract:

    This module contains the definitions for the non-inline member functions
    for the class OBJECT, the root of the Ulib hierarchy. OBJECT's
    constructor merely initializes it's internal CLASS_DESCRIPTOR to point
    to the static descriptor for the class at the beginning of this
    construction chain.

Author:

    David J. Gilman (davegi) 30-Oct-1990

Environment:

    ULIB, User Mode

[Notes:]

    optional-notes

--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"

OBJECT::OBJECT(
    )
{
}

OBJECT::~OBJECT(
    )
{
}


LONG
OBJECT::Compare (
    IN PCOBJECT Object
    ) CONST

/*++

Routine Description:

    Compare two objects based on their CLASS_ID's

Arguments:
    
    Object - Supplies the object to compare with.

Return Value:

    LONG     < 0    - supplied OBJECT has a higher CLASS_ID
            == 0    - supplied object has same CLASS_ID
             > 0    - supplied OBJECT has a lower CLASS_ID

Notes:

    It is expected that derived classes will overload this method and supply
    an implementation that is more meaningful (i.e. class specific). This
    implementation is ofeered as a default but is fairly meaningless as
    CLASS_IDs are allocated randomly (but uniquely) at run-time by
    CLASS_DESCRIPTORs. Therefore comparing two CLASS_IDs is not very
    interesting (e.g. it will help if an ORDERED_CONTAINER of homogenous
    objects is sorted).

--*/

{
    LONG    r;

    DebugPtrAssert( Object );

    r = (LONG)(QueryClassId() - Object->QueryClassId());

    return r ? r : (LONG)(this - Object);
}


DEFINE_OBJECT_DBG_FUNCTIONS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\pch.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    This module implements pre-compiled headers for ulib.

Author:

    Matthew Bradburn (mattbr)  26-Apr-1994

--*/

#define _ULIB_MEMBER_

//
// Include all ulib headers, except a couple of troublemakers.
//

#include "ulib.hxx"
#include "smsg.hxx"
#include "array.hxx"
#include "basesys.hxx"
#include "bitvect.hxx"
#include "buffer.hxx"
#include "bufstrm.hxx"
#include "bytestrm.hxx"
#include "contain.hxx"
#include "wstring.hxx"
#include "system.hxx"
#include "achkmsg.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "chkmsg.hxx"
#include "comm.hxx"
#include "dir.hxx"
#include "error.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "filter.hxx"
#include "fsnode.hxx"
#include "ifsentry.hxx"
#include "ifsserv.hxx"
#include "iterator.hxx"
#include "keyboard.hxx"
#include "list.hxx"
#include "listit.hxx"
#include "mbstr.hxx"
#include "membmgr.hxx"
#include "membmgr2.hxx"
#include "message.hxx"
#include "newdelp.hxx"
#include "path.hxx"
#include "pipe.hxx"
#include "pipestrm.hxx"
#include "program.hxx"
#include "prtstrm.hxx"
#include "rtmsg.h"
#include "screen.hxx"
#include "seqcnt.hxx"
#include "sortcnt.hxx"
#include "sortlist.hxx"
#include "sortlit.hxx"
#include "stream.hxx"
#include "string.hxx"
#include "stringar.hxx"
#include "substrng.hxx"
#include "ulibcl.hxx"
#include "timeinfo.hxx"
#include "object.hxx"
#include "clasdesc.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\membmgr.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    membmgr.cxx

Author:

    Norbert P. Kusters (norbertk) 29-May-92

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "membmgr.hxx"
#include "iterator.hxx"


DEFINE_CONSTRUCTOR( STATIC_MEM_BLOCK_MGR, OBJECT );


STATIC_MEM_BLOCK_MGR::~STATIC_MEM_BLOCK_MGR(
    )
/*++

Routine Description:

    Destructor for STATIC_MEM_BLOCK_MGR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
STATIC_MEM_BLOCK_MGR::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _heap = NULL;
    _num_blocks = 0;
    _block_size = 0;
    _num_allocated = 0;
    _next_alloc = 0;
}


VOID
STATIC_MEM_BLOCK_MGR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_heap);
    _num_blocks = 0;
    _block_size = 0;
    _num_allocated = 0;
    _next_alloc = 0;
}


BOOLEAN
STATIC_MEM_BLOCK_MGR::Initialize(
    IN  ULONG   MemBlockSize,
    IN  ULONG   NumBlocks
    )
/*++

Routine Description:

    This routine initializes this object to a usable initial state.

Arguments:

    MemBlockSize    - Supplies the number of bytes per mem block.
    NumBlocks       - Supplies the number of mem blocks to be
                        contained by this object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    DebugAssert(MemBlockSize);

    if (!(_heap = (PCHAR) MALLOC(NumBlocks*MemBlockSize)) ||
        !_bitvector.Initialize(NumBlocks)) {

        Destroy();
        return FALSE;
    }

    _num_blocks = NumBlocks;
    _block_size = MemBlockSize;

    return TRUE;
}


PVOID
STATIC_MEM_BLOCK_MGR::Alloc(
    )
/*++

Routine Description:

    This routine allocates a single memory block and returns its
    pointer.

Arguments:

    None.

Return Value:

    A pointer to a mem block.

--*/
{
    if (_num_allocated == _num_blocks) {
        return NULL;
    }

    for (;;) {

        if (!_bitvector.IsBitSet(_next_alloc)) {

            _bitvector.SetBit(_next_alloc);
            _num_allocated++;
            return &_heap[_next_alloc*_block_size];
        }

        _next_alloc = (_next_alloc + 1) % _num_blocks;
    }
}


BOOLEAN
STATIC_MEM_BLOCK_MGR::Free(
    OUT PVOID   MemBlock
    )
/*++

Routine Description:

    This routine frees the given mem block for use by other clients.

Arguments:

    MemBlock    - Supplies a pointer to the mem block to free.

Return Value:

    FALSE   - The mem block was not freed.
    TRUE    - Success.

--*/
{
    ULONG   i;

    if (!MemBlock) {
        return TRUE;
    }

    i = (ULONG)((PCHAR) MemBlock - _heap)/_block_size;
    if (i >= _num_blocks) {
        return FALSE;
    }

    DebugAssert(((PCHAR) MemBlock - _heap)%_block_size == 0);

    _bitvector.ResetBit(i);
    _num_allocated--;
    _next_alloc = i;
    return TRUE;
}


DEFINE_EXPORTED_CONSTRUCTOR( MEM_BLOCK_MGR, OBJECT, ULIB_EXPORT );


VOID
MEM_BLOCK_MGR::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(_static_mem_list, 0, 32*sizeof(PVOID));
}


VOID
MEM_BLOCK_MGR::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;

    for (i = 0; _static_mem_list[i]; i++) {
        DELETE(_static_mem_list[i]);
    }
}


ULIB_EXPORT
MEM_BLOCK_MGR::~MEM_BLOCK_MGR(
    )
/*++

Routine Description:

    Destructor for MEM_BLOCK_MGR.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
MEM_BLOCK_MGR::Initialize(
    IN  ULONG   MemBlockSize,
    IN  ULONG   InitialNumBlocks
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    MemBlockSize        - Specifies the size of the memory blocks to
                            be allocated from this object.
    InitialNumBlocks    - Specifies the initial number of blocks
                            to be allocated by this object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!(_static_mem_list[0] = NEW STATIC_MEM_BLOCK_MGR) ||
        !_static_mem_list[0]->Initialize(MemBlockSize, InitialNumBlocks)) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


ULIB_EXPORT
PVOID
MEM_BLOCK_MGR::Alloc(
    )
/*++

Routine Description:

    This routine allocates a mem blocks and returns its pointer.

Arguments:

    None.

Return Value:

    A pointer to a mem block.

--*/
{
    ULONG   i;
    PVOID   r;

    for (i = 0; _static_mem_list[i]; i++) {
        if (r = _static_mem_list[i]->Alloc()) {
            return r;
        }
    }

    // At this point all of the current buffers are full so
    // start another one.

    if (!(_static_mem_list[i] = NEW STATIC_MEM_BLOCK_MGR) ||
        !_static_mem_list[i]->Initialize(
                _static_mem_list[i - 1]->QueryBlockSize(),
                2*_static_mem_list[i - 1]->QueryNumBlocks())) {

        DELETE(_static_mem_list[i]);
        return NULL;
    }

    return _static_mem_list[i]->Alloc();
}


ULIB_EXPORT
BOOLEAN
MEM_BLOCK_MGR::Free(
    IN OUT  PVOID   MemPtr
    )
/*++

Routine Description:

    This routine frees the given memory block.

Arguments:

    MemPtr  - Supplies a pointer to the buffer to free.

Return Value:

    This function returns TRUE if the memory was successfully
    freed.

--*/
{
    ULONG   i;

    for (i = 0; _static_mem_list[i]; i++) {
        if (_static_mem_list[i]->Free(MemPtr)) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\path.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    path.cxx

Abstract:

    This contains the implementation for all methods handling file
    path names. These are needed for use with an file i/o or the
    FILE and DIR objects.

Author:

    bruce wilson    w-wilson    21-Mar-90
    steve rowe      stever      27-Dec-90

Environment:

    ULIB, user mode

Revision History:

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

extern "C" {
    #include <string.h>
}
#include "ulib.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "system.hxx"

#if DBG==1
    #define PATH_SIGNATURE  0xADDBEEAD
#endif


typedef enum _SPECIAL_DEVICES {
    LPT,
    COM,
    CON,
    PRN,
    AUX,
    LAST_SPECIAL_DEVICE
} SPECIAL_DEVICES;


//
// Static member data.
//

STATIC PWSTRING    _SlashString;
STATIC PWSTRING    _SpecialDevices[ LAST_SPECIAL_DEVICE ];

#define     DELIMITER_STRING    "\\"
#define     DELIMITER_CHAR      ((WCHAR)'\\')


BOOLEAN
PATH::Initialize (
    )

/*++

Routine Description:

    Perform global initialization of the PATH class.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if global initialization was succesful

Notes:

    Global initialization should be interpreted as class (rather than object)
    initialization. This routine should be called by ALL other
    PATH::Initialize member functions.

    Current this routine:

        - constructs and initializes _SlashString, a WSTRING that
          contains a '\'

--*/

{
    STATIC LONG     InitializingPathConstants = 0;
    STATIC BOOLEAN  fInit = FALSE;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };   // 100 ns resolution

    while (InterlockedCompareExchange(&InitializingPathConstants, 1, 0) != 0) {
        NtDelayExecution(FALSE, &timeout);
    }

    if (!fInit) {

        if ( (( _SlashString = NEW DSTRING) != NULL)        &&
             ((_SpecialDevices[LPT] = NEW DSTRING) != NULL) &&
             ((_SpecialDevices[COM] = NEW DSTRING) != NULL) &&
             ((_SpecialDevices[CON] = NEW DSTRING) != NULL) &&
             ((_SpecialDevices[PRN] = NEW DSTRING) != NULL) &&
             ((_SpecialDevices[AUX] = NEW DSTRING) != NULL) &&
             _SlashString->Initialize( DELIMITER_STRING )   &&
             _SpecialDevices[LPT]->Initialize( "LPT" )      &&
             _SpecialDevices[COM]->Initialize( "COM" )      &&
             _SpecialDevices[CON]->Initialize( "CON" )      &&
             _SpecialDevices[PRN]->Initialize( "PRN" )      &&
             _SpecialDevices[AUX]->Initialize( "AUX" )
           ) {

            status = InterlockedDecrement(&InitializingPathConstants);
            DebugAssert(status == 0);
            return fInit = TRUE;

        }
    }

    status = InterlockedDecrement(&InitializingPathConstants);
    DebugAssert(status == 0);
    return fInit;
}

ULIB_EXPORT
BOOLEAN
PATH::EndsWithDelimiter (
    ) CONST

/*++

Routine Description:

    Returns TRUE if the path ends with slash

Arguments:

    None.

Return Value:

    BOOLEAN -   Returns TRUE if the path ends with a slash

--*/
{

    return ( _PathString.QueryChAt( _PathString.QueryChCount() - 1 ) == DELIMITER_CHAR );

}

ULIB_EXPORT
PARRAY
PATH::QueryComponentArray (
    OUT PARRAY  Array
    ) CONST

/*++

Routine Description:

    Obtain an array of strings containing all the components in the path.
    Each string will have an element in the path delimited by '\\'

Arguments:

    Array   -   Supplies an optional pointer to the array to fill.

Return Value:

    Pointer to the array

--*/

{

    CHNUM           Index;
    CHNUM           DelimiterPosition;
    CHNUM           StringSize;
    PWSTRING        Component;

    if (!Array) {
        Array = NEW ARRAY;
    }

    if (Array == NULL) {
        DebugPrint("ULIB: Out of memory\n");
        return NULL;
    }

    DebugAssert( _Initialized == TRUE );

    Array->Initialize();

    Index = 0;
    StringSize = _PathString.QueryChCount();

    while ( ( Index < StringSize) &&
            ( _PathString.QueryChAt( Index ) == DELIMITER_CHAR ) ) {
        Index++;
    }

    while ( Index < StringSize ) {

        DelimiterPosition = _PathString.Strchr( DELIMITER_CHAR, Index );

        Component = _PathString.QueryString( Index,
            (DelimiterPosition == INVALID_CHNUM) ? TO_END : DelimiterPosition - Index );

        DebugPtrAssert( Component );

        if ( !Component ) {
            break;
        }

        Array->Put( Component );

        if ( DelimiterPosition == INVALID_CHNUM ) {
            Index = StringSize;
        } else {
            Index = DelimiterPosition + 1;
        }
    }

    return Array;
}

CHNUM
PATH::QueryDeviceLen(
    IN  PWSTRING pString
    ) CONST

/*++

Routine Description:

    Find length in character of drive section

Arguments:

    pString - Supplies the string to determine drive size.

Return Value:

    CHNUM - Number of characters making up drive section. If no
            drive section then the length is 0.

--*/
{
    CHNUM           Position = 0;
    CHNUM           Position1;
    SPECIAL_DEVICES Index;
    ULONG           tmp;
    INT             Pos;
    LONG            Number;


    UNREFERENCED_PARAMETER( (void)this );

    DebugPtrAssert( pString );

    if ( pString->QueryChCount() > 0 ) {

        //
        //  Check for special device
        //
        Pos = (INT)pString->QueryChCount() - 1;

        while ( (Pos >= 0) && (pString->QueryChAt( (CHNUM)Pos ) != DELIMITER_CHAR) ) {
            Pos --;
        }

        Pos++;

        for (Index = LPT; Index < LAST_SPECIAL_DEVICE;
             (tmp = (ULONG) Index, tmp++, Index = (SPECIAL_DEVICES) tmp) ) {

            if ( !pString->Stricmp( _SpecialDevices[Index],
                                    (CHNUM)Pos ) ) {

                Position = (CHNUM)Pos + _SpecialDevices[Index]->QueryChCount();

                //
                //  LPT && COM must be followed by a number;
                //
                if ( (Index == LPT) || (Index == COM) ) {
                    if ( Position >= pString->QueryChCount()) {
                        continue;
                    }
                    while ( (Position < pString->QueryChCount()) &&
                            pString->QueryNumber( &Number, Position, 1 ) ) {

                        Position++;
                    }
                }

                if (Position >= pString->QueryChCount()) {
                     return Position;
                } else if (pString->QueryChAt( Position ) == (WCHAR)':') {
                    return Position+1;
                }
            }
        }
        //
        //  Look for ':'
        //
        if ((Position = pString->Strchr((WCHAR)':')) != INVALID_CHNUM) {
            return Position + 1;
        }

        //
        // check for leading "\\"
        //
        if  ( pString->QueryChCount() > 1           &&
              pString->QueryChAt(0) == DELIMITER_CHAR &&
              pString->QueryChAt(1) == DELIMITER_CHAR) {

            //
            // the device is a machine name - find the second backslash
            // (start search after first double backsl). Note that this
            //  means that the device names if formed by the machine name
            //  and the sharepoint.
            //
            if ( ((Position  = pString->Strchr( DELIMITER_CHAR, 2 )) != INVALID_CHNUM )) {

                 Position1 = pString->Strchr( DELIMITER_CHAR, Position+1 );
                 if ( Position1 == INVALID_CHNUM ) {
                    return pString->QueryChCount();
                 }
                 return Position1;

            }

            //
            //  No backslash found, this is an invalid device
            //
            DebugAbort( "Invalid Device name" );

        }


    }

    return 0;
}

VOID
PATH::SetPathState(
    )

/*++

Routine Description:

    Sets the state information for the Path

Arguments:

    None.

Return Value:

    None.

--*/

{

    CHNUM chnLastSlash;
    CHNUM chnLastDot;
    CHNUM chnAcum;
    CHNUM FirstSeparator;

    //
    // Find the number of characters in the device name
    //
    chnAcum = _PathState.DeviceLen = QueryDeviceLen( &_PathString );

    //
    // Find the number of characters in the dirs portion of the path
    // by searching for the last '\'
    //
    if ( _PathString.QueryChAt( chnAcum ) == DELIMITER_CHAR ) {
        //
        //  Skip over the slash after the device name
        //
        FirstSeparator = 1;
        chnAcum++;

    } else {

        FirstSeparator = 0;
    }

    if ( chnAcum < _PathString.QueryChCount() ) {

        if (( chnLastSlash = _PathString.Strrchr( DELIMITER_CHAR, chnAcum )) != INVALID_CHNUM ) {

            //
            //  The dirs length is that character position less the length
            //  of the device
            //
            _PathState.DirsLen = chnLastSlash - _PathState.DeviceLen;
            _PathState.SeparatorLen = 1;

            chnAcum += _PathState.DirsLen;
            if ( FirstSeparator ==  0 ) {
                chnAcum++;
            }
        } else {
            //
            // There is no dirs portion of this path, but there is a name.
            //
            _PathState.DirsLen      = FirstSeparator;
            _PathState.SeparatorLen = 0;

        }
    } else {

        //
        //  There is no name portion in this path, and the dirs portion
        //  might be empty (or consist solely of the delimiter ).
        //
        _PathState.DirsLen      = FirstSeparator;
        _PathState.SeparatorLen = 0;
    }

    if ( chnAcum < _PathString.QueryChCount() ) {

        //
        // Find the number of characters in the name portion of the path
        // by searching for the last '.'
        //
        if (( chnLastDot = _PathString.Strrchr( ( WCHAR )'.',
                                                chnAcum )) != INVALID_CHNUM ) {

            _PathState.BaseLen = chnLastDot - chnAcum;

            chnAcum += _PathState.BaseLen + 1;

            _PathState.ExtLen   = _PathString.QueryChCount() - chnAcum;

            _PathState.NameLen  = _PathState.BaseLen + _PathState.ExtLen + 1;


        } else {

            //
            // There is no last '.' so the name length is the length of the
            // component from the last '\' to the end of the path (adjusted
            // for zero base) and there is no extension.
            //

            _PathState.NameLen = _PathString.QueryChCount() - chnAcum;
            _PathState.BaseLen = _PathState.NameLen;
            _PathState.ExtLen  = 0;

        }
    } else {

        //
        //  There is no name part
        //
        _PathState.NameLen = 0;
        _PathState.BaseLen = 0;
        _PathState.ExtLen  = 0;

    }


    //
    // The prefix length is the sum of the device and dirs
    //
    _PathState.PrefixLen = _PathState.DeviceLen + _PathState.DirsLen;

    //
    //  If The device refers to a drive, uppercase it. (Done for
    //  compatibility with some DOS apps ).
    //
    if ( _PathState.DeviceLen == 2 ) {
        _PathString.Strupr( 0,  1 );
    }

}

DEFINE_EXPORTED_CONSTRUCTOR( PATH, OBJECT, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( PATH );

VOID
PATH::Construct (
    )

{
    _PathState.BaseLen  = 0;
    _PathState.DeviceLen= 0;
    _PathState.DirsLen  = 0;
    _PathState.ExtLen   = 0;
    _PathState.NameLen  = 0;
    _PathState.PrefixLen= 0;

    _PathBuffer[0] = 0;
    _PathString.Initialize(_PathBuffer, MAX_PATH);

#if DBG==1
    _Signature  =   PATH_SIGNATURE;
#endif

}

ULIB_EXPORT
BOOLEAN
PATH::Initialize(
    IN PCWSTR   InitialPath,
    IN BOOLEAN  Canonicalize
    )

/*++

Routine Description:

    Initialize a PATH object with the supplied string.  No validation
    on the given path is performed unless 'Canonicalize' is set to TRUE.

Arguments:

    InitialPath - Supplies a zero terminated string
    Canonicalize- Supplies a flag, which if TRUE indicates that the PATH
        should be canoicalized at initialization time (i.e. now)

Return Value:

    BOOLEAN - Returns TRUE if the PATH was succesfully initialized.

--*/

{
    PWSTR       filepart;
    DWORD       CharsInPath;


    DebugPtrAssert( InitialPath );

    //
    // Perform global (class) initialization
    //
    if (!Initialize()) {
        DebugAbort( "Class initialization failed" );
        return FALSE;
    }

    // Avoid copies during Strcat by making this a reasonable size.
    if (!_PathString.NewBuf(MAX_PATH - 1)) {
        return FALSE;
    }

    if ( Canonicalize ) {

        if (!_PathString.NewBuf(MAX_PATH - 1) ||
            !(CharsInPath = GetFullPathName((LPWSTR) InitialPath,
                                            MAX_PATH,
                                            (LPWSTR) _PathString.GetWSTR(),
                                            &filepart)) ||
            CharsInPath > MAX_PATH) {

            return FALSE;
        }

        _PathString.SyncLength();

        SetPathState( );
#if DBG==1
        _Initialized = TRUE;
#endif
        return TRUE;

    } else if( ((PWSTRING) &_PathString)->Initialize( InitialPath )) {

        SetPathState( );
#if DBG==1
        _Initialized = TRUE;
#endif
        return TRUE;
    }

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
PATH::Initialize(
    IN PCWSTRING    InitialPath,
    IN BOOLEAN      Canonicalize

    )
{
    DebugPtrAssert( InitialPath );

    return Initialize( InitialPath->GetWSTR(), Canonicalize );
}

ULIB_EXPORT
BOOLEAN
PATH::Initialize (
    IN PCPATH       InitialPath,
    IN BOOLEAN      Canonicalize
    )

{
    DebugPtrAssert( InitialPath );

    return Initialize( InitialPath->GetPathString()->GetWSTR(), Canonicalize );
}

ULIB_EXPORT
PATH::~PATH (
    )

{
}

ULIB_EXPORT
BOOLEAN
PATH::AppendBase (
    IN PCWSTRING Base,
    IN BOOLEAN          Absolute
    )

/*++

Routine Description:

    Append the supplied name to the end of this PATH.

Arguments:

    Base        - Supplies the string to be appended.
    Absolute    - Supplies a flag which if TRUE means that the path must
                  be absolute.

Return Value:

    BOOLEAN - Returns TRUE if the '\' and the supplied string was succesfully
        appended.

--*/

{
    BOOLEAN     AppendedSlash = FALSE;

    DebugPtrAssert( Base );
    DebugAssert( _Initialized );

    //
    //  If the path does not consist of only a drive letter followed by a
    //  colon, we might need to add a '\'
    //
    if ( _PathString.QueryChCount() > 0 ) {
        if ( !(( _PathState.DeviceLen == _PathString.QueryChCount()) &&
              ( _PathString.QueryChAt( _PathState.DeviceLen - 1) == (WCHAR)':')) ||
              Absolute ) {


            if ( _PathString.QueryChAt( _PathString.QueryChCount() - 1 ) != (WCHAR)'\\' ) {

                if ( !_PathString.Strcat( _SlashString )) {
                    return FALSE;
                }

                AppendedSlash = TRUE;
            }
        }
    }

    //
    //  Append the base
    //
    if ( _PathString.Strcat( Base )) {
        SetPathState();
        return TRUE;
    }

    //
    //  Could not append base, remove the slash if we appended it
    //
    if ( AppendedSlash ) {
        TruncateBase();
    }

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
PATH::HasWildCard (
    ) CONST

/*++

Routine Description:

    Determines if the name portion of the path contains wild cards

Arguments:

    None.

Return Value:

    TRUE if the name portion of the path has wild cards
    FALSE otherwise

--*/

{

    FSTRING WildCards;

    DebugAssert( _Initialized );

    if ( _PathString.QueryChCount() > 0 ) {

        WildCards.Initialize( (PWSTR) L"*?" );

        if (_PathString.Strcspn( &WildCards, _PathState.PrefixLen ) != INVALID_CHNUM ) {
            return TRUE;
        }
    }

    return FALSE;

}

ULIB_EXPORT
BOOLEAN
PATH::IsDrive(
    ) CONST

/*++

Routine Description:

    Returns TRUE if the path refers to a device name

Arguments:

    None.

Return Value:

    BOOLEAN -   TRUE if the path is a device name.
                FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    return ( _PathState.DeviceLen > 0 ) &&
           ( (_PathString.QueryChCount() == _PathState.DeviceLen) );

}

BOOLEAN
PATH::IsRoot(
    ) CONST

/*++

Routine Description:

    Returns TRUE if the path refers to a root directory

Arguments:

    None.

Return Value:

    BOOLEAN -   TRUE if the path is a root directory.
                FALSE otherwise.

--*/

{
    DebugAssert( _Initialized );

    return( ( (_PathString.QueryChCount() == 1 ) &&
          (_PathString.QueryChAt( 0 ) == DELIMITER_CHAR ) ) ||
        ( ( _PathState.DeviceLen > 0 ) &&
          ( _PathString.QueryChCount() == _PathState.DeviceLen + 1 ) &&
          ( _PathString.QueryChAt( _PathState.DeviceLen ) == DELIMITER_CHAR ) )
          );
}

ULIB_EXPORT
PPATH
PATH::QueryFullPath(
    ) CONST

/*++

Routine Description:

Arguments:

    None.

Return Value:

    PPATH

--*/

{


    REGISTER PPATH      pFullPath;
    REGISTER PWSTRING   pFullPathString;

    DebugAssert( _Initialized );

    //
    // If the full path name string for this PATH can not be queried
    // or a new PATH, representing the full path, can not be constructed
    // return NULL.
    //

    if ((( pFullPathString = QueryFullPathString( )) == NULL )  ||
        (( pFullPath = NEW PATH ) == NULL )) {

        return NULL;
    }

    //
    // If the new, full path, can not be initialized, delete it.
    //

    if( ! ( pFullPath->Initialize( pFullPathString ))) {

        DELETE( pFullPath );
    }

    //
    // Delete the full path string and return a pointer to the new, full path
    // (note that the pointer may be NULL).
    //

    DELETE( pFullPathString );

    return pFullPath ;
}

ULIB_EXPORT
PWSTRING
PATH::QueryFullPathString (
    ) CONST
{

    LPWSTR      pszName;

    PWSTRING    pwcFullPathString;
    WSTR         szBufferSrc[ MAX_PATH ];
    WSTR         szBufferTrg[ MAX_PATH ];

    DebugAssert( _Initialized );

    if( (pwcFullPathString = NEW DSTRING ()) != NULL ) {

        if ( _PathString.QueryWSTR( 0, TO_END, szBufferSrc, MAX_PATH ) ) {

            if (GetFullPathName( szBufferSrc,MAX_PATH,szBufferTrg,&pszName)) {

                if (pwcFullPathString->Initialize(szBufferTrg)) {

                    return pwcFullPathString;

                }
            }
        }
    }

    DELETE( pwcFullPathString );

    return NULL;

}

ULIB_EXPORT
BOOLEAN
PATH::SetDevice (
    IN PCWSTRING NewDevice
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewDevice );

    if (_PathState.DeviceLen) {
        if (!_PathString.Replace(QueryDeviceStart(), _PathState.DeviceLen,
                                 NewDevice)) {

            return FALSE;
        }
    } else {
        if (!_PathString.Strcat(NewDevice)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

BOOLEAN
PATH::SetPrefix (
    IN PCWSTRING NewPrefix
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewPrefix );

    if (_PathState.PrefixLen) {

        if (!_PathString.Replace(QueryPrefixStart(), _PathState.PrefixLen,
                                 NewPrefix)) {

            return FALSE;
        }

    } else {

        if (!_PathString.Strcat(NewPrefix)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
PATH::SetName (
    IN PCWSTRING NewName
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewName );

    if (_PathState.NameLen) {

        if (!_PathString.Replace(QueryNameStart(), _PathState.NameLen,
                                 NewName)) {

            return FALSE;
        }

    } else {

        if (!_PathString.Strcat(NewName)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

BOOLEAN
PATH::SetBase (
    IN PCWSTRING NewBase
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewBase );

    if (_PathState.BaseLen) {

        if (!_PathString.Replace(QueryBaseStart(), _PathState.BaseLen,
                                 NewBase)) {

            return FALSE;
        }

    } else {

        if (!_PathString.Strcat(NewBase)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

BOOLEAN
PATH::SetExt (
    IN PCWSTRING NewExt
    )
{
    DebugAssert( _Initialized );
    DebugPtrAssert( NewExt );

    if (_PathState.ExtLen) {

        if (!_PathString.Replace(QueryExtStart(), _PathState.ExtLen,
                                 NewExt)) {

            return FALSE;
        }

    } else {

        if (!_PathString.Strcat(NewExt)) {
            return FALSE;
        }
    }

    SetPathState();

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
PATH::TruncateBase (
    )

/*++

Routine Description:

    This routine truncates the path after the prefix portion.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if the base existed and was succesfully removed.

--*/

{
    DebugAssert( _Initialized );

    // If this is the root then the prefix len will include the \.
    // If not, then it won't.  Either way.  Truncate this string to
    // the prefix length.

    _PathString.Truncate( _PathState.PrefixLen );

    SetPathState();

    return TRUE;
}



ULIB_EXPORT
PPATH
PATH::QueryPath(
    ) CONST

/*++

Routine Description:

Arguments:

    None.

Return Value:

    PPATH

--*/

{


    REGISTER PPATH      pPath;

    DebugAssert( _Initialized );

    if (( pPath = NEW PATH ) == NULL ) {
        return NULL;
    }

    //
    // If the new path can not be initialized, delete it.
    //
    if( ! ( pPath->Initialize( GetPathString()->GetWSTR(), FALSE ))) {

        DELETE( pPath );
    }

    return pPath ;
}

ULIB_EXPORT
PPATH
PATH::QueryWCExpansion(
    IN  PPATH   BasePath
    )
/*++

Routine Description:

    Expands any wildcards in path to match the equivalent characters in
    the base path.

Arguments:

    PCPATH BasePath - The base path from which the equivalent characters are
                    retrieved.

Return Value:

    Pointer to the generated path.


--*/
{
    PPATH               pGeneratedPath;
    PWSTRING            pBasePathStr;
    PWSTRING            pGeneratedPathStr;
    PWSTRING pTmp;
    FSTRING             fstring;
    DSTRING             new_string;

    //
    // Initialize the path to be generated with the current path (this)
    //
    pGeneratedPath = NEW PATH;
    if( pGeneratedPath == NULL ) {
        DebugAbort( "Failed to create a new path.\n" );
        return( NULL );
    }

    // Does the Base have '*' while the ext is not there?  If so then
    // make the extension '*'.

    if (_PathState.ExtLen == 0 &&
        _PathString.Strchr('*', _PathState.PrefixLen) != INVALID_CHNUM &&
        _PathString.QueryChAt(_PathString.QueryChCount() - 1) != '.') {

        if (!new_string.Initialize(GetPathString()) ||
            !new_string.Strcat(fstring.Initialize((PWSTR) L".*")) ||
            !pGeneratedPath->Initialize(&new_string)) {

            return NULL;
        }
    } else {
        if (!pGeneratedPath->Initialize(GetPathString())) {
            return NULL;
        }
    }

    if( ( pTmp = pGeneratedPath->QueryBase() ) != NULL ) {
        pGeneratedPathStr = pTmp->QueryString();
        DebugPtrAssert( pGeneratedPathStr );
        DELETE( pTmp );

        //
        // If the base path doesn't have a findable base, return an error...
        // (filenames must have a base - in Dos anyways...)
        //
        if( ( pTmp = BasePath->QueryBase() ) == NULL ) {
            DELETE( pGeneratedPathStr );
            DELETE( pGeneratedPath );
            return( NULL );
        }
        pBasePathStr = pTmp->QueryString();
        DebugPtrAssert( pBasePathStr );
        DELETE( pTmp );

        if( !ExpandWildCards( pBasePathStr, pGeneratedPathStr ) ) {
            DELETE( pBasePathStr );
            DELETE( pGeneratedPathStr );
            DELETE( pGeneratedPath );
            return( NULL );
        }
        pGeneratedPath->SetBase( pGeneratedPathStr );
        DELETE( pBasePathStr );
        DELETE( pGeneratedPathStr );
    }

    if( ( pTmp = pGeneratedPath->QueryExt() ) != NULL ) {
        pGeneratedPathStr = pTmp->QueryString();
        DebugPtrAssert( pGeneratedPathStr );

        DELETE( pTmp );

        //
        // If no extension is found, create an empty string to pass to
        // the wildcard expansion routine - this is to allow 'tmp.*' to
        // match 'tmp.'...
        //
        if( ( pTmp = BasePath->QueryExt() ) == NULL ) {
            pBasePathStr = NEW DSTRING;
            pBasePathStr->Initialize();
        } else {
            pBasePathStr = pTmp->QueryString();
            DebugPtrAssert( pBasePathStr );
            DELETE( pTmp );
        }

        if( !ExpandWildCards( pBasePathStr, pGeneratedPathStr ) ) {
            DELETE( pBasePathStr );
            DELETE( pGeneratedPathStr );
            DELETE( pGeneratedPath );
            return( NULL );
        }
        pGeneratedPath->SetExt( pGeneratedPathStr );
        DELETE( pBasePathStr );
        DELETE( pGeneratedPathStr );
    }
    return( pGeneratedPath );
}

BOOLEAN
PATH::ExpandWildCards(
    IN  OUT PWSTRING    pStr1,
    IN  OUT PWSTRING    pStr2
    )
/*++

Routine Description:

    Expands any wildcards in string 2 to match the equivalent characters in
    string 1.  Used by QueryWildCardExpansion().

Arguments:

    Str1    - A pointer to the 'base' string
    Str2    - A pointer to the string to be expanded

Return Value:

    TRUE if expansion was successful.

--*/
{
    CHNUM       idx;


    UNREFERENCED_PARAMETER( (void)this);

    // Deal with the * wild card first...
    //
    // Note: This method will ignore, even remove, any characters after the
    //       '*' in string 2.  This is to comform with the behavior of Dos...
    //
    if( ( idx = pStr2->Strchr( '*' ) ) != INVALID_CHNUM ) {
        if( idx > pStr1->QueryChCount() ) {
            return( FALSE );
        }
        if( idx == pStr1->QueryChCount() ) {
            pStr2->Truncate( idx );
        } else {
            pStr2->Replace( idx, TO_END, pStr1, idx, TO_END );
        }
    }

    // Now convert any '?' in the base
    while( ( idx = pStr2->Strchr( '?' ) ) != INVALID_CHNUM ) {
        // Make sure that the wild card is within the limits of the
        // base string...
        if( idx >= pStr1->QueryChCount() ) {
            return( FALSE );
        }
        pStr2->SetChAt( pStr1->QueryChAt( idx ), idx );
    }
    return( TRUE );
}

ULIB_EXPORT
BOOLEAN
PATH::ModifyName (
    IN  PCWSTRING Pattern
    )

/*++

Routine Description:

    Modifies the file name of the path according to a pattern. The pattern
    may contain wildcards.

Arguments:

    Pattern     -   Supplies pointer to string with the pattern

Return Value:

    none

--*/

{
    PATH        PatternPath;
    PPATH       TargetPath;
    PWSTRING    NewName;


    // If the pattern is trivial then just bail out since there's
    // nothing to change.

    if (Pattern->QueryChCount() == 1 &&
        Pattern->QueryChAt(0) == '*') {

        return TRUE;
    }

    if (Pattern->QueryChCount() == 3 &&
        Pattern->QueryChAt(0) == '*' &&
        Pattern->QueryChAt(1) == '.' &&
        Pattern->QueryChAt(2) == '*') {

        return TRUE;
    }

    if (!PatternPath.Initialize(Pattern)) {
        return FALSE;
    }

    TargetPath = PatternPath.QueryWCExpansion(this);
    if (!TargetPath) {
        return FALSE;
    }

    NewName = TargetPath->QueryName();

    DELETE(TargetPath);

    if (!NewName) {
        return FALSE;
    }

    TruncateBase();
    AppendBase( NewName );

    DELETE( NewName );

    return TRUE;
}

ULIB_EXPORT
VOID
PATH::TruncateNameAtColon (
    )

/*++

Routine Description:

    This is an awful hack to keep XCopy compatibility.

    If the last segment of the path contains a colon, we truncate the
    path at that point.

Arguments:

    none

Return Value:

    none

--*/

{

    CHNUM   IndexColon;
    CHNUM   IndexDelimiter;


    IndexColon     = _PathString.Strrchr( (WCHAR)':', 0 );

    if ( IndexColon != INVALID_CHNUM ) {

        IndexDelimiter = _PathString.Strrchr( DELIMITER_CHAR, 0 );

        if ( ( IndexDelimiter == INVALID_CHNUM ) ||
             ( IndexColon > IndexDelimiter ) ) {

            if (IndexColon > 1) {

                //
                //  Truncate the path
                //
                _PathString.Truncate( IndexColon );
                SetPathState();
            }
        }
    }
}




ULIB_EXPORT
PWSTRING
PATH::QueryRoot (
    )

/*++

Routine Description:

    Returns a string that contains the canonicalized name of the root
    directory (device name followed by "\").

    QueryRoot returns NULL if there is no device component part of
    this path.  In other words it may be necessary to canonicalize
    the path before having access to the Root.

Arguments:

    none

Return Value:

    Pointer to a WSTRING that contains the root directory in its
    canonicalized form.

--*/

{
    PWSTRING    Root;

    if( _PathState.DeviceLen == 0 ) {
        return( NULL );
    }
    Root = NEW( DSTRING );

    if (Root == NULL) {
        DebugPrint("ULIB: Out of memory\n");
        return NULL;
    }

    if( !Root->Initialize( &_PathString, 0, _PathState.DeviceLen ) ) {
        DELETE( Root );
        return( NULL );
    }

    Root->Strcat( _SlashString );
    return( Root );
}

ULIB_EXPORT
VOID
PATH::TruncateDelimiter (
        )
/*++

Routine Description:

    This routine truncates a delimiter character from the end
    of the path and recomputes the state of the path.

Arguments:

    none

Return Value:

    none

--*/
{
    if (EndsWithDelimiter()) {
        _PathString.DeleteChAt(_PathString.QueryChCount()-1);
        SetPathState();
    }
}


ULIB_EXPORT
BOOLEAN
PATH::AppendDelimiter (
        )
/*++

Routine Description:

    This routine adds a delimiter character to the end of the
    path and recomputes the state of the path.

Arguments:

    none

Return Value:

    TRUE    - success
    FALSE   - failure

--*/
{
    if (!_PathString.Strcat(_SlashString)) {
        return FALSE;
    }
    SetPathState();
    return TRUE;
}


ULIB_EXPORT
BOOLEAN
PATH::AppendString (
    IN PCWSTRING    String
        )
/*++

Routine Description:

    This routine adds a string to the existing path and
    recompute the state of the path.

Arguments:

    String  - Supplies the string to be appended to the end
              of the path.

Return Value:

    TRUE    - success
    FALSE   - failure

--*/
{
    if (!_PathString.Strcat(String)) {
        return FALSE;
    }
    SetPathState();
    return TRUE;
}


ULIB_EXPORT
BOOLEAN
PATH::IsGuidVolName(
    )
/*++

Routine Description:

    This routine checks to see if the given path is a guid volume name.

Arguments:

    none

Return Value:

    TRUE if the path starts with a guid volume name.

--*/
{
    DSTRING     guid_vol_name_header;

    if (_PathState.DeviceLen == 0)
        return FALSE;

    if (!guid_vol_name_header.Initialize(DOS_GUIDNAME_PREFIX GUID_VOLNAME_PREFIX)) {
        DebugPrint("Out of memory.\n");
        return FALSE;
    }

    return _PathString.Stricmp(&guid_vol_name_header,
                               0,
                               guid_vol_name_header.QueryChCount()) == 0;
}

ULIB_EXPORT
PPATH
PATH::QueryMountPointPath(
    )
/*++

Routine Description:

    This routine substitute the guid volume name with a mount point name.

Arguments:

    none

Return Value:

    Returns a mount point path which is the equivalent of the guid volume
    name path.
    Returns NULL if path already has a drive letter, or non-guid path, or
    no mount point path.

--*/
{
#if !defined(RUN_ON_NT4)
    PWSTRING    vol_name;
    FSTRING     mount_point;
    WCHAR       vol_mount_point[MAX_PATH];
    PPATH       p;
    WCHAR       c, name[5];

    //
    // no need to translate if already a path
    //
    if (!IsGuidVolName() ||
        (GetPathString()->QueryChAt(1) == (WCHAR)':'))
        return NULL;

    vol_name = QueryDevice();

    if (vol_name == NULL)
        return NULL;

    vol_name->Strcat(_SlashString);

    name[1] = ':';
    name[2] = '\\';
    name[3] = 0;

    for (c='A'; c <= 'Z'; c++) {
        name[0] = c;
        if (!GetVolumeNameForVolumeMountPoint(name, vol_mount_point, MAX_PATH))
            continue;
        if (_wcsicmp(vol_mount_point, vol_name->GetWSTR()) == 0) {
            name[2] = 0;    // no backslash
            p = NEW PATH;
            if (!p ||
                !vol_name->Initialize(name) ||
                !p->Initialize(this) ||
                !p->SetDevice(vol_name)) {
                DELETE(vol_name);
                DELETE(p);
                return NULL;
            }
            DELETE(vol_name);
            return p;
        }
    }

    for (c='A'; c <= 'Z'; c++) {
        name[0] = c;
        if (BuildMountPoint(name, vol_name->GetWSTR(), vol_mount_point)) {
            p = NEW PATH;
            if (!p ||
                !vol_name->Initialize(vol_mount_point) ||
                !p->Initialize(this) ||
                !p->SetDevice(vol_name)) {
                DELETE(vol_name);
                DELETE(p);
                return NULL;
            }
            DELETE(vol_name);
            return p;
        }
    }
    DELETE(vol_name);
    return NULL;
#else
    return NULL;
#endif
}

ULIB_EXPORT
PWSTRING
PATH::QueryGuidString(
        OUT PWSTRING    LongestMountPointPath,
        OUT PBOOLEAN    IsLongestMountPointADriveLetter,
        OUT PWSTRING    DrivePath
    )
/*++

Routine Description:

    This routine translates the longest valid mount point path into a guid volume
    name.  If the given path starts with a guid volume name, NULL will be returned.
    If it is just a root drive, null will be returned.

Arguments:

    LongestMountPointPath   - gets the longest valid mount point path or the
                              given guid volume name.
    DrivePath               - gets the mount point path that is not part of
                              the mount point.

Return Value:

    Returns a mount point path which is the equivalent of the guid volume name path.

--*/
{
#if !defined(RUN_ON_NT4)
    PATH        vol_name;
    WCHAR       vol_mount_point[MAX_PATH];
    PWSTRING    s;
    FSTRING     null_string;
    PWSTRING    name;
    BOOLEAN     found = FALSE;
    BOOLEAN     has_delimiter;

    if (IsGuidVolName()) {
        return NULL;
    }

    has_delimiter = EndsWithDelimiter();

    s = QueryFullPathString();

    if (!s ||
        !vol_name.Initialize(s) ||
        !null_string.Initialize(L"") ||
        !DrivePath->Initialize(&null_string)) {
        DebugPrint("Out of memory.\n");
        DELETE(s);
        return NULL;
    }

    DELETE(s);

    if (!vol_name.EndsWithDelimiter()) {
        if (!vol_name.AppendDelimiter()) {
            DebugPrint("Out of memory.\n");
            return NULL;
        }
    }

    *IsLongestMountPointADriveLetter = FALSE;

    while (!vol_name.IsDrive()) {
        if (GetVolumeNameForVolumeMountPoint(vol_name.GetPathString()->GetWSTR(),
                                             vol_mount_point,
                                             MAX_PATH)) {
            vol_name.TruncateDelimiter();
            if (vol_name.IsDrive()) {
                *IsLongestMountPointADriveLetter = TRUE;
            }
            if (!LongestMountPointPath->Initialize(vol_name.GetPathString()))
                return NULL;
            found = TRUE;
            break;
        }
        vol_name.TruncateDelimiter();   // remove backslash

        if (vol_name.IsDrive())
            break;

        name = vol_name.QueryName();
        if (name == NULL ||
            !DrivePath->InsertString(0, name) ||
            !DrivePath->InsertString(0, _SlashString)) {
            DebugPrint("Internal Error\n");
            DELETE(name);
            return NULL;
        }

        DELETE(name);

        if (!vol_name.SetName(&null_string)) {
            DebugPrint("SetName failed\n");
            return NULL;
        }
    }

    if (!found) {
        return NULL;
    }

    // remove backslash
    if (has_delimiter) {
        if (!DrivePath->Strcat(_SlashString)) {
            DebugPrint("Out of memory.\n");
            return NULL;
        }
    }

    vol_mount_point[wcslen(vol_mount_point)-1] = 0;

    s = NEW DSTRING;

    if (!s || !s->Initialize(vol_mount_point)) {
        DELETE(s);
        return NULL;
    }

    return s;
#else
    return NULL;
#endif
}


BOOLEAN
PATH::BuildMountPoint(
    IN     PWSTR        Name,
    IN     PCWSTR       GuidNameToMatch,
       OUT PWSTR        MountPointPath
    )
{
#if !defined(RUN_ON_NT4)
    WCHAR       vol_name[MAX_PATH];
    WCHAR       vol_mount_point[MAX_PATH];
    WCHAR       mount_point_path[MAX_PATH];
    HANDLE      h;
    DWORD       oldErrorMode;

    if (!GetVolumeNameForVolumeMountPoint(Name, vol_name, MAX_PATH))
        return FALSE;

    if (_wcsicmp(vol_name, GuidNameToMatch) == 0) {
        wcscpy(MountPointPath, Name);
        MountPointPath[wcslen(MountPointPath)-1] = 0;   // no backslash
        return TRUE;
    }

    oldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    h = FindFirstVolumeMountPoint(vol_name, vol_mount_point, MAX_PATH);
    SetErrorMode(oldErrorMode);

    if (h == INVALID_HANDLE_VALUE)
        return FALSE;

    for (;;) {
        if (wcslen(Name) + wcslen(vol_mount_point) >= MAX_PATH) {
            FindVolumeMountPointClose(h);
            return FALSE;
        }

        wcscpy(mount_point_path, Name);
        wcscat(mount_point_path, vol_mount_point);

        if (BuildMountPoint(mount_point_path, GuidNameToMatch, MountPointPath)) {
            FindVolumeMountPointClose(h);
            return TRUE;
        }

        if (!FindNextVolumeMountPoint(h, vol_mount_point, MAX_PATH))
            break;
    }

    FindVolumeMountPointClose(h);

    return FALSE;
#else
    return FALSE;
#endif
}


PATH_ANALYZE_CODE
PATH::AnalyzePath(
       OUT PWSTRING     VolumeName,
       OUT PPATH        VolumePath,
       OUT PWSTRING     RemainingPath
    )
/*++

Routine Description:

    This routine translates the given path into three components.  The first component
    is the ultimate guid volume name.  The second component is the volume path.  It
    can either be a drive letter or a mount point path corresponding to the volume name.
    The third component is the remaining path starting from the ultimate volume.

Arguments:

    VolumeName    - Receives the ultimate guid volume name that the path is pointing to.
                    If the return code is PATH_COULD_BE_FLOPPY, then this variable gets
                    the floppy drive letter.
    VolumePath    - Receives the corresponding drive letter or mount point path to the
                    ultimate guid volume name
    RemainingPath - Receives the path starting from the ultimate guid volume name

Return Value:

    Returns the following status:
        PATH_COULD_BE_FLOPPY
        PATH_OUT_OF_MEMORY
        PATH_INVALID_DRIVE_SPEC
        PATH_OK
--*/
{
#if !defined(RUN_ON_NT4)
    DSTRING     volume_path;
    BOOLEAN     is_volume_path_a_drive;
    PPATH       ppath, qpath;
    PWSTRING    p;

    if (!VolumeName->Initialize() ||
        !VolumePath->Initialize(VolumeName) ||
        !RemainingPath->Initialize()) {
        return PATH_OUT_OF_MEMORY;
    }

    if (IsGuidVolName()) {
        if (!IsDrive()) {
            // there is something besides the guid volume name
            // translate the guid name path to a mount point path
            if (!(ppath = QueryMountPointPath())) {
                // If this guid volume path does not translate into a
                // mount point path, the user must be specifying a
                // directory/file path of a drive letterless drive

                // we don't support that for now

                return PATH_NO_MOUNT_POINT_FOR_VOLUME_NAME_PATH;

            } else {
                // see if the mount point path has other mount points in it
                p = ppath->QueryGuidString(&volume_path,
                                           &is_volume_path_a_drive,
                                           RemainingPath);
                DebugAssert(p != NULL);
                if (!p ||
                    !ppath->Initialize(p)) {
                    DebugPrint("Out of memory.\n");
                    DELETE(p);
                    DELETE(ppath);
                    return PATH_OUT_OF_MEMORY;
                }

                qpath = ppath->QueryMountPointPath();

                DELETE(ppath);

                if (!qpath) {
                    DebugPrint("Out of memory.\n");
                    DELETE(p);
                    return PATH_OUT_OF_MEMORY;
                }

                if (qpath->GetPathString()->QueryChCount() == 2 &&
                    qpath->GetPathString()->QueryChAt(1) == (WCHAR)':' &&
                    volume_path.Stricmp(qpath->GetPathString()) != 0) {
                    if (!volume_path.Initialize(qpath->GetPathString())) {
                        DebugPrint("Out of memory.\n");
                        DELETE(p);
                        DELETE(qpath);
                        return PATH_OUT_OF_MEMORY;
                    }
                }

                DELETE(qpath);

                if (!VolumeName->Initialize(p) ||
                    !VolumePath->Initialize(&volume_path)) {
                    DebugPrint("Out of memory.\n");
                    DELETE(p);
                    return PATH_OUT_OF_MEMORY;
                }

                DELETE(p);
            }
        } else {
            // just a drive specification
            ppath = QueryMountPointPath();
            if (!VolumeName->Initialize(&_PathString)) {
                DebugPrint("Out of memory.\n");
                return PATH_OUT_OF_MEMORY;
            }
            if (ppath) {
                if (!VolumePath->Initialize(ppath)) {
                    DebugPrint("Out of memory.\n");
                    return PATH_OUT_OF_MEMORY;
                }
                DELETE(ppath);
            }
        }
    } else if (!IsDrive()) {

        CHNUM   offset;

        // a path (not necessary full) with drive letter

        p = QueryDevice();

        if (p) {
            if (!isalpha(p->QueryChAt(0)) ||
                p->QueryChAt(1) != (WCHAR)':' ||
                p->QueryChCount() != 2) {
                DELETE(p);
                return PATH_INVALID_DRIVE_SPEC;
            }
            DELETE(p);
        }

        p = QueryGuidString(&volume_path,
                            &is_volume_path_a_drive,
                            RemainingPath);

        if (p == NULL) {
            // something is not right as there should be
            // a guid volume name for each drive letter
            // unless the drive letter is a floppy, invalid,
            // or we are out of memory
            p = QueryDevice();
            if (!p) {
                return PATH_INVALID_DRIVE_SPEC;
            }

            if (!VolumeName->Initialize(p) ||
                !VolumePath->Initialize(p)) {
                DebugPrint("Out of memory.\n");
                return PATH_OUT_OF_MEMORY;
            }
            offset = p->QueryChCount();
            DELETE(p);

            p = _PathString.QueryString(offset);
            if (!p) {
                return PATH_INVALID_DRIVE_SPEC;
            }
            if (!RemainingPath->Initialize(p)) {
                DebugPrint("Out of memory.\n");
                return PATH_OUT_OF_MEMORY;
            }
            DELETE(p);

            return PATH_COULD_BE_FLOPPY;
        }

        if ((ppath = NEW PATH) == NULL ||
            !ppath->Initialize(p)) {
            DebugPrint("Out of memory.\n");
            DELETE(p);
            return PATH_OUT_OF_MEMORY;
        }

        qpath = ppath->QueryMountPointPath();

        DELETE(ppath);

        if (!qpath) {
            DebugPrint("Out of memory.\n");
            DELETE(p);
            return PATH_OUT_OF_MEMORY;
        }

        if (qpath->GetPathString()->QueryChCount() == 2 &&
            qpath->GetPathString()->QueryChAt(1) == (WCHAR)':' &&
            volume_path.Stricmp(qpath->GetPathString()) != 0) {
            if (!volume_path.Initialize(qpath->GetPathString())) {
                DebugPrint("Out of memory.\n");
                DELETE(p);
                DELETE(qpath);
                return PATH_OUT_OF_MEMORY;
            }
        }

        DELETE(qpath);

        if (!VolumeName->Initialize(p) ||
            !VolumePath->Initialize(&volume_path)) {
            DELETE(p);
            return PATH_OUT_OF_MEMORY;
        }

        DELETE(p);
    } else {
        // just a drive letter

        if (!isalpha(_PathString.QueryChAt(0)) ||
            _PathString.QueryChAt(1) != (WCHAR)':' ||
            _PathString.QueryChCount() != 2) {
            return PATH_INVALID_DRIVE_SPEC;
        }

        if (!AppendDelimiter()) {
            return PATH_OUT_OF_MEMORY;
        }
        p = QueryGuidString(&volume_path,
                            &is_volume_path_a_drive,
                            RemainingPath);
        TruncateDelimiter();
        if (p == NULL) {
            // something is not right as there should be
            // a guid volume name for each drive letter
            // unless the drive letter is a floppy, invalid,
            // or we are out of memory
            if (!VolumeName->Initialize(&_PathString) ||
                !VolumePath->Initialize(&_PathString)) {
                DebugPrint("Out of memory.\n");
                return PATH_OUT_OF_MEMORY;
            }
            return PATH_COULD_BE_FLOPPY;
        }
        DebugAssert(is_volume_path_a_drive);
        if (!VolumeName->Initialize(p) ||
            !VolumePath->Initialize(&volume_path) ||
            !RemainingPath->Initialize()) {
            DELETE(p);
            return PATH_OUT_OF_MEMORY;
        }
        DELETE(p);
    }
    return PATH_OK;
#else
    return PATH_INVALID_DRIVE_SPEC;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\membmgr2.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    membmgr2.cxx

Author:

    Daniel Chan (danielch) Oct 18, 1999

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "membmgr2.hxx"


DEFINE_CONSTRUCTOR( MEM_ALLOCATOR, OBJECT );

VOID
MEM_ALLOCATOR::Construct(
    )
/*++

Routine Description:

    This method is the worker function for object construction.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    _head_ptr = _next_free_ptr = NULL;
    _incremental_size = _free_space_in_current_block = 0;
    _max_mem_use = 0;
    _mem_use = 0;
}

VOID
MEM_ALLOCATOR::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    PVOID      p;

    if (_head_ptr) {
        DebugAssert(_incremental_size != 0);
    }

    // free up the entire linked memory block

    while (_head_ptr) {
        p = ((PUCHAR)_head_ptr) + _incremental_size - sizeof(PVOID *);
        p = (*(PVOID *)p);
        FREE(_head_ptr);
        _head_ptr = p;
    }

    _next_free_ptr = NULL;
    _incremental_size = _free_space_in_current_block = 0;
    _max_mem_use = 0;
    _mem_use = 0;
}

MEM_ALLOCATOR::~MEM_ALLOCATOR(
    )
/*++

Routine Description:

    This method un-initialize the class object.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    Destroy();
}

BOOLEAN
MEM_ALLOCATOR::Initialize(
    IN     ULONG64      MaximumMemoryToUse,
    IN     ULONG        IncrementalBlockSize
    )
/*++

Routine Description:

    This method initialize this class object.

Arguments:

    IncrementalBlockSize
                --  Supplies the block size to allocate
                    whenever there is a need to grow the memory.

Returns:

    TRUE if successful; otherwise, FALSE.

--*/
{
    Destroy();

    if (IncrementalBlockSize && MaximumMemoryToUse > 0) {
        if (MaximumMemoryToUse >= (((ULONG64)-1)-sizeof(PVOID*)))
            _incremental_size = IncrementalBlockSize;
        else if (IncrementalBlockSize > (MaximumMemoryToUse+sizeof(PVOID*)))
            _incremental_size = (ULONG)(MaximumMemoryToUse+sizeof(PVOID*));
        else
            _incremental_size = IncrementalBlockSize;
        _max_mem_use = MaximumMemoryToUse;
        return TRUE;
    } else {
        return FALSE;
    }
}

PVOID
MEM_ALLOCATOR::Allocate(
    IN     ULONG        SizeInBytes
    )
/*++

Routine Description:

    This method allocates a chunk of memory from the memory block.

Arguments:

    Size        -- Supplies the size of the buffer needed

Returns:

    Pointer to the block if successful
    NULL if failure

--*/
{
    PVOID      p;

    //
    // make sure request buffer is smaller than the max block size possible
    //

    if ((SizeInBytes + sizeof(PVOID *)) > _incremental_size)
        return NULL;

    if (_head_ptr == NULL) {

        DebugAssert(_mem_use == 0);

        //
        // first time, so allocate a buffer and initializes all class variables
        //
        _head_ptr = MALLOC(_incremental_size);
        if (_head_ptr == NULL)
            return NULL;
        _mem_use = _incremental_size;
        _free_space_in_current_block = _incremental_size - sizeof(PVOID *);
        *(PVOID *)(((PUCHAR)_head_ptr) + _free_space_in_current_block) = NULL;
        _free_space_in_current_block -= SizeInBytes;
        _next_free_ptr = ((PUCHAR)_head_ptr + SizeInBytes);
        return _head_ptr;

    } else {
        //
        // Check to see if there is enough space left
        //
        if (SizeInBytes <= _free_space_in_current_block) {
            //
            // Enough space from current block
            //
            p = _next_free_ptr;
            _free_space_in_current_block -= SizeInBytes;
            _next_free_ptr = ((PUCHAR)_next_free_ptr) + SizeInBytes;
            return p;
        } else {

            if (_mem_use >= _max_mem_use)
                return NULL;    // reached the limit

            p = MALLOC(_incremental_size);
            if (p == NULL)
                return NULL;

            _mem_use = _mem_use - _free_space_in_current_block + _incremental_size;
            _next_free_ptr = ((PUCHAR)_next_free_ptr) + _free_space_in_current_block;
            *(PVOID *)_next_free_ptr = p;
            _free_space_in_current_block = _incremental_size - sizeof(PVOID *);
            *(PVOID *)(((PUCHAR)_head_ptr) + _free_space_in_current_block) = NULL;
            _free_space_in_current_block -= SizeInBytes;
            _next_free_ptr = ((PUCHAR)p + SizeInBytes);
            return p;
        }
    }
    DebugAssert(FALSE);
    return NULL;    // should never get here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\message.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "message.hxx"
#include "hmem.hxx"

extern "C" {
#include "stdio.h"
#if defined(_AUTOCHECK_)
#include "ntos.h"
#endif
}

DEFINE_EXPORTED_CONSTRUCTOR(MESSAGE, OBJECT, ULIB_EXPORT);


MESSAGE::~MESSAGE(
    )
/*++

Routine Description:

    Destructor for MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _logged_chars = 0;
    _next_message_offset = 0;
    _logging_enabled = FALSE;
    _msgid = 0;
    _inuse = 0;
    _timeout.QuadPart = 0;
}


VOID
MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _logged_chars = 0;
    _next_message_offset = 0;
    _logging_enabled = FALSE;
    _msgid = 0;
    _inuse = 0;
    _timeout.QuadPart = 0;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::Initialize(
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    DotsOnly    - Autochk should produce only dots instead of messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _timeout.QuadPart = -10000;
    return _log_buffer.Initialize();
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsSuppressedMessage(
    )
/*++

Routine Description:

    This function determines whether the specified message ID
    should be suppressed, i.e. not recorded in the message log.

Arguments:

    MessageId   --  Supplies the Message ID in question.

Return Value:

    TRUE if this message ID is in the set which is not recorded
    in the message log.

--*/
{
    BOOLEAN result;

    switch( _msgid ) {

    case MSG_HIDDEN_STATUS:
    case MSG_PERCENT_COMPLETE:
    case MSG_PERCENT_COMPLETE2:
    case MSG_CHK_NTFS_CHECKING_FILES:
    case MSG_CHK_NTFS_CHECKING_INDICES:
    case MSG_CHK_NTFS_INDEX_VERIFICATION_COMPLETED:
    case MSG_CHK_NTFS_FILE_VERIFICATION_COMPLETED:
    case MSG_CHK_NTFS_CHECKING_SECURITY:
    case MSG_CHK_NTFS_SECURITY_VERIFICATION_COMPLETED:
    case MSG_CHK_VOLUME_CLEAN:
    case MSG_CHK_CHECKING_FILES:
    case MSG_CHK_DONE_CHECKING:

        result = TRUE;
        break;

    default:
        result = FALSE;
        break;
    }

    return result;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::Display(
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    // unreferenced parameters
    (void)(this);

    va_start(ap, Format);
    r = DisplayV(Format, ap);
    va_end(ap);

    return r;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::DisplayMsg(
    IN  MSGID   MsgId,
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.
    It performs the operation atomically.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }

    Set(MsgId);

    va_start(ap, Format);
    r = DisplayV(Format, ap);
    va_end(ap);

    InterlockedDecrement(&_inuse);

    return r;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::DisplayMsg(
    IN  MSGID           MsgId,
    IN  MESSAGE_TYPE    MessageType,
    IN  ULONG           MessageVisual,
    IN  PCSTR           Format ...
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.
    It performs the operation atomically.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }

    Set(MsgId, MessageType, MessageVisual);

    va_start(ap, Format);
    r = DisplayV(Format, ap);
    va_end(ap);

    InterlockedDecrement(&_inuse);

    return r;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::LogMsg(
    IN  MSGID   MsgId,
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine logs the message with the specified parameters.
    It performs the operation atomically.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }

    Set(MsgId);

    va_start(ap, Format);
    r = LogV(Format, ap);
    va_end(ap);

    InterlockedDecrement(&_inuse);

    return r;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::Log(
    IN  PCSTR   Format ...
    )
/*++

Routine Description:

    This routine logs the message with the specified parameters.

Arguments:

    Format ... - Supplies a printf style list of arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    // unreferenced parameters
    (void)(this);

    va_start(ap, Format);
    r = LogV(Format, ap);
    va_end(ap);

    return r;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::DumpDataToLog(
    IN  PVOID   Data,
    IN  ULONG   Length
    )
/*++

Routine Description:

    This routine dumps the binary data to the log.

Arguments:

    Data       - Supplies a pointer to the data to be dumped
    Length     - Supplies the number of bytes to dump

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PUCHAR  pdata = (PUCHAR)Data;
    ULONG   block;
    BOOLEAN rst = TRUE;
    WCHAR    buffer[50], buffer2[20];
    USHORT  i;

    block = ((Length + 0xf) >> 4) + 1;
    Set(MSG_CHKLOG_DUMP_DATA);

    while (rst && block--) {

        for (i=0; i<16; i++) {
            __try {
                swprintf(buffer+i*3, L"%02x ", pdata[i]);
                if (isprint(pdata[i]))
                    swprintf(buffer2+i, L"%c", pdata[i]);
                else
                    buffer2[i] = '.';
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                buffer[i*3] = '?';
                buffer[i*3+1] = '?';
                buffer[i*3+2] = ' ';
                buffer2[i] = '.';
            }
        }
        buffer[48] = ' ';
        buffer[49] = 0;
        buffer2[16] = 0;

        pdata += 0x10;
        rst = rst && Log("%ws%ws", buffer, buffer2);
    }

    return rst;
}

BOOLEAN
MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

Arguments:

    Format      - Supplies a printf style list of arguments.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);
    (void)(Format);
    (void)(VarPointer);

    return TRUE;
}


BOOLEAN
MESSAGE::LogV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine logs the message with the specified parameters.

Arguments:

    Format      - Supplies a printf style list of arguments.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING         display_string;
    CHAR            buffer[512];

    if (IsLoggingEnabled()) {

        if (!BASE_SYSTEM::QueryResourceStringV(&display_string, _msgid, Format,
                                               VarPointer)) {
            return FALSE;
        }

        if (display_string.QuerySTR(0, TO_END, buffer, 512, TRUE)) {
            DebugPrintTrace(("%s", buffer));
        }

        return LogMessage(&display_string);
    }

    return TRUE;
}


PMESSAGE
MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    // unreferenced parameters
    (void)(this);

    return NEW MESSAGE;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries to see if the response to a message is either
    yes or no.

Arguments:

    Default - Supplies a default answer to the question.

Return Value:

    FALSE   - A "no" response.
    TRUE    - A "yes" response.

--*/
{
    // unreferenced parameters
    (void)(this);

    return Default;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::QueryStringInput(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine queries a string from the user.

Arguments:

    String  - Supplies a buffer to return the string into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);

    return String->Initialize("");
}



ULIB_EXPORT
MSGID
MESSAGE::SelectResponse(
    IN  ULONG   NumberOfSelections ...
    )
/*++

Routine Descriptions:

    This routine queries a response from the user.  It returns the
    message id of the response inputted.

Arguments:

    NumberOfSelections  - Supplies the number of possible message
                            responses.

    ... - Supplies 'NumberOfSelections' message identifiers.

Return Value:

    The first message id on the list.

--*/
{
    va_list ap;
    MSGID   msg;

    // unreferenced parameters
    (void)(this);

    va_start(ap, NumberOfSelections);
    msg = va_arg(ap, MSGID);
    va_end(ap);
    return msg;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::IsInAutoChk(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in regular autochk.

Arguments:

    None.

Return Value:

    FALSE   - Not in autochk

--*/
{
    return FALSE;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsInSetup(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in setup.

Arguments:

    None.

Return Value:

    FALSE   - Not in setup

--*/
{
    return FALSE;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::IsKeyPressed(
    MSGID       MsgId,
    ULONG       TimeOutInSeconds
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate no
    key has been pressed.

Arguments:

    None.

Return Value:

    FALSE   - No key is pressed within the time out period.

--*/
{
    // unreferenced parameters
    (void)(this);
    UNREFERENCED_PARAMETER( MsgId );
    UNREFERENCED_PARAMETER( TimeOutInSeconds );

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    This routine waits for a signal from the user.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);

    return TRUE;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::SetDotsOnly(
    IN  BOOLEAN DotsState
    )
{
    // unreferenced parameters
    (void)this;
    (void)DotsState;

    return FALSE;
}

ULIB_EXPORT
BOOLEAN
MESSAGE::QueryPackedLog(
    IN OUT  PHMEM   Mem,
    OUT     PULONG  PackedDataLength
    )
/*++

Routine Description:

Arguments:

    Mem                 --  Supplies a container for the packed log.
    PackedDataLength    --  Receives the number of bytes written to Mem.

Return Value:

    TRUE upon successful completion.

--*/
{
    FSTRING CurrentString;
    PWCHAR  Buffer;
    ULONG   NewBufferSize, CurrentOffset;

    if( !IsLoggingEnabled() ) {

        return FALSE;
    }

    ResetLoggingIterator();
    CurrentOffset = 0;

    while( QueryNextLoggedMessage( &CurrentString ) ) {

        NewBufferSize = (CurrentOffset + CurrentString.QueryChCount()) * sizeof(WCHAR);
        if( NewBufferSize > Mem->QuerySize() &&
            !Mem->Resize( (NewBufferSize + 1023)/1024 * 1024, 0x1 ) ) {

            return FALSE;
        }

        Buffer = (PWCHAR)Mem->GetBuf();
        memcpy( Buffer + CurrentOffset,
                CurrentString.GetWSTR(),
                CurrentString.QueryChCount() * sizeof(WCHAR) );

        CurrentOffset += CurrentString.QueryChCount();
    }

    *PackedDataLength = CurrentOffset * sizeof(WCHAR);
    return TRUE;
}

BOOLEAN
MESSAGE::QueryNextLoggedMessage(
    OUT PFSTRING    MessageText
    )
{
    PWCHAR Buffer = (PWCHAR)_log_buffer.GetBuf();
    BOOLEAN Result;

    if( _next_message_offset >= _logged_chars ) {

        // No more logged messages.
        //
        return FALSE;
    }

    Result = (MessageText->Initialize( Buffer + _next_message_offset ) != NULL) ?
             TRUE : FALSE;

    // Push _next_message_offset to the next message.  Note
    // that _next_message_offset is also incremented if this
    // loop terminates because a zero was found, so that it
    // will be one character past the next NULL character.
    //
    while( _next_message_offset < _logged_chars &&
           Buffer[_next_message_offset++] );

    return Result;
}


ULIB_EXPORT
BOOLEAN
MESSAGE::LogMessage(
    PCWSTRING   Message
    )
{
    ULONG NewBufferSize;
    PWCHAR Buffer;

    // The buffer must be large enough to accept this message plus
    // a trailing null.  To cut down the number of memory allocation
    // calls, grow the buffer by 1K chunks.
    //
    NewBufferSize = (_logged_chars + Message->QueryChCount() + 1) * sizeof(WCHAR);

    // Don't allow the buffer to grow more than 0.5MB
    // otherwise we may use up all the pages.

    if (NewBufferSize > 512000)
        return FALSE;

    if( _log_buffer.QuerySize() < NewBufferSize &&
        !_log_buffer.Resize( (NewBufferSize + 1023)/1024 * 1024, 0x1 ) ) {
        return FALSE;
    }

    Buffer = (PWCHAR)_log_buffer.GetBuf();

    // QueryWSTR will append a trailing NULL.
    //
    Message->QueryWSTR( 0, TO_END,
                        Buffer + _logged_chars,
                        _log_buffer.QuerySize()/sizeof(WCHAR) - _logged_chars );

    _logged_chars += Message->QueryChCount() + 1;

    return TRUE;
}

ULIB_EXPORT
VOID
MESSAGE::Lock(
    )
{
    while (InterlockedCompareExchange(&_inuse, 1, 0)) {
        NtDelayExecution(FALSE, &_timeout);
    }
}

ULIB_EXPORT
VOID
MESSAGE::Unlock(
    )
{
    InterlockedDecrement(&_inuse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\newdel.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    newdel.cxx

Abstract:

    This module implements the C++ new and delete operators for
    the Setup-Loader environment.  In other environments, the utilities
    use the standard C++ new and delete.

Author:

    David J. Gilman (davegi) 07-Dec-1990

Environment:

    ULIB, User Mode

--*/


#include <pch.cxx>

#define _ULIB_MEMBER_

#if defined( _AUTOCHECK_ )
extern "C" {
    #include "ntos.h"
    #include <windows.h>
}
#endif

#include "ulib.hxx"



extern "C"
int _cdecl
_purecall( );

int _cdecl
_purecall( )
{

    DebugAbort( "Pure virtual function called.\n" );

    return 0;
}




#if defined( _AUTOCHECK_ )

STATIC ULONG64 HeapLeft = -1;
STATIC LONG  InUse = 0;

ULIB_EXPORT
ULONG64
AutoChkFreeSpaceLeft(
    )
{
    ULONG64         heap_left;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };  // 100 ns resolution

    while (InterlockedCompareExchange(&InUse, 1, 0) != 0)
        NtDelayExecution(FALSE, &timeout);

    heap_left = HeapLeft;

    status = InterlockedDecrement(&InUse);
    DebugAssert(status == 0);

    return heap_left;
}

ULIB_EXPORT
PVOID
AutoChkMalloc(
    ULONG bytes
    )
{
    PVOID           p;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };  // 100 ns resolution

    while (InterlockedCompareExchange(&InUse, 1, 0) != 0)
        NtDelayExecution(FALSE, &timeout);

    if (HeapLeft == -1) {

        SYSTEM_PERFORMANCE_INFORMATION  PerfInfo;
        SYSTEM_BASIC_INFORMATION        BasicInfo;
        ULONG64                         dwi;
        ULONG64                         user_addr_space;

        status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &(BasicInfo),
                    sizeof(BasicInfo),
                    NULL
                    );

        if (!NT_SUCCESS(status)) {
            InterlockedDecrement(&InUse);
            KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_ERROR_LEVEL,
                       "AutoChkMalloc: NtQuerySystemInformation(SystemBasicInfo) failed %x\n", status));
            return NULL;
        }

        status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &(PerfInfo),
                    sizeof(PerfInfo),
                    NULL
                    );

        if (!NT_SUCCESS(status)) {
            InterlockedDecrement(&InUse);
            KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_ERROR_LEVEL,
                       "AutoChkMalloc: NtQuerySystemInformation(SystemPerformanceInfo) failed %x\n", status));
            return NULL;
        }

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: Pagesize %x\n", BasicInfo.PageSize));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: Min User Addr %Ix\n", (ULONG64)BasicInfo.MinimumUserModeAddress));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: Max User Addr %Ix\n", (ULONG64)BasicInfo.MaximumUserModeAddress));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: AvailablePages %x\n", PerfInfo.AvailablePages));

        user_addr_space = BasicInfo.MaximumUserModeAddress - BasicInfo.MinimumUserModeAddress;

        dwi = BasicInfo.PageSize;

        dwi *= PerfInfo.AvailablePages;

        if (user_addr_space < dwi)
            dwi = user_addr_space;  // can't go beyond available user address space

        if (dwi == -1) {
            dwi -= 1;
        }

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL, "AutoChkMalloc: DWI %I64x\n", dwi));

        //
        // The following magic number is simply a reserve subtracted off
        // the heap total to give the system some head room during the
        // AUTOCHK phase
        //
        if (dwi <= (100ul * 1024ul)) {
            HeapLeft = 0;
        } else {
            HeapLeft = dwi - dwi/10;
        }
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "AutoChkMalloc: HeapLeft %I64x\n", HeapLeft));
    }
    if (bytes > HeapLeft) {

        ULONG64   heapLeft = HeapLeft;

        status = InterlockedDecrement(&InUse);
        DebugAssert(status == 0);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_ERROR_LEVEL,
                   "AutoChkMalloc: Out of memory: Avail %I64x, Asked %x\n",
                   heapLeft, bytes));
        return (NULL);
    }

    p = RtlAllocateHeap(RtlProcessHeap(), 0, bytes);

    if (p) {
        HeapLeft -= bytes;
        status = InterlockedDecrement(&InUse);
    } else {

        ULONG64   heapLeft = HeapLeft;

        status = InterlockedDecrement(&InUse);

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_ERROR_LEVEL,
                   "AutoChkMalloc: Out of memory possibly due to fragmentation: Avail %I64x, Asked %x\n",
                   heapLeft, bytes));
    }
    DebugAssert(status == 0);
    return p;
}

ULIB_EXPORT
VOID
AutoChkMFree(
    PVOID pmem
    )
{
    ULONG           size;
    LONG            status;
    LARGE_INTEGER   timeout = { -10000, -1 };  // 100 ns resolution

    size = (ULONG)RtlSizeHeap(RtlProcessHeap(), 0, pmem);

    while (InterlockedCompareExchange(&InUse, 1, 0) != 0)
        NtDelayExecution(FALSE, &timeout);

    if (HeapLeft != -1) {
        HeapLeft += size;
    }

    RtlFreeHeap(RtlProcessHeap(), 0, pmem);

    status = InterlockedDecrement(&InUse);
    DebugAssert(status == 0);

    return;
}
#endif // _AUTOCHECK_


#if defined( _SETUP_LOADER_ ) || defined( _AUTOCHECK_ )

// When the utilities are running the Setup Loader
// or Autocheck environments, they can't use the C-Run-
// Time new and delete; instead, these functions are
// provided.
//
PVOID _cdecl
operator new (
    IN size_t   bytes
    )
/*++

Routine Description:

    This routine allocates 'bytes' bytes of memory.

Arguments:

    bytes   - Supplies the number of bytes requested.

Return Value:

    A pointer to 'bytes' bytes or NULL.

--*/
{
    #if defined( _AUTOCHECK_ )

    return AutoChkMalloc(bytes);

    #elif defined( _SETUP_LOADER_ )

        return SpMalloc( bytes );

    #else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

        return (PVOID) LocalAlloc(0, bytes);

    #endif // _AUTOCHECK_
}


VOID _cdecl
operator delete (
    IN  PVOID   pointer
    )
/*++

Routine Description:

    This routine frees the memory pointed to by 'pointer'.

Arguments:

    pointer - Supplies a pointer to the memoery to be freed.

Return Value:

    None.

--*/
{
    if (pointer) {

        #if defined( _AUTOCHECK_ )

        AutoChkMFree(pointer);

        #elif defined( _SETUP_LOADER_ )

            SpFree( pointer );

        #else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

            LocalFree( pointer );

        #endif // _AUTOCHECK_

    }
}


typedef void (*PF)(PVOID);
typedef void (*PFI)(PVOID, int);
PVOID
__vec_new(
    IN OUT PVOID    op,
    IN int          number,
    IN int          size,
    IN PVOID        f)
/*
     allocate a vector of "number" elements of size "size"
     and initialize each by a call of "f"
*/
{
    if (op == 0) {

        #if defined( _AUTOCHECK_ )

        op = AutoChkMalloc(number * size);

        #elif defined( _SETUP_LOADER_ )

            op = SpMalloc( number*size );

        #else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

            op = (PVOID) LocalAlloc(0, number*size);

        #endif // _AUTOCHECK_

    }

    if (op && f) {

        register char* p = (char*) op;
        register char* lim = p + number*size;
        register PF fp = PF(f);
        while (p < lim) {
            (*fp) (PVOID(p));
            p += size;
        }
    }

    return op;
}


void
__vec_delete(
    PVOID op,
    int n,
    int sz,
    PVOID f,
    int del,
    int x)

/*
     destroy a vector of "n" elements of size "sz"
*/
{
    // unreferenced parameters
    // I wonder what it does--billmc
    (void)(x);

    if (op) {
        if (f) {
            register char* cp = (char*) op;
            register char* p = cp;
            register PFI fp = PFI(f);
            p += n*sz;
            while (p > cp) {
                p -= sz;
                (*fp)(PVOID(p), 2);  // destroy VBC, don't delete
            }
        }
        if (del) {

            #if defined( _AUTOCHECK_ )

        AutoChkMFree(op);

            #elif defined( _SETUP_LOADER_ )

                SpFree( op );

            #else // _AUTOCHECK_ not defined

                LocalFree(op);

            #endif // _AUTOCHECK_

        }
    }
}

#endif // _SETUP_LOADER_

ULIB_EXPORT
PVOID
UlibRealloc(
    PVOID x,
    ULONG size
    )
{
#if defined( _SETUP_LOADER_ )

    return SpRealloc(x, size);

#else // _SETUP_LOADER_

    PVOID p;
    SIZE_T l;


    if (size <= (l = RtlSizeHeap(RtlProcessHeap(), 0, x))) {
        return x;
    }

    if (!(p = MALLOC(size))) {
        return NULL;
    }

    memcpy(p, x, (UINT) l);

    FREE(x);

    return p;

#endif // _SETUP_LOADER_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\pipe.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	pipe.cxx

Abstract:

	This module contains the implementation of the PIPE class.

Author:

	Barry J. Gilhuly	(W-Barry)		June 27, 1991

Environment:

	ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "pipestrm.hxx"
#include "pipe.hxx"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( PIPE, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( PIPE );


VOID
PIPE::Destroy(
	)
/*++

Routine Description:

	Close the handles which were opened by the initialize method.

Arguments:

	None.

Return Value:

	None.

--*/
{
	if( !_fInitialized ) {
		return;
	}

	//
	// Close the pipe...
	//
	CloseHandle( _hReadPipe );
	CloseHandle( _hWritePipe );
	_fInitialized = FALSE;

	return;
}

BOOLEAN
PIPE::Initialize(
	IN	LPSECURITY_ATTRIBUTES	PipeAttributes,
	IN	ULONG					PipeSize,
	IN	PWSTRING				PipeName
	)
/*++

Routine Description:

	Create a PIPE by making a call to the system API.  If the PIPE object
	has been previously initialized, destroy it first.

Arguments:

	PipeAttributes - A pointer to a structure which defines the attributes
				of the pipe to be created.

	PipeSize	   - A suggested buffer size for the pipe.

	PipeName	   - The name of the pipe.	Currently, this option is
				unimplemented, it should ALWAYS be NULL.

Return Value:

	TRUE if the PIPE was created successfully.

--*/
{
	BOOL PipeStatus = FALSE;

	Destroy();

	if( PipeName == NULL ) {
		//
		// Create an anonomous pipe...
		//
		if( !( PipeStatus = CreatePipe( &_hReadPipe,
						&_hWritePipe,
						PipeAttributes,
						PipeSize ) ) ) {
			DebugPrint( "Unable to create the pipe - returning failure!\n" );
			_fInitialized = FALSE;
		} else {
			_fInitialized = TRUE;
		}
	} else {
		DebugPrint( "Named Pipes are not currently implemented!\n" );
	}
	return( PipeStatus != FALSE );
}

PPIPE_STREAM
PIPE::QueryPipeStream(
	IN	HANDLE			hPipe,
	IN	STREAMACCESS	Access
	)
/*++

Routine Description:

	Create and initialize a stream to the PIPE object.

Arguments:

	hPipe	- A handle to use in the initialization of the stream.

	Access	- The desired access on this stream.

Return Value:

	Returns a pointer to the created PIPE STREAM if successful.  Otherwise,
	it returns NULL.

--*/
{
	PPIPE_STREAM	NewStream;

	if( !_fInitialized ) {
		DebugPrint( "Pipe object is uninitialized!\n" );
		NewStream = NULL;
	} else {
		if( ( NewStream = NEW PIPE_STREAM ) == NULL ) {
			DebugPrint( "Unable to create a new copy of the Read Stream!\n" );
		} else {
			if( !NewStream->Initialize( hPipe, Access ) ) {
				DebugPrint( "Unable to initialize the new stream!\n" );
				DELETE( NewStream );
				NewStream = NULL;
			}
		}
	}
	return( NewStream );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\pipestrm.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    pipestrm.cxx

Abstract:

    This module contains the definitions of the member functions
    of PIPE_STREAM class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "stream.hxx"
#include "bufstrm.hxx"
#include "pipestrm.hxx"

#define BUFFER_SIZE 4*1024


DEFINE_CONSTRUCTOR ( PIPE_STREAM, BUFFER_STREAM );


DEFINE_CAST_MEMBER_FUNCTION( PIPE_STREAM );


PIPE_STREAM::~PIPE_STREAM (
    )

/*++

Routine Description:

    Destroy a PIPE_STREAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
}


BOOLEAN
PIPE_STREAM::Initialize(
    IN HANDLE       Handle,
    IN STREAMACCESS Access
    )

/*++

Routine Description:

    Initializes a PIPE_STREAM object.

Arguments:

    Handle - Handle to the anonymous pipe.

    Access - Access allowed to the stream.


Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    if( ( Access == READ_ACCESS ) || ( Access == WRITE_ACCESS ) ) {
        _PipeHandle = Handle;
        _Access = Access;
        _EndOfFile = FALSE;
        return( BUFFER_STREAM::Initialize( BUFFER_SIZE ) );
    } else {
        return( FALSE );
    }
}


BOOLEAN
PIPE_STREAM::EndOfFile(
    ) CONST

/*++

Routine Description:

    Informs the caller if end of file has occurred. End of file happens
    when all bytes were read from the pipe (in the case of anonymous
    pipe, "end of file" happens when ReadFile returns STATUS_END_OF_FILE).

Arguments:

    None.

Return Value:

    A boolean value that indicates if end of file was detected.


--*/


{
    return( _EndOfFile );
}

#ifdef FE_SB  // v-junm - 10/15/93

BOOLEAN
PIPE_STREAM::CheckIfLeadByte(
    IN PUCHAR   text,
    IN ULONG   offset
    )

/*++

Routine Description:

    Checks to see if the character at an given offset in a MBCS string is a
    leadbyte of a DBCS character.

Arguments:

    text - MBCS string.

Return Value:

    TRUE - if char is leadbyte.
    FALSE - otherwise.

--*/

{
    ULONG   i = offset;

    for ( ; i; i-- )
        if ( !IsDBCSLeadByte ( text[i] ) )
            break;

    return( (BOOLEAN)(( offset - i ) % 2) );
}

#endif



BOOLEAN
PIPE_STREAM::FillBuffer(
    IN  PBYTE   Buffer,
    IN  ULONG   BufferSize,
    OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Fills a buffer with bytes read from the pipe, if the pipe has
    READ_ACCESS.
    Returns FALSE if the pipe has WRITE_ACCESS.

Arguments:

    Buffer - Buffer where the bytes are to be stored.

    BufferSize - Size of the buffer.

    BytesRead - Pointer to the variable that will contain the number of bytes
                put in the buffer.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/

{
    BOOL    Result;
    PBYTE   p;

#ifdef FE_SB  // v-junm - 10/15/93

    //
    // This define keeps the remaining leadbyte that was read from the
    // pipe stream and concatanates it to the next set of strings read.
    // The remaining byte means that if there is a leadbyte at the end
    // of a string without a cooresponding tail byte.
    //
    // NOTE: The following code assumes that the pipe stream is always
    // constant and is continuously reading from the same pipe for the
    // same caller.
    //

    static BYTE   LeadByte = 0;


    //
    // If there was a leadbyte, put it in buffer and decrement buffer size.
    //

    if ( LeadByte != 0 )  {
        *Buffer++ = LeadByte;
        BufferSize--;
    }

#endif

    Result = FALSE;
    if( _Access == READ_ACCESS ) {
        Result = ReadFile( _PipeHandle,
                           Buffer,
                           BufferSize,
                           BytesRead,
                           NULL );

#ifdef FE_SB  // v-junm - 10/15/93

        //
        // If there was a leadbyte placed earlier,
        // re-adjust buffer and buffercount.
        //

        if ( LeadByte != 0 ) {
            *BytesRead = *BytesRead + 1;
            Buffer--;
        }

        //
        // If bytes were read, check if string ends with a leadbyte.
        // If so, save it for next time.
        //

        if ( (*BytesRead != 0) && CheckIfLeadByte( Buffer, *BytesRead-1 ) )  {

            //
            // Check if buffer contains only the leadbyte that was placed
            // from the previous call to this function.
            //

            if ( (LeadByte != 0) && (*BytesRead == 1) )
                LeadByte = 0;
            else  {

                //
                // Leadbyte is at end of string. save it for next time
                // and adjust buffer size so a null will be replaced
                // for the leadbyte.
                //

                LeadByte = *(Buffer + *BytesRead - 1);
                *BytesRead = *BytesRead - 1;
            }

        }
        else
            LeadByte = 0;

#endif

        // no bytes read means end of file

        if( *BytesRead ) {
            p = (PBYTE)Buffer + *BytesRead;
            *p++ = '\0';
            *p   = '\0';
        } else {
            _EndOfFile = TRUE;
        }

    }
    return( Result != FALSE );
}



STREAMACCESS
PIPE_STREAM::QueryAccess(
    ) CONST

/*++

Routine Description:

    Returns the type of access of the pipe stream

Arguments:

    None.

Return Value:

    The stream access.


--*/


{
    return( _Access );
}



HANDLE
PIPE_STREAM::QueryHandle(
    ) CONST

/*++

Routine Description:

    Returns the file handle

Arguments:

    None.

Return Value:

    The file handle.


--*/


{
    return( _PipeHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\prtstrm.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	prtstrm.cxx

Abstract:

	This module contains the definitions of the member functions
	of PRINT_STREAM class.

Author:

	Jaime Sasson (jaimes) 12-Jun-1991

Environment:

	ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "stream.hxx"
#include "prtstrm.hxx"


DEFINE_EXPORTED_CONSTRUCTOR ( PRINT_STREAM, STREAM, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( PRINT_STREAM );


VOID
PRINT_STREAM::Construct(
    )
{
    _Handle = INVALID_HANDLE_VALUE;
}


ULIB_EXPORT
PRINT_STREAM::~PRINT_STREAM (
	)

/*++

Routine Description:

	Destroy a PRINT_STREAM.

Arguments:

	None.

Return Value:

	None.

--*/

{
	if (INVALID_HANDLE_VALUE != _Handle) {

	    CloseHandle( _Handle );
    }
}



ULIB_EXPORT
BOOLEAN
PRINT_STREAM::Initialize(
    IN PCPATH   DeviceName
    )

/*++

Routine Description:

    Initializes an object of type PRINT_STREAM.

Arguments:

    DevicName   - A path to the device associated with the printer.


Return Value:

    BOOLEAN - TRUE if the initialization succeeded. FALSE otherwise.


--*/


{
    ULONG       FileType;
    PCWSTRING   String;

    String = DeviceName->GetPathString();


    _Handle = CreateFile( String->GetWSTR(),
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,                 // Security attributes
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );
    if( _Handle == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }
    return( STREAM::Initialize() );
}


BOOLEAN
PRINT_STREAM::IsAtEnd(
	) CONST

/*++

Routine Description:

	Informs the caller if end of file has occurred. The concept of
	end of file for a PRINT_STREAM does not have any meaning, so this
	method will always return FALSE.

Arguments:

	None.

Return Value:

	Returns FALSE.


--*/


{
	(void)(this);
	return( FALSE );
}


STREAMACCESS
PRINT_STREAM::QueryAccess(
	) CONST

/*++

Routine Description:

	Returns the type of access of the print stream

Arguments:

	None.

Return Value:

	Returns always WRITE_ACCESS.


--*/


{
	(void)(this);
	return( WRITE_ACCESS );
}



HANDLE
PRINT_STREAM::QueryHandle(
	) CONST

/*++

Routine Description:

	Returns the handle to the stream.

Arguments:

	None.

Return Value:

	Returns a handle.


--*/


{
	return( _Handle );
}


BOOLEAN
PRINT_STREAM::Read(
	OUT PBYTE	Buffer,
	IN	ULONG	BytesToRead,
	OUT PULONG	BytesRead
	)

/*++

Routine Description:

	Reads bytes from the print stream.

Arguments:

	PBYTE - Points that will receive the bytes read.

	ULONG - Number of bytes to read (buffer size)

	PULONG - Points to the variable that will contain the total
			 number of bytes read.

Return Value:

	Returns always FALSE since no data can be read from a print stream.


--*/


{
	// unreferenced parameters
	(void)(this);
	(void)(Buffer);
	(void)(BytesToRead);
	(void)(BytesRead);

	return( FALSE );
}



BOOLEAN
PRINT_STREAM::ReadChar(
	OUT PWCHAR			Char,
        IN      BOOLEAN    Unicode
	)

/*++

Routine Description:

	Reads a character from the print stream.

Arguments:

	Char	-	Supplies poinbter to wide character

Return Value:

	Returns always FALSE since no data can be read from a print stream.


--*/


{
	// unreferenced parameters
	(void)(this);
	(void)(Char);
	(void)(Unicode);

	return( FALSE );
}



BOOLEAN
PRINT_STREAM::ReadString(
	OUT PWSTRING		String,
	IN	PWSTRING		Delimiter,
        IN      BOOLEAN    Unicode
	)

/*++

Routine Description:

	Reads a STRING from the print stream.

Arguments:

	Pointer to the variable that will contain the pointer to the STRING
	object.

Return Value:

	Returns always FALSE since no data can be read from a print stream.


--*/


{
	// unreferenced parameters
	(void)(this);
	(void)(String);
	(void)(Delimiter);
	(void)(Unicode);

	return( FALSE );
}



BOOLEAN
PRINT_STREAM::ReadMbString(
    IN      PSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/


{
	// unreferenced parameters
	(void)(this);
    (void)(String);
    (void)(BufferSize);
    (void)(StringSize);
    (void)(Delimiters);
    (void)(ExpandTabs);
    (void)(TabExp);

	return( FALSE );
}


BOOLEAN
PRINT_STREAM::ReadWString(
    IN      PWSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PWSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/


{
	// unreferenced parameters
	(void)(this);
    (void)(String);
    (void)(BufferSize);
    (void)(StringSize);
    (void)(Delimiters);
    (void)(ExpandTabs);
    (void)(TabExp);

	return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\prnthack.cxx ===
// Because the name of the function to be used is
// DbgPrint, we can't include "ulib.hxx"

void
DbgPrint (
    char* String
    );


void
AutoCheckDisplayString (
    char* String
    )
{
    DbgPrint(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\program.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

	program.cxx

Abstract:

Author:

	David J. Gilman (davegi) 02-Mar-1991

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "path.hxx"
#include "program.hxx"
#include "system.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( PROGRAM, OBJECT, ULIB_EXPORT );

ULIB_EXPORT
PROGRAM::~PROGRAM (
	)
{

}

ULIB_EXPORT
BOOLEAN
PROGRAM::Initialize (
	IN	MSGID	UsageMsg,
	IN	MSGID	FatalMsg,
	IN	ULONG	FatalLevel
	)

/*++

Routine Description:

	Initializes a PROGRAM object.

Arguments:

	UsageMsg	-	Supplies usage (help) message id.
	FatalMsg	-	Supplies default fatal message id.
	FatalLevel	-	Supplies default fatal exit level.

Return Value:

	BOOLEAN -	Returns TRUE if object initialized,
				FALSE otherwise.


--*/

{

	//
	//	Get standard streams.
	//
	_Standard_Input 	= Standard_Input_Stream;
	_Standard_Output	= Standard_Output_Stream;
	_Standard_Error 	= Standard_Error_Stream;

	//
	//	Initialize the message object
	//
    if ( _Standard_Output &&
           _Standard_Input &&
           _Message.Initialize( _Standard_Output, _Standard_Input, _Standard_Error ) ) {

		//
		//	Initialize message ids and error levels

		_UsageMsg	=	UsageMsg;
		_FatalMsg	=	FatalMsg;
		_FatalLevel =	FatalLevel;

		return TRUE;

	}

    _Standard_Input     = NULL;
    _Standard_Output    = NULL;
    _Standard_Error     = NULL;
    return FALSE;
}

ULIB_EXPORT
BOOLEAN
PROGRAM::DisplayMessage (
	IN	MSGID			Message,
	IN	MESSAGE_TYPE	Type
	) CONST

/*++

Routine Description:

	Displays a message

Arguments:

	Message -	Supplies the message id of the message to display
	Type	-	Supplies the type of message

Return Value:

	BOOLEAN -	Returns TRUE if message displayed,
				FALSE otherwise.


--*/

{
	return DisplayMessage( Message, Type, NULL );
}

ULIB_EXPORT
BOOLEAN
PROGRAM::DisplayMessage (
	IN	MSGID		 Message,
	IN	MESSAGE_TYPE Type,
	IN	PSTR		 Format,
	IN	...
	) CONST

/*++

Routine Description:

	Displays a message with arguments


Arguments:

	Message -	Supplies the message id of the message to display
	Type	-	Supplies the message type
	Format	-	Supplies a format string
	... 	-	Supplies list of arguments

Return Value:

	BOOLEAN -	Returns TRUE if message displayed,
				FALSE otherwise.

--*/

{

	va_list Arguments;
	BOOLEAN Status;

    if ( ((PPROGRAM) this)->_Message.Set( Message, Type ) ) {

		if ( !Format ) {

            return ((PPROGRAM) this)->_Message.Display( "" );

		} else {

			va_start( Arguments, Format );
            Status  = ((PPROGRAM) this)->_Message.DisplayV( Format, Arguments );
			va_end( Arguments );
			return Status;
		}
	}

	return FALSE;

}

ULIB_EXPORT
VOID
PROGRAM::ExitProgram (
	ULONG	Level
	)
{
	ExitProcess( Level );
}

ULIB_EXPORT
PSTREAM
PROGRAM::GetStandardInput (
	)

/*++

Routine Description

	Obtains the standard input stream

Arguments:

	None

Return Value:

	PSTREAM -	Returns the standard input stream

--*/

{

	return _Standard_Input;

}

ULIB_EXPORT
PSTREAM
PROGRAM::GetStandardOutput (
	)

/*++

Routine Description

	Obtains the standard output stream

Arguments:

	None

Return Value:

	PSTREAM -	Returns the standard output stream

--*/

{

	return _Standard_Output;

}


ULIB_EXPORT
PSTREAM
PROGRAM::GetStandardError (
	)

/*++

Routine Description

	Obtains the standard error stream

Arguments:

	None

Return Value:

	PSTREAM -	Returns the standard error stream

--*/

{

	return _Standard_Error;

}


ULIB_EXPORT
VOID
PROGRAM::Fatal (
	) CONST

/*++

Routine Description

	Displays the default fatal message and exits with the default
	fatal error level.

Arguments:

	None

Return Value:

	None

--*/

{

	Fatal( _FatalLevel, _FatalMsg, NULL	);

}

ULIB_EXPORT
VOID
PROGRAM::Fatal (
	IN	ULONG	ErrorLevel,
	IN	MSGID	Message,
	IN	PSTR	Format,
	IN	...
	) CONST

/*++

Routine Description:

	Displays a message (with arguments) and exits with the specified
	error level.

Arguments:

	ErrorLevel	-	Supplies the error level to exit with.
	Message 	-	Supplies the id of the message to display
	Format		-	Supplies the format string
	... 		-	Supply pointers to the arguments

Return Value:

	None

--*/

{
	va_list Arguments;

    if ( ((PPROGRAM) this)->_Message.Set( Message, ERROR_MESSAGE ) ) {

		if ( !Format ) {

            ((PPROGRAM) this)->_Message.Display( "" );

		} else {

			va_start( Arguments, Format );
            ((PPROGRAM) this)->_Message.DisplayV( Format, Arguments );

		}
	}

	ExitProcess( ErrorLevel );
}

ULIB_EXPORT
VOID
PROGRAM::Usage (
	) CONST

/*++

Routine Description:

	Displays the usage (help) message and exits with an error level of
	zero.

Arguments:

	None

Return Value:

	None

--*/

{
    ((PPROGRAM) this)->_Message.Set( _UsageMsg, NORMAL_MESSAGE );
    ((PPROGRAM) this)->_Message.Display();

	ExitProcess( 0 );
}

PPATH
PROGRAM::QueryImagePath (
    )

/*++

Routine Description:

	Queries the path to the program image (executable file)

Arguments:

	None

Return Value:

	PPATH	-	Returns a canonicalized path to the program image.

--*/

{
    WSTR     PathName[ MAX_PATH ];
	PPATH	Path;

	if (( GetModuleFileName( NULL, PathName, MAX_PATH ) != 0 )	&&
		(( Path = NEW PATH ) != NULL )							&&
		 Path->Initialize( PathName, TRUE )) {

		return Path;

	}

	return NULL;
}


ULIB_EXPORT
VOID
PROGRAM::ValidateVersion (
	IN	MSGID	InvalidVersionMsg,
	IN	ULONG	ErrorLevel
	) CONST

/*++

Routine Description:

	Validates the version, and if the version is invalid, exits the
	program.

Arguments:

	InvalidVersionMsg	-	Supplies id of message to display if the
							version number is incorrect.

	ErrorLevel			-	Supplies the error level with which to exit
							if the version number is incorrect.

Return Value:

	None (Only returns if is correct version).


--*/

{
	if ( !SYSTEM::IsCorrectVersion() ) {

		Fatal( ErrorLevel, InvalidVersionMsg, "" );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\smsg.cxx ===
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "smsg.hxx"
#include "array.hxx"
#include "arg.hxx"
#include "iterator.hxx"
#include "system.hxx"
#include "stream.hxx"
#include "keyboard.hxx"
#include "rtmsg.h"
#include "screen.hxx"


DEFINE_EXPORTED_CONSTRUCTOR(STREAM_MESSAGE, MESSAGE, ULIB_EXPORT)


VOID
STREAM_MESSAGE::Construct(
    )
/*++

Routine Description:

    Constructor for STREAM_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _msgtype = NORMAL_MESSAGE;
    _out_stream = NULL;
    _in_stream = NULL;
    _err_stream = NULL;
    _case_sensitive = FALSE;
    _copy_input = FALSE;
}


ULIB_EXPORT
STREAM_MESSAGE::~STREAM_MESSAGE(
    )
/*++

Routine Description:

    Destructor for STREAM_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


ULIB_EXPORT
BOOLEAN
STREAM_MESSAGE::Initialize(
    IN OUT  PSTREAM OutputStream,
    IN OUT  PSTREAM InputStream,
    IN OUT  PSTREAM ErrorStream
    )
/*++

Routine Description:

    This routine initializes the STREAM_MESSAGE object to the specified stream.

Arguments:

    OutputStream    - Supplies the output stream for the object.
    InputStream     - Supplies the input stream for the object.
    ErrorStream     - Supplies the error stream for the object.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    DebugAssert(OutputStream);
    DebugAssert(InputStream);

    _out_stream = OutputStream;
    _in_stream = InputStream;
    _err_stream = ErrorStream;
    _copy_input = SCREEN::Cast(OutputStream) ? FALSE : TRUE;


#ifdef FE_SB
    LANGID LangId;

    switch (GetConsoleOutputCP()) {
        case 932:
            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT );
            break;
        case 949:
            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN );
            break;
        case 936:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED );
            break;
        case 950:
            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL );
            break;
        default:
            LangId = PRIMARYLANGID(LANGIDFROMLCID( GetUserDefaultLCID() ));
            if (LangId == LANG_JAPANESE ||
                LangId == LANG_KOREAN   ||
                LangId == LANG_CHINESE    ) {
                LangId = MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
            }
            else {
                LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT );
            }
            break;
    }

    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
#endif

    return MESSAGE::Initialize();
}

ULIB_EXPORT
BOOLEAN
STREAM_MESSAGE::Set(
    IN  MSGID           MsgId,
    IN  MESSAGE_TYPE    MessageType,
    IN  ULONG           MessageVisual
    )
/*++

Routine Description:

    This routine sets up the class to display the message with the
    'MsgId' resource identifier.

Arguments:

    MsgId       - Supplies the resource id of the message.
    MessageType - Supplies the type of the message.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    SetMessageId(MsgId);
    _msgtype = MessageType;
    _msgvisual = MessageVisual;
    return TRUE;
}


BOOLEAN
STREAM_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style list format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (! (_msgvisual & TEXT_MESSAGE) )
    {
        return TRUE;
    }

    if (!SYSTEM::QueryResourceStringV(&_display_string,
                                      GetMessageId(),
                                      Format,
                                      VarPointer)) {
        return FALSE;
    }

    return DisplayString();
}


ULIB_EXPORT
BOOLEAN
STREAM_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries either a "yes" or "no" from the input stream.

Arguments:

    Default - Supplies the default answer if neither "yes" nor "no" is the
                recognized input.

Return Value:

    FALSE   - A "no" response.
    TRUE    - A "yes" response.

--*/
{
    DSTRING     input;
    DSTRING     yes_message;
    DSTRING     no_message;
    WCHAR       w;

    Flush();

    if (!SYSTEM::QueryResourceString(&yes_message, MSG_YES, "")) {
        return Default;
    }

    if (!SYSTEM::QueryResourceString(&no_message, MSG_NO, "")) {
        return Default;
    }

    for (;;) {
        if (!ReadLine(&input)) {
            return Default;
        }

        if (!input.Strupr()) {
            return Default;
        }

        w = input.QueryChAt(0);

        if (w == no_message.QueryChAt(0) || w == '0') {
            return FALSE;
        }

        if (w == yes_message.QueryChAt(0) || w == '1') {
            return TRUE;
        }

        DisplayString();
    }
}


BOOLEAN
STREAM_MESSAGE::QueryStringInput(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine queries a string from the user.

Arguments:

    String  - Supplies a buffer to return the string into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return ReadLine(String);
}


BOOLEAN
STREAM_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    This routine waits for a signal from the user.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING string;

    return (BOOLEAN) (Flush() && ReadLine(&string));
}


MSGID
STREAM_MESSAGE::SelectResponse(
    IN  ULONG   NumberOfSelections ...
    )
/*++

Routine Description:

    This routine queries input from the user in order to determine which
    message was entered.  It then returns the message id of the message
    entered.

Arguments:

    NumberOfSelections  - Supplies the number of message ids.
    ...                 - Supplies the message ids.

Return Value:

    The message id of the message entered, or the first message id.

--*/
{
    va_list             ap;
    ARRAY               lex_array;
    ARRAY               arg_array;
    PFLAG_ARGUMENT      flag_arg;
    ARGUMENT_LEXEMIZER  arg;
    DSTRING             input_string;
    MSGID               first;
    PITERATOR           arg_it;
    ULONG               i;
    DSTRING             match_string;
    DSTRING             del;

    va_start(ap, NumberOfSelections);
    first = va_arg(ap, MSGID);
    va_end(ap);

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return first;
    }

    if (!arg.Initialize(&lex_array)) {
        return first;
    }

    arg.SetCaseSensitive(_case_sensitive);

    va_start(ap, NumberOfSelections);
    for (i = 0; i < NumberOfSelections; i++) {
        SYSTEM::QueryResourceString(&match_string, va_arg(ap, MSGID), "");

        if (!(flag_arg = NEW FLAG_ARGUMENT) ||
            !flag_arg->Initialize(&match_string) ||
            !arg_array.Put(flag_arg)) {
            va_end(ap);
            return first;
        }
    }
    va_end(ap);

    Flush();

    if (!ReadLine(&input_string)) {
        return first;
    }

    if (!arg.PrepareToParse(&input_string)) {
        return first;
    }

    if (!arg.DoParsing(&arg_array)) {
        return first;
    }

    arg_it = arg_array.QueryIterator();
    va_start(ap, NumberOfSelections);
    for (i = 0; i < NumberOfSelections; i++) {
        flag_arg = (PFLAG_ARGUMENT) arg_it->GetNext();
        if (flag_arg->QueryFlag()) {
            first = va_arg(ap, MSGID);
        } else {
            va_arg(ap, MSGID) ? 1 : 0;
        }
        DELETE(flag_arg);
    }
    va_end(ap);

    DELETE(arg_it);

    return first;
}


PMESSAGE
STREAM_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MSG object.

--*/
{
    PSTREAM_MESSAGE   p;

    if (!(p = NEW STREAM_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize(_out_stream, _in_stream)) {
        DELETE(p);
        return NULL;
    }

    return p;
}


VOID
STREAM_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns an STREAM_MESSAGE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _msgtype = NORMAL_MESSAGE;
    _out_stream = NULL;
    _in_stream = NULL;
    _err_stream = NULL;
    _case_sensitive = FALSE;
    _copy_input = FALSE;
}


BOOLEAN
STREAM_MESSAGE::ReadLine(
    OUT PWSTRING    String
    )
/*++

Routine Description:

    This routine reads a line from the input stream.

Arguments:

    String  - Returns the read in string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING del;
    WCHAR   w;

    if (!del.Initialize("\r\n")) {
        return FALSE;
    }

    if (_in_stream->IsAtEnd()) {
        return FALSE;
    }

    String->Initialize( "" );

    if (!_in_stream->ReadString(String, &del)) {
        return FALSE;
    }

    // Line feed is the last character on the line.

    for (;;) {
        if (_in_stream->IsAtEnd()) {
            return TRUE;
        }

        if (!_in_stream->ReadChar(&w)) {
            return FALSE;
        }

        if (w == '\n') {
            break;
        }
    }

    if (_copy_input) {
        _out_stream->WriteString(String, 0, String->QueryChCount());
        _out_stream->WriteString(&del, 0, del.QueryChCount());
    }

    return TRUE;
}


BOOLEAN
STREAM_MESSAGE::Flush(
    )
/*++

Routine Description:

    This routine flushes the input stream of all previously typed input.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PKEYBOARD   key;

    if (key = KEYBOARD::Cast(_in_stream)) {
        return key->Flush();
    }

    return TRUE;
}


BOOLEAN
STREAM_MESSAGE::DisplayString(
    )
/*++

Routine Description:

    This routine prints this objects current string to the
    appropriate output.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTREAM stream;

    if (! (_msgvisual & TEXT_MESSAGE) )
    {
        return TRUE;
    }

    if (_msgtype == ERROR_MESSAGE && _err_stream) {
        stream = _err_stream;
    } else {
        stream = _out_stream;
    }

    if (!stream->WriteString(&_display_string, 0, TO_END, 40)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\screen.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    screen.cxx

Abstract:

    This module contains the definitions of the member functions
    of SCREEN class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "stream.hxx"
#include "screen.hxx"


DEFINE_EXPORTED_CONSTRUCTOR ( SCREEN, STREAM, ULIB_EXPORT );

DEFINE_EXPORTED_CAST_MEMBER_FUNCTION( SCREEN, ULIB_EXPORT );


ULIB_EXPORT
SCREEN::~SCREEN (
    )

/*++

Routine Description:

    Destroy a SCREEN (closes the screen handle).

Arguments:

    None.

Return Value:

    None.

--*/

{
    CloseHandle( _ScreenHandle );
}



BOOLEAN
SCREEN::Initialize(
    IN BOOLEAN  CurrentActiveScreen,
    IN USHORT   NumberOfRows,
    IN USHORT   NumberOfColumns,
    IN USHORT   TextAttribute,
    IN BOOLEAN  ExpandAsciiControlSequence,
    IN BOOLEAN  WrapAtEndOfLine
    )

/*++

Routine Description:

    Initializes an object of type SCREEN.

Arguments:

    CurrentActiveScreen - Indicates if the client wants to use the screen
                          currently displayed (TRUE), or if a new screen
                          buffer is to be created (FALSE).

    NumberOfRows - Number of rows in the screen.

    NumberOfColumns - Number of columns in the screen.

    TextAttribute - Indicates the default text attribute.

    ExpandAsciiControlSequence - Indicates if expansion of ASCII control
                                 sequences is allowed.

    WrapAtEndOfLine - Indicates if wrap at the end of a line is allowed.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{


    if( CurrentActiveScreen ) {
            _ScreenHandle = CreateFile( (LPWSTR)L"CONOUT$",
                                            GENERIC_READ | GENERIC_WRITE,
                                            0,
                                            NULL,
                                            OPEN_EXISTING,
                                            0,
                                            NULL );
    } else {
                _ScreenHandle = CreateConsoleScreenBuffer(GENERIC_WRITE | GENERIC_READ,
                                            0,
                                            NULL,
                                            CONSOLE_TEXTMODE_BUFFER,
                                            NULL );
    }


    if( _ScreenHandle == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    if( !GetConsoleMode( _ScreenHandle, (LPDWORD)&_ScreenMode ) ) {
        return( FALSE );
    }
    if( ExpandAsciiControlSequence ) {
        _ScreenMode |= ENABLE_PROCESSED_OUTPUT;
        } else {
                _ScreenMode &= ~ENABLE_PROCESSED_OUTPUT;
        }
    if( WrapAtEndOfLine ) {
        _ScreenMode |= ENABLE_WRAP_AT_EOL_OUTPUT;
        } else {
                _ScreenMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;
        }
    if( !ChangeScreenSize( NumberOfRows, NumberOfColumns ) ) {
        return( FALSE );
    }
    if( !ChangeTextAttribute( TextAttribute ) ) {
        return( FALSE );
    }
    if( !SetConsoleMode( _ScreenHandle, _ScreenMode ) ) {
        return( FALSE );
    }
    return( STREAM::Initialize() );
}



ULIB_EXPORT
BOOLEAN
SCREEN::Initialize(
    )

/*++

Routine Description:

    Initializes an object of type SCREEN with default values.
    This object will access the screen currently active, and all
    values such as number of rows, columns, attributes, and mode
    will be the ones defined in the currently active screen.


Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

        _ScreenHandle = CreateFile( (LPWSTR)L"CONOUT$",
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );
    if( _ScreenHandle == (HANDLE)-1 ) {
        return( FALSE );
    }

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    if( !GetConsoleMode( _ScreenHandle, (LPDWORD)&_ScreenMode ) ) {
        return( FALSE );
    }
    _TextAttribute = ScreenBufferInfo.wAttributes;
    return( STREAM::Initialize() );
}




ULIB_EXPORT
BOOLEAN
SCREEN::ChangeScreenSize(
    IN  USHORT   NumberOfRows,
    IN  USHORT   NumberOfColumns,
    OUT PBOOLEAN IsFullScreen
    )

/*++

Routine Description:

    Changes the screen buffer size to the specified number of rows and
    columns. And sets the window size accordingly.

Arguments:

    NumberOfRows - Number of rows in the screen.

    NumberOfColumns - Number of columns in the screen.

    IsFullScreen    - TRUE if in full screen mode.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/

{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;
    SMALL_RECT                  ScreenRect;
    COORD                       ScreenSize;
    COORD                       LargestScreenSize;
    USHORT                      MaxRows;
    USHORT                      MaxCols;
    BOOLEAN                     WindowSet = FALSE;

    //
    //  Clear the screen
    //
    MoveCursorTo(0, 0);
    EraseScreen();

    if ( IsFullScreen ) {
        *IsFullScreen = FALSE;
    }

    //
    //  We obtain the current screen information.
    //
    if ( GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {

        //
        //  Set the Window Size. The new size is the minimum of the
        //  buffer size or the screen size.
        //
        LargestScreenSize = GetLargestConsoleWindowSize( _ScreenHandle );

        if ( (LargestScreenSize.X == 0) && (LargestScreenSize.Y == 0) ) {

            if ( IsFullScreen && (GetLastError() == ERROR_FULLSCREEN_MODE) ) {
                *IsFullScreen = TRUE;
            }
            return FALSE;
        }

        //
        //  If the desired window size is smaller than the current window
        //  size, we have to resize the current window first. (The buffer
        //  size cannot be smaller than the window size)
        //
        if ( ( NumberOfRows < (USHORT)
                              (ScreenBufferInfo.srWindow.Bottom -
                               ScreenBufferInfo.srWindow.Top + 1) ) ||
             ( NumberOfColumns < (USHORT)
                                 (ScreenBufferInfo.srWindow.Right -
                                  ScreenBufferInfo.srWindow.Left + 1) ) ) {


            //
            //  Set the window to a size that will fit in the current
            //  screen buffer and that is no bigger than the size to
            //  which we want to grow the screen buffer or the largest window
            //  size.
            //
            MaxRows = (USHORT)min( (int)NumberOfRows, (int)(ScreenBufferInfo.dwSize.Y) );
            MaxRows = (USHORT)min( (int)MaxRows, (int)LargestScreenSize.Y );
            MaxCols = (USHORT)min( (int)NumberOfColumns, (int)(ScreenBufferInfo.dwSize.X) );
            MaxCols = (USHORT)min( (int)MaxCols, (int)LargestScreenSize.X );

            ScreenRect.Top      = 0;
            ScreenRect.Left     = 0;
            ScreenRect.Right    = MaxCols - (SHORT)1;
            ScreenRect.Bottom   = MaxRows - (SHORT)1;

            WindowSet = (BOOLEAN)SetConsoleWindowInfo( _ScreenHandle, TRUE, &ScreenRect );

            if ( !WindowSet ) {

                DebugPrintTrace(( "MODE: SetConsoleWindowInfo failed. Error %d\n", GetLastError() ));
                if ( IsFullScreen && (GetLastError() == ERROR_FULLSCREEN_MODE) ) {
                    *IsFullScreen = TRUE;
                }
                return FALSE;
            }
        }

        //
        //  Set the screen buffer size to the desired size.
        //
        ScreenSize.X = NumberOfColumns;
        ScreenSize.Y = NumberOfRows;

        if ( !SetConsoleScreenBufferSize( _ScreenHandle, ScreenSize ) ) {

            DebugPrintTrace(( "MODE: SetConsoleScreenBufferSize failed (Y:%d X:%d ) Error: %d\n",
                        ScreenSize.Y, ScreenSize.X, GetLastError() ));

            if ( IsFullScreen && (GetLastError() == ERROR_FULLSCREEN_MODE) ) {
                *IsFullScreen = TRUE;
            }

            //
            //  Return the window to its original size. We ignore the return
            //  code because there is nothing we can do about it.
            //
            if ( !SetConsoleWindowInfo( _ScreenHandle, TRUE, &(ScreenBufferInfo.srWindow) )) {
                DebugPrintTrace(( "MODE: SetConsoleWindowInfo (2) failed. Error %d\n", GetLastError() ));

            }

            return FALSE;
        }

        MaxRows = (USHORT)min( (int)NumberOfRows, (int)(LargestScreenSize.Y) );
        MaxCols = (USHORT)min( (int)NumberOfColumns, (int)(LargestScreenSize.X) );

        ScreenRect.Top      = 0;
        ScreenRect.Left     = 0;
        ScreenRect.Right    = MaxCols - (SHORT)1;
        ScreenRect.Bottom   = MaxRows - (SHORT)1;

        WindowSet = (BOOLEAN)SetConsoleWindowInfo( _ScreenHandle, TRUE, &ScreenRect );

        if ( !WindowSet ) {
            //
            //  We could not resize the window. We will leave the
            //  resized screen buffer.
            //
            DebugPrintTrace(( "MODE: SetConsoleWindowInfo (3) failed. Error %d\n", GetLastError() ));
            return FALSE;
        }

        return TRUE;

    } else {

        DebugPrintTrace(( "ULIB: Cannot get console screen buffer info, Error = %X\n", GetLastError() ));
    }

    return FALSE;
}




BOOLEAN
SCREEN::ChangeTextAttribute(
    IN USHORT   Attribute
    )

/*++

Routine Description:

    Set the attribute to be used when text is written using WriteFile()
    (ie, when the stream API is used ).

Arguments:

    Attribute - Attribute to be used

Return Value:

    BOOLEAN - Indicates if the initialization succeeded.


--*/

{
    _TextAttribute = Attribute;
    return( SetConsoleTextAttribute( _ScreenHandle, Attribute ) != FALSE );
}



BOOLEAN
SCREEN::EnableAsciiControlSequence(
    )

/*++

Routine Description:

    Set the screen in the line mode (allows expansion of control ASCII
    sequences);

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    if( _ScreenMode & ENABLE_PROCESSED_OUTPUT ) {
        return( TRUE );
    }
    _ScreenMode |= ENABLE_PROCESSED_OUTPUT;
    return( SetConsoleMode( _ScreenHandle, _ScreenMode ) != FALSE );
}



BOOLEAN
SCREEN::DisableAsciiControlSequence(
    )

/*++

Routine Description:

    Set the screen in the character mode (does not expansion of control
    ASCII sequences);

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    if( !( _ScreenMode & ENABLE_PROCESSED_OUTPUT ) ) {
        return( TRUE );
    }
    _ScreenMode &= ~(ENABLE_PROCESSED_OUTPUT);
    return( SetConsoleMode( _ScreenHandle, _ScreenMode ) != FALSE );
}



BOOLEAN
SCREEN::EnableWrapMode(
    )

/*++

Routine Description:

    Sets the screen in the wrap mode (characters are written in the next
    line when cursor reaches the end of a line).

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    if( _ScreenMode & ENABLE_WRAP_AT_EOL_OUTPUT ) {
        return( TRUE );
    }
    _ScreenMode |= ENABLE_WRAP_AT_EOL_OUTPUT;
    return( SetConsoleMode( _ScreenHandle, _ScreenMode ) != FALSE );
}



BOOLEAN
SCREEN::DisableWrapMode(
    )

/*++

Routine Description:

    Disables the wrap mode (cursor does not move to the beginning of
    the next line when it reaches the eand of a line).

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    if( !( _ScreenMode & ENABLE_WRAP_AT_EOL_OUTPUT ) ) {
        return( TRUE );
    }
    _ScreenMode &= ~ENABLE_WRAP_AT_EOL_OUTPUT;
    return( SetConsoleMode( _ScreenHandle, _ScreenMode ) != FALSE );
}



BOOLEAN
SCREEN::IsAtEnd(
    ) CONST

/*++

Routine Description:

    Determines if the cursor is at the end of the screen.

Arguments:

    None.


Return Value:

    BOOLEAN - Indicates if the cursor is at the end of the screen.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );
    return( ( ScreenBufferInfo.dwCursorPosition.X ==
              ScreenBufferInfo.dwSize.X ) &&
            ( ScreenBufferInfo.dwCursorPosition.Y ==
              ScreenBufferInfo.dwSize.Y ) );
}



BOOLEAN
SCREEN::SetScreenActive(
    )

/*++

Routine Description:

    Makes the screen buffer defined in this class active.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    return( SetConsoleActiveScreenBuffer( _ScreenHandle ) != FALSE );
}




ULIB_EXPORT
BOOLEAN
SCREEN::MoveCursorTo(
    IN USHORT   Row,
    IN USHORT   Column
    )

/*++

Routine Description:

    Moves the cursor to a particular position in the screen

Arguments:

    USHORT - Row where the cursor is to be moved to.

    USHORT - Column where the cursor is to be moved to.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   CursorPosition;

    CursorPosition.Y = Row;
    CursorPosition.X = Column;
    return( SetConsoleCursorPosition( _ScreenHandle, CursorPosition ) != FALSE );
}



BOOLEAN
SCREEN::MoveCursorDown(
    IN USHORT   Rows
    )

/*++

Routine Description:

    Moves the cursor down by a number of lines, keeping it in the same
    column.

Arguments:

    Rows - Number of lines to move the cursor.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( MoveCursorTo( ScreenBufferInfo.dwCursorPosition.Y + Rows,
                          ScreenBufferInfo.dwCursorPosition.X ) );
}



BOOLEAN
SCREEN::MoveCursorUp(
    IN USHORT   Rows
    )

/*++

Routine Description:

    Moves the cursor up by a number of lines, keeping it in the same
    column.

Arguments:

    Rows - Number of lines to move the cursor.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( MoveCursorTo( ScreenBufferInfo.dwCursorPosition.Y - Rows,
                          ScreenBufferInfo.dwCursorPosition.X ) );
}



BOOLEAN
SCREEN::MoveCursorRight(
    IN USHORT   Columns
    )

/*++

Routine Description:

    Moves the cursor right by a number of columns, keeping it in the same
    line.

Arguments:

    Columns - Number of columns to move the cursor.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( MoveCursorTo( ScreenBufferInfo.dwCursorPosition.Y,
                          ScreenBufferInfo.dwCursorPosition.X + Columns ) );
}



BOOLEAN
SCREEN::MoveCursorLeft(
    IN USHORT   Columns
    )

/*++

Routine Description:

    Moves the cursor left by a number of columns, keeping it in the same
    line.

Arguments:

    Columns - Number of columns to move the cursor.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( MoveCursorTo( ScreenBufferInfo.dwCursorPosition.Y,
                          ScreenBufferInfo.dwCursorPosition.X - Columns ) );
}




ULIB_EXPORT
DWORD
SCREEN::QueryCodePage(
    )

/*++

Routine Description:

    Obtains the current console code page.

Arguments:

    None


Return Value:

    The current console code page.


--*/


{
    return GetConsoleCP( );
}


DWORD
SCREEN::QueryOutputCodePage(
    )

/*++

Routine Description:

    Obtains the current console code page.

Arguments:

    None


Return Value:

    The current console code page.


--*/


{
    return GetConsoleOutputCP( );
}


BOOLEAN
SCREEN::QueryCursorPosition(
    OUT PUSHORT Row,
    OUT PUSHORT Column
    )

/*++

Routine Description:

    Returns to the caller the current position of the cursor.

Arguments:

    Row - Address of the variable that will contain the row.

    Column - Address of the variable that will contain the column.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }

    *Row = ScreenBufferInfo.dwCursorPosition.Y;
    *Column = ScreenBufferInfo.dwCursorPosition.X;
    return( TRUE );
}



ULIB_EXPORT
BOOLEAN
SCREEN::SetCodePage(
    IN DWORD    CodePage
    )

/*++

Routine Description:

    Sets the console codepage.

Arguments:


    CodePage    -   New codepage


Return Value:

    BOOLEAN - TRUE if codepage set, FALSE otherwise (most probably the
              codepage is invalid).


--*/


{
    return SetConsoleCP( CodePage ) != FALSE;
}


ULIB_EXPORT
BOOLEAN
SCREEN::SetOutputCodePage(
    IN DWORD    CodePage
    )

/*++

Routine Description:

    Sets the console output codepage.

Arguments:


    CodePage    -   New codepage


Return Value:

    BOOLEAN - TRUE if codepage set, FALSE otherwise (most probably the
              codepage is invalid).


--*/


{
    return SetConsoleOutputCP( CodePage ) != FALSE;
}


BOOLEAN
SCREEN::SetCursorSize(
    IN ULONG    Size
    )

/*++

Routine Description:

    Sets the size of the cursor.

Arguments:

    Size - A number in the range 1-100 that indicates the percentage of
            character cell to be filled.


Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_CURSOR_INFO CursorInfo;

    if( !GetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) ) {
        return( FALSE );
    }
    CursorInfo.dwSize = Size;
    return( SetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) != FALSE );
}



BOOLEAN
SCREEN::SetCursorOff(
    )

/*++

Routine Description:

    Turns off the cursor.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_CURSOR_INFO CursorInfo;

    if( !GetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) ) {
        return( FALSE );
    }
    CursorInfo.bVisible = FALSE;
    return( SetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) != FALSE );
}



BOOLEAN
SCREEN::SetCursorOn(
    )

/*++

Routine Description:

    Turns on the cursor.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_CURSOR_INFO CursorInfo;

    if( !GetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) ) {
        return( FALSE );
    }
    CursorInfo.bVisible = TRUE;
    return( SetConsoleCursorInfo( _ScreenHandle, &CursorInfo ) != FALSE );
}



BOOLEAN
SCREEN::FillRegionCharacter(
    IN USHORT   StartRow,
    IN USHORT   StartColumn,
    IN USHORT   EndRow,
    IN USHORT   EndColumn,
    IN CHAR     Character
    )

/*++

Routine Description:

    Fills a region in the screen with a particular character. Attributes
    in this region are not changed.

Arguments:

    StartRow - Row where the region starts.

    StartColumn - Column where the region starts.

    EndRow - Row where the region ends.

    EndColumn - Column where the region ends.

    Character - Character to fill the region.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   Origin;
    ULONG   Length;
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;
    ULONG   Columns;
    ULONG   NumberOfCharsWritten;


    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );
    Columns = ScreenBufferInfo.dwSize.X;

    if( EndRow == StartRow ) {
        Length = EndColumn - StartColumn + 1;
    } else {
        Length = Columns - StartColumn +
                 Columns*( EndRow - StartRow - 1 ) +
                 EndColumn + 1;
    }
    Origin.Y = StartRow;
    Origin.X = StartColumn;
    if( !FillConsoleOutputCharacter( _ScreenHandle,
                                     Character,
                                     Length,
                                     Origin,
                                     &NumberOfCharsWritten ) ||
        NumberOfCharsWritten != Length) {
        return( FALSE );
    }
    return( TRUE );
}



BOOLEAN
SCREEN::FillRectangularRegionCharacter(
    IN USHORT   TopLeftRow,
    IN USHORT   TopLeftColumn,
    IN USHORT   BottomRightRow,
    IN USHORT   BottomRightColumn,
    IN CHAR     Character
    )

/*++

Routine Description:

    Fills a rectangular region in the screen with a particular character.
    Attributes in this region are not changed.

Arguments:

    TopLeftRow - Row where the region starts.

    TopLeftColumn - Column where the region starts.

    BottomRightRow - Row where the region ends.

    BottomeRightColumn - Column where the region ends.

    Character - Character to fill the region.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   Origin;
    ULONG   Length;
    ULONG   NumberOfRows;
    ULONG   NumberOfCharsWritten;

    NumberOfRows = BottomRightRow - TopLeftRow + 1;
    Length = BottomRightColumn - TopLeftColumn + 1;
    Origin.X = TopLeftColumn;
    Origin.Y = TopLeftRow;
    while( NumberOfRows-- ) {
        if( !FillConsoleOutputCharacter( _ScreenHandle,
                                         Character,
                                         Length,
                                         Origin,
                                         &NumberOfCharsWritten ) ||
            NumberOfCharsWritten != Length ) {
            return( FALSE );
        }
        Origin.Y++;
    }
    return( TRUE );
}



BOOLEAN
SCREEN::FillRegionAttribute(
    IN USHORT   StartRow,
    IN USHORT   StartColumn,
    IN USHORT   EndRow,
    IN USHORT   EndColumn,
    IN USHORT   Attribute
    )

/*++

Routine Description:

    Fills a region in the screen with a particular attribute. Characters
    in this region are not changed.

Arguments:

    StartRow - Row where the region starts.

    StartColumn - Column where the region starts.

    EndRow - Row where the region ends.

    EndColumn - Column where the region ends.

    Attribute - Attribute to fill the region.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   Origin;
    ULONG   Length;
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;
    ULONG   Columns;
    ULONG   NumberOfAttrsWritten;


    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );
    Columns = ScreenBufferInfo.dwSize.X;

    if( EndRow == StartRow ) {
        Length = EndColumn - StartColumn + 1;
    } else {
        Length = Columns - StartColumn +
                 Columns*( EndRow - StartRow - 1 ) +
                 EndColumn + 1;
    }
    Origin.Y = StartRow;
    Origin.X = StartColumn;
    if( !FillConsoleOutputAttribute( _ScreenHandle,
                                     Attribute,
                                     Length,
                                     Origin,
                                     &NumberOfAttrsWritten ) ||
        NumberOfAttrsWritten != Length ) {
        return( FALSE );
    }
    return( TRUE );
}



BOOLEAN
SCREEN::FillRectangularRegionAttribute(
    IN USHORT   TopLeftRow,
    IN USHORT   TopLeftColumn,
    IN USHORT   BottomRightRow,
    IN USHORT   BottomRightColumn,
    IN USHORT   Attribute
    )

/*++

Routine Description:

    Fills a rectangular region in the screen with a particular attribute.
    Characters in this region are not changed.

Arguments:

    TopLeftRow - Row where the region starts.

    TopLeftColumn - Column where the region starts.

    BottomRighhtRow - Row where the region ends.

    BottomRightColumn - Column where the region ends.

    Attribute - Attribute used to fill the region.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    COORD   Origin;
    ULONG   Length;
    ULONG   NumberOfRows;
    ULONG   NumberOfAttrsWritten;

    NumberOfRows = BottomRightRow - TopLeftRow + 1;
    Length = BottomRightColumn - TopLeftColumn + 1;
    Origin.X = TopLeftColumn;
    Origin.Y = TopLeftRow;
    while( NumberOfRows-- ) {
        if( !FillConsoleOutputAttribute( _ScreenHandle,
                                         Attribute,
                                         Length,
                                         Origin,
                                         &NumberOfAttrsWritten ) ||
            NumberOfAttrsWritten != Length ) {
            return( FALSE );
        }
        Origin.Y++;
    }
    return( TRUE );
}



BOOLEAN
SCREEN::EraseLine(
    IN USHORT   LineNumber
    )

/*++

Routine Description:

    Erases a line in the screen.

Arguments:

    LineNumber - Line number.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( FillRegionCharacter( LineNumber,
                                 0,
                                 LineNumber,
                                 ScreenBufferInfo.dwSize.X - 1,
                                 0x20 ) );
}



BOOLEAN
SCREEN::EraseToEndOfLine(
    )

/*++

Routine Description:

    Erases the current line from the cursor position to the end of line.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    return( FillRegionCharacter( ScreenBufferInfo.dwCursorPosition.Y,
                                 ScreenBufferInfo.dwCursorPosition.X,
                                 ScreenBufferInfo.dwCursorPosition.Y,
                                 ScreenBufferInfo.dwSize.X - 1,
                                 0x20 ) );
}



ULIB_EXPORT
BOOLEAN
SCREEN::EraseScreen(
    )

/*++

Routine Description:

    Erases all characters in the screen. Attributes are not changed.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );
    return( FillRegionCharacter( 0,
                                 0,
                                 ScreenBufferInfo.dwSize.Y - 1,
                                 ScreenBufferInfo.dwSize.X - 1,
                                 0x20 ) );
}



ULIB_EXPORT
VOID
SCREEN::QueryScreenSize(
    OUT PUSHORT NumberOfRows,
    OUT PUSHORT NumberOfColumns,
    OUT PUSHORT WindowRows,
    OUT PUSHORT WindowColumns
    ) CONST

/*++

Routine Description:

    Returns to the caller the screen size, and optionally the window
    size.

Arguments:

    NumberOfRows    - Points to the variable that will contain the
                      number of rows

    NumberOfColumns - Points to the variable that will contain the
                      number of columns

    WindowRows      - Points to the variable that will contain the number
                      of rows in the window

    WindowColumns   - Points to the variable that will contain the number
                      of columns in the window

Return Value:

    None.


--*/


{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );

    //
    //  Get screen buffer size
    //
    *NumberOfRows = ScreenBufferInfo.dwSize.Y;
    *NumberOfColumns = ScreenBufferInfo.dwSize.X;

    //
    //  Get window size
    //
    if ( WindowRows && WindowColumns ) {
        *WindowColumns  = ScreenBufferInfo.srWindow.Right - ScreenBufferInfo.srWindow.Left + 1;
        *WindowRows     = ScreenBufferInfo.srWindow.Bottom - ScreenBufferInfo.srWindow.Top + 1;
    }
}




BOOLEAN
SCREEN::ScrollScreen(
    IN  USHORT              Amount,
    IN  SCROLL_DIRECTION    Direction
    )

/*++

Routine Description:

    Scrolls the screen.

Arguments:

    Amount - Number of rows or columns to scroll.

    Direction - Indicates if up, down, left or right.

Return Value:

    BOOLEAN - Returns TRUE if the screen was scrolled. FALSE otherwise.


--*/


{
    UNREFERENCED_PARAMETER( Amount );
    UNREFERENCED_PARAMETER( Direction );

/*
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;
    CONSOLE_SCROLL_INFO         ConsoleScrollInfo;

    if( !GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo ) ) {
        return( FALSE );
    }
    switch( Direction ) {

    case SCROLL_UP:

        ConsoleScrollInfo.ScrollRectangle.Left = 0;
        ConsoleScrollInfo.ScrollRectangle.Top = Amount;
        ConsoleScrollInfo.ScrollRectangle.Right =
                                ( SHORT )( ScreenBufferInfo.dwSize.X - 1 );
        ConsoleScrollInfo.ScrollRectangle.Bottom =
                                ( SHORT )( ScreenBufferInfo.dwSize.Y - 1 );
        ConsoleScrollInfo.dwDestinationOrigin.X = 0;
        ConsoleScrollInfo.dwDestinationOrigin.Y = 0;
        break;


    case SCROLL_DOWN:

        ConsoleScrollInfo.ScrollRectangle.Left = 0;
        ConsoleScrollInfo.ScrollRectangle.Top = 0;
        ConsoleScrollInfo.ScrollRectangle.Right =
                                ( SHORT )( ScreenBufferInfo.dwSize.X - 1 );
        ConsoleScrollInfo.ScrollRectangle.Bottom =
                                ( SHORT )( ScreenBufferInfo.dwSize.Y - Amount - 1 );
        ConsoleScrollInfo.dwDestinationOrigin.X = 0;
        ConsoleScrollInfo.dwDestinationOrigin.Y = Amount;
        break;


    case SCROLL_LEFT:

        ConsoleScrollInfo.ScrollRectangle.Left = Amount;
        ConsoleScrollInfo.ScrollRectangle.Top = 0;
        ConsoleScrollInfo.ScrollRectangle.Right =
                                ( SHORT )( ScreenBufferInfo.dwSize.X - 1 );
        ConsoleScrollInfo.ScrollRectangle.Bottom =
                                ( SHORT )( ScreenBufferInfo.dwSize.Y - 1 );
        ConsoleScrollInfo.dwDestinationOrigin.X = 0;
        ConsoleScrollInfo.dwDestinationOrigin.Y = 0;
        break;


    case SCROLL_RIGHT:

        ConsoleScrollInfo.ScrollRectangle.Left = 0;
        ConsoleScrollInfo.ScrollRectangle.Top = 0;
        ConsoleScrollInfo.ScrollRectangle.Right =
                                ( SHORT )( ScreenBufferInfo.dwSize.X - Amount - 1 );
        ConsoleScrollInfo.ScrollRectangle.Bottom =
                                ( SHORT )( ScreenBufferInfo.dwSize.Y - 1 );
        ConsoleScrollInfo.dwDestinationOrigin.X = Amount;
        ConsoleScrollInfo.dwDestinationOrigin.Y = 0;
        break;

    }

    ConsoleScrollInfo.Fill.Char.AsciiChar = 0x20;
    ConsoleScrollInfo.Fill.Attributes = ScreenBufferInfo.wAttributes;
    return( ScrollConsoleScreenBuffer( _ScreenHandle,
                                       &ConsoleScrollInfo ) );
*/
//
//  jaimes - 07/08/91
//  ScrollConsoleScreenBuffer has chaged
//
return TRUE;
}



BOOLEAN
SCREEN::Read(
            OUT PBYTE   Buffer,
            IN  ULONG   BytesToRead,
            OUT PULONG  BytesRead
    )

/*++

Routine Description:

    Reads bytes from the screen stream.

Arguments:

    Buffer - Points that will receive the bytes read.

    BytesToRead - Number of bytes to read (buffer size)

    BytesRead - Points to the variable that will contain the total
                number of bytes read.

Return Value:

    Returns always FALSE since no data can be read from a screen stream.


--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(Buffer);
    (void)(BytesToRead);
    (void)(BytesRead);

    return( FALSE );
}



BOOLEAN
SCREEN::ReadChar(
    OUT PWCHAR          Char,
        IN  BOOLEAN  Unicode
    )

/*++

Routine Description:

    Reads a character from the screen stream.

Arguments:

    Char    -   Supplies poinbter to wide character

Return Value:

    Returns always FALSE since no data can be read from a screen stream.


--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(Char);
    (void)(Unicode);

    return( FALSE );
}



BOOLEAN
SCREEN::ReadMbString(
    IN      PSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:


Arguments:


Return Value:



--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(String);
    (void)(BufferSize);
    (void)(StringSize);
    (void)(Delimiters);
    (void)(ExpandTabs);
    (void)(TabExp);

    return( FALSE );
}



BOOLEAN
SCREEN::ReadWString(
    IN      PWSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      PWSTR    Delimiters,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
    )

/*++

Routine Description:


Arguments:


Return Value:



--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(String);
    (void)(BufferSize);
    (void)(StringSize);
    (void)(Delimiters);
    (void)(ExpandTabs);
    (void)(TabExp);

    return( FALSE );
}



BOOLEAN
SCREEN::ReadString(
    OUT PWSTRING        String,
    IN  PWSTRING        Delimiter,
        IN  BOOLEAN  Unicode
    )

/*++

Routine Description:

    Reads a STRING from the screen stream.

Arguments:

    String - Pointer to a WSTRING object that will contain the string read.

    Delimiter - Pointer to a WSTRING object that contains the delimiters
                of a string

Return Value:

    Returns always FALSE since no data can be read from a screen stream.


--*/


{
    // unreferenced parameters
    (void)(this);
    (void)(String);
    (void)(Delimiter);
    (void)(Unicode);

    return( FALSE );
}



STREAMACCESS
SCREEN::QueryAccess(
    ) CONST

/*++

Routine Description:

    Returns the access to the screen stream.

Arguments:

    None.

Return Value:

    Returns always WRITE_ACCESS.


--*/


{
    (void)(this);
    return( WRITE_ACCESS );
}



HANDLE
SCREEN::QueryHandle(
    ) CONST

/*++

Routine Description:

    Returns the handle to the screen.

Arguments:

    None.

Return Value:

    Returns a handle.


--*/


{
    return( _ScreenHandle );
}


#if 0
// TMPTMP just for debug.

#include <stdio.h>
#endif




BOOLEAN
SCREEN::WriteString(
    IN PCWSTRING    String,
    IN CHNUM        Position,
    IN CHNUM        Length,
    IN CHNUM        Granularity
    )

/*++

Routine Description:

    Writes a string to the screen.

Arguments:

    String      - Pointer to a STRING object.
    Position    - Starting character within the string
    Length      - Number of characters to write
    Granularity - The maximum number of bytes to write at one time.
                    A value of 0 indicates to write it all at once.

Return Value:

    BOOLEAN - Returns TRUE if the write operation succeeded.


--*/


{
    ULONG   i, n, written, to_write;
    PCWSTR  p;
    BOOLEAN r;
    HANDLE  h;

    DebugAssert(Position <= String->QueryChCount());

    n = min(String->QueryChCount() - Position, Length);
    p = String->GetWSTR() + Position;
    h = QueryHandle();

    if (!Granularity) {
        Granularity = n;
    }

    r = TRUE;
    for (i = 0; r && i < n; i += Granularity) {

        to_write = min(Granularity, n - i);

        r = WriteConsole(h, p + i, to_write,
                         &written, NULL) &&
            to_write == written;
    }

    return r;
}


BOOLEAN
SCREEN::WriteChar(
    IN  WCHAR   Char
    )
/*++

Routine Description:

    This routine writes a character to the output.  This routine
    uses WriteConsoleW to avoid having to make the translation
    from wide to narrow characters.

Arguments:

    Char    - Supplies the character to write.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    ULONG   written;

    if (!WriteConsole(QueryHandle(), &Char, 1, &written, NULL) ||
        written != 1) {

        return FALSE;
    }

    return TRUE;
}

#ifdef FE_SB

BOOLEAN
SCREEN::EraseScreenAndResetAttribute(
    )

/*++

Routine Description:

    Erases all characters in the screen. Attributes are also reset.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the operation succeeded.


--*/

{
    CONSOLE_SCREEN_BUFFER_INFO  ScreenBufferInfo;

    GetConsoleScreenBufferInfo( _ScreenHandle, &ScreenBufferInfo );

    return (
        FillRegionCharacter(
                0,
                0,
                ScreenBufferInfo.dwSize.Y - 1,
                ScreenBufferInfo.dwSize.X - 1,
                0x20
                )
        &&
        FillRegionAttribute(
                0,
                0,
                ScreenBufferInfo.dwSize.Y - 1,
                ScreenBufferInfo.dwSize.X - 1,
                ScreenBufferInfo.wAttributes
                )
        );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\seqcnt.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	seqcnt.cxx

Abstract:

	This module contains the definition for the SEQUENTIAL_CONTAINER class.
	There exists no implementation, merely a constructor that acts as a link
	between derived classes as SEQUENTIAL_CONTAINERs base class CONTAINER.

Author:

	David J. Gilman (davegi) 02-Nov-1990

Environment:

	ULIB, User Mode

[Notes:]

	optional-notes

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "iterator.hxx"
#include "seqcnt.hxx"


DEFINE_CONSTRUCTOR( SEQUENTIAL_CONTAINER, CONTAINER );

SEQUENTIAL_CONTAINER::~SEQUENTIAL_CONTAINER(
    )
{
}

ULIB_EXPORT
BOOLEAN
SEQUENTIAL_CONTAINER::DeleteAllMembers(
    )
/*++

Routine Description:

    This routine not only removes all members from the container
    class, but also deletes all the objects themselves.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PITERATOR   iter;
    POBJECT     pobj;

    if (!(iter = QueryIterator())) {
        return FALSE;
    }

    iter->GetNext();
    while (iter->GetCurrent()) {
        pobj = Remove(iter);
        DELETE(pobj);
    }
    DELETE(iter);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\sortcnt.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	sortcnt.cxx

Abstract:

	This module contains the definition for the SORTABLE_CONTAINER class.

Author:

	David J. Gilman (davegi) 02-Nov-1990

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "iterator.hxx"
#include "sortcnt.hxx"


DEFINE_CONSTRUCTOR( SORTABLE_CONTAINER, SEQUENTIAL_CONTAINER );

SORTABLE_CONTAINER::~SORTABLE_CONTAINER(
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\sortlist.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sortlist.cxx

Abstract:

	This module contains the definition for the SORTED_LIST class.
    SORTED_LIST is a concrete implementation of a SORTABLE_CONTAINER, where
    all the elements are maintained in sorted order.

Author:

    Ramon J. San Andres (ramonsa) 29-Oct-1991

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "sortlist.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( SORTED_LIST, SORTABLE_CONTAINER, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( SORTED_LIST );

VOID
SORTED_LIST::Construct (
	)

/*++

Routine Description:

	Constructor for SORTED_LIST

Arguments:

	None.

Return Value:

	None.

--*/

{
}





ULIB_EXPORT
SORTED_LIST::~SORTED_LIST (
	)

/*++

Routine Description:

    Destructor for SORTED_LIST

Arguments:

	None.

Return Value:

	None.

--*/

{
}



ULIB_EXPORT
BOOLEAN
SORTED_LIST::Initialize (
    IN BOOLEAN  Ascending
	)

/*++

Routine Description:

    Initializes a SORTED_LIST object.

Arguments:

    Ascending   -   Supplies ascending flag

Return Value:

	BOOLEAN - TRUE if the SORTED_LIST is successfully initialized.

--*/

{
    _Ascending = Ascending;

#if DBG==1
    _IteratorCount      = 0;
#endif

    return _Array.Initialize();
}




ULIB_EXPORT
BOOLEAN
SORTED_LIST::DeleteAllMembers (
	)

/*++

Routine Description:

    Deletes all the members of the sorted list

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if all members deleted

--*/

{
    return _Array.DeleteAllMembers();
}





ULIB_EXPORT
BOOLEAN
SORTED_LIST::Put (
	IN OUT  POBJECT Member
	)

/*++

Routine Description:

	Puts an OBJECT in the sorted list, maintaining the list sorted

Arguments:

	Member  -   Supplies the OBJECT to place in the array

Return Value:

    BOOLEAN -   TRUE if member put, FALSE otherwise

--*/

{
    if ( _Array.QueryMemberCount() > 0 ) {
        return _Array.Insert( Member, Search( Member, 0, _Array.QueryMemberCount()-1 ) );
    } else {
        return _Array.Insert( Member, 0 );
    }
}




ULIB_EXPORT
PITERATOR
SORTED_LIST::QueryIterator (
	) CONST

/*++

Routine Description:

    Creates an iterator object for this sorted-list.

Arguments:

	None.

Return Value:

	PITERATOR - Pointer to an ITERATOR object.

--*/

{



    return (PITERATOR)_Array.QueryIterator();
}



ULIB_EXPORT
ULONG
SORTED_LIST::QueryMemberCount (
	) CONST

/*++

Routine Description:

    Obtains the number of elements in the list

Arguments:

    None

Return Value:

    ULONG   -   The number of members in the list


--*/

{
    return _Array.QueryMemberCount();
}


POBJECT
SORTED_LIST::Remove (
	IN OUT  PITERATOR   Position
	)

/*++

Routine Description:

    Removes a member from the list

Arguments:

    Position    -   Supplies an iterator whose currency is to be removed

Return Value:

    POBJECT -   The object removed


--*/

{
    return _Array.Remove( Position );
}




BOOLEAN
SORTED_LIST::Sort (
    IN  BOOLEAN Ascending
	)

/*++

Routine Description:

    Sorts the array

Arguments:

    Ascending   -   Supplies ascending flag

Return Value:

    BOOLEAN -   TRUE if array sorted, FALSE otherwise


--*/

{
    if ( ( Ascending == _Ascending ) ||
          _Array.Sort( Ascending ) ) {

        _Ascending = Ascending;
        return TRUE;

    } else {

        return FALSE;
    }
}




ULONG
SORTED_LIST::Search(
    IN  PCOBJECT    Key,
    IN  ULONG       FirstIndex,
    IN  ULONG       LastIndex
    )

/*++

Routine Description:

    Searches an element that matches the supplied key.
    If no such element is found, this method returns
    the element one past the largest element less
    than the given element.

Arguments:

    Key         -   Supplies the key
    FirstIndex  -   Supplies lowerbound for the search
    LastIndex   -   Supplies upperbound for the search

Return Value:

    ULONG   -   Index of the element that matched the key, or
                LastIndex+1 if no match

--*/

{
    LONG    First, Middle, Last;
    LONG    Match;

    DebugPtrAssert( Key );
    DebugPtrAssert( FirstIndex < _Array.QueryMemberCount() );
    DebugPtrAssert( (LastIndex == INVALID_INDEX)  ||
                  (LastIndex < _Array.QueryMemberCount()) );
    DebugPtrAssert( FirstIndex <= LastIndex );

    if (LastIndex == INVALID_INDEX) {
        return 0;
    }

    First = FirstIndex;
    Last = LastIndex;
    while (First <= Last) {
        Middle = (First + Last)/2;
        Match = _Array.CompareAscDesc((POBJECT) Key,
                                      _Array.GetAt(Middle),
                                      _Ascending);

        if (!Match) {
            break;
        }

        if (Match < 0) {
            Last = Middle - 1;
        } else {
            First = ++Middle;
        }
    }

    return Middle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\spackmsg.cxx ===
/*++

Copyright (c) 1991-1994 Microsoft Corporation

Module Name:

    spackmsg.cxx

Abstract:

    Contains the implementation of the SP_AUTOCHECK_MESSAGE subclass.

Author:

    Lonny McMichael (lonnym) 09-Jun-94

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "spackmsg.hxx"


DEFINE_CONSTRUCTOR(SP_AUTOCHECK_MESSAGE, AUTOCHECK_MESSAGE);

SP_AUTOCHECK_MESSAGE::~SP_AUTOCHECK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for SP_AUTOCHECK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
SP_AUTOCHECK_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // nothing to do
    //
}


VOID
SP_AUTOCHECK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // nothing to do
    //
}


BOOLEAN
SP_AUTOCHECK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine outputs the message to the debugger (if checked build).

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR            buffer[256];
    DSTRING         display_string;

    if (!BASE_SYSTEM::QueryResourceStringV(&display_string, GetMessageId(), Format,
                                           VarPointer)) {
        return FALSE;
    }

    //
    // Log the output if necessary
    //
    if (IsLoggingEnabled() && !IsSuppressedMessage()) {
        LogMessage(&display_string);
    }

    //
    // Send the output to the debug port.
    //
    if( display_string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {
        DebugPrint(buffer);
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOLEAN
SP_AUTOCHECK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries a response of yes or no.

Arguments:

    Default - Supplies a default in the event that a query is not possible.

Return Value:

    FALSE   - The answer is no.
    TRUE    - The answer is yes.

--*/
{
    CHAR            buffer[256];
    DSTRING         string;

    if (!BASE_SYSTEM::QueryResourceString(&string, Default ? MSG_YES : MSG_NO, "")) {
        return Default;
    }

    //
    // Send the output to the debug port.
    //
    if( string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {
        DebugPrint(buffer);
    }

    return Default;
}

BOOLEAN
SP_AUTOCHECK_MESSAGE::IsInAutoChk(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in regular autochk.

Arguments:

    None.

Return Value:

    FALSE   - Not in autochk

--*/
{
    return FALSE;
}

BOOLEAN
SP_AUTOCHECK_MESSAGE::IsInSetup(
)
/*++

Routine Description:

    This routine simply returns TRUE to indicate it is in
    setup.

Arguments:

    None.

Return Value:

    FALSE   - Not in setup

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\sources.inc ===
!IF 0

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ulib
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernl32p.lib    \
           $(SDK_LIB_PATH)\user32.lib      \
           $(SDK_LIB_PATH)\advapi32.lib

DLLENTRY=_DllMainCRTStartup

USE_MSVCRT=1

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\rtmsg.rc        \
        ..\arg.cxx         \
        ..\array.cxx       \
        ..\arrayit.cxx     \
        ..\basesys.cxx     \
        ..\bitvect.cxx     \
        ..\bstring.cxx     \
        ..\bytestrm.cxx    \
        ..\bufstrm.cxx     \
        ..\chkmsg.cxx      \
        ..\clasdesc.cxx    \
        ..\cmem.cxx        \
        ..\comm.cxx        \
        ..\contain.cxx     \
        ..\dir.cxx         \
        ..\file.cxx        \
        ..\filestrm.cxx    \
        ..\filter.cxx      \
        ..\fsnode.cxx      \
        ..\hmem.cxx        \
        ..\iterator.cxx    \
        ..\keyboard.cxx    \
        ..\list.cxx        \
        ..\listit.cxx      \
        ..\machine.cxx     \
        ..\mbstr.cxx       \
        ..\mem.cxx         \
        ..\membmgr.cxx     \
        ..\membmgr2.cxx     \
        ..\message.cxx     \
        ..\newdel.cxx      \
        ..\object.cxx      \
        ..\path.cxx        \
        ..\pipe.cxx        \
        ..\pipestrm.cxx    \
        ..\program.cxx     \
        ..\prtstrm.cxx     \
        ..\screen.cxx      \
        ..\seqcnt.cxx      \
        ..\smsg.cxx        \
        ..\sortcnt.cxx     \
        ..\sortlist.cxx    \
        ..\sortlit.cxx     \
        ..\stream.cxx      \
        ..\stringar.cxx    \
        ..\system.cxx      \
        ..\timeinfo.cxx    \
        ..\ulib.cxx        \
        ..\wstring.cxx

i386_SOURCES=..\i386\dosttr.c

INCLUDES=..\.;..\..\inc;

PRECOMPILED_INCLUDE= ..\pch.cxx

C_DEFINES=-DUNICODE=1 -DSTRICT=1 -DNO_COMMDLGH -DNO_LZEXPANDH -DNO_MMSYSTEMH -DNO_NB30H

#
# This allow W2K utils to run under NT4 for temporary use.  Not intend for release.
#
!IF defined(UTILS_RUN_ON_NT4)
C_DEFINES=$(C_DEFINES) /DRUN_ON_NT4
!ENDIF

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console

NTTARGETFILE0=..\..\inc\rtmsg.h
DLLDEF=

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\stream.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    stream.cxx

Abstract:

    This module contains the definitions of the member functions
    of STREAM class.

Author:

    Jaime Sasson (jaimes) 24-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "mbstr.hxx"
#include "wstring.hxx"
#include "stream.hxx"
#include "system.hxx"

extern "C" {
    #include <ctype.h>
}

DEFINE_CONSTRUCTOR ( STREAM, OBJECT );


STREAM::~STREAM (
    )

/*++

Routine Description:

    Destroy a STREAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
}



BOOLEAN
STREAM::ReadByte(
    OUT PBYTE   Data
    )

/*++

Routine Description:

    Reads one byte from the stream.

Arguments:

    Data    - Address of the variable that will contain the byte read.


Return Value:

    BOOLEAN - Returns TRUE if the read operation succeeded.


--*/


{
    ULONG   BytesRead;

    DebugPtrAssert( Data );
    if( Read( Data, sizeof( BYTE ), &BytesRead ) &&
        ( BytesRead == sizeof( BYTE ) ) ) {
        return( TRUE );
    } else {
        return( FALSE );
    }
}



ULIB_EXPORT
BOOLEAN
STREAM::ReadLine(
            OUT PWSTRING    String,
                        IN  BOOLEAN     Unicode
        )

/*++

Routine Description:

    Reads a line from the stream.
    A line is sequence of WCHARs, terminated by '\n' or '\r\n'.
    The delimiters are not returned in the string, but are removed
    from the stream.

Arguments:

    String - Pointer to an initialized string object. This object
             will contain the string read from the stream, without the
             delimiters.

Return Value:

    BOOLEAN - Returns TRUE if the operation succeeded, and String points to
              a valid WSTRING.
              Returns FALSE otherwise.


--*/


{
    WCHAR           Wchar;
    CHNUM           StringSize;

    DebugPtrAssert( String );
    //
    //  Read a string from the stream
    //
    if( !ReadString( String, &_Delimiter , Unicode) ) {
        DebugAbort( "ReadString() failed \n" );
        return( FALSE );
    }
    //
    //  If a string was successfully read, then we have to remove the
    //  delimiter from the stream
    //
    if( !IsAtEnd() ) {
        //
        //  Read the delimiter
        //
        if( !ReadChar( &Wchar , Unicode) ) {
            DebugAbort( "ReadChar() failed \n" );
            return( FALSE );
        }
    }
    //  Also, we have to check if last character in the string is \r.
    //  If it is, then we remove it.
    //
    StringSize = String->QueryChCount();
    StringSize--;
    if( String->QueryChAt( StringSize ) == ( WCHAR )'\r' ) {
        String->Truncate( StringSize );
    }


/*
    if( !IsAtEnd() ) {
        //
        //  Read the first delimiter
        //
        if( !ReadChar( &Wchar, Unicode ) ) {
            DebugAbort( "ReadChar() failed \n" );
            return( FALSE );
        }
        if( Wchar == ( WCHAR )'\r' ) {
            //
            //  If the delimiter read was '\r' then there is a second
            //  delimiter ('\n') and we have to remove it from the stream
            //
            if( !IsAtEnd() ) {
                if( !ReadChar( &Wchar, Unicode ) ) {
                    DebugAbort( "ReadChar() failed \n" );
                    return( FALSE );
                }
            }
        }
    }
*/
    return( TRUE );
}


ULIB_EXPORT
BOOLEAN
STREAM::ReadMbLine(
    IN      PSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
        )

/*++

Routine Description:


Arguments:


Return Value:


--*/


{

    BYTE    Char;


    DebugPtrAssert( String );
    DebugPtrAssert( BufferSize );
    DebugPtrAssert( StringSize );

    //
    //  Read a string from the stream
    //  Note that ReadMbString will remove the delimiter from the stream,
    //  in order to improve performance of FC and Find
    //
    if( !ReadMbString( String, BufferSize, StringSize, _MbDelimiter, ExpandTabs, TabExp ) ) {
        DebugAbort( "ReadMbString() failed \n" );
        return( FALSE );
    }


    //  Also, we have to check if last character in the string is \r.
    //  If it is, then we remove it.
    //
    if ( (*StringSize > 0 ) && (String[*StringSize-1] == '\r') ) {
        (*StringSize)--;
        String[*StringSize] = '\0';
    }

    return( TRUE );
}



ULIB_EXPORT
BOOLEAN
STREAM::ReadWLine(
    IN      PWSTR    String,
    IN      DWORD   BufferSize,
    INOUT   PDWORD  StringSize,
    IN      BOOLEAN ExpandTabs,
    IN      DWORD   TabExp
        )

/*++

Routine Description:


Arguments:


Return Value:


--*/


{

    WCHAR    Char;


    DebugPtrAssert( String );
    DebugPtrAssert( BufferSize );
    DebugPtrAssert( StringSize );

    //
    //  Read a string from the stream
    //  Note that ReadWString will remove the delimiter from the stream,
    //  in order to improve performance of FC and Find
    //
    if( !ReadWString( String, BufferSize, StringSize, _WDelimiter, ExpandTabs, TabExp ) ) {
        DebugAbort( "ReadWString() failed \n" );
        return( FALSE );
    }


    //  Also, we have to check if last character in the string is \r.
    //  If it is, then we remove it.
    //
    if ( (*StringSize > 0 ) && (String[*StringSize-1] == L'\r') ) {
        (*StringSize)--;
        String[*StringSize] = 0;
    }

    return( TRUE );
}



BOOLEAN
STREAM::Write(
    IN  PCBYTE  Buffer,
    IN  ULONG   BytesToWrite,
    OUT PULONG  BytesWritten
    )

/*++

Routine Description:

    Writes data to the stream.

Arguments:

    Buffer  - Points to the buffer that contains the data to be written.

    BytesToWrite - Indicates total number of bytes to write.

    BytesWritten - Points to the variable that will contain the number of
                   bytes actually written.

Return Value:

    BOOLEAN - Returns TRUE if the write operation succeeded.


--*/


{
    DebugPtrAssert( Buffer );
    DebugPtrAssert( BytesWritten );

    if( QueryAccess() != READ_ACCESS ) {
        return( WriteFile( QueryHandle(),
                           (LPVOID)Buffer,
                           BytesToWrite,
                           BytesWritten,
                           NULL
                           ) != FALSE );
    } else {
        return( FALSE );
    }
}



ULIB_EXPORT
BOOLEAN
STREAM::WriteByte(
    IN  BYTE    Data
    )

/*++

Routine Description:

    Writes one byte to the stream.

Arguments:

    Data - Byte to be written.

Return Value:

    BOOLEAN - Returns TRUE if the write operation succeeded.


--*/


{
    ULONG   BytesWritten = 0;

    if( Write( &Data, sizeof( BYTE ), &BytesWritten ) &&
      ( BytesWritten == sizeof( BYTE ) ) ) {
        return( TRUE );
    } else {
        return( FALSE );
    }
}


BOOLEAN
STREAM::WriteChar(
    IN  WCHAR   Char
    )

/*++

Routine Description:

    Writes one character to the stream, Doing wide character - to -
    multibyte conversion before writting

Arguments:

    Char    - Supplies character to be converted and written

Return Value:

    TRUE if character converted and written. FALSE otherwise


--*/


{

    BYTE    Buffer[ 2 ];    // FIX, FIX - can this be anything but 2?
    USHORT  BytesToWrite;
    ULONG   BytesWritten;
    BOOLEAN Result = FALSE;

    BytesToWrite = (USHORT)wctomb( (char *)Buffer, (wchar_t)Char );

    if ( BytesToWrite > 0 ) {

        Result = Write( Buffer, BytesToWrite, &BytesWritten );

        if ( BytesWritten != BytesToWrite) {
            Result =FALSE;
        }
    }

    return Result;
}



BOOLEAN
STREAM::WriteString(
    IN PCWSTRING String,
    IN CHNUM            Position,
    IN CHNUM            Length,
    IN CHNUM            Granularity
    )

/*++

Routine Description:

    Writes a string to the stream.

Arguments:

    String      - Pointer to a STRING object.
    Position    - Starting character within the string
    Length      - Number of characters to write
    Granularity - The maximum number of bytes to write at one time.
                    A value of 0 indicates to write it all at once.

Return Value:

    BOOLEAN - Returns TRUE if the write operation succeeded.


--*/


{
    ULONG   BytesWritten = 0;
    BOOLEAN Result       = TRUE;
    ULONG   Size, i, to_write;
    PBYTE   Buffer;

    DebugPtrAssert( String );
#if defined(DBCS)
    //
    // let convert unicode string to oem string with current console codepage.
    //
    String->SetConsoleConversions();
#endif // defined(DBCS)
    Buffer = (PBYTE)String->QuerySTR( Position, Length );

    if (Buffer == NULL) {
#if defined(DBCS)
        //
        // Reset/Back to conversion mode.
        //
        String->ResetConversions();
#endif // defined(DBCS)
        return FALSE;
    }

    Size = strlen((char *)Buffer);

    if (!Granularity) {
        Granularity = Size;
    }

    Result = TRUE;
    for (i = 0; Result && i < Size; i += Granularity) {

        to_write = min(Granularity, Size - i);

        Result = Write( Buffer + i, to_write, &BytesWritten ) &&
                 to_write == BytesWritten;
    }

#if defined(DBCS)
    //
    // Reset/Back to conversion mode.
    //
    String->ResetConversions();
#endif // defined(DBCS)

    FREE( Buffer );
    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\sortlit.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	sortlit.cxx

Abstract:

	This file contains the definitions for the SORTED_LIST_ITERATOR class.
	SORTED_LIST_ITERATOR is a concrete implementation of the abstract ITERATOR
	class.

Author:

    Ramon J. San Andres ( ramonsa) 29-Oct-1991

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "sortlist.hxx"
#include "sortlit.hxx"


DEFINE_CAST_MEMBER_FUNCTION( SORTED_LIST_ITERATOR );

DEFINE_CONSTRUCTOR( SORTED_LIST_ITERATOR, ITERATOR );


VOID
SORTED_LIST_ITERATOR::Construct (
	)

/*++

Routine Description:

	Construct a SORTED_LIST_ITERATOR

Arguments:

	None.

Return Value:

	None.

--*/

{
	_List = NULL;
}



SORTED_LIST_ITERATOR::~SORTED_LIST_ITERATOR (
    )
/*++

Routine Description:

    Destructor for the SORTED_LIST_ITERATOR class

Arguments:

    None

Return Value:

    None

--*/

{
#if DBG==1
    if ( _List ) {
        _List->_IteratorCount--;
    }
#endif
}


POBJECT
SORTED_LIST_ITERATOR::FindNext(
    IN  PCOBJECT    Key
    )
/*++

Routine Description:

    Finds the next object in the list that matches the given key

Arguments:

    Key -   Supplies the key

Return Value:

    POBJECT -   Pointer to next member of the list that matches the key

--*/

{

    ULONG   Index;

    //
    //  Wrap if necessary
    //
    if ( _CurrentIndex == INVALID_INDEX ) {
        _CurrentIndex = 0;
    }

    //
    //  If we are not at the end of the list, look for the next object
    //  that matches the key.
    //
    if ( _CurrentIndex < _List->QueryMemberCount()-1 ) {

        Index = _List->Search( Key, _CurrentIndex+1, _List->QueryMemberCount()-1 );

        //
        //  If an object was found, set our currency and return the object
        //
        if ( Index < _List->QueryMemberCount() &&
             !Key->Compare(_List->_Array.GetAt( Index )))  {

            _CurrentIndex = Index;
            return _List->_Array.GetAt( Index );
        }
    }

    //
    //  No match, return NULL
    //
    _CurrentIndex = INVALID_INDEX;
    return NULL;
}


POBJECT
SORTED_LIST_ITERATOR::GetCurrent(
	)
/*++

Routine Description:

    Gets current member

Arguments:

    None

Return Value:

    POBJECT -   Pointer to current member in  the array

--*/

{
    if ( _CurrentIndex == INVALID_INDEX ) {
        return NULL;
    } else {
        return _List->_Array.GetAt( _CurrentIndex );
    }
}




POBJECT
SORTED_LIST_ITERATOR::GetNext(
	)
/*++

Routine Description:

    Gets next member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to next member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that INVALID_INDEX + 1 == 0
    //
    _CurrentIndex++;

    if ( _CurrentIndex >= _List->_Array.QueryMemberCount() ) {
        _CurrentIndex = INVALID_INDEX;
    }

    //
    //  Get next
    //
    return _List->_Array.GetAt( _CurrentIndex );
}


POBJECT
SORTED_LIST_ITERATOR::GetPrevious(
	)
/*++

Routine Description:

    Gets previous member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to previous member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that 0 - 1 == INVALID_INDEX
    //
    _CurrentIndex--;

    if ( _CurrentIndex == INVALID_INDEX ) {
        _CurrentIndex = _List->_Array.QueryMemberCount() - 1;
    }

    //
    //  Get next
    //
    return _List->_Array.GetAt( _CurrentIndex );
}



VOID
SORTED_LIST_ITERATOR::Reset(
    )

/*++

Routine Description:

    Resets the iterator

Arguments:

    None

Return Value:

    None

--*/

{
    _CurrentIndex = INVALID_INDEX;
}




BOOLEAN
SORTED_LIST_ITERATOR::Initialize (
	IN PSORTED_LIST List
	)

/*++

Routine Description:

	Associate a SORTED_LIST with this SORTED_LIST_ITERATOR and
    reset the current index

Arguments:

    List   -   Supplies pointer to the sorted list object

Return Value:

	BOOLEAN - Returns TRUE if the initialization was succesful.

--*/

{
	DebugPtrAssert( List );

#if DBG==1
    if ( _List ) {
        _List->_IteratorCount--;
    }
    List->_IteratorCount++;
#endif
    _List           = List;
    _CurrentIndex   = INVALID_INDEX;


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\string.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	GENERIC_STRING

Abstract:

	This module contains the implementation for the GENERIC_STRING class.

Author:

	Ramon J. San Andres (ramonsa)	07-May-1991


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "string.hxx"


DEFINE_CONSTRUCTOR( GENERIC_STRING, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( GENERIC_STRING );

GENERIC_STRING::~GENERIC_STRING(
    )
{
}

VOID
GENERIC_STRING::Construct (
    )

/*++

Routine Description:

	Constructs a GENERIC_STRING object

Arguments:

    None.

Return Value:

    None.


--*/

{
}

BOOLEAN
GENERIC_STRING::Initialize (
    )

/*++

Routine Description:

	Phase 2 of construction for a GENERIC_STRING.

Arguments:

	none

Return Value:

	TRUE  if the string was successfully initialized,
	FALSE otherwise.

--*/

{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\stringar.cxx ===
/*++

Copyright (c) 1991      Microsoft Corporation

Module Name:

        stringar.cxx

Abstract:

        This module contains the implementation of the STRING_ARRAY class.
        STRING_ARRAY is used only to store strings, and it provides a
        method to sort the strings in ascending or descending order.
        The sort methods uses the qsort() function of the C run time
        library.

Author:

        Jaime F. Sasson (jaimes) 01-May-1991

Environment:

        ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "wstring.hxx"
#include "stringar.hxx"

#if defined( __BCPLUSPLUS__ )

        #include <search.h>

#else

        extern "C" {
                #include <search.h>
        };

#endif // __BCPLUSPLUS__

CHNUM    STRING_ARRAY::_Position;
BOOLEAN  STRING_ARRAY::_Ascending;

DEFINE_EXPORTED_CONSTRUCTOR( STRING_ARRAY, ARRAY, ULIB_EXPORT );


ULIB_EXPORT
BOOLEAN
STRING_ARRAY::Initialize (
        IN CHNUM        Position,
        IN ULONG        Capacity,
        IN ULONG        CapacityIncrement
        )

/*++

Routine Description:

        Initialize a STRING_ARRAY object by setting it's internal state to s
        upplied or default values.

Arguments:

        Position                        - Supplies the position in each string to be used as
                                                  strating position when sorting the array.
        Capacity                        - Supplies the total number of WSTRINGs the
                                                  STRING_ARRAY can contain.
        CapacityIncrement       - Supplies the number of OBJECTs to make room for
                                                  when growing the STRING_ARRAY


Return Value:

        BOOLEAN - TRUE if the ARRAY is successfully initialized.

--*/

{
        _Position = Position;
        return( ARRAY::Initialize( Capacity, CapacityIncrement ) );
}



ULIB_EXPORT
BOOLEAN
STRING_ARRAY::Sort (
        BOOLEAN Ascending
        )

/*++

Routine Description:

        Sorts the array in ascending or descending order, depending
        on the parameter passed.

Arguments:

        Ascending - Specifies if the sort is to be performed in ascending (TRUE)
                                or descending (FALSE) order.

Return Value:

        BOOLEAN -

--*/

{
    _Ascending = Ascending;

    qsort( GetObjectArray(),
           ( size_t )QueryMemberCount(),
           sizeof( PWSTRING ),
           &STRING_ARRAY::StringCompare );

    return( TRUE );
}



int __cdecl
STRING_ARRAY::
StringCompare (
        IN const void * String1,
        IN const void * String2
        )

/*++

Routine Description:

        This function is used by qsort(), and it compares *String1
        and *String2. The string used as key depends on the value
        of _Ascending.
        If _Ascending == TRUE, then it uses *String1 as a key.
        If _Ascending == FALSE, then it uses *String2 as a key.

Arguments:

        *String1 - Pointer to a string object.

        *String2 - Pointer to a string object.

Return Value:

        Returns:

                if _Ascending == TRUE, then it returns
                        -1      if **String1 is less that **String2
                        0       if **String1 is equal to **String2
                        1       if **String1 is greater than **String2

                if _Ascending == FALSE, then it returns
                        -1      if **String2 is less that **String1
                        0       if **String2 is equal to **String1
                        1       if **String2 is greater than **String1

--*/

{
        PCWSTRING       St1;
        PCWSTRING       St2;
        CHNUM           Position1;
        CHNUM           Length1;
        CHNUM           Position2;
        CHNUM           Length2;
// char name[256];
// LONG result;

        if( _Ascending ) {
                St1 = *(PCWSTRING *)String1;
                St2 = *(PCWSTRING *)String2;
        } else  {
                St1 = *(PCWSTRING *)String2;
                St2 = *(PCWSTRING *)String1;
        }
        Length1 = St1->QueryChCount();
        Position1 = ( Length1 >= _Position ) ?  _Position : Length1;
        Length1 -= Position1;
        Length2 = St2->QueryChCount();
        Position2 = ( Length2 >= _Position ) ?  _Position : Length2;
        Length2 -= Position2;
/*
        St1->QueryApiString(name, 256);
        printf( "Length1 = %d, Position1 = %d, %s \n", Length1, Position1, name );
        St2->QueryApiString(name, 256);
        printf( "Length2 = %d, Position2 = %d, %s \n", Length2, Position2, name );
        result = St1->StringCompare( Position1,
                                                                 Length1,
                                                                 St2,
                                                                 Position2,
                                                                 Length2,
                                                                 CF_IGNORECASE );
        printf( "Result = %d \n", result );
        return( result );
*/
    return( St1->Stricmp( St2,
                          Position1,
                          Length1,
                          Position2,
                          Length2 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\system.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    system.cxx

Abstract:

    This contains the implementation for all methods communicating
    with the operating system.

Author:

    David J. Gilman (davegi) 13-Jan-1991

Environment:

    ULIB, user mode

Revision History:

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "system.hxx"

extern "C" {
    #include <stdio.h>
    #include <string.h>
    #include "winbasep.h"
}

#include "dir.hxx"
#include "file.hxx"
#include "path.hxx"
#include "wstring.hxx"
#include "timeinfo.hxx"


ULIB_EXPORT
BOOLEAN
SYSTEM::IsCorrectVersion (
    )

/*++

Routine Description:

    Verify that the version of the operating system is correct.

Arguments:

    None

Return Value:

    BOOLEAN - TRUE is the version is correct
            - FALSE if wrong version

--*/

{
    // It makes more sense to just allow this binary to run.
    // Future version of Windows NT will have to be backward
    // compatible.
    return TRUE;
    // return (GetVersion()&0x0000FFFF) == 0x0A03; // Windows 3.10
}


BOOLEAN
ClearDirectoryJunction(
    IN  PCWSTR  PathString
    )

{
    HANDLE                  h;
    PREPARSE_DATA_BUFFER    reparse;
    PWSTR                   pathString;
    BOOL                    b;
    DWORD                   bytes;
    UNICODE_STRING          reparseName;
    DWORD                   l;
    DWORD                   last_err;
    DWORD                   flags;
    BOOLEAN                 done;

    h = CreateFile(PathString, GENERIC_READ,
                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                   FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                   INVALID_HANDLE_VALUE);

    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    reparse = (PREPARSE_DATA_BUFFER)
              LocalAlloc(0, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
    if (!reparse) {
        CloseHandle(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (!DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse,
                         MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &bytes, NULL) ||
        (reparse->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT)) {
        LocalFree(reparse);
        CloseHandle(h);
        return TRUE;
    }

    flags = GetFileAttributes(PathString);
    if (flags != -1) {
        if (flags & FILE_ATTRIBUTE_READONLY) {
            flags &= ~FILE_ATTRIBUTE_READONLY;
            if (!SetFileAttributes(PathString, flags)) {
                last_err = GetLastError();
                LocalFree(reparse);
                CloseHandle(h);
                SetLastError(last_err);
                return FALSE;
            }
            flags = FILE_ATTRIBUTE_READONLY;
        } else
            flags = 0;
    }

    // at this point, flags can be -1, 0, or FILE_ATTRIBUTE_READONLY

    done = FALSE;
    last_err = ERROR_SUCCESS;

    if (flags == FILE_ATTRIBUTE_READONLY) {

        // if previously made writeable, a new handle is needed

        CloseHandle(h);
        h = CreateFile(PathString, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                       FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            last_err = GetLastError();
            done = TRUE;
        }
    }

    if (!done) {
        l = wcslen(PathString);
        if (l && PathString[l - 1] == '\\') {
            if (DeleteVolumeMountPoint(PathString)) {
                done = TRUE;
            }
        } else {
            pathString = (PWSTR) LocalAlloc(0, l*sizeof(WCHAR) + 2*sizeof(WCHAR));
            if (!pathString) {
                last_err = ERROR_NOT_ENOUGH_MEMORY;
                done = TRUE;
            } else {
                if (l) {
                    CopyMemory(pathString, PathString, l*sizeof(WCHAR));
                }
                pathString[l] = '\\';
                pathString[l + 1] = 0;
                if (DeleteVolumeMountPoint(pathString)) {
                    done = TRUE;
                }
                LocalFree(pathString);
            }
        }

        if (!done) {
            reparse->ReparseDataLength = 0;

            if (!DeviceIoControl(h, FSCTL_DELETE_REPARSE_POINT, reparse,
                                 REPARSE_DATA_BUFFER_HEADER_SIZE, NULL, 0, &bytes,
                                 NULL)) {
                last_err = GetLastError();
            }
        }
    }

    if (reparse != NULL)
        LocalFree(reparse);
    if (h != INVALID_HANDLE_VALUE)
        CloseHandle(h);

    if ((last_err == ERROR_SUCCESS) && (flags == FILE_ATTRIBUTE_READONLY)) {
        flags = GetFileAttributes(PathString);
        if (flags != -1) {
            flags |= FILE_ATTRIBUTE_READONLY;
            if (!SetFileAttributes(PathString, flags)) {
                last_err = GetLastError();
            }
        }
    }

    SetLastError(last_err);
    return (last_err == ERROR_SUCCESS);
}

ULIB_EXPORT
PFSN_DIRECTORY
SYSTEM::MakeDirectory (
    IN     PCPATH             Path,
    IN     PCPATH             TemplatePath,
       OUT PCOPY_ERROR        CopyError,
    IN     LPPROGRESS_ROUTINE Callback,
    IN     PVOID              Data,
    IN     PBOOL              Cancel,
    IN     ULONG              CopyFlags
    )

/*++

Routine Description:

    Creates a Directory and returns the corresponging FSN_Directory object.

Arguments:

    Path            - Supplies the Path of the directory to be created.
    TemplatePath    - Supplies the template directory from which to
                        copy alternate data streams.
    CopyError       - Pointer to location where the copy error code is to be returned
    Callback        - Pointer to callback routine passed to CopyFileEx.
    Data            - Pointer to opaque data passed to CopyFileEx.
    Cancel          - Pointer to cancel flag passed to CopyFileEx.
    CopyFlags       - Supplies the following flags:
                        FSN_FILE_COPY_RESTARTABLE
                            - copy is restartable.
                        FSN_FILE_COPY_COPY_OWNER
                            - copy the ownership of the file.
                        FSN_FILE_COPY_COPY_ACL
                            - copy the security information of the file

Return Value:

    PFSN_DIRECTORY  -   A pointer to the object of the directory created.

--*/

{
    PCWSTR                  PathString, TemplateString;
    BOOL                    r;
    PFSN_DIRECTORY          pdir;

    DebugAssert(Path);

    *CopyError = COPY_ERROR_SUCCESS;

    PathString = Path->GetPathString()->GetWSTR();
    DebugAssert(PathString);
    if (TemplatePath) {
        TemplateString = TemplatePath->GetPathString()->GetWSTR();
    } else {
        TemplateString = NULL;
    }

    if (TemplateString) {

        ULONG   flags;

        flags = PRIVCOPY_FILE_DIRECTORY;
        flags |= (FSN_FILE_COPY_RESTARTABLE & CopyFlags) ? COPY_FILE_RESTARTABLE : 0;
        flags |= (FSN_FILE_COPY_COPY_OWNER & CopyFlags) ? PRIVCOPY_FILE_OWNER_GROUP | PRIVCOPY_FILE_METADATA : 0;
        flags |= (FSN_FILE_COPY_COPY_ACL & CopyFlags)   ? PRIVCOPY_FILE_SACL : 0;

#if !defined(RUN_ON_NT4)
        r = PrivCopyFileExW( TemplateString,
                             PathString,
                             Callback,
                             Data,
                             Cancel,
                             flags );
        if (r) {
            r = ClearDirectoryJunction(PathString);
        }
#else
        r = FALSE;
        SetLastError(ERROR_NOT_SUPPORTED);
#endif

    } else {
        r = CreateDirectory((PWSTR) PathString, NULL);
    }

    if (!r) {
        *CopyError = (COPY_ERROR)GetLastError();
        return NULL;
    }

    pdir = QueryDirectory( Path );

    if (pdir == NULL) {
        DebugPrintTrace(("ULIB: QueryDirectory returns NULL\n"));
    }

    return pdir;
}

ULIB_EXPORT
PFSN_FILE
SYSTEM::MakeFile (
    IN PCPATH   Path
    )

/*++

Routine Description:

    Creates a File and returs the corresponging FSN_FILE object.

    If the file already exists, its contents are destroyed.

    Note that all the subdirectories along the path must exist (this
    method does not create directories).

Arguments:

    Path            - Supplies the Path of the file to be created.

Return Value:

    PFSN_FILE   -   A pointer to the FSN_FILE object of the file created.

--*/

{

    HANDLE      Handle;
    PCWSTR      PathString;
    PFSN_FILE   File = NULL;

    DebugPtrAssert( Path );

    PathString = Path->GetPathString()->GetWSTR();

    DebugPtrAssert( PathString );

    if ( PathString ) {

        Handle = CreateFile( (LPWSTR) PathString,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             0 );


        DebugAssert( Handle != INVALID_HANDLE_VALUE );

        if ( Handle != INVALID_HANDLE_VALUE ) {

            //
            //  Now that we know that the file exists, we use the
            //  QueryFile method to obtain the FSN_FILE object.
            //
            CloseHandle( Handle );

            File = QueryFile( Path );

        }
    }

    return File;

}

ULIB_EXPORT
PFSN_FILE
SYSTEM::MakeTemporaryFile (
    IN PCWSTRING PrefixString,
    IN PCPATH           Path
    )

/*++

Routine Description:

    Creates a file with a unique name using the provided path and
    prefix string. If the path is NULL, then the defult path for
    temporary files is used.

Arguments:

    PrefixString    - Supplies the file prefix used for creating the
                      file name.

    Path            - Supplies the Path of the directory to contain the
                      temporary file.


Return Value:

    PFSN_FILE   -   A pointer to the FSN_FILE object of the file created.

--*/

{
    DWORD       BufferSize;
    LPWSTR      TempPath;
    PCWSTR      TempPrefix;

    WCHAR       FileName[ MAX_PATH ];

    PFSN_FILE   File = NULL;
    PATH        FilePath;


    DebugPtrAssert( PrefixString );

    TempPrefix = PrefixString->GetWSTR();

    DebugPtrAssert( TempPrefix );

    if ( TempPrefix ) {

        //
        //  Get the STR representation of the directory for temporary files
        //
        if ( !Path ) {

            //
            //  Path not supplied, we will use the default
            //
            BufferSize = GetTempPath( 0, NULL );
            TempPath = (LPWSTR)MALLOC( (unsigned int)BufferSize * 2 );

            if (!GetTempPath( BufferSize, TempPath )) {
                FREE( TempPath );
                TempPath = NULL;
            }

        } else {

            //
            //   We will use the supplied path (and it better exist)
            //
            TempPath = Path->GetPathString()->QueryWSTR();

        }

        DebugPtrAssert( TempPath );

        if ( TempPath ) {

            //
            //  Now get the file name of the Temporary File.
            //
            if (!GetTempFileName( TempPath, (LPWSTR) TempPrefix, 0, FileName )) {
                FREE( TempPath );
                return NULL;
            }

            //
            //  Now create the file
            //
            FilePath.Initialize( FileName );

            File = MakeFile( &FilePath );

            FREE( TempPath );


        }
    }

    return File;

}

ULIB_EXPORT
BOOLEAN
SYSTEM::RemoveNode (
    IN OUT PFSNODE  *PointerToNode,
    IN     BOOLEAN   Force
    )

/*++

Routine Description:

    DDeletes nodes and directories.

    Read-only files are deleted only if the supplied "Force" flag
    is true.

Arguments:

    Node    -   Supplies a pointer to a pointer to the node

    Force   -   Supplies a flag which if TRUE means that the file
                should be deleted even if it is read-only.


Return Value:

    BOOLEAN -   Returns TRUE if the file was deleted successfully.

--*/

{

    PFSN_FILE       File;
    PFSN_DIRECTORY  Dir;
    PCWSTR          FileName;
    BOOL            Deleted = FALSE;

    DebugPtrAssert( PointerToNode );
    DebugPtrAssert( *PointerToNode );


    File = FSN_FILE::Cast( *PointerToNode );

    if ( File ) {

        //
        //  The node is a file
        //

        //
        //  We delete the file if it is not read-only or if the Force flag
        //  is set.
        //
        if ( Force || !File->IsReadOnly() ) {

            //
            //  If readonly, we reset the read only attribute.
            //
            if ( File->IsReadOnly() ) {

                File->ResetReadOnlyAttribute();

            }

            //
            //  Now we delete the file
            //
            FileName = File->GetPath()->GetPathString()->GetWSTR();

            DebugPtrAssert( FileName );

            if ( FileName ) {

                Deleted = DeleteFile( (LPWSTR) FileName );

                if ( Deleted ) {

                    //
                    //  The file has been deleted, now we have to get rid of
                    //  the file object, which is no longer valid.
                    //
                    DELETE( File );
                    *PointerToNode = NULL;

                }
            }

        }

    } else {

        Dir = FSN_DIRECTORY::Cast( *PointerToNode );

        if ( Dir ) {

            //
            //  We remove the directory if it is not read-only or if the Force flag
            //  is set.
            //
            if ( Force || !Dir->IsReadOnly() ) {

                //
                //  If readonly, we reset the read only attribute.
                //
                if ( Dir->IsReadOnly() ) {

                    Dir->ResetReadOnlyAttribute();

                }

                //
                //  Now we remove the directory
                //
                FileName = Dir->GetPath()->GetPathString()->GetWSTR();

                DebugPtrAssert( FileName );

                if ( FileName ) {

                    Deleted = RemoveDirectory( (LPWSTR) FileName );

                    if ( Deleted ) {

                        //
                        //  The directory has been  removed, now we have
                        //  to get rid of
                        //  the directory object, which is no longer valid.
                        //
                        DELETE( Dir );
                        *PointerToNode = NULL;

                    }
                }

            }

        } else {

            DebugAssert( FALSE );

        }

    }
    return Deleted != FALSE;

}

ULIB_EXPORT
PFSN_DIRECTORY
SYSTEM::QueryDirectory (
    IN PCPATH   Path,
    IN BOOLEAN  GetWhatYouCan
    )

/*++

Routine Description:

    Construct, initialize and return a FSN_DIRECTORY object.

Arguments:

    Path            - Supplies a PATH object to construct as a FSN_DIRECTORY.
                      **** IMPORTANT ****
                      If Path represents a drive (ie, C: ) the it must be terminated
                      by '\'. Otherwise the return value (PFSN_DIRECTORY will
                      contain information about the current directory, and not
                      the root directory.

    GetWhatYouCan   - Supplies a flag which if TRUE causes QueryDirectory to
                      backtrack along the path until it finds something
                      that it can open.

Return Value:

    PFSN_DIRECTORY - Returns a pointer to a FSN_DIRECTORY, NULL if the
        supplied path name does not point to an existing directory.

--*/

{
    WIN32_FIND_DATA             FindData;
    HANDLE                      Handle;
    PPATH                       TempPath;
    PFSN_DIRECTORY              Directory;
    PATH                        Parent;
    PCWSTRING                   TempString;
    PWSTRING                    DeviceString;
    BOOLEAN                     IsRoot;
    FSTRING                     TmpString;
    PCWSTR                      RootString = NULL;
    PATH                        FullPath;

    DebugPtrAssert( Path );

    //
    // Initialize the FSN_DIRECTORY and PATH pointers
    //
    Directory   = NULL;
    TempPath    = NULL;

    if ( !Path->HasWildCard() ) {

        //
        // If the supplied path exists and it references an existing entry
        // in the file system and it's a directory
        //

        TempPath = Path->QueryPath();
        DebugPtrAssert( TempPath );
        FullPath.Initialize( TempPath, TRUE );


        if ( TempPath != NULL ) {

            DeviceString = FullPath.QueryDevice();

            if ( DeviceString ) {
                IsRoot = (FullPath.IsRoot() || !FullPath.GetPathString()->Stricmp( DeviceString ) );
                DELETE( DeviceString );
            } else {
                IsRoot = TempPath->IsRoot();
            }

            if( !IsRoot ) {
                //
                // If path does not represent the root directory, then let it
                // call FindFirstFile()
                //
                if( ( Handle = FindFirstFile( TempPath, &FindData )) != INVALID_HANDLE_VALUE ) {

                    //
                    // Terminate the search
                    //
                    FindClose( Handle );

                    if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                        if ( !((( Directory = NEW FSN_DIRECTORY ) != NULL ) &&
                            Directory->Initialize( TempPath->GetPathString( ), &FindData ))) {

                            DELETE( Directory );
                        }
                    }
                }
            } else {

                //
                //  So we have a root directory. We have to determine if it
                //  is a valid drive. We used to call FindFirstFile on it,
                //  but it so happens that FindFirstFile may fail if the
                //  volume in question is empty (we don't even get the
                //  "." or ".." entries!)
                //
                if ( TmpString.Initialize( (PWSTR) L"." )                 &&
                     TempPath->AppendBase( &TmpString )                   &&
                     (RootString = TempPath->GetPathString()->GetWSTR())  &&
                     (GetFileAttributes( (LPWSTR) RootString ) != -1) ) {
                    //
                    // Path represents the root directory. We don't use the information
                    // obtained by FindFirstFile because that refers to the first entry
                    // in the root directory, not the root directory itself.
                    // This is not a bug in the API, but the way it is specified.
                    //
                    // The concept of WIN32_FIND_DATA does not apply to the root directory.
                    // For this reason I will do the initialization of FindData.
                    // Everything in FindData will be initialized, but the FILETIMEs will
                    // be initialized with zero.
                    //
                    // It is important that Path is contains a '\' at the end
                    // if it represents a drive.

                    TempPath->TruncateBase();

                    FindData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                    FindData.ftCreationTime.dwLowDateTime       = 0;
                    FindData.ftCreationTime.dwHighDateTime      = 0;
                    FindData.ftLastAccessTime.dwLowDateTime     = 0;
                    FindData.ftLastAccessTime.dwHighDateTime    = 0;
                    FindData.ftLastWriteTime.dwLowDateTime      = 0;
                    FindData.ftLastWriteTime.dwHighDateTime     = 0;
                    FindData.nFileSizeHigh  = 0;
                    FindData.nFileSizeLow   = 0;

                    TempString = TempPath->GetPathString();
                    DebugPtrAssert( TempString );
                    TempString->QueryWSTR( 0, TO_END, (LPWSTR)FindData.cFileName, MAX_PATH );
                    if ( !((( Directory = NEW FSN_DIRECTORY ) != NULL ) &&
                        Directory->Initialize( TempPath->GetPathString( ), &FindData ))) {

                        DELETE( Directory );
                    }
                }
            }
        }

        DELETE( TempPath );
    }

    if (!Directory && GetWhatYouCan && !Path->IsDrive() && !Path->IsRoot()) {
        //
        //  The path is not that of an existing directory.
        //  take off the base and try again.
        //
        Parent.Initialize( Path );
        Parent.TruncateBase();

        Directory = QueryDirectory( &Parent, GetWhatYouCan );
    }

    return Directory;
}



ULIB_EXPORT
PPATH
SYSTEM::QuerySystemDirectory (
    )

/*++

Routine Description:

    Returns the directory where the system files are located.

Arguments:

    None

Return Value:

    PPATH   -   Path of the system directory.

--*/

{
    WCHAR   Buffer[MAX_PATH];
    DSTRING PathName;
    PPATH   Path = NULL;
    DWORD   Cb;

    Cb = GetSystemDirectory( Buffer, MAX_PATH );

    if ( (Cb != 0) || (Cb < MAX_PATH) ) {

        if ( !PathName.Initialize( (PWSTR)Buffer) ||
             !(Path = NEW PATH)           ||
             !Path->Initialize( &PathName )
           ) {

            DELETE( Path );

        }
    }

    return Path;
}



const MaxEnvVarLen = 256;

ULIB_EXPORT
PWSTRING
SYSTEM::QueryEnvironmentVariable (
    IN PCWSTRING    Variable
    )

/*++

Routine Description:

    Obtains the value of an environment variable

Arguments:

    Variable    -   Supplies the variable to look for

Return Value:

    Value of the environment variable, NULL if not defined

--*/

{

    PCWSTR      Buffer;
    WCHAR       Value[MaxEnvVarLen];
    PWSTRING    pString;
    ULONG       ValueLength;

    if (!Variable) {
        return NULL;
    }

    //
    //  Get the ApiString of the variable to look for
    //
    Buffer = Variable->GetWSTR();

    //
    //  Look for the variable
    //
    ValueLength = GetEnvironmentVariable( (LPWSTR) Buffer, Value, MaxEnvVarLen );

    if ( ValueLength == 0 ) {

        //
        //  The environment variable is not defined
        //
        return NULL;
    }

    //
    //  Got the value, form a string with it and return it
    //
    if ( (pString = NEW DSTRING) != NULL ) {

         if (pString->Initialize( Value )) {

            return pString;

         }

         DELETE( pString );
     }

     return NULL;

}

ULIB_EXPORT
PPATH
SYSTEM::SearchPath(
    PWSTRING    pFileName,
    PWSTRING    pSearchPath
    )
/*++

Routine Description:

    Search a given path for a file name.  If the input path is NULL, the
    routine searches the default path.

Arguments:

    pSearchPath - Supplies a set of semicolon terminated paths.
    pFileName   - The name of the file to search for.

Return Value:

    A pointer to a path containing the first occurance of pFileName.  If the
    name isn't found, the path is NULL.

--*/
{
    CHNUM   cb;
    WSTR    ReturnPath[ MAX_PATH + 1 ];
    PPATH   pFullPath;
    LPWSTR  pFilePart;
    PCWSTR  pPath;
    PCWSTR  pName;

    if( pSearchPath != NULL ) {
        // Extract the path from pSearchPath for the API call...
        pPath = pSearchPath->GetWSTR();
    } else {
        pPath = NULL;
    }
    if( pFileName == NULL ) {
        DebugPrint( "The input filename is NULL - Can't find it...\n" );
        return( NULL );
    }
    // Extract the filename from the pFileName string...
    pName = pFileName->GetWSTR();

    //
    // Call the API ...
    //
    cb = ::SearchPath( (LPWSTR) pPath,
                     (LPWSTR) pName,
                     NULL,      // The extension must be specified as part of the file name...
                     MAX_PATH,
                     ReturnPath,
                     &pFilePart
                   );


    if( !cb ) {
        DebugPrint( "File name not found...\n" );
        return( NULL );
    }

    //
    // Create a new path and Initialize it with the buffer resulting
    //
    if( ( pFullPath = NEW PATH ) == NULL ) {
        DebugPrint( "Unable to allocate the path to return the data...\n" );
        return( NULL );
    }

    if( !pFullPath->Initialize( ReturnPath, FALSE ) ) {
        DebugPrint( "Unable to initialize the new path!\n" );
        return( NULL );
    }

    //
    // The path should now be constucted...
    //
    return( pFullPath );
}

ULIB_EXPORT
PFSN_FILE
SYSTEM::QueryFile (
    IN PCPATH       Path,
    IN BOOLEAN      SkipOffline,
    OUT PBOOLEAN    pOfflineSkipped
    )

/*++

Routine Description:

    Construct, initialize and return a FSN_FILE object.

Arguments:

    Path - Supplies a PATH object to construct as a FSN_FILE.
    SkipOffline - Specifies whether to skip offline files
    OfflineSkipped - Specifies whether an offline file has beed skipped

Return Value:

    A pointer to a FSN_FILE.

--*/

{

    PFSN_FILE           File        =   NULL;
    PPATH               FullPath    =   NULL;
    HANDLE              Handle;
    WIN32_FIND_DATA     FindData;

    DebugPtrAssert( Path );

    if (pOfflineSkipped) {
        *pOfflineSkipped = FALSE;
    }

    if ( Path                                                                       &&
         !Path->HasWildCard()                                                       &&
         ((FullPath = Path->QueryFullPath()) != NULL )                              &&
         ((Handle = FindFirstFile( FullPath, &FindData )) != INVALID_HANDLE_VALUE) ) {

        FindClose( Handle );

        if (! (SkipOffline && (FindData.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)) ) {

            if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

                if ((File = NEW FSN_FILE) != NULL) {
                    if ( !(File->Initialize(FullPath->GetPathString(), &FindData)) ) {
                        DELETE( File );
                        File = NULL;
                    }
                }
            }

        } else {
            // Skip offline file
            if (pOfflineSkipped) {
                *pOfflineSkipped = TRUE;
            }
        }
    }

    DELETE( FullPath );

    return File;
}


BOOLEAN
SYSTEM::PutStandardStream(
    IN  DWORD   StdHandle,
    IN  PSTREAM pStream
    )
/*++

Routine Description:

    Redirect a standard stream.

Arguments:

    StdHandle - An identifier for the Standard Handle to modify.
    pStream   - The standard stream is redirected to this stream.

Return Value:

    TRUE if successful.

--*/
{
    //
    // First, set the system standard handle to the stream
    //
    if( !SetStdHandle( StdHandle, pStream->QueryHandle() ) ) {
        DebugPrint( "Unable to redirect the system handle - nothing changed!\n" );
        return( FALSE );
    }


    //
    // Get a pointer to the stream to change...
    //
    switch( StdHandle ) {
        case STD_INPUT_HANDLE:
            Standard_Input_Stream = pStream;
            break;
        case STD_OUTPUT_HANDLE:
            Standard_Output_Stream = pStream;
            break;
        case STD_ERROR_HANDLE:
            Standard_Error_Stream = pStream;
            break;
        default:
            DebugPrint( "Unrecognized Standard Handle Type - Returning Error!\n" );
            return( FALSE );
    }
    return( TRUE );
}


ULIB_EXPORT
BOOLEAN
SYSTEM::QueryCurrentDosDriveName(
    OUT PWSTRING    DosDriveName
    )
/*++

Routine Description:

    This routine returns the name of the current drive.

Arguments:

    DosDriveName    - Returns the name of the current drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATH                path;
    PWSTRING     p;

    if (!path.Initialize( (LPWSTR)L"foo", TRUE)) {
        return FALSE;
    }

    if (!(p = path.QueryDevice())) {
        return FALSE;
    }

    if (!DosDriveName->Initialize(p)) {
        return FALSE;
    }

    DELETE(p);

    return TRUE;
}


ULIB_EXPORT
DRIVE_TYPE
SYSTEM::QueryDriveType(
    IN  PCWSTRING    DosDriveName
    )
/*++

Routine Description:

    This routine computes the type of drive pointed to by 'DosDriveName'.

Arguments:

    DosDriveName    - Supplies the dos name of the drive.

Return Value:

    The type of drive that is pointed to by 'DosDriveName'.

--*/
{
    DSTRING     wstring;
    DSTRING     slash;
    PCWSTR      p;
    DRIVE_TYPE  r;

    if (!wstring.Initialize(DosDriveName)) {
        return UnknownDrive;
    }

    if (!slash.Initialize("\\")) {
        return UnknownDrive;
    }

    wstring.Strcat(&slash);

    if (!(p = wstring.GetWSTR())) {
        return UnknownDrive;
    }

    switch (GetDriveType((LPWSTR) p)) {
        case DRIVE_REMOVABLE:
            r = RemovableDrive;
            break;

        case DRIVE_FIXED:
            r = FixedDrive;
            break;

        case DRIVE_REMOTE:
            r = RemoteDrive;
            break;

        case DRIVE_CDROM:
            r = CdRomDrive;
            break;

        case DRIVE_RAMDISK:
            r = RamDiskDrive;
            break;

        default:
            r = UnknownDrive;
            break;

    }

    return r;
}

ULIB_EXPORT
FILE_TYPE
SYSTEM::QueryFileType(
    IN  PCWSTRING    DosFileName
    )
/*++

Routine Description:

    This routine computes the type of filee pointed to by 'DosFileName'.

Arguments:

    DosFileName - Supplies the dos name of the file.

Return Value:

    The type of file that is pointed to by 'DosFileName'.

--*/
{
    DSTRING     wstring;
    PCWSTR      p;
    FILE_TYPE   r;
    HANDLE      Handle;

    if (!wstring.Initialize(DosFileName)) {
        return UnknownFile;
    }

    if (!(p = wstring.GetWSTR())) {
        return UnknownFile;
    }

    Handle = CreateFile( (LPWSTR) p,
                         GENERIC_READ,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                         NULL );

    if ( Handle != INVALID_HANDLE_VALUE ) {

        switch ( GetFileType( Handle ) ) {

            case FILE_TYPE_DISK:
                r = DiskFile;
                break;

            case FILE_TYPE_CHAR:
                r = CharFile;
                break;

            case FILE_TYPE_PIPE:
                r = PipeFile;
                break;

            default:
                r = UnknownFile;
                break;

        }

        CloseHandle( Handle );

    } else {

        r = UnknownFile;
    }

    return r;
}



ULIB_EXPORT
PWSTRING
SYSTEM::QueryVolumeLabel(
    IN      PPATH               Path,
       OUT  PVOL_SERIAL_NUMBER      VolSerialNumber
    )
/*++

Routine Description:

    Returns the name and serial number of a volume.

Arguments:

    Path - Path in the file system whose volume information is to be
           retrieved.

    VolSerialNumber -   Pointer to a structure that will contain the
                        serial number

Return Value:

    PWSTRING -  Pointer to a WSTRING that will contain the volume name, or
                NULL if an error occurs.


--*/
{
    PWSTRING            VolumeName;
    PWSTRING            RootString;
    PCWSTR              RootName;
    WCHAR               VolumeNameBuffer[ MAX_PATH ];
    ULONG               SerialNumber[2];

    DebugPtrAssert( Path );
    DebugPtrAssert( VolSerialNumber );
    RootString = Path->QueryRoot();
    if (RootString == NULL) {
        return NULL;
    }
    DebugPtrAssert( RootString );
    RootName = RootString->GetWSTR();
    if( !GetVolumeInformation( (LPWSTR) RootName,
                              (LPWSTR)VolumeNameBuffer,
                              MAX_PATH,
                              ( PDWORD )SerialNumber,
                              NULL,
                              NULL,
                              NULL,
                              0 ) ) {
        DELETE( RootString );
        return( NULL );
    }
    VolSerialNumber->LowOrder32Bits = SerialNumber[ 0 ];
    VolSerialNumber->HighOrder32Bits = SerialNumber[ 1 ];
    VolumeName = NEW( DSTRING );
    if (VolumeName == NULL ||
        !VolumeName->Initialize( VolumeNameBuffer )) {
        DELETE( RootString );
        DELETE( VolumeName );
        DebugPrint("ULIB: Out of memory\n");
        return NULL;
    }
    DELETE( RootString );
    return( VolumeName );
}



const MaximumLibraryNameLength = 256;
const MaximumEntryPointNameLength = 128;

ULIB_EXPORT
FARPROC
SYSTEM::QueryLibraryEntryPoint(
    IN  PCWSTRING   LibraryName,
    IN  PCWSTRING   EntryPointName,
    OUT PHANDLE     LibraryHandle
    )
/*++

Routine Description:

    Loads a dynamically-linked library and returns an
    entry point into it.

Arguments:

    LibraryName -- name of the library to load

    EntryPointName -- name of the entry point to get

    LibraryHandle -- receives handle of loaded library

Return Value:

    Pointer to the requested function; NULL to indicate failure.

--*/
{
    WCHAR AnsiLibraryName[MaximumLibraryNameLength+1];
    CHAR  AnsiEntryPointName[MaximumEntryPointNameLength+1];
    FARPROC EntryPoint;


    LibraryName->QueryWSTR( 0, TO_END, AnsiLibraryName, MaximumLibraryNameLength + 1);

    EntryPointName->QuerySTR( 0, TO_END, AnsiEntryPointName,
                                         MaximumEntryPointNameLength + 1 );

    if( (*LibraryHandle = (HANDLE)LoadLibrary( AnsiLibraryName )) != NULL &&
        (EntryPoint = GetProcAddress( (HINSTANCE)*LibraryHandle,
                                      (LPSTR)AnsiEntryPointName )) != NULL ) {

        return EntryPoint;

    } else {

        if( *LibraryHandle != NULL ) {

            FreeLibrary( (HMODULE)*LibraryHandle );
            *LibraryHandle = NULL;
        }

        return NULL;
    }
}


ULIB_EXPORT
VOID
SYSTEM::FreeLibraryHandle(
    HANDLE LibraryHandle
    )
/*++

Routine Description:

    Frees a library handle gotten by QueryLibraryEntryPoint

Arguments:

    LibraryHandle -- handle to free

Return Value:

    None.

--*/
{
    FreeLibrary( (HMODULE)LibraryHandle );
}


ULIB_EXPORT
BOOLEAN
SYSTEM::QueryLocalTimeFromUTime(
    IN  PCTIMEINFO  UTimeInfo,
    OUT PTIMEINFO   LocalTimeInfo
    )
/*++

Routine Description:

    This routine computes the local time from the given
    universal time.

Arguments:

    UTimeInfo       - Supplies the universal time to convert.
    LocalTimeInfo   - Returns the corresponding local time.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FILETIME    filetime;

    DebugAssert(UTimeInfo->GetFileTime());

    if (!FileTimeToLocalFileTime(UTimeInfo->GetFileTime(), &filetime)) {
        return FALSE;
    }

    return LocalTimeInfo->Initialize(&filetime);
}


BOOLEAN
SYSTEM::QueryUTimeFromLocalTime(
    IN  PCTIMEINFO  LocalTimeInfo,
    OUT PTIMEINFO   UTimeInfo
    )
/*++

Routine Description:

    This routine computes the universal time from the given
    local time.

Arguments:

    LocalTimeInfo   - Supplies the local time to convert.
    UTimeInfo       - Returns the corresponding universal time.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FILETIME    filetime;

    DebugAssert(LocalTimeInfo->GetFileTime());

    if (!LocalFileTimeToFileTime(LocalTimeInfo->GetFileTime(), &filetime)) {
        return FALSE;
    }

    return UTimeInfo->Initialize(&filetime);
}


ULIB_EXPORT
BOOLEAN
SYSTEM::QueryWindowsErrorMessage(
    IN  ULONG       WindowsErrorCode,
    OUT PWSTRING    ErrorMessage
    )
/*++

Routine Description:

    This routine returns the text corresponding to the given
    windows error message.

Arguments:

    WindowsErrorCode    - Supplies the windows error code.
    ErrorMessage        - Returns the error message for this error code.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WCHAR   buffer[MAX_PATH];

    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                       WindowsErrorCode, 0, buffer, MAX_PATH, NULL)) {

        return FALSE;
    }

    return ErrorMessage->Initialize(buffer);
}


STATIC BOOLEAN
GetFileSecurityBackupW(
    LPCWSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded,
    BOOLEAN UseBackUp,
    PULONG FileAttributes
    )
/*++

Routine Description:

    This API returns top the caller a copy of the security descriptor
    protecting a file or directory.  Based on the caller's access
    rights and privileges, this procedure will return a security
    descriptor containing the requested security descriptor fields.
    To read the handle's security descriptor the caller must be
    granted READ_CONTROL access or be the owner of the object.  In
    addition, the caller must have SeSecurityPrivilege privilege to
    read the system ACL.

Arguments:

    lpFileName - Represents the name of the file or directory whose
                security is being retrieved.

    RequestedInformation - A pointer to the security information being
                requested.

    pSecurityDescriptor - A pointer to the buffer to receive a copy of
        the secrity descriptor protecting the object that the caller
        has the rigth to view.  The security descriptor is returned in
        self-relative format.

    nLength - The size, in bytes, of the security descriptor buffer.

    lpnLengthNeeded - A pointer to the variable to receive the number
        of bytes needed to store the complete secruity descriptor.  If
        returned number of bytes is less than or equal to nLength then
        the entire security descriptor is returned in the output
        buffer, otherwise none of the descriptor is returned.

    FileAttributes - returns the file attributes (hidden, system, etc).

Return Value:

    TRUE is returned for success, FALSE if access is denied or if the
        buffer is too small to hold the security descriptor.

--*/
{
    NTSTATUS Status;
    HANDLE FileHandle;
    ACCESS_MASK DesiredAccess;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME RelativeName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;
    PVOID FreeBuffer;
    ULONG Flags;

    DesiredAccess = SYNCHRONIZE | FILE_GENERIC_READ;

    if ((RequestedInformation & OWNER_SECURITY_INFORMATION) ||
        (RequestedInformation & GROUP_SECURITY_INFORMATION) ||
        (RequestedInformation & DACL_SECURITY_INFORMATION)) {
        DesiredAccess |= READ_CONTROL;
    }

    if ((RequestedInformation & SACL_SECURITY_INFORMATION)) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    if (!RtlDosPathNameToNtPathName_U(lpFileName, &FileName, NULL,
        &RelativeName)) {
        return(FALSE);
    }

    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length) {
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja, &FileName, OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory, NULL);

    if (UseBackUp) {
        Flags = FILE_OPEN_FOR_BACKUP_INTENT;
    } else {
        Flags = 0;
    }

    Status = NtOpenFile(&FileHandle, DesiredAccess, &Obja,
        &IoStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        Flags);

    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = NtQueryInformationFile(FileHandle, &IoStatusBlock, &BasicInfo,
        sizeof(BasicInfo), FileBasicInformation);

    if (!NT_SUCCESS(Status)) {
        NtClose(FileHandle);
        return FALSE;
    }

    *FileAttributes = BasicInfo.FileAttributes;

    Status = NtQuerySecurityObject(FileHandle, RequestedInformation,
        pSecurityDescriptor, nLength, lpnLengthNeeded);

    NtClose(FileHandle);

    return NT_SUCCESS(Status);
}


ULIB_EXPORT
BOOLEAN
SYSTEM::GetFileSecurityBackup(
    IN  PCPATH  Path,
    IN  SECURITY_INFORMATION SecurityInfo,
    OUT PSECURITY_ATTRIBUTES SecurityAttrib,
    OUT PULONG  FileAttributes
    )
/*++

Routine Description:

    This routine retrieves the security descriptor from the specified
    path.  The file is opened for BACKUP_READ, so if the right privilege
    is enabled it should be able to retrieve information even for files
    that the caller does not directly have access to.

Arguments:

    Path            - Specifies the path for which info is queried.
    SecurityInfo    - Specifies what types of information is to be retrieved.
    SecurityAttrib  - Returns the security descriptor and its size.
    FileAttributes  - Returns file attributes (hidden, system, etc.)

Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    ULONG cbSdSize, cbRequired;
    BOOLEAN bSuccess;
    PVOID psd;
    PCWSTR pcwsSource;
    const int LargeSecurityDescriptorSize = 6000;

    pcwsSource = Path->GetPathString()->GetWSTR();
    DebugPtrAssert(pcwsSource);

    cbSdSize = LargeSecurityDescriptorSize;

    if (NULL == (psd = MALLOC(cbSdSize))) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    bSuccess = GetFileSecurityBackupW(pcwsSource, SecurityInfo, psd, cbSdSize,
        &cbRequired, TRUE, FileAttributes);

    if (!bSuccess) {
        if (0 == cbRequired) {
            return FALSE;
        }
        cbSdSize = cbRequired;

        GlobalFree(psd);

        if (NULL == (psd = MALLOC(cbSdSize))) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        bSuccess = GetFileSecurityBackupW(pcwsSource, SecurityInfo, psd,
            cbSdSize, &cbRequired, TRUE, FileAttributes);

        if (!bSuccess) {
            return FALSE;
        }
    }

    SecurityAttrib->nLength = cbSdSize;
    SecurityAttrib->lpSecurityDescriptor = psd;
    SecurityAttrib->bInheritHandle = TRUE;

    return TRUE;
}

ULIB_EXPORT
VOID
SYSTEM::DisplaySystemError(
    IN DWORD ErrorCode,
    IN BOOL Exit
    )
{
    DWORD Result;
    LPTSTR Buffer;

    //
    //  Use the system to generate an error message.
    //

    Result = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                            NULL,
                            ErrorCode,
                            0,
                            (LPTSTR) &Buffer,
                            0,
                            NULL);
    if (Result)  {

        wprintf( L"%s", Buffer);
        LocalFree( Buffer);
    }

    if (Exit)  {

        PROGRAM::ExitProgram( EXIT_READWRITE_ERROR );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\substrng.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SUB_STRING

Abstract:

    Implementation of the SUB_STRING class.

Author:

    Stve Rowe (stever)

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "substrng.hxx"


#if DBG==1
	#define SUBSTRING_SIGNATURE	0xADDCACA1
#endif




DEFINE_CONSTRUCTOR( SUB_STRING, GENERIC_STRING );

DEFINE_CAST_MEMBER_FUNCTION( SUB_STRING );

VOID
SUB_STRING::Construct (
    )

/*++

Routine Description:

    Construct a SUBS_TRING by initializing it's internal state.

Arguments:

    None.

Return Value:

    None.

--*/

{
	_BaseString	= NULL;

#if DBG==1
	_Signature	 = SUBSTRING_SIGNATURE;
	_Initialized = FALSE;
#endif
}

SUB_STRING::~SUB_STRING ()

{
	Destroy();
}

VOID
SUB_STRING::Destroy (
    )

/*++

Routine Description:

	Detaches this substring from the chain (if it belongs to one).

Arguments:

	none

Return Value:

	none

--*/

{
	if ( _BaseString != NULL ) {
		//
		//	We extract ourselves from the substring chain
		//
		if (_Previous) {

			//
			//	Update the previous in the chain
			//
			DebugAssert( _Previous->_Signature == SUBSTRING_SIGNATURE );
			_Previous->_Next = _Next;

		}

		if ( _Next ) {

			//
			//	Update the next in the chain
			//
			DebugAssert( _Next->_Signature == SUBSTRING_SIGNATURE );
			_Next->_Previous = _Previous;

		}

	}

	//
	//	Forget everything about our previous life
	//
	_BaseString 		= NULL;
	_CountOfChars		= 0;
	_StartingPosition	= 0;
	_Next = _Previous	= NULL;

#if DBG==1
	_Initialized = FALSE;
#endif

}

BOOLEAN
SUB_STRING::InitializeChainHead (
	IN	PGENERIC_STRING BaseString
	)

/*++

Routine Description:

	Initializes the substring with a base string. This should be called
	only for the head of the substring chain.

Arguments:

	BaseString		- Supplies pointer to base string

Return Value:

	TRUE

--*/

{
	DebugPtrAssert( BaseString );

	DebugAssert( _BaseString == NULL );

	Destroy();

	GENERIC_STRING::Initialize();

	_BaseString = BaseString;

#if DBG==1
	_Initialized = TRUE;
#endif

	return TRUE;

}

BOOLEAN
SUB_STRING::InitializeChainNode (
	IN OUT	PSUB_STRING	SubString,
	IN		CHNUM		Position,
	IN		CHNUM		Length
    )

/*++

Routine Description:

	Links this substring to a substring chain.

	This method should ONLY be used by a string class, who knows about string
	chains.

Arguments:

	SubString		- Supplies pointer to a substring in the chain.
	Position		- Supplies the starting position value for this substring.
					  Note that this is relative to the BASE string.
	Length			- Supplies Number of Characters in substring.

Return Value:

	TRUE

--*/

{

	//
	//	It is a bug to call this method on a substring that already belongs
	//	to a chain.
	//
	DebugAssert( SubString && (SubString->_Signature == SUBSTRING_SIGNATURE) );
	DebugAssert( _BaseString == NULL );

	Destroy();

	GENERIC_STRING::Initialize();

	//
	//	Initialize our pointers and counters
	//
	_StartingPosition	= Position;
	_CountOfChars		= Length;

	//
	//	Add ourselves to the substring chain
	//
	_BaseString = SubString->_BaseString;
	_Next		= SubString->_Next;
	_Previous	= SubString;

	SubString->_Next = this;

	if (_Next) {
		DebugAssert( _Next->_Signature == SUBSTRING_SIGNATURE );
		_Next->_Previous = this;
	}

#if DBG==1
	_Initialized = TRUE;
#endif

	return TRUE;

}

PBYTE
SUB_STRING::GetInternalBuffer (
	IN	CHNUM	Position
	) CONST

/*++

Routine Description:

	Gets pointer to buffer containing the string.

Arguments:

	none

Return Value:

	Pointer to the buffer

--*/
{

	DebugAssert( Position < _CountOfChars );

	return _BaseString->GetInternalBuffer( _StartingPosition + Position );

}

BOOLEAN
SUB_STRING::IsChAt (
	IN		WCHAR	Ch,
    IN      CHNUM   Position
    ) CONST

/*++

Routine Description:

    Finds out if a certain character is at the specified position.

Arguments:

    Ch          -   Supplies the character to llok for
    Position    -   Supplies the position to look at

Return Value:

    TRUE if the character is at the specified position

--*/

{
	DebugAssert( _StartingPosition + Position < _CountOfChars );

	return ( QueryChAt( Position ) == Ch );

}

BOOLEAN
SUB_STRING::MakeNumber (
	OUT PLONG	Number,
    IN  CHNUM   Position,
    IN  CHNUM   Length
	) CONST

/*++

Routine Description:

    Converts the string to a number.

Arguments:

	Number		-	Pointer to returned number
    Position    -   Supplies the starting position
    Length      -   Supplies the length


Return Value:

	TRUE	if made a valid number
	FALSE	otherwise

--*/

{
	GetValidLength( Position, &Length );

	return _BaseString->MakeNumber( Number, _StartingPosition + Position, Length );
}

ULONG
SUB_STRING::QueryByteCount (
	IN	CHNUM	Position,
	IN	CHNUM	Length
	) CONST

/*++

Routine Description:

	Gets the number of bytes in the buffer containing this substring

Arguments:

    Position    -   Supplies the starting position
    Length      -   Supplies the length


Return Value:

	Number of bytes in buffer.

--*/

{

	GetValidLength( Position, &Length );

	return _BaseString->QueryByteCount( _StartingPosition + Position, Length );
}

CHNUM
SUB_STRING::QueryChCount (
    ) CONST

/*++

Routine Description:

	Returns the number of characters in this substring.

Arguments:

    None.

Return Value:

	The number of characters in this substring.

--*/

{
	DebugAssert( _Initialized );
	return _CountOfChars;
}

WCHAR
SUB_STRING::QueryChAt(
    IN CHNUM    Position
    ) CONST

/*++

Routine Description:

    returns the character at the supplied position.

Arguments:

    Position - Supplies the character position.

Return Value:

	Returns the character at the supplied position.

--*/

{
	DebugAssert( Position < _CountOfChars );

	if ( Position < _CountOfChars ) {
		return _BaseString->QueryChAt( _StartingPosition + Position );
	} else {
		return INVALID_CHAR;
	}
}


PGENERIC_STRING
SUB_STRING::QueryGenericString(
	IN	CHNUM		Position,
	IN	CHNUM		Length
    ) CONST

/*++

Routine Description:

	Obtains a string off this substring

Arguments:

    Position - Supplies the character position.
	Length	 - Supplies the length of the substring

Return Value:

    Pointer to the string

--*/

{
	GetValidLength( Position, &Length );

	return _BaseString->QueryGenericString( _StartingPosition + Position, Length );

}

PSTR
SUB_STRING::QuerySTR(
	IN		CHNUM	Position,
	IN		CHNUM	Length,
	IN OUT	PSTR	Buffer,
	IN		ULONG	BufferSize
	) CONST



/*++

Routine Description:

	Obtains a null-terminated multibyte string ( PSTR )

Arguments:

	Position	-	Supplies starting position
	Length		-	Supplies length (in characters) of substring desired
	Buffer		-	Supplies optional pointer to buffer
	BufferSize	-	Supplies length of the buffer (in bytes)

Return Value:

	Pointer to PSTR


--*/

{

	GetValidLength( Position, &Length );

	return _BaseString->QuerySTR( _StartingPosition + Position,
								  Length,
								  Buffer,
								  BufferSize );


}

PSUB_STRING
SUB_STRING::QuerySubString(
	IN	CHNUM		Position,
	IN	CHNUM		Length,
	OUT PSUB_STRING SubString
    )

/*++

Routine Description:

    Obtains a substring of this string

Arguments:

	Position	- Supplies the character position.
	Length		- Supplies the length of the substring
	SubString	- Supplies optional pointer to SUB_STRING object

Return Value:

    Pointer to the substring

--*/

{
	GetValidLength( Position, &Length );

	if (SubString == NULL) {
		SubString = NEW SUB_STRING;
	}

	if (SubString) {

		SubString->InitializeChainNode( this, _StartingPosition + Position, Length );

	}

	return SubString;

}

PWSTR
SUB_STRING::QueryWSTR (
	IN		CHNUM	Position,
	IN		CHNUM	Length,
	IN OUT	PWSTR	Buffer,
    IN      ULONG   BufferSize,
    IN      BOOLEAN ForceNull
	) CONST

/*++

Routine Description:

	Obtains a null-terminated wide	character string ( PWSTR )

Arguments:

	Position	-	Supplies starting position
	Length		-	Supplies length (in characters) of substring desired
	Buffer		-	Supplies optional pointer to buffer
    BufferSize  -   Supplies length of the buffer (in bytes)
    ForceNull   -   Supplies a flag which indicates, if TRUE, that the
                    returned string must be null-terminated.  If this
                    flag is not FALSE, QueryWSTR will return as much
                    of the string as fits in the buffer; if it is TRUE,
                    QueryWSTR will return as much as fits in the buffer
                    minus one character for the terminating NULL.


Return Value:

	Pointer to PWSTR


--*/

{
	GetValidLength( Position, &Length );

	return _BaseString->QueryWSTR( _StartingPosition + Position,
								   Length,
								   Buffer,
                                   BufferSize,
                                   ForceNull );

}

CHNUM
SUB_STRING::Strchr (
	IN WCHAR	 Char,
	IN CHNUM	 Position,
	IN CHNUM	 Length
    ) CONST

/*++

Routine Description:

    Searches for first occurence of a character in the string

Arguments:

    Char        -   Supplies character to match
    Position    -   Supplies index of first character where search
					will start.
	Length		-	Supplies length of the subsequence in which to
					search.

Return Value:


    Index within the string where the character was found.

--*/

{
	CHNUM	Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strchr( Char,
								_StartingPosition + Position,
								Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;

}

LONG
SUB_STRING::Strcmp (
	IN PCGENERIC_STRING		GenericString
    ) CONST

/*++

Routine Description:

    Does a case sensitive string compare.

Arguments:

	GenericString - Supplies a pointer to string to compare against

Return Value:

    == 0    - strings are equal
    <0      - this string is less then StringToCompare
    >0      - this string is greater then StringToCompare

--*/

{
    return _BaseString->StringCompare( _StartingPosition,
                                       _CountOfChars,
                                       GenericString,
                                       0,
                                       GenericString->QueryChCount() );
}

CHNUM
SUB_STRING::Strcspn (
	IN PCGENERIC_STRING		GenericString,
	IN CHNUM				Position,
	IN CHNUM				Length
	) CONST

/*++

Routine Description:

	Returns index of the first character that belongs to the set of
	characters provided in the generic string.

Arguments:

   GenericString	- Supplies the string to match from
   Position 		- Supplies position where match should start
   Length			- Supplies the length of the subsequence in which to
					  search.


Return Value:

	Index of the character that matched.

--*/

{
	CHNUM Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strcspn( GenericString,
								 _StartingPosition + Position,
								 Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;

}

LONG
SUB_STRING::Stricmp (
	IN PCGENERIC_STRING	GenericString
    ) CONST

/*++

Routine Description:

    Does a case insensitive string compare.

Arguments:

    String - Supplies a pointer to string to compare against

Return Value:

    == 0    - strings are equal
    <0      - this string is less then StringToCompare
    >0      - this string is greater then StringToCompare

--*/

{
    return _BaseString->StringCompare( _StartingPosition,
                                       _CountOfChars,
                                       GenericString,
                                       0,
                                       GenericString->QueryChCount(),
									   COMPARE_IGNORECASE );
}

LONG
SUB_STRING::StringCompare (
	IN CHNUM			Position1,
	IN CHNUM			Length1,
	IN PCGENERIC_STRING GenericString2,
	IN CHNUM			Position2,
	IN CHNUM			Length2,
	IN USHORT			CompareFlags
    ) CONST

/*++

Routine Description:

    Compares this string with another one

Arguments:

    Position1       -   Supplies Index within this string
    Length1         -   Supplies Length within this string
	GenericString2	-	Supplies other string
    Position2       -   Supplies index within other string
    Length2         -   Supplies length of other string
    CompareFlags    -   Supplies compare flags

Return Value:

    < 0 if this string lexically less than other
      0 if both strings the same
    > 0 if other string lexically more than this one

--*/
{
	GetValidLength( Position1, &Length1 );

	return _BaseString->StringCompare( _StartingPosition + Position1,
									   Length1,
									   GenericString2,
									   Position2,
									   Length2,
									   CompareFlags );
}

CHNUM
SUB_STRING::Strrchr (
	IN WCHAR	Char,
	IN CHNUM	Position,
	IN CHNUM	Length
    ) CONST

/*++

Routine Description:

    Finds last occurrence of the character to match in the string.

Arguments:

	Char		- Supplies the character to match
	Position	- Supplies the starting position
	Length		- Supplies length of subsequence in which to search.

Return Value:

    Index of last occurence of the character

--*/

{
	CHNUM Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strrchr( Char,
								 _StartingPosition + Position,
								 Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;
}

CHNUM
SUB_STRING::StrLen (
    ) CONST

/*++

Routine Description:

	Returns the number of characters in this substring.

Arguments:

    None.

Return Value:

	The number of characters in this substring.

--*/

{
	return _CountOfChars;
}

CHNUM
SUB_STRING::Strspn (
	IN PCGENERIC_STRING		GenericString,
	IN CHNUM				Position,
	IN CHNUM				Length
    ) CONST

/*++

Routine Description:

    Returns index of the first character in the string that
    does not belong to the set of characters in the string to match.

Arguments:

    String   -   Supplies pointer to string to match from
    Position -   Supplies initial position to start search
    Length   -   Supplies length.

Return Value:

    Index of the first character that does not belong to the set
    of characters in the string passed.

--*/

{
	CHNUM	Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strspn( GenericString,
								 _StartingPosition + Position,
								 Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;
}

CHNUM
SUB_STRING::Strstr (
	IN PCGENERIC_STRING	GenericString,
	IN CHNUM			Position,
	IN CHNUM			Length
    ) CONST

/*++

Routine Description:

	Returns the index of the first occurrence of a string within us.

Arguments:

	GenericString	- Supplies pointer to string to match from
	Position		- Supplies initial position to start search
	Length			- Supplies the length of the subsequence in which to
					  search.

Return Value:

	Index of first occurence of the string

--*/

{

	CHNUM	Pos;

	GetValidLength( Position, &Length );

	Pos =  _BaseString->Strstr( GenericString,
								 _StartingPosition + Position,
								 Length );

	return (Pos == INVALID_CHNUM) ? INVALID_CHNUM : Pos - _StartingPosition;
}


BOOLEAN
SUB_STRING::Replace (
	IN	PCGENERIC_STRING	String2,
	IN	CHNUM				Position,
	IN	CHNUM				Length,
	IN	CHNUM				Position2,
	IN	CHNUM				Length2
	)

/*++

Routine Description:

	Illegal method in SUB_STRING

Arguments:

    String2     -   Supplies pointer to other string
	Position	-	Suplies the starting position to start copy
	Lengh		-	Supplies the length of the portion to replace
    Position2   -   Supplies position in other string
    Length2     -   Supplies length to copy

Return Value:

	FALSE

--*/

{
	UNREFERENCED_PARAMETER( String2 );
	UNREFERENCED_PARAMETER( Position );
	UNREFERENCED_PARAMETER( Length );
	UNREFERENCED_PARAMETER( Position2 );
	UNREFERENCED_PARAMETER( Length2 );

	DebugAssert( FALSE );
	return FALSE;
}

BOOLEAN
SUB_STRING::SetChAt(
	IN		WCHAR	Char,
	IN		CHNUM	Position,
	IN		CHNUM	Length
    )

/*++

Routine Description:

	Illegal method in SUB_STRING

Arguments:

	Char		-	Supplies the character to set.
	Position	-	Supplies the character position to set.
	Length		-	Supplies the number of characters to set.

Return Value:

	FALSE

--*/

{
	UNREFERENCED_PARAMETER( Char );
	UNREFERENCED_PARAMETER( Position );
	UNREFERENCED_PARAMETER( Length );

	DebugAssert( FALSE );
	return FALSE;

}

BOOLEAN
SUB_STRING::Update (
	IN	CHNUM	Length
    )

/*++

Routine Description:

	Updates a substring. When the length of the base string changes, the
	new length has to be propagated along the substring chain, so that
	substrings are maintained up-to-date.  Each substring is responsible
	for propagating the new length to its successors in the chain.


Arguments:

	Length	-	Supplies the new length of the base string


Return Value:

    TRUE if updated, FALSE otherwise.

--*/

{

	//
	//	Set the new starting position
	//
	_StartingPosition = min ( _StartingPosition, Length - 1);

	//
	//	Set the new length
	//
	if ( _StartingPosition + _CountOfChars > Length ) {

		_CountOfChars = Length - _StartingPosition;
    }

	//
	//	Propagate along the chain
	//
	if ( _Next ) {

		DebugAssert( _Next->_Signature == SUBSTRING_SIGNATURE );
		return _Next->Update( Length );
	}

    return TRUE;

}


/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    DYNAMIC_SUB_STRING

Abstract:

    Implementation of the DYNAMIC_SUB_STRING class.

Author:

    Stve Rowe (stever)

Environment:

    ULIB, User Mode

--*/

DEFINE_CONSTRUCTOR( DYNAMIC_SUB_STRING, SUB_STRING);

VOID
DYNAMIC_SUB_STRING::Construct (
    )

{
	UNREFERENCED_PARAMETER( (void)this );
}

BOOLEAN
DYNAMIC_SUB_STRING::Copy (
	IN PCGENERIC_STRING GenericString
    )
/*++

Routine Description:

	Copies one substring to another. The size of the substring changes

Arguments:

    None.

Return Value:

    TRUE if copied, false otherwise

--*/

{

	DebugPtrAssert( GenericString );

	if	( GetBaseString()->Replace( GenericString,
									QueryStartingPosition(),
									QueryChCount(),
									0,
									GenericString->QueryChCount() )) {
		//
		//	Update the length
		//
		SetChCount( GenericString->QueryChCount());

		return TRUE;
	}

	return FALSE;
}

BOOLEAN
DYNAMIC_SUB_STRING::SetChAt(
	IN		WCHAR	Char,
	IN		CHNUM	Position,
	IN		CHNUM	Length
    )

/*++

Routine Description:

	Sets the specified number of characters, starting at a certain
	position, with the supplied character.

Arguments:

	Char		-	Supplies the character to set.
	Position	-	Supplies the character position to set.
	Length		-	Supplies the number of characters to set.

Return Value:

	BOOLEAN - Returns TRUE if the characters were succesfully set.

--*/

{

	GetValidLength( Position, &Length );

	return GetBaseString()->SetChAt( Char,
									 QueryStartingPosition() + Position,
									 Length );

}

CHNUM
DYNAMIC_SUB_STRING::Truncate(
	IN		CHNUM	Position
    )

/*++

Routine Description:

	Truncates the substring at the specified position. The corresponding
	part of the base string is chopped out.

Arguments:

	Position	-	Supplies the character position where truncation is to
					occur.

Return Value:

	CHNUM	- Returns new size of the substring

--*/

{


	DebugAssert( Position < QueryStartingPosition() + QueryChCount() );

	if	( GetBaseString()->Replace( NULL,
									QueryStartingPosition() + Position,
									QueryChCount() - Position,
									0,
									0 )) {
		//
		//	Update the length
		//
		SetChCount( Position );

	}

	return QueryChCount();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\tmackmsg.cxx ===
/*++

Copyright (c) 1991-1996 Microsoft Corporation

Module Name:

    tmackmsg.cxx

Abstract:

    Contains the implementation of the TM_AUTOCHECK_MESSAGE subclass.

Author:

    Daniel Chan (DanielCh) 11-11-96

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "windows.h"

#include "fmifs.h"
#include "setupdd.h"

#include "tmackmsg.hxx"


DEFINE_CONSTRUCTOR(TM_AUTOCHECK_MESSAGE, AUTOCHECK_MESSAGE);

TM_AUTOCHECK_MESSAGE::~TM_AUTOCHECK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for TM_AUTOCHECK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
TM_AUTOCHECK_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // nothing to do
    //
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   attributes;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatusBlock;

    RtlInitUnicodeString(&unicodeString, DD_SETUP_DEVICE_NAME_U);

    InitializeObjectAttributes(&attributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenFile(&_handle,
                        FILE_GENERIC_READ,
                        &attributes,
                        &ioStatusBlock,
                        FILE_SHARE_READ,
                        FILE_OPEN);

    if (!NT_SUCCESS(status)) {
        _handle = NULL;
        DebugPrintTrace(("Unable to obtain a handle from setup device driver ( %08X )\n", status));
    }

    _base_percent = 0;
    _percent_divisor = 1;
    _kilobytes_total_disk_space = 0;
    _values_in_mb = 0;
}


VOID
TM_AUTOCHECK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // nothing to do
    //
    if (_handle) {
        NtClose(_handle);
        _handle = NULL;
    }
}


BOOLEAN
TM_AUTOCHECK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine outputs the message to the debugger (if checked build).
    It also sends messages to the setup device driver.
    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR                buffer[256];
    DSTRING             display_string;
    SETUP_FMIFS_MESSAGE setupDisplayInfo;
    BOOLEAN             match = FALSE;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatusBlock;
    ULONG               unit_bits = 0;

    FMIFS_PERCENT_COMPLETE_INFORMATION  percent_info;
    FMIFS_FORMAT_REPORT_INFORMATION     chkdsk_report;

    if (!BASE_SYSTEM::QueryResourceStringV(&display_string, GetMessageId(), Format,
                                           VarPointer)) {
        return FALSE;
    }

    //
    // Log the output if necessary
    //
    if (IsLoggingEnabled() && !IsSuppressedMessage()) {
        LogMessage(&display_string);
    }

    //
    // Send the output to the debug port.
    //
    if( display_string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {

        if (MSG_HIDDEN_STATUS != GetMessageId()) {
            DebugPrint(buffer);
        }

        if (_handle) {

            switch (GetMessageId()) {
                case MSG_CHK_NTFS_CHECKING_FILES:       // first stage
                    _base_percent = 0;
                    _percent_divisor = 4;
                    break;

                case MSG_CHK_NTFS_CHECKING_INDICES:     // second stage
                    _base_percent = 25;
                    _percent_divisor = 4;
                    break;

                case MSG_CHK_NTFS_CHECKING_SECURITY:    // third stage
                    _base_percent = 50;
                    _percent_divisor = 4;
                    break;

                case MSG_CHK_NTFS_RESETTING_USNS:       // optional fourth stage
                    _base_percent = 75;
                    _percent_divisor = 8;
                    break;

                case MSG_CHK_NTFS_RESETTING_LSNS:       // optional fifth stage
                    _base_percent = 87;
                    _percent_divisor = 8;
                    break;

                case MSG_PERCENT_COMPLETE:
                case MSG_PERCENT_COMPLETE2:
                    percent_info.PercentCompleted = va_arg(VarPointer, ULONG)/_percent_divisor+_base_percent;
                    setupDisplayInfo.FmifsPacket = (PVOID)&percent_info;
                    setupDisplayInfo.FmifsPacketType = FmIfsPercentCompleted;
                    match = TRUE;
                    break;

                case MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_MB:
                    unit_bits = TOTAL_DISK_SPACE_IN_MB;

                    // fall thru

                case MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_KB:
                    _values_in_mb = unit_bits;
                    _kilobytes_total_disk_space = va_arg(VarPointer, ULONG);

                    //
                    // drop through to fake a 100% completion as we are already at
                    // the very final statistics stage
                    //
                case MSG_CHK_VOLUME_CLEAN:
                    // This is the case when the drive is not dirty and autochk
                    // returns right away.  Setup needs a way to cancel/close the
                    // progress bar.
                    percent_info.PercentCompleted = 100;
                    setupDisplayInfo.FmifsPacket = (PVOID)&percent_info;
                    setupDisplayInfo.FmifsPacketType = FmIfsPercentCompleted;
                    match = TRUE;
                    break;

                case MSG_CHK_NTFS_AVAILABLE_SPACE_IN_MB:
                    _values_in_mb |= BYTES_AVAILABLE_IN_MB;

                    // fall thru

                case MSG_CHK_NTFS_AVAILABLE_SPACE_IN_KB:
                    chkdsk_report.KiloBytesTotalDiskSpace = _kilobytes_total_disk_space;
                    chkdsk_report.KiloBytesAvailable = va_arg(VarPointer, ULONG);
                    setupDisplayInfo.FmifsPacket = (PVOID)&chkdsk_report;
                    setupDisplayInfo.FmifsPacketType = FmIfsFormatReport;
                    match = TRUE;
                    break;

                case MSG_DASD_ACCESS_DENIED:
                    setupDisplayInfo.FmifsPacket = NULL;
                    setupDisplayInfo.FmifsPacketType = FmIfsAccessDenied;
                    match = TRUE;
                    break;
            }
            if (match) {

                status = NtDeviceIoControlFile(_handle,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &ioStatusBlock,
                                               IOCTL_SETUP_FMIFS_MESSAGE,
                                               &setupDisplayInfo,
                                               sizeof(setupDisplayInfo),
                                               NULL,
                                               0);

                if (!NT_SUCCESS(status)) {
                    DebugPrintTrace(("Unable to send message to setup ( %08X )", status));
                }
            }

        }
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOLEAN
TM_AUTOCHECK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries a response of yes or no.

Arguments:

    Default - Supplies a default in the event that a query is not possible.

Return Value:

    FALSE   - The answer is no.
    TRUE    - The answer is yes.

--*/
{
    CHAR            buffer[256];
    DSTRING         string;

    if (!BASE_SYSTEM::QueryResourceString(&string, Default ? MSG_YES : MSG_NO, "")) {
        return Default;
    }

    //
    // Send the output to the debug port.
    //
    if( string.QuerySTR( 0, TO_END, buffer, 256, TRUE ) ) {
        DebugPrint(buffer);
    }

    return Default;
}

BOOLEAN
TM_AUTOCHECK_MESSAGE::IsInAutoChk(
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate it is not
    in regular autochk.

Arguments:

    None.

Return Value:

    FALSE   - Not in autochk

--*/
{
    return FALSE;
}

BOOLEAN
TM_AUTOCHECK_MESSAGE::IsInSetup(
)
/*++

Routine Description:

    This routine simply returns TRUE to indicate it is in
    setup.

Arguments:

    None.

Return Value:

    FALSE   - Not in setup

--*/
{
    return TRUE;
}

BOOLEAN
TM_AUTOCHECK_MESSAGE::IsKeyPressed(
    MSGID       MsgId,
    ULONG       TimeOutInSeconds
)
/*++

Routine Description:

    This routine simply returns FALSE to indicate no
    key has been pressed.

Arguments:

    None.

Return Value:

    FALSE   - No key is pressed within the time out period.

--*/
{
    // unreferenced parameters
    (void)(this);
    UNREFERENCED_PARAMETER( MsgId );
    UNREFERENCED_PARAMETER( TimeOutInSeconds );

    return FALSE;
}

BOOLEAN
TM_AUTOCHECK_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    This routine waits for a signal from the user.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unreferenced parameters
    (void)(this);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\ulib.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    ulib.cxx

Abstract:

    This module contains run-time, global support for the ULIB class library.
    This support includes:

        - creation of CLASS_DESCRIPTORs
        - Global objects
        - Ulib to Win32 API mapping functions

Author:

    David J. Gilman (davegi) 05-Dec-1990

Environment:

    ULIB, User Mode

Notes:

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

#include "system.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "bitvect.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filestrm.hxx"
#include "filter.hxx"
#include "keyboard.hxx"
#include "message.hxx"
#include "wstring.hxx"
#include "path.hxx"
#include "pipestrm.hxx"
#include "prtstrm.hxx"
#include "screen.hxx"
#include "stream.hxx"
#include "timeinfo.hxx"

#include <locale.h>

#endif // _AUTOCHECK_ || _SETUP_LOADER_


//
// Constants
//

CONST CLASS_ID  NIL_CLASS_ID    = 0;

#if defined(RUN_ON_W2K) && ((DBG==1) || defined(_AUTOCHECK_DBG_))
ULIB_EXPORT
VOID
DebugPrintfReal2(
    IN ULONG    ComponentId,
    IN ULONG    Level,
    IN PCSTR    Format,
    IN ...
    )

/*++

Routine Description:

    Printf to the debug console.

Arguments:

    Format      - Supplies a printf style format string.

Return Value:

    None.

--*/

{
    va_list     args;

    va_start( args, Format );
#if DBG==1
    DebugPrintfReal(Format, args);
#else defined(_AUTOCHECK_DBG_)
    DbgPrint((PCH)Format, args);
#endif
    va_end( args );
}
#endif // defined(RUN_ON_W2K) && ((DBG==1) || defined(_AUTOCHECK_DBG_))

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

#if DBG==1

//
// UlibGlobalFlag is used to selectively enable debugging options at
// run-time.
//

ULONG           UlibGlobalFlag     = 0x00000000;

ULIB_EXPORT
VOID
DebugPrintfReal(
    IN PCSTR    Format,
    IN ...
    )

/*++

Routine Description:

    Printf to the debug console.

Arguments:

    Format      - Supplies a printf style format string.

Return Value:

    None.

--*/

{
    STR         Buffer[ 512 ];
    va_list     args;

    va_start( args, Format );
    vsprintf( Buffer, Format, args );
    va_end( args );
    OutputDebugStringA( Buffer );
}
#endif // DBG

//
// GLobal object pointers.
//

// Clients of the DLL cannot access the DLL's
// global data yet, so I have the delightful hacks to get at it.

ULIB_EXPORT
PSTREAM
Get_Standard_Input_Stream(
 )
{
    return Standard_Input_Stream;
}

ULIB_EXPORT
PSTREAM
Get_Standard_Output_Stream(
 )
{
    return Standard_Output_Stream;
}

ULIB_EXPORT
PSTREAM
Get_Standard_Error_Stream(
 )
{
    return Standard_Error_Stream;
}

PSTREAM     Standard_Input_Stream;
PSTREAM     Standard_Output_Stream;
PSTREAM     Standard_Error_Stream;

#endif // _AUTOCHECK_ || _SETUP_LOADER_

//
//  Declare class descriptors for all classes.
//

DECLARE_CLASS(  CLASS_DESCRIPTOR        );

DECLARE_CLASS(  ARGUMENT                );
DECLARE_CLASS(  ARGUMENT_LEXEMIZER      );
DECLARE_CLASS(  ARRAY                   );
DECLARE_CLASS(  ARRAY_ITERATOR          );
DECLARE_CLASS(  BDSTRING                );
DECLARE_CLASS(  BITVECTOR               );
DECLARE_CLASS(  BUFFER_STREAM           );
DECLARE_CLASS(  BYTE_STREAM             );
DECLARE_CLASS(  CHKDSK_MESSAGE          );
DECLARE_CLASS(  COMM_DEVICE             );
DECLARE_CLASS(  CONT_MEM                );
DECLARE_CLASS(  CONTAINER               );
DECLARE_CLASS(  DSTRING                 );
DECLARE_CLASS(  FILE_STREAM             );
DECLARE_CLASS(  FLAG_ARGUMENT           );
DECLARE_CLASS(  FSNODE                  );
DECLARE_CLASS(  FSN_DIRECTORY           );
DECLARE_CLASS(  FSN_FILE                );
DECLARE_CLASS(  FSN_FILTER              );
DECLARE_CLASS(  FSTRING                 );
DECLARE_CLASS(  HMEM                    );
DECLARE_CLASS(  ITERATOR                );
DECLARE_CLASS(  KEYBOARD                );
DECLARE_CLASS(  LIST                    );
DECLARE_CLASS(  LIST_ITERATOR           );
DECLARE_CLASS(  LONG_ARGUMENT           );
DECLARE_CLASS(  MEM                     );
DECLARE_CLASS(  MESSAGE                 );
DECLARE_CLASS(  MULTIPLE_PATH_ARGUMENT  );
DECLARE_CLASS(  OBJECT                  );
DECLARE_CLASS(  PATH                    );
DECLARE_CLASS(  PATH_ARGUMENT           );
DECLARE_CLASS(  PIPE                    );
DECLARE_CLASS(  PIPE_STREAM             );
DECLARE_CLASS(  PROGRAM                 );
DECLARE_CLASS(  PRINT_STREAM            );
DECLARE_CLASS(  REST_OF_LINE_ARGUMENT   );
DECLARE_CLASS(  SCREEN                  );
DECLARE_CLASS(  SEQUENTIAL_CONTAINER    );
DECLARE_CLASS(  SORTABLE_CONTAINER      );
DECLARE_CLASS(  SORTED_LIST             );
DECLARE_CLASS(  SORTED_LIST_ITERATOR    );
DECLARE_CLASS(  STREAM_MESSAGE          );
DECLARE_CLASS(  STACK                   );
DECLARE_CLASS(  STREAM                  );
DECLARE_CLASS(  WSTRING                 );
DECLARE_CLASS(  BSTRING                 );
DECLARE_CLASS(  STRING_ARGUMENT         );
DECLARE_CLASS(  STRING_ARRAY            );
DECLARE_CLASS(  TIMEINFO                );
DECLARE_CLASS(  TIMEINFO_ARGUMENT       );
DECLARE_CLASS(  STATIC_MEM_BLOCK_MGR    );
DECLARE_CLASS(  MEM_ALLOCATOR           );
DECLARE_CLASS(  MEM_BLOCK_MGR           );


#if defined( _AUTOCHECK_ )

    DECLARE_CLASS( AUTOCHECK_MESSAGE    );
    DECLARE_CLASS( TM_AUTOCHECK_MESSAGE );

#endif // _AUTOCHECK_





//
//  Local prototypes
//
STATIC
BOOLEAN
DefineClassDescriptors (
    );

STATIC
BOOLEAN
UndefineClassDescriptors (
    );

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

BOOLEAN
CreateStandardStreams (
    );

PSTREAM
GetStandardStream (
    IN HANDLE       Handle,
    IN STREAMACCESS Access
    );

#endif // _AUTOCHECK_ || _SETUP_LOADER_

BOOLEAN
DllMain (
    IN HANDLE   DllHandle,
    IN ULONG    Reason,
    IN PVOID    Reserved
    )

/*++

Routine Description:

    Initilize Ulib by constructing and initializing all global objects. These
    include:

        - all CLASS_DESCRIPTORs (class_cd)
        - SYSTEM (System)
        - Standard streams

Arguments:

    DllHandle   - Not used.
    Reason      - Supplies the reason why the entry point was called.
    Reserved    - Not used.

Return Value:

    BOOLEAN - Returns TRUE if all global objects were succesfully constructed
        and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Reserved );

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ )

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Ulib initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_ULIB_MEM_LEAK)
    DebugPrint("ULIB.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ and _SETUP_LOADER_ not defined

    STATIC ULONG   count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrintTrace(("ULIB.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            //
            // Initialization of ULIB can no longer depend on
            // the initialization of the standard streams since they don't seem
            // to exist for Windows programs (no console...)
            //

            if( !DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Ulib initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_ULIB_MEM_LEAK)
            DebugPrint("ULIB.DLL got attached.\n");
#endif

            CreateStandardStreams();

            {
                UINT Codepage;
                char achCodepage[12] = ".OCP";      // ".", "uint in decimal", null
                if (Codepage = GetConsoleOutputCP()) {
                    wsprintfA(achCodepage, ".%u", Codepage);
                }
                setlocale(LC_ALL, achCodepage);
            }

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrintTrace(("ULIB.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrint("ULIB.DLL got detached.\n");
#endif

                UndefineClassDescriptors();

                DELETE(Standard_Input_Stream);
                DELETE(Standard_Output_Stream);
                DELETE(Standard_Error_Stream);

                count--;
            } else {
#if defined(TRACE_ULIB_MEM_LEAK)
                DebugPrint("ULIB.DLL detached more than attached\n");
#endif
            }
            break;

        break;

    }
#endif // _AUTOCHECK || _SETUP_LOADER_

    return( TRUE );

}

BOOLEAN
InitializeUlib (
    IN HANDLE   DllHandle,
    IN ULONG    Reason,
    IN PVOID    Reserved
    )
{
    return DllMain(DllHandle, Reason, Reserved);
}




STATIC
BOOLEAN
DefineClassDescriptors (
    )

/*++

Routine Description:

    Defines all the class descriptors used by ULIB

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              constructed and initialized.

--*/

{

    // This is broken up into many ifs because of compiler limitations.

    BOOLEAN Success = TRUE;

    if (Success                                               &&
        DEFINE_CLASS_DESCRIPTOR(    ARGUMENT                ) &&
        DEFINE_CLASS_DESCRIPTOR(    ARGUMENT_LEXEMIZER      ) &&
        DEFINE_CLASS_DESCRIPTOR(    ARRAY                   ) &&
        DEFINE_CLASS_DESCRIPTOR(    ARRAY_ITERATOR          ) &&
        DEFINE_CLASS_DESCRIPTOR(    BDSTRING                ) &&
        DEFINE_CLASS_DESCRIPTOR(    BITVECTOR               ) &&
        DEFINE_CLASS_DESCRIPTOR(    BYTE_STREAM             ) &&
        DEFINE_CLASS_DESCRIPTOR(    CHKDSK_MESSAGE          ) &&
        DEFINE_CLASS_DESCRIPTOR(    COMM_DEVICE             ) &&
        DEFINE_CLASS_DESCRIPTOR(    CONTAINER               ) &&
        DEFINE_CLASS_DESCRIPTOR(    DSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    FLAG_ARGUMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSNODE                  ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSN_DIRECTORY           ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSN_FILE                ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSN_FILTER              ) &&
        DEFINE_CLASS_DESCRIPTOR(    ITERATOR                ) &&
        DEFINE_CLASS_DESCRIPTOR(    LIST                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    LIST_ITERATOR           ) &&
        DEFINE_CLASS_DESCRIPTOR(    LONG_ARGUMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR(    MULTIPLE_PATH_ARGUMENT  ) &&
        DEFINE_CLASS_DESCRIPTOR(    PATH                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    PATH_ARGUMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR(    PROGRAM                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    SEQUENTIAL_CONTAINER    ) &&
        DEFINE_CLASS_DESCRIPTOR(    SORTABLE_CONTAINER      ) &&
        DEFINE_CLASS_DESCRIPTOR(    SORTED_LIST             ) &&
        DEFINE_CLASS_DESCRIPTOR(    SORTED_LIST_ITERATOR    ) &&
        DEFINE_CLASS_DESCRIPTOR(    WSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    BSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    STRING_ARGUMENT         ) &&
        DEFINE_CLASS_DESCRIPTOR(    STRING_ARRAY            ) &&
        DEFINE_CLASS_DESCRIPTOR(    TIMEINFO                ) &&
        DEFINE_CLASS_DESCRIPTOR(    TIMEINFO_ARGUMENT       ) &&
        DEFINE_CLASS_DESCRIPTOR(    MESSAGE                 ) &&
        TRUE ) {
    } else {
        Success = FALSE;
    }

    if (Success                                               &&
        DEFINE_CLASS_DESCRIPTOR(    BUFFER_STREAM           ) &&
        DEFINE_CLASS_DESCRIPTOR(    CONT_MEM                ) &&
        TRUE ) {
    } else {
        Success = FALSE;
    }

    if (Success                                               &&
        DEFINE_CLASS_DESCRIPTOR(    FILE_STREAM             ) &&
        DEFINE_CLASS_DESCRIPTOR(    FSTRING                 ) &&
        DEFINE_CLASS_DESCRIPTOR(    HMEM                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    STATIC_MEM_BLOCK_MGR    ) &&
        DEFINE_CLASS_DESCRIPTOR(    MEM_ALLOCATOR           ) &&
        DEFINE_CLASS_DESCRIPTOR(    MEM_BLOCK_MGR           ) &&
        TRUE ) {
    } else {
        Success = FALSE;
    }

    if (Success                                               &&
        DEFINE_CLASS_DESCRIPTOR(    KEYBOARD                ) &&
        DEFINE_CLASS_DESCRIPTOR(    MEM                     ) &&
        DEFINE_CLASS_DESCRIPTOR(    PIPE                    ) &&
        DEFINE_CLASS_DESCRIPTOR(    PIPE_STREAM             ) &&
        DEFINE_CLASS_DESCRIPTOR(    PRINT_STREAM            ) &&


        DEFINE_CLASS_DESCRIPTOR(    REST_OF_LINE_ARGUMENT   ) &&
        DEFINE_CLASS_DESCRIPTOR(    SCREEN                  ) &&
        DEFINE_CLASS_DESCRIPTOR(    STREAM                  ) &&
        DEFINE_CLASS_DESCRIPTOR(    STREAM_MESSAGE          ) &&

#if defined( _AUTOCHECK_ )

        DEFINE_CLASS_DESCRIPTOR(    AUTOCHECK_MESSAGE       ) &&
        DEFINE_CLASS_DESCRIPTOR(    TM_AUTOCHECK_MESSAGE    ) &&

#endif // _AUTOCHECK_

        TRUE ) {
    } else {
        Success = FALSE;
    }


    if  (!Success) {
        DebugPrint( "Could not initialize class descriptors!");
    }
    return Success;

}


STATIC
BOOLEAN
UndefineClassDescriptors (
    )

/*++

Routine Description:

    Defines all the class descriptors used by ULIB

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              constructed and initialized.

--*/

{

    UNDEFINE_CLASS_DESCRIPTOR(    ARGUMENT                );
    UNDEFINE_CLASS_DESCRIPTOR(    ARGUMENT_LEXEMIZER      );
    UNDEFINE_CLASS_DESCRIPTOR(    ARRAY                   );
    UNDEFINE_CLASS_DESCRIPTOR(    ARRAY_ITERATOR          );
    UNDEFINE_CLASS_DESCRIPTOR(    BDSTRING                );
    UNDEFINE_CLASS_DESCRIPTOR(    BITVECTOR               );
    UNDEFINE_CLASS_DESCRIPTOR(    BYTE_STREAM             );
    UNDEFINE_CLASS_DESCRIPTOR(    CHKDSK_MESSAGE          );
    UNDEFINE_CLASS_DESCRIPTOR(    COMM_DEVICE             );
    UNDEFINE_CLASS_DESCRIPTOR(    CONTAINER               );
    UNDEFINE_CLASS_DESCRIPTOR(    DSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    FLAG_ARGUMENT           );
    UNDEFINE_CLASS_DESCRIPTOR(    FSNODE                  );
    UNDEFINE_CLASS_DESCRIPTOR(    FSN_DIRECTORY           );
    UNDEFINE_CLASS_DESCRIPTOR(    FSN_FILE                );
    UNDEFINE_CLASS_DESCRIPTOR(    FSN_FILTER              );
    UNDEFINE_CLASS_DESCRIPTOR(    ITERATOR                );
    UNDEFINE_CLASS_DESCRIPTOR(    LIST                    );
    UNDEFINE_CLASS_DESCRIPTOR(    LIST_ITERATOR           );
    UNDEFINE_CLASS_DESCRIPTOR(    LONG_ARGUMENT           );
    UNDEFINE_CLASS_DESCRIPTOR(    MULTIPLE_PATH_ARGUMENT  );
    UNDEFINE_CLASS_DESCRIPTOR(    PATH                    );
    UNDEFINE_CLASS_DESCRIPTOR(    PATH_ARGUMENT           );
    UNDEFINE_CLASS_DESCRIPTOR(    PROGRAM                 );
    UNDEFINE_CLASS_DESCRIPTOR(    SEQUENTIAL_CONTAINER    );
    UNDEFINE_CLASS_DESCRIPTOR(    SORTABLE_CONTAINER      );
    UNDEFINE_CLASS_DESCRIPTOR(    SORTED_LIST             );
    UNDEFINE_CLASS_DESCRIPTOR(    SORTED_LIST_ITERATOR    );
    UNDEFINE_CLASS_DESCRIPTOR(    WSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    BSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    STRING_ARGUMENT         );
    UNDEFINE_CLASS_DESCRIPTOR(    STRING_ARRAY            );
    UNDEFINE_CLASS_DESCRIPTOR(    TIMEINFO                );
    UNDEFINE_CLASS_DESCRIPTOR(    TIMEINFO_ARGUMENT       );
    UNDEFINE_CLASS_DESCRIPTOR(    MESSAGE                 );

    UNDEFINE_CLASS_DESCRIPTOR(    BUFFER_STREAM           );
    UNDEFINE_CLASS_DESCRIPTOR(    CONT_MEM                );

    UNDEFINE_CLASS_DESCRIPTOR(    FILE_STREAM             );
    UNDEFINE_CLASS_DESCRIPTOR(    FSTRING                 );
    UNDEFINE_CLASS_DESCRIPTOR(    HMEM                    );
    UNDEFINE_CLASS_DESCRIPTOR(    STATIC_MEM_BLOCK_MGR    );
    UNDEFINE_CLASS_DESCRIPTOR(    MEM_ALLOCATOR           );
    UNDEFINE_CLASS_DESCRIPTOR(    MEM_BLOCK_MGR           );

    UNDEFINE_CLASS_DESCRIPTOR(    KEYBOARD                );
    UNDEFINE_CLASS_DESCRIPTOR(    MEM                     );
    UNDEFINE_CLASS_DESCRIPTOR(    PIPE                    );
    UNDEFINE_CLASS_DESCRIPTOR(    PIPE_STREAM             );
    UNDEFINE_CLASS_DESCRIPTOR(    PRINT_STREAM            );


    UNDEFINE_CLASS_DESCRIPTOR(    REST_OF_LINE_ARGUMENT   );
    UNDEFINE_CLASS_DESCRIPTOR(    SCREEN                  );
    UNDEFINE_CLASS_DESCRIPTOR(    STREAM                  );
    UNDEFINE_CLASS_DESCRIPTOR(    STREAM_MESSAGE          );

#if defined( _AUTOCHECK_ )

    UNDEFINE_CLASS_DESCRIPTOR(    AUTOCHECK_MESSAGE       );
    UNDEFINE_CLASS_DESCRIPTOR(    TM_AUTOCHECK_MESSAGE    );

#endif // _AUTOCHECK_

    return TRUE;

}


#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )

BOOLEAN
CreateStandardStreams (
    )

/*++

Routine Description:

    Creates the standard streams

Arguments:

    None.

Return Value:

    TRUE if the streams were successfully created,
    FALSE otherwise

--*/

{

    Standard_Input_Stream   = GetStandardStream( GetStdHandle( STD_INPUT_HANDLE),
                                                 READ_ACCESS );

    Standard_Output_Stream  = GetStandardStream( GetStdHandle( STD_OUTPUT_HANDLE),
                                                 WRITE_ACCESS );

    Standard_Error_Stream   = GetStandardStream( GetStdHandle( STD_ERROR_HANDLE),
                                                 WRITE_ACCESS );


    return ( (Standard_Input_Stream  != NULL) &&
             (Standard_Output_Stream != NULL) &&
             (Standard_Error_Stream  != NULL) );
}

PSTREAM
GetStandardStream (
    IN HANDLE       Handle,
    IN STREAMACCESS Access
    )

/*++

Routine Description:

    Creates a standard stream out of a standard handle

Arguments:

    Handle  -   Supplies the standard handle
    Access  -   Supplies the access.

Return Value:

    Pointer to the stream object created.

--*/


{
    PSTREAM         Stream = NULL;
    PFILE_STREAM    FileStream;
    PPIPE_STREAM    PipeStream;
    PKEYBOARD       Keyboard;
    PSCREEN         Screen;


    switch ( GetFileType( Handle ) ) {

    case (DWORD)FILE_TYPE_DISK:

        if ((FileStream = NEW FILE_STREAM) != NULL ) {
            if ( !FileStream->Initialize( Handle, Access ) ) {
                DELETE( FileStream );
            }
            Stream = (PSTREAM)FileStream;
        }
        break;


    case (DWORD)FILE_TYPE_CHAR:

        //
        // There is no API to determine if a handle is a console handle.
        // Any console API will return ERROR_INVALID_HANDLE if the handle is
        // not a console handle.
        // The following code uses GetConsoleMode().
        //
        switch ( Access ) {

        case READ_ACCESS:

            {
                DWORD   Mode;
                if (!GetConsoleMode( Handle, &Mode )) {

                    if (GetLastError() != ERROR_INVALID_HANDLE)
                        break;

                    //
                    //  This is not a console, but some other character
                    //  device. Create a pipe stream for it.
                    //
                    if ((PipeStream = NEW PIPE_STREAM) != NULL ) {
                        if ( !PipeStream->Initialize( Handle, Access ) ) {
                            DELETE( PipeStream );
                        }
                        Stream = (PSTREAM)PipeStream;
                    }
                    break;
                }
            }
            if ((Keyboard = NEW KEYBOARD) != NULL ) {
                if ( !Keyboard->Initialize() ) {
                    DELETE( Keyboard );
                }
                Stream = (PSTREAM)Keyboard;
            }
            break;

        case WRITE_ACCESS:

            {
                DWORD   Mode;
                if (!GetConsoleMode( Handle, &Mode )) {

                    if (GetLastError() != ERROR_INVALID_HANDLE)
                        break;

                    //
                    //  This is not a console, but some other character
                    //  device. Create a file stream for it.
                    //
                    if ((FileStream = NEW FILE_STREAM) != NULL ) {
                        if ( !FileStream->Initialize( Handle, Access ) ) {
                            DELETE( FileStream );
                        }
                        Stream = (PSTREAM)FileStream;
                    }
                    break;
                }
            }

            if ((Screen = NEW SCREEN) != NULL ) {
                if ( !Screen->Initialize() ) {
                    DELETE( Screen );
                }
                Stream = (PSTREAM)Screen;
            }
            break;

        default:
            break;
        }

        break;

    case (DWORD)FILE_TYPE_PIPE:

        if ((PipeStream = NEW PIPE_STREAM) != NULL ) {
            if ( !PipeStream->Initialize( Handle, Access ) ) {
                DELETE( PipeStream );
            }
            Stream = (PSTREAM)PipeStream;
        }
        break;

    case (DWORD)FILE_TYPE_UNKNOWN:
        // Probably a windows app. Don't print anything to debug.
        break;

    default:
        DebugPrintTrace(("ERROR: FileType for standard stream %lx is invalid (%lx)\n", Handle, GetFileType(Handle)));
        break;

    }

    return Stream;

}

NONVIRTUAL
ULIB_EXPORT
HANDLE
FindFirstFile (
    IN  PCPATH              Path,
    OUT PWIN32_FIND_DATA     FileFindData
    )

/*++

Routine Description:

    Perform a FindFirst file given a PATH rather tha a PSTR.

Arguments:

    Path         - Supplies a pointer to the PATH to search.
    FileFindData - Supplies a pointer where the results of the find is
        returned.

Return Value:

    HANDLE - Returns the results of the call to the Win32 FindFirstFile API.

--*/

{
    PWSTR           p;

    //
    // If the supplied pointers are non-NULL and an OEM representation
    // (i.e. API ready) of the PATH is available, return the
    // HANDLE returned by the Win32 FindFirstFile API
    //

    DebugPtrAssert( Path );
    DebugPtrAssert( FileFindData );
    if (!Path || !FileFindData) {
        return INVALID_HANDLE_VALUE;
    }

    p = (PWSTR) Path->GetPathString()->GetWSTR();
    if (!p) {
        return INVALID_HANDLE_VALUE;
    }

    return FindFirstFile(p, FileFindData);
}

#endif // _AUTOCHECK_ || _SETUP_LOADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\i386\dosttr.c ===
#include <windows.h>

#define MaxCallStack		20

VOID
DoStackTrace( DWORD callstack[] )

/*++

Routine Description:

	Backtrace a stack recording all the return addresses in the supplied
	structure.	The mips version of this code does nothing.

Arguments:

	DWORD Callstack[]	- The array in which the addresses are stored.

Return Value:

	None.

--*/

{

#pragma message( "Including the stack trace!" )

	int i;
	DWORD bytes;
	HANDLE hProcess;
	DWORD dwEbp;

	hProcess = GetCurrentProcess();

	//
	// Get the current contents of the control registers...
	//
	_asm {
	
		mov dwEbp, ebp

	}

	//
	// Ignore the entry on the stack for this procedure...
	//
	if( !ReadProcessMemory( hProcess,
							(LPVOID)dwEbp,
							(LPVOID)&dwEbp,
							sizeof( DWORD ),
							NULL ) ) {
		return;
	}

	for( i = 0; ( i < MaxCallStack ) && dwEbp; i++ ) {

		if( !ReadProcessMemory( hProcess,
								(LPVOID)( (PDWORD)dwEbp + 1 ),
								(LPVOID)( &callstack[ i ] ),
								sizeof( DWORD ),
								NULL ) ) {
			break;
		}
		if( !ReadProcessMemory( hProcess,
								(LPVOID)dwEbp,
								(LPVOID)&dwEbp,
								sizeof( DWORD ),
								NULL ) ) {
		   break;
		}

	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\timeinfo.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    timeinfo.cxx

Abstract:

    This module contains the definitions of the member functions
    of TIMEINFO class.

Author:

    Jaime Sasson (jaimes) 13-Mar-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "wstring.hxx"
#include "timeinfo.hxx"

extern "C" {
    #include <stdio.h>
}


//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CONST USHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CONST USHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};



//
//  The tables below contain the number of days in each month of
//  a year (leap and normal year)
//

CONST USHORT LeapYearDaysInMonth[12] = {
                                   31, // January
                                   29, // February
                                   31, // March
                                   30, // April
                                   31, // May
                                   30, // June
                                   31, // July
                                   31, // August
                                   30, // September
                                   31, // October
                                   30, // November
                                   31  // December
                                   };

CONST USHORT NormalYearDaysInMonth[12] = {
                                   31, // January
                                   28, // February
                                   31, // March
                                   30, // April
                                   31, // May
                                   30, // June
                                   31, // July
                                   31, // August
                                   30, // September
                                   31, // October
                                   30, // November
                                   31  // December
                                   };




DEFINE_EXPORTED_CONSTRUCTOR ( TIMEINFO, OBJECT, ULIB_EXPORT );

VOID
TIMEINFO::Construct (
    )

/*++

Routine Description:

    Contructs a TIMEINFO.

Arguments:

    None.

Return Value:

    None.


--*/

{
    // unreferenced parameters
    (void)(this);
}




BOOLEAN
TIMEINFO::Initialize(
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the current date and time.

Arguments:

    None.

Return Value:

    BOOLEAN - Indicates if the data members were correctly initialized.


--*/


{
    SYSTEMTIME  st;

    GetSystemTime( &st );
    return( this->Initialize( &st ) );
}




ULIB_EXPORT
BOOLEAN
TIMEINFO::Initialize(
    IN PFILETIME    FileTime
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the date and time stored in the structured pointed by FileTime.

Arguments:

    FileTime - Pointer to a FILETIME structure that contains the
               date and time to be used in the initialization of the
               date members.

Return Value:

    BOOLEAN - Indicates if the data members were correctly initialized.


--*/


{
    _FileTime = *FileTime;
    return( FileTimeToSystemTime( &_FileTime, &_SystemTime ) != FALSE );
}


BOOLEAN
TIMEINFO::Initialize(
    IN PSYSTEMTIME  SystemTime
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the date and time stored in the structured pointed by SystemTime.

Arguments:

    SystemTime - Pointer to a SYSTEMTIME structure that contains the
                 date and time to be used in the initialization of the
                 data members.

Return Value:

    BOOLEAN - Indicates if the data members were correctly initialized.


--*/


{
    BOOLEAN Result;

    _SystemTime = *SystemTime;
    Result = (BOOLEAN)SystemTimeToFileTime( &_SystemTime, &_FileTime );
//
//  The call below is necessary in order to make sure that
//  SystemTime.wDayOfWeek is correctly initialized
//
    Result &= FileTimeToSystemTime( &_FileTime, &_SystemTime );
    return( Result );
}


ULIB_EXPORT
VOID
TIMEINFO::Initialize(
    IN PCTIMEINFO   TimeInfo
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the date and time stored in the class pointed by pTimeInfo.

Arguments:

    TimeInfo -  Pointer to a TIMEINFO class that contains the
                date and time to be used in the initialization of the
                data members in this class.

Return Value:

    None.


--*/


{
    _FileTime = TimeInfo->_FileTime;
    _SystemTime = TimeInfo->_SystemTime;
}



BOOLEAN
TIMEINFO::Initialize(
    IN USHORT   Year,
    IN USHORT   Month,
    IN USHORT   Day,
    IN USHORT   Hour,
    IN USHORT   Minute,
    IN USHORT   Second,
    IN USHORT   Milliseconds
    )

/*++

Routine Description:

    This function initializes the data members of TIMEINFO class with
    the date and time information received as parameter.

Arguments:

    Year - A number indicating the year
    Month - A number indicating the month
    Day - A number indicating the day
    Hour  - Number of hours
    Minute - Number of minutes
    Second - Number of seconds
    Milliseconds - Number of milliseconds

Return Value:

    BOOLEAN - Indicates if the data members were correctly initialized.


--*/


{
    SYSTEMTIME  st;
    st.wYear = Year;
    st.wMonth = Month;
    st.wDay = Day;
    st.wHour = Hour;
    st.wMinute = Minute;
    st.wSecond = Second;
    st.wMilliseconds = Milliseconds;

    return( this->Initialize( &st ) );
}


SHORT
TIMEINFO::CompareTimeInfo(
    IN PFILETIME    FileTime
    ) CONST


/*++

Routine Description:

    This function compares the date and time information stored in
    this class, with one pointed by FileTime.

Arguments:

    FileTime -  Pointer to a FILETIME structure that contains the
                date and time to be used in the comparison.

Return Value:

    -1: - Indicates that the time information in this class is less
          than the time information pointed by FileTime.

     0: - Indicates that the time information in this class is equal
          to the time information pointed by FileTime.

     1: - Indicates that the time information in this class is greater
          than the time information pointed by FileTime.


--*/

{
    FILETIME    ft1;

    ft1 = _FileTime;
    return( (SHORT)CompareFileTime( &ft1, FileTime ) ) ;
}



SHORT
TIMEINFO::CompareTimeInfo(
    IN PSYSTEMTIME  SystemTime
    ) CONST


/*++

Routine Description:

    This function compares the date and time information stored in
    this class, with the one pointed by SysteTime.

Arguments:

    SystemTime - Pointer to a FILETIME structure that contains the
                  date and time to be used in the comparison.

Return Value:

    -1: - Indicates that the time information in this class is less
          than the time information pointed by SystemTime.

     0: - Indicates that the time information in this class is equal
          to the time information pointed by SystemTime.

     1: - Indicates that the time information in this class is greater
          than the time information pointed by SystemTime.


--*/

{
    FILETIME    ft1;
    FILETIME    ft2;

    ft1 = _FileTime;
    SystemTimeToFileTime( SystemTime, &ft2 );
    return( (SHORT)CompareFileTime( &ft1, &ft2 ) );
}



USHORT
TIMEINFO::QueryDayOffset(
    ) CONST

/*++

Routine Description:

    This function determines the offset in year of the day stored in
    this class.

Arguments:

    None.

Return Value:

    USHORT - Offset in year of the current day.


--*/

{
    USHORT  Offset;

    if( IsLeapYear( (USHORT)_SystemTime.wYear ) ) {
        Offset = LeapYearDaysPrecedingMonth[ _SystemTime.wMonth ];
    }
    else {
        Offset = NormalYearDaysPrecedingMonth[ _SystemTime.wMonth ];
    }
    Offset += _SystemTime.wDay;
    return( Offset );
}



USHORT
TIMEINFO::QueryDaysInMonth(
    ) CONST

/*++

Routine Description:

    This function determines the number of days in the month of the
    date stored in this class.

Arguments:

    None.

Return Value:

    USHORT - Number of days in the month.


--*/

{
    USHORT  NumberOfDays;

    if( IsLeapYear( (USHORT)_SystemTime.wYear ) ) {
        NumberOfDays = LeapYearDaysInMonth[ _SystemTime.wMonth ];
    }
    else {
        NumberOfDays = NormalYearDaysInMonth[ _SystemTime.wMonth ];
    }
    return( NumberOfDays );
}



USHORT
TIMEINFO::QueryDaysInYear(
    ) CONST

/*++

Routine Description:

    This function determines the total number of days in the year
    stored in this class.

Arguments:

    None.

Return Value:

    USHORT - Number of days in the year.


--*/

{
    if( IsLeapYear( (USHORT)_SystemTime.wYear ) ) {
        return( LeapYearDaysPrecedingMonth[ 12 ] );
    }
    else {
        return( NormalYearDaysPrecedingMonth[ 12 ] );
    }
}



BOOLEAN
TIMEINFO::SetDate(
    USHORT  Year,
    USHORT  Month,
    USHORT  Day
    )

/*++

Routine Description:

    This function sets the date of the TIMEINFO object (the time
    remains unchanged).

Arguments:

    Year  - A number that indicates the year.
    Month - A number that indicates the month.
    Day   - A number that indicates the day.

Return Value:

    BOOLEAN - A boolean value indicating if the date was set correctly.


--*/

{
    SYSTEMTIME    TempSystemTime;

    TempSystemTime = _SystemTime;
    TempSystemTime.wYear = Year;
    TempSystemTime.wMonth = Month;
    TempSystemTime.wDay = Day;
    return( this->Initialize( &TempSystemTime ) );
}



BOOLEAN
TIMEINFO::SetDate(
    PCWSTRING    Date
    )

/*++

Routine Description:

    This function sets the date of a TIMEINFO object (the time remains
    unchanged).

Arguments:

    Date  - A string that contains the date.

Return Value:

    BOOLEAN - A boolean value indicating if the date was set correctly.

Notes:

    THE IMPLEMENTATION BELOW ASSUMES THAT THE DATE REPRESENTED IN THE
    STRING HAS THE FORM: m-d-y or m/d/y, where:

        m: represents the month (1 or 2 characters);
        d: represents the day (1 or 2 characters);
        y: represents the year (any number of characters)

    NTRAID#93231-2000/03/09 - DanielCh - SetDate/SetTime/SetDateAndTime needs
                                         to recognize international formats

--*/

{
    SYSTEMTIME  TempSystemTime;
    CHNUM       FirstDelimiter;
    CHNUM       SecondDelimiter;
    FSTRING     Delimiters;
    USHORT      Day;
    USHORT      Month;
    USHORT      Year;
    BOOLEAN     IsNumber;
    LONG        Number;


    //
    //  Check if the string is a valid one ( must contain two separators )
    //
    if( !Delimiters.Initialize( (PWSTR) L"/-" ) ) {
        return( FALSE );
    }
    if( ( FirstDelimiter = Date->Strcspn( &Delimiters ) ) == INVALID_CHNUM ) {
        return( FALSE );
    }
    if( ( SecondDelimiter = Date->Strcspn(   &Delimiters,
                                             FirstDelimiter + 1 ) ) == INVALID_CHNUM ) {
        return( FALSE );
    }
    if( Date->Strcspn( &Delimiters, SecondDelimiter + 1 ) != INVALID_CHNUM ) {
        return( FALSE );
    }
    //
    // At this point we know that the string has two delimiters and
    // three numeric fields.
    // We now have to extract the numbers that represent the date,
    // and validate these numbers.
    //

    if (!(IsNumber = Date->QueryNumber(&Number, 0, FirstDelimiter ))) {
        return FALSE;
    }
    Month = (USHORT)Number;

    if (!(IsNumber = Date->QueryNumber(&Number, FirstDelimiter+1, SecondDelimiter-FirstDelimiter-1))) {
        return FALSE;
    }
    Day = (USHORT)Number;

    if (!(IsNumber = Date->QueryNumber(&Number, SecondDelimiter+1))) {
        return FALSE;
    }
    Year = (USHORT)Number;

    if( ( Month == 0 ) || ( Month > 12 ) ) {
        return( FALSE );
    }
    //
    //  Years in the range 00 - 79 are transformed to 2000-2079
    //  Years in the range 80 - 99 are transformed to 1980-1999
    if( ( Year >= 80 ) && ( Year < 100 ) ) {
        Year += 1900;
    } else {
        if( Year <= 79 ) {
            Year += 2000;
        }

    }
    if( ( Day > 31 ) ||
        ( ( Day >= 30 ) && ( Month == 2 ) ) ||
        ( ( Day == 29 ) && ( Month == 2 ) && !IsLeapYear( Year ) ) ||
        ( ( Day == 31 ) && ( ( Month == 4 ) || ( Month == 6 ) ||
                             ( Month == 9 ) || ( Month == 11 ) ) ) ) {
        return( FALSE );
    }

    TempSystemTime = _SystemTime;
    TempSystemTime.wYear = ( USHORT )Year;
    TempSystemTime.wMonth = ( USHORT )Month;
    TempSystemTime.wDay = ( USHORT )Day;
    return( this->Initialize( &TempSystemTime ) );
}


BOOLEAN
TIMEINFO::SetDateAndTime (
    IN PCWSTRING DateAndTime
    )

/*++

Routine Description:

    This function sets the date or time of a TIMEINFO object.

Arguments:

    DateAndTime - A string that contains the date or time.

Return Value:

    BOOLEAN - A boolean value indicating if the date or time was set
    correctly.

Notes:

    THIS IMPLEMENTATION SETS ONLY THE DATE OR THE TIME, BUT NOT BOTH.
    IT RELIES ON HACKS UNTIL THE WINNLS SUPPORT IS AVAILABLE FOR
    TRANSFORMING STRINGS INTO DATES AND TIMES.

    NTRAID#93231-2000/03/09 - DanielCh - SetDate/SetTime/SetDateAndTime needs
                                         to recognize international formats

--*/

{
    if( DateAndTime->Strchr( (WCHAR)':' ) == INVALID_CHNUM ) {
        //
        //  We assume that we have a date
        //
        if( !SetDate( DateAndTime ) ) {
            return( FALSE );
        }
        //
        // Sets the time to the earliest time in the day
        //
        return( SetTime( 0, 0, 0, 0 ) );
    } else {
        //
        //  We assume that we have a time
        //
        return SetTime( DateAndTime );
    }
}


BOOLEAN
TIMEINFO::SetTime(
    USHORT  Hour,
    USHORT  Minute,
    USHORT  Second,
    USHORT  Milliseconds
    )

/*++

Routine Description:

    This function sets the time of of a TIMEINFO object (the date
    remains unchanged).

Arguments:

    Hour -         Number of hours.
    Minute -       Number of minutes.
    Second -       Number of seconds.
    Milliseconds - Number of milliseconds

Return Value:

    BOOLEAN - A boolean value indicating if the time was set correctly.


--*/

{
    SYSTEMTIME    TempSystemTime;

    TempSystemTime = _SystemTime;
    TempSystemTime.wHour = Hour;
    TempSystemTime.wMinute = Minute;
    TempSystemTime.wSecond = Second;
    TempSystemTime.wMilliseconds = Milliseconds;
    return( this->Initialize( &TempSystemTime ) );
}



BOOLEAN
TIMEINFO::SetTime(
    PCWSTRING    Time
    )

/*++

Routine Description:

    This function sets the time of a TIMEINFO object (the date remains
    unchanged).

Arguments:

    Date  - A string that contains the time. This string must have
            one of the following formats:

                h:m
                h:m:s

            Where:

                h: represents the hour (1 or 2 digits)
                m: represents the minutes (1 or 2 digits)
                s: represents the seconds (1 or 2 digits)


Return Value:

    BOOLEAN - A boolean value indicating if the time was set correctly.

Notes:

    NTRAID#93231-2000/03/09 - DanielCh - SetDate/SetTime/SetDateAndTime needs
                                         to recognize international formats

--*/

{
    CHNUM       FirstDelimiter;
    CHNUM       SecondDelimiter;
    USHORT      Hour;
    USHORT      Minute;
    USHORT      Second;
    BOOLEAN     IsNumber;
    LONG        Number;
    FSTRING     Delimiters;
    SYSTEMTIME  TempSystemTime;

    //
    //  Check if the string is a valid one
    //
    FirstDelimiter = INVALID_CHNUM;
    SecondDelimiter = INVALID_CHNUM;

    if( !Delimiters.Initialize( (LPWSTR) L":" ) ) {
        return( FALSE );
    }
    if( ( FirstDelimiter = Time->Strcspn( &Delimiters ) ) == INVALID_CHNUM ) {
        return( FALSE );
    }
    SecondDelimiter = Time->Strcspn( &Delimiters, FirstDelimiter + 1 );

    //
    // At this point we know that the string has one or two delimiters, and
    // two or three numeric fields.
    // We now have to extract the numbers that represent the time,
    // and validate these numbers.
    //

    if (!(IsNumber = Time->QueryNumber(&Number, 0, FirstDelimiter ))) {
        return FALSE;
    }
    Hour = (USHORT)Number;

    if( SecondDelimiter == INVALID_CHNUM ) {
        if (!(IsNumber = Time->QueryNumber(&Number, FirstDelimiter+1))) {
            return FALSE;
        }
        Minute = (USHORT)Number;
        Second = 0;
    } else {
        if (!(IsNumber = Time->QueryNumber(&Number, FirstDelimiter+1, SecondDelimiter-FirstDelimiter-1))) {
            return FALSE;
        }
        Minute = (USHORT)Number;

        if (!(IsNumber = Time->QueryNumber(&Number, SecondDelimiter+1))) {
            return FALSE;
        }
        Second = (USHORT)Number;
    }

    //
    //  Check if the time is valid
    //
    if( ( Hour >= 24 ) || ( Minute >= 60 ) || ( Second >= 60 ) ) {
        return( FALSE );
    }

    TempSystemTime = _SystemTime;
    TempSystemTime.wHour = ( USHORT )Hour;
    TempSystemTime.wMinute = ( USHORT )Minute;
    TempSystemTime.wSecond = ( USHORT )Second;
    TempSystemTime.wMilliseconds = 0;
    return( this->Initialize( &TempSystemTime ) );
}


ULIB_EXPORT
BOOLEAN
TIMEINFO::QueryTime(
    OUT PWSTRING    FormattedTimeString
    ) CONST
/*++

Routine Description:

    This routine computes the correct time string for this TIMEINFO.

Arguments:

    FormattedTimeString - Returns a formatted time string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WSTR buf[50];

    return( GetTimeFormatW( GetSystemDefaultLCID(),
                            TIME_NOSECONDS,
                            &_SystemTime,
                            NULL,
                            buf,
                            50 ) &&
            FormattedTimeString->Initialize(buf) );

}


NONVIRTUAL
ULIB_EXPORT
BOOLEAN
TIMEINFO::QueryDate(
    OUT PWSTRING    FormattedDateString
    ) CONST
/*++

Routine Description:

    This routine computes the correct date string for this TIMEINFO.

Arguments:

    FormattedTimeString - Returns a formatted date string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WSTR buf[50];

    return( GetDateFormatW( GetSystemDefaultLCID(),
                            DATE_SHORTDATE,
                            &_SystemTime,
                            NULL,
                            buf,
                            50 ) != 0 &&
             FormattedDateString->Initialize(buf) );
}


BOOLEAN
ULIB_EXPORT
TIMEINFO::ConvertToUTC (
    )
/*++

Routine Description:

    This function converts the filetime (presumably it was
    previously local) to UTC.  The system time is left unchanged.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/

{
    FILETIME temp;
    BOOL b;

    b = LocalFileTimeToFileTime( &_FileTime, &temp );

    if (!b) {
        return FALSE;
    }

    _FileTime = temp;
    return TRUE;
}

BOOLEAN
ULIB_EXPORT
TIMEINFO::ConvertToLocal (
    )
/*++

Routine Description:

    This function converts the filetime (presumably it was
    previously UTC) to local time.  The system time is left unchanged.

Arguments:

    None.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/

{
    FILETIME temp;
    BOOL b;

    b = FileTimeToLocalFileTime( &_FileTime, &temp );

    if (!b) {
        return FALSE;
    }

    _FileTime = temp;
    return TRUE;
}



BOOLEAN
TIMEINFO::operator== (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is equal to the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is equal to the information in the object received
              as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {
    case 0:
        return( TRUE );

    default:
        return( FALSE );
    }
}



BOOLEAN
TIMEINFO::operator!= (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is different than the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is different than the information in the object received
              as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case 0:
        return( FALSE );

    default:
        return( TRUE );
    }
}



ULIB_EXPORT
BOOLEAN
TIMEINFO::operator< (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is smaller than the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is smaller than the information in the object received
              as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case -1:
        return( TRUE );

    default:
        return( FALSE );
    }
}



ULIB_EXPORT
BOOLEAN
TIMEINFO::operator> (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is greter than the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is greater than the information in the object received
              as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case 1:
        return( TRUE );

    default:
        return( FALSE );
    }
}



BOOLEAN
TIMEINFO::operator<= (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is less or equal than the time information received as parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is less or equal than the information in the object
              received as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case -1:
    case  0:
        return( TRUE );

    default:
        return( FALSE );
    }
}



BOOLEAN
TIMEINFO::operator>= (
    IN TIMEINFO TimeInfo
    ) CONST

/*++

Routine Description:

    This function determines if the time information contained in this
    class is greater or equal than the time information received as
    parameter.

Arguments:

    TimeInfo - An object of type TIMEINFO that contains the time
               information to be compared.

Return Value:

    BOOLEAN - A boolean value indicating if the time information in this
              object is greater or equal than the information in the object
              received as parameter.


--*/


{
    FILETIME    ft;

    ft = _FileTime;
    switch( CompareFileTime( &ft, TimeInfo.GetFileTime() ) ) {

    case 0:
    case 1:
        return( TRUE );

    default:
        return( FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ulib\src\wstring.cxx ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    wstring.cxx

Author:

    Norbert P. Kusters (norbertk) 6-Aug-92

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "wstring.hxx"

#include <stdio.h>
#include <wchar.h>

BOOLEAN WSTRING::_UseAnsiConversions = FALSE;
BOOLEAN WSTRING::_UseConsoleConversions = FALSE;
#if defined FE_SB
BOOLEAN WSTRING::_UseAnsiConversionsPrev = FALSE;
BOOLEAN WSTRING::_UseConsoleConversionsPrev = FALSE;
#endif

// Helper functions for OEM/Unicode conversion.  Note that these
// are abstracted to private functions to make it easier to set
// them up for various environments.
//
#if defined( _AUTOCHECK_ )

INLINE
BOOLEAN
WSTRING::ConvertOemToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR OemString,
    ULONG BytesInOemString
    )
{
    return _UseAnsiConversions ?
           NT_SUCCESS(RtlMultiByteToUnicodeN( UnicodeString,
                                   MaxBytesInUnicodeString,
                                   BytesInUnicodeString,
                                   OemString,
                                   BytesInOemString )) :
           NT_SUCCESS(RtlOemToUnicodeN( UnicodeString,
                             MaxBytesInUnicodeString,
                             BytesInUnicodeString,
                             OemString,
                             BytesInOemString ));
}

INLINE
BOOLEAN
WSTRING::ConvertUnicodeToOemN(
    PCHAR OemString,
    ULONG MaxBytesInOemString,
    PULONG BytesInOemString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )
{
    return _UseAnsiConversions ?
           NT_SUCCESS(RtlUnicodeToMultiByteN( OemString,
                                   MaxBytesInOemString,
                                   BytesInOemString,
                                   UnicodeString,
                                   BytesInUnicodeString )) :
           NT_SUCCESS(RtlUnicodeToOemN( OemString,
                             MaxBytesInOemString,
                             BytesInOemString,
                             UnicodeString,
                             BytesInUnicodeString ));
}

#else // _AUTOCHECK_ not defined

INLINE
BOOLEAN
ConvertToUnicodeWithConsoleCP(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR OemString,
    ULONG BytesInOemString
    )
{
    int result;

    *BytesInUnicodeString =
        MultiByteToWideChar( GetConsoleCP(),
                             MB_PRECOMPOSED,
                             OemString,
                             BytesInOemString,
                             UnicodeString,
                             MaxBytesInUnicodeString/sizeof(WCHAR) ) *
        sizeof(WCHAR);

    return( *BytesInUnicodeString != 0 );
}

#if defined FE_SB // ConvertToOemWithConsoleCP()
INLINE
BOOLEAN
ConvertToOemWithConsoleCP(
    PCHAR OemString,
    ULONG MaxBytesInOemString,
    PULONG BytesInOemString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )
{
    int result;

    *BytesInOemString =
        WideCharToMultiByte( GetConsoleCP(),
                             0,
                             UnicodeString,
                             BytesInUnicodeString/sizeof(WCHAR),
                             OemString,
                             MaxBytesInOemString,
                             NULL,
                             NULL );

    return( *BytesInOemString != 0 );
}
#endif

INLINE
BOOLEAN
WSTRING::ConvertOemToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR OemString,
    ULONG BytesInOemString
    )
{
    return
       _UseConsoleConversions ?
           ConvertToUnicodeWithConsoleCP( UnicodeString,
                                          MaxBytesInUnicodeString,
                                          BytesInUnicodeString,
                                          OemString,
                                          BytesInOemString ) :
       _UseAnsiConversions ?
           NT_SUCCESS(RtlMultiByteToUnicodeN( UnicodeString,
                                   MaxBytesInUnicodeString,
                                   BytesInUnicodeString,
                                   OemString,
                                   BytesInOemString )) :
           NT_SUCCESS(RtlOemToUnicodeN( UnicodeString,
                             MaxBytesInUnicodeString,
                             BytesInUnicodeString,
                             OemString,
                             BytesInOemString ));
}

INLINE
BOOLEAN
WSTRING::ConvertUnicodeToOemN(
    PCHAR OemString,
    ULONG MaxBytesInOemString,
    PULONG BytesInOemString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )
{
#if defined FE_SB // WSTRING::ConvertUnicodeToOemN()
    return
       _UseConsoleConversions ?
           ConvertToOemWithConsoleCP( OemString,
                                   MaxBytesInOemString,
                                   BytesInOemString,
                                   UnicodeString,
                                   BytesInUnicodeString ) :
           _UseAnsiConversions ?
#else
    return _UseAnsiConversions ?
#endif
           NT_SUCCESS(RtlUnicodeToMultiByteN( OemString,
                                   MaxBytesInOemString,
                                   BytesInOemString,
                                   UnicodeString,
                                   BytesInUnicodeString )) :
           NT_SUCCESS(RtlUnicodeToOemN( OemString,
                             MaxBytesInOemString,
                             BytesInOemString,
                             UnicodeString,
                             BytesInUnicodeString ));
}


#endif  // not autochk

INLINE
VOID
WSTRING::Construct(
    )
{
    _s = NULL;
    _l = 0;
}


DEFINE_CONSTRUCTOR( WSTRING, OBJECT );


BOOLEAN
WSTRING::Initialize(
    IN  PCWSTRING   InitialString,
    IN  CHNUM       Position,
    IN  CHNUM       Length
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.
    Position        - Supplies the position in the given string to start at.
    Length          - Supplies the length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Position <= InitialString->_l);

    Length = min(Length, InitialString->_l - Position);

    if (!NewBuf(Length)) {
        return FALSE;
    }

    memcpy(_s, InitialString->_s + Position, (UINT) Length*sizeof(WCHAR));

    return TRUE;
}


BOOLEAN
WSTRING::Initialize(
    IN  PCWSTR  InitialString,
    IN  CHNUM   StringLength
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (StringLength == TO_END) {
        StringLength = wcslen(InitialString);
    }

    if (!NewBuf(StringLength)) {
        return FALSE;
    }

    memcpy(_s, InitialString, (UINT) StringLength*sizeof(WCHAR));

    return TRUE;
}


BOOLEAN
WSTRING::Initialize(
    IN  PCSTR   InitialString,
    IN  CHNUM   StringLength
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM       length;
    BOOLEAN     status;

    if (StringLength == TO_END) {
        StringLength = strlen(InitialString);
    }

    if (!StringLength) {
        return Resize(0);
    }


    // We want to avoid making two calls to RtlOemToUnicodeN so
    // try to guess an adequate size for the buffer.

    if (!NewBuf(StringLength)) {
        return FALSE;
    }

    status = ConvertOemToUnicodeN(_s, _l*sizeof(WCHAR),
                                  &length, (PSTR) InitialString,
                                  StringLength);
    length /= sizeof(WCHAR);

    if (status) {
        return Resize(length);
    }


    // We didn't manage to make in one try so ask exactly how much
    // we need and then make the call.

    status = ConvertOemToUnicodeN(NULL, 0, &length, (PSTR) InitialString,
                                  StringLength);
    length /= sizeof(WCHAR);

    if (!status || !NewBuf(length)) {
        return FALSE;
    }

    status = ConvertOemToUnicodeN(_s, _l*sizeof(WCHAR),
                                  &length, (PSTR) InitialString, StringLength);

    if (!status) {
        return FALSE;
    }

    DebugAssert(length == _l*sizeof(WCHAR));

    return TRUE;
}


BOOLEAN
WSTRING::Initialize(
    IN  LONG    Number
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    Number  - Supplies the number to initialize the string to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR    tmp[64];

    sprintf(tmp, "%d", Number);
    return Initialize(tmp);
}


NONVIRTUAL
PWSTRING
WSTRING::QueryString(
    IN  CHNUM   Position,
    IN  CHNUM   Length
    ) CONST
/*++

Routine Description:

    This routine returns a copy of this string from the specified
    coordinates.

Arguments:

    Position    - Supplies the initialize position of the string.
    Length      - Supplies the length of the string.

Return Value:

    A pointer to a string or NULL.

--*/
{
    PWSTRING    p;

    if (!(p = NEW DSTRING) ||
        !p->Initialize(this, Position, Length)) {

        DELETE(p);
    }

    return p;
}


BOOLEAN
WSTRING::QueryNumber(
    OUT PLONG   Number,
    IN  CHNUM   Position,
    IN  CHNUM   Length
    ) CONST
/*++

Routine Description:

    This routine queries a number from the string.

Arguments:

    Number      - Returns the number parsed out of the string.
    Position    - Supplies the position of the number.
    Length      - Supplies the length of the number.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FSTRING String;
    PSTR    p;
    CHNUM   spn;

    if (Position >= _l) {
        return FALSE;
    }

    Length = min(Length, _l - Position);

        //
    //  Note that 123+123 will be a number!
        //
    String.Initialize((PWSTR) L"1234567890+-");

    spn = Strspn(&String, Position);

    if ((spn == INVALID_CHNUM || spn >= Position + Length) &&
        (p = QuerySTR(Position, Length))) {

        *Number = atol(p);

        DELETE(p);
                return TRUE;
        }

        return FALSE;
}


VOID
WSTRING::DeleteChAt(
    IN  CHNUM   Position,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine removes the character at the given position.

Arguments:

    Position    - Supplies the position of the character to remove.
    Length      - Supplies the number of characters to remove.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    memmove(_s + Position, _s + Position + Length,
            (UINT) (_l - Position - Length)*sizeof(WCHAR));

    Resize(_l - Length);
}


NONVIRTUAL
BOOLEAN
WSTRING::InsertString(
    IN  CHNUM       AtPosition,
    IN  PCWSTRING   String,
    IN  CHNUM       FromPosition,
    IN  CHNUM       FromLength
    )
/*++

Routine Description:

    This routine inserts the given string at the given position in
    this string.

Arguments:

    AtPosition  - Supplies the position at which to insert the string.
    String      - Supplies the string to insert.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;

    DebugAssert(AtPosition <= _l);
    DebugAssert(FromPosition <= String->_l);

    FromLength = min(FromLength, String->_l - FromPosition);

    old_length = _l;
    if (!Resize(_l + FromLength)) {
        return FALSE;
    }

    memmove(_s + AtPosition + FromLength, _s + AtPosition,
            (UINT) (old_length - AtPosition)*sizeof(WCHAR));

    memcpy(_s + AtPosition, String->_s + FromPosition,
           (UINT) FromLength*sizeof(WCHAR));

    return TRUE;
}


NONVIRTUAL
BOOLEAN
WSTRING::Replace(
    IN CHNUM        AtPosition,
    IN CHNUM        AtLength,
    IN PCWSTRING    String,
    IN CHNUM        FromPosition,
    IN CHNUM        FromLength
    )
/*++

Routine Description:

    This routine replaces the contents of this string from
    'Position' to 'Length' with the contents of 'String2'
    from 'Position2' to 'Length2'.

Arguments:

    AtPosition      - Supplies the position to replace at.
    AtLength        - Supplies the length to replace at.
    String          - Supplies the string to replace with.
    FromPosition    - Supplies the position to replace from in String2.
    FromLength      - Supplies the position to replace from in String2.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;

    DebugAssert(AtPosition <= _l);
    DebugAssert(FromPosition <= String->_l);

    AtLength = min(AtLength, _l - AtPosition);
    FromLength = min(FromLength, String->_l - FromPosition);

    // Make sure up front that we have the room but don't disturb
    // the string.

    if (FromLength > AtLength) {
        old_length = _l;
        if (!Resize(_l + FromLength - AtLength)) {
            return FALSE;
        }
        Resize(old_length);
    }

    DeleteChAt(AtPosition, AtLength);
    if (!InsertString(AtPosition, String, FromPosition, FromLength)) {
        DebugAbort("This absolutely can never happen\n");
        return FALSE;
    }

    return TRUE;
}


NONVIRTUAL
BOOLEAN
WSTRING::ReplaceWithChars(
    IN CHNUM        AtPosition,
    IN CHNUM        AtLength,
    IN WCHAR        Character,
    IN CHNUM        FromLength
    )
/*++

Routine Description:

    This routine replaces the contents of this string from
    AtPosition of AtLength with the string formed by Character
    of FromLength.

Arguments:

    AtPosition      - Supplies the position to replace at.
    AtLength        - Supplies the length to replace at.
    Character       - Supplies the character to replace with.
    FromLength      - Supplies the total number of new characters to replace the old one with.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;
    PWCHAR  currptr, endptr;

    DebugAssert(AtPosition <= _l);

    AtLength = min(AtLength, _l - AtPosition);

    // Make sure up front that we have the room but don't disturb
    // the string.

    if (FromLength > AtLength) {
        old_length = _l;
        if (!Resize(_l + FromLength - AtLength)) {
            return FALSE;
        }
        Resize(old_length);
    }

    DeleteChAt(AtPosition, AtLength);
    old_length = _l;

    if (!Resize(_l + FromLength)) {
        DebugPrint("This should not fail\n");
        return FALSE;
    }

    memmove(_s + AtPosition + FromLength, _s + AtPosition,
            (UINT) (old_length - AtPosition)*sizeof(WCHAR));

    for (currptr = _s + AtPosition, endptr = currptr + FromLength;
         currptr < endptr;
         currptr++) {
        *currptr = Character;
    }

    return TRUE;
}


PWSTR
WSTRING::QueryWSTR(
    IN  CHNUM   Position,
    IN  CHNUM   Length,
    OUT PWSTR   Buffer,
    IN  CHNUM   BufferLength,
    IN  BOOLEAN ForceNull
    ) CONST
/*++

Routine Description:

    This routine makes a copy of this string into the provided
    buffer.  If this string is not provided then a buffer is
    allocated on the heap.

Arguments:

    Position        - Supplies the position within this string.
    Length          - Supplies the length of this string to take.
    Buffer          - Supplies the buffer to copy to.
    BufferLength    - Supplies the number of characters in the buffer.
    ForceNull       - Specifies whether or not to force the final character
                        of the buffer to be NULL in the case when there
                        isn't enough room for the whole string including
                        the NULL.

Return Value:

    A pointer to a NULL terminated string.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    if (!Buffer) {
        BufferLength = Length + 1;
        if (!(Buffer = (PWCHAR) MALLOC(BufferLength*sizeof(WCHAR)))) {
            return NULL;
        }
    }

    if (BufferLength > Length) {
        memcpy(Buffer, _s + Position, (UINT) Length*sizeof(WCHAR));
        Buffer[Length] = 0;
    } else {
        memcpy(Buffer, _s + Position, (UINT) BufferLength*sizeof(WCHAR));
        if (ForceNull) {
            Buffer[BufferLength - 1] = 0;
        }
    }

    return Buffer;
}


PSTR
WSTRING::QuerySTR(
    IN  CHNUM   Position,
    IN  CHNUM   Length,
    OUT PSTR    Buffer,
    IN  CHNUM   BufferLength,
    IN  BOOLEAN ForceNull
    ) CONST
/*++

Routine Description:

    This routine computes a multi-byte version of the current
    unicode string.  If the buffer is not supplied then it
    will be allocated by this routine.

Arguments:

    Position        - Supplies the position within this string.
    Length          - Supplies the length of this string to take.
    Buffer          - Supplies the buffer to convert into.
    BufferLength    - Supplies the number of characters in this buffer.
    ForceNull       - Specifies whether or not to force a NULL even
                        when the buffer is too small for the string.

Return Value:

    A pointer to a NULL terminated multi byte string.

--*/
{
    ULONG       ansi_length;

    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);


    // First special case the empty result.

    if (!Length) {

        if (!Buffer) {
            if (!(Buffer = (PSTR) MALLOC(1))) {
                return NULL;
            }
        } else if (!BufferLength) {
            return NULL;
        }

        Buffer[0] = 0;
        return Buffer;
    }


    // Next case is that the buffer is not provided and thus
    // we have to figure out what size it should be.

    if (!Buffer) {

        // We want to avoid too many calls to RtlUnicodeToOemN
        // so we'll estimate a correct size for the buffer and
        // hope that that works.

        BufferLength = 2*Length + 1;
        if (!(Buffer = (PSTR) MALLOC(BufferLength))) {
            return NULL;
        }

        if (ConvertUnicodeToOemN(Buffer, BufferLength - 1,
                                 &ansi_length, _s + Position,
                                 Length*sizeof(WCHAR))) {
            Buffer[ansi_length] = 0;
            return Buffer;
        }


        // We failed to estimate the necessary size of the buffer.
        // So ask the correct size and try again.

        FREE(Buffer);

        if (!ConvertUnicodeToOemN(NULL, 0, &ansi_length,
                                  _s + Position, Length*sizeof(WCHAR))) {
            return NULL;
        }

        BufferLength = ansi_length + 1;
        if (!(Buffer = (PSTR) MALLOC(BufferLength))) {
            return NULL;
        }
    }

    if (!ConvertUnicodeToOemN(Buffer, BufferLength, &ansi_length,
                              _s + Position, Length*sizeof(WCHAR))) {
        return NULL;
    }

    if (BufferLength > ansi_length) {
        Buffer[ansi_length] = 0;
    } else {
        if (ForceNull) {
            Buffer[BufferLength - 1] = 0;
        }
    }

    return Buffer;
}


BOOLEAN
WSTRING::Strcat(
    IN  PCWSTRING   String
    )
/*++

Routine Description:

    This routine concatenates the given string onto this one.

Arguments:

    String  - Supplies the string to concatenate to this one.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;

    old_length = _l;
    if (!Resize(_l + String->_l)) {
        return FALSE;
    }

    memcpy(_s + old_length, String->_s, (UINT) String->_l*sizeof(WCHAR));

    return TRUE;
}


NONVIRTUAL
PWSTRING
WSTRING::Strupr(
    IN  CHNUM   StartPosition,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine upcases a portion of this string.

Arguments:

    StartPosition   - Supplies the start position of the substring to upcase.
    Length          - Supplies the length of the substring to upscase.

Return Value:

    A pointer to this string.

--*/
{
    WCHAR   c;

    DebugAssert(StartPosition <= _l);

    Length = min(Length, _l - StartPosition);

    c = _s[StartPosition + Length];
    _s[StartPosition + Length] = 0;

    _wcsupr(_s + StartPosition);

    _s[StartPosition + Length] = c;

    return this;
}


NONVIRTUAL
PWSTRING
WSTRING::Strlwr(
    IN  CHNUM   StartPosition,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine lowercases a portion of this string.

Arguments:

    StartPosition   - Supplies the start position of the substring to lowercase.
    Length          - Supplies the length of the substring to lowercase.

Return Value:

    A pointer to this string.

--*/
{
    WCHAR   c;

    DebugAssert(StartPosition <= _l);

    Length = min(Length, _l - StartPosition);

    c = _s[StartPosition + Length];
    _s[StartPosition + Length] = 0;

    _wcslwr(_s + StartPosition);

    _s[StartPosition + Length] = c;

    return this;
}


NONVIRTUAL
LONG
WSTRING::Strcmp(
    IN  PCWSTRING   String,
    IN  CHNUM       LeftPosition,
    IN  CHNUM       LeftLength,
    IN  CHNUM       RightPosition,
    IN  CHNUM       RightLength
    ) CONST
/*++

Routine Description:

    This routine compares two substrings.

Arguments:

    String          - Supplies the string to compare this one to.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.

Return Value:

    <0  - Left substring is less than right substring.
    0   - Left and Right substrings are equal
    >0  - Left substring is greater than right substring.

--*/
{
    WCHAR   c, d;
    LONG    r;

    DebugAssert(LeftPosition <= _l);
    DebugAssert(RightPosition <= String->_l);

    LeftLength = min(LeftLength, _l - LeftPosition);
    RightLength = min(RightLength, String->_l - RightPosition);

    c = _s[LeftPosition + LeftLength];
    d = String->_s[RightPosition + RightLength];
    _s[LeftPosition + LeftLength] = 0;
    String->_s[RightPosition + RightLength] = 0;

    r = wcscmp(_s + LeftPosition, String->_s + RightPosition);

    _s[LeftPosition + LeftLength] = c;
    String->_s[RightPosition + RightLength] = d;

    return r;
}


NONVIRTUAL
LONG
WSTRING::Stricmp(
    IN  PCWSTRING   String,
    IN  CHNUM       LeftPosition,
    IN  CHNUM       LeftLength,
    IN  CHNUM       RightPosition,
    IN  CHNUM       RightLength
    ) CONST
/*++

Routine Description:

    This routine compares two substrings insensitive of case.

Arguments:

    String          - Supplies the string to compare this one to.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.

Return Value:

    <0  - Left substring is less than right substring.
    0   - Left and Right substrings are equal
    >0  - Left substring is greater than right substring.

--*/
{
    WCHAR   c, d;
    LONG    r;

    DebugAssert(LeftPosition <= _l);
    DebugAssert(RightPosition <= String->_l);

    LeftLength = min(LeftLength, _l - LeftPosition);
    RightLength = min(RightLength, String->_l - RightPosition);

    c = _s[LeftPosition + LeftLength];
    d = String->_s[RightPosition + RightLength];
    _s[LeftPosition + LeftLength] = 0;
    String->_s[RightPosition + RightLength] = 0;

#if !defined _AUTOCHECK_

    // This works around a bug in the libc version of wcsicoll, where
    // it doesn't specify STRINGSORT to CompareString().  To reproduce the
    // bug, try sorting 1 and -1.  (-1 should sort before 1.) -mjb.
    //

    r = CompareString(GetUserDefaultLCID(),
                      NORM_IGNORECASE | SORT_STRINGSORT,
                      _s + LeftPosition,
                      -1,
                      String->_s + RightPosition,
                      -1
                      );


    if (r >= 1) {

        //
        // return codes 1, 2, and 3 map to -1, 0, and 1.
        //

        _s[LeftPosition + LeftLength] = c;
        String->_s[RightPosition + RightLength] = d;
        return r - 2;
    }

    // If 'r' is 0, this indicates failure and we'll fall through and
    // call wcsicoll.
    //

#endif // _AUTOCHECK_

    r = _wcsicmp(_s + LeftPosition, String->_s + RightPosition);

    _s[LeftPosition + LeftLength] = c;
    String->_s[RightPosition + RightLength] = d;

    return r;
}


PWSTR
WSTRING::SkipWhite(
    IN  PWSTR    p
    )
{
#ifdef FE_SB

  while (*p) {

    if (iswspace(*p))
      p++;
    else if ( *p == 0x3000 )
    {
      *p++ = TEXT(' ');
    }
    else
      break;
  }

#else
    while (iswspace(*p)) {
        p++;
    }
#endif

  return p;

}


/**************************************************************************/
/* Compare two strings, ignoring white space, case is significant, return */
/* 0 if identical, <>0 otherwise.  Leading and trailing white space is    */
/* ignored, internal white space is treated as single characters.         */
/**************************************************************************/
INT
WSTRING::Strcmps (
    IN  PWSTR    p1,
    IN  PWSTR    p2
    )
{
  WCHAR *q;

  p1 = WSTRING::SkipWhite(p1);                /* skip any leading white space */
  p2 = WSTRING::SkipWhite(p2);

  while (TRUE)
  {
    if (*p1 == *p2)
    {
      if (*p1++ == 0)             /* quit if at the end */
        return (0);
      else
        p2++;

#ifdef FE_SB
      if (CheckSpace(p1))
#else
      if (iswspace(*p1))           /* compress multiple spaces */
#endif
      {
        q = WSTRING::SkipWhite(p1);
        p1 = (*q == 0) ? q : q - 1;
      }

#ifdef FE_SB
      if (CheckSpace(p2))
#else
      if (iswspace(*p2))
#endif
      {
        q = WSTRING::SkipWhite(p2);
        p2 = (*q == 0) ? q : q - 1;
      }
    }
    else
      return *p1-*p2;
  }
}





/**************************************************************************/
/* Compare two strings, ignoring white space, case is not significant,    */
/* return 0 if identical, <>0 otherwise.  Leading and trailing white      */
/* space is ignored, internal white space is treated as single characters.*/
/**************************************************************************/
INT
WSTRING::Strcmpis (
    IN  PWSTR    p1,
    IN  PWSTR    p2
    )
{
  WCHAR *q;
#ifdef FE_SB
  WCHAR c1,c2;
#endif

  p1 = WSTRING::SkipWhite(p1);                  /* skip any leading white space */
  p2 = WSTRING::SkipWhite(p2);

  while (TRUE)
  {
      if (towupper(*p1) == towupper(*p2))
      {
        if (*p1++ == 0)                /* quit if at the end */
          return (0);
        else
          p2++;
#ifdef FE_SB
        if (CheckSpace(p1))
#else
        if (iswspace(*p1))              /* compress multiple spaces */
#endif
        {
          q = SkipWhite(p1);
          p1 = (*q == 0) ? q : q - 1;
        }
#ifdef FE_SB
        if (CheckSpace(p2))
#else
        if (iswspace(*p2))
#endif
        {
          q = WSTRING::SkipWhite(p2);
          p2 = (*q == 0) ? q : q - 1;
        }
      }
      else
        return *p1-*p2;
  }
}

#ifdef FE_SB

/**************************************************************************/
/* Routine:  CheckSpace                                                   */
/* Arguments: an arbitrary string                                         */
/* Function: Determine whether there is a space in the string.            */
/* Side effects: none                                                     */
/**************************************************************************/
INT
WSTRING::CheckSpace(
    IN  PWSTR    s
    )
{
  if (iswspace(*s) || *s == 0x3000 )
    return (TRUE);
  else
    return (FALSE);
}

#endif


#define     DUMMY_ULIB_EXPORT

DEFINE_EXPORTED_CONSTRUCTOR( FSTRING, WSTRING, DUMMY_ULIB_EXPORT );


BOOLEAN
FSTRING::Resize(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine implements the WSTRING Resize routine by using
    the buffer supplied at initialization time.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return NewBuf(NewStringLength);
}


BOOLEAN
FSTRING::NewBuf(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine implements the WSTRING NewBuf routine by using
    the buffer supplied at initialization time.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (NewStringLength >= _buffer_length) {
        return FALSE;
    }

    PutString((PWSTR) GetWSTR(), NewStringLength);

    return TRUE;
}


INLINE
VOID
DSTRING::Construct(
    )
/*++

Routine Description:

    This routine initializes the string to a valid initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _length = 0;
}


DEFINE_EXPORTED_CONSTRUCTOR( DSTRING, WSTRING, DUMMY_ULIB_EXPORT );


DSTRING::~DSTRING(
    )
/*++

Routine Description:

    Destructor for DSTRING.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_buf);
}


BOOLEAN
DSTRING::Resize(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PWSTR   new_buf;

    if (NewStringLength >= _length) {

        if (_buf) {
            if (!(new_buf = (PWSTR)
                  REALLOC(_buf, (NewStringLength + 1)*sizeof(WCHAR)))) {

                return FALSE;
            }
        } else {
            if (!(new_buf = (PWSTR)
                  MALLOC((NewStringLength + 1)*sizeof(WCHAR)))) {

                return FALSE;
            }
        }

        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}


BOOLEAN
DSTRING::NewBuf(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PWSTR   new_buf;

    if (NewStringLength >= _length) {

        if (!(new_buf = (PWSTR)
              MALLOC((NewStringLength + 1)*sizeof(WCHAR)))) {

            return FALSE;
        }

        if (_buf) {
            FREE(_buf);
        }
        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}

#if defined FE_SB
VOID
WSTRING::ResetConversions(
    )
{
    _UseAnsiConversions = _UseAnsiConversionsPrev;
    _UseConsoleConversions = _UseConsoleConversionsPrev;
}
#endif

VOID
WSTRING::SetAnsiConversions(
    )
/*++

Routine Description:

    This routine declares that all conversions from multi byte
    to unicode will take place using the ANSI code page.  Note
    that this is a STATIC method.  Therefore this switch affects
    *all* WSTRINGs.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined FE_SB
    _UseAnsiConversionsPrev = _UseAnsiConversions;
    _UseConsoleConversionsPrev = _UseConsoleConversions;
#endif

    _UseAnsiConversions = TRUE;
    _UseConsoleConversions = FALSE;
}


VOID
WSTRING::SetOemConversions(
    )
/*++

Routine Description:

    This routine declares that all conversions from multi byte
    to unicode will take place using the OEM code page.  Note
    that this is a STATIC method.  Therefore this switch affects
    *all* WSTRINGs.

    This is the default if neither this nor the above function is
    called.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined FE_SB
    _UseAnsiConversionsPrev = _UseAnsiConversions;
    _UseConsoleConversionsPrev = _UseConsoleConversions;
#endif

    _UseAnsiConversions = FALSE;
    _UseConsoleConversions = FALSE;
}

VOID
WSTRING::SetConsoleConversions(
    )
/*++

Routine Description:

    This routine declares that all conversions from multi byte
    to unicode will take place using the current console code page.
    Note that this is a STATIC method.  Therefore this switch
    affects *all* WSTRINGs.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined FE_SB
    _UseAnsiConversionsPrev = _UseAnsiConversions;
    _UseConsoleConversionsPrev = _UseConsoleConversions;
#endif
    _UseAnsiConversions = FALSE;
    _UseConsoleConversions = TRUE;
}

#if defined FE_SB
CHNUM
WSTRING::QueryByteCount(
        ) CONST
/*++

Routine Description:

    This routine returns the number of ANSI bytes the UNICODE string
    consists of.

Arguments:

    None.

Return Value:

    Number of ANSI bytes the UNICODE string is made from, or INVALID_CHNUM
    on error.

--*/

{
    ULONG   ansi_length;
    ULONG   BufferLen = _l * sizeof(WCHAR) + 1;
    PSTR    Buffer;
    BOOLEAN success;

    if ( !_l ) {
        return( (CHNUM)0 );
    }

    if (NULL == (Buffer = (PSTR)MALLOC( BufferLen ))) {
        return( INVALID_CHNUM );
    }

    success = ConvertUnicodeToOemN( Buffer, BufferLen - 1, &ansi_length,
        _s, BufferLen - 1 );

    FREE( Buffer );

    if (!success) {
        return INVALID_CHNUM;
    }
    return ansi_length;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\inc\fsrtlp.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    fsrtlp.h

Abstract:

    This header file is included by largemcb.h, and is used to stub out the
    kernel-only subroutine calls, as well as declare types and functions
    provided by the MCB package.

Author:

    Matthew Bradburn (mattbr) 19-August-95

Environment:

    ULIB, User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define NTKERNELAPI

typedef ULONG ERESOURCE, *PERESOURCE;
typedef ULONG FAST_MUTEX, *PFAST_MUTEX;
typedef ULONG KEVENT, *PKEVENT;
typedef ULONG KMUTEX, *PKMUTEX;

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType
} POOL_TYPE;

typedef ULONG VBN, *PVBN;
typedef ULONG LBN, *PLBN;
typedef LONGLONG LBN64, *PLBN64;

#define PAGED_CODE()                    /* nothing */
#define DebugTrace(a, b, c, d)          /* nothing */
#define ExInitializeFastMutex(a)        /* nothing */
#define ExAcquireFastMutex(a)           /* nothing */
#define ExReleaseFastMutex(a)           /* nothing */
#define ExAcquireSpinLock(a, b)         /* nothing */
#define ExReleaseSpinLock(a, b)         /* nothing */

#define ExIsFullZone(a)                    FALSE
#define ExAllocateFromZone(a)              ((PVOID)1)
#define ExIsObjectInFirstZoneSegment(a, b) TRUE
#define ExFreeToZone(a, p)                 /* nothing */

#define try_return(S)       { S; goto try_exit; }

extern
PVOID
MemAlloc(
    IN  ULONG   Size
    );

extern
PVOID
MemAllocOrRaise(
    IN  ULONG   Size
    );

extern
VOID
MemFree(
    IN  PVOID   Addr
    );

#define ExAllocatePool(type, size)      MemAlloc(size)
#define FsRtlAllocatePool(type, size)   MemAllocOrRaise(size)
#define ExFreePool(p)                   MemFree(p)

//
//  Large Integer Mapped Control Blocks routines, implemented in LargeMcb.c
//
//  An LARGE_MCB is an opaque structure but we need to declare the size of
//  it here so that users can allocate space for one.  Consequently the
//  size computation here must be updated by hand if the MCB changes.
//
//  Current the structure consists of the following.
//      PVOID
//      ULONG
//      ULONG
//      POOL_TYPE (enumerated type)
//      PVOID
//
//  We will round the structure up to a quad-word boundary.
//

typedef struct _LARGE_MCB {
#ifdef _WIN64
    ULONG Opaque[ 8 ];
#else
    ULONG Opaque[ 6 ];
#endif
} LARGE_MCB;
typedef LARGE_MCB *PLARGE_MCB;

NTKERNELAPI
VOID
FsRtlInitializeLargeMcb (
    IN PLARGE_MCB Mcb,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
VOID
FsRtlUninitializeLargeMcb (
    IN PLARGE_MCB Mcb
    );

NTKERNELAPI
VOID
FsRtlTruncateLargeMcb (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn
    );

NTKERNELAPI
BOOLEAN
FsRtlAddLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    IN LONGLONG Lbn,
    IN LONGLONG SectorCount
    );

NTKERNELAPI
VOID
FsRtlRemoveLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    IN LONGLONG SectorCount
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    OUT PLONGLONG Lbn OPTIONAL,
    OUT PLONGLONG SectorCountFromLbn OPTIONAL,
    OUT PLONGLONG StartingLbn OPTIONAL,
    OUT PLONGLONG SectorCountFromStartingLbn OPTIONAL,
    OUT PULONG Index OPTIONAL
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLastLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    OUT PLONGLONG Vbn,
    OUT PLONGLONG Lbn
    );

NTKERNELAPI
ULONG
FsRtlNumberOfRunsInLargeMcb (
    IN PLARGE_MCB Mcb
    );

NTKERNELAPI
BOOLEAN
FsRtlGetNextLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN ULONG RunIndex,
    OUT PLONGLONG Vbn,
    OUT PLONGLONG Lbn,
    OUT PLONGLONG SectorCount
    );

NTKERNELAPI
BOOLEAN
FsRtlSplitLargeMcb (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    IN LONGLONG Amount
    );


//
//  Mapped Control Blocks routines, implemented in Mcb.c
//
//  An MCB is an opaque structure but we need to declare the size of
//  it here so that users can allocate space for one.  Consequently the
//  size computation here must be updated by hand if the MCB changes.
//

typedef struct _MCB {
    ULONG Opaque[ 4 + (sizeof(PKMUTEX)+3)/4 ];
} MCB;
typedef MCB *PMCB;

NTKERNELAPI
VOID
FsRtlInitializeMcb (
    IN PMCB Mcb,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
VOID
FsRtlUninitializeMcb (
    IN PMCB Mcb
    );

NTKERNELAPI
VOID
FsRtlTruncateMcb (
    IN PMCB Mcb,
    IN VBN Vbn
    );

NTKERNELAPI
BOOLEAN
FsRtlAddMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    IN LBN Lbn,
    IN ULONG SectorCount
    );

NTKERNELAPI
VOID
FsRtlRemoveMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    IN ULONG SectorCount
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLastMcbEntry (
    IN PMCB Mcb,
    OUT PVBN Vbn,
    OUT PLBN Lbn
    );

NTKERNELAPI
ULONG
FsRtlNumberOfRunsInMcb (
    IN PMCB Mcb
    );

NTKERNELAPI
BOOLEAN
FsRtlGetNextMcbEntry (
    IN PMCB Mcb,
    IN ULONG RunIndex,
    OUT PVBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\attrcol.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        attrcol.cxx

Abstract:

        This module contains the implementation for the
        NTFS_ATTRIBUTE_COLUMNS class, which models
        the attribute columns of an attribute definition table
        file for an NTFS volume.

Author:

        Norbert P. Kusters (norbertk) 19-Aug-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "untfs.hxx"
#include "attrcol.hxx"

#include "attrib.hxx"


DEFINE_CONSTRUCTOR( NTFS_ATTRIBUTE_COLUMNS, OBJECT );

NTFS_ATTRIBUTE_COLUMNS::~NTFS_ATTRIBUTE_COLUMNS(
    )
/*++

Routine Description:

    Destructor for NTFS_ATTRIBUTE_COLUMNS.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
NTFS_ATTRIBUTE_COLUMNS::Construct(
    )
/*++

Routine Description:

    This routine initializes the class to an initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _columns = NULL;
    _num_columns = 0;
}


VOID
NTFS_ATTRIBUTE_COLUMNS::Destroy(
    )
/*++

Routine Description:

    This routine returns the class to an initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_columns);
    _num_columns = 0;
}


BOOLEAN
NTFS_ATTRIBUTE_COLUMNS::Initialize(
    IN  ULONG                           NumberOfColumns,
    IN  PCATTRIBUTE_DEFINITION_COLUMNS  Columns
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    NumberOfColumns - Supplies the number of columns.
    Columns         - Supplies 'NumberOfColumns' columns to
                        initialize to.  This parameter is optional.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _num_columns = NumberOfColumns;

    // NOTE: use old new for vectors.
    if (!(_columns = NEW ATTRIBUTE_DEFINITION_COLUMNS[_num_columns])) {
        Destroy();
        return FALSE;
    }

    if (Columns) {
        memcpy(_columns, Columns,
               (UINT) (NumberOfColumns*sizeof(ATTRIBUTE_DEFINITION_COLUMNS)));
    }

    return TRUE;
}


NONVIRTUAL
BOOLEAN
NTFS_ATTRIBUTE_COLUMNS::Read(
    IN OUT  PNTFS_ATTRIBUTE AttributeDefinitionTableData
    )
/*++

Routine Description:

    This routine reads in the attribute definition columns from disk.

Arguments:

    AttributeDefinitionTableData    - Supplies the data attribute of the
                                        attribute definition table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   bytes_to_read;
    ULONG   bytes_read;

    bytes_to_read = _num_columns*sizeof(ATTRIBUTE_DEFINITION_COLUMNS);

    return AttributeDefinitionTableData->Read(_columns,
                                              0,
                                              bytes_to_read,
                                              &bytes_read) &&
           (bytes_read == bytes_to_read);
}


BOOLEAN
NTFS_ATTRIBUTE_COLUMNS::QueryIndex(
    IN  ATTRIBUTE_TYPE_CODE AttributeCode,
    OUT PULONG              Index
    ) CONST
/*++

Routine Description:

    This routine computes the location of the column for
    'AttributeCode' and sets the internal pointer to that
    column.  This makes it so that subsequent 'Query' operations
    are for the attribute type of 'AttributeCode'.

Arguments:

    AttributeCode   - Supplies the attribute type code to search for.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;

    DebugAssert(Index);

    for (i = 0; i < _num_columns; i++) {
        if (_columns[i].AttributeTypeCode == AttributeCode) {
            *Index = i;
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\attrdef.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    attrdef.cxx

Abstract:

    This module contains the member function implementation for
    the NTFS_ATTRIBUTE_DEFINITION_TABLE class, which models
    the attribute definition table file for an NTFS volume.

Author:

    Bill McJohn (billmc) 17-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "attrib.hxx"
#include "ntfsbit.hxx"
#include "attrdef.hxx"
#include "ifssys.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "attrcol.hxx"

// This is the initial table for NT 4.0:

CONST ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions_1[$EA_DATA+1] =

{
    {{'$','S','T','A','N','D','A','R','D','_','I','N','F','O','R','M','A','T','I','O','N'},
    $STANDARD_INFORMATION,                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(STANDARD_INFORMATION), 0},                  // Minimum length
    {sizeof(STANDARD_INFORMATION), 0}},                 // Maximum length

    {{'$','A','T','T','R','I','B','U','T','E','_','L','I','S','T'},
    $ATTRIBUTE_LIST,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','F','I','L','E','_','N','A','M','E'},
    $FILE_NAME,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT | ATTRIBUTE_DEF_INDEXABLE,   // Flags
    {sizeof(FILE_NAME), 0},                             // Minimum length
    {sizeof(FILE_NAME) + (255 * sizeof(WCHAR)), 0}},    // Maximum length

    {{'$','V','O','L','U','M','E','_','V','E','R','S','I','O','N'},
    $VOLUME_VERSION,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(VOLUME_VERSION), 0},                        // Minimum length
    {sizeof(VOLUME_VERSION), 0}},                       // Maximum length

    {{'$','S','E','C','U','R','I','T','Y','_','D','E','S','C','R','I','P','T','O','R'},
    $SECURITY_DESCRIPTOR,                               // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','V','O','L','U','M','E','_','N','A','M','E'},
    $VOLUME_NAME,                                       // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {2,0},                                              // Minimum length
    {256,0}},                                           // Maximum length

    {{'$','V','O','L','U','M','E','_','I','N','F','O','R','M','A','T','I','O','N'},
    $VOLUME_INFORMATION,                                // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(VOLUME_INFORMATION),0},                     // Minimum length
    {sizeof(VOLUME_INFORMATION),0}},                    // Maximum length

    {{'$','D','A','T','A'},
    $DATA,                                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','I','N','D','E','X','_','R','O','O','T'},
    $INDEX_ROOT,                                        // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','I','N','D','E','X','_','A','L','L','O','C','A','T','I','O','N'},
    $INDEX_ALLOCATION,                                  // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','B','I','T','M','A','P'},
    $BITMAP,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','S','Y','M','B','O','L','I','C','_','L','I','N','K'},
    $SYMBOLIC_LINK,                                     // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','E','A','_','I','N','F','O','R','M','A','T','I','O','N'},
    $EA_INFORMATION,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(EA_INFORMATION), 0},                        // Minimum length
    {sizeof(EA_INFORMATION), 0}},                       // Maximum length

    {{'$','E','A',},
    $EA_DATA,                                           // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {0x10000,0}},                                       // Maximum length

    {{0, 0, 0, 0},
    $UNUSED,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {0,0}}                                              // Maximum length
};

// This is the initial table for NT 5.0 (W2K):

CONST ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions_2[] =

{
    {{'$','S','T','A','N','D','A','R','D','_','I','N','F','O','R','M','A','T','I','O','N'},
    $STANDARD_INFORMATION,                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(STANDARD_INFORMATION), 0},                  // Minimum length
    {sizeof(STANDARD_INFORMATION2), 0}},                // Maximum length

    {{'$','A','T','T','R','I','B','U','T','E','_','L','I','S','T'},
    $ATTRIBUTE_LIST,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','F','I','L','E','_','N','A','M','E'},
    $FILE_NAME,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT | ATTRIBUTE_DEF_INDEXABLE,   // Flags
    {sizeof(FILE_NAME), 0},                             // Minimum length
    {sizeof(FILE_NAME) + (255 * sizeof(WCHAR)), 0}},    // Maximum length

    {{'$','O','B','J','E','C','T','_','I','D'},
    $OBJECT_ID,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {0, 0},                                             // Minimum length
    {256, 0}},                                          // Maximum length

    {{'$','S','E','C','U','R','I','T','Y','_','D','E','S','C','R','I','P','T','O','R'},
    $SECURITY_DESCRIPTOR,                               // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','V','O','L','U','M','E','_','N','A','M','E'},
    $VOLUME_NAME,                                       // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {2,0},                                              // Minimum length
    {256,0}},                                           // Maximum length

    {{'$','V','O','L','U','M','E','_','I','N','F','O','R','M','A','T','I','O','N'},
    $VOLUME_INFORMATION,                                // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(VOLUME_INFORMATION),0},                     // Minimum length
    {sizeof(VOLUME_INFORMATION),0}},                    // Maximum length

    {{'$','D','A','T','A'},
    $DATA,                                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','I','N','D','E','X','_','R','O','O','T'},
    $INDEX_ROOT,                                        // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','I','N','D','E','X','_','A','L','L','O','C','A','T','I','O','N'},
    $INDEX_ALLOCATION,                                  // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','B','I','T','M','A','P'},
    $BITMAP,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {MAXULONG,MAXULONG}},                               // Maximum length

    {{'$','R','E','P','A','R','S','E','_','P','O','I','N','T'},
    $REPARSE_POINT,                                     // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {16*1024,0}},                                       // Maximum length

    {{'$','E','A','_','I','N','F','O','R','M','A','T','I','O','N'},
    $EA_INFORMATION,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    {sizeof(EA_INFORMATION), 0},                        // Minimum length
    {sizeof(EA_INFORMATION), 0}},                       // Maximum length

    {{'$','E','A'},
    $EA_DATA,                                           // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {0x10000,0}},                                       // Maximum length

    {{'$','L','O','G','G','E','D','_','U','T','I','L','I','T','Y','_','S','T','R','E','A','M'},
    $LOGGED_UTILITY_STREAM,                             // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    {0,0},                                              // Minimum length
    {0x10000,0}},                                       // Maximum length

    {{0, 0, 0, 0},
    $UNUSED,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    {0,0},                                              // Minimum length
    {0,0}}                                              // Maximum length
};

CONST NumberOfNtfsAttributeDefinitions_1 = sizeof(NtfsAttributeDefinitions_1)/
                                           sizeof(ATTRIBUTE_DEFINITION_COLUMNS);
CONST NumberOfNtfsAttributeDefinitions_2 = sizeof(NtfsAttributeDefinitions_2)/
                                           sizeof(ATTRIBUTE_DEFINITION_COLUMNS);


DEFINE_EXPORTED_CONSTRUCTOR( NTFS_ATTRIBUTE_DEFINITION_TABLE,
                    NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_ATTRIBUTE_DEFINITION_TABLE::~NTFS_ATTRIBUTE_DEFINITION_TABLE(
    )
{
    Destroy();
}


VOID
NTFS_ATTRIBUTE_DEFINITION_TABLE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    (void) this;
}


VOID
NTFS_ATTRIBUTE_DEFINITION_TABLE::Destroy(
    )
/*++

Routine Description:

    Worker function for destruction/reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    (void) this;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE_DEFINITION_TABLE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      UCHAR                   VolumeMajorVersion
    )
/*++

Routine Description:

    This method initializes an Attribute Definition Table object.
    The only special knowledge that it adds to the File Record Segment
    initialization is the location within the Master File Table of the
    Attribute Definition Table.

Arguments:

    Drive           -- Supplies the drive on which the segment resides.
    Mft             -- Supplies the volume MasterFile Table.
    ClusterFactor   -- Supplies the volume Cluster Factor.

Return Value:

    TRUE upon successful completion

Notes:

    This class is reinitializable.


--*/
{
    Destroy();

    _volume_major_version = VolumeMajorVersion;

    return( NTFS_FILE_RECORD_SEGMENT::Initialize( ATTRIBUTE_DEF_TABLE_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_ATTRIBUTE_DEFINITION_TABLE::Create(
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
    )
/*++

Routine Description:

    This method formats a Attribute Definition Table File Record
    Segment in memory (without writing it to disk).

Arguments:

    StandardInformation -- supplies the standard information for the
                            file record segment.
    VolumeBitmap        -- supplies the bitmap for the volume on
                            which this object resides.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;
    LCN FirstLcn;
    ULONG Size;
    ULONG NumberOfClusters;
    ULONG BytesWritten;
    ULONG ClusterSize;

    // Set this object up as a File Record Segment.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }

    // The Attribute Definition Table has a data attribute whose value
    // consists of the attribute definition table.  The initial table,
    // with the system-defined attributes, is copied into this attribute.

    Size = QueryDefaultSize();

    ClusterSize = GetDrive()->QuerySectorSize() * QueryClusterFactor();

    NumberOfClusters = Size/ClusterSize;

    if( Size % ClusterSize ) {

        NumberOfClusters += 1;
    }

    if( !Extents.Initialize( 0, 0 ) ||
        !Extents.Resize( NumberOfClusters, VolumeBitmap ) ||
        !DataAttribute.Initialize( GetDrive(),
                                    QueryClusterFactor(),
                                    &Extents,
                                    Size,
                                    Size,
                                    $DATA ) ||
        !DataAttribute.Write( (PVOID) (_volume_major_version >= 2) ?
                                        NtfsAttributeDefinitions_2 :
                                        NtfsAttributeDefinitions_1,
                                0,
                                Size,
                                &BytesWritten,
                                VolumeBitmap ) ||
        BytesWritten != Size ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_ATTRIBUTE_DEFINITION_TABLE::VerifyAndFix(
    IN OUT  PNTFS_ATTRIBUTE_COLUMNS     AttributeDefTable,
    IN OUT  PNTFS_BITMAP                VolumeBitmap,
    IN OUT  PNUMBER_SET                 BadClusters,
    IN OUT  PNTFS_INDEX_TREE            RootIndex,
       OUT  PBOOLEAN                    Changes,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN      BOOLEAN                     SilentMode
    )
/*++

Routine Description:

    This routine compares the given attribute definition table with
    the one contained in this file's DATA attribute and ensures
    that both are the same.  The in-memory version will override the
    on-disk version.

Arguments:

    AttributeDefTable   - Supplies the in-memory version of the table.
    VolumeBitmap        - Supplies the volume bitmap.
    BadClusters         - Supplies the list of bad clusters.
    RootIndex           - Supplies the root index.
    Changes             - Returns whether or not changes were made.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.
    SilentMode          - Suppresses changes message as errors is expected

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE                  data_attribute;
    BOOLEAN                         error;
    ULONG                           num_columns;
    ULONG                           value_length;
    PCATTRIBUTE_DEFINITION_COLUMNS  mem_columns;
    PATTRIBUTE_DEFINITION_COLUMNS   disk_columns;
    ULONG                           num_bytes;
    NTFS_EXTENT_LIST                extent_list;
    BOOLEAN                         ErrorInAttribute;

    *Changes = FALSE;

    mem_columns = AttributeDefTable->GetColumns(&num_columns);
    value_length = num_columns*sizeof(ATTRIBUTE_DEFINITION_COLUMNS);

    if (!(disk_columns = new ATTRIBUTE_DEFINITION_COLUMNS[num_columns])) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!QueryAttribute(&data_attribute, &ErrorInAttribute, $DATA)) {

        *Changes = TRUE;

        if (!extent_list.Initialize(0, 0) ) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE(disk_columns);
            return FALSE;
        }

        if (!data_attribute.Initialize(GetDrive(),
                                       QueryClusterFactor(),
                                       &extent_list,
                                       0,
                                       0,
                                       $DATA)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE(disk_columns);
            return FALSE;

        }
    }

    error = FALSE;
    if (value_length != data_attribute.QueryValueLength()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ATTR_DEF_TABLE_LENGTH,
                     "%I64x%x",
                     data_attribute.QueryValueLength().GetLargeInteger(),
                     value_length);
        error = TRUE;
    } else if (!data_attribute.Read(disk_columns, 0, value_length, &num_bytes)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_ATTR_DEF_TABLE);

        error = TRUE;
    } else if (num_bytes != value_length) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_ATTR_DEF_TABLE);

        error = TRUE;
    } else if (memcmp(mem_columns, disk_columns, value_length)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ATTR_DEF_TABLE);

        error = TRUE;
    }

    if (error) {

        *Changes = TRUE;

        if (!SilentMode) {
            Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_ATTR_DEF);
        }

        if (FixLevel != CheckOnly) {
            if (!data_attribute.MakeNonresident(VolumeBitmap) ||
                !data_attribute.Resize(value_length, VolumeBitmap) ||
                !data_attribute.Write(mem_columns, 0, value_length, &num_bytes,
                                      VolumeBitmap) ||
                value_length != num_bytes) {

                if (!data_attribute.RecoverAttribute(VolumeBitmap, BadClusters) ||
                    !data_attribute.Write(mem_columns, 0, value_length,
                                          &num_bytes, VolumeBitmap) ||
                    value_length != num_bytes) {

                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTR_DEF);
                    DELETE(disk_columns);
                    return FALSE;
                }
            }
        }

        if (!data_attribute.InsertIntoFile(this, VolumeBitmap)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTR_DEF);
            DELETE(disk_columns);
            return FALSE;
        }
    }

    if (FixLevel != CheckOnly && !Flush(VolumeBitmap, RootIndex)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTR_DEF);
        DELETE(disk_columns);
        return FALSE;
    }

    DELETE(disk_columns);
    return TRUE;
}

ULONG
NTFS_ATTRIBUTE_DEFINITION_TABLE::QueryDefaultSize(
    )
/*++

Routine Description:

    This method returns the size of the default upcase table.

Arguments:

    None.

Return Value:

    The size of the default upcase table;

--*/
{
    if (_volume_major_version >= 2)
        return (sizeof( NtfsAttributeDefinitions_2 ));
    else
        return( sizeof( NtfsAttributeDefinitions_1 ) );
}

ULONG
NTFS_ATTRIBUTE_DEFINITION_TABLE::QueryDefaultMaxSize(
    )
/*++

Routine Description:

    This method returns the maximum size of the default upcase table.

Arguments:

    None.

Return Value:

    The maximum size of the default upcase table;

--*/
{
    return max(sizeof( NtfsAttributeDefinitions_1 ),
               sizeof( NtfsAttributeDefinitions_2 ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\attrib.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

   attrib.cxx

Abstract:

   This module contains member function definitions for NTFS_ATTRIBUTE,
   which models an NTFS attribute instance.

Author:

   Bill McJohn (billmc) 21-June-91

Environment:

   ULIB, User Mode


--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "cmem.hxx"
#include "drive.hxx"
#include "mft.hxx"
#include "attrrec.hxx"
#include "attrib.hxx"
#include "frs.hxx"
#include "ntfsbit.hxx"
#include "badfile.hxx"
#include "numset.hxx"
#include "rtmsg.h"

// This constant specifies the maximum number of clusters Read and
// Write will try to transfer at once.  Note that it is chosen to
// ensure that MaximumClustersToTransfer * ClusterSize will fito
// in  a ULONG.

CONST MaximumClustersToTransfer = 32;

UCHAR
ComputeCompressionUnit(
    IN ULONG    ClusterSize
    );

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_ATTRIBUTE, OBJECT, UNTFS_EXPORT );


UNTFS_EXPORT
NTFS_ATTRIBUTE::~NTFS_ATTRIBUTE(
         )
{
   Destroy();
}


VOID
NTFS_ATTRIBUTE::Construct (
   )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Type = 0;
    _Flags = 0;
    _CompressionUnit = 0;
    _ValueLength = 0;
    _ValidDataLength = 0;

    _ResidentData = NULL;
    _ExtentList = NULL;

    _StorageModified = FALSE;
}


VOID
NTFS_ATTRIBUTE::Destroy(
   )
/*++

Routine Description:

    Worker method for object destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Type = 0;

    _Flags = 0;
    _CompressionUnit = 0;
    _ValueLength = 0;
    _ValidDataLength = 0;

    if( _ResidentData != NULL ) {

        FREE( _ResidentData );
        _ResidentData = NULL;
    }

    if( _ExtentList != NULL ) {

        DELETE( _ExtentList );
        _ExtentList = NULL;
    }

    _StorageModified = FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Initialize (
   IN OUT  PLOG_IO_DP_DRIVE     Drive,
   IN      ULONG                ClusterFactor,
   IN      PCVOID               Value,
   IN      ULONG                ValueLength,
   IN      ATTRIBUTE_TYPE_CODE  TypeCode,
   IN      PCWSTRING            Name,
   IN      USHORT               Flags
   )
/*++

Routine Description:

    This method initializes a resident attribute based on its value.

Arguments:


    Drive           -- supplies the drive on which the attribute resides
    ClusterFactor   -- supplies the cluster factor for that drive
    Value           -- supplies the attribute's value.
    ValueLength     -- supplies the length of the attribute's value.
    TypeCode        -- supplies the attribute's type code.
    Name            -- supplies the attribute's name.  NULL indicates
                        that the attribute has no name.
    Flags           -- supplies the attribute's flags.

Return Value:

    TRUE upon successful completion.

Notes:

    If ValueLength is zero, then this is an empty attribute (and Value
    may be NULL).

--*/
{
    Destroy();

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;
    if (Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                 ATTRIBUTE_FLAG_SPARSE |
                 ATTRIBUTE_FLAG_ENCRYPTED)) {
        _CompressionUnit = ComputeCompressionUnit(
                            _Drive->QuerySectorSize() * ClusterFactor);
    }

    if( (_ResidentData = MALLOC( (UINT) ValueLength )) == NULL ) {

        Destroy();
        return FALSE;
    }

    if (Name) {
        if (!_Name.Initialize(Name)) {
            Destroy();
            return FALSE;
        }
    } else {
        if (!_Name.Initialize("")) {
            Destroy();
            return FALSE;
        }
    }


    // Copy the value into our buffer:

    memcpy( _ResidentData, Value, (UINT) ValueLength );

    _ValueLength = ValueLength;
    _ValidDataLength = ValueLength;

    _Type = TypeCode;
    _Flags = Flags;
    _ResidentFlags = 0;
    _FormCode = RESIDENT_FORM;

    _StorageModified = TRUE;

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Initialize (
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      ULONG               ClusterFactor,
    IN      PCNTFS_EXTENT_LIST  Extents,
    IN      BIG_INT             ValueLength,
    IN      BIG_INT             ValidLength,
    IN      ATTRIBUTE_TYPE_CODE TypeCode,
    IN      PCWSTRING           Name,
    IN      USHORT              Flags
   )
/*++

Routine Description:

    This method initializes a non-resident attribute based on an
    extent list.

Arguments:

    Drive           -- supplies the drive on which the attribute resides
    ClusterFactor   -- supplies the cluster factor for that drive
    Extents         -- supplies the extent list describing the attribute
                        value's disk storage.
    ValueLength     -- supplies the actual length of the attribute's value.
    ValidLength     -- supplies the valid length of the attribute's value.
    TypeCode        -- supplies the attribute's type code.
    Name            -- supplies the attribute's name.  NULL indicates
                        that the attribute has no name.
    Flags           -- supplies the attribute's flags.

Return Code:

    TRUE upon successful completion.

--*/
{
    Destroy();

    if (Extents->QueryLowestVcn() != 0) {
        Destroy();
        return FALSE;
    }

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;

    if (Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                 ATTRIBUTE_FLAG_SPARSE |
                 ATTRIBUTE_FLAG_ENCRYPTED)) {
        _CompressionUnit = ComputeCompressionUnit(
                            _Drive->QuerySectorSize() * ClusterFactor);
    }

    if( (_ExtentList = NEW NTFS_EXTENT_LIST) == NULL ||
        !_ExtentList->Initialize( Extents ) ) {

        Destroy();
        return FALSE;
    }

    if (Name) {
        if (!_Name.Initialize(Name)) {
            Destroy();
            return FALSE;
        }
    } else {
        if (!_Name.Initialize("")) {
            Destroy();
            return FALSE;
        }
    }

    _ResidentData = NULL;
    _ResidentFlags = 0;

    _ValueLength = ValueLength;
    _ValidDataLength =  ValidLength;

    if (CompareGT(_ValidDataLength, _ValueLength) ||
        CompareGT(_ValueLength, QueryAllocatedLength())) {

        Destroy();
        return FALSE;
    }

    _Type = TypeCode;
    _Flags = Flags;
    _FormCode = NONRESIDENT_FORM;
    _StorageModified = TRUE;

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::Initialize (
    IN OUT  PLOG_IO_DP_DRIVE        Drive,
    IN      ULONG                   ClusterFactor,
    IN      PCNTFS_ATTRIBUTE_RECORD AttributeRecord
   )
/*++

Routine Description:

    This method initializes an attribute based on an attribute record.

Arguments:

    Drive           -- supplies the drive on which the attribute resides
    ClusterFactor   -- supplies the cluster factor for that drive
    AttributeRecord -- supplies the attribute record.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT AllocatedLength;

    Destroy();

    if (AttributeRecord->QueryLowestVcn() != 0) {
        Destroy();
        return FALSE;
    }

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;

    _Type = AttributeRecord->QueryTypeCode();
    _Flags = AttributeRecord->QueryFlags();
    _CompressionUnit = (UCHAR)AttributeRecord->QueryCompressionUnit();
    _StorageModified = FALSE;

    if (!AttributeRecord->QueryName(&_Name)) {

        Destroy();
        return FALSE;
    }

    if( AttributeRecord->IsResident() ) {

        _ValueLength = AttributeRecord->QueryResidentValueLength();

        if( (_ResidentData = MALLOC( (UINT) AttributeRecord->
                                            QueryResidentValueLength() )) ==
            NULL ) {

            Destroy();
            return FALSE;
        }

        // Copy the value into our buffer:

        memcpy( _ResidentData,
                AttributeRecord->GetResidentValue(),
                (UINT) AttributeRecord->QueryResidentValueLength() );

        _ValidDataLength = _ValueLength;

        _FormCode = RESIDENT_FORM;
        _ResidentFlags = AttributeRecord->QueryResidentFlags();

    } else {

        if (!(_ExtentList = NEW NTFS_EXTENT_LIST) ||
            !AttributeRecord->QueryExtentList(_ExtentList)) {

            Destroy();
            return FALSE;
        }

        AttributeRecord->QueryValueLength( &_ValueLength,
                                           &AllocatedLength,
                                           &_ValidDataLength );

        _FormCode = NONRESIDENT_FORM;
        _ResidentFlags = 0;
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::AddAttributeRecord (
    IN      PCNTFS_ATTRIBUTE_RECORD AttributeRecord,
    IN OUT  PNTFS_EXTENT_LIST       *BackupExtent
   )
/*++

Routine Description:

    This method adds an attribute record to the attribute.

    This method is intended to be used in inializing the
    attribute with multiple attribute records.

Arguments:

    AttributeRecord -- supplies the attribute record.
    BackupExtent    -- supplies/receives a copy of the extent list

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING             record_name;
    NTFS_EXTENT_LIST    extent_list;
    ULONG               i, n;
    VCN                 vcn;
    LCN                 lcn;
    BIG_INT             run_length;

    if (IsResident() || AttributeRecord->IsResident()) {

        // Can't have multiple resident attribute records.
        return FALSE;
    }

    DebugAssert(_ExtentList);

    if (_Type != AttributeRecord->QueryTypeCode()) {

        // Attribute record must have the same type code.
        return FALSE;
    }

    // The filesystem only cares about and maintains the Flags member
    // in the first attribute record of a multi-frs attribute.  So
    // I removed the check below, which used to insure that each set
    // of flags was identical. -mjb.

    if (!AttributeRecord->QueryName(&record_name) ||
        record_name.Strcmp(&_Name) ||
        /* _Flags != AttributeRecord->QueryFlags() || */
        !AttributeRecord->QueryExtentList(&extent_list) ||
        (*BackupExtent == NULL &&
         ((*BackupExtent = NEW NTFS_EXTENT_LIST) == NULL ||
          !(*BackupExtent)->Initialize(_ExtentList)))) {

        return FALSE;
    }

    n = extent_list.QueryNumberOfExtents();

    for (i = 0; i < n; i++) {
        // Query i'th extent from attribute record and
        // add it to the backup extent list
        if (!extent_list.QueryExtent(i, &vcn, &lcn, &run_length) ||
            !(*BackupExtent)->AddExtent(vcn, lcn, run_length)) {
            DebugPrint("UNTFS: Unable to update the backup extent list\n");
            return FALSE;
        }
    }

    for (i = 0; i < n; i++) {

        // Query i'th extent from attribute record and
        // add it to the current extent list
        if (!extent_list.QueryExtent(i, &vcn, &lcn, &run_length) ||
            !_ExtentList->AddExtent(vcn, lcn, run_length)) {

            // Restore the extent list.
            for (i=0; i < n; i++) {
                if (!extent_list.QueryExtent(i, &vcn, &lcn, &run_length) ||
                    !(*BackupExtent)->DeleteRange(vcn, run_length)) {
                    DebugPrint("UNTFS: Unable to restore extent list\n");
                    return FALSE;
                }
            }
            _ExtentList->Initialize(*BackupExtent);
            return FALSE;
        }
    }

    // If the LowestVcn of this record is less than the LowestVcn
    // of the extent list, update the extent list.  If the NextVcn
    // of this record is greater than the NextVcn of the extent list,
    // update the extent list.  This will cover the cases where the
    // the attribute is sparse and the new record begins or ends with
    // a gap
    //

    if( AttributeRecord->QueryLowestVcn() < _ExtentList->QueryLowestVcn() ) {

        _ExtentList->SetLowestVcn( AttributeRecord->QueryLowestVcn() );
        (*BackupExtent)->SetLowestVcn( AttributeRecord->QueryLowestVcn() );
    }

    if( AttributeRecord->QueryNextVcn() > _ExtentList->QueryNextVcn() ) {

        _ExtentList->SetNextVcn( AttributeRecord->QueryNextVcn() );
        (*BackupExtent)->SetNextVcn( AttributeRecord->QueryNextVcn() );
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::VerifyAndFix(
    IN  BIG_INT VolumeSectors
    )
/*++

Routine Description:

    This routine ensures that the allocation of the given
    attribute is non-self overlapping and that the allocation
    does not use the clusters reserved for the boot file.

    It also tweeks the allocation sizes if necessary.

Arguments:

    VolumeSectors   - Supplies the number of sectors on the volume.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG               i;
    LCN                 j;
    LCN                 lcn;
    VCN                 vcn;
    BIG_INT             run_length;
    NTFS_BITMAP         allocated_clusters;
    NTFS_EXTENT_LIST    new_extent_list;
    BOOLEAN             cross_link;
    BIG_INT             num_clusters;

    cross_link = FALSE;

    if (_ExtentList) {

        // Now analyse the mapping pairs for cross-links.
        // Truncate the attribute at the first offending
        // cluster.

        num_clusters = VolumeSectors/QueryClusterFactor();

        if (!allocated_clusters.Initialize(num_clusters, FALSE, _Drive,
                _ClusterFactor) ||
            !new_extent_list.Initialize(0, 0)) {

            return FALSE;
        }

        // Mark as allocate sector zero since this always belongs
        // to the boot file.  Don't bother marking n/2 as allocated
        // because we deal with copying that cross-links there.

        allocated_clusters.SetAllocated(0, 1);

        for (i = 0; _ExtentList->QueryExtent(i, &vcn, &lcn, &run_length); i++) {

            if (LCN_NOT_PRESENT == lcn) {
                continue;
            }

            if (!allocated_clusters.IsFree(lcn, run_length)) {

                for (j = 0; j < run_length; j += 1) {
                    if (!allocated_clusters.IsFree(lcn + j, 1)) {
                        break;
                    }
                }

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_TAG_ATTR_REC_CROSS_LINKED,
                                 "%x%I64x%I64x",
                                 QueryTypeCode(),
                                 (lcn + j).GetLargeInteger(),
                                 (run_length - j).GetLargeInteger());
                    }
                }

                if (j > 0 && !new_extent_list.AddExtent(vcn, lcn, j)) {
                    return FALSE;
                }

                cross_link = TRUE;
                break;
            }

            allocated_clusters.SetAllocated(lcn, run_length);

            if (!new_extent_list.AddExtent(vcn, lcn, run_length)) {
                return FALSE;
            }
        }
    }

    if (cross_link) {
        if (!_ExtentList->Initialize(&new_extent_list)) {
            return FALSE;
        }
        _StorageModified = TRUE;
    }

    if (CompareGT(_ValueLength, QueryAllocatedLength())) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_UNKNOWN_TAG_ATTR_SIZES,
                         "%I64x%I64x%I64x%x",
                         _ValidDataLength.GetLargeInteger(),
                         _ValueLength.GetLargeInteger(),
                         QueryAllocatedLength().GetLargeInteger(),
                         QueryTypeCode());
            }
        }

        _ValueLength = QueryAllocatedLength();
        _StorageModified = TRUE;
    }

    if (CompareGT(_ValidDataLength, _ValueLength)) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_UNKNOWN_TAG_ATTR_SIZES,
                         "%I64x%I64x%I64x%x",
                         _ValidDataLength.GetLargeInteger(),
                         _ValueLength.GetLargeInteger(),
                         QueryAllocatedLength().GetLargeInteger(),
                         QueryTypeCode());
            }
        }

        _ValidDataLength = _ValueLength;
        _StorageModified = TRUE;
    }

    return TRUE;
}


BOOLEAN
PartitionExtentList(
    IN  PCNTFS_EXTENT_LIST  SourceList,
    IN  ULONG               MaxSize,
    OUT PNTFS_EXTENT_LIST   ResultList,
    OUT PNTFS_EXTENT_LIST   RemainderList
    )
/*++

Routine Description:

    This routine partitions 'SourceList' into 'ResultList' and
    'RemainderList'.

    'ResultList' contains as many extents from 'SourceList' as can be
    compressed into 'MaxSize' bytes.

    'RemainderList' contains all of the extents of 'SourceList' which are
    not in 'ResultList'.

Arguments:

    SourceList      - Supplies the list of extents to partition.
    MaxSize         - Supplies the maximum number of bytes for
                        the compressed mapping pairs of the first
                        part of the partition.
    ResultList      - Returns the first part of the partition.
    RemainderList   - Returns the second part of the partition.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   MaxBytesPerMappingPair = sizeof(LCN) + sizeof(VCN) + 1;

    VCN lowest;
    VCN next;
    ULONG mapping_length;
    PUCHAR mapping_space;
    ULONG buffer_size;
    ULONG count;
    ULONG ptr;
    VCN vcn;
    LCN lcn;
    BIG_INT run_length;
    ULONG i;
    VCN part_next;
    ULONG num_extents;
    UCHAR v, l;
    BIG_INT tmp;
    BIG_INT sum;
    BOOLEAN ends_with_gap = FALSE;
    BOOLEAN HasHoleInFront;


    // Handle an empty list gracefully

    if( SourceList->IsEmpty() ) {

        if( !ResultList->Initialize( SourceList ) ||
            !RemainderList->Initialize( 0, 0 ) ) {

            return FALSE;
        }

        return TRUE;
    }


    // compute an upper bound for the space required by the compressed
    // extents of the source extent list.

    // This upper bound formula may be too much as QueryNumberOfExtents will
    // return all entries including gaps except the last one if it is a gap.

    buffer_size = MaxBytesPerMappingPair*
                  (2*SourceList->QueryNumberOfExtents() + 1) + 1;

    if ( (mapping_space = (PUCHAR) MALLOC( (UINT) buffer_size )) == NULL ) {

        return FALSE;
    }


    // Get the compressed mapping pairs for the source list.

    // The HasHoleInFront flag allows us to take into account of the
    // (0, ffffffff. ????) entry at the very beginning of an extented
    // list.  As this entry won't make it into the compression pairs.
    // The code below that counts the compression pairs and retrieves
    // vcn/lcn/runlength tuple needs to take into account of this entry.


    if (!SourceList->QueryCompressedMappingPairs(&lowest,
                                                 &next,
                                                 &mapping_length,
                                                 buffer_size,
                                                 mapping_space,
                                                 &HasHoleInFront)) {
        FREE(mapping_space);
        return FALSE;
    }

    // Let count denote the number of extents in the first partition

    count = 0;
    ptr = 0;
    sum = 0;
    while (mapping_space[ptr] != 0) {

        v = VcnBytesFromCountByte(mapping_space[ptr]);
        l = LcnBytesFromCountByte(mapping_space[ptr]);

        // Only consider this mapping pair if it will fit along with
        // the next description byte.

        if (ptr + v + l + 2 > MaxSize) {
            break;
        }

        tmp.Set(l, &mapping_space[ptr + v + 1]);
        sum += tmp;

#if 0
        if (SourceList->QueryNumberOfExtents() > 20) {
            DebugPrintTrace(("%d, %I64x, ", count, sum));
            if (SourceList->QueryExtent(count, &vcn, &lcn, &run_length)) {
                DebugPrintTrace(("(%I64x, %I64x, %I64x)\n", vcn, lcn, run_length));
            } else {
                DebugPrintTrace(("(error)\n"));
            }
        }
#endif

        count++;

        // If the number of LCN bytes is 0 or the lcn is -1,
        // then it's a place holder, not a real extent.

        if (l != 0 && sum != -1) {
            ends_with_gap = FALSE;
        } else {
            ends_with_gap = TRUE;
        }

        ptr += v + l + 1;
    }

#if 0
    if (SourceList->QueryNumberOfExtents() > 20) {
        DebugPrintTrace(("%d", count));
        if (SourceList->QueryExtent(count, &vcn, &lcn, &run_length)) {
            DebugPrintTrace(("(%I64x, %I64x, %I64x)\n", vcn, lcn, run_length));
        } else {
            DebugPrintTrace(("(error)\n"));
        }
    }
#endif

    // Compute the next VCN of the first partition, which is also the
    // starting VCN of the remainder.
    //
    if (mapping_space[ptr] == 0) {

        // We processed and accepted for the first partition the entire
        // source list; this means that the result list is the same as
        // the sources, and the remainder is empty.
        //
        count = SourceList->QueryNumberOfExtents();
        part_next = next;

    } else {

        if (!SourceList->QueryExtent(count,
                                     &part_next, &lcn, &run_length)) {
            return FALSE;
        }
    }

    FREE(mapping_space);


    // Now that we know how to split it up, create the two partitions.

    if (!ResultList->Initialize(lowest, part_next) ||
        !RemainderList->Initialize(part_next, next)) {

        return FALSE;
    }

    for (i = 0; i < count; i++) {

        if (!SourceList->QueryExtent(i, &vcn, &lcn, &run_length)) {
            return FALSE;
        }

        if (LCN_NOT_PRESENT == lcn) {
            continue;
        }

        if (!ResultList->AddExtent(vcn, lcn, run_length)) {
            return FALSE;
        }
    }

    num_extents = SourceList->QueryNumberOfExtents();

    for (i = count; i < num_extents; i++) {

        if (!SourceList->QueryExtent(i, &vcn, &lcn, &run_length)) {
            return FALSE;
        }

        if (LCN_NOT_PRESENT == lcn) {
            continue;
        }

        if (!RemainderList->AddExtent(vcn, lcn, run_length)) {
            return FALSE;
        }
    }

    return TRUE;
}



UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::InsertIntoFile (
   IN OUT  PNTFS_FILE_RECORD_SEGMENT   BaseFileRecordSegment,
   IN OUT  PNTFS_BITMAP                Bitmap
   )
/*++


Routine Description:

    This method inserts the attribute into a File Record Segment.
    The attribute packages itself up into Attribute Records and
    jams them into the File Record Segment.

Arguments:

    FileRecordSegment   -- Supplies the File Record Segment into
                            which the attribute will jam itself.
    Bitmap              -- Supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    If the volume bitmap is supplied, the attribute may make itself
    nonresident, or the File Record Segment may make one or more of
    its attribute records nonresident or external.

--*/
{
    NTFS_ATTRIBUTE_RECORD AttributeRecord;
    PVOID AttributeRecordData;
    BOOLEAN Result;
    ULONG MaxSize;
    ULONG MaxExtentsSize, CurrentMaxExtentsSize;
    NTFS_EXTENT_LIST source;
    NTFS_EXTENT_LIST result;
    NTFS_EXTENT_LIST remainder;
    BOOLEAN FirstChunkInserted = FALSE;
    BOOLEAN Completed = FALSE;


    // First purge the attribute out of the file, unless it's indexed.

    if (!IsIndexed()) {

        if (!BaseFileRecordSegment->PurgeAttribute(_Type, &_Name)) {
            return FALSE;
        }
    }

    // If this is the MFT Data attribute, use the private worker method:
    //
    if( BaseFileRecordSegment->QueryFileNumber() == MASTER_FILE_TABLE_NUMBER &&
        QueryTypeCode() == $DATA &&
        _Name.QueryChCount() == 0 ) {

        // First, try to save the MFT data attribute conservatively,
        // leaving space for future hotfixing.  If that fails (typically
        // because of bootstrapping problems), fill it to the gills.
        //
        if( InsertMftDataIntoFile( BaseFileRecordSegment, Bitmap, TRUE ) ) {

            ResetStorageModified();
            return TRUE;

        } else {

            Result = BaseFileRecordSegment->PurgeAttribute(_Type, &_Name) &&
                     InsertMftDataIntoFile( BaseFileRecordSegment, Bitmap, FALSE );
            ResetStorageModified();
            return Result;
        }
    }


    // Allocate a buffer to hold attribute records.

    MaxSize = BaseFileRecordSegment->QueryMaximumAttributeRecordSize();

    if( (AttributeRecordData = MALLOC( (UINT) MaxSize )) == NULL ) {

        return FALSE;
    }


    // Handle the resident attribute case:

    if ( _ResidentData != NULL ) {

        if( !AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize ) ) {

            FREE( AttributeRecordData );
            return FALSE;
        }

        // The attribute value is resident.  Package up a resident
        // attribute record.

        Result = AttributeRecord.
                    CreateResidentRecord( _ResidentData,
                                          _ValueLength.GetLowPart(),
                                          _Type,
                                          &_Name,
                                          _Flags,
                                          _ResidentFlags );

        //
        // Check to see if there is enough space to Create a resident record
        //

        if (Result) {
            Result = BaseFileRecordSegment->
                            InsertAttributeRecord( &AttributeRecord );

            FREE( AttributeRecordData );
            return Result;
        } else {
            // Not enough space to do so, make attribute record non-resident
            if (IsIndexed() || !Bitmap || !MakeNonresident(Bitmap)) {
               FREE( AttributeRecordData );
               return FALSE;
            }
        }
    }


    // Compute the maximum number of bytes in an extent list.
    //
    MaxExtentsSize = MaxSize - SIZE_OF_NONRESIDENT_HEADER;
    if (_Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                  ATTRIBUTE_FLAG_SPARSE)) {
        MaxExtentsSize -= sizeof(BIG_INT);
    }
    MaxExtentsSize -= QuadAlign(_Name.QueryChCount());
    Result = source.Initialize(_ExtentList);

    while (Result && !Completed) {

        // Initialize attribute record.

        Result = AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize );


        // Partition extent list into two pieces, the first of which
        // can be made into an attribute record.

        Result = Result &&
                 PartitionExtentList(&source,
                                     MaxExtentsSize,
                                     &result,
                                     &remainder);


        // Create the attribute record.

        Result = Result &&
                 AttributeRecord.
                    CreateNonresidentRecord( &result,
                                             QueryAllocatedLength(),
                                             _ValueLength,
                                             _ValidDataLength,
                                             _Type,
                                             &_Name,
                                             _Flags,
                                             _CompressionUnit,
                                             _ClusterFactor*_Drive->QuerySectorSize());


        // If we were able to package it up, then give the attribute
        // record to the File Record Segment.

        Result = Result &&
                 BaseFileRecordSegment->
                            InsertAttributeRecord( &AttributeRecord );


        // If all of the extents fit in the last record then we are done.

        if (remainder.IsEmpty()) {

            Completed = TRUE;

        } else {

            Result = Result &&
                    source.Initialize(&remainder);
        }
    }


    ResetStorageModified();
    FREE( AttributeRecordData );
    return Result;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::MakeNonresident (
   IN OUT  PNTFS_BITMAP    Bitmap
   )
/*++

Routine Description:

    This method makes the attribute value nonresident.

Arguments:

    Bitmap  -- supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    If the attribute is already nonresident, this method succeeds.

--*/
{
    NTFS_CLUSTER_RUN ClusterRun;
    HMEM IntermediateBuffer;
    LCN Lcn;
    ULONG DataLength, ClusterSize, ClustersRequired, ClustersAllocated, MaxRunLength;
    ULONG RunLength;

    if (!IsResident()) {

        // The attribute is already nonresident, which makes
        // this task pretty easy.

        return TRUE;
    }


    // Since the attribute is resident, its length will fit in a ULONG.
    //
    DebugAssert(_ValueLength.GetHighPart() == 0);

    DataLength = _ValueLength.GetLowPart();

    if (DataLength == 0) {

        // This attribute has no data, so we just set up an empty
        // extent list.

        if ((_ExtentList = NEW NTFS_EXTENT_LIST) == NULL ||
            !_ExtentList->Initialize( 0, 0 )) {
            if (_ExtentList != NULL)
                DELETE(_ExtentList);
            return FALSE;
        }

        FREE(_ResidentData);
        _ResidentData = NULL;

        _FormCode = NONRESIDENT_FORM;
        SetStorageModified();
        return TRUE;
    }

    // This attribute has data, so we need to allocate disk space
    // for it, copy it into that disk space, and set up an extent
    // list that describes that disk space.  Determine how many
    // clusters we need to hold the resident value.

    if ((_ExtentList = NEW NTFS_EXTENT_LIST ) == NULL ||
        !_ExtentList->Initialize( 0, 0 )) {

        if (_ExtentList != NULL)
            DELETE( _ExtentList );
        return FALSE;
    }

    ClusterSize = _Drive->QuerySectorSize() * _ClusterFactor;

    ClustersRequired = DataLength / ClusterSize;
    if (DataLength % ClusterSize) {

        ClustersRequired += 1;
    }

    ClustersAllocated = 0;
    MaxRunLength = ClustersRequired;

    while (ClustersAllocated < ClustersRequired) {

        //
        // Never try to allocate more clusters than we need to finish the
        // allocation.
        //

        RunLength = min(MaxRunLength, ClustersRequired - ClustersAllocated);

        if (!Bitmap->AllocateClusters( 0, RunLength, &Lcn )) {

            if (RunLength == 1) {

                // Out of disk space.
                return FALSE;
            }

            MaxRunLength /= 2;
            continue;
        }

        _ExtentList->AddExtent( ClustersAllocated /* vcn */,
                                Lcn,
                                RunLength );

        //
        // Copy data from the resident attribute value into this chunk of
        // the nonresident attribute allocation.
        //

        if (!IntermediateBuffer.Initialize() ||
            !ClusterRun.Initialize( &IntermediateBuffer, _Drive, Lcn, _ClusterFactor,
                                    RunLength )) {

            Bitmap->SetFree( Lcn, RunLength );
            return FALSE;
        }

        memset( ClusterRun.GetBuf(), '\0', ClusterSize * RunLength );
        memcpy( ClusterRun.GetBuf(),
                PUCHAR(_ResidentData) + ClustersAllocated * ClusterSize,
                min(ClusterSize * RunLength,
                    DataLength - ClustersAllocated * ClusterSize) );

        if (!ClusterRun.Write()) {

            Bitmap->SetFree( Lcn, RunLength );
            return FALSE;
        }

        ClustersAllocated += RunLength;
    }

    //
    // We've succeeded in making the attribute value nonresident.
    // Clean up the resident data and change the state variables.
    //

    FREE( _ResidentData );
    _ResidentData = NULL;

    _FormCode = NONRESIDENT_FORM;

    SetStorageModified();

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Resize (
   IN      BIG_INT      NewSize,
   IN OUT  PNTFS_BITMAP Bitmap
   )
/*++

Routine Description:

    This method changes the file size of an attribute.  It will also modify
    the allocated size appropriately, either extending or truncating it.

Arguments:

    NewSize -- supplies the attribute value's new allocated size.
    Bitmap  -- supplies the volume bitmap.  May be NULL.

Return Value:

    None.

Notes:

    If the attribute value is resident and the client attempts to
    allocate to a new size which is greater than the maximum ULONG,
    this method will fail.  The client must call MakeNonresident first.

    Note that a nonresident attribute cannot be extended without
    the bitmap; if a nonresident attribute is truncated without
    a bitmap then the free space is not updated in the bitmap.

--*/
{
    BIG_INT NewNumberOfClusters, NewAllocatedSize;
    PVOID NewData;
    ULONG ClusterSize;

    if (_ValueLength == NewSize &&
        QueryAllocatedLength() == NewSize) {

        return TRUE;
    }

    if( _ResidentData != NULL ) {

        // The attribute value is resident.  We just allocate a
        // new chunk of memory, zero it out, copy in the old value
        // (or as much of it as fits), and adjust the length fields.

        // Note that we do not allow the client to resize a resident
        // attribute to a size greater than the maximum ULONG.

        if( NewSize.GetHighPart() == 0 &&
            (NewData = MALLOC( NewSize.GetLowPart() )) != NULL ) {

            memset( NewData, '\0', NewSize.GetLowPart() );
            memcpy( NewData,
                    _ResidentData,
                    MIN(_ValueLength.GetLowPart(), NewSize.GetLowPart()) );

            _ValueLength = NewSize;
            _ValidDataLength = NewSize;

            FREE( _ResidentData );
            _ResidentData = NewData;

            SetStorageModified();

            return TRUE;

        } else {

            return FALSE;
        }

    } else {

        // The attribute value is nonresident.  First, we round the
        // allocation size up to a multiple of the volume cluster size.
        // Since ClusterSize is always a power of two, the use of
        // the low part of NewSize in this modulo operation is safe.

        ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();

        NewAllocatedSize = NewSize;

        if( NewAllocatedSize % ClusterSize != 0 ) {

            NewAllocatedSize += (ClusterSize - NewAllocatedSize % ClusterSize);
        }

        NewNumberOfClusters = NewAllocatedSize / ClusterSize;

        DebugAssert( _ExtentList != NULL );

        if (_ExtentList == NULL)
            return FALSE;

        if( _ExtentList->Resize( NewNumberOfClusters, Bitmap ) ) {

            _ValueLength = NewSize;

            if( CompareGT(_ValidDataLength, _ValueLength) ) {

                _ValidDataLength = _ValueLength;
            }

            SetStorageModified();

            return TRUE;

        } else {

            return FALSE;
        }
    }
}

UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::SetSparse(
   IN      BIG_INT      NewSize,
   IN OUT  PNTFS_BITMAP Bitmap
   )
/*++

Routine Description:

    This method changes the file size of an sparse attribute to the given size.  It
    will free any allocated clusters and put a hole at the beginning.

Arguments:

    NewSize -- supplies the attribute value's new file size.
    Bitmap  -- supplies the volume bitmap.

Return Value:

    None.

Notes:

--*/
{
    BIG_INT NewNumberOfClusters, NewAllocatedSize;
    ULONG   ClusterSize;

    if (!(_Flags & ATTRIBUTE_FLAG_SPARSE)) {

        // return error if this is not a sparse file

        return FALSE;
    }

    if ( _ResidentData != NULL ) {

        // The attribute value is resident.  So, make it into a non-resident
        // one first.

        if (!MakeNonresident(Bitmap))
            return FALSE;

    }

    // The attribute value is nonresident.  First, we round the
    // allocation size up to a multiple of the volume cluster size.
    // Since ClusterSize is always a power of two, the use of
    // the low part of NewSize in this modulo operation is safe.

    ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();

    NewAllocatedSize = NewSize;

    if( NewAllocatedSize % ClusterSize != 0 ) {

        NewAllocatedSize += (ClusterSize - NewAllocatedSize % ClusterSize);
    }

    NewNumberOfClusters = NewAllocatedSize / ClusterSize;

    DebugAssert( _ExtentList != NULL );

    if (_ExtentList == NULL)
        return FALSE;

    // now throw away any allocation and then make
    // the stream sparse

    if( _ExtentList->Resize( 0, Bitmap ) &&
        _ExtentList->SetSparse(NewNumberOfClusters)) {

        _ValueLength = NewSize;

        _ValidDataLength = 0;

        SetStorageModified();

        return TRUE;

    } else {

        return FALSE;
    }
}


BOOLEAN
NTFS_ATTRIBUTE::AddExtent(
    IN  VCN     Vcn,
   IN  LCN     Lcn,
   IN  BIG_INT RunLength
   )
/*++

Routine Description:

    This method adds an extent to the Attribute's allocation.  (Note
    that if the attribute is resident, this method will fail.)

Arguments:

    Vcn         -- supplies the starting VCN of the run.
    Lcn         -- supplies the starting LCN of the run.
    RunLength   -- supplies the number of clusters in the run.

Return Value:

    TRUE upon successful completion.
--*/
{
    if( _ExtentList == NULL ) {

        return FALSE;

    } else {

        if ( _ExtentList->AddExtent( Vcn, Lcn, RunLength ) ) {

            SetStorageModified();
            return TRUE;

        } else {

            return FALSE;
        }
    }
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Read (
   OUT PVOID   Data,
   IN BIG_INT ByteOffset,
   IN ULONG   BytesToRead,
   OUT PULONG  BytesRead
   )
/*++

Routine Description:

    This method reads data from the attribute's value.

Arguments:

    Data        -- supplies the user's buffer, into which data
                    will be read.
    ByteOffset  -- supplies the byte offset into the attribute value
                    at which the read should commence.
    BytesToRead -- supplies the number of bytes to read.
    BytesRead   -- receives the number of bytes actually read.

Return Value:

    TRUE upon successful completion.

Notes:

    Read will only read up to the attribute's actual length.

    Note that Read ignores the attribute's valid data length.

    Note that if Read fails, the contents of the user's buffer is
    undefined.

    This method is able to handle sparse attributes.

--*/
{
    NTFS_CLUSTER_RUN ClusterRun;
    HMEM IntermediateBuffer;
    BIG_INT TempBigInt;
    BIG_INT RunLength;
    VCN CurrentVcn;
    LCN CurrentLcn;
    PBYTE CurrentData;
    ULONG BytesToCopy;
    ULONG OffsetIntoCluster;
    ULONG ClusterSize;
    ULONG CurrentRunLength;
    ULONG RemainingRequest;
    ULONG BytesToZero = 0;

    // First, perform some range-checking.  We can only read to
    // the end of the actual size of the attribute value.

    if( _ValueLength <= ByteOffset ) {

        BytesToRead = 0;

    } else if ( _ValueLength < ByteOffset + BytesToRead ) {

        // Since this difference is less than BytesToRead, this
        // assignment is safe:

        TempBigInt = _ValueLength - ByteOffset;
        BytesToRead = TempBigInt.GetLowPart();
    }


    if( _ResidentData != NULL ) {

        // Since the attribute value is resident, we can
        // just copy it.  We've verified above that the request
        // fits in the allocated space, so there's nothing more
        // to do except the copy itself.

        memcpy( Data,
                (PCHAR) _ResidentData + ByteOffset.GetLowPart(),
                (UINT) BytesToRead );

    } else if ( _ExtentList != NULL ) {

        RemainingRequest = BytesToRead;

        // Now check the valid length.  If the entire read is beyond
        // the end valid data, just zero it out; otherwise, zero out
        // the portion beyond the end of valid data.
        //
        if( CompareLTEQ(_ValidDataLength, ByteOffset) ) {

            // The entire read is beyond the end of valid data.
            //
            memset( Data, 0, BytesToRead );
            *BytesRead = BytesToRead;
            return TRUE;

        } else if( CompareLT(_ValidDataLength, ByteOffset + BytesToRead) ) {

            // Only read the portion up to the end of valid data;
            // zero the rest out.
            //
            TempBigInt = _ValidDataLength - ByteOffset;
            RemainingRequest = TempBigInt.GetLowPart();

            BytesToZero = BytesToRead - RemainingRequest;

            memset( (PBYTE) Data + RemainingRequest, 0, BytesToZero );
        }

        // The attribute value is nonresident, so we'll have to go
        // find it on disk.  First, we'll read any leading partial
        // cluster through an intermediate buffer.  Then we'll read
        // as many whole clusters as there are in the request directly
        // into the user's buffer.  Finally, we'll read any trailing
        // partial cluster through the intermediate buffer.

        if( RemainingRequest > 0 ) {

            ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();
            CurrentData = (PBYTE) Data;

            OffsetIntoCluster = (ByteOffset % ClusterSize).GetLowPart();

            if( OffsetIntoCluster != 0 ) {

                // We have a partial leading cluster, so we'll read
                // it through the intermediate buffer.

                BytesToCopy = MIN( BytesToRead - BytesToZero,
                                   ClusterSize - OffsetIntoCluster );

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->  QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This part of the request hits a hole in a
                    // sparse file, so we just fill the corresponding
                    // part of the request with zeroes.

                    memset( CurrentData, 0, BytesToCopy );

                } else {

                    // Read the cluster containing this part of the
                    // request and copy the partial leading cluster
                    // into the client's buffer.

                    if( !IntermediateBuffer.Initialize() ||
                        !ClusterRun.Initialize( &IntermediateBuffer,
                                                _Drive,
                                                CurrentLcn,
                                                _ClusterFactor,
                                                1 ) ||
                        !ClusterRun.Read() ) {

                        DebugPrint( "Cannot read leading clusters.\n" );

                        return FALSE;
                    }

                    memcpy( CurrentData,
                            (PBYTE)ClusterRun.GetBuf() + OffsetIntoCluster,
                            (UINT) BytesToCopy );
                }

                RemainingRequest -= BytesToCopy;
                CurrentData += BytesToCopy;
                ByteOffset += BytesToCopy;
            }

            // Now transfer any complete clusters.  Because the
            // client's buffer may not be suitably aligned, we
            // have to cycle these through an intermediate buffer.

            while( RemainingRequest >= ClusterSize ) {

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( RunLength.GetHighPart() != 0 ||
                    RunLength.GetLowPart() >
                            MaximumClustersToTransfer ) {

                    CurrentRunLength = MaximumClustersToTransfer;

                } else {

                    CurrentRunLength = RunLength.GetLowPart();
                }

                if( CurrentRunLength * ClusterSize >
                    RemainingRequest ) {

                    CurrentRunLength = RemainingRequest/ClusterSize;
                }

                BytesToCopy = CurrentRunLength * ClusterSize;

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This part of the read request falls into a hole
                    // in a sparse attribute, so we can just fill the
                    // client's buffer with zeroes.

                    memset( CurrentData, 0, BytesToCopy );

                } else {

                    // Read the data into the temporary buffer (used
                    // to avoid alignment problems) and then copy it
                    // into the client's buffer.

                    if( !IntermediateBuffer.Initialize( ) ||
                        !ClusterRun.Initialize( &IntermediateBuffer,
                                                _Drive,
                                                CurrentLcn,
                                                _ClusterFactor,
                                                CurrentRunLength ) ||
                        !ClusterRun.Read() ) {

                        DebugPrint( "Cannot read complete clusters.\n" );
                        return FALSE;
                    }

                    memcpy( CurrentData,
                            IntermediateBuffer.GetBuf(),
                            BytesToCopy );
                }

                RemainingRequest -= BytesToCopy;
                CurrentData += BytesToCopy;
                ByteOffset += BytesToCopy;
            }

            if( RemainingRequest > 0 ) {

                // OK, we have a partial trailing cluster.  Read
                // it through the intermediate buffer.

                BytesToCopy = RemainingRequest;

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This part of the read request falls into a hole
                    // in a sparse attribute, so we can just fill the
                    // appropriate part of the client's buffer with
                    // zeroes.

                    memset( CurrentData, 0, BytesToCopy );

                } else {

                    // Read this part of the request into an intermediate
                    // buffer (to avoid alignment problems) and then
                    // copy the data into the client's buffer.

                    if( !IntermediateBuffer.Initialize() ||
                        !ClusterRun.Initialize( &IntermediateBuffer,
                                                _Drive,
                                                CurrentLcn,
                                                _ClusterFactor,
                                                1 ) ||
                         !ClusterRun.Read() ) {
                         DebugPrint( "Cannot read partial clusters.\n" );

                        return FALSE;
                    }


                    // We've read the cluster in question; copy the partial
                    // trailing cluster of our request.

                    memcpy( CurrentData,
                            ClusterRun.GetBuf(),
                            (UINT) BytesToCopy );
                }
            }
        }

    } else {

        DebugAbort( "This attribute is neither resident nor nonresident.\n" );
        return FALSE;
    }

    *BytesRead = BytesToRead;
    return TRUE;
}


VOID
NTFS_ATTRIBUTE::PrimeCache (
    IN  BIG_INT ByteOffset,
    IN  ULONG   BytesToRead
    )
/*++

Routine Description:

    This routine reads the given range from the attribute.  If the drive
    hierarchy is cached then this will have the effect of priming the
    cache so that fewer reads are necessary.

Arguments:

    ByteOffset  - Supplies where to start the read.
    BytesToRead - Supplies the number of bytes to read.

Return Value:

    None.

--*/
{
    HMEM    hmem;
    PVOID   buf;
    ULONG   bytes_read;

    if (hmem.Initialize() &&
        (buf = hmem.Acquire(BytesToRead))) {

        Read(buf, ByteOffset, BytesToRead, &bytes_read);
    }
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE::Write (
   IN     PCVOID        Data,
   IN     BIG_INT       ByteOffset,
   IN     ULONG         BytesToWrite,
   OUT       PULONG        BytesWritten,
   IN OUT   PNTFS_BITMAP   Bitmap
   )

/*++

Routine Description:

    This method writes data to the attribute's value.

Arguments:

    Data            -- supplies the user's buffer containing data
                        to be written
    ByteOffset      -- supplies the byte offset within the attribute's
                        value at shich the write should commence.
    BytesToWrite    -- supplies the number of bytes to write.
    BytesWritten    -- receives the number of bytes written.
    Bitmap          -- supplies the volume bitmap.  This may be NULL.

Notes:

    If the user supplies a bitmap, Write will attempt to extend the
    attribute's allocation (if necessary) in order to complete the
    write.  If the user does not supply a bitmap, Write will fail if
    the write extends past the attribute value's allocated length.
    (It may or may not write some of the data.)

    Note that this method does not check the attribute's valid data
    length, but it does reset the valid data length if it writes
    past the valid data length.  Therefore, clients must use some
    caution to avoid introducing stretches of uninitialized data
    in the attribute (which would be a security leak).

    Note that if Write fails, the contents of the attribute on
    disk is undefined.

    Note also that Write is not supported for sparse files.

--*/
{
    NTFS_CLUSTER_RUN ClusterRun;
    HMEM IntermediateBuffer;
    BIG_INT TempBigInt;
    BIG_INT RunLength;
    BIG_INT OldValidDataLength;
    VCN CurrentVcn, RecentLcn;
    LCN CurrentLcn;
    PBYTE CurrentData;
    ULONG BytesToCopy, OffsetIntoCluster, CurrentRunLength;
    ULONG ClusterSize;
    ULONG RemainingRequest;
    ULONG BytesToZero;

    // First, make sure that the space allocated to the attribute
    // value is sufficient.

    if( CompareLT(QueryAllocatedLength(), ByteOffset + BytesToWrite) &&
        !Resize( ByteOffset + BytesToWrite, Bitmap ) ) {

        // This attribute does not have enough space allocated
        // to it to satisfy the write request, and we could not
        // extend the allocation, so the write fails.

        return FALSE;
    }

    // Now check the valid data length.  If the write begins
    // past the end of valid data, we have to fill the intervening
    // gap with zeroes.  Note that before we call Fill, we
    // must set the Valid Data Length appropriately, since Fill
    // just recurses back into Write.
    //
    if( CompareLT(_ValidDataLength, ByteOffset) ) {

        TempBigInt = ByteOffset - _ValidDataLength;

        if( TempBigInt.GetHighPart() != 0 ) {

            DebugPrint( "UNTFS: Writing discontiguous huge attribute.\n" );
            return FALSE;
        }

        BytesToZero = TempBigInt.GetLowPart();

        OldValidDataLength = _ValidDataLength;
        _ValidDataLength = ByteOffset;

        if( !Fill( OldValidDataLength, 0, BytesToZero ) ) {

            // Couldn't zero-fill the gap; restore Valid Data
            // Length and return failure.
            //
            _ValidDataLength = OldValidDataLength;
            return FALSE;
        }
    }


    if( _ResidentData != NULL ) {

        // Since the attribute value is resident, we can
        // just copy it.
        //
        DebugAssert( ByteOffset.GetHighPart() == 0 );

        memcpy( (PBYTE)_ResidentData + ByteOffset.GetLowPart(),
                Data,
                (UINT) BytesToWrite );

        SetStorageModified();
        ByteOffset += BytesToWrite;

    } else if ( _ExtentList != NULL ) {

        // Now we can actually start writing stuff!  First, we'll write
        // any partial leading cluster through an intermediate buffer.
        // Next, we write entire clusters directly from the user's buffer.
        // Finally, we write any partial trailing cluster.

        ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();

        RemainingRequest = BytesToWrite;

        // RecentLcn is used in case we need to grab extents on the
        // fly--if we have to allocate space to fill in holes in a
        // sparse attribute, using RecentLcn will increase the probability
        // that the space we grab is close to the rest of the attribute.

        RecentLcn = 0;

        if( RemainingRequest > 0 ) {

            CurrentData = (PBYTE) Data;

            OffsetIntoCluster = (ByteOffset % ClusterSize).GetLowPart();

            if( OffsetIntoCluster != 0 ) {

                // We have a partial leading cluster, so we'll write
                // it through the intermediate buffer.  Note that we
                // must read the cluster in, copy the part we intend
                // to write, and then write it back out.

                BytesToCopy = MIN( BytesToWrite,
                                   ClusterSize - OffsetIntoCluster );

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This portion of the request falls into a
                    // hole in a sparse attribute, so we have
                    // to allocate disk space for it and add
                    // this new extent to the extent list.  If
                    // we can't, the request fails.

                    if( Bitmap == NULL ||
                        !Bitmap->AllocateClusters( RecentLcn,
                                                   1,
                                                   &CurrentLcn) ||
                        !_ExtentList->AddExtent( CurrentVcn,
                                                 CurrentLcn,
                                                 1 ) ) {

                        return FALSE;
                    }
                }

                RecentLcn = CurrentLcn;

                if( !IntermediateBuffer.Initialize() ||
                    !ClusterRun.Initialize( &IntermediateBuffer,
                                            _Drive,
                                            CurrentLcn,
                                            _ClusterFactor,
                                            1 ) ||
                     !ClusterRun.Read() ) {

                    DebugPrint( "Could not read partial leading sector\n" );
                    return FALSE;
                }

                // We've read the cluster in question; copy the partial
                // leading cluster of our write request and write it
                // back out.

                memcpy( (PBYTE)ClusterRun.GetBuf() + OffsetIntoCluster,
                        CurrentData,
                        (UINT) BytesToCopy );

                if( !ClusterRun.Write() ) {

                    DebugPrint( "Could not write partial leading sector.\n" );
                    return FALSE;
                }

                RemainingRequest -= BytesToCopy;
                CurrentData += BytesToCopy;
                ByteOffset += BytesToCopy;

            }

            // Now transfer any complete clusters.  Because the
            // client's buffer may not be suitably aligned, we
            // have to cycle these through an intermediate buffer.

            while( RemainingRequest >= ClusterSize ) {

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( RunLength.GetHighPart() != 0 ||
                    RunLength.GetLowPart() >
                            MaximumClustersToTransfer ) {

                    CurrentRunLength = MaximumClustersToTransfer;

                } else {

                    CurrentRunLength = RunLength.GetLowPart();
                }

                if( CurrentRunLength * ClusterSize >
                    RemainingRequest ) {

                    CurrentRunLength = RemainingRequest/ClusterSize;
                }

                BytesToCopy = CurrentRunLength * ClusterSize;

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This portion of the request falls into a
                    // hole in a sparse attribute, so we have
                    // to allocate disk space for it and add
                    // this new extent to the extent list.  If
                    // we can't, the request fails.

                    if( Bitmap == NULL ||
                        !Bitmap->AllocateClusters( RecentLcn,
                                                   CurrentRunLength,
                                                   &CurrentLcn) ||
                        !_ExtentList->AddExtent( CurrentVcn,
                                                 CurrentLcn,
                                                 1 ) ) {

                        return FALSE;
                    }
                }

                RecentLcn = CurrentLcn;

                if( !IntermediateBuffer.Initialize() ||
                    !ClusterRun.Initialize( &IntermediateBuffer,
                                            _Drive,
                                            CurrentLcn,
                                            _ClusterFactor,
                                            CurrentRunLength ) ) {


                    DebugPrint( "Could not get memory to write user data.\n" );
                    return FALSE;
                }

                memcpy( IntermediateBuffer.GetBuf(),
                        CurrentData,
                        BytesToCopy );

                if( !ClusterRun.Write() ) {

                    DebugPrint( "Could not write complete clusters.\n" );
                    return FALSE;
                }

                RemainingRequest -= BytesToCopy;
                CurrentData += BytesToCopy;
                ByteOffset += BytesToCopy;
            }

            if( RemainingRequest > 0 ) {

                // OK, we have a partial trailing cluster.  Write
                // it through the intermediate buffer.  Again,
                // we have to read the cluster, copy the data,
                // and write the cluster back out.

                BytesToCopy = RemainingRequest;

                CurrentVcn = ByteOffset / ClusterSize;

                if( !_ExtentList->QueryLcnFromVcn( CurrentVcn,
                                                   &CurrentLcn,
                                                   &RunLength ) ) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_LCN_FROM_VCN_FAILED,
                                     "%x%I64x",
                                     QueryTypeCode(),
                                     CurrentVcn.GetLargeInteger());
                        }
                    }

                    DebugPrint( "Unable to Query Lcn from Vcn.\n" );

                    return FALSE;
                }

                if( CurrentLcn == LCN_NOT_PRESENT ) {

                    // This portion of the request falls into a
                    // hole in a sparse attribute, so we have
                    // to allocate disk space for it and add
                    // this new extent to the extent list.  If
                    // we can't, the request fails.

                    if( Bitmap == NULL ||
                        !Bitmap->AllocateClusters( RecentLcn,
                                                   1,
                                                   &CurrentLcn) ||
                        !_ExtentList->AddExtent( CurrentVcn,
                                                 CurrentLcn,
                                                 1 ) ) {

                        return FALSE;
                    }
                }

                RecentLcn = CurrentLcn;

                if( !IntermediateBuffer.Initialize() ||
                    !ClusterRun.Initialize( &IntermediateBuffer,
                                            _Drive,
                                            CurrentLcn,
                                            _ClusterFactor,
                                            1 ) ||
                    !ClusterRun.Read() ) {

                    DebugPrint( "Failure getting LCN or intermediat buffer.\n" );
                    return FALSE;
                }

                // We've read the cluster in question; copy the partial
                // leading cluster of our write request and write it
                // back out.

                memcpy( ClusterRun.GetBuf(),
                        CurrentData,
                        (UINT) BytesToCopy );

                if( !ClusterRun.Write() ) {

                    DebugPrint( "Could not write trailing partial cluster.\n" );
                    DebugPrintTrace(("Status: %x\n", _Drive->QueryLastNtStatus()));
                    DebugPrintTrace(("LCN: %x\n", CurrentLcn.GetLowPart()));
                    return FALSE;
                }

                // Update ByteOffset, since it may be used to check
                // _ValidDataLength below.

                ByteOffset += RemainingRequest;
            }
        }

    } else {

        DebugAbort( "This attribute is neither resident nor nonresident.\n" );
        return FALSE;
    }

    if( CompareLT(_ValidDataLength, ByteOffset) ) {

        _ValidDataLength = ByteOffset;
        SetStorageModified();
    }

    if( CompareLT(_ValueLength, ByteOffset) ) {

        _ValueLength = ByteOffset;
        SetStorageModified();
    }

    *BytesWritten = BytesToWrite;
    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE::Fill (
    IN BIG_INT  Offset,
    IN CHAR     FillCharacter
    )
/*++

Routine Description:

    This method fills the attribute with the specified character
    from the given offset until the end of the attribute.

Arguments:

    Offset          --  Starting offset to begin the fill.
    FillCharacter   --  Supplies the character that will be written
                        to every byte of the attribute value.

Return Value:

    TRUE upon successful completion.

Notes:

    This method will fail if it is used on an attribute which has a size
    greater than MAXULONG.

--*/
{
    BIG_INT TempBigInt;

    if( Offset >= QueryValueLength() )  {

        // Nothing to do.
        //
        return TRUE;
    }

    // Fill to the end of the attribute--compute the number of
    // bytes in the attribute starting at Offset.  Make sure
    // that the amount to fill fits in a ULONG.
    //
    TempBigInt = QueryValueLength() - Offset;

    if( TempBigInt.GetHighPart() != 0 ) {

        DebugPrint( "UNTFS: Trying to fill a very large attribute.\n" );
        return FALSE;
    }

    return( Fill( Offset, FillCharacter, TempBigInt.GetLowPart() ) );
}


BOOLEAN
NTFS_ATTRIBUTE::Fill (
    IN BIG_INT  Offset,
    IN CHAR     FillCharacter,
    IN ULONG    NumberOfBytes
    )
/*++

Routine Description:

    This method fills the attribute with the specified character
    from the given offset for the specified number of bytes.

Arguments:

    Offset          --  Starting offset to begin the fill.
    FillCharacter   --  Supplies the character that will be written
                        to every byte of the attribute value.
    NumberOfBytes   --  Number of bytes to fill.

Return Value:

    TRUE upon successful completion.

Notes:

    This method will fail if it is used on an attribute which has a size
    greater than MAXULONG.

--*/
{
    PVOID FillBuffer;
    ULONG BytesRemaining, FillBufferSize, BytesToWrite, BytesWritten;
    BOOLEAN Result;

    CONST ULONG MaximumBufferSize = 0x10000;

    if( Offset > QueryValueLength() ) {

        DebugPrint( "UNTFS: Filling an attribute starting past end.\n" );
        return TRUE;
    }

    // Get a buffer to fill with the fill character.  Start out by
    // requesting the full amount; if we can't get it, keep asking
    // for smaller amounts.
    //
    BytesRemaining = NumberOfBytes;
    FillBufferSize = min( BytesRemaining, MaximumBufferSize );

    while( FillBufferSize > 0 &&
           (FillBuffer = MALLOC( FillBufferSize )) == NULL ) {

        FillBufferSize /= 2;
    }

    // If we couldn't get a buffer, fail.
    //
    if( FillBufferSize == 0 || FillBuffer == NULL ) {

        return FALSE;
    }

    // Fill the buffer with the fill character.
    //
    memset( FillBuffer,
            FillCharacter,
            FillBufferSize );

    // Chug through the attribute, writing each chunk until we hit
    // a failure or reach the end.
    //
    Result = TRUE;

    while( BytesRemaining > 0 && Result ) {

        // Write the lesser of our buffer size or the remainder
        // of the attribute.  Note that we pass NULL for the
        // bitmap parameter to Write, since this write should
        // not affect the allocated length of the buffer.
        //
        BytesToWrite = min( BytesRemaining, FillBufferSize );

        if( !Write( FillBuffer,
                    Offset,
                    BytesToWrite,
                    &BytesWritten,
                    NULL ) ||
            BytesWritten != BytesToWrite ) {

            DebugPrintTrace(("Write failed in NTFS_ATTRIBUTE::Fill with status %x\n",
                             GetDrive()->QueryLastNtStatus()));
            Result = FALSE;
        }

        Offset += BytesToWrite;
        BytesRemaining -= BytesToWrite;
    }

    FREE( FillBuffer );
    return Result;
}



BOOLEAN
NTFS_ATTRIBUTE::RecoverAttribute(
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN OUT PNUMBER_SET  BadClusters,
    OUT    PBIG_INT     BytesRecovered
    )
/*++

Routine Description:

    This method recovers an attribute.  Recovery consists of reading each
    cluster in the attribute value, and replacing it with a cluster full
    of zeroes if it is unreadable.

Arguments:

    VolumeBitmap    --  supplies the volume bitmap.
    BadClusters     --  receives the bad clusters identified by this method.
    BytesRecovered  --  receives the number of bytes recovered (not
                        mapped out).  This parameter may be NULL, in
                        which case this information is not returned.
                        Note that if the method returns FALSE, this
                        parameter's contents will be undefined.

Notes:

    This method should not be called for any system-defined attribute
    other than $DATA.

    Recover for resident attributes is trivial.

--*/
{
    HMEM MultiClusterMem, SingleClusterMem;
    NTFS_CLUSTER_RUN MultiClusterRun, SingleClusterRun;
    VCN StartingVcn, ClustersAttempted, BadVcn;
    LCN StartingLcn;
    BIG_INT RunLength, dVcn;
    ULONG CurrentRunLength;
    ULONG ExtentNumber, i, j;
    BOOLEAN FoundBad;
    LCN NewLcn;
    BIG_INT OldOffset;
    ULONG ClusterSize;
    ULONG MaxClusters, Take;
    BOOLEAN AllHoles = TRUE;
    VCN     LastStartingVcn;
    BIG_INT LastRunLength;

    // Compressed attributes receive special handling.
    //
    if (IsCompressed() && !IsResident()) {

        return RecoverCompressedAttribute( VolumeBitmap, BadClusters,
                                           BytesRecovered );
    }

    if( _ExtentList == NULL ) {

        // The attribute is resident--Recover is a no-op.
        //
        if( BytesRecovered != NULL ) {

            *BytesRecovered = QueryValueLength();
        }

        return TRUE;
    }

    ClusterSize = QueryClusterFactor() * GetDrive()->QuerySectorSize();
    MaxClusters = 0x10000/ClusterSize;

    if( !MultiClusterMem.Initialize() ||
        !MultiClusterRun.Initialize( &MultiClusterMem,
                                     GetDrive(),
                                     0,
                                     QueryClusterFactor(),
                                     MaxClusters ) ||
        !SingleClusterMem.Initialize() ||
        !SingleClusterRun.Initialize( &SingleClusterMem,
                                      GetDrive(),
                                      0,
                                      QueryClusterFactor(),
                                      1 ) ) {
        // insufficient memory.

        return FALSE;
    }


    // Initialize the counters.
    //
    ExtentNumber = 0;
    ClustersAttempted = 0;

    if( BytesRecovered != NULL ) {

        *BytesRecovered = 0;
    }

    while( _ExtentList->QueryExtent( ExtentNumber,
                                     &StartingVcn,
                                     &StartingLcn,
                                     &RunLength ) ) {

        if( RunLength.GetHighPart() != 0 ) {

            DebugPrint( "NTFS_ATTRIBUTE::Recover--RunLength > Max ULONG )\n" );
            return FALSE;
        }

        if (StartingLcn == LCN_NOT_PRESENT) {
            ExtentNumber += 1;
            continue;
        }

        AllHoles = FALSE;
        LastStartingVcn = StartingVcn;
        LastRunLength = RunLength;

        // Read the extent in chunks until we get a bad sector
        // (read failure) or run out.
        //
        CurrentRunLength = RunLength.GetLowPart();

        FoundBad = FALSE;

        Take = MaxClusters;
        for( i = 0; i < CurrentRunLength && !FoundBad; i += Take ) {

            Take = min(MaxClusters, CurrentRunLength - i);

            MultiClusterRun.Initialize( &MultiClusterMem,
                                        GetDrive(),
                                        StartingLcn + i,
                                        QueryClusterFactor(),
                                        Take );

            if( MultiClusterRun.Read() ) {

                // This whole run of clusters is good.  If this
                // range of VCNs has not already been attempted,
                // update the count of bytes recovered.
                //
                if( BytesRecovered &&
                    StartingVcn + i + Take > ClustersAttempted ) {

                    dVcn = StartingVcn + i + Take - ClustersAttempted;
                    OldOffset = ClustersAttempted * ClusterSize;

                    ClustersAttempted += dVcn;

                    if( OldOffset + dVcn * ClusterSize < QueryValueLength() ) {

                        *BytesRecovered += dVcn * ClusterSize;

                    } else if( OldOffset < QueryValueLength() ) {

                        *BytesRecovered += QueryValueLength() - OldOffset;
                    }
                }

            } else {

                // Check each of the clusters individually.
                //
                for( j = 0; j < Take && !FoundBad; j++ ) {

                    SingleClusterRun.Relocate( StartingLcn + i + j );

                    if( SingleClusterRun.Read() ) {

                        // This cluster is good.  Update the total
                        // of bytes recovered.
                        //
                        if( BytesRecovered &&
                            StartingVcn + i + j + 1 > ClustersAttempted ) {

                            OldOffset = ClustersAttempted * ClusterSize;
                            ClustersAttempted += 1;

                            if( OldOffset+ClusterSize < QueryValueLength() ) {

                                *BytesRecovered += ClusterSize;

                            } else if( OldOffset < QueryValueLength() ) {

                                *BytesRecovered += QueryValueLength() -
                                                                OldOffset;
                            }
                        }

                    } else {

                        // Found a bad cluster.  Allocate a replacement
                        // for it, fill the replacement with zeroes, and
                        // splinter the extent.  Note that we don't check
                        // the return value of the write; instead, on the
                        // next iteration, we'll check this VCN again.
                        //
                        FoundBad = TRUE;
                        BadVcn = StartingVcn + i + j;

                        if( BytesRecovered &&
                            ClustersAttempted < BadVcn + 1 ) {

                            ClustersAttempted = BadVcn + 1;
                        }

                        if( !VolumeBitmap->AllocateClusters( StartingLcn,
                                                             1,
                                                             &NewLcn) ) {

                            return FALSE;
                        }

                        SingleClusterRun.Relocate( NewLcn );

                        memset( SingleClusterMem.GetBuf(),
                                '\0',
                                GetDrive()->QuerySectorSize() *
                                                QueryClusterFactor() );

                        SingleClusterRun.Write();

                        _ExtentList->DeleteExtent( ExtentNumber );

                        if( ( i + j > 0 &&
                              !AddExtent( StartingVcn,
                                          StartingLcn,
                                          i + j ) ) ||
                            !AddExtent( BadVcn, NewLcn, 1 ) ||
                            ( i + j + 1 < CurrentRunLength &&
                              !AddExtent( StartingVcn + i + j + 1,
                                          StartingLcn + i + j + 1,
                                          CurrentRunLength - (i + j + 1) ) ) ) {

                            DebugPrint( "RECOVER: couldn't splinter extent." );
                            return FALSE;
                        }

                        // Add the bad cluster to the list of identified
                        // bad clusters, and remember that the attribute's
                        // storage has been modified.
                        //
                        if( !BadClusters->Add( StartingLcn + i + j ) ) {

                            return FALSE;
                        }

                        SetStorageModified();
                    }
                }
            }
        }

        // If we processed this entire extent without finding any bad
        // sectors, update the count of bytes recovered and go on to
        // the next one.  Otherwise, try this one again.
        //
        if( !FoundBad ) {

            ExtentNumber += 1;
        }
    }

    if (BytesRecovered) {
        //
        // fix up BytesRecovered for sparse looking (including encrypted) file
        //
        if (AllHoles) {
            DebugAssert(*BytesRecovered == 0);
            *BytesRecovered = QueryValueLength();
        } else {
            OldOffset = (LastStartingVcn + LastRunLength)*ClusterSize;
            if (OldOffset < QueryValueLength()) {
                //
                // Hole at the end of the extent list
                //
                *BytesRecovered += (QueryValueLength() - OldOffset);
            }
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::MarkAsAllocated(
    IN OUT  PNTFS_BITMAP    VolumeBitmap
    ) CONST
/*++

Routine Description:

    This routine allocated the space taken by this attribute in the
    given Volume Bitmap.  If any of the space taken by this attribute is
    beyond the range of the given bitmap then this routine will fail
    without allocating any new space in the bitmap.

    This routine allocates the space in the bitmap regardless of whether
    or not this space is already allocated in the bitmap.

Arguments:

    VolumeBitmap    - Supplies the bitmap which to mark the allocation.

Return Value:

    FALSE   - The space requested is beyond the natural range of the
                given bitmap.
    TRUE    - Success.

--*/
{
    ULONG   num_extents;
    ULONG   i;
    VCN     next_vcn;
    LCN     current_lcn;
    BIG_INT run_length;


    DebugAssert(VolumeBitmap);


    // If the attribute is resident then we have already succeeded.

    if (!_ExtentList) {
        return TRUE;
    }


    num_extents = _ExtentList->QueryNumberOfExtents();

    for (i = 0; i < num_extents; i++) {

        if (!_ExtentList->QueryExtent(i, &next_vcn, &current_lcn,
                                      &run_length)) {

            DebugAbort("Could not query extent");
            return FALSE;
        }
        if (LCN_NOT_PRESENT == current_lcn) {
            continue;
        }

        if (!VolumeBitmap->IsInRange(current_lcn, run_length)) {
            return FALSE;
        }
    }

    for (i = 0; i < num_extents; i++) {

        if (!_ExtentList->QueryExtent(i, &next_vcn, &current_lcn,
                                      &run_length)) {

            DebugAbort("Could not query extent");
            return FALSE;
        }
        if (LCN_NOT_PRESENT == current_lcn) {
            return FALSE;
        }

        VolumeBitmap->SetAllocated(current_lcn, run_length);
    }

    return TRUE;
}


BOOLEAN
AccountForBadClusters(
    IN      LCN                 Lcn,
    IN      BIG_INT             RunLength,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      ULONG               ClusterFactor,
    OUT     PBOOLEAN            SomeWereBad,
    IN OUT  PNUMBER_SET         BadClusters
    )
/*++

Routine Description:

    This routine read through the given run of clusters.  The clusters
    that are bad are added to the list of BadClusters and marked
    as allocated in the volume bitmap.  The clusters which are good are
    marked free in the volume bitmap.

Arguments:

    Lcn                 - Supplies the first logical cluster number.
    RunLength           - Supplies the length of the run.
    VolumeBitmap        - Supplies the volume bitmap.
    Drive               - Supplies the drive.
    ClusterFactor       - Supplies the cluster factor.
    SomeWereBad         - Returns whether or not any clusters were bad.
    BadClusters   - Supplies the list of bad volume clusters.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM                hmem;
    NTFS_CLUSTER_RUN    clusrun;
    BIG_INT             i;
    LCN                 sup;

    if (!hmem.Initialize()) {
        return FALSE;
    }

    *SomeWereBad = FALSE;

    sup = Lcn + RunLength;
    for (i = Lcn; i < sup; i += 1) {

        if (!clusrun.Initialize(&hmem, Drive, i, ClusterFactor, 1)) {
            return FALSE;
        }

        if (clusrun.Read()) {

            VolumeBitmap->SetFree(i, 1);

        } else {

            VolumeBitmap->SetAllocated(i, 1);

            *SomeWereBad = TRUE;

            if (!BadClusters->Add(i)) {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::Hotfix(
    IN      VCN                 Vcn,
    IN      BIG_INT             RunLength,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNUMBER_SET         BadClusters,
    IN      BOOLEAN             Contiguous
    )
/*++

Routine Description:

    This routine replaces the cluster run specified by 'Vcn' and
    'RunLength' with new readable clusters allocated from
    'VolumeBitmap'.

    If 'Contiguous' is TRUE then the readable clusters will be allocated
    from the bitmap in one contiguous run.

    If 'BadClusters' is specified then the logical cluster numbers
    of all of the bad clusters detected by this routine will be added
    to this list.  This does not include the run to hotfix.

Arguments:

    Vcn             - Supplies the first vcn of the run to hotfix.
    RunLength       - Supplies the number of clusters to hotfix.
    VolumeBitmap    - Supplies a valid volume bitmap from which to
                        allocate new clusters.
    BadClusters     - Supplies a list to which to add the bad clusters
                        of the volume.
    Contiguous      - Supplies whether or not the new clusters must be
                        contiguous.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT             alloc_size;
    BIG_INT             total_so_far;
    LCN                 first_lcn;
    BOOLEAN             some_were_bad;
    NTFS_EXTENT_LIST    new_stuff;
    NTFS_EXTENT_LIST    backup_copy;
    VCN                 i;
    VCN                 vcn;
    LCN                 lcn;
    BIG_INT             run_length;
    ULONG               j;
    ULONG               num_extents;


    DebugAssert(RunLength != 0);

    if (!_ExtentList) {
        return FALSE;
    }

    if (!new_stuff.Initialize(0, 0) ||
        !backup_copy.Initialize(_ExtentList)) {

        return FALSE;
    }

    // Allocate the space necessary on the bitmap making sure that
    // the sectors are good.

    alloc_size = RunLength;
    total_so_far = 0;

    while (total_so_far < RunLength) {

        if (VolumeBitmap->AllocateClusters(0, alloc_size, &first_lcn)) {

            if (!AccountForBadClusters(first_lcn, alloc_size,
                                       VolumeBitmap, GetDrive(),
                                       QueryClusterFactor(),
                                       &some_were_bad,
                                       BadClusters)) {

                return FALSE;
            }

            if (some_were_bad) {
                continue;
            }

            VolumeBitmap->SetAllocated(first_lcn, alloc_size);

            if (!new_stuff.AddExtent(Vcn + total_so_far,
                                     first_lcn,
                                     alloc_size)) {

                return FALSE;
            }

            total_so_far += alloc_size;

            alloc_size = min(alloc_size, RunLength - total_so_far);

        } else {

            if (Contiguous || alloc_size == 1) {
                return FALSE;
            }

            alloc_size = alloc_size/2;
        }
    }


    // Delete the given range of VCN's from the extent list.

    if (!_ExtentList->DeleteRange(Vcn, RunLength)) {
        return FALSE;
    }


    // Now insert the extents into the extent list.

    num_extents = new_stuff.QueryNumberOfExtents();

    for (j = 0; j < num_extents; j++) {

        if (!new_stuff.QueryExtent(j, &vcn, &lcn, &run_length) ||
            !_ExtentList->AddExtent(vcn, lcn, run_length)) {

            _ExtentList->Initialize(&backup_copy);
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE::ReplaceVcns(
    IN  VCN     StartingVcn,
    IN  LCN     NewLcn,
    IN  BIG_INT NumberOfClusters
    )
/*++

Routine Description:

    This routine replaces the VCNs specified by 'StartingVcn' and
    'NumberOfClusters' with the contiguous run that starts at
    'NewLcn'.

Arguments:

    StartingVcn         - Supplies the starting vcn to replace.
    NewLcn              - Supplies a run of 'NumberOfClusters' clusters.
    NumberOfClusters    - Supplies the number of clusters to replace.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!_ExtentList->DeleteRange(StartingVcn, NumberOfClusters)) {
        return FALSE;
    }

    if (!_ExtentList->AddExtent(StartingVcn, NewLcn, NumberOfClusters)) {
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
operator==(
    IN  RCNTFS_ATTRIBUTE    Left,
    IN  RCNTFS_ATTRIBUTE    Right
    )
/*++

Routine Description:

    This routine computes whether or not the two given attributes are
    equal.

Arguments:

    Left    - Supplies the left argument.
    Right   - Supplies the right argument.

Return Value:

    FALSE   - The given attributes are not equal.
    TRUE    - The given attributes are equal.

--*/
{
    VCN                 left_vcn, right_vcn;
    LCN                 left_lcn, right_lcn;
    BIG_INT             left_length, right_length;
    ULONG               num_extents;
    PNTFS_EXTENT_LIST   left_list;
    PNTFS_EXTENT_LIST   right_list;
    ULONG               i;

    if (Left._ClusterFactor != Right._ClusterFactor ||
        Left._Type != Right._Type ||
        Left._Name.Strcmp(&Right._Name) ||
        Left._Flags != Right._Flags ||
        Left._FormCode != Right._FormCode ||
        Left._ValueLength != Right._ValueLength ||
        Left._ValidDataLength != Right._ValidDataLength ||
        Left._ResidentFlags != Right._ResidentFlags) {

        return FALSE;
    }

    if (Left._ResidentData) {

        if (!Right._ResidentData) {
            return FALSE;
        }

        return !memcmp(Left._ResidentData,
                       Right._ResidentData,
                       (UINT) Left._ValueLength.GetLowPart());
    }

    DebugAssert(Left._ExtentList);
    DebugAssert(Right._ExtentList);

    left_list = Left._ExtentList;
    right_list = Right._ExtentList;

    if (left_list->QueryNumberOfExtents() !=
            right_list->QueryNumberOfExtents() ||
        left_list->QueryLowestVcn() != right_list->QueryLowestVcn() ||
        left_list->QueryNextVcn() != right_list->QueryNextVcn()) {

        return FALSE;
    }

    num_extents = left_list->QueryNumberOfExtents();

    for (i = 0; i < num_extents; i += 1) {

        if (!left_list->QueryExtent(i, &left_vcn, &left_lcn, &left_length) ||
            !right_list->QueryExtent(i, &right_vcn, &right_lcn, &right_length) ||
            left_vcn != right_vcn ||
            left_lcn != right_lcn ||
            left_length != right_length) {

            return FALSE;
        }
    }

    return TRUE;
}


BIG_INT
NTFS_ATTRIBUTE::QueryClustersAllocated(
    ) CONST
/*++

Routine Description:

    This routine computes the number of clusters allocated for this
    attribute.

Arguments:

    None.

Return Value:

    The number of clusters allocated by this attribute.

--*/
{
    BIG_INT r;

    if (_ExtentList) {
        r = _ExtentList->QueryClustersAllocated();
    } else {
        r = 0;
    }

    return r;
}



BOOLEAN
NTFS_ATTRIBUTE::InsertMftDataIntoFile (
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   BaseFileRecordSegment,
    IN OUT  PNTFS_BITMAP                Bitmap OPTIONAL,
    IN      BOOLEAN                     BeConservative
    )
/*++

Routine Description:

    This method inserts the MFT Data attribute into a File Record
    Segment (presumably FRS 0).  It is a private worker method for
    InsertIntoFile.

Arguments:

    FileRecordSegment   --  Supplies the File Record Segment into
                            which the attribute will jam itself.
    Bitmap              --  Supplies the volume bitmap.
    BeConservative      --  Supplies a flag which indicates, if TRUE,
                            that the attribute should try to leave free
                            space in the File Record Segments (to leave
                            room for changes due to hotfixing).  If this
                            flag is FALSE, the attribute will make each
                            attribute record as large as it can.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE_RECORD AttributeRecord;
    PVOID AttributeRecordData;
    BOOLEAN Result;
    ULONG MaxSize;
    ULONG MaxExtentsSize, CurrentMaxExtentsSize;
    NTFS_EXTENT_LIST source;
    NTFS_EXTENT_LIST result;
    NTFS_EXTENT_LIST remainder;
    BOOLEAN FirstChunkInserted = FALSE;
    BOOLEAN Completed = FALSE;

    // Allocate a buffer to hold attribute records.  If we're being
    // conservative, reduce the size of the maximum record by 1/8.
    //
    MaxSize = BaseFileRecordSegment->QueryMaximumAttributeRecordSize();

    if( BeConservative ) {

        // Reduce the maximum record size by 1/8 of the FRS size,
        // to allow for hotfixing and other changes.
        //
        MaxSize -= BaseFileRecordSegment->QuerySize()/8;
    }

    if( (AttributeRecordData = MALLOC( (UINT) MaxSize )) == NULL ) {

        return FALSE;
    }


    // The MFT data attribute must be resident.
    //
    if( _ResidentData != NULL ) {

        if( !AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize ) ) {

            FREE( AttributeRecordData );
            return FALSE;
        }

        // The attribute value is resident.  Package up a resident
        // attribute record.

        Result = AttributeRecord.
                    CreateResidentRecord( _ResidentData,
                                          _ValueLength.GetLowPart(),
                                          _Type,
                                          &_Name,
                                          _Flags,
                                          _ResidentFlags );

        //
        // Check to see if there is enough space to Create a resident record
        //

        if (Result) {
            Result = BaseFileRecordSegment->
                            InsertAttributeRecord( &AttributeRecord );

            FREE( AttributeRecordData );
            return Result;
        } else {
            // Not enough space to do so, make attribute record non-resident
            if (IsIndexed() || !Bitmap || !MakeNonresident(Bitmap)) {
               FREE( AttributeRecordData );
               return FALSE;
            }
        }
    }

    // Compute the maximum number of bytes in an extent list.
    //
    MaxExtentsSize = MaxSize - SIZE_OF_NONRESIDENT_HEADER;
    if (_Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                  ATTRIBUTE_FLAG_SPARSE)) {
        MaxExtentsSize -= sizeof(BIG_INT);
    }
    MaxExtentsSize -= QuadAlign(_Name.QueryChCount());

    // The first chunk of the MFT's DATA attribute gets
    // special treatment, since it has to fit into the
    // Base FRS.  If our first attempt doesn't fit, we
    // keep whittling it down until it does or until we
    // run out of possibilities.
    //
    CurrentMaxExtentsSize = MaxExtentsSize;

    Result = AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize );

    while( Result && !FirstChunkInserted ) {

        // Partition the extent list.
        //
        if( PartitionExtentList( _ExtentList,
                                 CurrentMaxExtentsSize,
                                 &result,
                                 &remainder ) ) {

            if( !AttributeRecord.
                    CreateNonresidentRecord( &result,
                                             QueryAllocatedLength(),
                                             _ValueLength,
                                             _ValidDataLength,
                                             _Type,
                                             &_Name,
                                             _Flags,
                                             _CompressionUnit ) ||
                !BaseFileRecordSegment->
                        InsertAttributeRecord( &AttributeRecord ) ) {

                // This partition didn't work.  Try a smaller one.
                //
                CurrentMaxExtentsSize /= 2;

                if( CurrentMaxExtentsSize == 0 ) {

                    Result = FALSE;
                }

            } else {

                // Successfully inserted first chunk.  Set up
                // source to continue inserting the remaining
                // chunks.
                //
                FirstChunkInserted = TRUE;

                if (remainder.IsEmpty()) {

                    Completed = TRUE;

                } else {

                    Result = source.Initialize(&remainder);
                }
            }

        } else {

            Result = FALSE;
        }
    }



    while (Result && !Completed) {

        // Initialize attribute record.

        Result = AttributeRecord.Initialize( GetDrive(), AttributeRecordData, MaxSize );


        // Partition extent list into two pieces, the first of which
        // can be made into an attribute record.

        Result = Result &&
                 PartitionExtentList(&source,
                                     MaxExtentsSize,
                                     &result,
                                     &remainder);


        // Create the attribute record.

        Result = Result &&
                 AttributeRecord.
                    CreateNonresidentRecord( &result,
                                             QueryAllocatedLength(),
                                             _ValueLength,
                                             _ValidDataLength,
                                             _Type,
                                             &_Name,
                                             _Flags,
                                             _CompressionUnit );


        // If we were able to package it up, then give the attribute
        // record to the File Record Segment.

        Result = Result &&
                 BaseFileRecordSegment->
                            InsertAttributeRecord( &AttributeRecord );


        // If all of the extents fit in the last record then we are done.

        if (remainder.IsEmpty()) {

            Completed = TRUE;

        } else {

            Result = Result &&
                    source.Initialize(&remainder);
        }
    }


    ResetStorageModified();
    FREE( AttributeRecordData );
    return Result;
}


BOOLEAN
NTFS_ATTRIBUTE::RecoverCompressedAttribute(
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN OUT PNUMBER_SET  BadClusters,
    OUT    PBIG_INT     BytesRecovered
    )
/*++

Routine Description:

    This method is a private helper function for RecoverAttribute;
    it is invoked if the attribute is compressed.  Recovery consists
    of reading each cluster in the attribute value, and replacing it
    with a cluster full of zeroes if it is unreadable.

Arguments:

    VolumeBitmap    --  supplies the volume bitmap.
    BadClusters     --  receives the bad clusters identified by this method.
    BytesRecovered  --  receives the number of bytes recovered (not
                        mapped out).  This parameter may be NULL, in
                        which case this information is not returned.
                        Note that if the method returns FALSE, this
                        parameter's contents will be undefined.

Return Value:

    TRUE upon successful completion.

--*/
{
    HMEM             ClusterMem, OneClusterMem;
    NTFS_CLUSTER_RUN ClusterRun, OneCluster;
    VCN              CurrentVcn, Vcn;
    LCN              Lcn, lcnStart, lcnEnd;
    BIG_INT          RunLength, j;
    ULONG            i;
    ULONG            BytesPerCluster, ClustersPerCompressionUnit, ClustersRemaining;
    ULONG            CompressedClusters, ThisRun, UncompressedSize, Holes;
    BOOLEAN          DiscardThisUnit;
    PUCHAR           CompressedBuffer, UncompressedBuffer;
    NTSTATUS         Status;


    if (IsResident() || !IsCompressed()) {

        DebugPrintTrace(( "UNTFS: RecoverCompressedAttribute called for non-compressed attribute.\n" ));
        return FALSE;
    }

    if( !OneClusterMem.Initialize() ||
        !OneCluster.Initialize( &OneClusterMem,
                                GetDrive(),
                                0,
                                QueryClusterFactor(),
                                1 ) ) {

        return FALSE;
    }

    if( BytesRecovered ) {

        *BytesRecovered = 0;
    }

    ClustersPerCompressionUnit = 1 << QueryCompressionUnit();
    BytesPerCluster = QueryClusterFactor() * GetDrive()->QuerySectorSize();

    CompressedBuffer = (PUCHAR)MALLOC( ClustersPerCompressionUnit * BytesPerCluster );
    UncompressedBuffer = (PUCHAR)MALLOC( ClustersPerCompressionUnit * BytesPerCluster );

    if( CompressedBuffer == NULL || UncompressedBuffer == NULL ) {

        CompressedBuffer   ? FREE( CompressedBuffer )   : 0;
        UncompressedBuffer ? FREE( UncompressedBuffer ) : 0;
        return FALSE;
    }

    ClustersRemaining = QueryAllocatedLength().GetLowPart()/BytesPerCluster;
    CurrentVcn = 0;

    while( ClustersRemaining ) {

        DiscardThisUnit = FALSE;

        if( ClustersRemaining < ClustersPerCompressionUnit ) {

            ClustersPerCompressionUnit = ClustersRemaining;
        }

        CompressedClusters = 0;
        Holes = 0;

        while( CompressedClusters + Holes < ClustersPerCompressionUnit ) {

            if( !QueryLcnFromVcn( CurrentVcn + CompressedClusters + Holes,
                                  &Lcn,
                                  &RunLength ) ) {

                // No more clusters in this compression unit.
                // Check to make sure that the gap covers at
                // least the rest of the compression unit.
                //

                if( CompressedClusters + Holes < ClustersPerCompressionUnit ) {

                    DebugPrintTrace(( "UNTFS: malformed compression unit at VCN 0x%I64x\n",
                                      CurrentVcn.GetLargeInteger() ));
                    DiscardThisUnit = TRUE;
                }
                break;
            }

            if( Lcn == LCN_NOT_PRESENT ) {

                Holes += RunLength.GetLowPart();
                continue;
            }

            if( CompressedClusters + RunLength.GetLowPart() >
                    ClustersPerCompressionUnit ) {

                ThisRun = ClustersPerCompressionUnit - CompressedClusters;

            } else {

                ThisRun = RunLength.GetLowPart();
            }

            if( !ClusterMem.Initialize() ||
                !ClusterRun.Initialize( &ClusterMem,
                                        GetDrive(),
                                        Lcn,
                                        QueryClusterFactor(),
                                        ThisRun ) ) {

                FREE( CompressedBuffer );
                FREE( UncompressedBuffer );
                return FALSE;
            }

            if( !ClusterRun.Read() ) {

                // There's a bad sector in here.  Read the clusters
                // one at a time to see which ones are bad.
                //
                for( i = 0; i < ThisRun; i++ ) {

                    OneCluster.Relocate( Lcn + i );

                    if( !OneCluster.Read() ) {

                        // This one's bad--add it to the bad block list.
                        //
                        BadClusters->Add( Lcn + i );
                    }
                }

                DebugPrintTrace(( "UNTFS: unreadable compression unit at VCN 0x%I64x\n",
                                  (CurrentVcn + CompressedClusters + Holes).GetLargeInteger() ));
                DiscardThisUnit = TRUE;

            } else {

                // Copy this run into the compressed buffer.
                //
                memcpy( CompressedBuffer + CompressedClusters * BytesPerCluster,
                        ClusterRun.GetBuf(),
                        ThisRun * BytesPerCluster );

            }

            CompressedClusters += ThisRun;
        }

        if( !DiscardThisUnit &&
            CompareLT(CurrentVcn * BytesPerCluster, QueryValidDataLength()) &&
            CompressedClusters != 0 &&
            CompressedClusters != ClustersPerCompressionUnit ) {

            // The clusters can all be read--see if they can be
            // decompressed.
            //
            Status = RtlDecompressBuffer( COMPRESSION_FORMAT_LZNT1,
                                          UncompressedBuffer,
                                          ClustersPerCompressionUnit * BytesPerCluster,
                                          CompressedBuffer,
                                          CompressedClusters * BytesPerCluster,
                                          &UncompressedSize );

            // If the RTL compression routines are not implemented,
            // assume that the compressed data is just fine.
            //
            if( Status != STATUS_NOT_IMPLEMENTED &&
                Status != STATUS_NOT_SUPPORTED   &&
                !NT_SUCCESS( Status ) ) {

                // Can't decompress it.
                //
                DebugPrintTrace(( "UNTFS: RtlDecompressBuffer failed--status 0x%x\n", Status ));
                DiscardThisUnit = TRUE;
            }
        }

        if( DiscardThisUnit ) {

            // Replace this compression unit with a gap.
            // Walk through all the extents, clipping any
            // extent that intersects the discarded unit.
            //
            SetStorageModified();

            i = 0;

            while( _ExtentList->QueryExtent( i,
                                             &Vcn,
                                             &Lcn,
                                             &RunLength ) ) {

                if( Lcn == LCN_NOT_PRESENT ) {

                    i++;
                    continue;
                }

                if( Vcn >= CurrentVcn + ClustersPerCompressionUnit ) {

                    // We're done.
                    //
                    break;
                }

                if( Vcn + RunLength <= CurrentVcn ) {

                    // This run does not overlap the discarded
                    // segment.  Try the next one.
                    //
                    i++;
                    continue;
                }

                _ExtentList->DeleteExtent( i );

                if( Vcn < CurrentVcn) {

                    if (!_ExtentList->AddExtent( Vcn,
                                                 Lcn,
                                                 CurrentVcn - Vcn ) ) {

                        FREE( CompressedBuffer );
                        FREE( UncompressedBuffer );
                        return FALSE;
                    }
                    lcnStart = Lcn + (CurrentVcn - Vcn);
                } else
                    lcnStart = Lcn;

                if( Vcn + RunLength > CurrentVcn + ClustersPerCompressionUnit) {

                    lcnEnd = Lcn + (CurrentVcn - Vcn) + ClustersPerCompressionUnit;
                    if (!_ExtentList->AddExtent( CurrentVcn + ClustersPerCompressionUnit,
                                                 lcnEnd,
                                                 RunLength - (CurrentVcn - Vcn) -
                                                 ClustersPerCompressionUnit ) ) {

                        FREE( CompressedBuffer );
                        FREE( UncompressedBuffer );
                        return FALSE;
                    }
                } else
                    lcnEnd = Lcn + RunLength;

                // Free stuff in the bitmap.
                //
                for( j = lcnStart; j < lcnEnd; j = j + 1) {

                    if( !BadClusters->DoesIntersectSet( j, 1 ) ) {

                        // this cluster was not added to the bad clusters,
                        // it has become free.
                        //
                        VolumeBitmap->SetFree( j, 1 );
                    }
                }

                // Don't advance to the next extent, since we may have
                // deleted this entire extent.
            }

        } else {

            if( BytesRecovered &&
                CurrentVcn * BytesPerCluster < QueryValueLength() ) {

                if( CurrentVcn * BytesPerCluster +
                        ClustersPerCompressionUnit * BytesPerCluster >
                    QueryValueLength() ) {

                    *BytesRecovered += QueryValueLength() - CurrentVcn * BytesPerCluster;

                } else {

                    *BytesRecovered += ClustersPerCompressionUnit * BytesPerCluster;
                }
            }
        }

        ClustersRemaining -= ClustersPerCompressionUnit;
        CurrentVcn += ClustersPerCompressionUnit;
    }

    FREE( CompressedBuffer );
    FREE( UncompressedBuffer );
    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE::IsAllocationZeroed(
    OUT PBOOLEAN  Error
    )
/*++

Routine Description:

    This routine reads the attribute value and checks whether all the
    bytes in the allocation are zeros.

Arguments:

    Error   - if this routine returns false, check error to see if it
              encountered an error trying to read the attribute.

Return Value:

    TRUE if all zeroes, FALSE otherwise.

--*/
{
    CONST   MaxNumBytesToCheck = 65536;
    ULONG   num_bytes, chomp_length, bytes_read, disk_bytes;
    ULONG   bytes_left;
    PUCHAR  buf;
    PBYTE   p1, p2;
    ULONG   i, j;
    BOOLEAN error;

    DebugAssert(QueryValueLength().GetHighPart() == 0);

    if (NULL != Error) {
        *Error = FALSE;
    } else {
        Error = &error;
    }

    disk_bytes = QueryValueLength().GetLowPart();

    if (NULL == (buf = NEW UCHAR[min(MaxNumBytesToCheck, disk_bytes)])) {

        *Error = TRUE;
        return FALSE;
    }

    for (i = 0; i < disk_bytes; i += MaxNumBytesToCheck) {

        chomp_length = min(MaxNumBytesToCheck, disk_bytes - i);

        if (!Read(buf, i, chomp_length, &bytes_read) ||
            bytes_read != chomp_length) {

            *Error = TRUE;
            DELETE(buf);
            return FALSE;
        }

        for (j = 0; j < chomp_length; j++) {

            if (buf[j] != 0) {
                DELETE(buf);
                return FALSE;
            }
        }
    }

    DELETE(buf);
    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE::GetNextAllocationOffset(
    IN OUT PBIG_INT     ByteOffset,
    IN OUT PBIG_INT     Length
    )
/*++

Routine Description:

    This routine locates the next allocation offset and allocation length of a
    file.  This routine is useful for skipping over holes within the value of
    the attribute.

Arguments:

    ByteOffset  - Supplies the location to start searching and returns
                  the next existing location.
    Length      - Supplies the length of existing clusters starting at
                  ByteOffset of the attribute.  If -1, the search starts
                  at the given location; otherwise, it starts at the
                  location after the given location.  On return, it
                  contains the length of the allocation starting at
                  ByteOffset.  If return value is zero, it means there
                  is no more allocation starting at that offset.

Return Value:

    TRUE if all succeeded.
    FALSE if failed.

Notes:

    All offsets and lengths are rounded down to the nearest cluster.

--*/
{
    BIG_INT CurrentVcn;
    BIG_INT CurrentLcn;
    ULONG   ClusterSize;

    ClusterSize = _ClusterFactor * _Drive->QuerySectorSize();
    CurrentVcn = *ByteOffset / ClusterSize;

    if (_ResidentData != NULL) {

        // attribute is resident; allocation is contiguous
        // return zero as the offset and the attribute's valid
        // data length as the length from the offset.

        *ByteOffset = 0;
        *Length = _ValidDataLength;
        return TRUE;

    } else if (_ExtentList != NULL) {

        if (*Length != -1)
            CurrentVcn += *Length/ClusterSize;

        for(;;) {
            if (!_ExtentList->QueryLcnFromVcn(CurrentVcn,
                                              &CurrentLcn,
                                              Length)) {

                // the CurrentVcn is out of range already
                // so set the length to zero and return
                // successful status

                *Length = 0;
                break;
            }

            if (CurrentLcn == LCN_NOT_PRESENT) {
                CurrentVcn += *Length;
            } else {
                *Length = *Length * ClusterSize;
                break;
            }
        }

        *ByteOffset = CurrentVcn * ClusterSize;
        return TRUE;

    } else {
        DebugAbort( "This attribute is neither resident nor nonresident.\n" );
        return FALSE;
    }
}

UCHAR
ComputeCompressionUnit(
    IN ULONG    ClusterSize
    )
{
    if (ClusterSize <= (1024*4))
        return 4;
    else if (ClusterSize == (1024*8))
        return 3;
    else if (ClusterSize == (1024*16))
        return 2;
    else if (ClusterSize == (1024*32))
        return 1;
    else if (ClusterSize == (1024*64))
        return 0;
    else {
        DebugAbort("Unable to determine compression unit value.");
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\attrrec.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    attrrec.hxx

Abstract:

    This module contains the member function definitions for
    NTFS_ATTRIBUTE_RECORD, which models NTFS attribute records.

    An Attribute Record may be a template laid over a chunk of
    memory; in that case, it does not own the memory.  It may
    also be told, upon initialization, to allocate its own memory
    and copy the supplied data.  In that case, it is also responsible
    for freeing that memory.

    Attribute Records are passed between Attributes and File
    Record Segments.  A File Record Segment can initialize
    an Attribute with a list of Attribute Records; when an
    Attribute is Set into a File Record Segment, it packages
    itself up into Attribute Records and inserts them into
    the File Record Segment.

    File Record Segments also use Attribute Records to scan
    through their list of attribute records, and to shuffle
    them around.

Author:

    Bill McJohn (billmc) 14-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "wstring.hxx"
#include "extents.hxx"
#include "attrrec.hxx"
#include "attrcol.hxx"
#include "ntfsbit.hxx"
#include "extents.hxx"
#include "upcase.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_ATTRIBUTE_RECORD, OBJECT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_ATTRIBUTE_RECORD::~NTFS_ATTRIBUTE_RECORD(
    )
{
    Destroy();
}

VOID
NTFS_ATTRIBUTE_RECORD::Construct(
    )
/*++

Routine Description:

    This method is the private worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Data = NULL;
    _MaximumLength = 0;
    _IsOwnBuffer = FALSE;
    _DisableUnUse = FALSE;
    _Drive = NULL;
}

VOID
NTFS_ATTRIBUTE_RECORD::Destroy(
    )
/*++

Routine Description:

    This method is the private worker function for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if( _IsOwnBuffer && _Data != NULL ) {

        FREE( _Data );
    }

    _Data = NULL;
    _MaximumLength = 0;
    _IsOwnBuffer = FALSE;
    _Drive = NULL;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::Initialize(
    IN      PIO_DP_DRIVE    Drive,
    IN OUT  PVOID           Data,
    IN      ULONG           MaximumLength,
    IN      BOOLEAN         MakeCopy
    )
/*++

Routine Description:

    This method initializes an NTFS_ATTRIBUTE_RECORD object,
    handing it a buffer with attribute record data.  The caller
    may also ask the object to make a private copy of the data.

Arguments:

    Drive           -- supplies the drive on which the attribute record resides
    Data            -- supplies a buffer containing the attribute
                        record data the object will own.
    MaximumLength   -- supplies the size of the buffer.
    MakeCopy        -- supplies a flag indicating whether the object
                        should copy the data to a private buffer.

Return Value:

    TRUE upon successful completion.

Notes:

    If MakeCopy is TRUE, then the object must allocate its own
    buffer and copy the attribute record data to it, in which
    case the object is also responsible for freeing that private
    buffer.  It that flag is FALSE, then the object will cache a
    pointer to the buffer supplied by the client; the client is
    responsible for making sure that buffer remains valid for
    the lifetime of the NTFS_ATTRIBUTE_RECORD object.

    This object is reinitializable.

--*/
{
    Destroy();

    if( !MakeCopy ) {

        _Data = (PATTRIBUTE_RECORD_HEADER) Data;
        _MaximumLength = MaximumLength;
        _IsOwnBuffer = FALSE;
        _Drive = Drive;

        return TRUE;

    } else {

        if( (_Data = (PATTRIBUTE_RECORD_HEADER)
                     MALLOC( (UINT) MaximumLength )) == NULL ) {

            Destroy();
            return FALSE;
        }

        _MaximumLength = MaximumLength;
        _IsOwnBuffer = TRUE;
        _Drive = Drive;
        memcpy(_Data, Data, (UINT) MaximumLength);

        return TRUE;
    }
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE_RECORD::Initialize(
    IN      PIO_DP_DRIVE    Drive,
    IN OUT  PVOID           Data
    )
/*++

Routine Description:

    This version of Initialize takes it's maximum size from the
    attribute record.

Arguments:

    Drive   - supplies the drive on which the attribute record resides
    Data    - supplies a buffer containing the attribute
                record data.

Return Value:

    TRUE upon successful completion.

--*/
{
    Destroy();

    _Data = (PATTRIBUTE_RECORD_HEADER) Data;
    _MaximumLength = _Data->RecordLength;
    _IsOwnBuffer = FALSE;
    _Drive = Drive;

    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE_RECORD::CreateResidentRecord(
    IN  PCVOID              Value,
    IN  ULONG               ValueLength,
    IN  ATTRIBUTE_TYPE_CODE TypeCode,
    IN  PCWSTRING           Name,
    IN  USHORT              Flags,
    IN  UCHAR               ResidentFlags
    )
/*++

Routine Description:

    This method formats the object's buffer with a resident
    attribute record.

Arguments:

    Value           -- supplies the attribute value
    ValueLength     -- supplies the length of the value
    TypeCode        -- supplies the attribute type code
    Name            -- supplies the name of the attribute
                        (may be NULL)
    Flags           -- supplies the attribute's flags.
    ResidentFlags   -- supplies the attribute's resident flags

Return Value:

    TRUE upon successful completion.

--*/
{
    // Clear the memory first.
    memset(_Data, 0, (UINT) _MaximumLength);

    // We will arrange the attribute in the following order:
    //  Attribute Record Header
    //  Name (if any)
    //  Value

    if( _MaximumLength < SIZE_OF_RESIDENT_HEADER )  {

        DebugAbort( "Create:  buffer is too small.\n" );
        return FALSE;
    }

    _Data->TypeCode = TypeCode;
    _Data->FormCode = RESIDENT_FORM;
    _Data->Flags = Flags;

    if( Name != NULL ) {

        _Data->NameLength = (UCHAR) Name->QueryChCount();
        _Data->NameOffset = QuadAlign(SIZE_OF_RESIDENT_HEADER);

        //
        // The structure should be quad aligned already.  This check is just in case.
        //
        DebugAssert(QuadAlign(SIZE_OF_RESIDENT_HEADER) == SIZE_OF_RESIDENT_HEADER);

        _Data->Form.Resident.ValueOffset =
            QuadAlign( _Data->NameOffset +
                        _Data->NameLength * sizeof( WCHAR ) );

    } else {

        _Data->NameLength = 0;
        _Data->NameOffset = 0;

        _Data->Form.Resident.ValueOffset =
                    QuadAlign(SIZE_OF_RESIDENT_HEADER);
    }

    _Data->Form.Resident.ValueLength = ValueLength;
    _Data->Form.Resident.ResidentFlags = ResidentFlags;

    _Data->RecordLength =
        QuadAlign(_Data->Form.Resident.ValueOffset + ValueLength );

    if( _Data->RecordLength > _MaximumLength ) {

        return FALSE;
    }

    // Now that we're sure there's room, copy the name (if any)
    // and the value into their respective places.

    if( Name != NULL ) {

        Name->QueryWSTR( 0,
                         _Data->NameLength,
                         (PWSTR)((PBYTE)_Data + _Data->NameOffset),
                         _Data->NameLength,
                         FALSE );
    }

    memcpy( (PBYTE)_Data + _Data->Form.Resident.ValueOffset,
            Value,
            (UINT) ValueLength );

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::CreateNonresidentRecord(
    IN  PCNTFS_EXTENT_LIST  Extents,
    IN  BIG_INT             AllocatedLength,
    IN  BIG_INT             ActualLength,
    IN  BIG_INT             ValidLength,
    IN  ATTRIBUTE_TYPE_CODE TypeCode,
    IN  PCWSTRING           Name,
    IN  USHORT              Flags,
    IN  USHORT              CompressionUnit,
    IN  ULONG               ClusterSize
    )
/*++

Routine Description:

    This method formats the attribute record to hold a nonresident
    attribute.

Arguments:

    Extents         -- supplies an extent list describing the
                        attribute value's disk storage.
    AllocatedLength -- supplies the allocated length of the value
    ActualLength    -- supplies the actual length of the value
    ValidLength     -- supplies the valid length of the value
    TypeCode        -- supplies the attribute type code
    Name            -- supplies the name of the attribute
                        (may be NULL)
    Flags           -- supplies the attribute's flags.
    CompressionUnit -- supplies the log in base 2 of the number of
                        clusters per compression unit.

--*/
{
    ULONG   MappingPairsLength;
    VCN     NextVcn, HighestVcn;
    USHORT  sizeOfNonResidentHeader = SIZE_OF_NONRESIDENT_HEADER;

    if (Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                 ATTRIBUTE_FLAG_SPARSE)) {
        sizeOfNonResidentHeader += sizeof(BIG_INT); // TotalAllocated field
    }

    // Clear the memory first.
    memset(_Data, 0, (UINT) _MaximumLength);

    // We will arrange the attribute in the following order:
    //  Attribute Record Header
    //  Name (if any)
    //  Compressed Mapping Pairs

    if( _MaximumLength < sizeOfNonResidentHeader )   {

        DebugAbort( "Create:  buffer is too small.\n" );
        return FALSE;
    }

    _Data->TypeCode = TypeCode;
    _Data->FormCode = NONRESIDENT_FORM;
    _Data->Flags = Flags;

    if( Name != NULL ) {

        _Data->NameLength = (UCHAR) Name->QueryChCount();
        _Data->NameOffset = QuadAlign(sizeOfNonResidentHeader);

        //
        // The structure should be quad aligned already.  This check is just in case.
        //
        DebugAssert(QuadAlign(sizeOfNonResidentHeader) == sizeOfNonResidentHeader);

        _Data->Form.Nonresident.MappingPairsOffset =
            (USHORT)QuadAlign( _Data->NameOffset +
                                _Data->NameLength * sizeof( WCHAR ) );

    } else {

        _Data->NameLength = 0;
        _Data->NameOffset = 0;

        _Data->Form.Nonresident.MappingPairsOffset =
            (USHORT)QuadAlign(sizeOfNonResidentHeader);
    }

    _Data->Form.Nonresident.CompressionUnit = (UCHAR)CompressionUnit;

    _Data->Form.Nonresident.AllocatedLength =
                    AllocatedLength.GetLargeInteger();

    if (Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                 ATTRIBUTE_FLAG_SPARSE)) {
        _Data->Form.Nonresident.TotalAllocated =
            (Extents->QueryClustersAllocated()*ClusterSize).GetLargeInteger();
    }
    _Data->Form.Nonresident.FileSize = ActualLength.GetLargeInteger();
    _Data->Form.Nonresident.ValidDataLength = ValidLength.GetLargeInteger();


    // Copy the name

    if( Name != NULL ) {

        if( (ULONG)(_Data->NameOffset + _Data->NameLength) > _MaximumLength ) {

            // There isn't enough room for the name.

            return FALSE;
        }

        Name->QueryWSTR( 0,
                         _Data->NameLength,
                         (PWSTR)((PBYTE)_Data + _Data->NameOffset),
                         _Data->NameLength,
                         FALSE );
    }


    if( !Extents->QueryCompressedMappingPairs(
                        (PVCN)&(_Data->Form.Nonresident.LowestVcn),
                        &NextVcn,
                        &MappingPairsLength,
                        _MaximumLength -
                          _Data->Form.Nonresident.MappingPairsOffset,
                        (PVOID)((PBYTE)_Data +
                          _Data->Form.Nonresident.MappingPairsOffset) ) ) {

        // Unable to get the compressed mapping pairs.

        DebugPrint( "Could not get compressed mapping pairs.\n" );
        return FALSE;
    }

    HighestVcn = NextVcn - 1;
    memcpy( &_Data->Form.Nonresident.HighestVcn, &HighestVcn, sizeof(VCN) );

    _Data->RecordLength =
        QuadAlign(_Data->Form.Nonresident.MappingPairsOffset +
                  MappingPairsLength );

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::Verify(
    IN  PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN  BOOLEAN                     BeLenient
    ) CONST
/*++

Routine Description:

    This routine verifies an attribute record for consistency against
    itself and against the attribute definition table.  This routine
    will return FALSE if the attribute record contains any
    inconsistencies.

Arguments:

    AttributeDefTable   - Supplies the attribute definition table.

Return Value:

    FALSE   - The attribute record is inconsistent.
    TRUE    - The attribute record is ok.

--*/
{
    NTFS_EXTENT_LIST    extent_list;
    BOOLEAN             bad_mapping_pairs;
    ULONG               index;
    ULONG               column_flags;
    BIG_INT             length;
    PFILE_NAME          file_name;
    ULONG               value_length;
    UCHAR               i;
    PWCHAR              p;
    USHORT              sizeOfNonResidentHeader = SIZE_OF_NONRESIDENT_HEADER;

    DebugAssert(_Data);

    // Make sure that we can access at least the form code.

    if (FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER, Instance) > _Data->RecordLength) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_TOO_SMALL,
                         "%x%x%x%x",
                         _Data->RecordLength,
                         FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER, Instance),
                         QueryTypeCode(),
                         QueryInstanceTag());
            }
        }

        DebugPrintTrace(("Attribute form code out-of-bounds.\n"));
        return FALSE;
    }

    // Make sure that the form code is either resident or non-resident.

    if (_Data->FormCode != RESIDENT_FORM &&
        _Data->FormCode != NONRESIDENT_FORM) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_ATTR_FORM_CODE,
                         "%x%x%x",
                         _Data->FormCode,
                         QueryTypeCode(),
                         QueryInstanceTag());
            }
        }

        DebugPrintTrace(("Attribute %d has non-existent form code.\n", _Data->TypeCode));
        return FALSE;
    }

    if (_Data->FormCode == NONRESIDENT_FORM &&
        (_Data->Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                         ATTRIBUTE_FLAG_SPARSE))) {
        sizeOfNonResidentHeader += sizeof(BIG_INT); // TotalAllocated field
    }

    // Make sure that the record is at least as big as the header
    // for the record

    if (_Data->FormCode == RESIDENT_FORM &&
        _Data->RecordLength < SIZE_OF_RESIDENT_HEADER) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_TOO_SMALL,
                         "%x%x%x%x",
                         _Data->RecordLength,
                         SIZE_OF_RESIDENT_HEADER,
                         QueryTypeCode(),
                         QueryInstanceTag());
            }
        }

        DebugPrintTrace(("Attribute record res header out-of-bounds.\n"));
        return FALSE;
    }

    if (_Data->FormCode == NONRESIDENT_FORM &&
        _Data->RecordLength < sizeOfNonResidentHeader) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_TOO_SMALL,
                         "%x%x%x%x",
                         _Data->RecordLength,
                         sizeOfNonResidentHeader,
                         QueryTypeCode(),
                         QueryInstanceTag());
            }
        }

        DebugPrintTrace(("Attribute record nonres header out-of-bounds.\n"));

        return FALSE;
    }


    switch (_Data->TypeCode) {

        case $STANDARD_INFORMATION:

            if (!IsResident() ||
                (_Data->Form.Resident.ValueLength !=
                sizeof(STANDARD_INFORMATION) &&
                _Data->Form.Resident.ValueLength !=
                SIZEOF_NEW_STANDARD_INFORMATION)
                    ) {

                // This attribute must be resident and at least
                // as big as the above structure.

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {

                        if (!IsResident()) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_BE_RESIDENT,
                                     "%x%x",
                                     QueryTypeCode(),
                                     QueryInstanceTag());
                        } else {
                            msg->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_STD_INFO_ATTR_SIZE,
                                     "%x%x%x",
                                     _Data->Form.Resident.ValueLength,
                                     sizeof(STANDARD_INFORMATION),
                                     SIZEOF_NEW_STANDARD_INFORMATION);
                        }
                    }
                }

                DebugPrintTrace(("The standard information is too small\n"));
                return FALSE;
            }

            // Fall through for next check.

        case $ATTRIBUTE_LIST:
        case $VOLUME_VERSION:
        case $SECURITY_DESCRIPTOR:
        case $VOLUME_NAME:
        case $VOLUME_INFORMATION:
        case $SYMBOLIC_LINK:
        case $EA_INFORMATION:
        case $EA_DATA:

            if (_Data->NameLength) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_NOT_HAVE_NAME,
                                 "%x%x",
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                // These attribute may not have names.
                DebugPrintTrace(("Attribute %d should not have a name.\n", _Data->TypeCode));
                return FALSE;
            }

            break;

        case $INDEX_ALLOCATION:

            // $INDEX_ALLOCATION's can't be resident.

            if (IsResident()) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_NOT_BE_RESIDENT,
                                 "%x%x",
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has resident index allocation\n", _Data->TypeCode));
                return FALSE;
            }
            break;

        default:
            break;

    }


    // Make sure the name offset is well-aligned and in bounds.
    // Also make sure that the name does not have any unicode NULLs
    // in them.

    if (_Data->NameOffset%sizeof(WCHAR) ||
        ULONG(_Data->NameOffset + _Data->NameLength) > _Data->RecordLength) {

        if (_Drive) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->Lock();
                msg->Set(MSG_CHKLOG_NTFS_INCORRECT_ATTR_NAME_OFFSET);
                msg->Log("%x%x",
                         QueryTypeCode(),
                         QueryInstanceTag());
                msg->DumpDataToLog(_Data,
                                   sizeof(ATTRIBUTE_RECORD_HEADER)+
                                   sizeof(WCHAR)*_Data->NameLength);
                msg->Unlock();
            }
        }

        DebugPrintTrace(("Corrupt name for attribute %d.\n", _Data->TypeCode));
        return FALSE;
    }

    p = (PWCHAR) ((PCHAR) _Data + _Data->NameOffset);
    for (i = 0; i < _Data->NameLength; i++) {
        if (!p[i]) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_NULL_FOUND_IN_ATTR_NAME);
                    msg->Log("%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(_Data,
                                       sizeof(ATTRIBUTE_RECORD_HEADER)+
                                       sizeof(WCHAR)*_Data->NameLength);
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Unicode NULL in attribute name for attribute %d.\n",
                      _Data->TypeCode));
            return FALSE;
        }
    }


    // Make sure that things mesh with the attribute definition table.

    if (AttributeDefTable) {


        if (_Data->TypeCode == $UNUSED ||
            !AttributeDefTable->QueryIndex(_Data->TypeCode, &index)) {

            // The attribute type code doesn't exist in the attribute
            // definition table.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_ATTR_TO_ATTR_DEF_TABLE,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d does not exist in the definition table.\n", _Data->TypeCode));
            return FALSE;
        }

        column_flags = AttributeDefTable->QueryFlags(index);

        if (IsResident() &&
            (_Data->Form.Resident.ResidentFlags & RESIDENT_FORM_INDEXED) &&
            !(column_flags & ATTRIBUTE_DEF_INDEXABLE)) {

            // Non-indexable indexed attribute.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_NOT_BE_INDEXED,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d is NOT indexable.\n", _Data->TypeCode));
            return FALSE;
        }

        if ((column_flags & ATTRIBUTE_DEF_MUST_BE_INDEXED) &&
            !(IsResident() &&
              (_Data->Form.Resident.ResidentFlags & RESIDENT_FORM_INDEXED))) {

            // Attribute must be indexed but isn't.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_BE_INDEXED,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d MUST be indexed.\n", _Data->TypeCode));
            return FALSE;
        }

        if ((column_flags & ATTRIBUTE_DEF_INDEXABLE) && _Data->NameLength) {

            // Indexable attributes cannot have names.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INDEXABLE_ATTR_SHOULD_NOT_HAVE_NAME);
                    msg->Log("%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(_Data,
                                       sizeof(ATTRIBUTE_RECORD_HEADER)+
                                       sizeof(WCHAR)*_Data->NameLength);
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Attribute %d cannot have a name.\n", _Data->TypeCode));
            return FALSE;
        }

        if ((column_flags & ATTRIBUTE_DEF_MUST_BE_NAMED) &&
            !_Data->NameLength) {

            // Attribute must be named but isn't.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_BE_NAMED,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d MUST have a name.\n", _Data->TypeCode));
            return FALSE;
        }

        if ((column_flags & ATTRIBUTE_DEF_MUST_BE_RESIDENT) &&
            !IsResident()) {

            // Attribute must be resident but isn't.

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_BE_RESIDENT,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d MUST be resident.\n", _Data->TypeCode));
            return FALSE;
        }

        if (IsResident()) {
            length = _Data->Form.Resident.ValueLength;
        } else if (_Data->Form.Nonresident.LowestVcn == 0) {
            length = _Data->Form.Nonresident.FileSize;
        } else {
            length = 0;
        }

        if (length != 0) {

            if (length < AttributeDefTable->QueryMinimumLength(index)) {

                // Length is less than the minimum.

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_LENGTH_TOO_SMALL,
                                 "%I64x%x%x%x",
                                 length.GetLargeInteger(),
                                 AttributeDefTable->QueryMinimumLength(index),
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has length less than the minimum.\n", _Data->TypeCode));
                return FALSE;
            }

            // Note that a value of -1 in the Length field of the
            // Attribute Definition Table entry indicates that the
            // attribute can be as large as it pleases.
            //
            // Note the length of the $STANDARD_INFORMATION attribute
            // is checked above.
            //

            if (AttributeDefTable->QueryMaximumLength(index) != -1 &&
                length > AttributeDefTable->QueryMaximumLength(index) &&
                _Data->TypeCode != $VOLUME_VERSION &&
                _Data->TypeCode != $STANDARD_INFORMATION ) {

                // Length is greater than the maximum.

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_LENGTH_TOO_BIG,
                                 "%I64x%x%x%x",
                                 length.GetLargeInteger(),
                                 AttributeDefTable->QueryMaximumLength(index),
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has length greater than the maximum.\n", _Data->TypeCode));
                return FALSE;
            }
        }
    }


    if (IsResident()) {

        // Make sure that the value is in bounds and
        // make sure that name comes before value.

        if (_Data->Form.Resident.ValueLength > _Data->RecordLength ||
            _Data->Form.Resident.ValueOffset >
            _Data->RecordLength - _Data->Form.Resident.ValueLength) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_RESIDENT_ATTR,
                             "%x%x%x%x%x",
                             _Data->Form.Resident.ValueLength,
                             _Data->Form.Resident.ValueOffset,
                             _Data->RecordLength,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has corrupt resident value.\n", _Data->TypeCode));
            return FALSE;
        }

        if (_Data->NameOffset +
            _Data->NameLength >
            _Data->Form.Resident.ValueOffset) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_RESIDENT_ATTR_COLLISION,
                             "%x%x%x%x%x",
                             _Data->NameLength,
                             _Data->NameOffset,
                             _Data->Form.Resident.ValueOffset,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d colliding name and resident value.\n", _Data->TypeCode));
            return FALSE;
        }

        // Make sure that if the attribute is indexed then it
        // has no name.

        if ((_Data->Form.Resident.ResidentFlags & RESIDENT_FORM_INDEXED) &&
            _Data->NameLength) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INDEXABLE_ATTR_SHOULD_NOT_HAVE_NAME);
                    msg->Log("%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(_Data,
                                       sizeof(ATTRIBUTE_RECORD_HEADER)+
                                       sizeof(WCHAR)*_Data->NameLength);
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Attribute %d is indexed AND has a name.\n", _Data->TypeCode));
            return FALSE;
        }


    } else {

        // Make sure that the mapping pairs are in bounds.

        if (_Data->Form.Nonresident.MappingPairsOffset >=
            _Data->RecordLength) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_HAS_BAD_MAPPING_PAIRS_OFFSET,
                             "%x%x%x%x",
                             _Data->Form.Nonresident.MappingPairsOffset,
                             _Data->RecordLength,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has mapping pairs that are out of bounds.\n", _Data->TypeCode));
            return FALSE;
        }

        if (QuadAlign(_Data->Form.Nonresident.MappingPairsOffset) !=
            _Data->Form.Nonresident.MappingPairsOffset) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_HAS_UNALIGNED_MAPPING_PAIRS_OFFSET,
                             "%x%x%x%x",
                             _Data->Form.Nonresident.MappingPairsOffset,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has unaligned mapping pairs offset %x.\n",
                             _Data->Form.Nonresident.MappingPairsOffset));
            return FALSE;
        }

        if ((QueryFlags() & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                             ATTRIBUTE_FLAG_SPARSE)) != 0) {

            if (_Data->Form.Nonresident.LowestVcn == 0 &&
                _Data->Form.Nonresident.MappingPairsOffset <
                    4 * sizeof(BIG_INT)) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_MAPPING_PAIRS_OFFSET_TOO_SMALL,
                                     "%x%x%x%x",
                                     _Data->Form.Nonresident.MappingPairsOffset,
                                     4 * sizeof(BIG_INT),
                                     QueryTypeCode(),
                                     QueryInstanceTag());
                        }
                    }

                    DebugPrintTrace(("Attribute %d MappingPairsOffset too small (%d).\n",
                                     _Data->TypeCode,
                                     _Data->Form.Nonresident.MappingPairsOffset));

                return FALSE;
            }
        } else {
            if (_Data->Form.Nonresident.LowestVcn == 0 &&
                _Data->Form.Nonresident.MappingPairsOffset <
                    3 * sizeof(BIG_INT)) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_MAPPING_PAIRS_OFFSET_TOO_SMALL,
                                     "%x%x%x%x",
                                     _Data->Form.Nonresident.MappingPairsOffset,
                                     3 * sizeof(BIG_INT),
                                     QueryTypeCode(),
                                     QueryInstanceTag());
                        }
                    }

                    DebugPrintTrace(("Attribute %d has MappingPairsOffset too small (%d).\n",
                                     _Data->TypeCode,
                                     _Data->Form.Nonresident.MappingPairsOffset));
            }
        }

        // Make sure that the name comes before the mapping pairs.

        if (_Data->NameLength &&
            _Data->NameOffset +
            _Data->NameLength >
            _Data->Form.Nonresident.MappingPairsOffset) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_NON_RESIDENT_ATTR_COLLISION,
                             "%x%x%x%x%x",
                             _Data->NameLength,
                             _Data->NameOffset,
                             _Data->Form.Nonresident.MappingPairsOffset,
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has its name colliding with the mapping pairs.\n", _Data->TypeCode));
            return FALSE;
        }


        // Validate the mapping pairs.

        bad_mapping_pairs = FALSE;

        if (!extent_list.Initialize(_Data->Form.Nonresident.LowestVcn,
                                    (PCHAR) _Data +
                                    _Data->Form.Nonresident.MappingPairsOffset,
                                    _Data->RecordLength -
                                    _Data->Form.Nonresident.MappingPairsOffset,
                                    &bad_mapping_pairs)) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {

                    MSGID   msgid;

                    if (bad_mapping_pairs) {
                        msgid = MSG_CHKLOG_NTFS_BAD_MAPPING_PAIRS;
                    } else {
                        msgid = MSG_CHKLOG_NTFS_UNABLE_TO_INITIALIZE_EXTENT_LIST;
                    }
                    msg->LogMsg(msgid,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has bad mapping pairs.\n", _Data->TypeCode));
            return FALSE;
        }

        if (extent_list.QueryNextVcn() !=
            _Data->Form.Nonresident.HighestVcn + 1 && !BeLenient) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_HAS_INVALID_HIGHEST_VCN,
                             "%I64x%I64x%x%x",
                             _Data->Form.Nonresident.HighestVcn + 1,
                             extent_list.QueryNextVcn().GetLargeInteger(),
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Attribute %d has an invalid highest vcn.\n", _Data->TypeCode));
            return FALSE;
        }


        // If the lowest vcn is 0 then make sure that the three sizes
        // make sense.

        if (_Data->Form.Nonresident.LowestVcn == 0 && !BeLenient) {

            if (CompareGT(_Data->Form.Nonresident.ValidDataLength,
                          _Data->Form.Nonresident.FileSize) ||
                CompareGT(_Data->Form.Nonresident.FileSize,
                          _Data->Form.Nonresident.AllocatedLength)) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_ATTR_SIZES,
                                 "%I64x%I64x%I64x%x%x",
                                 _Data->Form.Nonresident.ValidDataLength,
                                 _Data->Form.Nonresident.FileSize,
                                 _Data->Form.Nonresident.AllocatedLength,
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has inconsistent sizes.\n", _Data->TypeCode));
                return FALSE;
            }

            if ((QueryFlags() & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                 ATTRIBUTE_FLAG_SPARSE)) != 0 &&
                CompareGT(_Data->Form.Nonresident.TotalAllocated,
                          _Data->Form.Nonresident.AllocatedLength)) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_ATTR_TOTAL_ALLOC,
                                 "%I64x%I64x%x%x",
                                 _Data->Form.Nonresident.TotalAllocated,
                                 _Data->Form.Nonresident.AllocatedLength,
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has inconsistent TotalAllocated.\n",
                    _Data->TypeCode));
#if 0
//
// This would cause the attribute record to be deleted, which is considered
// to be too harsh a penalty for this minor error.
//
                return FALSE;
#endif
            }

            if ((QueryFlags() & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                 ATTRIBUTE_FLAG_SPARSE |
                                 ATTRIBUTE_FLAG_ENCRYPTED)) != 0 &&
                (_Data->Form.Nonresident.AllocatedLength %
                 (1 << QueryCompressionUnit())) != 0) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_INVALID_NON_RESIDENT_ATTR_TOTAL_ALLOC_BLOCK,
                                 "%I64x%x%x%x",
                                 _Data->Form.Nonresident.AllocatedLength,
                                 1<<QueryCompressionUnit(),
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                    }
                }

                DebugPrintTrace(("Attribute %d has TotalAllocated not multiple of "
                                 "compression unit\n", _Data->TypeCode));

                return FALSE;
            }
        }

    }


    // $FILE_NAME attribute must follow additional special structure.

    if (_Data->TypeCode == $FILE_NAME) {

        if (!IsIndexed()) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_SHOULD_NOT_BE_INDEXED,
                             "%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("File name attribute is not indexed.\n"));
            return FALSE;
        }

        file_name = (PFILE_NAME) ((PCHAR) _Data +
                                  _Data->Form.Resident.ValueOffset);

        value_length = _Data->Form.Resident.ValueLength;

        if (value_length < sizeof(FILE_NAME)) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_FILE_NAME_VALUE_LENGTH_TOO_SMALL,
                             "%x%x%x%x",
                             value_length,
                             sizeof(FILE_NAME),
                             QueryTypeCode(),
                             QueryInstanceTag());
                }
            }

            DebugPrintTrace(("Corrupt file name attribute.\n"));
            return FALSE;
        }

        if (NtfsFileNameGetLength(file_name) != value_length) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INCONSISTENCE_FILE_NAME_VALUE);
                    msg->Log("%x%x%x",
                             value_length,
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(file_name, NtfsFileNameGetLength(file_name));
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Corrupt file name attribute.\n"));
            return FALSE;
        }

        if (file_name->FileNameLength == 0) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_BAD_FILE_NAME_LENGTH_IN_FILE_NAME_VALUE);
                    msg->Log("%x%x",
                             QueryTypeCode(),
                             QueryInstanceTag());
                    msg->DumpDataToLog(file_name, sizeof(FILE_NAME)+0x20);
                    msg->Unlock();
                }
            }

            DebugPrintTrace(("Corrupt file name attribute.\n"));
            return FALSE;
        }


        // Make sure that the file name has no NULL
        // characters in it.  If it does then the attribute
        // is "corrupt".

        for (i = 0; i < file_name->FileNameLength; i++) {
            if (!file_name->FileName[i]) {

                if (_Drive) {

                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->Lock();
                        msg->Set(MSG_CHKLOG_NTFS_NULL_FOUND_IN_FILE_NAME_OF_FILE_NAME_VALUE);
                        msg->Log("%x%x",
                                 QueryTypeCode(),
                                 QueryInstanceTag());
                        msg->DumpDataToLog(file_name, NtfsFileNameGetLength(file_name));
                        msg->Unlock();
                    }
                }

                DebugPrintTrace(("Attribute %d has filename w/ null characters\n", _Data->TypeCode));
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::UseClusters(
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    OUT     PBIG_INT        ClusterCount
    ) CONST
/*++

Routine Description:

    This routine allocates the disk space claimed by this attribute
    record in the bitmap provided.  A check is made to verify that
    the requested disk space is free before the allocation takes
    place.  If the requested space is not available in the bitmap
    then this routine will return FALSE.

Arguments:

    VolumeBitmap    - Supplies the bitmap.
    ClusterCount    - Receives the number of clusters allocated
                      to this record.  Not set if method fails.

Return Value:

    FALSE   - The request bitmap space was not available.
    TRUE    - Success.

--*/
{
    NTFS_EXTENT_LIST    extent_list;
    ULONG               num_extents;
    ULONG               i, j;
    VCN                 next_vcn;
    LCN                 current_lcn;
    BIG_INT             run_length;

    DebugAssert(VolumeBitmap);

    if (IsResident()) {
        *ClusterCount = 0;
        return TRUE;
    }

    if (!QueryExtentList(&extent_list)) {
        return FALSE;
    }

    num_extents = extent_list.QueryNumberOfExtents();

    for (i = 0; i < num_extents; i++) {

        if (!extent_list.QueryExtent(i, &next_vcn, &current_lcn,
                                     &run_length)) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_EXTENT_FAILED,
                             "%x%x%x", QueryTypeCode(), QueryInstanceTag(), i);
                }
            }
            return FALSE;
        }

        if (current_lcn == LCN_NOT_PRESENT) {
            continue;
        }


        // Make sure that the run is free before allocating.
        // If it is not, this indicates a cross-link.

        if (!VolumeBitmap->IsFree(current_lcn, run_length)) {

            if (_Drive) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_REC_CROSS_LINKED,
                             "%x%x%I64x%I64x",
                             QueryTypeCode(), QueryInstanceTag(),
                             current_lcn, run_length);
                }
            }

            DebugPrintTrace(("cross-linked run starts at 0x%I64x for 0x%I64x\n",
                             current_lcn.GetLargeInteger(),
                             run_length.GetLargeInteger()));

            // Free everything so far allocated by this routine.

            for (j = 0; j < i; j++) {

                if (!extent_list.QueryExtent(j, &next_vcn, &current_lcn,
                                             &run_length)) {

                    if (_Drive) {

                        PMESSAGE msg = _Drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_QUERY_EXTENT_FAILED,
                                     "%x%x%x", QueryTypeCode(), QueryInstanceTag(), i);
                        }
                    }
                    DebugAbort("Could not query extent");
                    return FALSE;
                }
                if (current_lcn == LCN_NOT_PRESENT) {
                    continue;
                }

                VolumeBitmap->SetFree(current_lcn, run_length);
            }

            return FALSE;
        }

        VolumeBitmap->SetAllocated(current_lcn, run_length);
    }

    *ClusterCount = extent_list.QueryClustersAllocated();
    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::UseClusters(
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    OUT     PBIG_INT        ClusterCount,
    IN      ULONG           AllowCrossLinkStart,
    IN      ULONG           AllowCrossLinkLength,
    OUT     PBOOLEAN        DidCrossLinkOccur
    ) CONST
/*++

Routine Description:

    This routine allocates the disk space claimed by this attribute
    record in the bitmap provided.  A check is made to verify that
    the requested disk space is free before the allocation takes
    place.  If the requested space is not available in the bitmap
    then this routine will return FALSE.

    This methode assumes that the range specified by the Allow
    parameters are marked as allocated in the given bitmap.

Arguments:

    VolumeBitmap            - Supplies the bitmap.
    ClusterCount            - Receives the number of clusters allocated
                                to this record.  Not set if method fails.
    AllowCrossLinkStart     - Supplies the start of a range where
                                cross-links are allowed.
    AllowCrossLinkLength    - Supplies the length of the range where
                                cross-links are allowed.
    DidCrossLinkOccur       - Returns whether or not an allowable
                                cross-link occurred.

Return Value:

    FALSE   - The request bitmap space was not available.
    TRUE    - Success.

--*/
{
    BOOLEAN r;

    DebugAssert(DidCrossLinkOccur);

    *DidCrossLinkOccur = FALSE;

    if (UseClusters(VolumeBitmap,ClusterCount)) {
        return TRUE;
    }

    *DidCrossLinkOccur = TRUE;

    if (AllowCrossLinkLength == 0)  // if we are not freeing any cluster
                                    // there is no need to check again
        return FALSE;

    VolumeBitmap->SetFree(AllowCrossLinkStart, AllowCrossLinkLength);

    r = UseClusters(VolumeBitmap,ClusterCount);

    VolumeBitmap->SetAllocated(AllowCrossLinkStart, AllowCrossLinkLength);

    return r;
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::UnUseClusters(
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    IN      ULONG           LeaveInUseStart,
    IN      ULONG           LeaveInUseLength
    ) CONST
/*++

Routine Description:

    This operation reverses a successful 'UseClusters' operation.

    This method assumes that the LeaveInUse range is already in
    use by the bitmap.

Arguments:

    VolumeBitmap        - Supplies the bitmap.
    LeaveInUseStart     - Supplies the start of the range that this routine
                            should leave in use.
    LeaveInUseLength    - Supplies the length of the range that this
                            routine should leave in use.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_EXTENT_LIST    extent_list;
    ULONG               num_extents;
    ULONG               i;
    VCN                 next_vcn;
    LCN                 current_lcn;
    BIG_INT             run_length;

    DebugAssert(VolumeBitmap);

    if (IsResident() || _DisableUnUse) {
        return TRUE;
    }

    if (!QueryExtentList(&extent_list)) {
        return FALSE;
    }

    num_extents = extent_list.QueryNumberOfExtents();

    for (i = 0; i < num_extents; i++) {

        if (!extent_list.QueryExtent(i, &next_vcn, &current_lcn,
                                     &run_length)) {

            DebugAbort("Could not query extent");
            return FALSE;
        }
        if (LCN_NOT_PRESENT == current_lcn) {
            continue;
        }

        VolumeBitmap->SetFree(current_lcn, run_length);
    }

    VolumeBitmap->SetAllocated(LeaveInUseStart, LeaveInUseLength);

    return TRUE;
}



NONVIRTUAL
UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE_RECORD::QueryName(
    OUT PWSTRING    Name
    ) CONST
/*++

Routine Description:

    This method returns the name of the attribute.

Arguments:

    Name    - Returns the name of the attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (FIELD_OFFSET(ATTRIBUTE_RECORD_HEADER, Flags) >= _MaximumLength ||
        ULONG(_Data->NameOffset + _Data->NameLength) > _MaximumLength ||
        _Data->NameLength == 0) {

        return Name->Initialize( "" );

    } else {

        return Name->Initialize((PWSTR)((PBYTE)_Data + _Data->NameOffset),
                                _Data->NameLength);

    }
}


VOID
NTFS_ATTRIBUTE_RECORD::QueryValueLength(
    OUT PBIG_INT ValueLength,
    OUT PBIG_INT AllocatedLength,
    OUT PBIG_INT ValidLength,
    OUT PBIG_INT TotalAllocated
    ) CONST
/*++

Routine Description:

    This method returns the actual, allocated, valid, and
    total allocated lengths
    of the attribute value associated with this record.

    If the attribute is resident, these values are all
    the length of the resident value, except total allocated,
    which is meaningless.

    If the attribute is nonresident, these four values are only
    meaningful if the LowestVcn of this attribute record is 0.
    Additionally, TotalAllocated is only valid for compressed
    attributes.

Arguments:

    ValueLength     -- receives the actual length of the value.
    AllocatedLength -- receives the allocated size of the value.
                        (may be NULL if the caller doesn't care)
    ValidLength     -- receives the valid length of the value.
                        (may be NULL if the caller doesn't care)
    TotalAllocated  -- receives the total allocated length of the
                        value (may be NULL).

Return Value:

    None.

--*/
{
    DebugPtrAssert( _Data );

    if( _Data->FormCode == RESIDENT_FORM ) {

        *ValueLength = _Data->Form.Resident.ValueLength;

        if( AllocatedLength != NULL ) {

            *AllocatedLength = _Data->Form.Resident.ValueLength;
        }

        if( ValidLength != NULL ) {

            *ValidLength = _Data->Form.Resident.ValueLength;
        }

        if (TotalAllocated != NULL ) {

            // no such value for resident attributes

            *TotalAllocated = 0;
        }

    } else {

        DebugAssert( _Data->FormCode == NONRESIDENT_FORM );

        *ValueLength = _Data->Form.Nonresident.FileSize;

        if( AllocatedLength != NULL ) {

            *AllocatedLength = _Data->Form.Nonresident.AllocatedLength;
        }

        if( ValidLength != NULL ) {

            *ValidLength = _Data->Form.Nonresident.ValidDataLength;
        }

        if (TotalAllocated != NULL) {
            if ((_Data->Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                 ATTRIBUTE_FLAG_SPARSE)) != 0) {
                *TotalAllocated = _Data->Form.Nonresident.TotalAllocated;
            } else {
                *TotalAllocated = 0;
            }
        }

    }
}

VOID
NTFS_ATTRIBUTE_RECORD::SetTotalAllocated(
    IN BIG_INT TotalAllocated
    )
/*++

Routine Description:

    Set the "TotalAllocated" field in the attribute record.  If the
    attribute record doesn't have a total allocated field because
    the attribute isn't compressed or because it's resident, this
    method has no effect.

Arguments:

    TotalAllocated - the new value.

Return Value:

    None.

--*/
{
    DebugPtrAssert( _Data );

    if( _Data->FormCode == RESIDENT_FORM ) {

        // no such value for resident attributes; ignore

        return;

    }

    DebugAssert( _Data->FormCode == NONRESIDENT_FORM );

    if ((_Data->Flags & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                         ATTRIBUTE_FLAG_SPARSE)) != 0) {
        _Data->Form.Nonresident.TotalAllocated =
            TotalAllocated.GetLargeInteger();
    }
}


UNTFS_EXPORT
BOOLEAN
NTFS_ATTRIBUTE_RECORD::QueryExtentList(
    OUT PNTFS_EXTENT_LIST   ExtentList
    ) CONST
/*++

Routine Description:

Arguments:

    None.

Return Value:

    A pointer to the extent list.  A return value of NULL indicates
    that the attribute is resident or that an error occurred processing
    the compressed mapping pairs.  (Clients should use IsResident to
    determine whether the attribute value is resident.)

--*/
{
    DebugPtrAssert( _Data );

    if( _Data->FormCode == NONRESIDENT_FORM &&
        ExtentList->Initialize( _Data->Form.Nonresident.LowestVcn,
                                (PVOID)((PBYTE)_Data +
                                    _Data->Form.Nonresident.MappingPairsOffset),
                                 _MaximumLength -
                                    _Data->Form.Nonresident.
                                        MappingPairsOffset ) ) {

        return TRUE;

    } else {

        return FALSE;
    }
}


BOOLEAN
NTFS_ATTRIBUTE_RECORD::IsMatch(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name,
    IN  PCVOID              Value,
    IN  ULONG               ValueLength
    ) CONST
/*++

Routine Description:

    This method determines whether the attribute record matches the
    parameters given.

Arguments:

    Type        --  Supplies the type code of the attribute.  This
                        is the primary key, and must always be present.
    Name        --  Supplies a name to match.  A name of NULL is the
                        same as specifying the null string.
    Value       --  Supplies the value to match.  If this argument is
                        null, any value matches.  Only resident
                        attributes can be checked for value matches.
    ValueLength --  Supplies the length of the value (if any).

Notes:

    Value matching is not supported for nonresident attribute values;
    if a Value parameter is supplied, then no non-resident attribute
    records will match.

--*/
{
    DSTRING RecordName;

    DebugPtrAssert( _Data );

    if( Type != _Data->TypeCode ) {

        return FALSE;
    }

    if( Name != NULL ) {

        if( !RecordName.Initialize((PWSTR)((PBYTE)_Data + _Data->NameOffset),
                                   _Data->NameLength ) ) {

            return FALSE;
        }

        if( Name->Strcmp( &RecordName ) != 0 ) {

            return FALSE;
        }
    } else if (_Data->NameLength) {
        return FALSE;
    }

    if( Value != NULL &&
        ( _Data->FormCode != RESIDENT_FORM ||
          ValueLength != _Data->Form.Resident.ValueLength ||
          memcmp( Value,
                  (PBYTE)_Data + _Data->Form.Resident.ValueOffset,
                  (UINT) ValueLength ) ) ) {

        return FALSE;
    }

    return TRUE;
}


LONG
CompareAttributeRecords(
    IN  PCNTFS_ATTRIBUTE_RECORD Left,
    IN  PCNTFS_ATTRIBUTE_RECORD Right,
    IN  PCNTFS_UPCASE_TABLE     UpcaseTable
    )
/*++

Routine Description:

    This method compares two attribute records to determine their
    correct ordering in the File Record Segment.

Arguments:

    Left        --  Supplies the left-hand operand of the comparison.
    Right       --  Supplies the right-hand operand of the comparison.
    UpcaseTable --  Supplies the upcase table for the volume.
                    If this parameter is NULL, name comparison
                    cannot be performed.

Return Value:

    <0 if Left is less than Right
     0 if Left equals Right
    >0 if Left is greater than Right.

Notes:

    Attribute records are ordered first by type code and then
    by name.  An attribute record without a name is less than
    any attribute record of the same type with a name.

    Name comparision is first done case-insensitive; if the names
    are equal by that metric, a case-sensitive comparision is made.

    The UpcaseTable parameter may be omitted if either or both names
    are zero-length, or if they are identical (including case).
    Otherwise, it must be supplied.

--*/
{
    ULONG Result;

    // First, compare the type codes:
    //
    Result = Left->QueryTypeCode() - Right->QueryTypeCode();

    if( Result != 0 ) {

        return Result;
    }

    // They have the same type code, so we have to compare the names.
    // Pass in TRUE for the IsAttribute parameter, to indicate that
    // we are comparing attribute names.
    //
    return( NtfsUpcaseCompare( Left->GetName(),
                               Left->QueryNameLength(),
                               Right->GetName(),
                               Right->QueryNameLength(),
                               UpcaseTable,
                               TRUE ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\attrlist.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    attrlist.cxx

Abstract:

    This module contains the member function definitions for
    NTFS_ATTRIBUTE_LIST, which models an ATTRIBUTE_LIST Attribute
    in an NTFS File Record Segment.

    If a file has any external attributes (i.e. if it has more than
    one File Record Segment), then it will have an ATTRIBUTE_LIST
    attribute.  This attribute's value consists of a series of
    Attribute List Entries, which describe the attribute records
    in the file's File Record Segments.  There is an entry for each
    attribute record attached to the file, including the attribute
    records in the base File Record Segment, and in particular
    including the attribute records which describe the ATTRIBUTE_LIST
    attribute itself.

    An entry in the Attribute List gives the type code and name (if any)
    of the attribute, along with the LowestVcn of the attribute record
    (zero if the attribute record is Resident) and a segment reference
    (which combines an MFT VCN with a sequence number) showing where
    the attribute record may be found.

    The entries in the Attribute List are sorted first by attribute
    type code and then by name.  Note that two attributes can have the
    same type code and name only if they can be distinguished by
    value.

Author:

    Bill McJohn (billmc) 12-Aug-1991

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "wstring.hxx"
#include "hackwc.hxx"

#include "attrlist.hxx"
#include "attrrec.hxx"
#include "upcase.hxx"

#include "message.hxx"
#include "rtmsg.h"


ULONG
CompareAttributeListEntries(
    IN PCATTRIBUTE_LIST_ENTRY   Left,
    IN PCATTRIBUTE_LIST_ENTRY   Right,
    IN PCNTFS_UPCASE_TABLE      UpcaseTable
    )
/*++

Routine Description:

    This function compares two attribute list entries.

Arguments:

    Left        --  Supplies the left hand of the comparison
    Right       --  Supplies the right hand of the comparison
    UpcaseTable --  Supplies the volume upcase table.

Return Value:

    <0 if Left is less than Right
     0 if Left equals Right
    >0 if Left is greater than Right.

Notes:

    Attribute List Entries are ordered first by type code, then
    by name, and finally by lowest VCN.  An attribute list entry
    with no name is less than any entry of the same type code with
    a name.

    Name comparision is first done case-insensitive; if the names
    are equal by that metric, a case-sensitive comparision is made.

    The UpcaseTable parameter may be omitted if either or both names
    are zero-length, or if they are identical (including case).
    Otherwise, it must be supplied.

--*/
{
    LONG Result;

    // First, compare the type codes:
    //
    Result = Left->AttributeTypeCode - Right->AttributeTypeCode;

    if( Result != 0 ) {

        return Result;
    }

    // The entries have the same type code, so we compare the
    // names.  Pass in TRUE for the IsAttribute parameter, to
    // indicate that we are comparing attribute names.
    //
    Result = NtfsUpcaseCompare( NameFromEntry( Left ),
                                Left->AttributeNameLength,
                                NameFromEntry( Right ),
                                Right->AttributeNameLength,
                                UpcaseTable,
                                TRUE );

    if( Result != 0 ) {

        return Result;
    }

    // These two entries have the same type code and name;
    // compare the lowest VCN.
    //
    if( Left->LowestVcn < Right->LowestVcn ) {

        Result = -1;

    } else if( Left->LowestVcn < Right->LowestVcn ) {

        Result = 1;

    } else {

        Result = 0;
    }

    return Result;
}


DEFINE_CONSTRUCTOR( NTFS_ATTRIBUTE_LIST, NTFS_ATTRIBUTE );


NTFS_ATTRIBUTE_LIST::~NTFS_ATTRIBUTE_LIST(
    )
{
    Destroy();
}

VOID
NTFS_ATTRIBUTE_LIST::Construct(
    )
/*++

Routine Description:

    Worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _LengthOfList = 0;
    _UpcaseTable = NULL;
}

VOID
NTFS_ATTRIBUTE_LIST::Destroy(
    )
/*++

Routine Description:

    Worker function for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _LengthOfList = 0;
    _UpcaseTable = NULL;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      ULONG               ClusterFactor,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
    )
/*++

Routine Description:

    This method initializes an empty attribute list.

Arguments:

    Drive           -- supplies the drive on which the attribute list resides
    ClusterFactor   -- supplies the cluster factor for that drive
    UpcaseTable     -- supplies the volume upcase table.

Return Value:

    TRUE upon successful completion.

Notes:

    UpcaseTable may be NULL if the client will never compare
    named attribute records.

--*/
{
    Destroy();

    if( !_Mem.Initialize() ||
        !NTFS_ATTRIBUTE::Initialize( Drive,
                                     ClusterFactor,
                                     NULL,
                                     0,
                                     $ATTRIBUTE_LIST ) ) {

        return FALSE;
    }

    _UpcaseTable = UpcaseTable;
    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE        Drive,
    IN      ULONG                   ClusterFactor,
    IN      PCNTFS_ATTRIBUTE_RECORD AttributeRecord,
    IN      PNTFS_UPCASE_TABLE      UpcaseTable
    )
/*++

Routine Description:

    This method initializes an attribute list based on an
    attribute record.

Arguments:

    Drive           -- supplies the drive on which the attribute list resides
    ClusterFactor   -- supplies the cluster factor for that drive
    AttributeRecord -- supplies the attribute record describing the
                        attribute list.
    UpcaseTable     -- supplies the volume upcase table.

Return Value:

    TRUE upon successful completion.

Notes:

    This method does not read the attribute list.

    UpcaseTable may be NULL if the client will never compare
    named attribute records.

--*/
{
    Destroy();

    if( !_Mem.Initialize() ||
        !NTFS_ATTRIBUTE::Initialize( Drive,
                                     ClusterFactor,
                                     AttributeRecord ) ) {

        return FALSE;
    }

    _UpcaseTable = UpcaseTable;
    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::VerifyAndFix(
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    IN OUT  PMESSAGE        Message,
    IN      VCN             FileNumber,
    OUT     PBOOLEAN        Tube,
    IN OUT  PBOOLEAN        DiskErrorsFound
    )
/*++

Routine Description:

    This routine verifies and fixes this attribute list under
    the assumption that this class was initialized with an
    attribute record that was itself VerifiedAndFixed.

    In other words, this routine will check the issues specific
    to the $ATTRIBUTE_LIST attribute.

Arguments:

    FixLevel        - Supplies the fix up level.
    VolumeBitmap    - Supplies the volume bitmap.
    Message         - Supplies an outlet for messages.
    FileNumber      - Supplies the file number for the file that owns
                        this attribute list.
    Tube            - Returns whether or not the attribute list is beyond
                        repair.
    DiskErrorsFound - Supplies whether or not disk errors have been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT                 file_size;
    BIG_INT                 alloc_size;
    BIG_INT                 valid_size;
    PATTRIBUTE_LIST_ENTRY   p;
    ULONG                   length;
    BOOLEAN                 need_write;
    BOOLEAN                 changes;
    BOOLEAN                 error;
    PCNTFS_EXTENT_LIST      extent_list;
    ULONG                   num_extents;
    ULONG                   i;
    VCN                     next_vcn;
    LCN                     current_lcn;
    BIG_INT                 run_length;
    BIG_INT                 temp_length;

    DebugAssert(VolumeBitmap);
    DebugAssert(Message);
    DebugAssert(Tube);

    *Tube = FALSE;

    // If the attribute is non-resident then make sure that the
    // lowest vcn is 0 and the the three size parameters make sense.

    if (!GetResidentValue()) {

        QueryValueLength(&file_size, &alloc_size, &valid_size);

        temp_length = QueryClusterFactor()*
                      GetDrive()->QuerySectorSize()*
                      GetExtentList()->QueryNextVcn();

        error = FALSE;
        if (GetExtentList()->QueryLowestVcn() != 0) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_TAG_ATTR_LOWEST_VCN_IS_NOT_ZERO,
                         "%x%I64x%I64x",
                         QueryTypeCode(),
                         GetExtentList()->QueryLowestVcn().GetLargeInteger(),
                         FileNumber.GetLargeInteger());

            error = TRUE;
        } else if (alloc_size != temp_length) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_TAG_ATTR_INCORRECT_ALLOCATE_LENGTH,
                         "%x%I64x%I64x%I64x",
                         QueryTypeCode(),
                         alloc_size.GetLargeInteger(),
                         temp_length.GetLargeInteger(),
                         FileNumber.GetLargeInteger());

            error = TRUE;
        }

        if (error) {

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST,
                                "%d", FileNumber.GetLowPart());

            *Tube = TRUE;
            return TRUE;
        }
    }


    // Read the attribute.  If it is not readable then it must be tubed.

    if (!ReadList()) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_ATTR_LIST,
                            "%d", FileNumber.GetLowPart());

        *Tube = TRUE;
        return TRUE;
    }


    // Go through the attribute list entries and make sure that
    // they're all ok.  If any of them are not good then delete
    // them.

    need_write = FALSE;

    p = (PATTRIBUTE_LIST_ENTRY) _Mem.GetBuf();
    length = 0;
    while (length + sizeof(ATTRIBUTE_TYPE_CODE) + sizeof(USHORT) <
           _LengthOfList) {

        // Make sure that the record fits inside the attribute list.

        if (length + p->RecordLength > _LengthOfList) {
            break;
        }

        // If the record length is zero then break out of this loop.

        if (!p->RecordLength) {
            break;
        }

        // Make sure the name fits inside the attribute list entry.

        error = FALSE;
        if (((p->RecordLength & 0x7) != 0)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LIST_ENTRY_LENGTH_MISALIGNED,
                         "%x%x%x%I64x",
                         p->AttributeTypeCode,
                         p->Instance,
                         p->RecordLength,
                         FileNumber.GetLargeInteger());

            error = TRUE;
        } else if (p->AttributeNameLength != 0) {
            if (p->AttributeNameLength + p->AttributeNameOffset >
                p->RecordLength) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ATTR_NAME_IN_ATTR_LIST_ENTRY,
                             "%x%x%x%x%x%I64x",
                             p->AttributeTypeCode,
                             p->Instance,
                             p->AttributeNameLength,
                             p->AttributeNameOffset,
                             p->RecordLength,
                             FileNumber.GetLargeInteger());
                error = TRUE;
            } else if (p->AttributeNameOffset <
                       FIELD_OFFSET(ATTRIBUTE_LIST_ENTRY, AttributeName)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_NAME_OFFSET_IN_ATTR_LIST_ENTRY_TOO_SMALL,
                             "%x%x%x%x%I64x",
                             p->AttributeTypeCode,
                             p->Instance,
                             p->AttributeNameOffset,
                             FIELD_OFFSET(ATTRIBUTE_LIST_ENTRY, AttributeName),
                             FileNumber.GetLargeInteger());
                error = TRUE;
            }
        }

        if (error) {

            need_write = TRUE;

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST_ENTRY,
                             "%d%d", p->AttributeTypeCode,
                                     FileNumber.GetLowPart());

            _LengthOfList -= p->RecordLength;

            memmove(p,
                    (PCHAR) p + p->RecordLength,
                    (UINT) (_LengthOfList - length));

            p = (PATTRIBUTE_LIST_ENTRY) _Mem.GetBuf();
            length = 0;
            continue;
        }

        length += p->RecordLength;
        p = NextEntry(p);
    }


    if (length != _LengthOfList) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ATTR_LIST_LENGTH,
                     "%x%x%I64x",
                     length,
                     _LengthOfList,
                     FileNumber.GetLargeInteger());

        need_write = TRUE;

        Message->DisplayMsg(MSG_CHK_NTFS_ATTR_LIST_TRUNC,
                         "%d", FileNumber.GetLowPart());
        _LengthOfList = length;
    }


    // Now that the attribute list is valid, it must next be sorted.

    if (!Sort(&changes)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {
        Message->DisplayMsg(MSG_CHK_NTFS_UNSORTED_ATTR_LIST,
                         "%d", FileNumber.GetLowPart());
        need_write = TRUE;
    }

    if (need_write) {

        if (DiskErrorsFound) {
            *DiskErrorsFound = TRUE;
        }

        //
        // Make sure attr list is not cross linked before writing out the list
        //

        if (!*Tube && !GetResidentValue()) {

            extent_list = GetExtentList();
            num_extents = extent_list->QueryNumberOfExtents();

            for (i = 0; i < num_extents; i++) {

                if (!extent_list->QueryExtent(i, &next_vcn, &current_lcn,
                                              &run_length)) {

                    DebugAbort("Could not query extent");
                    return FALSE;
                }

                if (current_lcn == LCN_NOT_PRESENT) {
                    continue;
                }


                // Make sure that the run is free before allocating.
                // If it is not, this indicates a cross-link.

                if (!VolumeBitmap->IsFree(current_lcn, run_length)) {

                    DebugPrintTrace(("cross-linked run starts at 0x%I64x for 0x%I64x\n",
                                     current_lcn.GetLargeInteger(), run_length.GetLargeInteger()));

                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LIST_CROSS_LINKED,
                                 "%I64x%I64x%I64x",
                                 current_lcn.GetLargeInteger(),
                                 run_length.GetLargeInteger(),
                                 FileNumber.GetLargeInteger());

                    *Tube = TRUE;

                    return TRUE;
                }
            }
        }


        if (FixLevel != CheckOnly && !WriteList(VolumeBitmap)) {

            DebugAbort("Cant write readable attribute list");
            *Tube = TRUE;
            return TRUE;
        }
    }

    return TRUE;
}



BOOLEAN
NTFS_ATTRIBUTE_LIST::AddEntry(
    IN ATTRIBUTE_TYPE_CODE      Type,
    IN VCN                      LowestVcn,
    IN PCMFT_SEGMENT_REFERENCE  SegmentReference,
    IN USHORT                   InstanceTag,
    IN PCWSTRING                Name
    )
/*++

Routine Description:

    This adds an Attribute List Entry to the list.

Arguments:

    Type                --  supplies the attribute type code of the
                            attribute record corresponding to this entry
    LowestVcn           --  supplies the record's LowestVcn
    SegmentReference    --  supplies the location of the record
    InstanceTag         --  supplies the record's attribute instance tag.
    Name                --  supplies the name associated with the
                            record (NULL if it has no name).

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG LengthOfNewEntry;
    ULONG NewLengthOfList;
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG EntryOffset, NameLength;


    // Compute the size of the new entry and the new length of the
    // list with this entry added.
    //
    NameLength = ( Name == NULL ) ? 0 : (Name->QueryChCount());

    LengthOfNewEntry = QuadAlign( sizeof(ATTRIBUTE_LIST_ENTRY) +
                                            NameLength * sizeof(WCHAR) );

    NewLengthOfList = _LengthOfList + LengthOfNewEntry;

    // If our existing buffer isn't big enough, stretch it to
    // hold the new entry.

    if( !_Mem.Resize( NewLengthOfList ) ) {

        return FALSE;
    }

    // Scan forward to the point at which the new entry should
    // be inserted.

    CurrentEntry = FindEntry( Type, Name, LowestVcn, &EntryOffset );

    if (CurrentEntry == NULL)
        return FALSE;   // fail as there is no insertion point

    // Insert a new entry at CurrentEntry.

    memmove( (PBYTE)CurrentEntry + LengthOfNewEntry,
             (PVOID)CurrentEntry,
             _LengthOfList - EntryOffset );

    memset( (PVOID)CurrentEntry, '\0', LengthOfNewEntry );

    _LengthOfList = NewLengthOfList;

    // Fill in the new entry

    CurrentEntry->AttributeTypeCode = Type;
    CurrentEntry->RecordLength = (USHORT)LengthOfNewEntry;
    CurrentEntry->AttributeNameLength = (UCHAR)NameLength;
    CurrentEntry->LowestVcn = LowestVcn;
    CurrentEntry->SegmentReference = *SegmentReference;
    CurrentEntry->Instance = InstanceTag;
    CurrentEntry->AttributeNameOffset = FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY,
                                                      AttributeName );

    if( Name != NULL ) {

        Name->QueryWSTR( 0,
                         TO_END,
                         NameFromEntry( CurrentEntry ),
                         Name->QueryChCount(),
                         FALSE );
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::DeleteEntry(
    IN ULONG EntryIndex
    )
/*++

Routine Description:

    This method deletes the nth entry from the list.

Arguments:

    EntryIndex  --  supplies the index of the entry to be deleted

Return Value:

    TRUE upon successful completion.  Note that if there are
    not enough entries, this method returns TRUE.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;
    ULONG BytesToRemove;
    ULONG i;


    // Scan forward to the requested entry

    CurrentOffset = 0;
    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(_Mem.GetBuf());

    if( _LengthOfList == 0 ) {

        // The list is empty.

        return TRUE;
    }


    for( i = 0; i < EntryIndex; i++ ) {

        CurrentOffset += CurrentEntry->RecordLength;

        if( CurrentOffset >= _LengthOfList ) {

            // We ran out of entries.

            return TRUE;
        }

        CurrentEntry = NextEntry( CurrentEntry );
    }



    // Delete the entry.

    BytesToRemove = CurrentEntry->RecordLength;

    DebugAssert( CurrentOffset + BytesToRemove <= _LengthOfList );

    memmove( CurrentEntry,
             (PBYTE)CurrentEntry + BytesToRemove,
             _LengthOfList - (CurrentOffset + BytesToRemove) );

    _LengthOfList -= BytesToRemove;

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::DeleteCurrentEntry(
    IN PATTR_LIST_CURR_ENTRY    Entry
    )
/*++

Routine Description:

    This method deletes the current entry from the list.

Arguments:

    Entry  --  supplies the entry to delete

Return Value:

    TRUE upon successful completion.  Note that if there are
    not enough entries, this method returns TRUE.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;
    ULONG BytesToRemove;
    ULONG i;


    if( _LengthOfList == 0 ) {

        // The list is empty.

        return TRUE;
    }

    CurrentEntry = Entry->CurrentEntry;
    CurrentOffset = Entry->CurrentOffset;

    if( CurrentOffset >= _LengthOfList ) {

        // We ran out of entries.

        return TRUE;
    }

    // Delete the entry.

    BytesToRemove = CurrentEntry->RecordLength;

    DebugAssert( CurrentOffset + BytesToRemove <= _LengthOfList );

    memmove( CurrentEntry,
             (PBYTE)CurrentEntry + BytesToRemove,
             _LengthOfList - (CurrentOffset + BytesToRemove) );

    _LengthOfList -= BytesToRemove;

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::DeleteEntry(
    IN ATTRIBUTE_TYPE_CODE      Type,
    IN VCN                      LowestVcn,
    IN PCWSTRING                Name,
    IN PCMFT_SEGMENT_REFERENCE  SegmentReference
    )
/*++

Routine Description:

    This method deletes from the list the first entry which matches
    its parameters.  This method is used when deleting a non-unique
    (resident) attribute.  It may also be used to delete the entry
    for a known attribute record (for instance, when we move shuffle
    records between File Record Segments).

Arguments:

    Type                --  Supplies the attribute type code of the
                            entry to be deleted.
    Name                --  Supplies the name of the entry to be deleted;
                            may be NULL, in which case it is ignored.
    LowestVCN           --  Supplies the LowestVcn of the entry to delete.
    SegmentReference    --  Supplies the segment reference field of the
                            entry to be deleted; may be NULL, in which
                            case it is ignored.

Return Value:

    TRUE upon successful completion.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG EntryOffset;
    ULONG BytesToRemove;
    PWSTR NameBuffer = NULL;
    ULONG NameLength;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->QueryWSTR();

        if( NameBuffer == NULL ) {

            return FALSE;
        }
    }


    // Scan forward to the first entry that matches the input

    CurrentEntry = FindEntry( Type, Name, LowestVcn, &EntryOffset );

    if (CurrentEntry == NULL) {
        if (NameBuffer)
            FREE(NameBuffer);
        return TRUE;    // assume nothing to delete
    }

    if( SegmentReference != NULL ) {

        // The caller specified a segment reference, so we have to
        // scan through the matching entries until we find that segment
        // reference or we run out of matching entries.

        while( EntryOffset < _LengthOfList &&
               CurrentEntry->AttributeTypeCode == Type &&
               ( Name == NULL ||
                 (NameLength == CurrentEntry->AttributeNameLength &&
                  memcmp( NameBuffer,
                          NameFromEntry(CurrentEntry),
                          NameLength * sizeof(WCHAR) ) == 0) ) &&
               CurrentEntry->LowestVcn == LowestVcn &&
               memcmp( SegmentReference,
                       &CurrentEntry->SegmentReference,
                       sizeof(MFT_SEGMENT_REFERENCE) ) != 0 ) {

            EntryOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry(CurrentEntry);
        }
    }

    // If we've gone off the end of the list, or if the type, name,
    // and LowestVcn don't match, then we don't have any matching
    // records.

    if( EntryOffset >= _LengthOfList ||
        CurrentEntry->AttributeTypeCode != Type ||
        ( Name != NULL &&
          ( NameLength != CurrentEntry->AttributeNameLength ||
            memcmp( NameBuffer,
                    NameFromEntry(CurrentEntry),
                    NameLength * sizeof(WCHAR) ) != 0 ) ) ||
        CurrentEntry->LowestVcn != LowestVcn ) {

        // There are no matching entries, so there's nothing to
        // delete.

        if( NameBuffer != NULL ) {

            FREE( NameBuffer );
        }

        return TRUE;
    }


    // Delete the entry.

    BytesToRemove = CurrentEntry->RecordLength;

    DebugAssert( EntryOffset + BytesToRemove <= _LengthOfList );

    memmove( CurrentEntry,
             (PBYTE)CurrentEntry + BytesToRemove,
             _LengthOfList - (EntryOffset + BytesToRemove) );

    _LengthOfList -= BytesToRemove;

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::DeleteEntries(
    IN ATTRIBUTE_TYPE_CODE  Type,
    IN PCWSTRING            Name
    )
/*++

Routine Description:

    This method deletes all entries in the list which match the input.
    This is used when deleting a unique attribute, since all attribute
    records for that attribute type-code and name will be removed.

Arguments:

    Type                --  Supplies the attribute type code of the
                            entry to be deleted.
    Name                --  Supplies the name of the entry to be deleted;
                            may be NULL, in which case it is ignored.

Return Value:

    TRUE upon successful completion.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG EntryOffset;
    ULONG BytesToRemove;
    ULONG NameLength;
    PWSTR NameBuffer = NULL;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->QueryWSTR();

        if( NameBuffer == NULL ) {

            return FALSE;
        }
    }


    // find the first matching entry.

    CurrentEntry = FindEntry( Type, Name, 0, &EntryOffset );

    if (CurrentEntry) {
        while( EntryOffset < _LengthOfList &&
               CurrentEntry->AttributeTypeCode == Type &&
               ( Name == NULL ||
                 ( NameLength == CurrentEntry->AttributeNameLength &&
                   memcmp( NameBuffer,
                           NameFromEntry( CurrentEntry ),
                           NameLength * sizeof(WCHAR) ) == 0 ) ) ) {

            // This entry matches, so we delete it.  Note that instead of
            // incrementing CurrentEntry and EntryOffset, we draw the
            // succeeding entries down to the current point.

            BytesToRemove = CurrentEntry->RecordLength;

            DebugAssert( EntryOffset + BytesToRemove <= _LengthOfList );

            memmove( CurrentEntry,
                     (PBYTE)CurrentEntry + BytesToRemove,
                     _LengthOfList - (EntryOffset + BytesToRemove) );

            _LengthOfList -= BytesToRemove;
        }
    }

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }

    return TRUE;
}


NONVIRTUAL
BOOLEAN
NTFS_ATTRIBUTE_LIST::IsInList(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name
    ) CONST
/*++

Routine Description:

Arguments:

    Type        -- supplies the type code of the attribute in question.
    Name        -- supplies the name of the attribute in question.
                    (may be NULL, in which case the attribute has no name.)
Return Value:

    TRUE if there is an entry in the attribute list with this
    type code and (if specified) name.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG EntryOffset, CurrentEntryIndex;
    ULONG NameLength;
    PCWSTR NameBuffer = NULL;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->GetWSTR();

    } else {

        NameLength = 0;
    }


    // Find the first entry which matches this type code & name.

    CurrentEntry = FindEntry( Type, Name, 0,
                                &EntryOffset, &CurrentEntryIndex );

    if( CurrentEntry == NULL ||
        EntryOffset >= _LengthOfList ||
        CurrentEntry->AttributeTypeCode != Type ||
        NameLength != CurrentEntry->AttributeNameLength ||
        (NameLength != 0 &&
         NtfsUpcaseCompare( NameBuffer,
                            NameLength,
                            NameFromEntry( CurrentEntry ),
                            NameLength,
                            _UpcaseTable,
                            TRUE) != 0) ) {

        // We've gone too far.  There are no matching entries.

        return FALSE;
    }

    return TRUE;
}

#if 0

BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryEntry(
    IN  ULONG                   EntryIndex,
    OUT PATTRIBUTE_TYPE_CODE    Type,
    OUT PVCN                    LowestVcn,
    OUT PMFT_SEGMENT_REFERENCE  SegmentReference,
    OUT PUSHORT                 InstanceTag,
    OUT PWSTRING                Name
    ) CONST
/*++

Routine Description:

    This method fetches the nth entry in the list.

Arguments:

    EntryIndex          --  supplies the index into the list of the
                            entry to fetch
    Type                --  receives the entry's attribute type code
    LowestVcn           --  receives the entry's LowestVcn
    SegmentReference    --  receives the entry's SegmentReference
    InstanceTag         --  receives the entry's attribute instance tag.
    Name                --  receives the entry's Name (if any)

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG i;
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;

    CurrentOffset = 0;
    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(((PNTFS_ATTRIBUTE_LIST) this)->_Mem.GetBuf());

    if( _LengthOfList == 0 ) {

        // The list is empty.

        return FALSE;
    }


    for( i = 0; i < EntryIndex; i++ ) {

        if (CurrentEntry->RecordLength == 0)
            return FALSE;

        CurrentOffset += CurrentEntry->RecordLength;

        if( CurrentOffset >= _LengthOfList ) {

            // We ran out of entries.

            return FALSE;
        }

        CurrentEntry = NextEntry( CurrentEntry );
    }

    *Type = CurrentEntry->AttributeTypeCode;
    *LowestVcn = CurrentEntry->LowestVcn;
    *SegmentReference = CurrentEntry->SegmentReference;
    *InstanceTag = CurrentEntry->Instance;

    if( !Name->Initialize( NameFromEntry( CurrentEntry ),
                           CurrentEntry->AttributeNameLength ) ) {

        return FALSE;
    }

    return TRUE;
}
#endif


BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryNextEntry(
    IN OUT PATTR_LIST_CURR_ENTRY   CurrEntry,
    OUT    PATTRIBUTE_TYPE_CODE    Type,
    OUT    PVCN                    LowestVcn,
    OUT    PMFT_SEGMENT_REFERENCE  SegmentReference,
    OUT    PUSHORT                 InstanceTag,
    OUT    PWSTRING                Name
    ) CONST
/*++

Routine Description:

    This method fetches the next entry in the list.

Arguments:

    NextEntry           --  supplies the pointer to the entry
    Type                --  receives the entry's attribute type code
    LowestVcn           --  receives the entry's LowestVcn
    SegmentReference    --  receives the entry's SegmentReference
    InstanceTag         --  receives the entry's attribute instance tag.
    Name                --  receives the entry's Name (if any)

Return Value:

    TRUE upon successful completion.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG                 CurrentOffset;

    DebugPtrAssert(CurrEntry);

    if (CurrEntry->CurrentEntry == NULL) {

        CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(((PNTFS_ATTRIBUTE_LIST) this)->_Mem.GetBuf());
        CurrEntry->CurrentEntry = CurrentEntry;
        CurrEntry->CurrentOffset = 0;

        *Type = CurrentEntry->AttributeTypeCode;
        *LowestVcn = CurrentEntry->LowestVcn;
        *SegmentReference = CurrentEntry->SegmentReference;
        *InstanceTag = CurrentEntry->Instance;

        if( !Name->Initialize( NameFromEntry( CurrentEntry ),
                               CurrentEntry->AttributeNameLength ) ) {

            return FALSE;
        }

        return TRUE;
    } else {

        CurrentEntry = CurrEntry->CurrentEntry;
        CurrentOffset = CurrEntry->CurrentOffset;
    }

    if( _LengthOfList == 0 ) {

        // The list is empty.

        return FALSE;
    }

    if ( CurrentEntry->RecordLength == 0 ) {

        // something is not right or it's the end

        return FALSE;
    }

    CurrentOffset += CurrentEntry->RecordLength;

    if( CurrentOffset >= _LengthOfList ) {

        // it's the end

        return FALSE;
    }

    CurrentEntry = NextEntry( CurrentEntry );

    CurrEntry->CurrentEntry = CurrentEntry;
    CurrEntry->CurrentOffset = CurrentOffset;

    *Type = CurrentEntry->AttributeTypeCode;
    *LowestVcn = CurrentEntry->LowestVcn;
    *SegmentReference = CurrentEntry->SegmentReference;
    *InstanceTag = CurrentEntry->Instance;

    if( !Name->Initialize( NameFromEntry( CurrentEntry ),
                           CurrentEntry->AttributeNameLength ) ) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryEntry(
    IN  MFT_SEGMENT_REFERENCE   SegmentReference,
    IN  USHORT                  InstanceTag,
    OUT PATTRIBUTE_TYPE_CODE    Type,
    OUT PVCN                    LowestVcn,
    OUT PWSTRING                Name
    ) CONST
/*++

Routine Description:

    This routine returns the type, lowestvcn, and name of the attribute
    list entry with the given segment reference and instance tag.

Arguments:

    SegmentReference    - Supplies the entry's segment reference.
    InstanceTag         - Supplies the entry's instance tag.
    Type                - Returns the entry's type code.
    LowestVcn           - Returns the entry's lowest vcn.
    Name                - Returns the entry's name.

Return Value:

    FALSE   - An entry with the given segment reference and instance was
                not found.
    TRUE    - Success.

--*/
{
    ULONG i;
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;

    CurrentOffset = 0;
    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(_Mem.GetBuf());

    if( _LengthOfList == 0 ) {

        // The list is empty.

        return FALSE;
    }


    for( i = 0; ; i++ ) {

        if (CurrentEntry->Instance == InstanceTag &&
            CurrentEntry->SegmentReference == SegmentReference) {

            break;
        }

        CurrentOffset += CurrentEntry->RecordLength;

        if( CurrentOffset >= _LengthOfList ) {

            // We ran out of entries.

            return FALSE;
        }

        CurrentEntry = NextEntry( CurrentEntry );
    }

    *Type = CurrentEntry->AttributeTypeCode;
    *LowestVcn = CurrentEntry->LowestVcn;

    if( !Name->Initialize( NameFromEntry( CurrentEntry ),
                           CurrentEntry->AttributeNameLength ) ) {

        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
PCATTRIBUTE_LIST_ENTRY
NTFS_ATTRIBUTE_LIST::GetNextAttributeListEntry(
    IN  PCATTRIBUTE_LIST_ENTRY  CurrentEntry
    ) CONST
/*++

Routine Description:

    This routine fetches the next attribute list entry structure.

Arguments:

    CurrentEntry    - Supplies the current attribute list entry.
                        Supplying NULL as the current entry specifies that
                        you want the first entry in the list.

Return Value:

    The next attribute list entry or NULL if the current entry
    is at the end of the list.

--*/
{
    ULONG   CurrentOffset;

    if (!_LengthOfList) {
        return NULL;
    }

    if (!CurrentEntry) {
        return (PCATTRIBUTE_LIST_ENTRY) _Mem.GetBuf();
    }

    CurrentOffset = (ULONG)((PCHAR) CurrentEntry - (PCHAR) _Mem.GetBuf());

    if (CurrentOffset + CurrentEntry->RecordLength >= _LengthOfList) {
        return NULL;
    }

    return (PCATTRIBUTE_LIST_ENTRY) ((PCHAR) CurrentEntry + CurrentEntry->RecordLength);
}



BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryExternalReference(
    IN  ATTRIBUTE_TYPE_CODE     Type,
    OUT PMFT_SEGMENT_REFERENCE  SegmentReference,
    OUT PULONG                  EntryIndex,
    IN  PCWSTRING               Name,
    IN  PVCN                    DesiredVcn,
    OUT PVCN                    StartingVcn
    ) CONST
/*++

Routine Description:

    This method fetches an entry from the list based on a type code,
    name (optional), and VCN.

Arguments:

    Type                --  supplies the attribute type code to search for.
    SegmentReference    --  receives the entry's SegmentReference
    EntryIndex          --  receives the entry's index into the list
    Name                --  supplies the entry's name.  If this pointer
                            is NULL, attribute names are ignored.
    DesiredVcn          --  supplies a pointer to the VCN we're interested
                            in.  (Note that this pointer may be NULL if
                            the caller just wants the first entry for this
                            type & name.)
    StartingVcn         --  receives the LowestVcn of the entry found;
                            if this pointer is NULL, that information is
                            not returned.


Return Value:

    TRUE if a matching entry is found.

Notes:

    A client who wishes to find all the entries for a particular
    attribute can take advantage of the fact that the list is sorted
    by type code and name.  Thus, the client finds the first matching
    entry (using QueryExternalReference), and then queries successive
    entries by index until one doesn't match.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry, PreviousEntry;
    ULONG EntryOffset, CurrentEntryIndex;
    ULONG NameLength;
    PWSTR NameBuffer = NULL;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->QueryWSTR();

        if( NameBuffer == NULL ) {

            return FALSE;
        }
    }


    // The search algorithm for this method is slightly different than
    // the other methods for this class.  Instead of the first matching
    // entry, we want the last matching entry which has a LowestVcn field
    // less than or equal to *DesiredVcn.  (If DesiredVcn is NULL, we can
    // just return the first entry we find.)

    CurrentEntry = FindEntry( Type, Name, 0,
                                &EntryOffset, &CurrentEntryIndex );

    if( CurrentEntry == NULL ||
        EntryOffset >= _LengthOfList ||
        CurrentEntry->AttributeTypeCode != Type ||
        ( Name != NULL &&
          ( NameLength != CurrentEntry->AttributeNameLength ||
            memcmp( NameBuffer,
                    NameFromEntry( CurrentEntry ),
                    NameLength * sizeof(WCHAR) ) != 0 ) ) ||
        ( DesiredVcn != NULL &&
          CurrentEntry->LowestVcn > *DesiredVcn ) ) {

        // We've gone too far.  There are no matching entries.

        if( NameBuffer != NULL ) {

            FREE( NameBuffer );
        }

        return FALSE;
    }

    if( DesiredVcn != NULL ) {

        // The caller specified a particular VCN, so we have to find the
        // entry that contains it.  We do this by scanning forward until
        // we find an entry that is beyond what we want, and then backing
        // up one.  Since we passed the test above, we know that the
        // loop below will execute at least once, so PreviousEntry is
        // sure to get set.

        while( EntryOffset < _LengthOfList &&
               CurrentEntry->AttributeTypeCode == Type &&
               ( Name == NULL ||
                 ( NameLength == CurrentEntry->AttributeNameLength &&
                   memcmp( NameBuffer,
                           NameFromEntry( CurrentEntry ),
                           NameLength * sizeof(WCHAR) ) == 0 ) ) &&
               CurrentEntry->LowestVcn <= *DesiredVcn ) {

            PreviousEntry = CurrentEntry;
            CurrentEntryIndex += 1;
            EntryOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry( CurrentEntry );
        }

        // Now back up one, to the entry we really want:

        CurrentEntry = PreviousEntry;
        CurrentEntryIndex -= 1;
    }

    // Fill in the output parameters.

    memcpy( SegmentReference,
            &CurrentEntry->SegmentReference,
            sizeof( MFT_SEGMENT_REFERENCE ) );

    *EntryIndex = CurrentEntryIndex;

    if( StartingVcn != NULL ) {

        *StartingVcn = CurrentEntry->LowestVcn;
    }

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }

    return TRUE;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryNextAttribute(
    IN OUT PATTRIBUTE_TYPE_CODE TypeCode,
    IN OUT PWSTRING             Name
    ) CONST
/*++

Routine Description:

    This method determines the type code and name of the first
    attribute list which is strictly greater than the supplied
    type and name.

Arguments:

    TypeCode    --  supplies the current attribute type code.  Receives
                    the type code of the next attribute.  A returned type
                    code of $END indicates that there are no more attributes.
    Name        --  supplies the current name.  Receives the name of the
                    next attribute.


Return Value:

    TRUE upon successful completion.

Notes:

    This method is useful for iterating through the non-indexed
    attributes of a file, since there can only be one non-indexed
    attribute with a given type code and name in the file.  However,
    it offers no way of dealing with indexed attributes, which may
    be distinguished only by value.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentEntryOffset, CurrentEntryIndex;

    // Use FindEntry to get to the entry we want.  Note that we use
    // a LowestVcn of -1, to skip over all matching entries.

    if( (CurrentEntry = FindEntry( *TypeCode,
                                   Name,
                                   -1,
                                   &CurrentEntryOffset,
                                   &CurrentEntryIndex )) == NULL ) {

        // An error occurred searching the list.
        return FALSE;
    }

    if( CurrentEntryOffset >= _LengthOfList ) {

        // This is the end of the list; there are no more entries.

        *TypeCode = $END;

        return Name->Initialize("");
    }

    // OK, we have the entry we want.  Copy its type and name (if any).

    *TypeCode = CurrentEntry->AttributeTypeCode;

    if( !Name->Initialize( NameFromEntry(CurrentEntry),
                           CurrentEntry->AttributeNameLength ) ) {

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_ATTRIBUTE_LIST::ReadList(
    )
/*++

Routine Description:

    This method reads the list into the object's private buffer.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT ValueLength;
    ULONG BytesRead;

    // Determine the length of the list.

    QueryValueLength( &ValueLength );

    DebugAssert( ValueLength.GetHighPart() == 0 );

    _LengthOfList = ValueLength.GetLowPart();

    // Initialize our MEM object and use it to get the correct
    // amount of memory.

    if( !_Mem.Initialize() ||
        !_Mem.Acquire( (LONG)_LengthOfList ) ) {

        return FALSE;
    }

    // Read the attribute's value into our buffer.

    return( Read( _Mem.GetBuf(), 0, _LengthOfList, &BytesRead) &&
            BytesRead == _LengthOfList );
}



PATTRIBUTE_LIST_ENTRY
NTFS_ATTRIBUTE_LIST::FindEntry(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name,
    IN  VCN                 LowestVcn,
    OUT PULONG              EntryOffset,
    OUT PULONG              EntryIndex
    ) CONST
/*++

Routine Description:

    This method finds the first entry in the list which matches
    its input or, if there is no match, the first entry that
    would come after it (i.e. the place it would be if it were there).

Arguments:

    Type        -- supplies the attribute type code to find
    Name        -- supplies the name to find (may be NULL, in which case it
                    is ignored)
    LowestVcn   -- supplies the VCN to find.  A value of -1 indicates
                    we should skip all entries for this type and name.
    EntryOffset -- receives the offset into the list of the
                    returned pointer.  (May be NULL, in which case
                    this value is not returned.)
    EntryIndex  -- receives the index into the list of the returned
                    entry.  (May be NULL, in which case this value
                    is not returned.


Return Value:

    A pointer to the first entry in the list which matches the input.
    If there is no match, this method returns the next entry (i.e. the
    point at which a matching entry should be inserted).

    NULL is returned to indicate end of entry.

--*/
{
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset, CurrentIndex;
    ULONG NameLength;
    PWSTR NameBuffer = NULL;

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    if( Name != NULL ) {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->QueryWSTR();

        if( NameBuffer == NULL ) {

            return NULL;
        }
    }

    // Start at the beginning of the list.

    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(((PNTFS_ATTRIBUTE_LIST) this)->_Mem.GetBuf());
    CurrentOffset = 0;
    CurrentIndex = 0;

    // Scan forward to the first entry which has a type code
    // greater than or equal to the type code we want.

    while( CurrentOffset < _LengthOfList &&
           Type > CurrentEntry->AttributeTypeCode ) {

        CurrentIndex += 1;
        CurrentOffset += CurrentEntry->RecordLength;
        CurrentEntry = NextEntry( CurrentEntry );
    }


    // CurrentEntry now points at the first entry with an attribute
    // type code greater than or equal to the one we're seeking.
    // Within the group of entries with the same type code, the
    // entries are sorted first by name and then by LowestVcn.

    if( Name != NULL ) {

        // The caller specified a name name, so we need to scan
        // through the entries with this attribute type code for
        // the first entry with a name greater than or equal to
        // that name.

        while( CurrentOffset < _LengthOfList &&
               Type == CurrentEntry->AttributeTypeCode &&
               NtfsUpcaseCompare( NameBuffer,
                                  NameLength,
                                  NameFromEntry( CurrentEntry ),
                                  CurrentEntry->AttributeNameLength,
                                  _UpcaseTable,
                                  TRUE ) > 0 ) {

            CurrentIndex += 1;
            CurrentOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry( CurrentEntry );
        }

        // Now scan forward by LowestVcn through the attributes with
        // this type code and name.  Note that a search value of -1
        // for LowestVcn indicates we should skip all matching entries.

        while( CurrentOffset < _LengthOfList &&
               Type == CurrentEntry->AttributeTypeCode &&
               ( NameLength == CurrentEntry->AttributeNameLength &&
                 memcmp( NameBuffer,
                         NameFromEntry( CurrentEntry ),
                         NameLength * sizeof(WCHAR) ) == 0 ) &&
               ( (LowestVcn == -1) ||
                 (LowestVcn > CurrentEntry->LowestVcn) ) ) {

            CurrentIndex += 1;
            CurrentOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry( CurrentEntry );
        }

    } else {

        // The caller did not specify a name, so we only examine
        // entries without names.  These come before entries with
        // that same attribute type code that have names.  Scan
        // forward by LowestVcn through the entries that have this
        // attribute type code and no name.  Note that a search value
        // of -1 for LowestVcn indicates that we should skip all matching
        // entries.

        while( CurrentOffset < _LengthOfList &&
               Type == CurrentEntry->AttributeTypeCode &&
               CurrentEntry->AttributeNameLength == 0 &&
               ( (LowestVcn == -1) ||
                 (LowestVcn > CurrentEntry->LowestVcn) ) ) {

            CurrentIndex += 1;
            CurrentOffset += CurrentEntry->RecordLength;
            CurrentEntry = NextEntry( CurrentEntry );
        }
    }

    if( EntryOffset != NULL ) {

        *EntryOffset = CurrentOffset;
    }

    if( EntryIndex != NULL ) {

        *EntryIndex = CurrentIndex;
    }

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }

    return CurrentEntry;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::QueryAttributeRecord(
    OUT PVOID                   AttributeRecordData,
    IN  ULONG                   MaximumLength,
    OUT PNTFS_ATTRIBUTE_RECORD  AttributeRecord
    ) CONST
/*++

Routine Description:

    This routine computes an attribute record which corresponds to
    this attribute.

Arguments:

    AttributeRecordData - Supplies a buffer for the attribute record.
    MaximumLength       - Supplies the length of the buffer in bytes.
    AttributeRecord     - Returns the attribute record for this attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BIG_INT value_length;
    BIG_INT alloc_length;
    BIG_INT valid_length;

    DebugAssert(AttributeRecordData);
    DebugAssert(MaximumLength);
    DebugAssert(AttributeRecord);

    //LOGLOG: Is there a need to pass drive instead of NULL
    if (!AttributeRecord->Initialize(NULL, AttributeRecordData, MaximumLength)) {
        DebugAbort("Could not initialize attribute record.");
        return FALSE;
    }

    QueryValueLength(&value_length, &alloc_length, &valid_length);

    if (GetResidentValue()) {

        DebugAssert(value_length.GetHighPart() == 0);

        if (!AttributeRecord->CreateResidentRecord(GetResidentValue(),
                                                   value_length.GetLowPart(),
                                                   QueryTypeCode(),
                                                   NULL,
                                                   QueryFlags(),
                                                   QueryResidentFlags())) {

            return FALSE;
        }

    } else {

        if (!AttributeRecord->CreateNonresidentRecord(
                GetExtentList(),
                alloc_length,
                value_length,
                valid_length,
                QueryTypeCode(),
                NULL,
                QueryFlags(),
                (USHORT)QueryCompressionUnit())) {

            return FALSE;
        }

    }

    return TRUE;
}


BOOLEAN
SwapAttributeListEntries(
    IN OUT  PVOID   FirstAttributeListEntry
    )
/*++

Routine Description:

    This routine swaps 'FirstAttributeListEntry' with the next attribute
    list entry in the attribute list.  This method will fail if there is not
    enough memory available for a swap buffer.

Arguments:

    FirstAttributeListEntry - Supplies the first of two attribute list
                                entries to be swapped.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST   BufSize = 256;
    CHAR    buffer[BufSize];

    PATTRIBUTE_LIST_ENTRY   p1, p2;
    PCHAR                   q1, q2;
    PVOID                   buf;
    UINT                    first_entry_length;
    BOOLEAN                 alloc_buf;

    p1 = (PATTRIBUTE_LIST_ENTRY) FirstAttributeListEntry;
    q1 = (PCHAR) p1;

    first_entry_length = p1->RecordLength;

    if (first_entry_length > BufSize) {
        if (!(buf = MALLOC(first_entry_length))) {
            return FALSE;
        }
        alloc_buf = TRUE;
    } else {
        buf = buffer;
        alloc_buf = FALSE;
    }

    // Tuck away the first record.

    memcpy(buf, p1, first_entry_length);


    q2 = q1 + p1->RecordLength;
    p2 = (PATTRIBUTE_LIST_ENTRY) q2;


    // Overwrite first attribute record with second attribute record.

    memmove(p1, p2, (UINT) p2->RecordLength);


    // Copy over the first attribute record after the second.

    memcpy(q1 + p1->RecordLength, buf, first_entry_length);

    if (alloc_buf) {
        FREE(buf);
    }

    return TRUE;
}


INT
CompareInstances(
    IN  PCATTRIBUTE_LIST_ENTRY  Left,
    IN  PCATTRIBUTE_LIST_ENTRY  Right
    )
/*++

Routine Description:

    This routine compares the left and right instance and segment
    reference values for these two attribute list entries.

Arguments:

    Left    - Supplies the left side of the comparison.
    Right   - Supplies the right side of the comparison.

Return Value:

    < 0 - Left < Right
    0   - Left == Right
    > 0 - Left > Right

--*/
{
    BIG_INT l, r;

    // First compare the segment references as BIG_INTs.

    l = *((PBIG_INT) &Left->SegmentReference);
    r = *((PBIG_INT) &Right->SegmentReference);

    if (l < r) {
        return -1;
    }

    if (l > r) {
        return 1;
    }

    if (Left->Instance < Right->Instance) {
        return -1;
    }

    if (Left->Instance > Right->Instance) {
        return 1;
    }

    return 0;
}


BOOLEAN
NTFS_ATTRIBUTE_LIST::Sort(
    OUT PBOOLEAN    Changes
    )
/*++

Routine Description:

    This routine sorts an attribute list by type, name, and lowest vcn.
    It reports through Message if any attribute list entries are out
    of order.

Arguments:

    Changes - Returns whether or not a change was made.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN                 stable;
    PATTRIBUTE_LIST_ENTRY   prev, curr;
    PCHAR                   start;
    ULONG                   i;
    INT                     r;

    DebugAssert(Changes);

    *Changes = FALSE;

    start = (PCHAR) _Mem.GetBuf();

    stable = FALSE;

    while (!stable) {

        stable = TRUE;

        prev = (PATTRIBUTE_LIST_ENTRY) _Mem.GetBuf();
        DebugAssert(prev);

        for (i = 0; ; i++) {

            curr = NextEntry(prev);

            if ((ULONG)((PCHAR) curr - start) >= _LengthOfList) {
                break;
            }

            r = CompareAttributeListEntries( prev,
                                             curr,
                                             _UpcaseTable );

            if( r > 0 ) {

                // prev is greater than curr--these two
                // entries are out of order.  Swap them.

                PIO_DP_DRIVE    drive = GetDrive();

                if (drive) {

                    PMESSAGE msg = drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_LIST_ENTRIES_OUT_OF_ORDER,
                                 "%x%x%x%x",
                                 prev->AttributeTypeCode,
                                 prev->Instance,
                                 curr->AttributeTypeCode,
                                 curr->Instance);
                    }
                }

                if (!SwapAttributeListEntries(prev)) {
                    return FALSE;
                }

                *Changes = TRUE;
                stable = FALSE;
                break;

            } else if( r == 0 ) {

                // These two entries have the same type code, name,
                // and lowest vcn.  We must now insure that they
                // have different instance numbers.

                r = CompareInstances(prev, curr);

                if (r == 0) {

                    // Duplicates.  Remove them both.

                    PIO_DP_DRIVE    drive = GetDrive();

                    if (drive) {

                        PMESSAGE msg = drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_IDENTICAL_ATTR_LIST_ENTRIES,
                                     "%x%x",
                                     prev->AttributeTypeCode,
                                     prev->Instance);
                        }
                    }

                    if (!DeleteEntry(i + 1) ||
                        !DeleteEntry(i)) {

                        DebugAbort("Could not delete entry");
                        return FALSE;
                    }

                    *Changes = TRUE;
                    stable = FALSE;
                    break;
                }

                if (r > 0) {

                    // Out of order.  Swap.

                    if (!SwapAttributeListEntries(prev)) {
                        return FALSE;
                    }

                    // We don't set the 'Changes' flag here because
                    // attribute list entries don't have to be ordered by
                    // instance.

                    stable = FALSE;
                    curr = NextEntry(prev);
                }
            }

            prev = curr;
        }
    }

    return TRUE;
}

BOOLEAN
NTFS_ATTRIBUTE_LIST::ModifyInstanceTag(
    IN  PCNTFS_ATTRIBUTE_RECORD AttributeRecord,
    IN  MFT_SEGMENT_REFERENCE   SegmentReference,
    IN  USHORT                  NewInstanceTag
    )
/*++

Routine Description:

    Find an entry in the attribute list and change it's instance
    tag to the given value.


Arguments:

    AttributeRecord -
    SegmentReference -  These two objects describe the interesting
                        attribute list entry -- it's the entry for this
                        attribute record in this segment.

    NewInstanceTag -    The desired instance tag value.

Return Value:

    FALSE           - Failure (the entry could not be located)
    TRUE            - Success.

--*/
{
    ULONG i;
    PATTRIBUTE_LIST_ENTRY CurrentEntry;
    ULONG CurrentOffset;
    USHORT InstanceTag;

    InstanceTag = AttributeRecord->QueryInstanceTag();

    CurrentOffset = 0;
    CurrentEntry = (PATTRIBUTE_LIST_ENTRY)(_Mem.GetBuf());

    if( _LengthOfList == 0 ) {
        // The list is empty.
        return FALSE;
    }

    for (i = 0; ; i++) {

        if (CurrentEntry->Instance == InstanceTag &&
            CurrentEntry->SegmentReference == SegmentReference) {
            break;
        }

        CurrentOffset += CurrentEntry->RecordLength;

        if( CurrentOffset >= _LengthOfList ) {
            // We ran out of entries.
            return FALSE;
        }

        CurrentEntry = NextEntry(CurrentEntry);
    }

    CurrentEntry->Instance = NewInstanceTag;

    SetStorageModified();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\badfile.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    badfile.hxx

Abstract:

    This module contains the declarations for the NTFS_BAD_CLUSTER_FILE
    class, which models the bad cluster file for an NTFS volume.

    The DATA attribute of the bad cluster file is a non-resident
    attribute to which bad clusters are allocated.  It is stored
    as a sparse file with LCN = VCN.

Author:

    Bill McJohn (billmc) 18-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "numset.hxx"

#include "ntfsbit.hxx"
#include "mft.hxx"
#include "attrrec.hxx"
#include "attrib.hxx"

#include "badfile.hxx"
#include "ifssys.hxx"
#include "message.hxx"
#include "rtmsg.h"

#define BadfileDataNameData "$Bad"


DEFINE_EXPORTED_CONSTRUCTOR( NTFS_BAD_CLUSTER_FILE, NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_BAD_CLUSTER_FILE::~NTFS_BAD_CLUSTER_FILE(
    )
{
    Destroy();
}

VOID
NTFS_BAD_CLUSTER_FILE::Construct(
    )
/*++

Routine Description:

    Worker method for NTFS_BAD_CLUSTER_FILE construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataAttribute = NULL;
}

VOID
NTFS_BAD_CLUSTER_FILE::Destroy(
    )
/*++

Routine Description:

    Worker method for NTFS_BAD_CLUSTER_FILE destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE( _DataAttribute );
}


UNTFS_EXPORT
BOOLEAN
NTFS_BAD_CLUSTER_FILE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes an NTFS_BAD_CLUSTER_FILE object.

Arguments:

    Mft             -- Supplies the volume MasterFile Table.

--*/
{
    Destroy();

    return( NTFS_FILE_RECORD_SEGMENT::
                Initialize( BAD_CLUSTER_FILE_NUMBER,
                            Mft ) );
}


BOOLEAN
NTFS_BAD_CLUSTER_FILE::Create(
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN OUT  PNTFS_BITMAP            Bitmap,
    IN      PCNUMBER_SET            BadClusters
    )
/*++

Routine Description:

    This method sets up the volume's Bad Cluster List.  It also accepts
    a set of clusters to add to the list, and marks those clusters
    as used in the volume bitmap.

Arguments:

    Bitmap      -- supplies the volume bitmap.
    BadClusters -- supplies the set of bad clusters.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_EXTENT_LIST Extents;
    DSTRING DataAttributeName;
    LCN Lcn;
    BIG_INT Size, ClustersOnVolume, RunLength;
    ULONG i;

    // If we have an old data attribute lying around,
    // throw it out.
    //
    DELETE( _DataAttribute );


    // First, we have to set up the File Record Segment structure.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation) ) {

        return FALSE;
    }

    ClustersOnVolume = QueryVolumeSectors()/QueryClusterFactor();


    // Now we put together an extent list with all the bad clusters.
    //
    if( !Extents.Initialize( 0, ClustersOnVolume ) ) {

        return FALSE;
    }

    for( i = 0; i < BadClusters->QueryNumDisjointRanges(); i++ ) {

        BadClusters->QueryDisjointRange(i, &Lcn, &RunLength);

        Bitmap->SetAllocated( Lcn, RunLength);

        if( !Extents.AddExtent( Lcn, Lcn, RunLength ) ) {

            return FALSE;
        }
    }

    // Finally, create a data attribute and initialize it with
    // the extent list.  Then insert it into this File Record
    // Segment (but keep it around in case we want to add to it).
    // This data attribute has a value length equal to the size
    // of the disk, but a valid length of zero.
    //
    // Note that the size of the attribute only includes clusters
    // on the volume; it excludes any partial cluster at the end
    // of the volume.
    //
    Size = ClustersOnVolume * QueryClusterFactor() *
                                    GetDrive()->QuerySectorSize();

    if( (_DataAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
        !DataAttributeName.Initialize( BadfileDataNameData ) ||
        !_DataAttribute->Initialize( GetDrive(),
                                     QueryClusterFactor(),
                                     &Extents,
                                     Size,
                                     0,
                                     $DATA,
                                     &DataAttributeName ) ||
        !_DataAttribute->InsertIntoFile( this, NULL ) ) {

        DELETE( _DataAttribute );
        return FALSE;
    }


    // Add an unnamed, empty $DATA attribute.

    if (!AddAttribute($DATA, NULL, NULL, 0, NULL)) {

        DELETE( _DataAttribute );
        return FALSE;
    }


    return TRUE;
}



BOOLEAN
NTFS_BAD_CLUSTER_FILE::Add(
    IN  LCN Lcn
    )
/*++

Routine Description:

    This method adds a cluster to the Bad Cluster List.  Note that it
    does not mark it as used in the volume bitmap.

Arguments:

    Lcn -- supplies the LCN of the bad cluster

Return Value:

    TRUE upon successful completion.

--*/
{
    return( AddRun( Lcn, 1 ) );
}



BOOLEAN
NTFS_BAD_CLUSTER_FILE::Add(
    IN  PCNUMBER_SET    ClustersToAdd
    )
/*++

Routine Description:

    This method adds a set of clusters to the Bad Cluster List.  Note
    that it does not mark them as used in the volume bitmap.

Arguments:

    BadClusters --  Supplies the clusters to be added to the
                    bad cluster file.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT NumberOfClustersToAdd;
    LCN CurrentLcn;
    ULONG i;

    NumberOfClustersToAdd = ClustersToAdd->QueryCardinality();

    for( i = 0; i < NumberOfClustersToAdd; i++ ) {

        CurrentLcn = ClustersToAdd->QueryNumber(i);

        if( !IsInList( CurrentLcn ) &&
            !Add( CurrentLcn ) ) {

            return FALSE;
        }
    }

    return TRUE;
}



BOOLEAN
NTFS_BAD_CLUSTER_FILE::AddRun(
    IN  LCN     Lcn,
    IN  BIG_INT RunLength
    )
/*++

Routine Description:

    This method adds a run of clusters to the Bad Cluster List.  Note
    that it does not mark these clusters as used in the volume bitmap.

Arguments:

    Lcn         -- supplies the LCN of the first cluster in the run.
    RunLength   -- supplies the number of clusters in the run.

Return Value:

    TRUE upon successful completion.

Notes:

    If LCN is in the range of the volume but the run extends past
    the end of the volume, then the run is truncated.

    If LCN or the RunLength is negative, the run is ignored.  (The
    method succeeds without doing anything in this case.)

--*/
{
    DSTRING DataAttributeName;
    BIG_INT num_clusters;
    BOOLEAN Error;

    num_clusters = QueryVolumeSectors()/QueryClusterFactor();

    if( Lcn < 0             ||
        Lcn >= num_clusters ||
        RunLength < 0 ) {

        return TRUE;
    }

    if (Lcn + RunLength > num_clusters) {

        RunLength = num_clusters - Lcn;
    }

    if( _DataAttribute == NULL &&
        ( !DataAttributeName.Initialize( BadfileDataNameData ) ||
          (_DataAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
          !QueryAttribute( _DataAttribute,
                           &Error,
                           $DATA,
                           &DataAttributeName ) ) ) {

        DELETE( _DataAttribute );
        return FALSE;
    }

    return( _DataAttribute->AddExtent( Lcn, Lcn, RunLength ) );
}


BOOLEAN
NTFS_BAD_CLUSTER_FILE::IsInList(
    IN LCN Lcn
    )
/*++

Routine Description:

    This method determines whether a particular LCN is in the bad
    cluster list.

Arguments:

    Lcn --  supplies the LCN in question.

Return Value:

    TRUE if the specified LCN is in the list of bad clusters.

Notes:

    This method cannot be CONST because it may need to fetch the
    data attribute.

--*/
{
    DSTRING DataAttributeName;
    LCN QueriedLcn;
    BOOLEAN Error;

    if( _DataAttribute == NULL &&
        (!DataAttributeName.Initialize( BadfileDataNameData ) ||
          (_DataAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
          !QueryAttribute( _DataAttribute,
                           &Error,
                           $DATA,
                           &DataAttributeName ) ) ) {

        DELETE( _DataAttribute );
        return FALSE;
    }

    if( !_DataAttribute->QueryLcnFromVcn( Lcn, &QueriedLcn ) ||
        QueriedLcn == LCN_NOT_PRESENT ) {

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_BAD_CLUSTER_FILE::Flush(
    IN OUT  PNTFS_BITMAP        Bitmap,
    IN OUT  PNTFS_INDEX_TREE    ParentIndex
    )
/*++

Routine Description:

    Write the modified bad cluster list to disk.

Arguments:

    Bitmap  -- supplies the volume bitmap.  (May be NULL).

Return Value:

    TRUE upon successful completion.

--*/
{
    if( _DataAttribute != NULL &&
        _DataAttribute->IsStorageModified() &&
        !_DataAttribute->InsertIntoFile( this, Bitmap ) ) {

        return FALSE;
    }

    return( NTFS_FILE_RECORD_SEGMENT::Flush( Bitmap, ParentIndex ) );
}

BOOLEAN
NTFS_BAD_CLUSTER_FILE::VerifyAndFix(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine ensures that this bad cluster file is prepared
    to receive new bad clusters.

Arguments:

    VolumeBitmap    - Supplies the volume bitmap.
    RootIndex       - Supplies the root index.
    Changes         - Returns whether or not changes were made.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING                 DataAttributeName;
    NTFS_EXTENT_LIST        extent_list;
    BOOLEAN                 errors;
    BOOLEAN                 ErrorInAttribute;

    errors = *Changes = FALSE;

    if (!_DataAttribute) {

        if (!(_DataAttribute = NEW NTFS_ATTRIBUTE) ||
            !DataAttributeName.Initialize(BadfileDataNameData)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!QueryAttribute(_DataAttribute,
                            &ErrorInAttribute,
                            $DATA,
                            &DataAttributeName)) {

            *Changes = TRUE;

            if (!errors) {
                errors = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_BAD_FILE);
            }

            if (!extent_list.Initialize(0, QueryVolumeSectors()/
                                           QueryClusterFactor())) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!_DataAttribute->Initialize(GetDrive(),
                                            QueryClusterFactor(),
                                            &extent_list,
                                            0,
                                            0,
                                            $DATA,
                                            &DataAttributeName ) ) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!_DataAttribute->InsertIntoFile(this, VolumeBitmap)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }
    }

    if (_DataAttribute->IsStorageModified())
        *Changes = TRUE;

    if (_DataAttribute->IsStorageModified() &&
        !_DataAttribute->InsertIntoFile(this, VolumeBitmap) ||
        (FixLevel != CheckOnly && !Flush(VolumeBitmap, RootIndex))) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_BAD_FILE);
        return FALSE;
    }

    return TRUE;
}


BIG_INT
NTFS_BAD_CLUSTER_FILE::QueryNumBad(
    )
/*++

Routine Description:

    This routine return the number of bad clusters in the bad cluster
    file.

Arguments:

    None.

Return Value:

    The number of bad clusters in the bad cluster file.

--*/
{
    DSTRING DataAttributeName;
    BOOLEAN Error;

    if( _DataAttribute == NULL &&
        ( !DataAttributeName.Initialize( BadfileDataNameData ) ||
          (_DataAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
          !QueryAttribute( _DataAttribute,
                           &Error,
                           $DATA,
                           &DataAttributeName ) ) ) {

        DELETE( _DataAttribute );
        return 0;
    }

    return _DataAttribute->QueryClustersAllocated();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\bootfile.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bootfile.cxx

Abstract:

    This module contains the member function definitions for
    the NTFS_BOOT_FILE class.

Author:

    Bill McJohn (billmc) 18-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "attrib.hxx"
#include "bootfile.hxx"
#include "ifssys.hxx"
#include "ntfsbit.hxx"
#include "message.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_BOOT_FILE,
                    NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_BOOT_FILE::~NTFS_BOOT_FILE(
    )
{
    Destroy();
}


VOID
NTFS_BOOT_FILE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
NTFS_BOOT_FILE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_MASTER_FILE_TABLE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


UNTFS_EXPORT
BOOLEAN
NTFS_BOOT_FILE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes a Master File Table Reflection object.
    The only special knowledge that it adds to the File Record Segment
    initialization is the location within the Master File Table of the
    Boot File.

Arguments:

    Mft             -- Supplies the volume MasterFile Table.

Return Value:

    TRUE upon successful completion

Notes:

    This class is reinitializable.


--*/
{
    Destroy();

    return( NTFS_FILE_RECORD_SEGMENT::Initialize( BOOT_FILE_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_BOOT_FILE::CreateDataAttribute(
    )
/*++

Routine Description:

    This routine creates the data attribute for the boot file.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;
    ULONG Size, ClusterSize, ClustersInBootArea;
    ULONG NumBootClusters;

    ClusterSize = QueryClusterFactor() * GetDrive()->QuerySectorSize();

    ClustersInBootArea = (BYTES_IN_BOOT_AREA % ClusterSize) ?
                            BYTES_IN_BOOT_AREA / ClusterSize + 1 :
                            BYTES_IN_BOOT_AREA / ClusterSize;

    NumBootClusters = max(1, BYTES_PER_BOOT_SECTOR/ClusterSize);

    Size = ClustersInBootArea * ClusterSize;

    if( !Extents.Initialize( 0, 0 ) ) {

        return FALSE;
    }

    if( !Extents.AddExtent( 0,
                            0,
                            ClustersInBootArea ) ) {
        return FALSE;
    }

    if( !DataAttribute.Initialize( GetDrive(),
                                   QueryClusterFactor(),
                                   &Extents,
                                   Size,
                                   Size,
                                   $DATA ) ) {

        return FALSE;
    }

    if( !DataAttribute.InsertIntoFile( this, NULL ) ) {

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_BOOT_FILE::Create(
    IN  PCSTANDARD_INFORMATION  StandardInformation
    )
/*++

Routine Description:

    This method formats a Boot-File File Record
    Segment in memory (without writing it to disk).

Arguments:

    StandardInformation -- supplies the standard information for the
                            file record segment.

Return Value:

    TRUE upon successful completion.

--*/
{
    // Set this object up as a File Record Segment.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }

    if (!CreateDataAttribute()) {
        return FALSE;
    }

    return TRUE;
}



NONVIRTUAL
BOOLEAN
NTFS_BOOT_FILE::VerifyAndFix(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine ensures that the boot file's $DATA attribute is present
    and encompases the two boot sectors.

Arguments:

    VolumeBitmap    - Supplies the volume bitmap.
    RootIndex       - Supplies the root index.
    Changes         - Returns whether or not changes were made.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE      data_attribute;
    LCN                 lcn, mid_lcn;
    BIG_INT             run_length;
    BOOLEAN             ErrorInAttribute;
    BOOLEAN             replace_data;
    BOOLEAN             found_zero;
    BOOLEAN             found_mid;
    VCN                 i;
    NTFS_EXTENT_LIST    extents;
    ULONG               size;
    ULONG               num_boot_clusters;

    //
    // We used to do a replica boot sector in the middle of the volume.
    // Now we want it at the end, so chkdsk has to deal with both cases.
    // The rule is that the boot file should have a data attribute.  If
    // that data attribute has two extents, the second one should describe
    // a replica at n/2.  If there's a single extent, the replica is
    // assumed to occupy the last sector of the partition.
    //

    // Insure that the $DATA attribute is present and that it
    // allocates cluster 0 and the cluster in the middle of the disk.

    *Changes = FALSE;

    num_boot_clusters = max(1,
                            BYTES_PER_BOOT_SECTOR/(GetDrive()->QuerySectorSize()*
                            QueryClusterFactor()));
    mid_lcn = QueryVolumeSectors()/2/QueryClusterFactor();

    replace_data = FALSE;
    if (QueryAttribute(&data_attribute, &ErrorInAttribute, $DATA)) {

        found_zero = FALSE;
        found_mid = FALSE;
        for (i = 0; data_attribute.QueryLcnFromVcn(i, &lcn, &run_length); i += 1) {
            if (lcn == 0) {
                found_zero = (run_length >= num_boot_clusters);
            }
            if (lcn == mid_lcn) {
                found_mid = (run_length >= num_boot_clusters);
            }
        }

        if (!found_zero) {

            Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_SECTOR_ZERO_IN_BOOT_FILE);

            replace_data = TRUE;
            data_attribute.Resize(0, VolumeBitmap);
        }

    } else {

        replace_data = TRUE;
    }

    // If it's not good then replace it with one that takes
    // up only the boot sector and the middle sector.


    //
    // When creating a new boot sector we just do sector 0.
    //

    if (replace_data) {

        *Changes = TRUE;

        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_BOOT_FILE);

        size = GetDrive()->QuerySectorSize()*QueryClusterFactor();

        if (!extents.Initialize(0,0) ||
            !extents.AddExtent(0, 0, num_boot_clusters) ||
            !data_attribute.Initialize(GetDrive(),
                                       QueryClusterFactor(),
                                       &extents,
                                       size,
                                       size,
                                       $DATA) ||
            !data_attribute.InsertIntoFile(this, VolumeBitmap) ||
            (FixLevel != CheckOnly && !Flush(VolumeBitmap, RootIndex))) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_BOOT_FILE);
            return FALSE;
        }

        VolumeBitmap->SetAllocated(0, num_boot_clusters);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\bitfrs.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

	bitfrs.cxx

Abstract:

	This module contains the member function definitions for
    the NTFS_BITMAP_FILE class.

Author:

	Bill McJohn (billmc) 18-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "ntfsbit.hxx"
#include "drive.hxx"
#include "attrib.hxx"
#include "bitfrs.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_BITMAP_FILE, NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_BITMAP_FILE::~NTFS_BITMAP_FILE(
	)
{
	Destroy();
}


VOID
NTFS_BITMAP_FILE::Construct(
	)
/*++

Routine Description:

	Worker function for the construtor.

Arguments:

	None.

Return Value:

	None.

--*/
{
}


VOID
NTFS_BITMAP_FILE::Destroy(
	)
/*++

Routine Description:

	Clean up an NTFS_BITMAP_FILE object in preparation for
	destruction or reinitialization.

Arguments:

	None.

Return Value:

	None.

--*/
{
}


UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP_FILE::Initialize(
	IN OUT  PNTFS_MASTER_FILE_TABLE	Mft
	)
/*++

Routine Description:

    This method initializes a Bitmap File object.
    The only special knowledge that it adds to the File Record Segment
    initialization is the location within the Master File Table of the
    Bitmap File.

Arguments:

	Mft 			-- Supplies the volume MasterFile Table.

Return Value:

	TRUE upon successful completion

Notes:

	This class is reinitializable.


--*/
{
    Destroy();

    return( NTFS_FILE_RECORD_SEGMENT::Initialize( BIT_MAP_FILE_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_BITMAP_FILE::Create(
	IN      PCSTANDARD_INFORMATION	StandardInformation,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
	)
/*++

Routine Description:

    This method formats a Bitmap-File File Record
    Segment in memory (without writing it to disk).

    It creates a DATA attribute to hold the volume bitmap, and
    allocates space on disk for the bitmap.  Note that it does
    not write the bitmap.

Arguments:

	StandardInformation -- supplies the standard information for the
							file record segment.

    VolumeBitmap        -- supplies the volume bitmap

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;
    LCN BitmapLcn;
    BIG_INT NumberOfClusters;
    ULONG Size;
    ULONG ClusterSize;
    ULONG ClustersToHoldBitmap;


    // Set this object up as a File Record Segment.

	if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }


    // Determine the number of clusters necessary to hold the bitmap.

    NumberOfClusters = VolumeBitmap->QuerySize();

    if( NumberOfClusters.GetHighPart() != 0 ) {

        DebugAbort( "Bitmap is too big.\n" );
        return FALSE;
    }

    Size = NumberOfClusters.GetLowPart()/8;

    ClusterSize = GetDrive()->QuerySectorSize() * QueryClusterFactor();

    if( NumberOfClusters.GetLowPart() % (ULONG)8 ) {

        Size += 1;
    }

    Size = QuadAlign(Size);

    ClustersToHoldBitmap = Size/ClusterSize;
    if( Size % ClusterSize ) {

        ClustersToHoldBitmap++;
    }

    // Create a zero-length non-resident attribute, and
    // then resize it to the correct size to hold the bitmap.
    //
    if( !Extents.Initialize( 0, 0 ) ||
        !Extents.Resize( ClustersToHoldBitmap, VolumeBitmap ) ||
        !DataAttribute.Initialize( GetDrive(),
                                   QueryClusterFactor(),
                                   &Extents,
                                   Size,
                                   Size,
                                   $DATA ) ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\clusrun.cxx ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

	clusrun.cxx

Abstract:

	This class models a run of clusters on an NTFS volume.	Its
	principle purpose is to mediate between the cluster-oriented
	NTFS volume and the sector-oriented drive object.

Author:

	Bill McJohn (billmc) 11-July-1991

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "clusrun.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_CLUSTER_RUN, SECRUN, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_CLUSTER_RUN::~NTFS_CLUSTER_RUN(
	)
{
	Destroy();
}


VOID
NTFS_CLUSTER_RUN::Construct(
	)
/*++

Routine Description:

	Worker function for construction of the NTFS_CLUSTER_RUN object.

Arguments:

	None.

Return Value:

	None.

--*/
{
	_StartLcn = 0;
	_ClusterFactor = 0;
	_Drive = NULL;
	_IsModified = FALSE;
}

VOID
NTFS_CLUSTER_RUN::Destroy(
	)
/*++

Routine Description:

	Worker function for destruction of the NTFS_CLUSTER_RUN object.

Arguments:

	None.

Return Value:

	None.

--*/
{
	_StartLcn = 0;
	_ClusterFactor = 0;
	_Drive = NULL;
	_IsModified = FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_CLUSTER_RUN::Initialize (
	IN OUT  PMEM 		        Mem,
	IN OUT  PLOG_IO_DP_DRIVE	Drive,
	IN      LCN			        Lcn,
	IN      ULONG		        ClusterFactor,
	IN      ULONG		        RunLength
	)
/*++

Routine Description:

	Initialize an NTFS_CLUSTER_RUN object.

Arguments:

	Mem 			-- supplies the memory object for this cluster run.
	Drive			-- supplies the drive on which this cluster run resides.
	Lcn 			-- supplies the staring Lcn of the cluster run.
	Cluster Factor	-- supplies the cluster factor for the drive.
	RunLength		-- supplies the length of the run in clusters.

Return Value:

	TRUE upon successful completion.

Notes:

	This class is reinitializable.

--*/
{
	DebugPtrAssert( Mem );
	DebugPtrAssert( Drive );

	Destroy();

	if( !SECRUN::Initialize( Mem, Drive,
                             Lcn * ClusterFactor,
                             RunLength * ClusterFactor ) ) {

		return FALSE;
	}

	_StartLcn = Lcn;
	_Drive = Drive;
	_ClusterFactor = ClusterFactor;

	return TRUE;
}


UNTFS_EXPORT
VOID
NTFS_CLUSTER_RUN::Relocate (
	IN LCN NewLcn
	)
/*++

Routine Description:

	Move the cluster run to point at a different section of
	the volume.

Arguments:

	NewLcn	-- supplies the first Lcn of the new location.

Return Value:

	None.

--*/
{
	_StartLcn = NewLcn;

	SECRUN::Relocate( NewLcn * _ClusterFactor );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\downgrad.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    ntfschk.cxx

Abstract:

    This module implements NTFS CHKDSK.

Author:

    Norbert P. Kusters (norbertk) 29-Jul-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#if defined(TIMING_ANALYSIS)
extern "C" {
    #include <stdio.h>
    #include <time.h>
}
#endif

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"

BOOLEAN
NTFS_SA::DownGradeNtfs(
    IN OUT  PMESSAGE                Message,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo
    )
/*++

Routine Description:

    This routine verifies and, if necessary, fixes an NTFS volume.

Arguments:

    Message             - Supplies an outlet for messages.
    Mft                 - Supplies the MFT.
    ChkdskInfo          - Supplies the current chkdsk info.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#if 1
    return FALSE;
#else
    ULONG                       i, j, n;
    PSTANDARD_INFORMATION       standard_information;
    PSTANDARD_INFORMATION2      standard_information2;
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_FILE_RECORD_SEGMENT    extend_frs;
    NTFS_FILE_RECORD_SEGMENT    root_frs;
    ULONG                       percent;
    NTFS_ATTRIBUTE              attrib;
    BOOLEAN                     error;
    BOOLEAN                     changes;
    ULONG                       depth;
    ULONG                       bytesWritten;
    NTFS_INDEX_TREE             index;
    PVOLUME_INFORMATION         vol_info;
    DSTRING                     name;
    NUMBER_SET                  bad_clusters;

    extern WCHAR          FileNameQuota[];
    CONST USHORT                FileNameBufferSize = 256;
    CHAR                        FileNameBuffer[FileNameBufferSize];
    CONST PFILE_NAME            FileName = (PFILE_NAME)FileNameBuffer;
    CONST PVOID                 FileNameValue = NtfsFileNameGetName( FileName );
    MFT_SEGMENT_REFERENCE       RootFileIndexSegment;
    STANDARD_INFORMATION        StandardInformation;
    LARGE_INTEGER               SystemTime;
    PCINDEX_ENTRY               index_entry;
    NTFS_ATTRIBUTE_COLUMNS      attr_def_table;
    NTFS_ATTRIBUTE_DEFINITION_TABLE attr_def_file;
    USHORT                      volume_flags;
    BOOLEAN                     corrupt_volume;
    UCHAR                       major, minor;

    volume_flags = QueryVolumeFlagsAndLabel(&corrupt_volume, &major, &minor);
    if (corrupt_volume) {
        Message->DisplayMsg(MSG_NTFS_CHK_NOT_NTFS);
        return FALSE;
    }

    // If volume is current, a downgrade followed by an upgrade will have no effect.
    // If volume is not current, a upgrade followed by a downgrade will have no effect.
    // So, remove upgrade bit and return in any case.

    if (volume_flags & VOLUME_UPGRADE_ON_MOUNT) {
        if (!ClearVolumeFlag(VOLUME_UPGRADE_ON_MOUNT,
                             NULL,
                             FALSE,
                             LargestLsnEncountered,
                             &corrupt_volume) ||
            corrupt_volume) {
            Message->DisplayMsg(MSG_NTFS_CHK_NOT_NTFS);
            return FALSE;
        }
        Message->DisplayMsg(MSG_CHK_NTFS_UPGRADE_DOWNGRADE);
        return TRUE;
    }

    //
    // make sure the version to operate on is correct
    //

    if (ChkdskInfo->major != 3 && ChkdskInfo->major != 2) {
        Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_TO_DOWNGRADE);
        return TRUE;
    }
    Message->DisplayMsg(MSG_CHK_NTFS_DOWNGRADE_SCANNING);

    percent = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
        return FALSE;
    }

    n = ChkdskInfo->NumFiles;
    for (i = 0; i < n; i++) {

        if (i*100/n > percent) {
            percent = i*100/n;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                return FALSE;
            }
        }

        if (i % MFT_READ_CHUNK_SIZE == 0) {
            ULONG       remaining_frs;
            ULONG       number_to_read;

            remaining_frs = n - i;
            number_to_read = min(MFT_READ_CHUNK_SIZE, remaining_frs);

            if (!frs.Initialize(i, number_to_read, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (!frs.Initialize()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (!frs.ReadNext(i))
            continue;

        if (Mft->GetMftBitmap()->IsFree(i, 1) ||
            !frs.IsInUse() ||
            !frs.IsBase()) {
            continue;
        }

        // scan for $REPARSE_POINT attribute

        if (frs.QueryAttribute(&attrib,
                               &error,
                               $REPARSE_POINT)) {
            Message->DisplayMsg(MSG_CHK_NTFS_REPARSE_POINT_FOUND,
                             "%d", i);
            Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
            return TRUE;
        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // scan for $LOGGED_UTILITY_STREAM attributes

        for (j=0; frs.QueryAttributeByOrdinal(&attrib,
                                              &error,
                                              $LOGGED_UTILITY_STREAM,
                                              j); j++) {
            Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE_FOUND,
                             "%d", i);
            Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
            return TRUE;
        }

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // scan for $PROPERTY_SET attributes

        for (j=0; frs.QueryAttributeByOrdinal(&attrib,
                                              &error,
                                              $PROPERTY_SET,
                                              j); j++) {
            Message->DisplayMsg(MSG_CHK_NTFS_PROPERTY_SET_FOUND,
                             "%d", i);
            Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
            return TRUE;
        }

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // scan all $data for sparse or encryption settings

        for (j=0; frs.QueryAttributeByOrdinal(&attrib,
                                              &error,
                                              $DATA,
                                              j); j++) {
            if (attrib.QueryFlags() & ATTRIBUTE_FLAG_ENCRYPTED) {
                Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE_FOUND,
                                 "%d", i);
                Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
                return TRUE;
            }
            if (attrib.QueryFlags() & ATTRIBUTE_FLAG_SPARSE) {
                Message->DisplayMsg(MSG_CHK_NTFS_SPARSE_FILE_FOUND,
                                 "%d", i);
                Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_DOWNGRADE);
                return TRUE;
            }
        }

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100);

    Message->DisplayMsg(MSG_CHK_NTFS_DOWNGRADE_SCANNING_COMPLETED);

    //
    // now look for encrypted bits and turn them off
    // delete any object Id found
    // reduce the size of large standard information
    // Add security descriptor attribute
    //

    Message->DisplayMsg(MSG_CHK_NTFS_DOWNGRADE);

    percent = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
        return FALSE;
    }

    for (i = 0; i < n; i++) {

        if (i*100/n > percent) {
            percent = i*100/n;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                return FALSE;
            }
        }

        if (i % MFT_READ_CHUNK_SIZE == 0) {
            ULONG       remaining_frs;
            ULONG       number_to_read;

            remaining_frs = n - i;
            number_to_read = min(MFT_READ_CHUNK_SIZE, remaining_frs);

            if (!frs.Initialize(i, number_to_read, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (!frs.Initialize()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.ReadNext(i))
            continue;

        if (Mft->GetMftBitmap()->IsFree(i, 1) ||
            !frs.IsInUse() ||
            !frs.IsBase()) {
            continue;
        }

        if (!frs.PurgeAttribute($OBJECT_ID)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.QueryAttribute(&attrib,
                               &error,
                               $STANDARD_INFORMATION)) {
            DebugPrintTrace(("Standard Information is missing from FRS %d\n",
                            frs.QueryFileNumber().GetLowPart()));
            if (!frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                 "%d", i);
                return FALSE;
            }
            continue;
        }
        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (attrib.QueryValueLength() != sizeof(STANDARD_INFORMATION2)) {
            if (!frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                 "%d", i);
                return FALSE;
            }
            continue;   // if small standard information, we are done!
        }

        if (!attrib.Resize(sizeof(STANDARD_INFORMATION), Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                             "%d%d", attrib.QueryTypeCode(), i);
            return FALSE;
        }

        standard_information = (PSTANDARD_INFORMATION)attrib.GetResidentValue();

        //
        // clear some flags just to be sure; they should not be there in the first place
        //

        standard_information->FileAttributes &= ~(FILE_ATTRIBUTE_ENCRYPTED|
                                                   FILE_ATTRIBUTE_SPARSE_FILE|
                                                   FILE_ATTRIBUTE_REPARSE_POINT);
        standard_information->Reserved = 0;

        if (!attrib.Write(standard_information,
                          0,
                          sizeof(STANDARD_INFORMATION),
                          &bytesWritten,
                          Mft->GetVolumeBitmap()) ||
            bytesWritten != sizeof(STANDARD_INFORMATION)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                             "%d%d", attrib.QueryTypeCode(), i);
            return FALSE;
        }
        if (attrib.IsStorageModified() &&
            !attrib.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                             "%d%d", attrib.QueryTypeCode(), i);
            return FALSE;
        }
        if (!frs.AddSecurityDescriptor(EditCannedSd, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY,
                             "%d", i);
            return FALSE;
        }
        if (!frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                             "%d", i);
            return FALSE;
        }

        //
        // don't worry about the same bits in attribute flag in DUPLICATED_INFORMATION
        // as they should not be there in the first place.  If they were there,
        // chkdsk will fix it up as minor inconsistences.
        //
    }

    Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100);

    //
    // now go thru the extend directory and eliminate things inside it
    //

    if (!extend_frs.Initialize(EXTEND_TABLE_NUMBER, Mft) ||
        !extend_frs.Read() ||
        !name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive, QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          extend_frs.QuerySize()/2,
                          &extend_frs,
                          &name)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    ChkdskInfo->ObjectIdFileNumber = 0;
    ChkdskInfo->QuotaFileNumber = 0;
    ChkdskInfo->UsnJournalFileNumber = 0;
    ChkdskInfo->ReparseFileNumber = 0;

    if (!ExtractExtendInfo(&index, ChkdskInfo, Message)) {
        return FALSE;
    }

    if (ChkdskInfo->ObjectIdFileNumber != 0) {
        if (!frs.Initialize(ChkdskInfo->ObjectIdFileNumber, Mft) || !frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.Delete(Mft->GetVolumeBitmap());
    }

    if (ChkdskInfo->QuotaFileNumber != 0) {
        if (!frs.Initialize(ChkdskInfo->QuotaFileNumber, Mft) || !frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.Delete(Mft->GetVolumeBitmap());
    }

    if (ChkdskInfo->UsnJournalFileNumber != 0) {
        if (!frs.Initialize(ChkdskInfo->UsnJournalFileNumber, Mft) || !frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.Delete(Mft->GetVolumeBitmap());
    }

    if (ChkdskInfo->ReparseFileNumber != 0) {
        if (!frs.Initialize(ChkdskInfo->ReparseFileNumber, Mft) || !frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.Delete(Mft->GetVolumeBitmap());
    }

    if (!frs.Initialize(SECURITY_TABLE_NUMBER, Mft) || !frs.Read()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    frs.Delete(Mft->GetVolumeBitmap());

    extend_frs.Delete(Mft->GetVolumeBitmap());

    //
    // Remove the $Security & $Extend entries from the root index
    //

    if (!root_frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, Mft) || !root_frs.Read()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive, QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          root_frs.QuerySize()/2,
                          &root_frs,
                          &name)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    index.ResetIterator();

    while (index_entry = index.GetNext(&depth, &error)) {
        switch (index_entry->FileReference.LowPart) {
            case SECURITY_TABLE_NUMBER:
            case EXTEND_TABLE_NUMBER:
                if (index_entry->FileReference.HighPart == 0) {
                    if (!index.DeleteCurrentEntry()) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }
                }
                break;
        }
    }

    //
    // Re-Initialize FRS 0x9 to $Quota FRS
    //

    RootFileIndexSegment.LowPart = ROOT_FILE_NAME_INDEX_NUMBER;
    RootFileIndexSegment.HighPart = 0;
    RootFileIndexSegment.SequenceNumber = ROOT_FILE_NAME_INDEX_NUMBER;

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameQuota );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameQuota,
            FileName->FileNameLength * sizeof( WCHAR ) );

    // Set up the Standard Information structure that will
    // be used by all the special files.  The creation and modification
    // times are now, and all files created by format are hidden.

    memset( (PVOID)&StandardInformation,
            0,
            sizeof(STANDARD_INFORMATION) );

    IFS_SYSTEM::QueryNtfsTime( &SystemTime );

    StandardInformation.CreationTime =
        StandardInformation.LastModificationTime =
        StandardInformation.LastChangeTime =
        StandardInformation.LastAccessTime = SystemTime;

    StandardInformation.FileAttributes = FILE_ATTRIBUTE_HIDDEN |
                                         FILE_ATTRIBUTE_SYSTEM;

    Mft->GetMftBitmap()->SetAllocated( QUOTA_TABLE_NUMBER, 1);

    if( !frs.Initialize( QUOTA_TABLE_NUMBER,
                         Mft ) ||
        !frs.Create( &StandardInformation ) ||
        !frs.AddEmptyAttribute( $DATA ) ||
        !frs.AddFileNameAttribute( FileName ) ||
        !frs.AddSecurityDescriptor( WriteCannedSd, Mft->GetVolumeBitmap() ) ||
        !index.InsertEntry( NtfsFileNameGetLength( FileName ),
                            FileName,
                            frs.QuerySegmentReference() ) ||
        !frs.Flush(Mft->GetVolumeBitmap(), &index) ) {

        DebugPrint( "Can't create Quota Table File Record Segment.\n" );
        return FALSE;
    }

    //
    // Re-Initialize FRS 0xB to a generic FRS
    //

    Mft->GetMftBitmap()->SetAllocated( EXTEND_TABLE_NUMBER, 1 );

    if( !frs.Initialize( EXTEND_TABLE_NUMBER, Mft ) ||
        !frs.Create( &StandardInformation ) ||
        !frs.AddEmptyAttribute( $DATA ) ||
        !frs.AddSecurityDescriptor( WriteCannedSd, Mft->GetVolumeBitmap() ) ||
        !frs.Flush( Mft->GetVolumeBitmap() ) ) {

        DebugPrint( "Can't create a generic FRS.\n" );
        return FALSE;
    }

    //
    // Fix up the Attribute Definition Table
    //

    SetVersionNumber(1,2);  // back to NTFS for NT 4.0

    if (!FetchAttributeDefinitionTable(NULL,
                                       Message,
                                       &attr_def_table)) {
        return FALSE;
    }

    if (!attr_def_file.Initialize(Mft, 1) ||
        !bad_clusters.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!attr_def_file.Read()) {
        DebugAbort("Can't read in hotfixed attribute definition file.");
        return FALSE;
    }

    if (!attr_def_file.VerifyAndFix(&attr_def_table,
                                    Mft->GetVolumeBitmap(),
                                    &bad_clusters,
                                    &index,
                                    &changes,
                                    TotalFix,
                                    Message,
                                    TRUE)) {
        return FALSE;
    }

    if( !index.Save( &root_frs ) ||
        !root_frs.Flush( Mft->GetVolumeBitmap() ) ) {

        DebugPrint( "Can't save root index.\n" );
        return FALSE;
    }

    //
    // change volume version from 3.0 (for NT 5.0) to 1.2 (for NT 4.0)
    //

    if (!frs.Initialize(VOLUME_DASD_NUMBER, Mft) || !frs.Read()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.QueryAttribute(&attrib, &error, $VOLUME_INFORMATION) || error) {
        Message->DisplayMsg(MSG_CHK_NTFS_BAD_VOLUME_VERSION);
        return FALSE;
    }

    vol_info = (PVOLUME_INFORMATION)attrib.GetResidentValue();
    vol_info->MajorVersion = 1;
    vol_info->MinorVersion = 2;

    if (!attrib.Write(vol_info,
                      0,
                      sizeof(VOLUME_INFORMATION),
                      &bytesWritten,
                      NULL)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                         "%d%d", attrib.QueryTypeCode(), VOLUME_DASD_NUMBER);
        return FALSE;
    }
    if (attrib.IsStorageModified() &&
        !attrib.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                         "%d%d", attrib.QueryTypeCode(), VOLUME_DASD_NUMBER);
        return FALSE;
    }
    if (!frs.Flush(Mft->GetVolumeBitmap())) {
        Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                         "%d", VOLUME_DASD_NUMBER);
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_NTFS_DOWNGRADE_COMPLETED);

    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\entry.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    entry.cxx

Abstract:

    This module contains the entry points for UNTFS.DLL.  These
    include:

        Chkdsk
        ChkdskEx
        Format
        FormatEx
        Recover
        Extend

Author:

    Bill McJohn (billmc) 31-05-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "ntfsvol.hxx"
#include "path.hxx"
#include "ifssys.hxx"
#include "rcache.hxx"
#include "ifsserv.hxx"

extern "C" {
    #include "nturtl.h"
}

#include "message.hxx"
#include "rtmsg.h"


BOOLEAN
FAR APIENTRY
Chkdsk(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Fix,
    IN      BOOLEAN     Verbose,
    IN      BOOLEAN     OnlyIfDirty,
    IN      BOOLEAN     Recover,
    IN      PPATH       PathToCheck,
    IN      BOOLEAN     Extend,
    IN      BOOLEAN     ResizeLogFile,
    IN      ULONG       DesiredLogFileSize,
    OUT     PULONG      ExitStatus
    )
/*++

Routine Description:

    Check an NTFS volume.

Arguments:

    NtDrivName          supplies the name of the drive to check
    Message             supplies an outlet for messages
    Fix                 TRUE if Chkdsk should fix errors
    Verbose             TRUE if Chkdsk should list every file it finds
    OnlyIfDirty         TRUE if the drive should be checked only if
                            it is dirty
    Recover             TRUE if the drive is to be completely checked
                            for bad sectors.
    PathToCheck         supplies a path to files Chkdsk should check
                            for contiguity
    Extend              TRUE if Chkdsk should extend the volume
    ResizeLogfile       TRUE if Chkdsk should resize the logfile.
    DesiredLogfileSize  if ResizeLogfile is true, supplies the desired logfile
                            size, or 0 if we're to resize the logfile to the
                            default size.
    ExitStatus          Returns information about whether the chkdsk failed


Return Value:

    TRUE if successful.

--*/
{
    NTFS_VOL        NtfsVol;
    BOOLEAN         RecoverFree, RecoverAlloc;
    BOOLEAN         r;
    DWORD           oldErrorMode;
    ULONG           flags;

    if (Extend) {

        LOG_IO_DP_DRIVE Drive;
        SECRUN          Secrun;
        HMEM            Mem;

        PPACKED_BOOT_SECTOR BootSector;

        if( !Drive.Initialize( NtDriveName, Message ) ||
            !Drive.Lock() ||
            !Mem.Initialize() ||
            !Secrun.Initialize( &Mem, &Drive, 0, 1 ) ||
            !Secrun.Read() ) {

            return FALSE;
        }

        BootSector = (PPACKED_BOOT_SECTOR)Secrun.GetBuf();

        BootSector->NumberSectors.LowPart = Drive.QuerySectors().GetLowPart();
        BootSector->NumberSectors.HighPart = Drive.QuerySectors().GetHighPart();

        if (!Secrun.Write()) {
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
    }

    RecoverFree = RecoverAlloc = Recover;

    if (Extend) {

        // If we're to extend the volume, we also want to verify the
        // new free space we're adding.
        //

        RecoverFree = TRUE;
    }

    // disable popups while we initialize the volume
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    if (!NtfsVol.Initialize(NtDriveName, Message)) {
        SetErrorMode ( oldErrorMode );
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    // Re-enable hardware popups
    SetErrorMode ( oldErrorMode );

    if (Fix || (ResizeLogFile && DesiredLogFileSize != 0)) {

        if (!NtfsVol.IsWriteable()) {
            Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }

        if (!NtfsVol.Lock()) {

            // The client wants to modify the drive, but we can't lock it.
            // Offer to do it on next reboot.
            //
            Message->DisplayMsg(MSG_CHKDSK_ON_REBOOT_PROMPT);

            if (Message->IsYesResponse( FALSE )) {

                flags = Recover ? CHKDSK_RECOVER : 0;
                flags |= ResizeLogFile ? CHKDSK_RESIZE_LOGFILE : 0;

                if (NtfsVol.ForceAutochk( Fix,
                                          flags,
                                          DesiredLogFileSize,
                                          0,
                                          NtDriveName )) {

                    Message->DisplayMsg(MSG_CHKDSK_SCHEDULED);

                } else {

                    Message->DisplayMsg(MSG_CHKDSK_CANNOT_SCHEDULE);
                }
            }

            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
    }

    if (!Fix && ResizeLogFile) {

        if (!NtfsVol.GetNtfsSuperArea()->ResizeCleanLogFile( Message,
                                                             TRUE, /* ExplicitResize */
                                                             DesiredLogFileSize )) {
            Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED);
            return FALSE;
        }
        return TRUE;
    }

    flags = (Verbose ? CHKDSK_VERBOSE : 0);
    flags |= (OnlyIfDirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    flags |= (RecoverFree ? CHKDSK_RECOVER_FREE_SPACE : 0);
    flags |= (RecoverAlloc ? CHKDSK_RECOVER_ALLOC_SPACE : 0);
    flags |= (ResizeLogFile ? CHKDSK_RESIZE_LOGFILE : 0);

    return NtfsVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                           Message,
                           flags,
                           DesiredLogFileSize,
                           0,
                           ExitStatus );
}


BOOLEAN
FAR APIENTRY
ChkdskEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Fix,
    IN      PCHKDSKEX_FN_PARAM  Param,
    OUT     PULONG              ExitStatus
    )
/*++

Routine Description:

    Check an NTFS volume.

Arguments:

    NtDrivName          supplies the name of the drive to check
    Message             supplies an outlet for messages
    Fix                 TRUE if Chkdsk should fix errors
    Param               supplies the chkdsk parameter block
    ExitStatus          Returns information about whether the chkdsk failed


Return Value:

    TRUE if successful.

--*/
{
    NTFS_VOL        NtfsVol;
    BOOLEAN         RecoverFree, RecoverAlloc;
    BOOLEAN         r;
    DWORD           oldErrorMode;
    USHORT          algorithm;

    if (Param->Major != 1 || (Param->Minor != 0 && Param->Minor != 1)) {
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    if (Param->Major > 1 || (Param->Major == 1 && Param->Minor == 1)) {
        algorithm = Param->Algorithm;
    } else
        algorithm = 0;

    if (Param->Flags & CHKDSK_EXTEND) {

        LOG_IO_DP_DRIVE Drive;
        SECRUN          Secrun;
        HMEM            Mem;

        PPACKED_BOOT_SECTOR BootSector;

        if( !Drive.Initialize( NtDriveName, Message ) ||
            !Drive.Lock() ||
            !Mem.Initialize() ||
            !Secrun.Initialize( &Mem, &Drive, 0, 1 ) ||
            !Secrun.Read() ) {

            return FALSE;
        }

        BootSector = (PPACKED_BOOT_SECTOR)Secrun.GetBuf();

        BootSector->NumberSectors.LowPart = Drive.QuerySectors().GetLowPart();
        BootSector->NumberSectors.HighPart = Drive.QuerySectors().GetHighPart();

        if (!Secrun.Write()) {
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
    }

    RecoverFree = RecoverAlloc = (BOOLEAN)(Param->Flags & CHKDSK_RECOVER);

    if (Param->Flags & CHKDSK_EXTEND) {

        // If we're to extend the volume, we also want to verify the
        // new free space we're adding.
        //

        RecoverFree = TRUE;
    }

    // disable popups while we initialize the volume
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    if (!NtfsVol.Initialize(NtDriveName, Message)) {
        SetErrorMode ( oldErrorMode );
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    // Re-enable hardware popups
    SetErrorMode ( oldErrorMode );

    if (Fix || ((Param->Flags & CHKDSK_RESIZE_LOGFILE) &&
                Param->LogFileSize != 0)) {

        MSGID   msgId = MSG_CHKDSK_ON_REBOOT_PROMPT;
        WCHAR   windows_path[MAX_PATH];
        DSTRING sdrive, nt_drive_name;
        BOOLEAN system_drive = FALSE;
        BOOLEAN do_not_dismount = FALSE;

        if (!NtfsVol.IsWriteable()) {
            Message->DisplayMsg(MSG_CHK_WRITE_PROTECTED);
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }

        if (GetWindowsDirectory(windows_path, sizeof(windows_path)/sizeof(WCHAR)) &&
            wcslen(windows_path) >= 2 &&
            windows_path[1] == TEXT(':') &&
            !(windows_path[2] = 0) &&
            sdrive.Initialize(windows_path) &&
            IFS_SYSTEM::DosDriveNameToNtDriveName(&sdrive, &nt_drive_name)) {

            system_drive = nt_drive_name.Stricmp(NtDriveName) == 0;
        } else {

            Message->DisplayMsg(MSG_CHK_UNABLE_TO_TELL_IF_SYSTEM_DRIVE);
            system_drive = FALSE;
        }

        if (!system_drive) {
            if (!NtfsVol.Lock()) {
                if (!(Param->Flags & CHKDSK_FORCE)) {

                    Message->DisplayMsg(MSG_CHKDSK_FORCE_DISMOUNT_PROMPT);

                    if (Message->IsYesResponse( FALSE )) {
                        if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
                            Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
                        } else
                            msgId = MSG_CHKDSK_DISMOUNT_ON_REBOOT_PROMPT;
                    } else {
                        do_not_dismount = TRUE;
                    }

                } else if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
                    Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
                } else
                    msgId = MSG_CHKDSK_DISMOUNT_ON_REBOOT_PROMPT;

                // disable popups while we initialize the volume
                oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

                if (!NtfsVol.Initialize(NtDriveName, Message)) {
                    SetErrorMode ( oldErrorMode );
                    *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
                    return FALSE;
                }

                // Re-enable hardware popups
                SetErrorMode ( oldErrorMode );
            }
        }

        if (do_not_dismount || !NtfsVol.Lock()) {

            // The client wants to modify the drive, but we can't lock it.
            // Offer to do it on next reboot.
            //
            Message->DisplayMsg(msgId);

            if (Message->IsYesResponse( FALSE )) {

                if (NtfsVol.ForceAutochk( Fix,
                                          Param->Flags,
                                          Param->LogFileSize,
                                          algorithm,
                                          NtDriveName )) {

                    Message->DisplayMsg(MSG_CHKDSK_SCHEDULED);

                } else {

                    Message->DisplayMsg(MSG_CHKDSK_CANNOT_SCHEDULE);
                }
            }

            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;

        }
    }

    if (!Fix && (Param->Flags & CHKDSK_RESIZE_LOGFILE)) {

        if (!NtfsVol.GetNtfsSuperArea()->ResizeCleanLogFile( Message,
                                                             TRUE, /* ExplicitResize */
                                                             Param->LogFileSize )) {
            Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED);
            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;
        }
        *ExitStatus = CHKDSK_EXIT_SUCCESS;
        return TRUE;
    }

    return NtfsVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                           Message,
                           Param->Flags,
                           Param->LogFileSize,
                           algorithm,
                           ExitStatus );
}


BOOLEAN
FAR APIENTRY
Format(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Quick,
    IN      BOOLEAN     BackwardCompatible,
    IN      MEDIA_TYPE  MediaType,
    IN      PCWSTRING   LabelString,
    IN      ULONG       ClusterSize
    )
/*++

Routine Description:

    Format an NTFS volume.

Arguments:

    NtDriveName     -- supplies the name (in NT API form) of the volume
    Message         -- supplies an outlet for messages
    Quick           -- supplies a flag to indicate whether to do Quick Format
    BackwardCompatible
                    -- supplies a flag to indicate if formatting to previous
                       version of file system (e.g. FAT32->FAT16, NTFS 5.0->NTFS 4.0)
    MediaType       -- supplies the volume's Media Type
    LabelString     -- supplies the volume's label
    ClusterSize     -- supplies the cluster size for the volume.

--*/
{
    DP_DRIVE            DpDrive;
    NTFS_VOL            NtfsVol;
    ULONG               SectorsNeeded;
    FORMAT_ERROR_CODE   errcode;
    ULONG               flags;

    if (ClusterSize && ClusterSize > 64*1024) {
        Message->DisplayMsg(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
        return FALSE;
    }

    if (!DpDrive.Initialize( NtDriveName, Message )) {

        return FALSE;
    }

    if (DpDrive.IsFloppy()) {

        Message->DisplayMsg(MSG_NTFS_FORMAT_NO_FLOPPIES);
        return FALSE;
    }

    SectorsNeeded = NTFS_SA::QuerySectorsInElementaryStructures( &DpDrive );

    if( SectorsNeeded > DpDrive.QuerySectors() ) {

        Message->DisplayMsg( MSG_FMT_VOLUME_TOO_SMALL );
        return FALSE;
    }

    errcode = NtfsVol.Initialize( NtDriveName,
                                  Message,
                                  FALSE,
                                  !Quick,
                                  MediaType );

    if (errcode == NoError) {
        flags = (BackwardCompatible ? FORMAT_BACKWARD_COMPATIBLE : 0);
        errcode = NtfsVol.Format( LabelString, Message, flags, ClusterSize );
    }

    if (errcode == LockError) {
        Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
        return FALSE;
    } else
        return (errcode == NoError);
}


BOOLEAN
FAR APIENTRY
FormatEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      PFORMATEX_FN_PARAM  Param,
    IN      MEDIA_TYPE          MediaType
    )
/*++

Routine Description:

    Format an NTFS volume.

Arguments:

    NtDriveName     -- supplies the name (in NT API form) of the volume
    Message         -- supplies an outlet for messages
    Param           -- supplies the format parameter block
    MediaType       -- supplies the volume's Media Type

--*/
{
    DP_DRIVE            DpDrive;
    NTFS_VOL            NtfsVol;
    ULONG               SectorsNeeded;
    FORMAT_ERROR_CODE   errcode;

    if (Param->Major != 1 || Param->Minor != 0) {
        return FALSE;
    }

    if (Param->ClusterSize && Param->ClusterSize > 64*1024) {
        Message->DisplayMsg(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
        return FALSE;
    }

    if (!DpDrive.Initialize( NtDriveName, Message )) {

        return FALSE;
    }

    if (DpDrive.IsFloppy()) {

        Message->DisplayMsg(MSG_NTFS_FORMAT_NO_FLOPPIES);
        return FALSE;
    }

    SectorsNeeded = NTFS_SA::QuerySectorsInElementaryStructures( &DpDrive );

    if( SectorsNeeded > DpDrive.QuerySectors() ) {

        Message->DisplayMsg( MSG_FMT_VOLUME_TOO_SMALL );
        return FALSE;
    }

    errcode = NtfsVol.Initialize( NtDriveName,
                                  Message,
                                  FALSE,
                                  (Param->Flags & FORMAT_QUICK) ? 0 : 1,
                                  MediaType );

    if (errcode == NoError) {
        errcode = NtfsVol.Format( Param->LabelString,
                                  Message,
                                  Param->Flags,
                                  Param->ClusterSize );
    }

    if (errcode == LockError) {

        if (!(Param->Flags & FORMAT_FORCE)) {
            Message->DisplayMsg(MSG_FMT_FORCE_DISMOUNT_PROMPT);

            if (Message->IsYesResponse(FALSE) &&
                IFS_SYSTEM::DismountVolume(NtDriveName)) {
                Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
            } else {
                Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
                return FALSE;
            }
        } else if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
            Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
        }

        errcode = NtfsVol.Initialize( NtDriveName,
                                      Message,
                                      FALSE,
                                      (Param->Flags & FORMAT_QUICK) ? 0 : 1,
                                      MediaType );

        if (errcode == NoError) {
            errcode = NtfsVol.Format( Param->LabelString,
                                      Message,
                                      Param->Flags,
                                      Param->ClusterSize );
        }

        if (errcode == LockError) {
            Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
            return FALSE;
        } else
            return (errcode == NoError);
    } else
        return (errcode == NoError);
}


BOOLEAN
FAR APIENTRY
Recover(
    IN      PPATH       RecFilePath,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    Recover a file on an NTFS disk.

Arguments:

    RecFilePath --  supplies the path to the file to recover
    Message     --  supplies a channel for messages

Return Value:

    TRUE if successful.

--*/
{
    NTFS_VOL    NtfsVol;
    PWSTRING    FullPath;
    PWSTRING    DosDriveName;
    DSTRING     NtDriveName;
    BOOLEAN     Result;

    FullPath = RecFilePath->QueryDirsAndName();
    DosDriveName = RecFilePath->QueryDevice();

    if ( DosDriveName == NULL ||
         !IFS_SYSTEM::DosDriveNameToNtDriveName(DosDriveName,
                                                &NtDriveName) ||
         FullPath == NULL ) {

        DELETE(DosDriveName);
        DELETE(FullPath);
        return FALSE;
    }

    Message->DisplayMsg(MSG_RECOV_BEGIN,
                     "%W", DosDriveName);
    Message->WaitForUserSignal();

    Result = ( NtfsVol.Initialize( &NtDriveName, Message ) &&
               NtfsVol.Recover( FullPath, Message ) );

    DELETE(DosDriveName);
    DELETE(FullPath);
    return Result;
}

BOOLEAN
FAR APIENTRY
Extend(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Verify
    )
/*++

Routine Description:

    Extend an NTFS volume without going through the whole chkdsk
    process.

Arguments:

    NtDrivName      Supplies the name of the drive to extend.
    Message         Supplies an outlet for messages.
    Verify          TRUE if we should verify the new space.

Return Value:

    TRUE if successful.

--*/
{
    BIG_INT         nsecOldSize;            // previous size in sectors

    //
    // First save the old volume size from the boot sector, then query
    // the new size from the device driver and write a new boot sector
    // contining that size.  When the Drive object is destroyed, the
    // dasd handle will be closed.
    //

    {
        LOG_IO_DP_DRIVE Drive;
        SECRUN          Secrun;
        HMEM            Mem;

        PPACKED_BOOT_SECTOR BootSector;


        if( !Drive.Initialize( NtDriveName, Message ) ||
            !Drive.Lock() ||
            !Mem.Initialize() ||
            !Secrun.Initialize( &Mem, &Drive, 0, 1 ) ||
            !Secrun.Read() ) {

            return FALSE;
        }

        BootSector = (PPACKED_BOOT_SECTOR)Secrun.GetBuf();

        nsecOldSize = BootSector->NumberSectors;

        // Leave one sector at the end of the volume for the replica boot
        // sector.
        //

        BootSector->NumberSectors.LowPart = (Drive.QuerySectors() - 1).GetLowPart();
        BootSector->NumberSectors.HighPart = (Drive.QuerySectors() - 1).GetHighPart();

        if (!Secrun.Write()) {
            return FALSE;
        }
    }

    //
    // When the ntfs volume object is initialized, it will get the new
    // size from the boot sector.  When it opens a handle on the volume,
    // the filesystem will re-mount and pick up the new size, as well.
    //

    NTFS_VOL        ntfs_vol;

    if (!ntfs_vol.Initialize(NtDriveName, Message) || !ntfs_vol.Lock()) {
        return FALSE;
    }

    return ntfs_vol.Extend(Message, Verify, nsecOldSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\format.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

   format.cxx

Abstract:

    This module contains the definition of NTFS_SA::Create,
    which performs FORMAT for an NTFS volume.

Author:

   Bill McJohn (billmc) 15-Aug-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "error.hxx"
#include "untfs.hxx"
#include "..\..\ufat\inc\fatsa.hxx" // for PHYS_REMOVABLE and PHYS_FIXED ;

#include "string.hxx"
#include "wstring.hxx"
#include "numset.hxx"
#include "numset.hxx"

#include "ifssys.hxx"

#include "ntfssa.hxx"
#include "attrib.hxx"
#include "frs.hxx"
#include "mftfile.hxx"
#include "mftref.hxx"
#include "ntfsbit.hxx"
#include "attrdef.hxx"
#include "badfile.hxx"
#include "bootfile.hxx"
#include "bitfrs.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "logfile.hxx"

#include "rtmsg.h"
#include "message.hxx"

#define LOGFILE_PLACEMENT_V1    1

CONST WCHAR FileNameMft[] = {'$', 'M', 'F', 'T', 0};
CONST WCHAR FileNameMftRef[] = {'$', 'M', 'F', 'T', 'M', 'i', 'r', 'r', 0 };
CONST WCHAR FileNameLogFile[] = {'$', 'L', 'o', 'g', 'F', 'i', 'l', 'e', 0 };
CONST WCHAR FileNameDasd[] = {'$', 'V', 'o', 'l', 'u', 'm', 'e', 0 };
CONST WCHAR FileNameAttrDef[] = {'$', 'A', 't', 't', 'r', 'D', 'e', 'f', 0 };
CONST WCHAR FileNameRootIndex[] = {'.', 0 };
CONST WCHAR FileNameBitmap[] = {'$', 'B', 'i', 't', 'm', 'a', 'p', 0 };
CONST WCHAR FileNameBootFile[] = {'$', 'B', 'o', 'o', 't', 0 };
CONST WCHAR FileNameBadFile[] = {'$', 'B', 'a', 'd', 'C', 'l', 'u', 's', 0 };
CONST WCHAR FileNameQuota[] = {'$', 'Q', 'u', 'o', 't', 'a', 0 };
CONST WCHAR FileNameUpcase[] = { '$', 'U', 'p', 'C', 'a', 's', 'e', 0 };


UNTFS_EXPORT
ULONG
NTFS_SA::QuerySectorsInElementaryStructures(
    IN  PCDP_DRIVE  Drive,
    IN  ULONG       ClusterFactor,
    IN  ULONG       FrsSize,
    IN  ULONG       ClustersPerIndexBuffer,
    IN  ULONG       LogFileSize
    )
/*++

Routine Description:

    This method computes the number of sectors required for
    the elementary structures of an NTFS volume.

Arguments:

    Drive                   --  Supplies the drive under consideration.
    ClusterFactor           --  Supplies the number of sectors per
                                cluster.  May be zero, in which case
                                a default value is supplied.
    FrsSize                 --  Supplies the number of bytes per
                                NTFS File Record Segment.  May be zero,
                                in which case a default value is supplied.
    ClustersPerIndexBuffer  --  Supplies the number of clusters per NTFS
                                index allocation buffer.  May be zero,
                                in which case a default value is supplied.
    LogFileSize             --  Supplies the size of the log file.  May
                                be zero, in which case a default value
                                is supplied.

Return Value:

    Returns the number of sectors required by an NTFS volume on
    this drive with the specified parameters.  Returns zero if
    it is unable to compute this figure.

--*/
{
    BIG_INT SectorsOnVolume;
    ULONG   SectorsRequired, ClusterSize, SectorSize;

#if 0
    if( Drive->QuerySectors().GetHighPart() != 0 ) {

        return 0;
    }
#endif

    SectorsOnVolume = Drive->QuerySectors() - 1;

    SectorSize = Drive->QuerySectorSize();

    if( SectorSize == 0 ) {

        return 0;
    }

    // compute defaults.
    //
    if( ClusterFactor == 0 ) {

        ClusterFactor = NTFS_SA::QueryDefaultClusterFactor( Drive );
    }

    if( FrsSize == 0 ) {
        FrsSize = SMALL_FRS_SIZE;
    }

    //
    //  We'll be in trouble if the frs size is less than the sector
    //  size, because we do all our io in units of sectors.
    //

    if (FrsSize < Drive->QuerySectorSize()) {
        FrsSize = Drive->QuerySectorSize();
    }

    if( ClustersPerIndexBuffer == 0 ) {

        ClustersPerIndexBuffer = QueryDefaultClustersPerIndexBuffer( Drive, ClusterFactor);
    }

    if( LogFileSize == 0 ) {

        LogFileSize = NTFS_LOG_FILE::QueryDefaultSize( Drive, SectorsOnVolume );
    }

    ClusterSize = ClusterFactor * SectorSize;

    // Now add up the various elementary structures:
    //
    // MFT
    //

    SectorsRequired = ((FIRST_USER_FILE_NUMBER * FrsSize + (ClusterSize - 1))
                       / ClusterSize) * ClusterFactor;

    // MFT Mirror
    //

    SectorsRequired += ((REFLECTED_MFT_SEGMENTS * FrsSize + (ClusterSize - 1))
                        / ClusterSize) * ClusterFactor;

    // Log file
    //

    SectorsRequired += LogFileSize/SectorSize + 1;

    // Attribute Definition Table
    //
    SectorsRequired += NTFS_ATTRIBUTE_DEFINITION_TABLE::QueryDefaultMaxSize()/SectorSize + 1;

    // Bitmap
    //

    // Number of clusters has to be within 32 bits
    //
    DebugAssert((SectorsOnVolume / ClusterFactor).GetHighPart() == 0);

    SectorsRequired += ((SectorsOnVolume / ClusterFactor).GetLowPart() / 8)/SectorSize + 1;

    // Boot file
    //
    SectorsRequired += BYTES_IN_BOOT_AREA/SectorSize;

    // Upcase Table
    //
    SectorsRequired += NTFS_UPCASE_TABLE::QueryDefaultSize()/SectorSize;

    // The Volume DASD file, the Bad Cluster file, and the Quota
    // Table don't take up any extra space.

    return SectorsRequired;
}



UNTFS_EXPORT
BOOLEAN
NTFS_SA::WriteRemainingBootCode(
    )
/*++

Routine Description:

    This method writes the remainder of the boot code, ie. the
    portion that is not stored in the first sector (which is
    written when the superarea itself is written).

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    HMEM BootCodeMem;
    SECRUN BootCodeSecrun;
    ULONG SectorsInBootArea, SectorSize;

    SectorSize = _drive->QuerySectorSize();

    SectorsInBootArea = ( BYTES_IN_BOOT_AREA % SectorSize ) ?
                            ( BYTES_IN_BOOT_AREA / SectorSize + 1 ) :
                            ( BYTES_IN_BOOT_AREA / SectorSize );

    if( !BootCodeMem.Initialize() ||
        !BootCodeSecrun.Initialize( &BootCodeMem,
                                    _drive,
                                    1,
                                    SectorsInBootArea - 1 ) ) {

        return FALSE;
    }

    memcpy( BootCodeSecrun.GetBuf(),
            _bootcode + SectorSize,
            _bootcodesize - SectorSize );

    if( !BootCodeSecrun.Write( ) ) {

        return FALSE;
    }

    SetSystemId();

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_SA::CreateElementaryStructures(
    IN OUT  PNTFS_BITMAP            VolumeBitmap,
    IN      ULONG                   ClusterFactor,
    IN      ULONG                   FrsSize,
    IN      ULONG                   IndexBufferSize,
    IN      ULONG                   InitialLogFileSize,
    IN      PCNUMBER_SET            BadSectors,
    IN      BOOLEAN                 BackwardCompatible,
    IN      BOOLEAN                 IsConvert,
    IN OUT  PMESSAGE                Message,
    IN      PBIOS_PARAMETER_BLOCK   OldBpb,
    IN      PCWSTRING               Label
    )
/*++

Routine Description:

    This method creates the system-defined files on the volume.  Note
    that it does not write the superarea (ie. the boot sectors).

Arguments:

    VolumeBitmap            --  Supplies the bitmap for the volume.
    ClusterFactor           --  Supplies the number of sectors per cluster.
    FrsSize                 --  Supplies the size of each FRS (in bytes).
    IndexBufferSize         --  Supplies the volume default index allocation
                                buffer size.
    InitialLogFileSize      --  Supplies the initial size of the log file.
                                If zero is given for this parameter, this
                                method will choose a default size based on
                                the size of the volume.
    BadSectors              --  Supplies a list of the bad sectors on the disk.
    BackwardCompatible      --  TRUE if volume is not suppose to be upgraded;
                                FALSE if volume is suppose to be upgraded on mount.
    Message                 --  Supplies an outlet for messages.
    OldBpb                  --  Supplies a pointer to the volume's existing
                                Bios Parameter Block.  If this parameter
                                is present, then the disk geometry information
                                (Sectors per Track, Heads, and HiddenSectors)
                                are copied from it; otherwise, they are
                                queried from the drive.
    Label                   --  Supplies an optional volume label (may be NULL)
    IsConvert               --  TRUE if we are being called to convert a FAT partition to NTFS.
                                FALSE if we are being called to format a partition.

Return Value:

    TRUE upon successful completion.

Notes:

    The supplied Bitmap is updated and written to disk.

    We want the volume layout to be something like this:

#ifdef LOGFILE_PLACEMENT_V1
        0   $Boot

        3GB ||
        1GB ||
        n/3 $LogFile
            $Mft Bitmap (at least 8k)
            $Mft

        n/2 $MftMirr
            $AttrDef
            $Bitmap
            $UpCase
            root index allocation
#else
        0   $Boot
            $Mft Bitmap (at least 8k)
            $Mft

            $AttrDef

        n/2 $MftMirr
            $LogFile
            root index allocation
            $Bitmap
            $UpCase
            $SDS
#endif

--*/
{

    NUMBER_SET                          BadClusters;
    NTFS_MFT_FILE                       MftFile;
    NTFS_REFLECTED_MASTER_FILE_TABLE    MftReflection;
    NTFS_ATTRIBUTE_DEFINITION_TABLE     AttributeDefinitionTable;
    NTFS_BAD_CLUSTER_FILE               BadClusterFile;
    NTFS_BITMAP_FILE                    BitmapFile;
    NTFS_BOOT_FILE                      BootFile;
    NTFS_LOG_FILE                       LogFile;
    NTFS_FILE_RECORD_SEGMENT            RootIndexFile;
    NTFS_FILE_RECORD_SEGMENT            QuotaFile;
    NTFS_FILE_RECORD_SEGMENT            VolumeDasdFile;
    NTFS_FILE_RECORD_SEGMENT            GenericFrs;
    NTFS_INDEX_TREE                     RootIndex;
    NTFS_ATTRIBUTE                      BitmapAttribute;
    NTFS_ATTRIBUTE                      VolumeInformationAttribute;
    DSTRING                             RootIndexName;
    NTFS_UPCASE_FILE                    UpcaseFile;
    NTFS_UPCASE_TABLE                   UpcaseTable;

    MFT_SEGMENT_REFERENCE               RootFileIndexSegment;
    STANDARD_INFORMATION                StandardInformation;
    VOLUME_INFORMATION                  VolumeInformation;
    LARGE_INTEGER                       SystemTime;
    LCN                                 InitialMftLcn;
    LCN                                 MftLcn;
    LCN                                 Lcn;
    LCN                                 LogFileNearLcn;
    ULONG                               i;
    ULONG                               nFirstUserFrs;
    ULONG                               ClusterSize;
    ULONG                               ClustersInBootArea;
    ULONG                               MftSize;
    BIG_INT                             NumberOfSectors;
    BIG_INT                             ClustersNeeded;
    PWSTR                               LabelString;
    ULONG                               NumBootClusters;

    CANNED_SECURITY_TYPE RootACL;

    CONST FileNameBufferSize = 256;
    CHAR FileNameBuffer[ FileNameBufferSize ];
    CONST PFILE_NAME FileName = (PFILE_NAME)(FileNameBuffer);
    CONST PVOID FileNameValue = NtfsFileNameGetName( FileName );

#if 0
    // Determine the size of the volume:
    //
    if (_drive->QuerySectors().GetHighPart() != 0) {

        DebugAbort("Number of sectors exceeds 32 bits");
        return FALSE;
    }
#endif

    NumberOfSectors = _drive->QuerySectors() - 1;

    //
    // The replica boot sector will be just past the end of the volume.
    //

    if (_boot2 != 0 && _boot2 != NumberOfSectors) {

        DebugPrintTrace(("NTFS_SA::CreateElementary - found _boot2 incorrect.\n"));
    }

    _boot2 = NumberOfSectors;


    if (!IsConvert) {

        memset( _boot_sector->Oem, 0, 8 );

        if (!Write(Message)) {
            DebugPrintTrace(("UNTFS: Unable to wipe out boot sector signature\n"));
        }

        // clear up any FAT/FAT32 reserved sectors

        PBYTE   ZeroBuf = (PBYTE)MALLOC(_drive->QuerySectorSize());

        if (ZeroBuf == NULL) {
            Message->Set( MSG_FMT_NO_MEMORY );
            Message->Display( "" );
            return FALSE;
        }
        memset(ZeroBuf, 0, _drive->QuerySectorSize());

        for (i=1; i<32; i++) {
            if (!_drive->Write(i, 1, ZeroBuf)) {
                DebugPrintTrace(("UNTFS: Unable to clean sector %d\n", i));
            }
        }
        FREE(ZeroBuf);
    }

    // Set up the Standard Information structure that will
    // be used by all the special files.  The creation and modification
    // times are now, and all files created by format are hidden.

    memset( (PVOID)&StandardInformation,
            0,
            sizeof(STANDARD_INFORMATION) );

    IFS_SYSTEM::QueryNtfsTime( &SystemTime );

    StandardInformation.CreationTime =
        StandardInformation.LastModificationTime =
        StandardInformation.LastChangeTime =
        StandardInformation.LastAccessTime = SystemTime;

    StandardInformation.FileAttributes = FILE_ATTRIBUTE_HIDDEN |
                                         FILE_ATTRIBUTE_SYSTEM;

    // Get the default system upcase table
    //
    if( !UpcaseTable.Initialize() ) {

        DebugAbort( "Can't initialize upcase table.\n" );
        return FALSE;
    }

    // Calculate the cluster size.  Currently cluster sizes greater
    // than 64k are not supported, so make sure we don't create volumes
    // with larger clusters.
    //

    ClusterSize = ClusterFactor * _drive->QuerySectorSize();

    if (ClusterSize > 64 * 1024) {

        ClusterSize = 64 * 1024;
        ClusterFactor = ClusterSize / _drive->QuerySectorSize();
    }

    // Clear the boot block and the backup boot cluster in the
    // bitmap.  Note that these will get set immediately after
    // the bad sectors are marked as in use--this allows me to
    // detect if these sectors are on the bad sector list.
    //

    ClustersInBootArea = (BYTES_IN_BOOT_AREA % ClusterSize) ?
                            BYTES_IN_BOOT_AREA / ClusterSize + 1 :
                            BYTES_IN_BOOT_AREA / ClusterSize;

    NumBootClusters = max(1, BYTES_PER_BOOT_SECTOR/ClusterSize);

    VolumeBitmap->SetFree( 0, ClustersInBootArea );

    // Convert the Bad Sectors to Bad Clusters, and mark those
    // clusters as in-use in the bitmap.  Note that we have to
    // check for duplicates, or else the Bad Cluster File will
    // choke on the list.

    if( !BadClusters.Initialize() ) {

        Message->Set( MSG_FMT_NO_MEMORY );
        Message->Display( "" );

        DebugPrint( "Can't initialize bad clusters numset.\n" );
        return FALSE;
    }

    for( i = 0; i < BadSectors->QueryCardinality(); i++ ) {

        Lcn = BadSectors->QueryNumber(i)/ClusterFactor;

        BadClusters.Add( Lcn );
        VolumeBitmap->SetAllocated( Lcn, 1 );
    }


    // The first BYTES_IN_BOOT_AREA bytes on the volume and
    // the cluster which contains the middle sector of the volume
    // are reserved for the Boot file.  If these sectors are not
    // free, it means that we have bad sectors in one of these
    // reserved spots.  We won't allow such a volume to be formatted
    // to NTFS.

    if( !VolumeBitmap->IsFree( 0, ClustersInBootArea )) {

        DebugPrint( "Boot sector is in bad cluster list.\n" );
        return FALSE;
    }

    VolumeBitmap->SetAllocated( 0, ClustersInBootArea );

    // Allocate space for the MFT itself.  We want the mft bitmap to
    // be immediately after the primary boot cluster, with the Mft following,
    // so we leave space for the mft bitmap.
    //

    MftSize = (FIRST_USER_FILE_NUMBER * FrsSize + (ClusterSize - 1))/ClusterSize;

    if (_cvt_zone != 0 && _cvt_zone_size != 0) {
        //
        // Make those reserved clusters appear to be unused
        // so that it will be allocated for the MFT and Logfile
        //
        DebugAssert(VolumeBitmap->IsAllocated(_cvt_zone, _cvt_zone_size));
        VolumeBitmap->SetFree(_cvt_zone, _cvt_zone_size);

        //
        // Figure out the amount of space needed
        //
        ULONG log_file_size = InitialLogFileSize ?
                            InitialLogFileSize :
                            NTFS_LOG_FILE::QueryDefaultSize(_drive, _drive->QuerySectors());
        ClustersNeeded = log_file_size/ClusterSize;
        if (log_file_size % ClusterSize)
            ClustersNeeded = ClustersNeeded + 1;

        ClustersNeeded = ClustersNeeded + (MFT_BITMAP_INITIAL_SIZE + (ClusterSize - 1))/ClusterSize;
        MftLcn = _cvt_zone + ClustersNeeded;
        ClustersNeeded = ClustersNeeded + MftSize;
    }

    if (_cvt_zone == 0 || _cvt_zone_size == 0 || _cvt_zone_size < ClustersNeeded) {
        if (_cvt_zone != 0) {
            Message->Set( MSG_CONV_CVTAREA_TOO_SMALL );
            Message->Display( "%d", (ClustersNeeded*ClusterSize-1)/(1024*1024)+1 );
        }
        _cvt_zone_size = 0;
        _cvt_zone = 0;
        ClustersNeeded = 0;
#if LOGFILE_PLACEMENT_V1
        #define ONE_GB 0x40000000U
        if (_drive->QuerySectors() < (2 * ONE_GB / _drive->QuerySectorSize())) {
            MftLcn = (_drive->QuerySectors() / 3) / ClusterFactor;
        } else if (_drive->QuerySectors() < ((BIG_INT)6 * ONE_GB / _drive->QuerySectorSize())) {
            MftLcn = ONE_GB / ClusterSize; // put it at 1GB for now
        } else {
            MftLcn = (3 * ONE_GB) / ClusterSize; // put it at 3GB for now
        }
#else
        MftLcn = ClustersInBootArea +
                    (MFT_BITMAP_INITIAL_SIZE + (ClusterSize - 1))/ClusterSize;
#endif
    } else {
        InitialMftLcn = MftLcn;
    }

    if( !VolumeBitmap->AllocateClusters( MftLcn, MftSize, &MftLcn ) ) {

        DebugPrint( "Can't allocate space for the MFT.\n" );
        return FALSE;
    }

    if (ClustersNeeded != 0) {
        //
        // Make sure those reserved clusters are used as expected
        //
        DebugAssert(MftLcn == InitialMftLcn);
        DebugAssert(VolumeBitmap->IsAllocated(InitialMftLcn, MftSize));
    }


#if LOGFILE_PLACEMENT_V1
    LogFileNearLcn = MftLcn - ((MFT_BITMAP_INITIAL_SIZE + (ClusterSize - 1))/ClusterSize);
#endif // PLACEMENT_EXP

    // Another bit of housecleaning:  I need the file segment reference
    // of the root file name index so I can add file-name attributes
    // to the system files.  The initial sequence number of the Root
    // File Index FRS is the same as its file number.
    //

    RootFileIndexSegment.LowPart = ROOT_FILE_NAME_INDEX_NUMBER;
    RootFileIndexSegment.HighPart = 0;
    RootFileIndexSegment.SequenceNumber = ROOT_FILE_NAME_INDEX_NUMBER;

    if( !RootIndexName.Initialize( FileNameIndexNameData ) ||
        !RootIndex.Initialize( $FILE_NAME,
                               _drive,
                               ClusterFactor,
                               VolumeBitmap,
                               &UpcaseTable,
                               COLLATION_FILE_NAME,
                               IndexBufferSize,
                               FrsSize / 2,
                               &RootIndexName ) ) {

        DebugPrint( "Cannot initialize Index Tree for root file name index.\n" );
        return FALSE;
    }

    // These "Hidden Status" messages are a hack to allow WinDisk to
    // cancel a quick format, which ordinarily doesn't send any status
    // messages, but which might take a while and for which there is a
    // cancel button.  When using format.com, no message will be displayed
    // for this.

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize and create the MFT.  Note that this will not
    // actually write the MFT to disk.

    // Set up the FILE_NAME attribute.

    memset( FileName,
            0,
            FileNameBufferSize );

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameMft );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameMft,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !MftFile.Initialize( _drive,
                             MftLcn,
                             ClusterFactor,
                             FrsSize,
                             _drive->QuerySectors() - 1,
                             VolumeBitmap,
                             &UpcaseTable ) ||
        !MftFile.Create( FIRST_USER_FILE_NUMBER,
                         &StandardInformation,
                         VolumeBitmap ) ||
        !MftFile.AddFileNameAttribute( FileName ) ||
        !MftFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                MftFile.QuerySegmentReference() ) ) {

        DebugPrint( "Can't create MFT.\n" );
        return FALSE;
    }

#if LOGFILE_PLACEMENT_V1
    // Initialize, create, and write the log file.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameLogFile );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameLogFile,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !LogFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !LogFile.Create( &StandardInformation,
                         LogFileNearLcn,
                         InitialLogFileSize,
                         VolumeBitmap ) ||
        !LogFile.AddFileNameAttribute( FileName ) ||
        !LogFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                LogFile.QuerySegmentReference() ) ||
        !LogFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Log File.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }
#endif

    // Initialize, create, and write the reflection of the Master
    // File Table.  Note that this allocates space for the MFT
    // Reflection's data attribute, but does not write the data
    // attribute.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameMftRef );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameMftRef,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !MftReflection.Initialize( MftFile.GetMasterFileTable() ) ||
        !MftReflection.Create( &StandardInformation,
                               VolumeBitmap ) ||
        !MftReflection.AddFileNameAttribute( FileName ) ||
        !MftReflection.AddSecurityDescriptor( ReadCannedSd,
                                              VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                MftReflection.QuerySegmentReference() ) ||
        !MftReflection.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create MFT Reflection.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

#if !defined(LOGFILE_PLACEMENT_V1)
    // Initialize, create, and write the log file.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameLogFile );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameLogFile,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !LogFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !LogFile.Create( &StandardInformation,
                         0,
                         InitialLogFileSize,
                         VolumeBitmap ) ||
        !LogFile.AddFileNameAttribute( FileName ) ||
        !LogFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                LogFile.QuerySegmentReference() ) ||
        !LogFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Log File.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }
#endif

    // Initialize, create, and write an empty file for the Volume DASD info.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameDasd );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameDasd,
            FileName->FileNameLength * sizeof( WCHAR ) );

    // Set up the volume information attribute.
    //
    memset(&VolumeInformation, 0, sizeof(VOLUME_INFORMATION));

    VolumeInformation.MajorVersion = NTFS_CURRENT_MAJOR_VERSION;
    VolumeInformation.MinorVersion = NTFS_CURRENT_MINOR_VERSION;
    VolumeInformation.VolumeFlags = 0;
    if (!BackwardCompatible)
        VolumeInformation.VolumeFlags |= VOLUME_UPGRADE_ON_MOUNT;

    if (!VolumeInformationAttribute.Initialize(_drive, ClusterFactor,
            &VolumeInformation, sizeof(VOLUME_INFORMATION),
            $VOLUME_INFORMATION)) {

        DebugPrint( "Can't create volume information attribute.\n" );
        return FALSE;
    }

    if (Label) {
        LabelString = Label->QueryWSTR();
    } else {
        LabelString = NULL;
    }

    if( !VolumeDasdFile.Initialize( VOLUME_DASD_NUMBER,
                                    MftFile.GetMasterFileTable() ) ||
        !VolumeDasdFile.Create( &StandardInformation ) ||
        !VolumeDasdFile.AddFileNameAttribute( FileName ) ||
        !VolumeDasdFile.AddSecurityDescriptor( WriteCannedSd, VolumeBitmap ) ||
        !VolumeDasdFile.AddEmptyAttribute( $DATA ) ||
        !(LabelString == NULL ||
          VolumeDasdFile.AddAttribute( $VOLUME_NAME, NULL, LabelString,
                                       Label->QueryChCount()*sizeof(WCHAR),
                                       VolumeBitmap )) ||
        !VolumeInformationAttribute.InsertIntoFile( &VolumeDasdFile,
                                                    NULL ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                VolumeDasdFile.QuerySegmentReference() ) ||
        !VolumeDasdFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Volume DASD file.\n" );
        return FALSE;
    }

    DELETE(LabelString);

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the Attribute Definition Table
    // File Record Segment.  This will also allocate and write the
    // Attribute Definition Table's DATA attribute, which is the
    // actual attribute definition table.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameAttrDef );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameAttrDef,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !AttributeDefinitionTable.Initialize( MftFile.GetMasterFileTable(),
                                              1) ||
        !AttributeDefinitionTable.Create( &StandardInformation,
                                          VolumeBitmap ) ||
        !AttributeDefinitionTable.AddFileNameAttribute( FileName ) ||
        !AttributeDefinitionTable.AddSecurityDescriptor( ReadCannedSd,
                                                         VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                AttributeDefinitionTable.
                                            QuerySegmentReference() ) ||
        !AttributeDefinitionTable.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Attribute Definition Table.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the FRS for the root file name
    // index.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameRootIndex );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameRootIndex,
            FileName->FileNameLength * sizeof( WCHAR ) );

    // If we are converting, use a generic ACL

    if (IsConvert) {
        RootACL = NoAclCannedSd;
    } else {
        RootACL = NewRootSd;
    }

    if( !RootIndexFile.Initialize( ROOT_FILE_NAME_INDEX_NUMBER,
                                   MftFile.GetMasterFileTable() ) ||
        !RootIndexFile.Create( &StandardInformation,
                               FILE_FILE_NAME_INDEX_PRESENT ) ||
        !RootIndexFile.AddFileNameAttribute( FileName ) ||
        !RootIndexFile.AddSecurityDescriptor( RootACL,
                                              VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                RootIndexFile.QuerySegmentReference() ) ||
        !RootIndexFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Root Index FRS.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the bitmap File Record Segment.
    // Note that this does not write the bitmap, just its File Record
    // Segment.  Note also that the disk space for the bitmap is
    // allocated at this time.


    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameBitmap );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameBitmap,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !BitmapFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BitmapFile.Create( &StandardInformation, VolumeBitmap ) ||
        !BitmapFile.AddFileNameAttribute( FileName ) ||
        !BitmapFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                BitmapFile.QuerySegmentReference() ) ||
        !BitmapFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Bitmap File.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the Boot-File File Record Segment.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameBootFile );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameBootFile,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !BootFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BootFile.Create( &StandardInformation ) ||
        !BootFile.AddFileNameAttribute( FileName ) ||
        !BootFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                BootFile.QuerySegmentReference() ) ||
        !BootFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create boot file.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the Bad Cluster File.
    //
    // Set up the FILE_NAME attribute.
    //
    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameBadFile );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameBadFile,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !BadClusterFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BadClusterFile.Create( &StandardInformation,
                                VolumeBitmap,
                                &BadClusters ) ||
        !BadClusterFile.AddFileNameAttribute( FileName ) ||
        !BadClusterFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                BadClusterFile.QuerySegmentReference() ) ||
        !BadClusterFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Bad Cluster File.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Initialize, create, and write the Quota Table.

    // Set up the FILE_NAME attribute.

    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameQuota );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameQuota,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !QuotaFile.Initialize( QUOTA_TABLE_NUMBER,
                               MftFile.GetMasterFileTable() ) ||
        !QuotaFile.Create( &StandardInformation ) ||
        !QuotaFile.AddEmptyAttribute( $DATA ) ||
        !QuotaFile.AddFileNameAttribute( FileName ) ||
        !QuotaFile.AddSecurityDescriptor( WriteCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                QuotaFile.QuerySegmentReference() ) ||
        !QuotaFile.Flush(VolumeBitmap, &RootIndex) ) {

        DebugPrint( "Can't create Quota Table File Record Segment.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    // Create the Upcase Table file.
    //
    // Set up the FILE_NAME attribute.
    //
    FileName->ParentDirectory = RootFileIndexSegment;
    FileName->FileNameLength = (UCHAR)wcslen( FileNameUpcase );
    FileName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    memset( FileNameValue,
            0,
            FileNameBufferSize - sizeof( FILE_NAME ) );

    memcpy( FileNameValue,
            FileNameUpcase,
            FileName->FileNameLength * sizeof( WCHAR ) );

    if( !UpcaseFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !UpcaseFile.Create( &StandardInformation,
                            &UpcaseTable,
                            VolumeBitmap ) ||
        !UpcaseFile.AddFileNameAttribute( FileName ) ||
        !UpcaseFile.AddSecurityDescriptor( ReadCannedSd, VolumeBitmap ) ||
        !RootIndex.InsertEntry( NtfsFileNameGetLength( FileName ),
                                FileName,
                                UpcaseFile.QuerySegmentReference() ) ||
        !UpcaseFile.Flush( VolumeBitmap, &RootIndex ) ) {

        DebugPrint( "Can't create Upcase Table File Record Segment.\n" );
        return FALSE;
    }



    // The reserved FRS's between the Upcase Table and the first user
    // file must be valid and in-use.

    if (ClusterSize > (FrsSize*FIRST_USER_FILE_NUMBER))
        nFirstUserFrs = (ClusterSize + FrsSize - 1) / FrsSize;
    else
        nFirstUserFrs = FIRST_USER_FILE_NUMBER;

    for( i = UPCASE_TABLE_NUMBER + 1; i < nFirstUserFrs; i++ ) {

        if( !GenericFrs.Initialize( i,
                                    MftFile.GetMasterFileTable() ) ||
            !GenericFrs.Create( &StandardInformation ) ||
            !GenericFrs.AddEmptyAttribute( $DATA ) ||
            !GenericFrs.AddSecurityDescriptor( WriteCannedSd,
                                               VolumeBitmap ) ||
            ((i >= FIRST_USER_FILE_NUMBER) && (GenericFrs.ClearInUse(), FALSE)) ||
            !GenericFrs.Flush( VolumeBitmap ) ) {

            DebugPrint( "Can't create a generic FRS.\n" );
            return FALSE;
        }
    }


    // Construct the root file name index.


    if( !RootIndex.Save( &RootIndexFile ) ||
        !RootIndexFile.Flush(VolumeBitmap) ) {

        DebugPrint( "Can't save root index.\n" );
        return FALSE;
    }


    // Flush the MFT.  Note that flushing the MFT writes the volume
    // bitmap and the MFT Mirror.

    if( !MftFile.Flush() ) {

        DebugPrint( "Can't flush MFT.\n" );
        return FALSE;
    }

    Message->Set(MSG_HIDDEN_STATUS, NORMAL_MESSAGE, 0);
    if (!Message->Display()) {
        return FALSE;
    }

    memset( _boot_sector->Unused1, 0, sizeof(_boot_sector->Unused1) );
    memset( _boot_sector->Unused2, 0, sizeof(_boot_sector->Unused2) );

    // Fill in sector zero.  First, copy the boot code in.  Then
    // set the fields of interest.
    //
    memcpy( _boot_sector, _bootcode, _drive->QuerySectorSize() );

    memcpy( _boot_sector->Oem, "NTFS    ", 8 );

    _bpb.BytesPerSector = (USHORT)_drive->QuerySectorSize();
    _bpb.SectorsPerCluster = (UCHAR)ClusterFactor;
    _bpb.ReservedSectors = 0;
    _bpb.Fats = 0;
    _bpb.RootEntries = 0;
    _bpb.Sectors = 0;
    _bpb.Media = _drive->QueryMediaByte();
    _bpb.SectorsPerFat = 0;

    if( OldBpb == NULL ) {

        // Use geometry supplied by the driver.
        //
        _bpb.SectorsPerTrack = (USHORT) _drive->QuerySectorsPerTrack();
        _bpb.Heads = (USHORT) _drive->QueryHeads();
        _bpb.HiddenSectors = _drive->QueryHiddenSectors().GetLowPart();

    } else {

        // Use geometry recorded in the existing Bios
        // Parameter Block.
        //
        _bpb.SectorsPerTrack = OldBpb->SectorsPerTrack;
        _bpb.Heads = OldBpb->Heads;
        _bpb.HiddenSectors = OldBpb->HiddenSectors;
    }

    _bpb.LargeSectors = 0;

    // Unused[0] is used by the boot code to indicate Drive Number.
    //
    memset( _boot_sector->Unused, '\0', 4 );

    memset( _boot_sector->Unused1, '\0', sizeof(_boot_sector->Unused1) );
    memset( _boot_sector->Unused2, '\0', sizeof(_boot_sector->Unused2) );

    _boot_sector->Unused[0] = _drive->IsRemovable() ? PHYS_REMOVABLE :
                                                      PHYS_FIXED ;

    _boot_sector->NumberSectors = (_drive->QuerySectors() - 1).GetLargeInteger();

    _boot_sector->MftStartLcn = MftLcn;
    _boot_sector->Mft2StartLcn = MftReflection.QueryFirstLcn();

    // If the frs size is less than the cluster size, we write 0 in the
    // ClustersPerFileRecordSegment.  In that case the actual frs size
    // should be SMALL_FRS_SIZE.
    //

    // If the frs size is greater than or equal to the cluster size, we
    // write cluster size divided by frs size into the ClustersPerFrs field.
    // Otherwise, we will want the frs size to be 1024 bytes, and we will
    // set the ClustersPerFileRecordSegment to the negation of the log (base 2)
    // of 1024.
    //

    ULONG cluster_size = ClusterFactor * _drive->QuerySectorSize();

    if (FrsSize < cluster_size) {

        ULONG temp;
        LONG j;

        for (j = 0, temp = FrsSize; temp > 1; temp >>= 1) {
            j++;
        }

        _boot_sector->ClustersPerFileRecordSegment = CHAR(-j);

    } else {

        _boot_sector->ClustersPerFileRecordSegment = CHAR(FrsSize / cluster_size);
    }

    // The treatment of DefaultClustersPerIndexBuffer is similar to that of
    // ClustersPerFRS, except we use SMALL_INDEX_BUFFER_SIZE if the clusters
    // are larger than a cluster.
    //

    if (IndexBufferSize < cluster_size) {

        ULONG temp;
        LONG j;

        for (j = 0, temp = SMALL_INDEX_BUFFER_SIZE; temp > 1; temp >>= 1) {
            j++;
        }

        _boot_sector->DefaultClustersPerIndexAllocationBuffer = CHAR(-j);

    } else {

        _boot_sector->DefaultClustersPerIndexAllocationBuffer =
            CHAR(IndexBufferSize / cluster_size);
    }

    _boot_sector->SerialNumber.LowPart = SUPERAREA::ComputeVolId();
    _boot_sector->SerialNumber.HighPart =
            SUPERAREA::ComputeVolId(_boot_sector->SerialNumber.LowPart);

    _boot_sector->Checksum = 0;

    // The elementary disk structures have been created.

    return TRUE;
}

BOOLEAN
NTFS_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      ULONG           Flags,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSectors
    )
/*++

Routine Description:

    This routine creates a new NTFS volume on disk based on defaults.

Arguments:

    BadSectors  - Supplies a list of the bad sectors on the disk.
    Message     - Supplies an outlet for messages.
    Label       - Supplies an optional volume label (may be NULL).
    ClusterSize - Supplies the desired size of a cluster in bytes.
    Flags       - Supplies various flags from format.


Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   ClusterFactor, ClustersPerIndexBuffer;
    BOOLEAN BackwardCompatible = ((Flags & FORMAT_BACKWARD_COMPATIBLE) ? TRUE : FALSE);

    UNREFERENCED_PARAMETER( VirtualSectors );

    if (ClusterSize) {
        if (ClusterSize > 64*1024) {
            Message->Set(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
            Message->Display();
            return FALSE;
        }
        ClusterFactor = max(1, ClusterSize/_drive->QuerySectorSize());
    } else {
        ClusterFactor = QueryDefaultClusterFactor( _drive );
    }

    if (ClusterSize != 0 &&
        ClusterFactor * _drive->QuerySectorSize() != ClusterSize) {

        Message->Set(MSG_FMT_ALLOCATION_SIZE_CHANGED);
        Message->Display("%d", ClusterFactor * _drive->QuerySectorSize());
    }

    return( Create( BadSectors,
                    ClusterFactor,
                    SMALL_FRS_SIZE,
                    SMALL_INDEX_BUFFER_SIZE,
                    0,
                    BackwardCompatible,
                    Message,
                    Label ) );
}

BOOLEAN
NTFS_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN      ULONG           ClusterFactor,
    IN      ULONG           FrsSize,
    IN      ULONG           IndexBufferSize,
    IN      ULONG           InitialLogFileSize,
    IN      BOOLEAN         BackwardCompatible,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label
    )
/*++

Routine Description:

    This routine creates a new NTFS volume on disk.

Arguments:

    BadSectors              --  Supplies a list of the bad sectors
                                on the disk.
    ClusterFactor           --  Supplies the volume cluster factor
    FrsSize                 --  Supplies the size of each FRS
    IndexBufferSize         --  Supplies the default size of
                                an index allocation block.
    InitialLogFileSize      --  Supplies the log file size.  May be zero,
                                in which case a default value is used.
    BackwardCompatible      --  TRUE if volume is not suppose to be upgraded;
                                FALSE if volume is suppose to be upgraded on mount.
    Message                 --  Supplies an outlet for messages.
    Label                   --  Supplies an optional volume label
                                (may be NULL).

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_BITMAP VolumeBitmap;
    DSTRING InternalLabel;
    SECRUN BootCodeSecrun;
    HMEM BootCodeMem;

    BIG_INT KBytesInVolume;
    BIG_INT NumberOfSectors;
    ULONG NumberOfClusters, SectorSize, ClusterSize, SectorsInBootArea;


#if 0
    // For testing, add a bad cluster.
    //
    ((PNUMBER_SET) BadSectors)->Add( _drive->QuerySectors() - 16 );
#endif


    // Determine the number of sectors and clusters on the drive.

    if ((_drive->QuerySectors()/ClusterFactor).GetHighPart() != 0) {

        Message->Set( MSG_FMT_TOO_MANY_CLUSTERS );
        Message->Display( "" );
        return FALSE;
    }


    NumberOfSectors = _drive->QuerySectors()- 1;
    NumberOfClusters = (NumberOfSectors/ClusterFactor).GetLowPart();

    // We're currently not prepared to deal with disks where the frs
    // size is smaller than the sector size, so bump the frs size
    // up if that is the case.  Same deal with the default index buffer
    // size.
    //

    if (FrsSize < _drive->QuerySectorSize()) {

        FrsSize = _drive->QuerySectorSize();
    }
    if (IndexBufferSize < _drive->QuerySectorSize()) {

        IndexBufferSize = _drive->QuerySectorSize();
    }

    // The replica boot sector will be at the very end of the volume.

    _boot2 = NumberOfSectors;

    // Generate a bitmap to cover the number of clusters on the drive.

    if (!VolumeBitmap.Initialize(NumberOfClusters, FALSE, NULL, 0)) {

        DebugPrint( "Cannot initialize bitmap.\n" );
        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    // If the user did not specify a label, prompt for it:
    //
    if (Label) {
        if (!InternalLabel.Initialize(Label)) {
            return FALSE;
        }
    } else {
        Message->Set(MSG_VOLUME_LABEL_NO_MAX);
        Message->Display("");
        Message->QueryStringInput(&InternalLabel);
    }

    while( !IsValidLabel(&InternalLabel)) {

        Message->Set(MSG_INVALID_LABEL_CHARACTERS);
        Message->Display("");

        Message->Set(MSG_VOLUME_LABEL_NO_MAX);
        Message->Display("");
        Message->QueryStringInput(&InternalLabel);
    }

    Message->Set( MSG_FMT_CREATING_FILE_SYSTEM );
    Message->Display( "" );

    // Create the elementary file system structures.  Pass in
    // zero for the initial log file size to indicate that
    // CreateElementaryStructures should choose the size of
    // the log file, and NULL for the OldBpb to indicate that
    // it should use the geometry information from the drive.
    //
    if( !CreateElementaryStructures( &VolumeBitmap,
                                     ClusterFactor,
                                     FrsSize,
                                     IndexBufferSize,
                                     InitialLogFileSize,
                                     BadSectors,
                                     BackwardCompatible,
                                     FALSE,
                                     Message,
                                     NULL,
                                     &InternalLabel ) ) {

        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    if( !Write( Message ) ) {

        DebugPrint( "UNTFS: Unable to write superarea.\n" );
        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    // Write the rest of the boot code:
    //
    SectorSize = _drive->QuerySectorSize();

    SectorsInBootArea = ( BYTES_IN_BOOT_AREA % SectorSize ) ?
                            BYTES_IN_BOOT_AREA / SectorSize + 1 :
                            BYTES_IN_BOOT_AREA / SectorSize;

    if( !BootCodeMem.Initialize() ||
        !BootCodeSecrun.Initialize( &BootCodeMem,
                                    _drive,
                                    1,
                                    SectorsInBootArea - 1 ) ) {

        DebugPrint( "UNTFS: Unable to write boot code.\n" );
        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    memcpy( BootCodeSecrun.GetBuf(),
            _bootcode + _drive->QuerySectorSize(),
            _bootcodesize - _drive->QuerySectorSize() );

    if( !BootCodeSecrun.Write( ) ) {

        DebugPrint( "UNTFS: Unable to write boot code.\n" );
        Message->Set( MSG_FORMAT_FAILED );
        Message->Display( "" );
        return FALSE;
    }

    if (!SetSystemId()) {
        Message->Set(MSG_WRITE_PARTITION_TABLE);
        Message->Display("");
        return FALSE;
    }

    Message->Set(MSG_FORMAT_COMPLETE);
    Message->Display("");

    // -----------------------
    // Generate a nice report.
    // -----------------------
    //
    ClusterSize = ClusterFactor * _drive->QuerySectorSize();

    KBytesInVolume = NumberOfClusters;
    KBytesInVolume = KBytesInVolume * ClusterSize / 1024;

    if (KBytesInVolume.GetHighPart() != 0) {
        Message->Set(MSG_TOTAL_MEGABYTES);
        Message->Display("%10u", (KBytesInVolume / 1024).GetLowPart()  );

    } else {
        Message->Set(MSG_TOTAL_KILOBYTES);
        Message->Display("%10u", KBytesInVolume.GetLowPart()  );
    }

    KBytesInVolume = (ClusterSize * VolumeBitmap.QueryFreeClusters())/1024;
    if (KBytesInVolume.GetHighPart() != 0) {
        Message->Set(MSG_AVAILABLE_MEGABYTES);
        Message->Display("%10u", (KBytesInVolume / 1024).GetLowPart() );
    } else {
        Message->Set(MSG_AVAILABLE_KILOBYTES);
        Message->Display("%10u", KBytesInVolume.GetLowPart() );
    }

    return TRUE;
}

VOID
NTFS_SA::PrintFormatReport (
    IN OUT PMESSAGE                     Message,
    IN     PFILE_FS_SIZE_INFORMATION    FsSizeInfo,
    IN     PFILE_FS_VOLUME_INFORMATION  FsVolInfo
    )
{
    DebugAbort("This should never be called\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\frsstruc.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "frsstruc.hxx"
#include "mem.hxx"
#include "attrib.hxx"
#include "drive.hxx"
#include "clusrun.hxx"
#include "wstring.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "ntfsbit.hxx"
#include "bigint.hxx"
#include "numset.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( NTFS_FRS_STRUCTURE, OBJECT, UNTFS_EXPORT );


UNTFS_EXPORT
NTFS_FRS_STRUCTURE::~NTFS_FRS_STRUCTURE(
    )
/*++

Routine Description:

    Destructor for NTFS_FRS_STRUCTURE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
NTFS_FRS_STRUCTURE::Construct(
    )
/*++

Routine Description:

    This routine initialize this class to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FrsData = NULL;
    _secrun = NULL;
    _mftdata = NULL;
    _file_number = 0;
    _cluster_factor = 0;
    _size = 0;
    _drive = NULL;
    _volume_sectors = 0;
    _upcase_table = NULL;
    _first_file_number = 0;
    _frs_count = 0;
    _frs_state = _read_status = FALSE;
    _usa_check = UpdateSequenceArrayCheckValueOk;
}



VOID
NTFS_FRS_STRUCTURE::Destroy(
    )
/*++

Routine Description:

    This routine returns this class to a default state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FrsData = NULL;
    DELETE(_secrun);
    _mftdata = NULL;
    _file_number = 0;
    _cluster_factor = 0;
    _size = 0;
    _drive = NULL;
    _volume_sectors = 0;
    _upcase_table = NULL;
    _first_file_number = 0;
    _frs_count = 0;
    _frs_state = _read_status = FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PNTFS_ATTRIBUTE     MftData,
    IN      VCN                 FileNumber,
    IN      ULONG               ClusterFactor,
    IN      BIG_INT             VolumeSectors,
    IN      ULONG               FrsSize,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
    )
/*++

Routine Description:

    This routine initializes a NTFS_FRS_STRUCTURE to a valid
    initial state.

Arguments:

    Mem             - Supplies memory for the FRS.
    MftData         - Supplies the $DATA attribute of the MFT.
    FileNumber      - Supplies the file number for this FRS.
    ClusterFactor   - Supplies the number of sectors per cluster.
    VolumeSectors   - Supplies the number of volume sectors.
    FrsSize         - Supplies the size of each frs, in bytes.
    UpcaseTable     - Supplies the volume upcase table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The client may supply NULL for the upcase table, but then
    it cannot manipulate named attributes until the ucpase
    table is set.

--*/
{
    Destroy();

    DebugAssert(Mem);
    DebugAssert(MftData);
    DebugAssert(ClusterFactor);

    _mftdata = MftData;
    _file_number = FileNumber;
    _cluster_factor = ClusterFactor;
    _drive = MftData->GetDrive();
    _size = FrsSize;
    _volume_sectors = VolumeSectors;
    _upcase_table = UpcaseTable;
    _usa_check = UpdateSequenceArrayCheckValueOk;

    DebugAssert(_drive);
    DebugAssert(_drive->QuerySectorSize());

    _FrsData = (PFILE_RECORD_SEGMENT_HEADER)
               Mem->Acquire(QuerySize(), _drive->QueryAlignmentMask());

    if (!_FrsData) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PNTFS_ATTRIBUTE     MftData,
    IN      VCN                 FirstFileNumber,
    IN      ULONG               FrsCount,
    IN      ULONG               ClusterFactor,
    IN      BIG_INT             VolumeSectors,
    IN      ULONG               FrsSize,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
    )
/*++

Routine Description:

    This routine initializes a NTFS_FRS_STRUCTURE to a valid
    initial state in preparation for reading a block of FRS'es.

Arguments:

    Mem             - Supplies memory for the FRS.
    MftData         - Supplies the $DATA attribute of the MFT.
    FirstFileNumber - Supplies the first file number for this FRS block.
    FrsCount        - Supplies the number of FRS'es in this FRS block.
    ClusterFactor   - Supplies the number of sectors per cluster.
    VolumeSectors   - Supplies the number of volume sectors.
    FrsSize         - Supplies the size of each frs, in bytes.
    UpcaseTable     - Supplies the volume upcase table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The client may supply NULL for the upcase table, but then
    it cannot manipulate named attributes until the ucpase
    table is set.

--*/
{
    Destroy();

    DebugAssert(Mem);
    DebugAssert(MftData);
    DebugAssert(ClusterFactor);

    _mftdata = MftData;
    _file_number = FirstFileNumber;
    _first_file_number = FirstFileNumber;
    _frs_count = FrsCount;
    _frs_state = _read_status = FALSE;
    _cluster_factor = ClusterFactor;
    _drive = MftData->GetDrive();
    _size = FrsSize;
    _volume_sectors = VolumeSectors;
    _upcase_table = UpcaseTable;
    _usa_check = UpdateSequenceArrayCheckValueOk;

    DebugAssert(_drive);
    DebugAssert(_drive->QuerySectorSize());

    _FrsData = (PFILE_RECORD_SEGMENT_HEADER)
               Mem->Acquire(QuerySize()*FrsCount, _drive->QueryAlignmentMask());

    if (!_FrsData) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LCN                 StartOfFrs,
    IN      ULONG               ClusterFactor,
    IN      BIG_INT             VolumeSectors,
    IN      ULONG               FrsSize,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable,
    IN      ULONG               Offset
    )
/*++

Routine Description:

    This routine initializes an NTFS_FRS_STRUCTURE to point at one
    of the low frs's.

Arguments:

    Mem             - Supplies memory for the FRS.
    Drive           - Supplies the drive.
    StartOfFrs      - Supplies the starting LCN for the frs.
    ClusterFactor   - Supplies the number of sectors per cluster.
    UpcaseTable     - Supplies the volume upcase table.
    FrsSize         - Supplies the size of frs 0 in bytes.
    Offset          - Supplies the offset in the cluster for the frs.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The client may supply NULL for the upcase table; in that case,
    the FRS cannot manipulate named attributes until the upcase
    table is set.

--*/
{
    Destroy();

    DebugAssert(Mem);
    DebugAssert(Drive);

    _file_number = 0;
    _cluster_factor = ClusterFactor;
    _drive = Drive;
    _size = FrsSize;
    _volume_sectors = VolumeSectors;
    _upcase_table = UpcaseTable;
    _usa_check = UpdateSequenceArrayCheckValueOk;

    //
    // Our SECRUN will need to hold the one or more sectors occupied
    // by this frs.
    //

#define BYTES_TO_SECTORS(bytes, sector_size)  \
    (((bytes) + ((sector_size) - 1))/(sector_size))

    ULONG sectors_per_frs = BYTES_TO_SECTORS(FrsSize,
                                             Drive->QuerySectorSize());

    if (!(_secrun = NEW SECRUN) ||
        !_secrun->Initialize(Mem,
                             Drive,
                             StartOfFrs * QueryClusterFactor() +
                                Offset/Drive->QuerySectorSize(),
                             sectors_per_frs)) {

        Destroy();
        return FALSE;
    }

    _FrsData = (PFILE_RECORD_SEGMENT_HEADER)_secrun->GetBuf();

    DebugAssert(_FrsData);

    return TRUE;
}


BOOLEAN
NTFS_FRS_STRUCTURE::VerifyAndFix(
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine verifies, and if necessary, fixes an NTFS_FRS_STRUCTURE.

    This routine will clear the IN_USE bit on this FRS if the FRS is
    completely hosed.

Arguments:

    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    AttributeDefTable   - Supplies an attribute definition table.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    pattr;
    NTFS_ATTRIBUTE_RECORD       attr;
    DSTRING                     string;
    BOOLEAN                     changes, duplicates;
    BOOLEAN                     need_write;
    DSTRING                     null_string;
    BOOLEAN                     errors_found;
    NUMBER_SET                  instance_numbers;
    BOOLEAN                     standard_info_found;
    PSTANDARD_INFORMATION       pstandard;
    BOOLEAN                     disk_errors_found;
    ULONG                       file_attributes;
    BOOLEAN                     v0_frs;
    PFILE_RECORD_SEGMENT_HEADER_V0  pfrs_v0 = (PFILE_RECORD_SEGMENT_HEADER_V0)_FrsData;

    if (!null_string.Initialize("\"\"") ||
        !instance_numbers.Initialize()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (DiskErrorsFound == NULL)
        DiskErrorsFound = &disk_errors_found;

    need_write = FALSE;

    // First make sure that the update sequence array precedes the
    // attribute records and that the two don't overlap.

    errors_found = FALSE;

    DebugAssert(FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER_V0, UpdateArrayForCreateOnly) <=
                FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly));

    if (_FrsData->MultiSectorHeader.Signature[0] != 'F' ||
        _FrsData->MultiSectorHeader.Signature[1] != 'I' ||
        _FrsData->MultiSectorHeader.Signature[2] != 'L' ||
        _FrsData->MultiSectorHeader.Signature[3] != 'E') {

        Message->Lock();
        Message->Set(MSG_CHKLOG_NTFS_INCORRECT_FRS_MULTI_SECTOR_HEADER_SIGNATURE);
        Message->Log("%I64x", QueryFileNumber().GetLargeInteger());
        Message->DumpDataToLog(_FrsData, sizeof(MULTI_SECTOR_HEADER));
        Message->Unlock();

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset <
                FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER_V0, UpdateArrayForCreateOnly)) {

        // A less precise check before we figure out if this is the smaller or larger
        // file record segment header.

        Message->LogMsg(MSG_CHKLOG_NTFS_FRS_USA_OFFSET_BELOW_MINIMUM,
                     "%x%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                     FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER_V0, UpdateArrayForCreateOnly),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (QuerySize() % SEQUENCE_NUMBER_STRIDE != 0) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_SIZE,
                     "%x%I64x",
                     QuerySize(),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset %
               sizeof(UPDATE_SEQUENCE_NUMBER)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_USA_OFFSET,
                     "%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArraySize !=
               QuerySize()/SEQUENCE_NUMBER_STRIDE + 1) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_USA_SIZE,
                     "%x%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArraySize,
                     QuerySize()/SEQUENCE_NUMBER_STRIDE + 1,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if ((_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset +
                _FrsData->MultiSectorHeader.UpdateSequenceArraySize *
                sizeof(UPDATE_SEQUENCE_NUMBER)) > _FrsData->FirstAttributeOffset ||
               _FrsData->FirstAttributeOffset + sizeof(ATTRIBUTE_TYPE_CODE) > QuerySize() ||
               !IsQuadAligned(_FrsData->FirstAttributeOffset)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FIRST_ATTR_OFFSET,
                     "%x%I64x",
                     _FrsData->FirstAttributeOffset,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->BytesAvailable != QuerySize()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_HEADER,
                     "%x%x%I64x",
                     _FrsData->BytesAvailable,
                     QuerySize(),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    }

    if (!errors_found) {
        v0_frs = (pfrs_v0->MultiSectorHeader.UpdateSequenceArrayOffset ==
                  FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER_V0, UpdateArrayForCreateOnly));
        if (!v0_frs &&
            _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset <
                   FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_FRS_USA_OFFSET_BELOW_MINIMUM,
                         "%x%x%I64x",
                         _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                         FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly),
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        }
    }

    if (errors_found) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_FRS,
                         "%d", QueryFileNumber().GetLowPart());
        ClearInUse();

        *DiskErrorsFound = TRUE;

        if (FixLevel != CheckOnly && !Write()) {

            DebugAbort("Could not write a readable sector");
            return FALSE;
        }

        return TRUE;
    }


    // If this is the MFT then make sure that the Sequence Number
    // is not zero.

    if (_FrsData->SequenceNumber != 1 && QueryFileNumber() == 0) {

        DebugPrintTrace(("UNTFS: MFT sequence number is not equal to 1\n"));

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEQUENCE_NUMBER,
                     "%x%I64x",
                     _FrsData->SequenceNumber,
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        _FrsData->SequenceNumber = 1;
        need_write = TRUE;
    }

    if (QueryFileNumber() < FIRST_USER_FILE_NUMBER &&
        QueryFileNumber() != 0 &&
        QueryFileNumber().GetLowPart() != _FrsData->SequenceNumber) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEQUENCE_NUMBER,
                     "%x%x",
                     _FrsData->SequenceNumber,
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        DebugPrintTrace(("UNTFS: File record segment 0x%I64x sequence number is not equal to 0x%x\n",
                         QueryFileNumber().GetLargeInteger(),
                         _FrsData->SequenceNumber));


        _FrsData->SequenceNumber = (USHORT)QueryFileNumber().GetLowPart();
        need_write = TRUE;
    }

    if (!v0_frs &&
        (_FrsData->SegmentNumberHighPart != (USHORT)QueryFileNumber().GetHighPart() ||
         _FrsData->SegmentNumberLowPart != QueryFileNumber().GetLowPart())) {

        BIG_INT     x;

        x.Set(_FrsData->SegmentNumberHighPart, _FrsData->SegmentNumberLowPart);

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEGMENT_NUMBER,
                     "%I64x%I64x",
                     x.GetLargeInteger(),
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        _FrsData->SegmentNumberHighPart = (USHORT)QueryFileNumber().GetHighPart();
        _FrsData->SegmentNumberLowPart = QueryFileNumber().GetLowPart();
        need_write = TRUE;
    }

    // Validate the stucture of the list of attribute records,
    // make sure that there are no special attributes with names,
    // and make sure that all of the attribute records are well
    // composed.

    pattr = NULL;
    while (pattr = (PATTRIBUTE_RECORD_HEADER)
                   GetNextAttributeRecord(pattr, Message, &errors_found)) {

        need_write = need_write || errors_found;

        // Make sure that the attribute record is in good shape.
        // Don't account for it's disk space yet.
        // Make sure that the attribute instance number is not duplicated.

        if (!attr.Initialize(GetDrive(), pattr)) {
            DebugAbort("Could not initialize attribute record.");
            return FALSE;
        }

        errors_found = FALSE;
        if (!attr.Verify(AttributeDefTable, FALSE)) {
            errors_found = TRUE;
        } else if (instance_numbers.DoesIntersectSet((ULONG) pattr->Instance, 1)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INSTANCE_NUMBER_COLLISION,
                         "%x%x%I64x",
                         pattr->TypeCode,
                         pattr->Instance,
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        } else if (pattr->Instance >= _FrsData->NextAttributeInstance) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INSTANCE_NUMBER_TOO_LARGE,
                         "%x%x%x%I64x",
                         pattr->TypeCode,
                         pattr->Instance,
                         _FrsData->NextAttributeInstance,
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        }

        if (errors_found) {

            if (!attr.QueryName(&string)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                             "%d%W%d", pattr->TypeCode,
                                       string.QueryChCount() ? &string : &null_string,
                                       QueryFileNumber().GetLowPart());

            DeleteAttributeRecord(pattr);

            if (!instance_numbers.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            need_write = TRUE;
            pattr = NULL;
            continue;
        }

        if (!instance_numbers.Add((ULONG) pattr->Instance)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    need_write = need_write || errors_found;


    // Sort the base FRS attribute records by type, and name.
    // This method will also eliminate duplicates.

    if (!Sort(&changes, &duplicates)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (duplicates || (changes && IsBase())) {
        Message->DisplayMsg(MSG_CHK_NTFS_UNSORTED_FRS,
                         "%d", QueryFileNumber().GetLowPart());
        need_write = TRUE;
    }


    // Detect whether or not there is a $STANDARD_INFORMATION.

    standard_info_found = FALSE;
    pattr = NULL;
    while (pattr = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(pattr)) {
        if (pattr->TypeCode == $STANDARD_INFORMATION) {

            standard_info_found = TRUE;

            // Make sure that if this is a system file than the
            // system and hidden bits are set in the $STANDARD_INFORMATION.

            if (QueryFileNumber() < FIRST_USER_FILE_NUMBER) {
                pstandard = (PSTANDARD_INFORMATION)
                            ((PCHAR) pattr + pattr->Form.Resident.ValueOffset);

                if (!(pstandard->FileAttributes&FAT_DIRENT_ATTR_HIDDEN) ||
                    !(pstandard->FileAttributes&FAT_DIRENT_ATTR_SYSTEM)) {

                    file_attributes = pstandard->FileAttributes |
                                      FAT_DIRENT_ATTR_SYSTEM |
                                      FAT_DIRENT_ATTR_HIDDEN;

                    Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_FILE_ATTR,
                                 "%x%x%I64x",
                                 pstandard->FileAttributes,
                                 file_attributes,
                                 QueryFileNumber().GetLargeInteger()
                                 );

                    pstandard->FileAttributes = file_attributes;

                    Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                                     "%d", QueryFileNumber().GetLowPart());
                    need_write = TRUE;
                }
            }
            break;
        }
    }

    if (IsBase() && !standard_info_found) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_STANDARD_INFO,
                     "%I64x", QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_FRS,
                         "%d", QueryFileNumber().GetLowPart());
        ClearInUse();
        need_write = TRUE;
    }


    // Write out changes if necessary.

    if (need_write || (_usa_check == UpdateSequenceArrayCheckValueMinorError)) {

        if (need_write) {
            *DiskErrorsFound = TRUE;
        } else {
            DebugPrintTrace(("UNTFS: Quietly fix up check value in file record segment 0x%I64x\n",
                             _file_number.GetLargeInteger()));
        }

        if (FixLevel != CheckOnly && !Write()) {

            DebugAbort("Could not write a readable sector");
            return FALSE;
        }
    }

    return TRUE;
}

#if defined(LOCATE_DELETED_FILE)
BOOLEAN
NTFS_FRS_STRUCTURE::LocateUnuseFrs(
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine locates a deleted file.

Arguments:

    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    AttributeDefTable   - Supplies an attribute definition table.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    pattr;
    NTFS_ATTRIBUTE_RECORD       attr;
    DSTRING                     string;
    BOOLEAN                     changes, duplicates;
    BOOLEAN                     need_write;
    DSTRING                     null_string;
    BOOLEAN                     errors_found;
    NUMBER_SET                  instance_numbers;
    BOOLEAN                     standard_info_found;
    PSTANDARD_INFORMATION       pstandard;
    BOOLEAN                     disk_errors_found;
    ULONG                       file_attributes;

    if (!null_string.Initialize("\"\"") ||
        !instance_numbers.Initialize()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (DiskErrorsFound == NULL)
        DiskErrorsFound = &disk_errors_found;

    need_write = FALSE;

    // First make sure that the update sequence array precedes the
    // attribute records and that the two don't overlap.

    errors_found = FALSE;

    if (_FrsData->MultiSectorHeader.Signature[0] != 'F' ||
        _FrsData->MultiSectorHeader.Signature[1] != 'I' ||
        _FrsData->MultiSectorHeader.Signature[2] != 'L' ||
        _FrsData->MultiSectorHeader.Signature[3] != 'E') {

        Message->Lock();
        Message->Set(MSG_CHKLOG_NTFS_INCORRECT_FRS_MULTI_SECTOR_HEADER_SIGNATURE);
        Message->Log("%I64x", QueryFileNumber().GetLargeInteger());
        Message->DumpDataToLog(_FrsData, sizeof(MULTI_SECTOR_HEADER));
        Message->Unlock();

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset <
               FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_FRS_USA_OFFSET_BELOW_MINIMUM,
                     "%x%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                     FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (QuerySize() % SEQUENCE_NUMBER_STRIDE != 0) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_SIZE,
                     "%x%I64x",
                     QuerySize(),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset %
               sizeof(UPDATE_SEQUENCE_NUMBER)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_USA_OFFSET,
                     "%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArraySize !=
               QuerySize()/SEQUENCE_NUMBER_STRIDE + 1) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_USA_SIZE,
                     "%x%x%I64x",
                     _FrsData->MultiSectorHeader.UpdateSequenceArraySize,
                     QuerySize()/SEQUENCE_NUMBER_STRIDE + 1,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->MultiSectorHeader.UpdateSequenceArrayOffset +
               _FrsData->MultiSectorHeader.UpdateSequenceArraySize *
               sizeof(UPDATE_SEQUENCE_NUMBER) > _FrsData->FirstAttributeOffset ||
               _FrsData->FirstAttributeOffset + sizeof(ATTRIBUTE_TYPE_CODE) >
               QuerySize() ||
               !IsQuadAligned(_FrsData->FirstAttributeOffset)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FIRST_ATTR_OFFSET,
                     "%x%I64x",
                     _FrsData->FirstAttributeOffset,
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    } else if (_FrsData->BytesAvailable != QuerySize()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FRS_HEADER,
                     "%x%x%I64x",
                     _FrsData->BytesAvailable,
                     QuerySize(),
                     QueryFileNumber().GetLargeInteger());

        errors_found = TRUE;
    }

    if (errors_found) {

        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                         "%s%x", "Corrupted unused FRS: ", QueryFileNumber().GetLowPart());

        return TRUE;
    }


    // If this is the MFT then make sure that the Sequence Number
    // is not zero.

    if (_FrsData->SequenceNumber != 1 && QueryFileNumber() == 0) {

        DebugPrintTrace(("UNTFS: MFT sequence number is not equal to 1\n"));

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEQUENCE_NUMBER,
                     "%x%I64x",
                     _FrsData->SequenceNumber,
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        _FrsData->SequenceNumber = 1;
        need_write = TRUE;
    }

    if (QueryFileNumber() < FIRST_USER_FILE_NUMBER &&
        QueryFileNumber() != 0 &&
        QueryFileNumber().GetLowPart() != _FrsData->SequenceNumber) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SEQUENCE_NUMBER,
                     "%x%x",
                     _FrsData->SequenceNumber,
                     QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        DebugPrintTrace(("UNTFS: File record segment 0x%I64x sequence number is not equal to 0x%x\n",
                         QueryFileNumber().GetLargeInteger(),
                         _FrsData->SequenceNumber));


        _FrsData->SequenceNumber = (USHORT)QueryFileNumber().GetLowPart();
        need_write = TRUE;
    }


    // Validate the stucture of the list of attribute records,
    // make sure that there are no special attributes with names,
    // and make sure that all of the attribute records are well
    // composed.

    pattr = NULL;
    while (pattr = (PATTRIBUTE_RECORD_HEADER)
                   GetNextAttributeRecord(pattr, Message, &errors_found)) {

        need_write = need_write || errors_found;

        // Make sure that the attribute record is in good shape.
        // Don't account for it's disk space yet.
        // Make sure that the attribute instance number is not duplicated.

        if (!attr.Initialize(GetDrive(), pattr)) {
            DebugAbort("Could not initialize attribute record.");
            return FALSE;
        }

        errors_found = FALSE;
        if (!attr.Verify(AttributeDefTable, FALSE)) {
            errors_found = TRUE;
        } else if (instance_numbers.DoesIntersectSet((ULONG) pattr->Instance, 1)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INSTANCE_NUMBER_COLLISION,
                         "%x%x%I64x",
                         pattr->TypeCode,
                         pattr->Instance,
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        } else if (pattr->Instance >= _FrsData->NextAttributeInstance) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INSTANCE_NUMBER_TOO_LARGE,
                         "%x%x%x%I64x",
                         pattr->TypeCode,
                         pattr->Instance,
                         _FrsData->NextAttributeInstance,
                         QueryFileNumber().GetLargeInteger());

            errors_found = TRUE;
        }

        if (errors_found) {

            if (!attr.QueryName(&string)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                             "%d%W%d", pattr->TypeCode,
                                       string.QueryChCount() ? &string : &null_string,
                                       QueryFileNumber().GetLowPart());

            DeleteAttributeRecord(pattr);

            if (!instance_numbers.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            need_write = TRUE;
            pattr = NULL;
            continue;
        }

        if (!instance_numbers.Add((ULONG) pattr->Instance)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    need_write = need_write || errors_found;


    // Sort the base FRS attribute records by type, and name.
    // This method will also eliminate duplicates.

    if (!Sort(&changes, &duplicates)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (duplicates || (changes && IsBase())) {
        Message->DisplayMsg(MSG_CHK_NTFS_UNSORTED_FRS,
                         "%d", QueryFileNumber().GetLowPart());
        need_write = TRUE;
    }


    // Detect whether or not there is a $FILE_NAME

    PFILE_NAME      fn;
    WCHAR           buf[MAX_PATH];
    BOOLEAN         found_name = FALSE;

    standard_info_found = FALSE;
    pattr = NULL;
    while (pattr = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(pattr)) {
        if (pattr->TypeCode == $FILE_NAME) {

            found_name = TRUE;
            fn = (PFILE_NAME)((PBYTE)pattr + SIZE_OF_RESIDENT_HEADER);
            memcpy(buf, fn->FileName, fn->FileNameLength*sizeof(WCHAR));
            buf[fn->FileNameLength] = 0;

            if (_wcsicmp(buf, L"drmtool.cpp") == 0) {
                Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                                    "%s%x",
                                    "Potential match:  ", QueryFileNumber().GetLowPart());
                return TRUE;
            } else {
                WCHAR   buf2[MAX_PATH+50];

                buf[15] = 0;

                wsprintf(buf2, L"Unused FRS %x Name: %ls",
                         QueryFileNumber().GetLowPart(), buf);

                Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                                    "%ws%s",
                                    buf2, "");
            }
        }
    }

    if (!found_name)
        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                            "%s%x",
                            "Unused FRS:       ",
                            QueryFileNumber().GetLowPart());

    return TRUE;
}
#endif


BOOLEAN
NTFS_FRS_STRUCTURE::LoneFrsAllocationCheck(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_CHKDSK_REPORT ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO   ChkdskInfo,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message,
    IN OUT  PBOOLEAN            DiskErrorsFound
    )
/*++

Routine Description:

    This routine checks the allocation of the attribute records in
    the given FRS under the presumption that there is no attribute
    list for this FRS and that this FRS is a base FRS.

Arguments:

    VolumeBitmap            - Supplies a volume bitmap on which to mark off
                                the non-resident attribute records'
                                allocations.
    ChkdskReport            - Supplies the current chkdsk report to be updated
                                with the statistics from this file.
    ChkdskInfo              - Supplies the chkdsk information.
    FixLevel                - Supplies the fix level.
    Message                 - Supplies an outlet for messages.
    DiskErrorsFound         - Supplies whether or not disk errors have
                                been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVOID                       pattr, next_attribute;
    NTFS_ATTRIBUTE_RECORD       attribute_record;
    DSTRING                     string;
    DSTRING                     null_string;
    BIG_INT                     file_length;
    BIG_INT                     alloc_length;
    BIG_INT                     total_allocated;
    BIG_INT                     compute_alloc_length;
    BIG_INT                     compute_total_allocated;
    BIG_INT                     cluster_count;
    BOOLEAN                     changes;
    BIG_INT                     total_user_bytes;
    ATTRIBUTE_TYPE_CODE         type_code;
    BOOLEAN                     user_file;
    BOOLEAN                     got_allow_cross_link;
    BOOLEAN                     error;

    DebugAssert(VolumeBitmap);
    DebugAssert(Message);

    user_file = FALSE;
    changes = FALSE;
    pattr = NULL;
    total_user_bytes = 0;
    pattr = GetNextAttributeRecord(NULL);

    while (pattr) {

        if (!attribute_record.Initialize(GetDrive(), pattr)) {

            DebugAbort("Can't initialize attribute record");
            return FALSE;
        }

        if (attribute_record.IsResident()) {

            compute_alloc_length = 0;
            cluster_count = 0;

        } else {

            compute_alloc_length = (attribute_record.QueryNextVcn() -
                                    attribute_record.QueryLowestVcn())*
                                   QueryClusterFactor()*
                                   _drive->QuerySectorSize();

            attribute_record.QueryValueLength(&file_length, &alloc_length,
                NULL, &total_allocated);

            error = FALSE;
            if (attribute_record.QueryLowestVcn() != 0) {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LOWEST_VCN_IS_NOT_ZERO,
                             "%x%I64x%x%I64x",
                             attribute_record.QueryTypeCode(),
                             attribute_record.QueryLowestVcn().GetLargeInteger(),
                             attribute_record.QueryInstanceTag(),
                             QueryFileNumber().GetLargeInteger());
                error = TRUE;
            } else if (compute_alloc_length != alloc_length) {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_INCORRECT_ALLOCATE_LENGTH,
                             "%x%x%I64x%I64x%I64x",
                             attribute_record.QueryTypeCode(),
                             attribute_record.QueryInstanceTag(),
                             alloc_length.GetLargeInteger(),
                             compute_alloc_length.GetLargeInteger(),
                             QueryFileNumber().GetLargeInteger());

                error = TRUE;
            } else if (!attribute_record.UseClusters(VolumeBitmap,
                                              &cluster_count,
                                              ChkdskInfo->CrossLinkStart,
                                              ChkdskInfo->CrossLinkYet ? 0 :
                                                  ChkdskInfo->CrossLinkLength,
                                              &got_allow_cross_link)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_CLUSTERS_IN_USE,
                             "%x%x%I64x",
                             attribute_record.QueryTypeCode(),
                             attribute_record.QueryInstanceTag(),
                             QueryFileNumber().GetLargeInteger());

                error = TRUE;
            }

            if (error) {

                DebugPrintTrace(("Attribute %d has either a cross-link or a bad allocation length\n",
                          attribute_record.QueryTypeCode()));

                // The lowest vcn must be zero and
                // the allocated length must match the length allocated and
                // the allocated space must be available in the volume
                // bitmap.
                // So tube this attribute record.

                if (!null_string.Initialize("\"\"") ||
                    !attribute_record.QueryName(&string)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                                 "%d%W%d", attribute_record.QueryTypeCode(),
                                 string.QueryChCount() ? &string : &null_string,
                                 QueryFileNumber().GetLowPart());

                next_attribute = GetNextAttributeRecord(pattr);

                DeleteAttributeRecord(pattr);
                changes = TRUE;

                // Do not increment pattr--DeleteAttributeRecord
                // will bring the next attribute record down to us.
                //
                if( !next_attribute ) {

                    // The deleted attribute record was the
                    // last in this FRS.
                    //
                    break;
                }

                continue;
            }

//+++
//ZZZ
            if ((attribute_record.QueryFlags() &
                 (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                  ATTRIBUTE_FLAG_SPARSE))) {

                NTFS_EXTENT_LIST extent_list;

                if (!attribute_record.QueryExtentList(&extent_list)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                compute_total_allocated = extent_list.QueryClustersAllocated() *
                    QueryClusterFactor() * _drive->QuerySectorSize();

                if (compute_total_allocated != total_allocated) {

                    DebugPrintTrace(("Attribute %d has bad total allocated\n"
                                     "total allocated is 0x%I64x\n"
                                     "actual total allocated is 0x%I64x.\n",
                                     attribute_record.QueryTypeCode(),
                                     total_allocated.GetLargeInteger(),
                                     compute_total_allocated.GetLargeInteger()));

                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_TOTAL_ALLOCATION,
                                 "%x%x%I64x%I64x%I64x",
                                 attribute_record.QueryTypeCode(),
                                 attribute_record.QueryInstanceTag(),
                                 total_allocated.GetLargeInteger(),
                                 compute_total_allocated.GetLargeInteger(),
                                 QueryFileNumber().GetLargeInteger());

                    Message->DisplayMsg(MSG_CHK_NTFS_FIX_ATTR,
                                     "%d%W%d", attribute_record.QueryTypeCode(),
                                     string.QueryChCount() ? &string : &null_string,
                                     QueryFileNumber().GetLowPart());

                    attribute_record.SetTotalAllocated(compute_total_allocated);

                    changes = TRUE;
                }
            }
//---

            if (got_allow_cross_link) {
                ChkdskInfo->CrossLinkYet = TRUE;
                ChkdskInfo->CrossLinkedFile = QueryFileNumber().GetLowPart();
                ChkdskInfo->CrossLinkedAttribute =
                        attribute_record.QueryTypeCode();
                if (!attribute_record.QueryName(&ChkdskInfo->CrossLinkedName)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }

        type_code = attribute_record.QueryTypeCode();

        if (type_code == $DATA ||
            type_code == $EA_DATA ||
            ((ChkdskInfo->major >= 2) ?
               (type_code >= $FIRST_USER_DEFINED_ATTRIBUTE_2) :
               (type_code >= $FIRST_USER_DEFINED_ATTRIBUTE_1)) ) {

            user_file = TRUE;
            total_user_bytes += cluster_count *
                                QueryClusterFactor()*
                                _drive->QuerySectorSize();
        }

        pattr = GetNextAttributeRecord(pattr);
    }

    if (changes && DiskErrorsFound) {
        *DiskErrorsFound = TRUE;
    }

    if (changes && FixLevel != CheckOnly && !Write()) {
        DebugAbort("readable FRS is unwriteable");
        return FALSE;
    }

    if (QueryFileNumber() >= FIRST_USER_FILE_NUMBER && user_file) {
        ChkdskReport->NumUserFiles += 1;
        ChkdskReport->BytesUserData += total_user_bytes;
    }

    return TRUE;
}

BOOLEAN
NTFS_FRS_STRUCTURE::CheckInstanceTags(
    IN      FIX_LEVEL               FixLevel,
    IN      BOOLEAN                 Verbose,
    IN OUT  PMESSAGE                Message,
    OUT     PBOOLEAN                Changes,
    IN OUT  PNTFS_ATTRIBUTE_LIST    AttributeList
    )
/*++

Routine Description:

    This routine attempts to prevent the instance tags on the
    FRS_STRUCTURE from rolling over...  if we see that the next
    instance tag field is above a reasonable value, we renumber
    the instance tags in the attribute records and reset the
    next instance tag field to the lowest acceptable value.

Arguments:

    AttributeList   - NULL if we're checking a lone frs, otherwise
                      changes to instance tags require us to update
                      this attribute list as well.

Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    PVOID pattr;
    NTFS_ATTRIBUTE_RECORD attr_rec;
    BOOLEAN errors;
    USHORT instance_tag;
    DSTRING Name;

    if (_FrsData->NextAttributeInstance <= ATTRIBUTE_INSTANCE_TAG_THRESHOLD) {
        *Changes = FALSE;
        return TRUE;
    }

    if (Verbose)
        Message->DisplayMsg(MSG_CHK_NTFS_ADJUSTING_INSTANCE_TAGS,
                            "%d", _file_number.GetLowPart());
    else
        Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_INSTANCE_TAG,
                        "%I64x", _file_number.GetLargeInteger());

    *Changes = TRUE;

    instance_tag = 0;
    pattr = NULL;
    while (NULL != (pattr = (PNTFS_ATTRIBUTE_RECORD)GetNextAttributeRecord(
        pattr ))) {

        if (!attr_rec.Initialize(GetDrive(), pattr)) {
            return FALSE;
        }

        if (NULL != AttributeList &&
            $ATTRIBUTE_LIST != attr_rec.QueryTypeCode()) {

            if (!AttributeList->ModifyInstanceTag(&attr_rec,
                                                  QuerySegmentReference(),
                                                  instance_tag)) {
                DebugAbort("UNTFS: Could not find attribute in attr list.");
                return FALSE;
            }
        }

        attr_rec.SetInstanceTag(instance_tag);

        instance_tag++;
    }

    _FrsData->NextAttributeInstance = instance_tag;

    if (FixLevel != CheckOnly && !Write()) {
        DebugAbort("UNTFS: Once readable frs struct is unwriteable");
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Read(
    )
/*++

Routine Description:

    This routine reads the FRS in from disk.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           bytes;
    BOOLEAN         r;
    PIO_DP_DRIVE    drive;

    DebugAssert(_mftdata || _secrun);

    if (_mftdata) {
        r = _mftdata->Read(_FrsData,
                           _file_number*QuerySize(),
                           QuerySize(),
                           &bytes) &&
            bytes == QuerySize();

        drive = _mftdata->GetDrive();
    } else {
        r = _secrun->Read();
        drive = _secrun->GetDrive();
    }

    _read_status = r &&
                   (_usa_check =
                    NTFS_SA::PostReadMultiSectorFixup(_FrsData,
                                                      QuerySize(),
                                                      drive,
                                                      _FrsData->FirstFreeByte));

    return _read_status;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::ReadNext(
    IN  VCN     FileNumber
    )
/*++

Routine Description:

    This routine reads a block of FRS'es in from the disk.  This routine
    is to be used with Initialize(PMEM, PNTFS_ATTRIBUTE, VCN, ULONG,
    ULONG, BIG_INT, ...).

Arguments:

    FileNumber  - Supplies the FRS number to be read

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           bytes;
    BOOLEAN         r;
    ULONG           bytesToRead;

    DebugAssert(_mftdata);

    if (_mftdata) {

        if (_frs_state) {
            _FrsData = (PFILE_RECORD_SEGMENT_HEADER)
                            (((PCHAR)_FrsData)+QuerySize());
            _file_number = _file_number + 1;
            DebugAssert(_file_number == FileNumber);
            r = TRUE;
        } else {
            _file_number = FileNumber;
            if (FileNumber == _first_file_number) {
                bytesToRead = _frs_count * QuerySize();
                r = _frs_state = _mftdata->Read(_FrsData,
                                                FileNumber*QuerySize(),
                                                bytesToRead,
                                                &bytes) &&
                                 bytes == bytesToRead;
                if (!r) {
                    bytesToRead = QuerySize();
                    r = _mftdata->Read(_FrsData,
                                       FileNumber*QuerySize(),
                                       bytesToRead,
                                       &bytes) &&
                        bytes == bytesToRead;
                }
            } else {
                bytesToRead = QuerySize();
                r = _mftdata->Read(_FrsData,
                                   FileNumber*QuerySize(),
                                   bytesToRead,
                                   &bytes) &&
                    bytes == bytesToRead;
            }
        }

    } else {
        return FALSE;
    }

    _read_status = r &&
                   (_usa_check =
                    NTFS_SA::PostReadMultiSectorFixup(_FrsData,
                                                      QuerySize(),
                                                      _mftdata->GetDrive(),
                                                      _FrsData->FirstFreeByte));

    return _read_status;
}

UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::ReadAgain(
    IN  VCN     FileNumber
    )
/*++

Routine Description:

    This routine does not read the frs again.  It is provided to tell if
    the last ReadNext was successful.

Arguments:

    FileNumber  - Supplies the FRS number to be read

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_mftdata);
    DebugAssert(_file_number == FileNumber);

    return _read_status;
}

UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::ReadSet(
    IN OUT  PTLINK      Link
    )
/*++

Routine Description:

    This routine reads a block of FRS'es in from the disk based on the given
    list.  This routine is to be used with Initialize(PMEM, PNTFS_ATTRIBUTE,
    VCN, ULONG, ULONG, BIG_INT, ...), and SetFrsData().


Arguments:

    Link            - Supplies the list of FRS numbers to be read

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    This routine always set the _usa_check to UpdateSequenceArrayCheckValueOk.
    It does not matter as the check value would have been corrected during stage one
    and this routine should only be used in stage two or after.

--*/
{
    BOOLEAN         r = TRUE;
    ULONG           bytes;
    ULONG           bytesToRead;
    USHORT          i, j;
    PCHAR           frsData;
    PCHAR           frsdata;
    BIG_INT         start;
    USHORT          length, size;
    USHORT          effective_length;
    PVOID           pNode;
    PIO_DP_DRIVE    drive;


    DebugAssert(_mftdata);

    if (_mftdata) {

        _usa_check = UpdateSequenceArrayCheckValueOk;
        frsData = (PCHAR)_FrsData;
        pNode = Link->GetSortedFirst();
        size = Link->QueryMemberCount();
        if (size == 0) {
            DebugPrint("Size cannot be zero\n");
            return _read_status = FALSE;
        }
        drive = _mftdata->GetDrive();
        for (i=0; r && i<size;) {

            pNode = Link->QueryDisjointRangeAndAssignBuffer(&start,
                                                            &length,
                                                            &effective_length,
                                                            frsData,
                                                            QuerySize(),
                                                            pNode);

            i += length;
            bytesToRead = QuerySize() * effective_length;
            r = _mftdata->Read(frsData,
                               start*QuerySize(),
                               bytesToRead,
                               &bytes) &&
                bytes == bytesToRead;
            frsdata = frsData;
            for (j=0; r && j<effective_length; j++) {
                r = NTFS_SA::PostReadMultiSectorFixup(frsdata,
                                                      QuerySize(),
                                                      drive,
                                                      ((PFILE_RECORD_SEGMENT_HEADER)frsdata)->FirstFreeByte);
                frsdata += QuerySize();
            }
            frsData += bytesToRead;
        }
        return _read_status = r;

    } else {
        return _read_status = FALSE;
    }
}

UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::Write(
    )
/*++

Routine Description:

    This routine writes the FRS to disk.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   bytes;
    BOOLEAN r;

    DebugAssert(_mftdata || _secrun);

    NTFS_SA::PreWriteMultiSectorFixup(_FrsData, QuerySize());

    if (_mftdata) {

        r = _mftdata->Write(_FrsData,
                            _file_number*QuerySize(),
                            QuerySize(),
                            &bytes,
                            NULL) &&
            bytes == QuerySize();

    } else {
        r = _secrun->Write();
    }

    NTFS_SA::PostReadMultiSectorFixup(_FrsData, QuerySize(), NULL);

    return r;
}


UNTFS_EXPORT
PVOID
NTFS_FRS_STRUCTURE::GetNextAttributeRecord(
    IN      PCVOID      AttributeRecord,
    IN OUT  PMESSAGE    Message,
    OUT     PBOOLEAN    ErrorsFound
    )
/*++

Routine Description:

    This routine gets the next attribute record in the file record
    segment assuming that 'AttributeRecord' points to a valid
    attribute record.  If NULL is given as the first argument then
    the first attribute record is returned.

Arguments:

    AttributeRecord - Supplies a pointer to the current attribute record.
    Message         - Supplies an outlet for error processing.
    ErrorsFound     - Supplies whether or not errors were found and
                        corrected in the FRS.

Return Value:

    A pointer to the next attribute record or NULL if there are no more.

--*/
{
    PATTRIBUTE_RECORD_HEADER    p;
    PCHAR                       q;
    PCHAR                       next_frs;
    ULONG                       bytes_free;
    BOOLEAN                     error;

    DebugAssert(_FrsData);

    if (ErrorsFound) {
        *ErrorsFound = FALSE;
    }

    next_frs = (PCHAR) _FrsData + QuerySize();

    if (!AttributeRecord) {

        // Make sure the FirstAttributeOffset field will give us a properly
        // aligned pointer.  If not, bail.
        //

        if (_FrsData->FirstAttributeOffset % 4 != 0) {

            return NULL;
        }

        AttributeRecord = (PCHAR) _FrsData + _FrsData->FirstAttributeOffset;

        p = (PATTRIBUTE_RECORD_HEADER) AttributeRecord;
        q = (PCHAR) AttributeRecord;

        if (q + QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE)) > next_frs) {

            // There is no way to correct this error.
            // The FRS is totally hosed, this will also be detected
            // by VerifyAndFix.  I can't really say *ErrorsFound = TRUE
            // because the error was not corrected.  I also cannot
            // update the firstfreebyte and bytesfree fields.

            return NULL;
        }

        if (p->TypeCode != $END) {

            error = FALSE;
            if (q + sizeof(ATTRIBUTE_TYPE_CODE) + sizeof(ULONG) > next_frs) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_OFFSET_TOO_LARGE,
                                 "%x%x%x%x%I64x",
                                 q - (PCHAR)_FrsData,
                                 QuerySize() - sizeof(ATTRIBUTE_TYPE_CODE) - sizeof(ULONG),
                                 p->TypeCode,
                                 p->Instance,
                                 QueryFileNumber().GetLargeInteger());
                }
                error = TRUE;
            } else if (!p->RecordLength) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_CANNOT_BE_ZERO,
                                 "%x%x%I64x",
                                 p->TypeCode,
                                 p->Instance,
                                 QueryFileNumber().GetLargeInteger());
                }
                error = TRUE;
            } else if (!IsQuadAligned(p->RecordLength)) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_MISALIGNED,
                                 "%x%x%x%I64x",
                                 p->RecordLength,
                                 p->TypeCode,
                                 p->Instance,
                                 QueryFileNumber().GetLargeInteger());
                }
                error = TRUE;
            } else if (q + p->RecordLength + sizeof(ATTRIBUTE_TYPE_CODE) > next_frs) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_TOO_LARGE,
                                 "%x%x%x%x%I64x",
                                 p->RecordLength,
                                 next_frs - q - sizeof(ATTRIBUTE_TYPE_CODE),
                                 p->TypeCode,
                                 p->Instance,
                                 QueryFileNumber().GetLargeInteger());
                }
                error = TRUE;
            }

            if (error) {

                p->TypeCode = $END;

                bytes_free = (ULONG)(next_frs - q) -
                                QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE));

                _FrsData->FirstFreeByte = QuerySize() - bytes_free;

                if (ErrorsFound) {
                    *ErrorsFound = TRUE;
                }

                if (Message) {
                    Message->DisplayMsg(MSG_CHK_NTFS_FRS_TRUNC_RECORDS,
                                     "%d", QueryFileNumber().GetLowPart());
                }

                return NULL;
            }
        }

    } else {

        // Assume that the attribute record passed in is good.

        p = (PATTRIBUTE_RECORD_HEADER) AttributeRecord;
        q = (PCHAR) AttributeRecord;

        q += p->RecordLength;
        p = (PATTRIBUTE_RECORD_HEADER) q;
    }


    if (p->TypeCode == $END) {

        // Update the bytes free and first free fields.

        bytes_free = (ULONG)(next_frs - q) - QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE));

        if (_FrsData->FirstFreeByte + bytes_free != QuerySize()) {

            if (Message) {
                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FIRST_FREE_BYTE,
                             "%x%x%x%I64x",
                             _FrsData->FirstFreeByte,
                             bytes_free,
                             QuerySize(),
                             QueryFileNumber().GetLargeInteger());
            }

            _FrsData->FirstFreeByte = QuerySize() - bytes_free;

            if (ErrorsFound) {
                *ErrorsFound = TRUE;
            }

            if (Message) {
                Message->DisplayMsg(MSG_CHK_NTFS_BAD_FIRST_FREE,
                                 "%d", QueryFileNumber().GetLowPart());
            }
        }

        return NULL;
    }


    // Make sure the attribute record is good.

    error = FALSE;
    if (q + sizeof(ATTRIBUTE_TYPE_CODE) + sizeof(ULONG) > next_frs) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_OFFSET_TOO_LARGE,
                         "%x%x%x%x%I64x",
                         q - (PCHAR)_FrsData,
                         QuerySize() - sizeof(ATTRIBUTE_TYPE_CODE) - sizeof(ULONG),
                         p->TypeCode,
                         p->Instance,
                         QueryFileNumber().GetLargeInteger());
        }
        error = TRUE;
    } else if (!p->RecordLength) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_CANNOT_BE_ZERO,
                         "%x%x%I64x",
                         p->TypeCode,
                         p->Instance,
                         QueryFileNumber().GetLargeInteger());
        }
        error = TRUE;
    } else if (!IsQuadAligned(p->RecordLength)) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_LENGTH_MISALIGNED,
                         "%x%x%x%I64x",
                         p->RecordLength,
                         p->TypeCode,
                         p->Instance,
                         QueryFileNumber().GetLargeInteger());
        }
        error = TRUE;
    } else if (q + p->RecordLength + QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE)) > next_frs) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_TOO_LARGE,
                         "%x%x%x%x%x%I64x",
                         q - (PCHAR)_FrsData,
                         p->RecordLength,
                         QuerySize(),
                         p->TypeCode,
                         p->Instance,
                         QueryFileNumber().GetLargeInteger());
        }
        error = TRUE;
    }

    if (error) {

        p->TypeCode = $END;

        bytes_free = (ULONG)(next_frs - q) - QuadAlign(sizeof(ATTRIBUTE_TYPE_CODE));

        _FrsData->FirstFreeByte = QuerySize() - bytes_free;

        if (ErrorsFound) {
            *ErrorsFound = TRUE;
        }

        if (Message) {
            Message->DisplayMsg(MSG_CHK_NTFS_FRS_TRUNC_RECORDS,
                             "%d", QueryFileNumber().GetLowPart());
        }

        return NULL;
    }

    return p;
}


VOID
NTFS_FRS_STRUCTURE::DeleteAttributeRecord(
    IN OUT  PVOID   AttributeRecord
    )
/*++

Routine Description:

    This routine removes the pointed to attribute record from the
    file record segment.  The pointer passed in will point to
    the next attribute record

Arguments:

    AttributeRecord - Supplies a valid pointer to an attribute record.

Return Value:

    None.

--*/
{
    PATTRIBUTE_RECORD_HEADER    p;
    PCHAR                       end;
    PCHAR                       frs_end;

    DebugAssert(AttributeRecord);

    p = (PATTRIBUTE_RECORD_HEADER) AttributeRecord;

    DebugAssert(p->TypeCode != $END);

    end = ((PCHAR) p) + p->RecordLength;
    frs_end = ((PCHAR) _FrsData) + QuerySize();

    DebugAssert(end < frs_end);

    memmove(p, end, (unsigned int)(frs_end - end));

    // This loop is here to straighten out the attribute records.
    p = NULL;
    while (p = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(p)) {
    }
}


BOOLEAN
NTFS_FRS_STRUCTURE::InsertAttributeRecord(
    IN OUT  PVOID   Position,
    IN      PCVOID  AttributeRecord
    )
/*++

Routine Description:

    This routine inserts the attribute record pointed to by
    'AttributeRecord' before the attribute record pointed to
    by Position.  When this routine is done, 'Position' will
    point to the copy of the attribute record just inserted
    inside this file record segment.

Arguments:

    Position        - Supplies a pointer to the attribute record that
                        will follow the attribute record to insert.
    AttributeRecord - Supplies the attribute record to insert.


Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    pos, attr;
    PCHAR                       dest, frs_end;

    DebugAssert(Position);
    DebugAssert(AttributeRecord);

    pos = (PATTRIBUTE_RECORD_HEADER) Position;
    attr = (PATTRIBUTE_RECORD_HEADER) AttributeRecord;

    if (attr->RecordLength > QueryAvailableSpace()) {
        return FALSE;
    }

    dest = (PCHAR) pos + attr->RecordLength;
    frs_end = (PCHAR) _FrsData + QuerySize();

    memmove(dest, pos, (unsigned int)(frs_end - dest));

    memcpy(pos, attr, (UINT) attr->RecordLength);

    // This loop is here to straighten out the attribute records.
    pos = NULL;
    while (pos = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(pos)) {
    }

    return TRUE;
}


BOOLEAN
NTFS_FRS_STRUCTURE::QueryAttributeList(
    OUT PNTFS_ATTRIBUTE_LIST    AttributeList
    )
/*++

Routine Description:

    This method fetches the Attribute List Attribute from this
    File Record Segment.

Arguments:

    AttributeList   - Returns A pointer to the Attribute List Attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    prec;
    NTFS_ATTRIBUTE_RECORD       record;

    return (prec = (PATTRIBUTE_RECORD_HEADER) GetAttributeList()) &&
           record.Initialize(GetDrive(), prec) &&
           AttributeList->Initialize(GetDrive(), QueryClusterFactor(),
                                     &record,
                                     GetUpcaseTable());
}


NONVIRTUAL
PVOID
NTFS_FRS_STRUCTURE::GetAttribute(
    IN  ULONG   TypeCode
    )
/*++

Routine Description:

    This routine returns a pointer to the unnamed attribute with the
    given type code or NULL if this attribute does not exist.

Arguments:

    TypeCode    - Supplies the type code of the attribute to search for.

Return Value:

    A pointer to an attribute or NULL if there none was found.

--*/
{
    PATTRIBUTE_RECORD_HEADER    prec;

    prec = NULL;
    while (prec = (PATTRIBUTE_RECORD_HEADER) GetNextAttributeRecord(prec)) {

        if (prec->TypeCode == TypeCode &&
            prec->NameLength == 0) {
            break;
        }
    }

    return prec;
}


NONVIRTUAL
PVOID
NTFS_FRS_STRUCTURE::GetAttributeList(
    )
/*++

Routine Description:

    This routine returns a pointer to the attribute list or NULL if
    there is no attribute list.

Arguments:

    None.

Return Value:

    A pointer to the attribute list or NULL if there is no attribute list.

--*/
{
    return GetAttribute($ATTRIBUTE_LIST);
}


BOOLEAN
NTFS_FRS_STRUCTURE::UpdateAttributeList(
    IN  PCNTFS_ATTRIBUTE_LIST   AttributeList,
    IN  BOOLEAN                 WriteFrs
    )
/*++

Routine Description:

    This routine updates the local $ATTRIBUTE_LIST with the
    attribute list provided.  'AttributeList' must be smaller
    than or equal (and of the form) to the the local
    $ATTRIBUTE_LIST in order for this method to be guaranteed
    to succeed.

Arguments:

    AttributeList   - Supplies a valid attribute list.
    WriteFrs        - State whether or not to write the FRS when done.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE_RECORD       attribute;
    PATTRIBUTE_RECORD_HEADER    old_attr, new_attr;

    DebugAssert(AttributeList);


    // Don't do anything if the attribute list hasn't changed.

    if (!AttributeList->IsStorageModified()) {
        return TRUE;
    }


    // Allocate some storage for the new attribute record.

    if (!(new_attr = (PATTRIBUTE_RECORD_HEADER) MALLOC((UINT) QuerySize()))) {
        return FALSE;
    }


    // Get the new attribute record.

    if (!AttributeList->QueryAttributeRecord(new_attr,
                                             QuerySize(),
                                             &attribute)) {

        FREE(new_attr);
        return FALSE;
    }


    // Locate the old attribute record.

    old_attr = (PATTRIBUTE_RECORD_HEADER) GetAttributeList();

    if (!old_attr) {
        FREE(new_attr);
        return FALSE;
    }


    // Make sure that there is enough room for new attribute record.

    if (QueryAvailableSpace() + old_attr->RecordLength <
                                new_attr->RecordLength) {

        FREE(new_attr);
        return FALSE;
    }


    // Use the same old instance field that exists on the current
    // attribute list for the new attribute list.

    new_attr->Instance = old_attr->Instance;


    // Delete the old attribute record.

    DeleteAttributeRecord(old_attr);


    // Insert the new attribute record.

    if (!InsertAttributeRecord(old_attr, new_attr)) {
        DebugAbort("Could not insert attribute list");
        FREE(new_attr);
        return FALSE;
    }


    // If required, write the changes to disk.

    if (WriteFrs && !Write()) {

        DebugAbort("Readable FRS is unwritable");
        return FALSE;
    }


    FREE(new_attr);

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FRS_STRUCTURE::SafeQueryAttribute(
    IN      ATTRIBUTE_TYPE_CODE TypeCode,
    IN OUT  PNTFS_ATTRIBUTE     MftData,
    OUT     PNTFS_ATTRIBUTE     Attribute
    )
/*++

Routine Description:

    This routine does a 'safe' query attribute operation.  This
    primarily needed by 'chkdsk' at times when it absolutely needs
    to retrieve a certain attribute but it cannot depend on the disk
    structures being good.

    This routine queries unnamed attributes only.

Arguments:

    TypeCode            - Supplies the type code of the attribute to retrieve.
    MftData             - Supplies the MFT $DATA attribute.
    Attribute           - Returns the attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVOID                   record;
    NTFS_ATTRIBUTE_RECORD   attr_record;
    NTFS_FRS_STRUCTURE      frs;
    HMEM                    hmem;
    VCN                     next_lowest_vcn;
    NTFS_ATTRIBUTE_LIST     attrlist;
    ATTRIBUTE_TYPE_CODE     type_code;
    MFT_SEGMENT_REFERENCE   seg_ref;
    VCN                     lowest_vcn;
    DSTRING                 name;
    DSTRING                 record_name;
    VCN                     file_number;
    PNTFS_FRS_STRUCTURE     pfrs;
    BOOLEAN                 rvalue;
    ATTR_LIST_CURR_ENTRY    entry;
    USHORT                  instance;
    PNTFS_EXTENT_LIST       backup_extent_list = NULL;


    // First validate the attribute records linking in this FRS;

    record = NULL;
    while (record = GetNextAttributeRecord(record)) {
    }


    if (!QueryAttributeList(&attrlist)) {

        // There's no attribute list so just go through it and pluck
        // out the record.

        record = NULL;
        while (record = GetNextAttributeRecord(record)) {

            if (!attr_record.Initialize(GetDrive(), record)) {
                DebugAbort("Counldn't initialize attribute record");
                return FALSE;
            }

            if (attr_record.QueryTypeCode() == TypeCode &&
                attr_record.QueryLowestVcn() == 0 &&
                attr_record.Verify(NULL, TRUE) &&
                attr_record.QueryName(&name) &&
                !name.QueryChCount()) {

                break;
            }
        }

        if (!record) {
            return FALSE;
        }

        return Attribute->Initialize(GetDrive(), QueryClusterFactor(),
                                     &attr_record) &&
               Attribute->VerifyAndFix(QueryVolumeSectors());
    }


    // give out if the attribute list is unreadable.

    if (!attrlist.ReadList()) {
        return FALSE;
    }


    // Since, there's an attribute list, perform the analysis based
    // on it.

    // The first attribute record to pick up will have lowest_vcn of 0.
    next_lowest_vcn = 0;

    rvalue = FALSE;

    entry.CurrentEntry = NULL;
    while (attrlist.QueryNextEntry(&entry,
                                   &type_code,
                                   &lowest_vcn,
                                   &seg_ref,
                                   &instance,
                                   &name)) {

        if (type_code != TypeCode ||
            lowest_vcn != next_lowest_vcn ||
            name.QueryChCount()) {
            continue;
        }

        file_number.Set(seg_ref.LowPart, (LONG) seg_ref.HighPart);

        pfrs = NULL;

        if (file_number == QueryFileNumber()) {

            if (!(seg_ref == QuerySegmentReference())) {
                continue;
            }

            pfrs = this;

        } else {

            // If we're boot strapping the MFT then make sure that
            // the first one is in the base FRS.

            if (lowest_vcn == 0 && MftData == Attribute) {
                DELETE(backup_extent_list);
                return FALSE;
            }

            if (!hmem.Initialize() ||
                !frs.Initialize(&hmem, MftData, file_number,
                                QueryClusterFactor(), QueryVolumeSectors(),
                                QuerySize(), GetUpcaseTable()) ||
                !frs.Read() ||
                !(frs.QuerySegmentReference() == seg_ref) ||
                !(frs.QueryBaseFileRecordSegment() == QuerySegmentReference())) {

                continue;
            }

            pfrs = &frs;
        }

        DebugAssert(pfrs);

        record = NULL;
        while (record = pfrs->GetNextAttributeRecord(record)) {

            if (!attr_record.Initialize(GetDrive(), record)) {
                DELETE(backup_extent_list);
                DebugAbort("Could not initialize attribute record");
                return FALSE;
            }


            if (attr_record.QueryTypeCode() == type_code &&
                attr_record.QueryLowestVcn() == lowest_vcn &&
                attr_record.Verify(NULL, TRUE) &&
                attr_record.QueryName(&record_name) &&
                !record_name.QueryChCount()) {

                break;
            }
        }

        if (!record) {
            continue;
        }

        if (lowest_vcn == 0) {

            rvalue = Attribute->Initialize(GetDrive(),
                                           QueryClusterFactor(),
                                           &attr_record);

            if (!rvalue) {
                continue;
            }

        } else {

            if (!Attribute->AddAttributeRecord(&attr_record, &backup_extent_list)) {
                DELETE(backup_extent_list);
                continue;
            }
        }

        next_lowest_vcn = attr_record.QueryNextVcn();
        entry.CurrentEntry = NULL;
    }

    DELETE(backup_extent_list);
    return rvalue ? Attribute->VerifyAndFix(QueryVolumeSectors()) : FALSE;
}


ULONG
NTFS_FRS_STRUCTURE::QueryAvailableSpace(
    )
/*++

Routine Description:

    This routine returns the number of bytes available for
    attribute records.

Arguments:

    None.

Return Value:

    The number of bytes currently available for attribute records.

--*/
{
    PVOID   p;

    // Spin through in order to guarantee a valid field.

    p = NULL;
    while (p = GetNextAttributeRecord(p)) {
    }

    return QuerySize() - _FrsData->FirstFreeByte;
}


BOOLEAN
SwapAttributeRecords(
    IN OUT  PVOID   FirstAttributeRecord
    )
/*++

Routine Description:

    This routine swaps 'FirstAttributeRecord' with the next attribute
    record in the list.  This method will fail if there is not
    enough memory available for a swap buffer.

Arguments:

    FirstAttributeRecord    - Supplies the first of two attribute records
                                to be swapped.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PATTRIBUTE_RECORD_HEADER    p1, p2;
    PCHAR                       q1, q2;
    PVOID                       buf;
    UINT                        first_record_length;

    p1 = (PATTRIBUTE_RECORD_HEADER) FirstAttributeRecord;
    q1 = (PCHAR) p1;

    DebugAssert(p1->TypeCode != $END);

    first_record_length = (UINT) p1->RecordLength;

    if (!(buf = MALLOC(first_record_length))) {
        return FALSE;
    }

    // Tuck away the first record.

    memcpy(buf, p1, first_record_length);


    q2 = q1 + p1->RecordLength;
    p2 = (PATTRIBUTE_RECORD_HEADER) q2;

    DebugAssert(p2->TypeCode != $END);


    // Overwrite first attribute record with second attribute record.

    memmove(p1, p2, (UINT) p2->RecordLength);


    // Copy over the first attribute record after the second.

    memcpy(q1 + p1->RecordLength, buf, first_record_length);

    FREE(buf);

    return TRUE;
}


INT
CompareResidentAttributeValues(
    IN  PCNTFS_ATTRIBUTE_RECORD Left,
    IN  PCNTFS_ATTRIBUTE_RECORD Right
    )
/*++

Routine Description:

    This routine compares the attribute values of two resident attributes
    and returns -1 is Left < Right, 0 if Left == Right, or 1 if Left > Right.

Arguments:

    Left    - Supplies the left hand side of the comparison.
    Right   - Supplies the right hand side of the comparison.

Return Value:

    < 0 - Left < Right
    0   - Left == Right
    > 0 - Left > Right

--*/
{
    BIG_INT left_length, right_length;
    INT     r;

    Left->QueryValueLength(&left_length);
    Right->QueryValueLength(&right_length);

    r = memcmp(Left->GetResidentValue(), Right->GetResidentValue(),
               min(left_length.GetLowPart(), right_length.GetLowPart()));

    if (r != 0) {
        return r;
    }

    if (left_length == right_length) {
        r = 0;
    } else if (left_length < right_length) {
        r = -1;
    } else {
        r = 1;
    }

    return r;
}


BOOLEAN
NTFS_FRS_STRUCTURE::Sort(
    OUT PBOOLEAN    Changes,
    OUT PBOOLEAN    Duplicates
    )
/*++

Routine Description:

    This routine bubble sorts the attributes by type, name, and (if
    the attribute is indexed) value.

Arguments:

    Changes     - Returns whether or not there were any changes made.
    Duplicates  - Returns whether or not there were any duplicates
                    eliminated.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVOID                   prev;
    PVOID                   p;
    NTFS_ATTRIBUTE_RECORD   attr1;
    NTFS_ATTRIBUTE_RECORD   attr2;
    PNTFS_ATTRIBUTE_RECORD  prev_attr;
    PNTFS_ATTRIBUTE_RECORD  attr;
    PNTFS_ATTRIBUTE_RECORD  tmp_attr;
    BOOLEAN                 stable;
    INT                     r;
    LONG                    CompareResult;

    DebugAssert(Changes);

    *Changes = FALSE;
    *Duplicates = FALSE;

    prev_attr = &attr1;
    attr = &attr2;

    stable = FALSE;

    while (!stable) {

        stable = TRUE;

        if (!(prev = GetNextAttributeRecord(NULL))) {
            return TRUE;
        }

        if (!prev_attr->Initialize(GetDrive(), prev)) {
            DebugAbort("Could not initialize attribute record.");
            return FALSE;
        }

        while (p = GetNextAttributeRecord(prev)) {

            if (!attr->Initialize(GetDrive(), p)) {
                DebugAbort("Could not initialize attribute record.");
                return FALSE;
            }

            CompareResult = CompareAttributeRecords( prev_attr,
                                          attr,
                                          GetUpcaseTable() );

            if ( CompareResult > 0 ) {

                // Out of order.  Swap.

                PIO_DP_DRIVE        drive = GetDrive();

                if (drive) {
                    PMESSAGE msg = drive->GetMessage();
                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_ATTR_OUT_OF_ORDER,
                                 "%x%x%x%x%I64x",
                                 prev_attr->QueryTypeCode(),
                                 prev_attr->QueryInstanceTag(),
                                 attr->QueryTypeCode(),
                                 attr->QueryInstanceTag(),
                                 QueryFileNumber().GetLargeInteger());
                    }
                }

                if (!SwapAttributeRecords(prev)) {
                    return FALSE;
                }

                *Changes = TRUE;
                stable = FALSE;
                break;
            }

            if ( CompareResult == 0 ) {

                // These two attribute records have the same type
                // code and name.  They better both be indexed and
                // have differing values.

                if (!attr->IsIndexed() ||
                    !prev_attr->IsIndexed()) {

                    // They're not both indexed so delete them.

                    PIO_DP_DRIVE        drive = GetDrive();

                    if (drive) {
                        PMESSAGE msg = drive->GetMessage();
                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_IDENTICAL_ATTR_RECORD_WITHOUT_INDEX,
                                     "%x%x%x%x%I64x",
                                     prev_attr->QueryTypeCode(),
                                     prev_attr->QueryInstanceTag(),
                                     attr->QueryTypeCode(),
                                     attr->QueryInstanceTag(),
                                     QueryFileNumber().GetLargeInteger());
                        }
                    }

                    DeleteAttributeRecord(p);
                    DeleteAttributeRecord(prev);

                    *Duplicates = TRUE;
                    *Changes = TRUE;
                    stable = FALSE;
                    break;
                }

                // They're both indexed so do a comparison.

                r = CompareResidentAttributeValues(prev_attr, attr);

                if (r == 0) {

                    // The attribute records are equal so
                    // delete them both.

                    PIO_DP_DRIVE        drive = GetDrive();

                    if (drive) {
                        PMESSAGE msg = drive->GetMessage();
                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_IDENTICAL_ATTR_VALUE,
                                     "%x%x%I64x",
                                     prev_attr->QueryTypeCode(),
                                     prev_attr->QueryInstanceTag(),
                                     QueryFileNumber().GetLargeInteger());
                        }
                    }

                    DeleteAttributeRecord(p);
                    DeleteAttributeRecord(prev);

                    *Duplicates = TRUE;
                    *Changes = TRUE;
                    stable = FALSE;
                    break;
                }

                if (r > 0) {

                    // Out of order.  Swap.

                    if (!SwapAttributeRecords(prev)) {
                        return FALSE;
                    }

                    // We don't set the 'Changes' flag here because
                    // indexed attributes don't have to be ordered by
                    // value.

                    stable = FALSE;
                    break;
                }
            }

            tmp_attr = prev_attr;
            prev_attr = attr;
            attr = tmp_attr;

            prev = p;
        }
    }

    return TRUE;
}

NONVIRTUAL
VOID
NTFS_FRS_STRUCTURE::SetFrsData(
    IN  VCN                         FileNumber,
    IN  PFILE_RECORD_SEGMENT_HEADER frsdata
    )
{
    _file_number = FileNumber;
    _FrsData = frsdata;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\extents.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    extents.cxx

Abstract:

    This module contains the definitions for NTFS_EXTENT_LIST, which
    models a set of NTFS extents.

    An extent is a contiguous run of clusters; a non-resident
    attribute's value is made up of a list of extents.  The
    NTFS_EXTENT_LIST object can be used to describe the disk space
    allocated to a non-resident attribute.

    This class also encapsulates the knowledge of mapping pairs
    and their compression, i.e. of the representation of extent
    lists in attribute records.

    The extent list is kept sorted by VCN.  Since extent lists are
    typically quite short, linear search is used.

Author:

    Bill McJohn (billmc) 17-June-91
    Matthew Bradburn (mattbr) 19-August-95
        Changed to use NTFS MCB package for improved performance.

Environment:

    ULIB, User Mode


--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "ntfsbit.hxx"
#include "intstack.hxx"
#include "iterator.hxx"

#include "extents.hxx"
#include "ntfssa.hxx"

extern "C" {
#include "fsrtlp.h"
}

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_EXTENT_LIST, OBJECT, UNTFS_EXPORT );
DEFINE_CONSTRUCTOR( NTFS_EXTENT, OBJECT );

//
// These routines are to support the NTFS MCB package.
//

extern "C"
PVOID
MemAlloc(
    IN  ULONG   Size
    );

PVOID
MemAlloc(
    IN  ULONG   Size
    )
{
    return  NEW BYTE[Size];
}

extern "C"
PVOID
MemAllocOrRaise(
    IN  ULONG   Size
    );

PVOID
MemAllocOrRaise(
    IN  ULONG   Size
    )
{
    PVOID p;

    p = MemAlloc(Size);

    if (NULL == p) {
        RtlRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
    }
    return p;
}

extern "C"
VOID
MemFree(
    IN  PVOID   Addr
    );

VOID
MemFree(
    IN  PVOID   Addr
    )
{
    delete[] Addr;
}


UNTFS_EXPORT
NTFS_EXTENT_LIST::~NTFS_EXTENT_LIST(
    )
/*++

Routine Description:

    Destructor for NTFS_EXTENT_LIST class.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

VOID
NTFS_EXTENT_LIST::Construct(
    )
/*++

Routine Description:

    Worker method for NTFS_EXTENT_LIST construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _LowestVcn = 0;
    _NextVcn = 0;
    _McbInitialized = FALSE;
    _Mcb = NULL;
}

VOID
NTFS_EXTENT_LIST::Destroy(
    )
/*++

Routine Description:

    Worker method for NTFS_EXTENT_LIST destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _LowestVcn = 0;
    _NextVcn = 0;

    if (_McbInitialized) {

        FsRtlUninitializeLargeMcb(_Mcb);
        _McbInitialized = FALSE;
    }

    DELETE(_Mcb);
}


UNTFS_EXPORT
BOOLEAN
NTFS_EXTENT_LIST::Initialize(
    IN VCN LowestVcn,
    IN VCN NextVcn
    )
/*++

Routine Description:

    Initializes an empty extent list.

Arguments:

    LowestVcn   -- supplies the lowest VCN mapped by this extent list
    NextVcn     -- supplies the next VCN following this extent list

Return Value:

    TRUE upon successful completion.

Notes:

    Highest and Lowest VCN are typically zero; they are provided
    to permit creation of sparse files.

    This class is reinitializable.

--*/
{
    Destroy();

    _LowestVcn = LowestVcn;
    _NextVcn = (NextVcn < LowestVcn) ? LowestVcn : NextVcn;

    if (NULL == (_Mcb = NEW LARGE_MCB)) {
        Destroy();
        return FALSE;
    }

    __try {

        FsRtlInitializeLargeMcb(_Mcb, (POOL_TYPE)0);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Destroy();
        return FALSE;
    }

    _McbInitialized = TRUE;

    return TRUE;
}


BOOLEAN
NTFS_EXTENT_LIST::Initialize(
    IN  VCN         StartingVcn,
    IN  PCVOID      CompressedMappingPairs,
    IN  ULONG       MappingPairsMaximumLength,
    OUT PBOOLEAN    BadMappingPairs
    )
/*++

Routine Description:

    Initialize an extent list based on a set of compressed mapping
    pairs (presumably taken from an attribute record).

Arguments:

    StartingVcn                 --  Supplies the starting VCN of the
                                    mapping pairs list
    CompressedMappingPairs      --  Supplies a pointer to the compressed
                                    list of mapping pairs
    MappingPairsMaximumLength   --  Supplies the length (in bytes) of
                                    the buffer in which the mapping
                                    pairs list resides
    BadMappingPairs             --  If non-NULL, receives TRUE if this
                                    method failed because the mapping
                                    pairs list could not be expanded.
                                    If this method returns TRUE, then
                                    *BadMappingPairs should be ignored.

Return Value:

    TRUE upon successful completion.

Notes:

    This method does not assume that the mapping pairs list can be
    correctly expanded.  It does assume that the MappingPairsMaximumLength
    is correct, i.e. that it can reference that many bytes of memory
    starting at CompressedMappingPairs.

    Clients who trust the mapping pairs list which they pass in may omit
    the BadMappingPairs parameter; those (like Chkdsk) who do not trust
    the list can use BadMappingPairs to determine whether Initialize failed
    because of a bad mapping pairs list.

--*/
{
    DebugPtrAssert( CompressedMappingPairs );

    return( Initialize( StartingVcn, StartingVcn ) &&
            AddExtents( StartingVcn,
                        CompressedMappingPairs,
                        MappingPairsMaximumLength,
                        BadMappingPairs ) );
}



BOOLEAN
NTFS_EXTENT_LIST::Initialize(
    IN PCNTFS_EXTENT_LIST ExtentsToCopy
    )
/*++

Routine Description:

    Initializes an extent list based on another extent list.

Arguments:

    ExtentsToCopy   - Supplies the other list of extents.

Return Value:

    TRUE upon successful completion.

Notes:

    This class is reinitializable.

--*/
{
    VCN             Vcn;
    LCN             Lcn;
    BIG_INT         RunLength;
    ULONG           num_extents;

    Destroy();

    if (!Initialize(ExtentsToCopy->_LowestVcn,
                    ExtentsToCopy->_NextVcn)) {

        Destroy();
        return FALSE;
    }

    num_extents = ExtentsToCopy->QueryNumberOfExtents();

    for (ULONG i = 0; i < num_extents; ++i) {
        if (!ExtentsToCopy->QueryExtent(i, &Vcn, &Lcn, &RunLength)) {
            Destroy();
            return FALSE;
        }
        if (LCN_NOT_PRESENT == Lcn) {
            continue;
        }

        if (!AddExtent(Vcn, Lcn, RunLength)) {
            Destroy();
            return FALSE;
        }
    }

    SetLowestVcn(ExtentsToCopy->_LowestVcn);
    SetNextVcn(ExtentsToCopy->_NextVcn);

    return TRUE;
}



BOOLEAN
NTFS_EXTENT_LIST::IsSparse(
    ) CONST
/*++

Routine Description:

    This method determines whether the extent list has holes
    (ie. if there are not-present-on-disk runs in the attribute).

Arguments:

    None.

Return Value:

    TRUE if the extent list is sparse.

--*/
{
    BIG_INT         previous_vcn, previous_lcn, previous_runlength;
    BIG_INT         current_vcn, current_lcn, current_runlength;
    ULONG           i = 0;

    if (!QueryExtent(i, &previous_vcn, &previous_lcn, &previous_runlength)) {

        if (_LowestVcn != _NextVcn) {

            // This extent list is one big hole.

            return TRUE;

        } else {

            // This extent list is empty.

            return FALSE;
        }
    }

    if (previous_vcn != _LowestVcn) {

        // This extent list starts with a hole.

        return TRUE;
    }

    // Check the rest of the extents, to see if there's a hole
    // before any of them:

    while (QueryExtent(++i, &current_vcn, &current_lcn, &current_runlength)) {

        if (LCN_NOT_PRESENT == current_lcn) {
            continue;
        }

        if (previous_vcn + previous_runlength != current_vcn) {
            return TRUE;
        }

        previous_vcn = current_vcn;
        previous_lcn = current_lcn;
        previous_runlength = current_runlength;
    }

    // Check to see if there's a hole after the last extent:

    if (previous_vcn + previous_runlength != _NextVcn) {
        return TRUE;
    }

    // Didn't find any holes.

    return FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_EXTENT_LIST::AddExtent(
    IN VCN      Vcn,
    IN LCN      Lcn,
    IN BIG_INT  RunLength
    )
/*++

Routine Description:

    This method adds an extent, specified by its Virtual Cluster Number,
    Logical Cluster Number, and Run Length, to the extent list.

    NTFS_EXTENT_LIST may, at its discretion, merge contiguous extents,
    but it does not guarrantee this behavior.

Arguments:

    Vcn         --  Supplies the starting VCN of the extent.
    Lcn         --  Supplies the starting LCN of the extent.
    RunLength   --  Supplies the number of clusters in the extent.

Return Value:

    TRUE upon successful completion.

--*/
{
    VCN             TempVcn;
    BOOLEAN         b;

    if (RunLength <= 0) {

        // zero-length runs are not valid.  Neither are negative ones.

        return FALSE;
    }
    if (LCN_NOT_PRESENT == Lcn) {

        // We ignore attempts to explicitly add holes.

        return TRUE;
    }

    //
    // Currently, Mcb routines cannot handle number beyond 32 bits
    //

    if (Vcn.GetLargeInteger().HighPart) {
        return FALSE;
    }

    __try {

        b = FsRtlAddLargeMcbEntry(_Mcb,
                                  Vcn.GetLargeInteger().QuadPart,
                                  Lcn.GetLargeInteger().QuadPart,
                                  RunLength.GetLargeInteger().QuadPart);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        return FALSE;
    }

    if (!b) {
        return FALSE;
    }

    if (_LowestVcn == _NextVcn) {
        _LowestVcn = Vcn;
        _NextVcn = Vcn + RunLength;
    }


    // If this extent changes the lowest and highest VCNs mapped
    // by this extent list, update those values.

    if (Vcn < _LowestVcn) {

        _LowestVcn = Vcn;
    }

    TempVcn = Vcn + RunLength;

    if (TempVcn > _NextVcn) {

        _NextVcn = TempVcn;
    }

    return TRUE;
}



VOID
NTFS_EXTENT_LIST::Coalesce(
    )
/*++

Routine Description:

    This routine coalesces adjacent extents in the extent list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // The MCB package does this for us.

    return;
}


BOOLEAN
NTFS_EXTENT_LIST::AddExtents(
    IN  VCN         StartingVcn,
    IN  PCVOID      CompressedMappingPairs,
    IN  ULONG       MappingPairsMaximumLength,
    OUT PBOOLEAN    BadMappingPairs
    )
/*++

Routine Description:

    This method adds a set of extents defined by a compressed mapping
    pairs list (presumably taken from an Attribute Record).

Arguments:

    StartingVcn     -- supplies the starting VCN of the mapping pairs list
    CompressedMappingPairs  -- supplies a pointer to the compressed
                                list of mapping pairs
    MappingPairsMaximumLengt -- supplies the length (in bytes) of the buffer
                                in which the mapping pairs list resides
    BadMappingPairs -- if non-NULL, receives TRUE if an error occurrs
                        while processing the mapping pairs list.

Return Value:

    TRUE upon successful completion.

Notes:

    BadMappingPairs will be set to TRUE if the compressed mapping
    pairs list cannot be expanded or if any extent derived from
    this list overlaps with another extent in the list.  In either
    of these cases, AddExtents will return FALSE.

    If this method encounters an error after processing part of
    the list, it will leave the extent list in an undefined (but
    valid, as an object) state.

    Clients who trust their mapping pairs list may omit the
    BadMappingPairs parameter.

--*/
{
    VCN             CurrentVcn;
    ULONG           LengthOfCompressedPairs;
    ULONG           NumberOfPairs;
    PMAPPING_PAIR   MappingPairs;
    ULONG i;

    // Assume innocent until found guilty
    //
    if( BadMappingPairs != NULL ) {

        *BadMappingPairs = FALSE;
    }

    // Determine how many mapping pairs we actually have, so
    // we can allocate the correct size of an expanded mapping
    // pairs buffer.

    if( !QueryMappingPairsLength( CompressedMappingPairs,
                                  MappingPairsMaximumLength,
                                  &LengthOfCompressedPairs,
                                  &NumberOfPairs ) ) {

        if( BadMappingPairs != NULL ) {

            *BadMappingPairs = TRUE;
        }

        DebugPrint( "Can't determine length of mapping pairs.\n" );
        return FALSE;
    }

    // Allocate a buffer to hold the expanded mapping pairs.

    MappingPairs = (PMAPPING_PAIR)MALLOC( sizeof(MAPPING_PAIR) *
                                            (UINT) NumberOfPairs );

    if( MappingPairs == NULL ) {

        return FALSE;
    }


    if( !ExpandMappingPairs( CompressedMappingPairs,
                             StartingVcn,
                             MappingPairsMaximumLength,
                             NumberOfPairs,
                             MappingPairs,
                             &NumberOfPairs ) ) {

        DebugPrint( "Cannot expand mapping pairs.\n" );

        if( BadMappingPairs != NULL ) {

            *BadMappingPairs = TRUE;
        }

        FREE( MappingPairs );
        return FALSE;
    }


    // Convert the mapping pairs into extents.

    CurrentVcn = StartingVcn;

    for( i = 0; i < NumberOfPairs; i++ ) {

        if( MappingPairs[i].CurrentLcn != LCN_NOT_PRESENT ) {

            if( !AddExtent( CurrentVcn,
                            MappingPairs[i].CurrentLcn,
                            MappingPairs[i].NextVcn - CurrentVcn ) ) {

                FREE( MappingPairs );
                return FALSE;
            }
        }

        CurrentVcn = MappingPairs[i].NextVcn;
    }

    // Set _LowestVcn to the client-supplied value, if necessary.
    // (This is required for mapping pair lists that begin with
    // a hole.)
    //
    if( StartingVcn < _LowestVcn ) {

        _LowestVcn = StartingVcn;
    }


    // Update _NextVcn if neccessary.
    //
    if( CurrentVcn > _NextVcn ) {

        _NextVcn = CurrentVcn;
    }

    FREE( MappingPairs );
    return TRUE;
}



VOID
NTFS_EXTENT_LIST::DeleteExtent(
    IN ULONG ExtentNumber
    )
/*++

Routine Description:

    This method removes an extent from the list.

Arguments:

    ExtentNumber    --  supplies the (zero-based) extent number to remove

Return Value:

    None.

--*/
{
    VCN             Vcn;
    LCN             Lcn;
    BIG_INT         RunLength;

    //
    // Find the VCN for the extent number.
    //

    if (!QueryExtent(ExtentNumber, &Vcn, &Lcn, &RunLength)) {
        DebugAbort("Shouldn't get here.");
        return;
    }

    FsRtlRemoveLargeMcbEntry(_Mcb,
                             Vcn.GetLargeInteger().QuadPart,
                             RunLength.GetLargeInteger().QuadPart);

    return;
}



BOOLEAN
NTFS_EXTENT_LIST::Resize(
    IN      BIG_INT         NewNumberOfClusters,
    IN OUT  PNTFS_BITMAP    Bitmap
    )
/*++

Routine Description:

    This method either extends or truncates the disk allocation
    covered by this extent list.

Arguments:

    NewNumberOfClusters -- supplies the number of clusters in
                            in the new allocation.

    Bitmap              -- supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    This method is only meaningful is the extent list covers an entire
    attribute instance.  In particular, if the extent list's LowestVcn
    is not zero, this method does nothing (and returns FALSE).

    If this method fails, it leaves the extent list in its original
    state.

--*/
{
    BIG_INT OldNumberOfClusters;
    BIG_INT ClustersToAdd;
    LCN     NewLcn, NearLcn;
    ULONG   ThisLump;

    if( _LowestVcn != 0 ) {

        // This extent list does not cover the entire attribute
        // instance, so it cannot be resized.

        return FALSE;
    }

    // Determine the number of clusters in the current size.

    OldNumberOfClusters = _NextVcn;


    if( OldNumberOfClusters == NewNumberOfClusters ) {

        // The extent list is already the size we want.

        return TRUE;

    } else if( NewNumberOfClusters < OldNumberOfClusters ) {

        // We're shrinking the extent list.  Note that Truncate
        // always succeeds, and does not have a return value.

        Truncate( NewNumberOfClusters, Bitmap );
        return TRUE;

    } else {

        // We are extending the allocation.

        ClustersToAdd = NewNumberOfClusters - OldNumberOfClusters;

        if( ClustersToAdd.GetHighPart() != 0 ) {

            DebugPrint( "Trying to allocate more than 4G clusters.\n" );
            return FALSE;
        }

        ThisLump = ClustersToAdd.GetLowPart();
        NearLcn = QueryLastLcn();

        while( ClustersToAdd != 0 ) {

            if (ClustersToAdd.GetLowPart() < ThisLump) {

                ThisLump = ClustersToAdd.GetLowPart();
            }

            if( !Bitmap->AllocateClusters( NearLcn,
                                           ThisLump,
                                           &NewLcn ) ) {

                // We can't allocate a chunk this size; cut it
                // in half and try again.
                //
                ThisLump /= 2;

                if( ThisLump == 0 )  {

                    // We're out of disk space.  Restore the extent
                    // list to its original state and exit with an
                    // error.

                    Truncate( OldNumberOfClusters, Bitmap );
                    return FALSE;
                }

            } else {

                // We allocated a chunk.  Add it on to the end.

                if( !AddExtent( _NextVcn, NewLcn, ThisLump ) ) {

                    // We hit an internal error trying to add
                    // this extent.  Restore the extent list to
                    // its original state and return failure.

                    Truncate( OldNumberOfClusters, Bitmap );
                    return FALSE;
                }

                ClustersToAdd -= ThisLump;

                // If there's more to get, we won't be able to get
                // it contiguous; instead, set NearLcn to 0 to take
                // advantage of the roving pointer.
                //
                NearLcn = 0;
            }
        }

        return TRUE;
    }
}

BOOLEAN
NTFS_EXTENT_LIST::SetSparse(
    IN      BIG_INT         NewNumberOfClusters
    )
/*++

Routine Description:

    This method sets up an extent lists to represents a sparse
    allocation (a hole).

Arguments:

    NewNumberOfClusters -- supplies the number of clusters in
                           the sparse extent list.

Return Value:

    TRUE upon successful completion.

Notes:

    This method is only meaningful if the extent list covers an entire
    attribute instance.  In particular, if the extent list's LowestVcn
    is not zero, this method does nothing (and returns FALSE).

    If this method fails, it leaves the extent list in its original
    state.

--*/
{
    if( _LowestVcn != 0 || _NextVcn != 0) {

        // This extent list does not cover the entire attribute
        // instance or is not empty, so it cannot be set sparse.

        return FALSE;
    }

    // Determine the number of clusters in the current size.

    _NextVcn = NewNumberOfClusters;

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_EXTENT_LIST::QueryExtent(
    IN  ULONG       ExtentNumber,
    OUT PVCN        Vcn,
    OUT PLCN        Lcn,
    OUT PBIG_INT    RunLength
    ) CONST
/*++

Routine Description:

    This methods gives the client information on an extent in
    the list.

Arguments:

    ExtentNumber -- supplies the number of the extent to return (zero-based).
    Vcn          -- receives the starting VCN of the extent.
    Lcn          -- receives the starting LCN of the extent.
    RunLength    -- receives the number of clusters in the extent.

Return Value:

    TRUE if ExtentNumber is less than the number of extents in the list;
    FALSE if it is out of range.

--*/
{
    BOOLEAN         b;
    LONGLONG        Vbn, Lbn, SectorCount;
    LARGE_INTEGER   li;

    b = FsRtlGetNextLargeMcbEntry((PLARGE_MCB)_Mcb,
            ExtentNumber, &Vbn, &Lbn, &SectorCount);
    if (!b) {
        return FALSE;
    }

    li.QuadPart = Vbn;
    *Vcn = li;

    li.QuadPart = Lbn;
    *Lcn = li;

    li.QuadPart = SectorCount;
    *RunLength = li;

    return TRUE;
}


BOOLEAN
NTFS_EXTENT_LIST::QueryLcnFromVcn(
    IN  VCN         Vcn,
    OUT PLCN        Lcn,
    OUT PBIG_INT    RunLength
    ) CONST
/*++

Routine Description:

    This method converts a VCN within the allocation described by
    this extent list into an LCN.

Arguments:

    Vcn       -- supplies the VCN to be converted.
    Lcn       -- receives the LCN that corresponds to the supplied Vcn.
    RunLength -- if non-NULL, receives the remaining length in the
                 extent from the supplied Vcn.

Return Value:

    TRUE upon successful completion.

    If the specified VCN is outside the range [_LowestVcn, _NextVcn),
    this method returns FALSE.

    If the extent list is sparse and the requested VCN is in the range
    of this extent list but falls in a hole, this method will return TRUE;
    *Lcn is set to LCN_NOT_PRESENT, and *RunLength is set to the remaining
    run length to the next actual extent.

--*/
{
    BOOLEAN         b;
    LONGLONG        Lbn = -1, SectorCount;
    LARGE_INTEGER   li;
    VCN             vcn;
    LCN             lcn;
    BIG_INT         runlength;

    if (Vcn < _LowestVcn || Vcn >= _NextVcn) {

        return FALSE;
    }

    b = FsRtlLookupLargeMcbEntry(
                   (PLARGE_MCB)_Mcb,
                   Vcn.GetLargeInteger().QuadPart,
                   &Lbn,
                   &SectorCount,            /* SectorCountFromLbn */
                   NULL,                    /* StartingLbn */
                   NULL,                    /* SectorCountFromStartingLbn */
                   NULL                     /* Index */
                   );
    if (!b) {

        // This VCN fell into a hole.  See if it comes after the last
        // real extent in the list, otherwise maybe it comes before the
        // first.
        //

        *Lcn = LCN_NOT_PRESENT;

        if (0 == QueryNumberOfExtents()) {
            if (NULL != RunLength) {
                *RunLength = _NextVcn - Vcn;
            }
            return TRUE;
        }

        if (!QueryExtent(QueryNumberOfExtents() - 1, &vcn, &lcn, &runlength)) {
            return FALSE;
        }

        if (Vcn > vcn) {
            if (NULL != RunLength) {
                *RunLength = _NextVcn - Vcn;
            }
            return TRUE;
        }

        if (!QueryExtent(0, &vcn, &lcn, &runlength)) {
            return FALSE;
        }

        if (Vcn < vcn) {
            if (NULL != RunLength) {
                *RunLength = Vcn - _LowestVcn;
            }
            return TRUE;
        }

        return FALSE;
    }

    if (NULL != RunLength) {
        li.QuadPart = SectorCount;
        *RunLength = li;
    }

    if (-1 == Lbn) {
        *Lcn = LCN_NOT_PRESENT;
        return TRUE;
    }

    li.QuadPart = Lbn;
    *Lcn = li;

    return TRUE;
}



BOOLEAN
NTFS_EXTENT_LIST::QueryCompressedMappingPairs(
    OUT    PVCN     LowestVcn,
    OUT    PVCN     NextVcn,
    OUT    PULONG   Length,
    IN     ULONG    BufferSize,
    IN OUT PVOID    Buffer,
    OUT    PBOOLEAN HasHoleInFront
    ) CONST
/*++

Routine Description:

    This method produces a set of compressed mapping pairs
    corresponding to this extent list.

Arguments:

    LowestVcn   -- receives the lowest VCN covered by this extent list.
    NextVcn     -- receives the VCN following this extent list.
    Length      -- receives the length of the compressed mapping pairs list.
    BufferSize  -- supplies the size of the mapping pairs buffer provided
                    by the caller
    Buffer      -- supplies the buffer into which the compressed mapping
                    pairs list is written.
    HasHoleInFront
                -- receives TRUE if we skipped a hole at the very beginning
                    of the extent list during compression; otherwise FALSE.
                    This is useful for code that counts the compression
                    pairs and calls QueryExtent with the count.

Return Value:

    A pointer to the compressed mapping pairs list.  Note that the client
    must free this memory (using FREE).  NULL indicates an error.

--*/
{
    ULONG           MaximumMappingPairs;
    PMAPPING_PAIR   MappingPairs;
    PMAPPING_PAIR   CurrentMappingPair;
    ULONG           NumberOfPairs;
    VCN             TheNextVcn;
    BOOLEAN         Result;
    ULONG           num_extents;

     if (HasHoleInFront)
          *HasHoleInFront = FALSE;

    // First, let's handle the degenerate case--if the list
    // has no extents, it's compresses to a single zero byte.
    //
    if (IsEmpty()) {

        if (BufferSize == 0) {

            return FALSE;

        } else {

            *LowestVcn = 0;
            *NextVcn = 0;
            *Length = 1;

            *(PBYTE)Buffer = 0;

            return TRUE;
        }
    }

    // Massage the extent list into a mapping pairs list and compress it.
    // In the worst case, no two extents are VCN-contiguous, and
    // so the number of mapping pairs would be one more than twice
    // the number of extents (gap extent gap extent gap ... extent gap).

    // This upper bound formula may be too much as QueryNumberOfExtents will
    // return all entries including gaps except the last one if it is a gap.

    num_extents = QueryNumberOfExtents();

    MaximumMappingPairs = 2 * num_extents + 1;

    MappingPairs = (PMAPPING_PAIR)MALLOC( (UINT) (sizeof(MAPPING_PAIR) *
                                            MaximumMappingPairs) );

    if( MappingPairs == NULL ) {

        return FALSE;
    }

    TheNextVcn = _LowestVcn;
    NumberOfPairs = 0;

    CurrentMappingPair = MappingPairs;

    for (ULONG i = 0; i < num_extents; ++i) {

        VCN Vcn;
        LCN Lcn;
        BIG_INT RunLength;

        DebugAssert(NumberOfPairs < MaximumMappingPairs);

        if (!QueryExtent(i, &Vcn, &Lcn, &RunLength)) {
            DebugAbort("This shouldn't happen\n");
            return FALSE;
        }
        if (LCN_NOT_PRESENT == Lcn) {
            if ((i == 0) && HasHoleInFront)
                *HasHoleInFront = TRUE;
            continue;
        }

        if (Vcn != TheNextVcn) {

            // This extent is preceded by a gap, so we create
            // a mapping pair with the LCN equal to LCN_NOT_PRESENT.

            CurrentMappingPair->NextVcn = Vcn;
            CurrentMappingPair->CurrentLcn = LCN_NOT_PRESENT;

            CurrentMappingPair++;
            NumberOfPairs++;
        }

        // Create a mapping pair for the extent represented by
        // the current node.  At the same time, compute NextVcn
        // so we can check to see if there's a gap before the
        // next extent.

        TheNextVcn = Vcn + RunLength;

        CurrentMappingPair->NextVcn = TheNextVcn;
        CurrentMappingPair->CurrentLcn = Lcn;

        CurrentMappingPair++;
        NumberOfPairs++;
    }

    DebugAssert(NumberOfPairs < MaximumMappingPairs);

    if (TheNextVcn != _NextVcn) {

        // The last extent is followed by a gap.  Add a mapping pair
        // (with CurrentLcn of LCN_NOT_PRESENT) to cover that gap.

        CurrentMappingPair->NextVcn = _NextVcn;
        CurrentMappingPair->CurrentLcn = LCN_NOT_PRESENT;

        NumberOfPairs++;
        CurrentMappingPair++;
    }

    // We now have a properly set-up array of mapping pairs.  Compress
    // it into the user's buffer.

    Result = CompressMappingPairs( MappingPairs,
                                   NumberOfPairs,
                                   _LowestVcn,
                                   Buffer,
                                   BufferSize,
                                   Length );

    FREE( MappingPairs );

    *LowestVcn = _LowestVcn;
    *NextVcn = _NextVcn;

    return Result;
}

VOID
NTFS_EXTENT_LIST::Truncate(
    IN     BIG_INT      NewNumberOfClusters,
    IN OUT PNTFS_BITMAP Bitmap
    )
/*++

Routine Description:

    This method truncates the extent list.

Arguments:

    NewNumberOfClusters -- supplies the number of clusters to keep.
    Bitmap              -- supplies the volume bitmap (optional).

Return Value:

    None.

Notes:

    If the number of clusters covered by this extent list is already
    less than or equal to NewNumberOfClusters, then this method does
    nothing.

--*/
{
    BIG_INT         new_run_length;
    ULONG           num_extents;

    DebugAssert(_LowestVcn == 0);

    if (NewNumberOfClusters >= _NextVcn) {

        return;
    }

    num_extents = QueryNumberOfExtents();

    for (ULONG i = 0; i < num_extents; ++i) {

        VCN Vcn;
        LCN Lcn;
        BIG_INT RunLength;

        if (!QueryExtent(i, &Vcn, &Lcn, &RunLength)) {
            DebugAbort("This shouldn't happen\n");
            return;
        }
        if (LCN_NOT_PRESENT == Lcn) {
            continue;
        }

        if (Vcn >= NewNumberOfClusters) {

            if (NULL != Bitmap) {
                Bitmap->SetFree(Lcn, RunLength);
            }
        } else if (Vcn + RunLength > NewNumberOfClusters) {

            new_run_length = NewNumberOfClusters - Vcn;

            if (NULL != Bitmap) {
                Bitmap->SetFree(Lcn + new_run_length,
                                RunLength - new_run_length);
            }
        }
    }

    _NextVcn = NewNumberOfClusters;
    FsRtlTruncateLargeMcb(_Mcb, _NextVcn.GetLargeInteger().QuadPart);
}



BOOLEAN
NTFS_EXTENT_LIST::QueryMappingPairsLength(
    IN  PCVOID  CompressedPairs,
    IN  ULONG   MaximumLength,
    OUT PULONG  Length,
    OUT PULONG  NumberOfPairs
    )
/*++

Routine Description:

    This function determines the length of a compressed
    mapping pairs list.

Arguments:

    CompressedPairs -- supplies the pointer to the compressed list
    MaximumLength   -- supplies the size of the buffer containing the
                        compressed list.
    Length          -- receives the length of the compressed list
    NumberOfPairs   -- receieves the number of pairs in the list

Return Value:

    TRUE upon successful completion.  FALSE indicates that the list
    overflows the supplied buffer.

--*/
{
    PBYTE CurrentCountByte;
    ULONG CurrentLength;

    CurrentCountByte = (PBYTE)CompressedPairs;

    *NumberOfPairs = 0;
    *Length = 0;

    while( *Length <= MaximumLength &&
           *CurrentCountByte != 0 ) {

        // The length for this pair is the number of LCN bytes, plus
        // the number of VCN bytes, plus one for the count byte.

        CurrentLength = LcnBytesFromCountByte( *CurrentCountByte ) +
                        VcnBytesFromCountByte( *CurrentCountByte ) +
                        1;

        (*NumberOfPairs)++;
        *Length += CurrentLength;

        CurrentCountByte += CurrentLength;
    }

    (*Length)++; // For the final 0 byte.

    return( *Length <= MaximumLength );
}


BOOLEAN
NTFS_EXTENT_LIST::ExpandMappingPairs(
    IN     PCVOID           CompressedPairs,
    IN     VCN              StartingVcn,
    IN     ULONG            BufferSize,
    IN     ULONG            MaximumNumberOfPairs,
    IN OUT PMAPPING_PAIR    MappingPairs,
    OUT    PULONG           NumberOfPairs
    )
/*++

Routine Description:

    This function expands a compressed list of mapping pairs into
    a client-supplied buffer.

Arguments:

    CompressedPairs         -- supplies the compressed mapping pairs
    StartingVcn             -- supplies the lowest VCN mapped by these
                                mapping pairs
    BufferSize              -- supplies the maximum size of the buffer from
                                which the compressed pairs are expanded
    MaximumNumberOfPairs    -- supplies the maximum number of expanded
                                mapping pairs the output buffer can accept
    MappingPairs            -- receives the expanded pairs
    NumberOfPairs           -- receives the number of pairs

Return Value:

    TRUE upon successful completion.

--*/
{
    PBYTE CurrentData;
    VCN CurrentVcn;
    LCN CurrentLcn;
    UCHAR v, l;
    ULONG CurrentLength;
    VCN DeltaVcn;
    LCN DeltaLcn;
    ULONG PairIndex;


    CurrentData = (PBYTE)CompressedPairs;
    CurrentVcn = StartingVcn;
    CurrentLcn = 0;
    CurrentLength = 0;
    PairIndex = 0;

    while(  CurrentLength < BufferSize &&
            *CurrentData != 0 &&
            PairIndex < MaximumNumberOfPairs
            ) {

        // Get the count byte.  Note that whenever we advance the
        // current data pointer, we first increment the length count,
        // to make sure our access is valid.

        CurrentLength ++;

        if( CurrentLength > BufferSize ) {

            return FALSE;
        }

        v = VcnBytesFromCountByte( *CurrentData );
        l = LcnBytesFromCountByte( *CurrentData );

        CurrentData ++;


        // Unpack DeltaVcn and compute the current VCN:

        CurrentLength += v;

        if( v > 8 || CurrentLength > BufferSize ) {

            return FALSE;
        }

        DeltaVcn.Set( v, CurrentData );
        CurrentData += v;

        CurrentVcn += DeltaVcn;
        MappingPairs[PairIndex].NextVcn = CurrentVcn;

        // Unpack DeltaLcn and compute the current LCN:
        //
        CurrentLength += l;

        if( l > 8 || CurrentLength > BufferSize ) {

            return FALSE;
        }

        if( l == 0 ) {

            // a delta-LCN count value of 0 indicates a
            // non-present run.
            //
            MappingPairs[PairIndex].CurrentLcn = LCN_NOT_PRESENT;

        } else {

            DeltaLcn.Set( l, CurrentData );
            CurrentLcn += DeltaLcn;
            MappingPairs[PairIndex].CurrentLcn = CurrentLcn;
        }

        CurrentData += l;
        PairIndex ++;
    }

    *NumberOfPairs = PairIndex;

    return( CurrentLength <= BufferSize &&
            *CurrentData == 0 &&
            PairIndex <= MaximumNumberOfPairs );
}


BOOLEAN
NTFS_EXTENT_LIST::CompressMappingPairs(
    IN      PCMAPPING_PAIR  MappingPairs,
    IN      ULONG           NumberOfPairs,
    IN      VCN             StartingVcn,
    IN OUT  PVOID           CompressedPairs,
    IN      ULONG           MaximumCompressedLength,
    OUT     PULONG          CompressedLength
    )
/*++

Notes:

    The returned length includes the terminating NULL count byte.

--*/
{
    PBYTE CurrentData;
    VCN CurrentVcn;
    LCN CurrentLcn;
    ULONG CurrentLength;
    VCN DeltaVcn;
    LCN DeltaLcn;
    ULONG i;
    UCHAR ComDeltaVcn[sizeof(VCN)];
    UCHAR ComDeltaLcn[sizeof(LCN)];
    UCHAR VcnLength;
    UCHAR LcnLength;
    UCHAR Major, Minor;
    BOOLEAN NewSparseFormat;

    // Determine whether to use the old or new format for
    // representing sparse files.
    //
    NTFS_SA::QueryVersionNumber( &Major, &Minor );
    NewSparseFormat = (Major > 1) || (Major == 1 && Minor > 1);

    // A mapping pair is (NextVcn, CurrentLcn); however, the compressed
    // form is a list of deltas.

    CurrentData = (PBYTE)CompressedPairs;
    CurrentVcn = StartingVcn;
    CurrentLcn = 0;
    CurrentLength = 0;

    for( i = 0; i < NumberOfPairs; i++ ) {

        DeltaVcn = MappingPairs[i].NextVcn - CurrentVcn;
        DeltaLcn = MappingPairs[i].CurrentLcn - CurrentLcn;

        DeltaVcn.QueryCompressedInteger(&VcnLength, ComDeltaVcn);

        if( NewSparseFormat && MappingPairs[i].CurrentLcn == LCN_NOT_PRESENT ) {

            LcnLength = 0;
            DeltaLcn = 0;

        } else {

            DeltaLcn.QueryCompressedInteger(&LcnLength, ComDeltaLcn);
        }

        // Fill in the count byte and step over it.

        CurrentLength ++;

        if( CurrentLength > MaximumCompressedLength ) {

            return FALSE;
        }

        *CurrentData = ComputeMappingPairCountByte( VcnLength, LcnLength );
        CurrentData ++;


        // Copy DeltaVcn and advance the pointer

        CurrentLength += VcnLength;

        if( CurrentLength > MaximumCompressedLength ) {

            return FALSE;
        }

        memcpy( CurrentData, ComDeltaVcn, VcnLength );
        CurrentData += VcnLength;


        // Copy DeltaLcn and advance the pointer

        CurrentLength += LcnLength;

        if( CurrentLength > MaximumCompressedLength ) {

            return FALSE;
        }

        memcpy( CurrentData, ComDeltaLcn, LcnLength );
        CurrentData += LcnLength;

        CurrentVcn += DeltaVcn;
        CurrentLcn += DeltaLcn;
    }

    // Terminate the compressed list with a zero count byte

    CurrentLength ++;

    if( CurrentLength > MaximumCompressedLength ) {

        return FALSE;
    }

    *CurrentData = 0;
    CurrentData ++;

    *CompressedLength = CurrentLength;
    return TRUE;
}


LCN
NTFS_EXTENT_LIST::QueryLastLcn(
    ) CONST
/*++

Routine Description:

    This method returns the last LCN associated with this allocation.
    If it cannot determine that LCN, it returns an LCN of zero.

Arguments:

    None.

Return Value:

    The LCN of the last cluster in the extent list (or zero, if
    the list is empty or we can't determine the last cluster).

--*/
{
    LCN TempLcn;

    if( QueryLcnFromVcn( _NextVcn - 1, &TempLcn ) &&
        TempLcn != LCN_NOT_PRESENT ) {

        return TempLcn;

    } else {

        return( 0 );
    }
}



BOOLEAN
NTFS_EXTENT_LIST::DeleteRange(
    IN  VCN     Vcn,
    IN  BIG_INT RunLength
    )
/*++

Routine Description:

    This routine will remove any vcn's in the range specified from
    the extent list.  If this does not exist or exists only partially
    then those parts that exist will be removed.

Arguments:

    Vcn         - Supplies the first Vcn of the range.
    RunLength   - Supplies the length of the range.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FsRtlRemoveLargeMcbEntry(_Mcb,
                             Vcn.GetLargeInteger().QuadPart,
                             RunLength.GetLargeInteger().QuadPart
                             );

    return TRUE;
}



BIG_INT
NTFS_EXTENT_LIST::QueryClustersAllocated(
    ) CONST
/*++

Routine Description:

    This routine computes the number of clusters allocated for this
    attribute.

Arguments:

    None.

Return Value:

    The number of clusters allocated by this attribute.

--*/
{
    ULONG   i;
    VCN     vcn;
    LCN     lcn;
    BIG_INT run_length;
    BIG_INT r;

    r = 0;
    for (i = 0; QueryExtent(i, &vcn, &lcn, &run_length); i++) {

        if (LCN_NOT_PRESENT == lcn) {
            continue;
        }
        r += run_length;
    }

    return r;
}


VOID
NTFS_EXTENT_LIST::SetLowestVcn(
    IN BIG_INT  LowestVcn
    )
/*++

Routine Description:

    This method sets the lowest VCN covered by this extent
    list.  Note that for a sparse file, this is not necessarily
    the same as the VCN of the first extent in the list.

Arguments:

    The lowest VCN mapped by this extent list.  Note that this must
    be less than or equal to the starting VCN of the first entry
    in the list.

Return Value:

    None.

--*/
{
    _LowestVcn = LowestVcn;
}

VOID
NTFS_EXTENT_LIST::SetNextVcn(
    IN BIG_INT NextVcn
    )
/*++

Routine Description:

    This method sets the highest VCN covered by this extent
    list.  Note that for a sparse file, this is not necessarily
    the same as the last VCN of the last extent in the list.

Arguments:

    The highest VCN mapped by this extent list.

Return Value:

    None.

--*/
{
    _NextVcn = NextVcn;
}

UNTFS_EXPORT
ULONG
NTFS_EXTENT_LIST::QueryNumberOfExtents(
    ) CONST
/*++

Routine Description:

    This methods tells the client how many extents are in the
    extent list.

Arguments:

    None.

Return Value:

    The number of extents in the list.

--*/
{
    return FsRtlNumberOfRunsInLargeMcb((PLARGE_MCB)_Mcb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\hackwc.cxx ===
/*++

Copyright (c) 1991	Microsoft Corporation

Module Name:

    hackwc.cxx

Abstract:

    This module contains the definition for a hack that allows me
    to compare attribute names correctly.

    The comparison of attribute names is binary (word by word);
    I can't use WSTRING because it's comparisons are all based
    on the locale, while this comparison is locale-independent.

Author:

	Bill McJohn (billmc) 14-Aug-91

Environment:

	ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "hackwc.hxx"

INT
CountedWCMemCmp(
    IN PCWSTR String1,
    IN ULONG Length1,
    IN PCWSTR String2,
    IN ULONG Length2
    )
/*++

Routine Description:

    This function compares two counted wide-character buffers.
    It compares word-by-word, rather than byte by byte.

Arguments:

    String1 -- supplies the first wide-character buffer
    Length1 -- supplies the number of wide characters in String1
    String2 -- supplies the second wide-character buffer
    Length2 -- supplies the number of wide characters in String2

Return Value:

    a negative value if String1 is less than String2
    zero if String1 equals String2
    a positive value if String1 is greater than String2

--*/
{
    ULONG i;
    LONG res;

    i = ( Length1 < Length2 ) ? Length1 : Length2;

    while( i-- ) {

        if( (res = *String1++ - *String2++) != 0 ) {

            return res;
        }
    }

    return Length1 - Length2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\frs.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

   frs.cxx

Abstract:

   This module contains the member function definitions for the
   NTFS_FILE_RECORD_SEGMENT class.  This class models File
   Record Segments in the NTFS Master File Table; it is the
   object through which a file's attributes may be accessed.



Author:

   Bill McJohn (billmc) 21-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "list.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "cannedsd.hxx"
#include "drive.hxx"
#include "mft.hxx"
#include "mftfile.hxx"
#include "attrrec.hxx"
#include "attrib.hxx"
#include "attrlist.hxx"
#include "frs.hxx"
#include "badfile.hxx"
#include "ntfsbit.hxx"
#include "indxtree.hxx"
#include "rtmsg.h"

#include "hackwc.hxx"
#include "sdchk.hxx"



DEFINE_EXPORTED_CONSTRUCTOR( NTFS_FILE_RECORD_SEGMENT, NTFS_FRS_STRUCTURE, UNTFS_EXPORT );


UNTFS_EXPORT
NTFS_FILE_RECORD_SEGMENT::~NTFS_FILE_RECORD_SEGMENT (
         )
{
    Destroy();
}

VOID
NTFS_FILE_RECORD_SEGMENT::Construct (
   )
/*++

Routine Description:

   Worker method for NTFS_FILE_RECORD_SEGMENT construction.

Arguments:

   None.

Return Value:

   None.

--*/
{
    _Mft = NULL;
    _AttributeList = NULL;
    _ChildIterator = NULL;
}


inline
VOID
NTFS_FILE_RECORD_SEGMENT::Destroy2 (
    )
/*++

Routine Description:

   Worker method for NTFS_FILE_RECORD_SEGMENT partial destruction.

Arguments:

   None.

Return Value:

   None.

--*/
{
    // If the child iterator is not NULL, then the
    // list of children has been initialized.

    if( _ChildIterator != NULL ) {

        DELETE( _ChildIterator );
        _Children.DeleteAllMembers();
    }

    DELETE(_AttributeList);
    _AttributeList = NULL;
}

VOID
NTFS_FILE_RECORD_SEGMENT::Destroy (
   )
/*++

Routine Description:

   Worker method for NTFS_FILE_RECORD_SEGMENT destruction.

Arguments:

   None.

Return Value:

   None.

--*/
{
   _Mft = NULL;

   Destroy2();
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
    IN      VCN                     FileNumber,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
   )
/*++

Routine Description:

   Initialize a File Record Segment object.  Note that this will not
   cause the FRS to be read.

Arguments:

   FileNumber     -- Supplies the FRS's cluster number within the MFT.
    Mft             -- Supplies the volume MasterFile Table.

Return Value:

   TRUE upon successful completion

Notes:

   This class is reinitializable.

--*/
{
   Destroy();

   DebugAssert(Mft);

   _Mft = Mft;

    if( !Mft->GetDataAttribute()    ||
        !_Mem.Initialize()          ||
        !_Children.Initialize()     ||
        (_ChildIterator = _Children.QueryIterator()) == NULL ||
        !NTFS_FRS_STRUCTURE::Initialize(&_Mem,
                                        Mft->GetDataAttribute(),
                                        FileNumber,
                                        Mft->QueryClusterFactor(),
                                        Mft->QueryVolumeSectors(),
                                        Mft->QueryFrsSize(),
                                        Mft->GetUpcaseTable() ) ) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
    IN      VCN                     FirstFileNumber,
    IN      ULONG                   FrsCount,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
   )
/*++

Routine Description:

   Initialize a File Record Segment object.  Note that this will not
   cause the FRS to be read.  This is meant to use together with
   Initialize(), ReadSet(), and ReadNext().

Arguments:

   FirstFileNumber - Supplies the first file number for this FRS block.
   FrsCount        - Supplies the number of FRS'es in this FRS block.
   Mft             - Supplies the volume MasterFile Table.

Return Value:

   TRUE upon successful completion

Notes:

   This class is reinitializable.

--*/
{
   Destroy();

   DebugAssert(Mft);

   _Mft = Mft;

   if( !Mft->GetDataAttribute()    ||
       !_Mem.Initialize()          ||
       !_Children.Initialize()     ||
       (_ChildIterator = _Children.QueryIterator()) == NULL ||
       !NTFS_FRS_STRUCTURE::Initialize(&_Mem,
                                       Mft->GetDataAttribute(),
                                       FirstFileNumber,
                                       FrsCount,
                                       Mft->QueryClusterFactor(),
                                       Mft->QueryVolumeSectors(),
                                       Mft->QueryFrsSize(),
                                       Mft->GetUpcaseTable() ) ) {
       Destroy();
       return FALSE;
   }

   return TRUE;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
   )
/*++

Routine Description:

   Partially initialize a File Record Segment object.  Note that this
   will not cause the FRS to be read.  This is meant to use together
   with SetFrsData() or ReadFrsData().

Arguments:

Return Value:

   TRUE upon successful completion

Notes:

   This class is reinitializable.

--*/
{
    Destroy2();

    if (!_Children.Initialize() ||
        (_ChildIterator = _Children.QueryIterator()) == NULL) {
        Destroy();
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
    IN      VCN                 FileNumber,
    IN OUT  PNTFS_MFT_FILE      MftFile
    )
/*++

Routine Description:

    This routine initializes this class to a valid initial state.

Arguments:

    FileNumber  - Supplies the file number for this FRS.
    MftFile     - Supplies the MFT file.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The upcase-table may be NULL; in this case, attributes with
    names cannot be manipulated until the upcase table is set.

--*/
{
    return Initialize(FileNumber,
                      MftFile->GetMasterFileTable());
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE        Drive,
    IN      LCN                     StartOfMft,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
   )
/*++

Routine Description:

   Initialize a File Record Segment object.  Note that this will not
   cause the FRS to be read.

Arguments:

    Drive           - Supplies the drive object.
    StartOfMft      - Supplies the starting cluster for the MFT.
    Mft             - Supplies the master file table.

Return Value:

   TRUE upon successful completion

Notes:

   This class is reinitializable.

--*/
{
    Destroy();

    DebugAssert(Mft);

    _Mft = Mft;
    _AttributeList = NULL;

    return _Children.Initialize() &&
           (_ChildIterator = _Children.QueryIterator()) != NULL &&
           _Mem.Initialize() &&
           NTFS_FRS_STRUCTURE::Initialize(&_Mem,
                                          Drive,
                                          StartOfMft,
                                          Mft->QueryClusterFactor(),
                                          Mft->QueryVolumeSectors(),
                                          Mft->QueryFrsSize(),
                                          Mft->GetUpcaseTable());
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Create (
    IN USHORT   Flags
   )
/*++

Routine Description:

   Create   (i.e. Format) a file record segment.  This is a private
   worker method which is called by the other Create methods.  It
   creates a File Record Segment which has no attribute records.

Arguments:

    Flags   --  Supplies the FILE_xxx flags which should be set in this
                File Record Set.  (Note that FILE_RECORD_SEGMENT_IN_USE
                will also be set, whether or not is is specified.)

Return value:

   TRUE upon successful completion.

--*/
{
    PATTRIBUTE_TYPE_CODE FirstAttribute;

    DebugPtrAssert( _FrsData );

    memset( _FrsData, 0, (UINT) QuerySize() );

    _FrsData->Lsn.LowPart = 0;
    _FrsData->Lsn.HighPart = 0;

    _FrsData->SequenceNumber = (USHORT) max(QueryFileNumber().GetLowPart(),1);
    _FrsData->ReferenceCount = 0;
    _FrsData->Flags = FILE_RECORD_SEGMENT_IN_USE | Flags;
    _FrsData->BytesAvailable = QuerySize();
    _FrsData->NextAttributeInstance = 0;

    memset( &_FrsData->BaseFileRecordSegment,
            0,
            sizeof(MFT_SEGMENT_REFERENCE) );


    // Write the 'FILE' signature in the MultiSectorHeader.

    memcpy( _FrsData->MultiSectorHeader.Signature,
            "FILE",
            4 );


    // Compute the number of Update Sequence Numbers in the
    // update array.  This number is (see ntos\inc\cache.h):
    //
    //      n/SEQUENCE_NUMBER_STRIDE + 1
    //
    // where n is the number of bytes in the protected structure
    // (in this case, a cluster).

    _FrsData->MultiSectorHeader.UpdateSequenceArraySize =
            (USHORT)(QuerySize()/SEQUENCE_NUMBER_STRIDE + 1);

    // The update sequence array starts at the field
    // UpdateArrayForCreateOnly.  (In other words, create locates
    // it using this field, all other methods locate it using
    // the offset that Create computes.)
    //
    _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset =
        FIELD_OFFSET( FILE_RECORD_SEGMENT_HEADER,
                      UpdateArrayForCreateOnly );

    _FrsData->FirstAttributeOffset =
      QuadAlign( _FrsData->MultiSectorHeader.UpdateSequenceArrayOffset +
                   _FrsData->MultiSectorHeader.UpdateSequenceArraySize *
                        sizeof( UPDATE_SEQUENCE_NUMBER ) );

    _FrsData->SegmentNumberHighPart = (USHORT)QueryFileNumber().GetHighPart();
    _FrsData->SegmentNumberLowPart = QueryFileNumber().GetLowPart();

    // Make sure that the offset of the first attribute is in range:
    //
    if( _FrsData->FirstAttributeOffset + sizeof(ULONG) > QuerySize() ) {

        return FALSE;
    }

    // Put an END attribute at the first-attribute offset.  (Note
    // that this attribute doesn't have an attribute header, it just
    // consists of an Attribute Type Code of $END.)
    //
    FirstAttribute = (PATTRIBUTE_TYPE_CODE)
                     ((PBYTE)_FrsData +
                      _FrsData->FirstAttributeOffset);

    *FirstAttribute = $END;

    // The first free byte comes after the END attribute, which
    // consists of a single ATTRIBUTE_TYPE_CODE.
    //
    _FrsData->FirstFreeByte = _FrsData->FirstAttributeOffset +
                                QuadAlign( sizeof( ATTRIBUTE_TYPE_CODE ) );

    return TRUE;
}



UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Create (
    IN  PCSTANDARD_INFORMATION  StandardInformation,
    IN  USHORT                  Flags
   )
/*++

Routine Description:

   Create   (i.e. Format) a base file record segment.  The base
   file record segment is the primary FRS for a file; it contains
   any resident attributes (and hence any indexed attributes) of the
   file and the External Attributes List, if any.

   Note that Create will not cause the FRS to be written, only to
   be formatted in memory.

Arguments:

   StandardInformation --  supplies the standard information for the
                     file record segment.
    Flags               --  Supplies the FILE_xxx flags which should
                            be set in this File Record Set.  (Note
                            that FILE_RECORD_SEGMENT_IN_USE will also
                            be set, whether or not is is specified.)


Return value:

   TRUE upon successful completion.

--*/
{
   NTFS_ATTRIBUTE StandardInfoAttribute;

    DebugPtrAssert( _FrsData );

    if( Create( Flags ) &&
      StandardInfoAttribute.Initialize( GetDrive(),
                                          QueryClusterFactor(),
                                          StandardInformation,
                                sizeof( STANDARD_INFORMATION ),
                                $STANDARD_INFORMATION ) &&
        StandardInfoAttribute.InsertIntoFile( this, NULL ) ) {

        return TRUE;

   } else {

        return FALSE;
    }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Create (
    IN PCMFT_SEGMENT_REFERENCE  BaseSegment,
    IN USHORT                   Flags
   )
/*++

Routine Description:

   Create (i.e. Format) a secondary file record segment.  A secondary
   file record segment contains external attributes; it is referenced
   in the file's External Attributes List, which is in the file's
   base file record segment.

Arguments:

    BaseSegment         --  supplies a reference to the base file
                     record segment for this file.
    Flags               --  Supplies the FILE_xxx flags which should
                            be set in this File Record Set.  (Note
                            that FILE_RECORD_SEGMENT_IN_USE will also
                            be set, whether or not is is specified.)

Return value:

   TRUE upon successful completion.

--*/
{
   DebugPtrAssert( _FrsData );

    if( Create( Flags ) ) {

        memcpy( &_FrsData->BaseFileRecordSegment,
                BaseSegment,
                sizeof(MFT_SEGMENT_REFERENCE) );

      return TRUE;

   } else {

      return FALSE;
   }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::CreateSystemFile(
    IN UCHAR    major,
    IN UCHAR    minor
    )
/*++

Routine Description:

    This method creates a new base frs with a STANDARD_INFORMATION and
    a FILE_NAME attribute.  The standard info attribute will be
    set to the current time.

    This function looks up the correct file name base on this FRS's
    file number.

    This function will not succeed unless this FRS is a system file.

    This function does not update the root index or write to the frs.

Arguments:

    major   - the major revision number for the volume
    minor   - the minor revsion number for the volume

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    STANDARD_INFORMATION        standard_info;
    PFILE_NAME                  file_name;
    UCHAR                       name_length;
    ULONG                       buffer_length;
    NTFS_FILE_RECORD_SEGMENT    root_dir;
    DSTRING                     file_name_text;
    NTFS_INDEX_TREE             root_index;
    DSTRING                     index_name;
    BOOLEAN                     no_file_name;
    MFT_SEGMENT_REFERENCE       root_ref;
    BOOLEAN                     this_is_root;


    // Figure out the correct file name for this.

    if (!GetSystemFileName(major,
                           QueryFileNumber(),
                           &file_name_text,
                           &no_file_name))
        return FALSE;

    this_is_root = (QueryFileNumber() == ROOT_FILE_NAME_INDEX_NUMBER);

    // Create a standard info structure.

    memset(&standard_info, 0, sizeof(STANDARD_INFORMATION));

    IFS_SYSTEM::QueryNtfsTime(&standard_info.CreationTime);

    standard_info.LastModificationTime =
    standard_info.LastChangeTime =
    standard_info.LastAccessTime = standard_info.CreationTime;

    standard_info.FileAttributes = FAT_DIRENT_ATTR_HIDDEN |
                                   FAT_DIRENT_ATTR_SYSTEM;

    if (!Create(&standard_info)) {
        return FALSE;
    }

    if (!no_file_name) {

        // Figure out the segment reference for the root index.

        if (this_is_root) {
            root_ref = QuerySegmentReference();
        } else {

            if (!root_dir.Initialize(ROOT_FILE_NAME_INDEX_NUMBER,
                                     _Mft) ||
                !root_dir.Read()) {

                return FALSE;
            }

            root_ref = root_dir.QuerySegmentReference();
        }


        // Allocate a buffer of sufficient length for the FILE_NAME struct.

        name_length = (UCHAR) file_name_text.QueryChCount();

        buffer_length = FIELD_OFFSET(FILE_NAME, FileName) +
                        name_length*sizeof(WCHAR);

        if (!(file_name = (PFILE_NAME) MALLOC(buffer_length))) {
            return FALSE;
        }
        memset(file_name, 0, buffer_length);


        // Initialize the FILE_NAME structure and add it to this FRS.

        file_name->ParentDirectory = root_ref;
        file_name->FileNameLength = name_length;
        file_name->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
        file_name_text.QueryWSTR(0,
                                 TO_END,
                                 file_name->FileName,
                                 name_length,
                                 FALSE);

        if (!AddFileNameAttribute(file_name)) {

            FREE(file_name);
            return FALSE;
        }

        // Set the ref count back to zero because this guy doesn't yet
        // exist in the root directory.

        SetReferenceCount(0);

        FREE(file_name);
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::CreateExtendSystemFile(
    PCWSTRING   file_name_text,
    IN USHORT   FrsFlags,
    IN ULONG    FileAttributes
    )
/*++

Routine Description:

    This method creates a new base frs with a STANDARD_INFORMATION and
    a FILE_NAME attribute.  The standard info attribute will be
    set to the current time.   The parent of this frs is \$Extend.

    This function does not update the root index or write to the frs.

Arguments:

    file_name_text
            --  Supplies the file name.
    Flags   --  Supplies the FILE_xxx flags which should be set in this
                File Record Set.  (Note that FILE_RECORD_SEGMENT_IN_USE
                will also be set, whether or not is is specified.)
    FileAttributes
            --  Supplies the FILE_xxx flags which should be set in the
                standard information of this file record segment.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    STANDARD_INFORMATION        standard_info;
    PFILE_NAME                  file_name;
    UCHAR                       name_length;
    ULONG                       buffer_length;
    NTFS_FILE_RECORD_SEGMENT    root_dir;
    NTFS_INDEX_TREE             root_index;
    DSTRING                     index_name;
    BOOLEAN                     no_file_name;
    MFT_SEGMENT_REFERENCE       root_ref;

    // Check file name

    no_file_name = (!file_name_text || file_name_text->QueryChCount() == 0);

    // Create a standard info structure.

    memset(&standard_info, 0, sizeof(STANDARD_INFORMATION));

    IFS_SYSTEM::QueryNtfsTime(&standard_info.CreationTime);

    standard_info.LastModificationTime =
    standard_info.LastChangeTime =
    standard_info.LastAccessTime = standard_info.CreationTime;

    standard_info.FileAttributes = FAT_DIRENT_ATTR_HIDDEN |
                                   FAT_DIRENT_ATTR_SYSTEM |
                                   FAT_DIRENT_ATTR_ARCHIVE |
                                   FileAttributes;

    if (!Create(&standard_info, FrsFlags)) {
        return FALSE;
    }

    if (!no_file_name) {

        // Figure out the segment reference for the root index.

        if (!root_dir.Initialize(EXTEND_TABLE_NUMBER, _Mft) ||
            !root_dir.Read()) {

            return FALSE;
        }

        root_ref = root_dir.QuerySegmentReference();

        // Allocate a buffer of sufficient length for the FILE_NAME struct.

        name_length = (UCHAR) file_name_text->QueryChCount();

        buffer_length = FIELD_OFFSET(FILE_NAME, FileName) +
                        name_length*sizeof(WCHAR);

        if (!(file_name = (PFILE_NAME) MALLOC(buffer_length))) {
            return FALSE;
        }
        memset(file_name, 0, buffer_length);


        // Initialize the FILE_NAME structure and add it to this FRS.

        file_name->ParentDirectory = root_ref;
        file_name->FileNameLength = name_length;
        file_name->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
        file_name_text->QueryWSTR(0,
                                  TO_END,
                                  file_name->FileName,
                                  name_length,
                                  FALSE);

        if (!AddFileNameAttribute(file_name)) {

            FREE(file_name);
            return FALSE;
        }

        // Set the ref count back to zero because this guy doesn't yet
        // exist in the root directory.

        SetReferenceCount(0);

        FREE(file_name);
    }

    return TRUE;
}


NONVIRTUAL
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::VerifyAndFixFileNames(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN      PCNTFS_CHKDSK_INFO  ChkdskInfo,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message,
    IN OUT  PBOOLEAN            DiskErrorsFound,
    IN      BOOLEAN             FixDupInfo,
    IN      BOOLEAN             ClearSystemFlags
    )
/*++

Routine Description:

    This routine ensures that the duplicate information in the
    file name attributes is correct.  It otherwise corrects
    these entries and outputs a message.

    This method will also make sure that for every NTFS
    file name there is a corresponding FAT file name with
    the same parent pointer and that for every FAT file
    name there is a corresponding NTFS file name with the
    same parent pointer.

Arguments:

    CurrentDirectory    - Supplies the directory to which this
                            file belongs.
    VolumeBitmap        - Supplies the volume bitmap.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have been
                            found.
    FixDupInfo          - Supplies whether or not to fix incorrect
                            duplicated information.
    ClearSystemFlags    - Supplies whether or not to clear the
                            FILE_VIEW_INDEX_PRESENT and
                            DUP_VIEW_INDEX_PRESENT flags

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE          attribute;
    DSTRING                 index_name;
    ULONG                   i;
    BOOLEAN                 error;
    DUPLICATED_INFORMATION  actual_info;
    PFILE_NAME              pfile_name;
    PFILE_NAME              pntfs_name;
    PFILE_NAME              pdos_name;
    ULONG                   num_bytes;
    BOOLEAN                 index_present;
    MFT_SEGMENT_REFERENCE   parent_for_dos_name;
    BOOLEAN                 ntfs_name_encountered;
    BOOLEAN                 dos_name_encountered;
    BOOLEAN                 flags_mod;
    BOOLEAN                 merge_flags;
    BOOLEAN                 success;
    HMEM                    hmem;
    ULONG                   value_length, cluster_size;
    PINDEX_ROOT             index_root;
    PSTANDARD_INFORMATION2  standard_info2;
    BOOLEAN                 frs_needs_flushing;
    BOOLEAN                 file_is_sparse;
    BOOLEAN                 file_is_encrypted;
    ULONG                   bytesWritten;
    UCHAR                   file_name_buffer[sizeof(FILE_NAME)+sizeof(WCHAR)*254];   // FileNameLength <= 255 characters

    // First check the validity of the FILE_FILE_NAME_INDEX_PRESENT bit.

    if (!index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    error = FALSE;
    index_present = QueryAttribute(&attribute, &error, $INDEX_ROOT,
                                   &index_name);


    // Make sure that if the $INDEX_ROOT is present then
    // that it is also valid enough so that it won't be tubed.

    if (index_present) {

        value_length = attribute.QueryValueLength().GetLowPart();

        if (error || !hmem.Acquire(value_length)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!attribute.Read(hmem.GetBuf(), 0, value_length, &num_bytes) ||
            num_bytes != value_length ||
            value_length < sizeof(INDEX_ROOT) ||
            !(index_root = (PINDEX_ROOT) hmem.GetBuf()) ||
            index_root->IndexHeader.FirstIndexEntry < sizeof(INDEX_HEADER)) {

            index_present = FALSE;
        }

        // If our cluster size is greater than the index buffer size,
        // the ClustersPerIndexBuffer in the index root should reflect
        // a 512-byte block size.
        //

        if (index_present) {

            ULONG cluster_size = QueryClusterFactor() * GetDrive()->QuerySectorSize();

            if (index_root->BytesPerIndexBuffer < cluster_size &&
                ULONG(index_root->ClustersPerIndexBuffer * NTFS_INDEX_BLOCK_SIZE) !=
                    index_root->BytesPerIndexBuffer) {

                DebugPrintTrace(("VerifyAndFixFileNames: %x %x %x\n",
                    index_root->BytesPerIndexBuffer, index_root->ClustersPerIndexBuffer,
                    cluster_size));

                index_present = FALSE;
            }
        }
    }

    if (ClearSystemFlags) {
        ClearViewIndexPresent();

        if (DiskErrorsFound) {
            *DiskErrorsFound = TRUE;
        }

        if (FixLevel != CheckOnly && !Flush(VolumeBitmap)) {
            DebugAbort("Can't write it out");
            return FALSE;
        }
    }


    if ((IsIndexPresent() && !index_present) ||
        (!IsIndexPresent() && index_present)) {

        MSGID   msgid;

        index_present ? SetIndexPresent() : ClearIndexPresent();

        if (index_present)
            msgid = MSG_CHKLOG_NTFS_MISSING_FILE_NAME_INDEX_PRESENT_BIT;
        else
            msgid = MSG_CHKLOG_NTFS_INCORRECT_INDEX_PRESENT_BIT;
        Message->LogMsg(msgid, "%I64x", QueryFileNumber().GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                         "%d", QueryFileNumber().GetLowPart());

        if (DiskErrorsFound) {
            *DiskErrorsFound = TRUE;
        }

        if (FixLevel != CheckOnly && !Flush(VolumeBitmap)) {
            DebugAbort("Can't write it out");
            return FALSE;
        }
    }

    if (ChkdskInfo->major >= 2) {
        file_is_sparse = FALSE;
        file_is_encrypted = FALSE;
        frs_needs_flushing = FALSE;
        for (i = 0; QueryAttributeByOrdinal(&attribute,
                                            &error,
                                            $DATA,
                                            i); i++) {

            if (attribute.QueryFlags() & ATTRIBUTE_FLAG_SPARSE) {
                file_is_sparse = TRUE;
            }
            if (attribute.QueryFlags() & ATTRIBUTE_FLAG_ENCRYPTED) {
                if (attribute.IsResident()) {
                    attribute.SetFlags(attribute.QueryFlags() &
                                       ~ATTRIBUTE_FLAG_ENCRYPTED);

                    Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_ENCRYPTED_FLAG,
                                    "%I64x", QueryFileNumber().GetLargeInteger());

                    if (ChkdskInfo->Verbose) {
                        Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE,
                                         "%d", QueryFileNumber().GetLowPart());
                    }
                    if (FixLevel != CheckOnly &&
                        !attribute.InsertIntoFile(this, VolumeBitmap)) {
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                         "%d%d", attribute.QueryTypeCode(),
                                         QueryFileNumber().GetLowPart());
                        return FALSE;
                    }
                    frs_needs_flushing = TRUE;
                } else {
                    file_is_encrypted = TRUE;
                }
            }
        }
        if (frs_needs_flushing && FixLevel != CheckOnly) {
            if (!Flush(VolumeBitmap)) {
                DebugAbort("Can't flush out changes");
                return FALSE;
            }
        }

        if (!QueryAttribute(&attribute, &error, $STANDARD_INFORMATION)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        //
        // It could be a small STANDARD_INFORMATION but it makes no difference
        // as we are only altering FileAttributes.
        //
        if (!(standard_info2 = (PSTANDARD_INFORMATION2)attribute.GetResidentValue())) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs_needs_flushing = FALSE;
        if (file_is_sparse) {
            if (!(standard_info2->FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE)) {
                standard_info2->FileAttributes |= FILE_ATTRIBUTE_SPARSE_FILE;

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_SPARSE_FLAG_IN_STD_INFO,
                             "%I64x", QueryFileNumber().GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_SPARSE_FILE,
                                 "%d", QueryFileNumber().GetLowPart());
                frs_needs_flushing = TRUE;
            }
        } else {
            //
            // do this quietly
            //
            if (standard_info2->FileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) {
                standard_info2->FileAttributes &= ~FILE_ATTRIBUTE_SPARSE_FILE;

                Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_SPARSE_FLAG,
                                "%I64x", QueryFileNumber().GetLargeInteger());

                if (ChkdskInfo->Verbose) {
                    Message->DisplayMsg(MSG_CHK_NTFS_SPARSE_FILE,
                                     "%d", QueryFileNumber().GetLowPart());
                }
                frs_needs_flushing = TRUE;
            }
        }

        if (standard_info2->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED_OLD) {

            // clear the old bit and turn on the new bit

            standard_info2->FileAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED_OLD;
            standard_info2->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;

            Message->LogMsg(MSG_CHKLOG_NTFS_REPLACING_OLD_ENCRYPTED_FLAG_WITH_NEW_ONE_IN_STD_INFO,
                         "%I64x", QueryFileNumber().GetLargeInteger());

            Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE,
                             "%d", QueryFileNumber().GetLowPart());
            frs_needs_flushing = TRUE;
        }

        if (file_is_encrypted) {
            if (!(standard_info2->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                standard_info2->FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_ENCRYPTED_FLAG_IN_STD_INFO,
                             "%I64x", QueryFileNumber().GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_ENCRYPTED_FILE,
                                 "%d", QueryFileNumber().GetLowPart());
                frs_needs_flushing = TRUE;
            }
        }   // don't clear the encryption bit even the file is not encrypted


        if (!ChkdskInfo->FilesWithReparsePoint.IsFree(QueryFileNumber(), 1)) {
            if (!(standard_info2->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_REPARSE_POINT_FLAG_IN_STD_INFO,
                             "%I64x", QueryFileNumber().GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_REPARSE_POINT,
                                 "%d", QueryFileNumber());
                standard_info2->FileAttributes |= FILE_ATTRIBUTE_REPARSE_POINT;
                frs_needs_flushing = TRUE;
            }
        } else {
            if (standard_info2->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

                Message->LogMsg(MSG_CHKLOG_NTFS_REPARSE_POINT_FLAG_SET_IN_STD_INFO,
                             "%I64x", QueryFileNumber().GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_REPARSE_POINT,
                                 "%d", QueryFileNumber());
                standard_info2->FileAttributes &= ~FILE_ATTRIBUTE_REPARSE_POINT;
                frs_needs_flushing = TRUE;
            }
        }

        if (ClearSystemFlags) {
            standard_info2->FileAttributes &= ~DUP_VIEW_INDEX_PRESENT;
            frs_needs_flushing = TRUE;
        }

        DebugAssert(attribute.QueryValueLength().GetHighPart() == 0);

        if (frs_needs_flushing && FixLevel != CheckOnly) {
            if (!attribute.Write(standard_info2,
                                 0,
                                 attribute.QueryValueLength().GetLowPart(),
                                 &bytesWritten,
                                 VolumeBitmap) ||
                bytesWritten != attribute.QueryValueLength().GetLowPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                 "%d%d", attribute.QueryTypeCode(),
                                 QueryFileNumber().GetLowPart());
                return FALSE;
            }
            if (attribute.IsStorageModified() &&
                !attribute.InsertIntoFile(this, VolumeBitmap)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                 "%d%d", attribute.QueryTypeCode(),
                                 QueryFileNumber().GetLowPart());
                return FALSE;
            }
            if (!Flush(VolumeBitmap)) {
                DebugAbort("Can't flush out changes");
                return FALSE;
            }
        }
        if (DiskErrorsFound)
            *DiskErrorsFound = *DiskErrorsFound || frs_needs_flushing;
    }

    if (FixDupInfo)
        if (!QueryDuplicatedInformation(&actual_info)) {
            DebugAbort("Cannot get duplicated information");
            return FALSE;
        }

    // Now go through the file name attributes and make sure that
    // they have the correct duplicated information.  Also insure
    // consistency of DOS and NTFS bits set.

    dos_name_encountered = FALSE;
    ntfs_name_encountered = FALSE;
    flags_mod = merge_flags = FALSE;
    pdos_name = pntfs_name = NULL;

    for (i = 0; QueryAttributeByOrdinal(&attribute,
                                        &error,
                                        $FILE_NAME,
                                        i);) {

        pfile_name = (PFILE_NAME) attribute.GetResidentValue();

        if (!pfile_name) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }


        if (FixDupInfo) {

            // Validate the duplicate information.

            if (memcmp(&pfile_name->Info, &actual_info,
                       sizeof(DUPLICATED_INFORMATION))) {

// No need to be verbal about this fix, since the duplicate information
// in the file name attribute is not maintained by the file system.

#if 0
                Message->DisplayMsg(MSG_CHK_NTFS_INACCURATE_DUPLICATED_INFORMATION,
                                 "%d", QueryFileNumber().GetLowPart());
#endif

                if (!UpdateFileNames(&actual_info, NULL, FALSE)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (DiskErrorsFound) {
                    *DiskErrorsFound = TRUE;
                }

                if (FixLevel != CheckOnly && !Flush(VolumeBitmap)) {
                    DebugAbort("Can't flush out changes");
                    return FALSE;
                }

                i = 0;
                continue;
            }
        }


        // Make sure there's only one NTFS name and that it's in the
        // same directory as the corresponding DOS name.

        if (pfile_name->Flags & FILE_NAME_NTFS) {

            if (ntfs_name_encountered) {

                Message->LogMsg(MSG_CHKLOG_NTFS_NTFS_FILE_NAME_ALREADY_ENCOUNTERED,
                             "%I64x", QueryFileNumber().GetLargeInteger());
                flags_mod = TRUE;
            } else {
                ntfs_name_encountered = TRUE;
                if (dos_name_encountered) {
                    if (!(parent_for_dos_name == pfile_name->ParentDirectory)) {
                        Message->LogMsg(MSG_CHKLOG_NTFS_DOS_NTFS_NAMES_HAVE_DIFFERENT_PARENTS,
                                     "%I64x%I64x%I64x",
                                     parent_for_dos_name,
                                     pfile_name->ParentDirectory,
                                     QueryFileNumber().GetLargeInteger());
                        flags_mod = TRUE;
                    }

                    //
                    // Make sure the ntfs name is not the same as the dos name
                    //
                    merge_flags = !flags_mod &&
                                  pdos_name &&
                                  (NtfsUpcaseCompare(NtfsFileNameGetName(pdos_name),
                                                     pdos_name->FileNameLength,
                                                     NtfsFileNameGetName(pfile_name),
                                                     pfile_name->FileNameLength,
                                                     GetUpcaseTable(),
                                                     FALSE) == 0);
                } else {
                    parent_for_dos_name = pfile_name->ParentDirectory;
                    if (!flags_mod &&
                        !(pfile_name->Flags & FILE_NAME_DOS) &&
                        NTFS_SA::IsDosName(pfile_name)) {
                        pntfs_name = (PFILE_NAME)file_name_buffer;
                        memcpy(pntfs_name, pfile_name, attribute.QueryValueLength().GetLowPart());
                    } else
                        pntfs_name = NULL;
                }
            }
        }


        // Make sure there's only one DOS name and that it's in the
        // same directory as the corresponding NTFS name.

        if (pfile_name->Flags & FILE_NAME_DOS) {

            if (dos_name_encountered || !NTFS_SA::IsDosName(pfile_name)) {

                if (dos_name_encountered) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_DOS_FILE_NAME_ALREADY_ENCOUNTERED,
                                 "%I64x", QueryFileNumber().GetLargeInteger());
                } else {
                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_INCORRECT_DOS_NAME);
                    Message->Log("%I64x", QueryFileNumber().GetLargeInteger());
                    Message->DumpDataToLog(NtfsFileNameGetName(pfile_name),
                                           sizeof(WCHAR)*pfile_name->FileNameLength);
                    Message->Unlock();
                }
                flags_mod = TRUE;
            } else {
                dos_name_encountered = TRUE;

                if (ntfs_name_encountered) {
                    if (!(parent_for_dos_name == pfile_name->ParentDirectory)) {
                        Message->LogMsg(MSG_CHKLOG_NTFS_DOS_NTFS_NAMES_HAVE_DIFFERENT_PARENTS,
                                     "%I64x%I64x%I64x",
                                     parent_for_dos_name,
                                     pfile_name->ParentDirectory,
                                     QueryFileNumber().GetLargeInteger());
                        flags_mod = TRUE;
                    }

                    //
                    // Make sure the dos name is not the same as the ntfs name
                    //
                    merge_flags = !flags_mod &&
                                  pntfs_name &&
                                  !(pfile_name->Flags & FILE_NAME_NTFS) &&
                                  (NtfsUpcaseCompare(NtfsFileNameGetName(pntfs_name),
                                                     pntfs_name->FileNameLength,
                                                     NtfsFileNameGetName(pfile_name),
                                                     pfile_name->FileNameLength,
                                                     GetUpcaseTable(),
                                                     FALSE) == 0);
                } else {
                    parent_for_dos_name = pfile_name->ParentDirectory;
                    if (!flags_mod &&
                        !(pfile_name->Flags & FILE_NAME_NTFS)) {
                        pdos_name = (PFILE_NAME)file_name_buffer;
                        memcpy(pdos_name, pfile_name, attribute.QueryValueLength().GetLowPart());
                    } else
                        pdos_name = NULL;
                }
            }
        }
        i++;
    }


    // Make sure DOS name iff NTFS name.

    if (dos_name_encountered && !ntfs_name_encountered ||
        !dos_name_encountered && ntfs_name_encountered) {

        MSGID   msgid;

        if (dos_name_encountered)
            msgid = MSG_CHKLOG_NTFS_MISSING_NTFS_NAME;
        else
            msgid = MSG_CHKLOG_NTFS_MISSING_DOS_NAME;
        Message->LogMsg(msgid, "%I64x", QueryFileNumber().GetLargeInteger());

        flags_mod = TRUE;
    }


    if (flags_mod) {

        merge_flags = FALSE;

        // There were some flags errors so clear all the flags.

        for (i = 0; QueryAttributeByOrdinal(&attribute,
                                            &error,
                                            $FILE_NAME,
                                            i);) {

            pfile_name = (PFILE_NAME) attribute.GetResidentValue();

            if (pfile_name->Flags & FILE_NAME_DOS ||
                pfile_name->Flags & FILE_NAME_NTFS) {

                DeleteResidentAttribute($FILE_NAME, NULL, pfile_name,
                        attribute.QueryValueLength().GetLowPart(), &success);

                // Clear the flags.

                pfile_name->Flags &= ~(FILE_NAME_DOS | FILE_NAME_NTFS);

                if (!attribute.InsertIntoFile(this, VolumeBitmap)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                i = 0;
                continue;
            }

            i++;
        }
    }

    if (merge_flags) {

        Message->LogMsg(MSG_CHKLOG_NTFS_DOS_NTFS_NAMES_ARE_IDENTICAL,
                     "%I64x", QueryFileNumber().GetLargeInteger());
        //
        // Combine the short and long names into one as both
        // are 8.3 names different in case at the most
        //
        for (i = 0; QueryAttributeByOrdinal(&attribute,
                                            &error,
                                            $FILE_NAME,
                                            i);) {

            pfile_name = (PFILE_NAME) attribute.GetResidentValue();

            if (pfile_name->Flags & FILE_NAME_DOS &&
                !(pfile_name->Flags & FILE_NAME_NTFS)) {

                DeleteResidentAttribute($FILE_NAME, NULL, pfile_name,
                        attribute.QueryValueLength().GetLowPart(), &success);
                i = 0;
                continue;
            }
            if (pfile_name->Flags & FILE_NAME_NTFS &&
                !(pfile_name->Flags & FILE_NAME_DOS)) {

                DeleteResidentAttribute($FILE_NAME, NULL, pfile_name,
                        attribute.QueryValueLength().GetLowPart(), &success);

                // Set the DOS flag as well

                pfile_name->Flags |= FILE_NAME_DOS;

                if (!attribute.InsertIntoFile(this, VolumeBitmap)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                i = 0;
                continue;   // may not have encountered the dos name yet
            }
            i++;
        }
    }


    // Commit any flag changes to disk.

    if (flags_mod || merge_flags) {

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_FILE_NAME_ERRORS,
                         "%d", QueryFileNumber().GetLowPart());

        if (FixLevel != CheckOnly && !Flush(VolumeBitmap)) {
            DebugAbort("Can't flush out changes");
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddDataAttribute(
    IN     ULONG        InitialSize,
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN     BOOLEAN      Fill,
    IN     CHAR         FillCharacter
    )
/*++

Routine Description:

    This method adds a nonresident data attribute to the File Record Segment.

Arguments:

    InitialSize     --  Supplies the number of bytes to allocate for
                        the data attribute.
    VolumeBitmap    --  Supplies the volume bitmap.
    Fill            --  Supplies a flag which, if TRUE, indicates that
                        the value of the attribute should be set to
                        the supplied fill character.
    FillCharacter   --  Supplies a fill character.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE   DataAttribute;
    NTFS_EXTENT_LIST Extents;

    // Initialize the data attribute [type is $DATA, no name] with an
    // empty extent list, and then resize it to the desired size.

    if( !Extents.Initialize( 0, 0 ) ||
        !DataAttribute.Initialize( GetDrive(),
                                   QueryClusterFactor(),
                                   &Extents,
                                   0,
                                   0,
                                   $DATA,
                                   NULL ) ||
        !DataAttribute.Resize( InitialSize, VolumeBitmap ) ) {

        return FALSE;
    }

    if( Fill &&
        !DataAttribute.Fill( 0, FillCharacter ) ) {

        return FALSE;
    }

    // Insert the data attribute into this File Record Segment.  If that
    // operation fails, we need to free up the space allocated by
    // resizing the attribute back to zero.

    if( !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        DataAttribute.Resize( 0, VolumeBitmap );
        return FALSE;
    }

    return TRUE;
}



UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddFileNameAttribute(
    IN PFILE_NAME   FileName
    )
/*++

Routine Description:

    This method adds a File Name attribute to the File Record Segment.
    Note that it assumes that the File Name is indexed.

Arguments:

    FileName    --  Supplies the value of the File Name attribute, which
                    is a FILE_NAME structure.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE FileNameAttribute;

    // Initialize a file-name attribute and insert it into this FRS.

    if( FileNameAttribute.Initialize( GetDrive(),
                                      QueryClusterFactor(),
                                      FileName,
                                      NtfsFileNameGetLength( FileName ),
                                      $FILE_NAME ) ) {

        FileNameAttribute.SetIsIndexed();

        return( FileNameAttribute.InsertIntoFile( this, NULL ) );

    } else {

        return FALSE;
    }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddAttribute(
    IN ATTRIBUTE_TYPE_CODE  Type,
    IN PCWSTRING            Name,
    IN PCVOID               Value,
    IN ULONG                Length,
    IN OUT PNTFS_BITMAP     Bitmap,
    IN BOOLEAN              IsIndexed
    )
/*++

Routine Description:

    This method adds an attribute of the specified type to the file.

Arguments:

    Type        --  Supplies the type of the attribute.
    Name        --  Supplies the name of the attribute--may be NULL,
                    which is interpreted as no name.
    Value       --  Supplies a pointer to the attribute's value.  May
                    be NULL if the attribute value length is zero.
    Length      --  Supplies the length of the attribute value.
    Bitmap      --  Supplies the volume bitmap.  May be NULL,
                    in which case the attribute cannot be made
                    nonresident.
    IsIndexed   --  Supplies a flag which indicates whether the
                    attribute is indexed.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE Attribute;

    // Initialize a resident attribute with the desired
    // characteristics.  If it is to be indexed, mark
    // it as such.
    //
    if( !Attribute.Initialize( GetDrive(),
                               QueryClusterFactor(),
                               Value,
                               Length,
                               Type,
                               Name ) ) {

        return FALSE;
    }

    if( IsIndexed ) {

        Attribute.SetIsIndexed();
    }

    // Insert the attribute into the file.  If it cannot be inserted
    // as a resident attribute, make it non-resident and try again.
    //
    if( Attribute.InsertIntoFile( this, NULL ) ) {

        // Success!
        //
        return TRUE;
    }

    // Couldn't insert it as a resident attribute; if it isn't
    // indexed, make it nonresident and try again.  Note that
    // we can't make it nonresident if the client did not provide
    // a bitmap, and that indexed attributes cannot be made
    // nonresident.
    //
    if( !IsIndexed &&
        Bitmap != NULL &&
        Attribute.MakeNonresident( Bitmap ) &&
        Attribute.InsertIntoFile( this, Bitmap ) ) {

        // Second time lucky.
        //
        return TRUE;
    }

    // Can't insert this attribute into this FRS.  If the attribute
    // is nonresident, truncate it to zero length to free up the
    // space allocated to it.
    //
    if( !Attribute.IsResident() ) {

        DebugPtrAssert( Bitmap );
        Attribute.Resize( 0, Bitmap );
    }

    // return failure.
    //
    return FALSE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddSecurityDescriptor(
    IN     CANNED_SECURITY_TYPE SecurityType,
    IN OUT PNTFS_BITMAP         Bitmap
    )
/*++

Routine Description:

    This method adds a security descriptor, chosen from the
    canned security descriptors, to the file.

Arguments:

    SecurityType    --  Identifies the sort of security descriptor
                        to add.
    Bitmap          --  Supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

--*/
{
    PCANNED_SECURITY CannedSecurity;
    PVOID SecurityDescriptor;
    ULONG SdLength;

#if defined( _SETUP_LOADER_ )

    // Security descriptors are not supported under the
    // setup loader.
    //
    return TRUE;

#else

    if( (CannedSecurity = IFS_SYSTEM::GetCannedSecurity()) == NULL ||
        (SecurityDescriptor =
            CannedSecurity->GetCannedSecurityDescriptor( SecurityType,
                                                         &SdLength ))
            == NULL ) {

        DebugPrint( "UNTFS: Canned security is not available.\n" );
        return FALSE;
    }

    return( AddAttribute( $SECURITY_DESCRIPTOR,
                          NULL,
                          SecurityDescriptor,
                          SdLength,
                          Bitmap ) );

#endif // _SETUP_LOADER_

}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddSecurityDescriptorData(
    IN     PNTFS_ATTRIBUTE      Attribute,
    IN OUT PVOID                Buffer,
    OUT    PSECURITY_ENTRY      *SecurityEntry,
    IN     ULONG                SecurityId,
    IN     CANNED_SECURITY_TYPE SecurityType,
    IN OUT PNTFS_BITMAP         Bitmap,
    IN     BOOLEAN              FixLevel
    )
/*++

Routine Description:

    This method adds a default security descriptor entry to the
    end of the security descriptor data stream.  This routine assumes
    that the security descriptor data stream has been checked out
    or corrected.

    A flush of the frs is required to commit changes onto disk.

Arguments:

    Attribute       --  supplies the attribute.
    Buffer          --  work buffer of SecurityDescriptorsBlockSize.
    SecurityEntry   --  returns a pointer into the working buffer where the
                        security entry lies.
    SecurityId      --  supplies the security id.
    SecurityType    --  Identifies the sort of security descriptor to add.
    Bitmap          --  Supplies the volume bitmap.
    FixLevel        --  Supplies a flag which, if equals to CheckOnly, indicates
                        that this method should not actually modify the
                        security descriptor data stream on disk.

Return Value:

    TRUE upon successful completion.

--*/
{
    PCANNED_SECURITY cannedSecurity;
    PVOID   securityDescriptor;
    ULONG   sdLength;
    ULONG   num_bytes = 0;
    ULONG   bytesWritten;
    ULONG   length, length1, length2, offset, pad1_size;

    SECURITY_DESCRIPTOR_HEADER  sdh;

#if defined( _SETUP_LOADER_ )

    // Security descriptors are not supported under the
    // setup loader.
    //
    return TRUE;

#else

    if( (cannedSecurity = IFS_SYSTEM::GetCannedSecurity()) == NULL ||
        (securityDescriptor =
            cannedSecurity->GetCannedSecurityDescriptor( SecurityType,
                                                         &sdLength ))
            == NULL ) {

        DebugPrint( "UNTFS: Canned security is not available.\n" );
        return FALSE;
    }

    length = Attribute->QueryValueLength().GetLowPart();
    if (length < SecurityDescriptorsBlockSize) {

        // this should not occur if the data stream has been checked

        if (FixLevel != CheckOnly)  // if stream has been corrected
            return FALSE;           // then we got bad news

        // If in read-only mode, then fake the length and continue

        length = SecurityDescriptorsBlockSize;
    }

    length -= SecurityDescriptorsBlockSize;
    offset = length & ~(SecurityDescriptorsBlockSize-1);

    length1 = length & (SecurityDescriptorsBlockSize-1);
    pad1_size = ((length1 + 0xf) & ~0xf) - length1;

    length2 = sizeof(SECURITY_DESCRIPTOR_HEADER)+sdLength;

    sdh.Length = length2;
    sdh.HashKey.SecurityId = SecurityId;
    sdh.HashKey.Hash = ComputeSecurityDescriptorHash(securityDescriptor,
                                                     sdLength);

    if (length1 + pad1_size + length2 <= SecurityDescriptorsBlockSize) {
        // everything fits into the current block
        memset(Buffer, 0, pad1_size);
        sdh.Offset = length + pad1_size;
        *SecurityEntry = (PSECURITY_ENTRY)((PCHAR)Buffer+pad1_size);
        memcpy((PVOID)*SecurityEntry,
               &sdh,
               sizeof(SECURITY_DESCRIPTOR_HEADER));
        memcpy(&((*SecurityEntry)->security),
               securityDescriptor,
               sdLength);
        offset += length1;
        length = pad1_size + length2;
    } else if (length1 + pad1_size +
               sizeof(SECURITY_DESCRIPTOR_HEADER) <=
               SecurityDescriptorsBlockSize) {
        // add End of Block marker then
        // goto next block and add the security descriptor
        memset(Buffer, 0, pad1_size);
        MarkEndOfSecurityDescriptorsBlock(
            (PSECURITY_ENTRY)((PCHAR)Buffer+pad1_size),
            SecurityDescriptorsBlockSize - length1 - pad1_size);
        length = SecurityDescriptorsBlockSize - length1;
        if (FixLevel != CheckOnly &&
            (!Attribute->Write(Buffer,
                               length1,
                               length,
                               &bytesWritten,
                               Bitmap) ||
             bytesWritten != length)) {
            return FALSE;
        }
        offset += (SecurityDescriptorsBlockSize<<1);
        sdh.Offset = offset;
        *SecurityEntry = (PSECURITY_ENTRY)Buffer;
        memcpy(*SecurityEntry, &sdh, sizeof(SECURITY_DESCRIPTOR_HEADER));
        memcpy(&((*SecurityEntry)->security),
               securityDescriptor,
               sdLength);
        length = length2;
    } else if ((length1 == SecurityDescriptorsBlockSize) ||
               (length1 + pad1_size == SecurityDescriptorsBlockSize)) {
        // goto next block and add the security descriptor
        offset += (SecurityDescriptorsBlockSize<<1);
        sdh.Offset = offset;
        *SecurityEntry = (PSECURITY_ENTRY)Buffer;
        memcpy(*SecurityEntry, &sdh, sizeof(SECURITY_DESCRIPTOR_HEADER));
        memcpy(&((*SecurityEntry)->security),
               securityDescriptor,
               sdLength);
        length = length2;
    } else {
        // move the last security descriptor to the beginning
        // of next block then append the new security descriptor
        *SecurityEntry = NULL;
        DebugAssert(FALSE);
        return FALSE;
    }

    if (FixLevel != CheckOnly &&
        (!Attribute->Write(Buffer,
                           offset,
                           length,
                           &bytesWritten,
                           Bitmap) ||
         bytesWritten != length ||
         !Attribute->Write(Buffer,
                           offset + SecurityDescriptorsBlockSize,
                           length,
                           &bytesWritten,
                           Bitmap) ||
         bytesWritten != length)) {
         return FALSE;
    }
    if (FixLevel != CheckOnly && Attribute->IsStorageModified() &&
        !Attribute->InsertIntoFile(this, Bitmap)) {
        return FALSE;
    }

    return TRUE;

#endif // _SETUP_LOADER_

}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::IsAttributePresent (
   IN  ATTRIBUTE_TYPE_CODE Type,
   IN  PCWSTRING           Name,
   IN  BOOLEAN             IgnoreExternal
   )
/*++

Routine Description:

   This function determines whether a specified attribute is present
   in the attributes associated with the File Record Segment.

Arguments:

   Type         -- supplies the type code of the attribute in question.
   Name         -- supplies the name of the attribute in question.
                  (may be NULL, in which case the attribute has no name.)
   IgnoreExternal -- supplies a flag indicating that the FRS should
               not look for external attributes.

Return Value:

   TRUE if the File Record Segment has an attribute which matches
   the type (and name, if given).

Notes:

   This method assumes that the file record segment is consistent,
   and that it has been read.

   Note that we can determine what attribute records are present,
   and whether they are unique, without reading the child FRS's,
   since the information we need is in the Attribute List.

   The NoExternal flag is provided mainly to allow us to check for
   the presence of the ATTRIBUTES_LIST attribute without falling
   into infinite recursion.

--*/
{
   ULONG CurrentRecordOffset;
   NTFS_ATTRIBUTE_RECORD CurrentRecord;
   NTFS_ATTRIBUTE AttributeList;
   BOOLEAN Found = FALSE;

    DebugPtrAssert( _FrsData );

    if( !IgnoreExternal &&
        Type != $ATTRIBUTE_LIST &&
        (_AttributeList != NULL ||
         IsAttributePresent( $ATTRIBUTE_LIST, NULL, TRUE )) ) {

      // This File Record Segment has an ATTRIBUTE_LIST attribute,
      // and the caller wants to include external attributes, so
      // we can traverse that list.

        if( !SetupAttributeList() ) {

            return FALSE;
        }

        return( _AttributeList->IsInList( Type, Name ) );

    } else {

      // Either the caller has asked us to ignore external
        // attributes or there is no ATTRIBUTE_LIST attribute,
        // or we're looking for the attribute list itself,
      // so we'll go through the list of attribute records
      // in this File Record Segment.

      CurrentRecordOffset = _FrsData->FirstAttributeOffset;

      while( CurrentRecordOffset < QuerySize() &&
             CurrentRecord.Initialize( GetDrive(),
                                       (PBYTE)_FrsData + CurrentRecordOffset,
                                       QuerySize() - CurrentRecordOffset ) &&
             CurrentRecord.QueryTypeCode() != $END ) {

         if( CurrentRecord.IsMatch( Type, Name ) ) {

                Found = TRUE;
                break;
         }

            // If this record has a zero length, then this FRS
            // is corrupt.  Otherwise, just go on to the next
            // attribute record.
            //
            if( CurrentRecord.QueryRecordLength() == 0 ) {
                Found = FALSE;
                break;
            }

         CurrentRecordOffset += CurrentRecord.QueryRecordLength();
      }
   }

   return Found;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttribute (
    OUT PNTFS_ATTRIBUTE     Attribute,
    OUT PBOOLEAN            Error,
   IN  ATTRIBUTE_TYPE_CODE  Type,
   IN  PCWSTRING            Name
   )
/*++

Routine Description:

   This function fetches an attribute associated with the
   File Record Segment.

   This method cannot be used to fetch the ATTRIBUTE_LIST attribute.

Arguments:

    Attribute   --  Receives (ie. is initialized to) the attribute.  Note
                    that this parameter may be uninitialized on entry, and
                    may be left uninitialized if this method fails.
    Error       --  Receives TRUE if the method fails because of an error.
    Type        --  Supplies the type of the desired attribute
    Name        --  Supplies the name of the desired attribute (NULL if
                    the attribute has no name).

Return Value:

    TRUE upon successful completion.

Notes:

    If the method returns TRUE, *Error should be ignored.  If it
    returns FALSE, *Error will be set to TRUE if the failure resulted
    from an error (out of memory, corrupt structure); otherwise, the
    caller may assume that the attribute is not present.

    This method will check both internal and external attributes,
   reading child File Record Segments as necessary to access their
   attribute records.

--*/
{
    MFT_SEGMENT_REFERENCE   SegmentReference;
    NTFS_ATTRIBUTE_RECORD   Record;
    PNTFS_FILE_RECORD_SEGMENT ChildFrs = NULL;
    VCN                     TargetFileNumber;
    ULONG                   Index;
    ATTRIBUTE_TYPE_CODE     FetchType;
    VCN                     LowestVcn;
    DSTRING                 FetchName;
    USHORT                  Instance;
    PNTFS_EXTENT_LIST       backup_extent_list = NULL;

    DebugPtrAssert( Attribute );
    DebugPtrAssert( Error );

    DebugPtrAssert( _FrsData );

    // Assume innocent until proven guilty:

    *Error = FALSE;

   // This method cannot be used to fetch the ATTRIBUTE_LIST
   // attribute.

   if( Type == $ATTRIBUTE_LIST ) {

        *Error = TRUE;
        return FALSE;
   }

    if( !IsAttributePresent( Type, Name, FALSE ) ) {

      // there is no matching attribute.

        return FALSE;
    }

    // Now that we've determined that the attribute is present,
    // this method can only fail because of an error.

    *Error = TRUE;


    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        return FALSE;
    }


    // Get the TargetFileNumber.

    if ( _AttributeList ) {

        if (!_AttributeList->QueryExternalReference( Type,
                                                     &SegmentReference,
                                                     &Index,
                                                     Name )) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    if (Name) {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                 "%x%W%I64x",
                                 Type,
                                 Name,
                                 QueryFileNumber().GetLargeInteger());
                    } else {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                 "%x%I64x",
                                 Type,
                                 QueryFileNumber().GetLargeInteger());
                    }
                }
            }

            return FALSE;
        }

        // We've found the first entry in the Attribute List
        // for this attribute.  We'll use that entry to
        // initialize the attribute object.  But first,
        // we have to find it...

        TargetFileNumber.Set( SegmentReference.LowPart,
                              (LONG) SegmentReference.HighPart );

    } else {

        TargetFileNumber = QueryFileNumber();
    }


    // Get the first attribute record.

    if ( TargetFileNumber == QueryFileNumber() ) {

        if (!QueryAttributeRecord(&Record, Type, Name)) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    if (Name) {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                 "%x%W%I64x",
                                 Type,
                                 Name,
                                 QueryFileNumber().GetLargeInteger());
                    } else {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                 "%x%I64x",
                                 Type,
                                 QueryFileNumber().GetLargeInteger());
                    }
                }
            }

            return FALSE;
        }

    } else {

        // The record we want is in a child record segment.
        // Fetch the child.  (Note that SetupChild will construct
        // an FRS for the child and read it, if it's not already
        // in the list of children.)

        if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_CHILD_FRS,
                             "%I64x%I64x",
                             QueryFileNumber().GetLargeInteger(),
                             TargetFileNumber.GetLargeInteger());
                }
            }

            return FALSE;
        }

        if (!ChildFrs->QueryAttributeRecord(&Record, Type, Name)) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    if (Name) {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                 "%x%W%I64x",
                                 Type,
                                 Name,
                                 ChildFrs->QueryFileNumber().GetLargeInteger());
                    } else {

                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                 "%x%I64x",
                                 Type,
                                 ChildFrs->QueryFileNumber().GetLargeInteger());
                    }
                }
            }

            return FALSE;
        }
    }


    // Initialize the Attribute with the first attribute record.

    if ( !Attribute->Initialize( GetDrive(),
                                 QueryClusterFactor(),
                                 &Record) ) {
        return FALSE;
    }

    if( Attribute->IsResident() ) {

        // A resident attribute can only have one attribute record;
        // since we've found it, we can return now.
        //
        *Error = FALSE;
        return TRUE;
    }

    // Add any other attribute records to the attribute.


    if (_AttributeList) {

        ATTR_LIST_CURR_ENTRY    Entry;
        ULONG                   i = 0;

        Entry.CurrentEntry = NULL;
        while (_AttributeList->QueryNextEntry(&Entry,
                                              &FetchType,
                                              &LowestVcn,
                                              &SegmentReference,
                                              &Instance,
                                              &FetchName)) {
            if (i++ == Index) {
                while (_AttributeList->QueryNextEntry(&Entry,
                                                      &FetchType,
                                                      &LowestVcn,
                                                      &SegmentReference,
                                                      &Instance,
                                                      &FetchName) &&
                       FetchType == Type &&
                       ((!Name && !FetchName.QueryChCount()) ||
                        (Name && !Name->Strcmp(&FetchName)))) {

                    TargetFileNumber.Set( SegmentReference.LowPart,
                                          (LONG) SegmentReference.HighPart );

                    // Get attribute record from file record segment.

                    if ( TargetFileNumber == QueryFileNumber() ) {

                        if (!QueryAttributeRecord(&Record, Type, Name)) {

                            DELETE(backup_extent_list);

                            PIO_DP_DRIVE    drive = GetDrive();

                            if (drive) {
                                PMESSAGE msg = drive->GetMessage();

                                if (msg) {
                                    if (Name) {

                                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                             "%x%W%I64x",
                                             Type,
                                             Name,
                                             QueryFileNumber().GetLargeInteger());
                                    } else {

                                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                             "%x%I64x",
                                             Type,
                                             QueryFileNumber().GetLargeInteger());
                                    }
                                }
                            }

                            return FALSE;
                        }

                    } else {

                        // The record we want is in a child record segment.
                        // Fetch the child.  (Note that SetupChild will construct
                        // an FRS for the child and read it, if it's not already
                        // in the list of children.)
                        //
                        if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ) {

                            DELETE(backup_extent_list);

                            PIO_DP_DRIVE    drive = GetDrive();

                            if (drive) {
                                PMESSAGE msg = drive->GetMessage();

                                if (msg) {
                                    msg->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_CHILD_FRS,
                                             "%I64x%I64x",
                                             QueryFileNumber().GetLargeInteger(),
                                             TargetFileNumber.GetLargeInteger());
                                }
                            }
                            return FALSE;

                        }

                        if (!ChildFrs->QueryAttributeRecord(&Record, Type, Name)) {

                            DELETE(backup_extent_list);

                            PIO_DP_DRIVE    drive = GetDrive();

                            if (drive) {
                                PMESSAGE msg = drive->GetMessage();

                                if (msg) {
                                    if (Name) {

                                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR,
                                                 "%x%W%I64x",
                                                 Type,
                                                 Name,
                                                 QueryFileNumber().GetLargeInteger());
                                    } else {

                                        msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_ATTR,
                                                 "%x%I64x",
                                                 Type,
                                                 QueryFileNumber().GetLargeInteger());
                                    }
                                }
                            }

                            return FALSE;
                        }
                    }


                    // Add attribute record to attribute.

                    if (!Attribute->AddAttributeRecord(&Record, &backup_extent_list)) {

                        DELETE(backup_extent_list);
                        DebugAbort("Couldn't do an Add attribute record.");
                        return FALSE;
                    }
                }
                break;
            }
        }
    }

    *Error = FALSE;
    DELETE(backup_extent_list);
    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryFileSizes (
    OUT PBIG_INT            AllocatedLength,
    OUT PBIG_INT            FileSize,
    OUT PBOOLEAN            Error
   )
/*++

Routine Description:

   This function fetches the allocated length and file size of a
   file associated with a base File Record Segment.

Arguments:

    AllocatedLength -- receives the allocated length of the file.
    FileSize        -- receives the valid length of the file.
    Error           -- receives TRUE if the method fails because of an error.

Return Value:

    TRUE upon successful completion.

Notes:

    If the method returns TRUE, *Error should be ignored.  If it
    returns FALSE, *Error will be set to TRUE if the failure resulted
    from an error (out of memory, corrupt structure); otherwise, the
    caller may assume that the attribute is not present.

    This method will check both internal and external attributes,
   reading child File Record Segments as necessary to access their
   attribute records.

    Please note that the file size and allocated length of the file
   is entire in the base frs or the first child frs.  There is no
   need to read in all the child frs in order to compute the desired
   values.

--*/
{
    NTFS_ATTRIBUTE Attribute;
    ULONG ClusterSize;
    BIG_INT TotalAllocated;
    MFT_SEGMENT_REFERENCE SegmentReference;
    NTFS_ATTRIBUTE_RECORD Record;
    PNTFS_FILE_RECORD_SEGMENT ChildFrs = NULL;
    VCN TargetFileNumber;
    ULONG Index;
    ATTRIBUTE_TYPE_CODE FetchType;
    VCN LowestVcn;
    DSTRING FetchName;
    USHORT Instance;

    DebugPtrAssert( Error );

    DebugPtrAssert( _FrsData );

    // Assume innocent until proven guilty:

    *Error = FALSE;

    // This method cannot be used to fetch the ATTRIBUTE_LIST
    // attribute.

    if( !IsAttributePresent( $DATA, NULL, FALSE ) ) {

        // there is no matching attribute.

        return FALSE;
    }

    // Now that we've determined that the attribute is present,
    // this method can only fail because of an error.

    *Error = TRUE;


    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        return FALSE;
    }


    // Get the TargetFileNumber.

    if ( _AttributeList ) {

        if (!_AttributeList->QueryExternalReference( $DATA,
                                                     &SegmentReference,
                                                     &Index,
                                                     NULL )) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_DATA_ATTR,
                             "%I64x", QueryFileNumber().GetLargeInteger());
                }
            }

            return FALSE;
        }

        // We've found the first entry in the Attribute List
        // for this attribute.  We'll use that entry to
        // initialize the attribute object.  But first,
        // we have to find it...

        TargetFileNumber.Set( SegmentReference.LowPart,
                              (LONG) SegmentReference.HighPart );

    } else {

        TargetFileNumber = QueryFileNumber();
    }


    // Get the first attribute record.

    if ( TargetFileNumber == QueryFileNumber() ) {

        if (!QueryAttributeRecord(&Record, $DATA, NULL)) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_DATA_ATTR,
                             "%I64x", QueryFileNumber().GetLargeInteger());
                }
            }

            return FALSE;
        }

    } else {

        // The record we want is in a child record segment.
        // Fetch the child.  (Note that SetupChild will construct
        // an FRS for the child and read it, if it's not already
        // in the list of children.)

        if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_CHILD_FRS,
                             "%I64x%I64x",
                             QueryFileNumber().GetLargeInteger(),
                             TargetFileNumber.GetLargeInteger());
                }
            }

            return FALSE;
        }

        if (!ChildFrs->QueryAttributeRecord(&Record, $DATA, NULL)) {

            PIO_DP_DRIVE    drive = GetDrive();

            if (drive) {
                PMESSAGE msg = drive->GetMessage();

                if (msg) {
                    msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_UNNAMED_DATA_ATTR,
                             "%I64x", QueryFileNumber().GetLargeInteger());
                }
            }

            return FALSE;
        }
    }

    Record.QueryValueLength(FileSize,
                            AllocatedLength,
                            NULL,
                            &TotalAllocated);

    // for uncompressed file, the total allocated length does
    // not exist

    if (Record.IsResident()) {

        *AllocatedLength = QuadAlign(AllocatedLength->GetLowPart());

    } else if((Record.QueryFlags() & (ATTRIBUTE_FLAG_COMPRESSION_MASK |
                                      ATTRIBUTE_FLAG_SPARSE))) {

        // for compressed file, the allocated length is the
        // total allocated length
        *AllocatedLength = TotalAllocated;

    }

    *Error = FALSE;
    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryResidentAttribute (
    OUT PNTFS_ATTRIBUTE     Attribute,
    OUT PBOOLEAN            Error,
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCVOID              Value,
    IN  ULONG               ValueLength,
    IN  COLLATION_RULE      CollationRule
    )
/*++

Routine Description:

    This method fetches a resident attribute associated with
    the File Record Segment based on attribute type code and
    attribute value.

    Note that it does not distinguish between attributes which
    have the same type code but different names; its primary use
    it to fetch indexable attributes, which are by convention
    do not have names.

Arguments:

    Attribute       --  Receives (ie. is initialized to) the attribute.
                        Note that this parameter may be uninitialized on
                        entry, and may be left uninitialized if this
                        method fails.
    Error           --  Receives TRUE if the method fails because of
                        an error (corrupt FRS or out of memory).
    Type            --  Supplies the type of the desired attribute
    Value           --  Supplies a pointer to the value to match.
    ValueLength     --  Supplies the length of the value to be matched.
    CollationRule   --  Supplies the collation rule to use for comparison.
                        The first attribute found whose value matches
                        the supplied value according to this collation
                        rule will be returned.

Return Value:

    TRUE if a matching attribute is found.

Notes:

    If this method succeeds, *Error should be ignored.

    If this method fails because of error, *Error will be set to
    TRUE.  If this method returns FALSE and *Error is FALSE, the
    client may assume that this File Record Segment has no
    matching attributes.

--*/
{
    ULONG AttributeValueLength, i;
    BOOLEAN Found;

   // This method cannot be used to fetch the ATTRIBUTE_LIST
   // attribute.

   if( Type == $ATTRIBUTE_LIST ) {

        *Error = TRUE;
        return FALSE;
   }

    // If the attribute list is present, force it into memory.

    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        *Error = TRUE;
        return FALSE;
    }

    // Iterate through all the attributes with this type code
    // until we run out or find a match.  Start by resetting *Error
    // to FALSE--if QueryAttributeByOrdinal encounters an error,
    // it will set *Error for us.

    *Error = FALSE;
    Found = FALSE;
    i = 0;

    while( !Found &&
           QueryAttributeByOrdinal( Attribute, Error, Type, i ) ) {

        DebugAssert( !Attribute->IsResident() ||
                   Attribute->GetResidentValue() != NULL );

        // If the attribute is resident and the value is the right
        // length, compare its value with the search value.
        //
        AttributeValueLength = Attribute->QueryValueLength().GetLowPart();

        if( Attribute->IsResident() &&
            AttributeValueLength == ValueLength &&
            NtfsCollate( Attribute->GetResidentValue(),
                         AttributeValueLength,
                         Value,
                         ValueLength,
                         CollationRule,
                         GetUpcaseTable() ) == 0 ) {

            if( CollationRule == COLLATION_FILE_NAME ) {

                // NOTE: for FILE_NAME comparison, we also have to
                // check that the parent pointer in the attribute
                // we found is the same as the search value, to ensure
                // that we are returning the name associated with the
                // appropriate index.
                //
                if( (((PFILE_NAME)
                      (Attribute->GetResidentValue()))->ParentDirectory ==
                     ((PFILE_NAME)Value)->ParentDirectory ) &&
                    (((PFILE_NAME)
                      (Attribute->GetResidentValue()))->Flags ==
                     ((PFILE_NAME)Value)->Flags)
                  ){

                    Found = TRUE;
                }

            } else {

                // This attribute is a match.  Return it to the client.
                //
                Found = TRUE;
            }
        }

        i++;
    }

    return Found;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttributeByOrdinal (
    OUT PNTFS_ATTRIBUTE     Attribute,
    OUT PBOOLEAN            Error,
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  ULONG               Ordinal
    )
/*++

Routine Description:

    This method returns the n-th attribute of the specified
    type.  Note that it ignores attribute names (but, of course,
    the client can query the name of the returned attribute from
    that attribute).

Arguments:

    Attribute   --  Receives (ie. is initialized to) the attribute.  Note
                    that this parameter may be uninitialized on entry, and
                    may be left uninitialized if this method fails.
    Error       --  Receives TRUE if the method fails because of an error.
    Type        --  Supplies the type of the desired attribute
    Ordinal     --  Supplies the (zero-based) ordinal number of the
                    attribute to return.

Return Value:

    TRUE upon successful completion.

    If this method succeeds, the client should ignore *Error.

    If this method fails because of error, *Error will be set; if
    this method returns FALSE and *Error is FALSE, the client may
    assume that there is no such matching attribute.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference, NextSegmentReference;
    DSTRING Name;
    VCN LowestVcn;
    VCN TargetFileNumber;
    ATTRIBUTE_TYPE_CODE CurrentType;

    PVOID CurrentRecordData;
    PNTFS_FILE_RECORD_SEGMENT TargetFrs = NULL;

    USHORT InstanceTag, NextInstanceTag;


    DebugPtrAssert( Attribute );
    DebugPtrAssert( Error );

    // If the attribute list is present, force it into memory.
    //
    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        *Error = TRUE;
        return FALSE;
    }


    if( _AttributeList != NULL ) {

        ATTR_LIST_CURR_ENTRY    Entry;

        // Spin through the attribute list until we find the nth
        // entry with the requested type and a LowestVcn of zero.
        //
        Entry.CurrentEntry = NULL;
        while( TRUE ) {

            if( !_AttributeList->QueryNextEntry( &Entry,
                                                 &CurrentType,
                                                 &LowestVcn,
                                                 &SegmentReference,
                                                 &InstanceTag,
                                                 &Name ) ) {

                // Out of entries in the attribute list, so there
                // is no matching attribute type.

                *Error = FALSE;
                return FALSE;
            }

            if( CurrentType == Type && LowestVcn == 0 ) {

                // This entry has the desired type code;  check
                // to see if we want to skip it or grab it.
                //
                if( Ordinal == 0 ) {

                    // Found the entry we want.
                    //
                    break;

                } else {

                    // Skip this one.
                    //
                    Ordinal--;
                }
            }
        }

        // Now we have an entry for the attribute we want.  If there's
        // only one entry for this attribute, we can initialize an
        // attribute with that record and return; if there are multiple
        //
        // If the next entry does not have a LowestVcn of zero, it
        // is another entry for this attribute.  Note that we need
        // SegmentReference and Instance tag for later use.
        //

        if( _AttributeList->QueryNextEntry( &Entry,
                                            &CurrentType,
                                            &LowestVcn,
                                            &NextSegmentReference,
                                            &NextInstanceTag,
                                            &Name ) &&
            CurrentType == Type &&
            LowestVcn != 0 ) {

            // This is a multi-record attribute, which means it is
            // uniquely identified by Type and Name.
            //
            return( QueryAttribute( Attribute,
                                    Error,
                                    Type,
                                    &Name ) );

        } else {

            // There are no more entries for this attribute,
            // so we can initialize an the attribute with
            // this record.  We'll let QueryAttributeByTag
            // do the work for us.
            //
            TargetFileNumber.Set( SegmentReference.LowPart,
                                  (LONG) SegmentReference.HighPart );

            if( TargetFileNumber == QueryFileNumber() ) {

                // The record is in this FRS.
                //
                TargetFrs = this;

            } else {

                // The record we want is in a child FRS; get that
                // child and squeeze the attribute out of it.
                //
                if( (TargetFrs = SetupChild( TargetFileNumber)) == NULL ) {

                    // Something is wrong--we can't get the child.
                    //
                    PIO_DP_DRIVE    drive = GetDrive();

                    if (drive) {
                        PMESSAGE msg = drive->GetMessage();

                        if (msg) {
                            msg->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_CHILD_FRS,
                                     "%I64x%I64x",
                                     QueryFileNumber().GetLargeInteger(),
                                     TargetFileNumber.GetLargeInteger());
                        }
                    }

                    *Error = TRUE;
                    return FALSE;
                }
            }


            if( !TargetFrs->QueryAttributeByTag( Attribute,
                                                 Error,
                                                 InstanceTag ) ) {

                // We know the attribute is there, but we can't
                // get it.
                //
                *Error = TRUE;
                return FALSE;

            } else {

                return TRUE;
            }
        }

    } else {

        // This File Record Segment does not have an attribute list,
        // so we only have to grope through this FRS.

        // First, skip over attribute records with a type-code
        // less than the one we're looking for:

        CurrentRecordData = NULL;
        *Error = FALSE;

        do {

            if( (CurrentRecordData =
                  GetNextAttributeRecord( CurrentRecordData,
                                          NULL,
                                          Error )) == NULL ||
                *Error ) {

                // No more, or an error was found.
                return FALSE;
            }

            if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

                *Error = TRUE;
                return FALSE;
            }

        } while( CurrentRecord.QueryTypeCode() != $END &&
                 CurrentRecord.QueryTypeCode() < Type );

        if( CurrentRecord.QueryTypeCode() == $END ||
            CurrentRecord.QueryTypeCode() > Type ) {

            // There are no attributes of the specified type in
            // this FRS.  Note that *Error has already been set
            // to FALSE.

            return FALSE;
        }

        // Now step through the attributes of this type code to
        // find the one we want.

        while( Ordinal != 0 ) {

            // In determining the ordinal of an attribute, we only
            // count attribute records which are resident or have
            // a LowestVcn of zero.

            if( CurrentRecord.IsResident() ||
                CurrentRecord.QueryLowestVcn() == 0 ) {

                Ordinal--;
            }

            if( (CurrentRecordData =
                 GetNextAttributeRecord( CurrentRecordData,
                                         NULL,
                                         Error )) == NULL ||
                *Error ) {

                // No more, or an error was found.
                return FALSE;
            }

            if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

                *Error = TRUE;
                return FALSE;
            }

            if( CurrentRecord.QueryTypeCode() == $END ||
                CurrentRecord.QueryTypeCode() > Type ) {

                // Ran out of matching records.

                return FALSE;
            }
        }

        // We've found our baby.  Initialize the attribute and return.

        if( CurrentRecord.IsResident() ) {

            // Since this attribute record is resident, it is
            // the only attribute record for this attribute, and
            // so it suffices to initialize the attribute with
            // this record.

            if( Attribute->Initialize( GetDrive(),
                                       QueryClusterFactor(),
                                       &CurrentRecord ) ) {

                // Everything is just fine.

                return TRUE;

            } else {

                // Foiled at the last minute by some dastardly error.

                *Error = TRUE;
                return FALSE;
            }

        } else {

            // Since there may be other attribute records associated
            // with this attribute, we have to invoke QueryAttribute
            // to do our work for us.  Get the name from the attribute
            // record, and then query this FRS for the attribute with
            // the requested type and that name.

            if( !CurrentRecord.QueryName( &Name ) ) {

                *Error = TRUE;
                return FALSE;
            }

            return( QueryAttribute( Attribute,
                                    Error,
                                    Type,
                                    &Name ) );
        }

    }
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttributeByTag (
    OUT PNTFS_ATTRIBUTE     Attribute,
    OUT PBOOLEAN            Error,
    IN  ULONG               Tag
    )
/*++

Routine Description:

    This method initializes an attribute based on the single attribute
    record with the specified instance tag.  Note that it only examines
    records in this File Record Segment; it does not look at child FRS's.

Arguments:

    Attribute   --  Receives (ie. is initialized to) the attribute
                    in question.  Note that this parameter may be
                    uninitialized on entry, and may be left in that
                    state if this method fails.
    Error       --  Receives TRUE if the method fails because of
                    an error.
    Tag         --  Supplies the attribute record instance tag of
                    the desired record.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    PVOID CurrentRecordData = NULL;
    BOOLEAN Found = FALSE;


    while( !Found ) {

        CurrentRecordData = GetNextAttributeRecord( CurrentRecordData );

        if( CurrentRecordData == NULL ) {

            // No more records.
            //
            *Error = FALSE;
            return FALSE;
        }

        if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

            // Error initializing object.
            //
            *Error = TRUE;
            return FALSE;
        }

        if( CurrentRecord.QueryInstanceTag() == Tag ) {

            Found = TRUE;
        }
    }

    if( !Attribute->Initialize( GetDrive(),
                                QueryClusterFactor(),
                                &CurrentRecord ) ) {

        *Error = TRUE;
        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::PurgeAttribute (
   IN  ATTRIBUTE_TYPE_CODE Type,
   IN  PCWSTRING           Name,
    IN  BOOLEAN             IgnoreExternal
   )
/*++

Routine Description:

   This method removes all attribute records for the given attribute
   type and name from the File Record Segment and its children.

Arguments:

   Type  -- supplies the type of the attribute to purge
   Name  -- supplies the name of the attribute to purge (NULL if
            the attribute has no name).
    IgnoreExternal -- supplies a flag that, if TRUE, indicates we
                      should ignore the attribute list and only delete
                      matching records found in this File Record Segment

Return Value:

   TRUE upon successful completion.

--*/
{
   NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference;
    PNTFS_FILE_RECORD_SEGMENT ChildFrs;
    VCN TargetFileNumber;
    ULONG EntryIndex;
   ULONG CurrentRecordOffset;
   ULONG NextRecordOffset;

   if( !IgnoreExternal &&
        Type != $ATTRIBUTE_LIST &&
        (_AttributeList != NULL ||
       IsAttributePresent($ATTRIBUTE_LIST, NULL, TRUE) ) ) {

        // This File Record Segment has an attribute list, so
        // we should consult it.

        if( !SetupAttributeList() ) {

            return FALSE;
        }


        while( _AttributeList->QueryExternalReference( Type,
                                                       &SegmentReference,
                                                       &EntryIndex,
                                                       Name ) ) {

            TargetFileNumber.Set( SegmentReference.LowPart,
                                (LONG) SegmentReference.HighPart );

            if( TargetFileNumber == QueryFileNumber() ) {

                // The record we want to delete is in this File
                // Record Segment.  The easiest way to get at it
                // is to recurse back into this function with
                // IgnoreExternal equal to TRUE (which prevents
                // further recursion).

                PurgeAttribute( Type, Name, TRUE );

            } else {

                // The record we want to delete is in a child record
                // segment.  Note that SetupChild will construct and
                // read a new FRS if the child isn't already in the list.

                if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ) {

                    return FALSE;
                }

                // Now we've got the child; purge any matching attributes
                // from it.  (It's OK if we purge more than one; we'll
                // catch up on later iterations.)

                if( !ChildFrs->PurgeAttribute( Type, Name ) ) {

                    return FALSE;
                }
            }

            _AttributeList->DeleteEntry( EntryIndex );
        }

   } else {

      // Either there is no Attribute List, or we're deleting
      // the Attribute List itself, or we've been instructed to
        // ignore it, so we can just go through this File Record
        // Segment and blow away any matching records we find.

        CurrentRecordOffset = _FrsData->FirstAttributeOffset;

      while( CurrentRecordOffset < QuerySize() &&
             CurrentRecord.Initialize( GetDrive(),
                                       (PBYTE)_FrsData + CurrentRecordOffset,
                                       QuerySize() - CurrentRecordOffset ) &&
              CurrentRecord.QueryTypeCode() != $END ) {

            if( CurrentRecord.QueryRecordLength() == 0 ) {

                return FALSE;
            }

         if( CurrentRecord.IsMatch( Type, Name ) ) {

            // This record matches, so away it goes!

            NextRecordOffset =CurrentRecordOffset +
                           CurrentRecord.QueryRecordLength();

            DebugAssert( NextRecordOffset < QuerySize() );

                _FrsData->FirstFreeByte -= CurrentRecord.QueryRecordLength();

            memmove( (PBYTE)_FrsData + CurrentRecordOffset,
                   (PBYTE)_FrsData + NextRecordOffset,
                   (UINT) (QuerySize() - NextRecordOffset) );



            // Note that, since we've brought the next record to
            // CurrentRecordOffset, there's no need to adjust
            // CurrentRecordOffset.

         } else {

            // This record doesn't match, so we won't purge it.

            CurrentRecordOffset += CurrentRecord.QueryRecordLength();
         }
      }
   }

   return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::DeleteResidentAttribute(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name,
    IN  PCVOID              Value,
    IN  ULONG               ValueLength,
    OUT PBOOLEAN            Deleted,
    IN  BOOLEAN             IgnoreExternal
    )
/*++

Routine Description:

    This method will delete any attribute record associated with the
    File Record Segment which represents a resident attribute of the
    specified type and name with a value equal to the supplied value.

Arguments:

    Type            --  Supplies the attribute type code.
    Name            --  Supplies the attribute name.  May be NULL, which
                        indicates that the attribute has no name.
    Value           --  Supplies the value of the attribute to delete.
    ValueLength     --  Supplies the length of the value.
    IgnoreExternal  --  Supplies a flag which indicates, if TRUE,
                        that this method should only examine records
                        in this FRS (ie. it should ignore external
                        attributes).
    Deleted         --  Receives TRUE if the method found and deleted
                        a matching record.

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CurrentName;
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference, FoundSegmentReference;

    PNTFS_FILE_RECORD_SEGMENT ChildFrs;

    ATTRIBUTE_TYPE_CODE CurrentType;
    VCN LowestVcn, TargetFileNumber;
    USHORT Instance, FoundInstance;
    BOOLEAN IsIndexed;

    DebugPtrAssert( Value );
    DebugPtrAssert( Deleted );

    *Deleted = FALSE;

    if( !SetupAttributeList() ) {

        return FALSE;
    }

    if( !IgnoreExternal &&
        _AttributeList != NULL ) {

        // First, traverse the list to force all the children into
        // memory.
        //

        ATTR_LIST_CURR_ENTRY        Entry;

        Entry.CurrentEntry = NULL;
        while (_AttributeList->QueryNextEntry( &Entry,
                                               &CurrentType,
                                               &LowestVcn,
                                               &SegmentReference,
                                               &Instance,
                                               &CurrentName )) {

            TargetFileNumber.Set( SegmentReference.LowPart,
                                  (LONG)SegmentReference.HighPart );

            if( TargetFileNumber != QueryFileNumber() &&
                SetupChild( TargetFileNumber ) == NULL ) {

                return FALSE;
            }
        }

        // Now traverse the list of children, trying to delete
        // the record in question.
        //
        _ChildIterator->Reset();

        while( (ChildFrs = (PNTFS_FILE_RECORD_SEGMENT)
                           _ChildIterator->GetNext()) != NULL ) {

            if( !ChildFrs->DeleteResidentAttributeLocal( Type,
                                                         Name,
                                                         Value,
                                                         ValueLength,
                                                         Deleted,
                                                         &IsIndexed,
                                                         &Instance ) ) {

                return FALSE;
            }

            if( *Deleted ) {

                // We found our victim.  Remember the segment reference
                // and instance tag, so we can delete the attribute list
                // entry.
                //
                FoundSegmentReference = ChildFrs->QuerySegmentReference();
                FoundInstance = Instance;

                break;
            }
        }

        if( !*Deleted ) {

            // We didn't find the target attribute record in any
            // of the children; see if it's in this FRS itself.
            //
            if( !DeleteResidentAttributeLocal( Type,
                                               Name,
                                               Value,
                                               ValueLength,
                                               Deleted,
                                               &IsIndexed,
                                               &Instance ) ) {

                return FALSE;
            }

            if( *Deleted ) {

                // Found it in this FRS.
                //
                FoundSegmentReference = QuerySegmentReference();
                FoundInstance = Instance;
            }
        }

        if( *Deleted ) {

            // We found and deleted a matching attribute record.
            // Find the corresponding entry in the attribute list
            // and delete it.  Note that the Segment Reference and
            // Instance Tag are sufficient to identify that entry.
            //

            ATTR_LIST_CURR_ENTRY    Entry;

            Entry.CurrentEntry = NULL;
            while (_AttributeList->QueryNextEntry( &Entry,
                                                   &CurrentType,
                                                   &LowestVcn,
                                                   &SegmentReference,
                                                   &Instance,
                                                   &CurrentName )) {

                if( SegmentReference == FoundSegmentReference &&
                    Instance == FoundInstance ) {

                    _AttributeList->DeleteCurrentEntry( &Entry );
                    break;
                }
            }
        }

    } else {

        // This FRS does not have an attribute list (or the client
        // wants to ignore it), so we just have to examine the records
        // in this FRS.
        //
        if( !DeleteResidentAttributeLocal( Type,
                                           Name,
                                           Value,
                                           ValueLength,
                                           Deleted,
                                           &IsIndexed,
                                           &Instance ) ) {

            return FALSE;
        }

    }

    // If we successfully deleted an indexed attribute record
    // from a Base File Record Segment, we need to adjust the
    // reference count.
    //
    if( *Deleted && IsBase() && IsIndexed ) {
        SetReferenceCount(QueryReferenceCount() - 1);
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::DeleteResidentAttributeLocal(
    IN  ATTRIBUTE_TYPE_CODE Type,
    IN  PCWSTRING           Name OPTIONAL,
    IN  PCVOID              Value,
    IN  ULONG               ValueLength,
    OUT PBOOLEAN            Deleted,
    OUT PBOOLEAN            IsIndexed,
    OUT PUSHORT             InstanceTag
    )
/*++

Routine Description:

    This method deletes a resident attribute from the FRS.  Note
    that it will not affect external attributes.

Arguments:

    Type            --  Supplies the attribute type code.
    Name            --  Supplies the attribute name.  May be NULL, which
                        indicates that the attribute has no name.
    Value           --  Supplies the value of the attribute to delete.
    ValueLength     --  Supplies the length of the value.
    Deleted         --  Receives TRUE if the method found and deleted
                        a matching record.
    IsIndexed       --  Receives TRUE if the deleted record was indexed.
                        If no matching record was found, *Deleted is
                        FALSE and *IsIndexed is undefined.
    InstanceTag     --  Receives the instance tag of the deleted record;
                        if no matching record was found, *Deleted is
                        FALSE and *InstanceTag is undefined.

Return Value:

    TRUE upon successful completion.


--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    PVOID CurrentRecordData;
    PCWSTR NameBuffer = NULL;
    ULONG NameLength;       //  Length of Name in characters

    DebugPtrAssert( Value );
    DebugPtrAssert( Deleted );

    *Deleted = FALSE;

    // Get the search name into a WSTR buffer, for
    // easier comparison:
    //
    if( Name == NULL ) {

        NameLength = 0;

    } else {

        NameLength = Name->QueryChCount();
        NameBuffer = Name->GetWSTR();
    }

    // Go through the attribute records in this FRS until
    // we find one that matches.  If we find one, it is
    // unique (unless the FRS is corrupt), so we delete
    // it and return.

    CurrentRecordData = NULL;

    while( (CurrentRecordData =
            GetNextAttributeRecord( CurrentRecordData )) != NULL ) {

        if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

            return FALSE;
        }

        // This record matches if the type codes are the same,
        // the record is resident, the names are the same length
        // and compare exactly, and the values are the same length
        // and compare exactly.
        //
        if( CurrentRecord.QueryTypeCode() == Type &&
            CurrentRecord.IsResident() &&
            CurrentRecord.QueryNameLength() == NameLength &&
            memcmp( NameBuffer,
                    CurrentRecord.GetName(),
                    NameLength * sizeof(WCHAR) ) == 0 &&
            CurrentRecord.QueryResidentValueLength() == ValueLength &&
            memcmp( CurrentRecord.GetResidentValue(),
                    Value,
                    ValueLength ) == 0 ) {

            // This is the record we want to delete.
            //
            *IsIndexed = CurrentRecord.IsIndexed();
            *InstanceTag = CurrentRecord.QueryInstanceTag();

            DeleteAttributeRecord( CurrentRecordData );
            *Deleted = TRUE;

            return TRUE;
        }
    }

    return TRUE;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::SetupAttributeList(
    )
/*++

Routine Description:

    This method makes sure that the attribute list, if present,
    has been properly set up.  If the attribute list is present
    but cannot be initialized, this method returns FALSE.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    if ( _AttributeList == NULL &&
         IsAttributePresent( $ATTRIBUTE_LIST, NULL, TRUE ) ) {

        if (!(_AttributeList = NEW NTFS_ATTRIBUTE_LIST) ||
            !QueryAttributeList(_AttributeList) ||
            !_AttributeList->ReadList()) {

            //  This File Record Segment has an Attribute List, and I
            //  can't get it.  Return failure.

            DELETE(_AttributeList);
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::CreateAttributeList(
    OUT PNTFS_ATTRIBUTE_LIST    AttributeList
    )
/*++

Routine Description:

    This method generates an Attribute List Attribute for this
    File Record Segment.

Arguments:

    AttributeList   - Returns a newly-create Attribute List.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    It is an error to create an Attribute List Attribute for a
    File Record Segment that already has one.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference;
    ULONG CurrentRecordOffset;
    DSTRING CurrentName;

    // Construct an attribute list object:

    if( !AttributeList->Initialize( GetDrive(),
                                    QueryClusterFactor(),
                                    GetUpcaseTable() ) ) {

        return FALSE;
    }

    // Walk through the record entries in this File Record Segment,
    // adding an entry to the Attribute List for each record we find.
    // Note that we can use the same Segment Reference for every entry,
    // since they are all in this File Record Segment.

    SegmentReference = QuerySegmentReference();

    CurrentRecordOffset = _FrsData->FirstAttributeOffset;

    while( CurrentRecordOffset < QuerySize() &&
           CurrentRecord.Initialize( GetDrive(),
                                     (PBYTE)_FrsData + CurrentRecordOffset,
                                     QuerySize() - CurrentRecordOffset ) &&
           CurrentRecord.QueryTypeCode() != $END ) {

        if( CurrentRecord.QueryRecordLength() == 0 ) {

            // Corrupt FRS.
            //
            return FALSE;
        }

        if (!CurrentRecord.QueryName(&CurrentName) ||
            !AttributeList->AddEntry( CurrentRecord.QueryTypeCode(),
                                      CurrentRecord.QueryLowestVcn(),
                                      &SegmentReference,
                                      CurrentRecord.QueryInstanceTag(),
                                      &CurrentName ) ) {

            return FALSE;
        }

        CurrentRecordOffset += CurrentRecord.QueryRecordLength();
    }

    return TRUE;
}


PVOID
GetBiggestLocalAttributeRecord(
    IN  PNTFS_FRS_STRUCTURE Frs
    )
/*++

Routine Description:

    This routine returns the biggest attribute record in this
    file record segment.

Arguments:

    Frs - Supplies a Frs.

Return Value:

    A pointer to the biggest attribute record or NULL.

--*/
{
    PATTRIBUTE_RECORD_HEADER    pattr, biggest;

    biggest = NULL;
    while (biggest = (PATTRIBUTE_RECORD_HEADER)
                     Frs->GetNextAttributeRecord(biggest)) {

        if (biggest->TypeCode != $STANDARD_INFORMATION) {
            break;
        }
    }

    if (!biggest) {
        return NULL;
    }

    pattr = biggest;
    while (pattr = (PATTRIBUTE_RECORD_HEADER)
                   Frs->GetNextAttributeRecord(pattr)) {

        if (pattr->TypeCode != $STANDARD_INFORMATION &&
            pattr->RecordLength > biggest->RecordLength) {
            biggest = pattr;
        }
    }

    return biggest;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::SaveAttributeList(
    PNTFS_BITMAP VolumeBitmap
    )
/*++

Routine Description:

    This method instructs the File Record Segment to save its
    attribute record list.

Arguments:

    VolumeBitmap    -- supplies the volume bitmap.

Notes:

    If _AttributesList is NULL, then the File Record Segment has not
    modified its attribute list (if it has one) and therefore does
    not need to save it.

    If this method fails, it will leave the File Record Segment in
    a consistent state (it will leave the old attribute list, if any,
    in place).

--*/
{
    NTFS_ATTRIBUTE_RECORD OldAttributeListRecord;
    NTFS_ATTRIBUTE_RECORD TemporaryRecord;
    BOOLEAN InsertSucceeded, OldPresent;
    PATTRIBUTE_RECORD_HEADER Biggest;
    ATTRIBUTE_TYPE_CODE type;
    VCN lowest_vcn;
    MFT_SEGMENT_REFERENCE seg_ref;
    USHORT instance;
    DSTRING name, tmp_name;
    BOOLEAN found_entry;


    if( _AttributeList == NULL ) {

        return TRUE;
    }

    // Note that there is no attribute list entry for the
    // attribute list's own attribute record.
    //
    // Write the attribute list.
    //
    if( !_AttributeList->WriteList( VolumeBitmap ) ) {

        return FALSE;
    }

    // We'll hedge our bets by squirreling away a copy of the old
    // attribute list's attribute record, if it exists.  Note that
    // this is a two-step process; first, we query the attribute
    // list's record from the File Record Segment; however, since
    // this record's data is actually owned by the File Record Segment,
    // we need to copy it into a record that has its own data.

    if( IsAttributePresent( $ATTRIBUTE_LIST, NULL, TRUE ) ) {

        OldPresent = TRUE;

        if( !QueryAttributeRecord(&TemporaryRecord, $ATTRIBUTE_LIST) ||
            !OldAttributeListRecord.Initialize( GetDrive(),
                                                (PVOID) TemporaryRecord.GetData(),
                                                TemporaryRecord.QueryRecordLength(),
                                                TRUE ) ) {

            // This File Record Segment has an attribute list record,
            // but we weren't able to copy it to a safe place.  Stop
            // right here, instead of going forward into a mess from
            // which we can't recover.

            return FALSE;
        }

    } else {

        OldPresent = FALSE;
    }


    // Now that we have our own copy of the old record (if it existed),
    // we can safely delete it from the File Record Segment.  We could
    // rely on _AttributeList->InsertIntoFile to do that for us, but
    // that would complicate our error handling further down.

    if( !PurgeAttribute( $ATTRIBUTE_LIST ) ) {

        return FALSE;
    }


    // Now we try every trick we've got to insert the new attribute
    // list into the File Record Segment.

    InsertSucceeded = FALSE;

    while( !InsertSucceeded ) {

        InsertSucceeded = _AttributeList->InsertIntoFile( this,
                                                          VolumeBitmap );

        if( !InsertSucceeded ) {

            // We weren't able to insert the attribute.  Try different
            // strategems to jam it in.   First, if the attribute list
            // is resident, we can make it non-resident.

            if( _AttributeList->IsResident() ) {

                if( !_AttributeList->MakeNonresident( VolumeBitmap ) ) {

                    // We failed trying to make the attribute list
                    // nonresident.  Give up.

                    break;
                }

            } else {

                // It's nonresident, so we have to move to our next
                // contingency plan:  start moving records out of the
                // base File Record Segment and into children.

                // Find the biggest attribute record in the base
                // and then eliminate it from the attribute list
                // and the base file record segment but save it.

                Biggest = (PATTRIBUTE_RECORD_HEADER)
                          GetBiggestLocalAttributeRecord(this);
                if (!Biggest ||
                    !TemporaryRecord.Initialize(GetDrive(),
                                                Biggest,
                                                Biggest->RecordLength,
                                                TRUE)) {

                    // Serious problems.
                    break;
                }

                found_entry = FALSE;

                ATTR_LIST_CURR_ENTRY    entry;

                entry.CurrentEntry = NULL;
                while (_AttributeList->QueryNextEntry(&entry,
                                                      &type,
                                                      &lowest_vcn,
                                                      &seg_ref,
                                                      &instance,
                                                      &name)) {

                    if (type == TemporaryRecord.QueryTypeCode() &&
                        lowest_vcn == TemporaryRecord.QueryLowestVcn() &&
                        seg_ref == QuerySegmentReference() &&
                        instance == TemporaryRecord.QueryInstanceTag() &&
                        TemporaryRecord.QueryName(&tmp_name) &&
                        !tmp_name.Strcmp(&name)) {

                        _AttributeList->DeleteCurrentEntry(&entry);
                        found_entry = TRUE;
                        break;
                    }
                }

                if (found_entry) {
                    DeleteAttributeRecord(Biggest);
                } else {
                    DebugAbort("Could not find attribute list entry for big");
                    break;
                }

                // Now just pull an insert external on this record to
                // finish the task.

                if (!InsertExternalAttributeRecord(&TemporaryRecord) ||
                    !_AttributeList->WriteList(VolumeBitmap)) {

                    // Out of memory or out of disk space.
                    break;
                }
            }
        }
    }


    if( !InsertSucceeded && OldPresent ) {

        // Since we were unable to insert the new attribute
        // record, we reinsert the old one.  Note that we can
        // be sure that there's room for it, since we haven't
        // added anything to the File Record Segment since we
        // deleted this record.

        InsertAttributeRecord( &OldAttributeListRecord );
    }

    // For good or ill, we're done.

    return( InsertSucceeded );
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttributeRecord (
    OUT PNTFS_ATTRIBUTE_RECORD  AttributeRecord,
    IN  ATTRIBUTE_TYPE_CODE     Type,
    IN  PCWSTRING               Name
   )
/*++

Routine Description:

    This method finds an attribute record in the FRS.  Note that it only
    searches this FRS, it will not look for external attribute records.

Arguments:

    AttributeRecord -- returns the Attribute Record object.
    Type            -- supplies the type of the desired attribute record
    Name            -- supplies the name of the desired attribute (NULL if
                           the attribute has no name).

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG CurrentRecordOffset;
    BOOLEAN Found = FALSE;

    DebugPtrAssert( _FrsData );
    DebugPtrAssert( AttributeRecord );

    // Spin through the records in this File Record Segment
    // looking for a match.  If we find one, set the Found
    // flag and break out.

    CurrentRecordOffset = _FrsData->FirstAttributeOffset;

    while( CurrentRecordOffset < QuerySize() &&
           AttributeRecord->Initialize( GetDrive(),
                                        (PBYTE)_FrsData + CurrentRecordOffset,
                                        QuerySize() - CurrentRecordOffset ) &&
           AttributeRecord->QueryTypeCode() != $END ) {

        if( AttributeRecord->IsMatch( Type, Name ) ) {

            Found = TRUE;
            break;
        }

        // Go on to the next record

        CurrentRecordOffset += AttributeRecord->QueryRecordLength();
    }

    // If Found is TRUE, then CurrentRecord is the attribute
    // record we want, so we'll return it to the caller.

    return Found;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::InsertAttributeRecord (
    IN  PNTFS_ATTRIBUTE_RECORD  NewRecord,
    IN  BOOLEAN                 ForceExternal
   )
/*++

Routine Description:

   This method inserts an attribute record into the File Record
   Segment.

   If the File Record Segment has room, it will just insert the
   record.  If not, it may make the attribute external, or it
   may make room for the record by making other attributes nonresident
   or external.

   The Attribute List attribute and the Standard Information attribute
   cannot be made external.

   This method is virtual because classes which derive from
   File Record Segment may have preferences about how they manage
   their attribute records.

Arguments:

   AttributeRecord   -- supplies the attribute record to insert

   ForceExternal     -- supplies a flag telling whether to force
                        this record into a child File Record Segment;
                        if this flag is TRUE, we force this record
                        to be external.

Return Value:

    TRUE upon successful completion.

Notes:

    This method may also update the Instance tag in the attribute record.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    MFT_SEGMENT_REFERENCE SegmentReference, CheckSegment;
    DSTRING               NewName, CheckName;
    NTFS_ATTRIBUTE_RECORD TempRecord;
    PATTRIBUTE_RECORD_HEADER EvicteeData, TempRecordData;
    DSTRING NewRecordName;
    VCN CheckVcn;
    ULONG CurrentRecordOffset;
    ULONG FreeSpace;
    ATTRIBUTE_TYPE_CODE CheckType;
    BOOLEAN Result, MatchPresent;
    USHORT CheckInstance;

    // The reservation for the attribute list is enought for
    // a nonresident attribute with no name and two worst-case
    // extents.  Since this reservation is only required for
    // FRS 0, this should be plenty.
    //
    CONST AttributeListReservation = SIZE_OF_NONRESIDENT_HEADER +
                                     3 * ( 1 + 2 * sizeof(VCN) );


   DebugPtrAssert( _FrsData );
    DebugPtrAssert( NewRecord );

    // The utilities will never insert any non-$DATA records into
    // the reserved MFT-overflow FRS when it is being used as
    // a child of the MFT.
    //
    if( !IsBase() &&
        QueryFileNumber() == MFT_OVERFLOW_FRS_NUMBER &&
        NewRecord->QueryTypeCode() != $DATA ) {

        return FALSE;
    }

    // If this File Record Segment has an attribute list, we have
    // to make sure that we've read it.

    if( !SetupAttributeList() ) {

        return FALSE;
    }

    // Determine whether an attribute record of the same type and
    // name is already present in this precise FRS (ie. in this
    // FRS and not one of its children).  If this is the case,
    // then if this
    //
    if( !NewRecord->QueryName( &NewRecordName ) ) {

        DebugPrint( "UNTFS: Can't get name from attribute record.\n" );
        return FALSE;
    }

    MatchPresent = IsAttributePresent( NewRecord->QueryTypeCode(),
                                       &NewRecordName,
                                       TRUE );

    // Determine how much space is available in the File Record Segment.
   // If there's enough, find the correct insertion point for this
    // attribute record and put it there.
    //
    FreeSpace = QueryFreeSpace();

    if( QueryFileNumber() == MASTER_FILE_TABLE_NUMBER &&
        IsBase() &&
        NewRecord->QueryTypeCode() != $ATTRIBUTE_LIST ) {

        // Reserve space for the Attribute List.
        //
        if ( FreeSpace < AttributeListReservation ) {

            FreeSpace = 0;

        } else{

            FreeSpace -= AttributeListReservation;
        }
    }

    // The new record can go in this FRS if the client has not
    // requested that it be made external, if there's sufficient
    // room for it, and if there is no collision with other records
    // for this attribute.
    //
   if( !ForceExternal &&
        NewRecord->QueryRecordLength() <= FreeSpace &&
        ( NewRecord->IsResident() || !MatchPresent ) ) {

        // There's enough free space for the new record, so it'll
        // go in this FRS.  Attach the current Next Instance tag
        // to this attribute record and increment the tag.
        //
        NewRecord->SetInstanceTag( QueryNextInstance() );
        IncrementNextInstance();

        // Scan through the list of records to find the point
      // at which we should insert it.
        //
      CurrentRecordOffset = _FrsData->FirstAttributeOffset;

      while( CurrentRecordOffset < QuerySize() &&
             CurrentRecord.Initialize( GetDrive(),
                                       (PBYTE)_FrsData + CurrentRecordOffset,
                                       QuerySize() - CurrentRecordOffset ) &&
             CurrentRecord.QueryTypeCode() != $END &&
             CompareAttributeRecords( &CurrentRecord,
                                        NewRecord,
                                        GetUpcaseTable() ) <= 0 ) {

            if( CurrentRecord.QueryRecordLength() == 0 ) {

                // Corrupt FRS.
                //
                return FALSE;
            }

         // Go on to the next record

         CurrentRecordOffset += CurrentRecord.QueryRecordLength();
      }

      // We want to insert the new record at CurrentRecordOffset;
      // make room for it there and copy it in.

      memmove( (PBYTE)_FrsData + CurrentRecordOffset +
                           NewRecord->QueryRecordLength(),
                 (PBYTE)_FrsData + CurrentRecordOffset,
                 _FrsData->FirstFreeByte - CurrentRecordOffset);

        _FrsData->FirstFreeByte += NewRecord->QueryRecordLength();

      memcpy( (PBYTE)_FrsData + CurrentRecordOffset,
            NewRecord->GetData(),
            (UINT) NewRecord->QueryRecordLength() );

        // if this File Record Segment has an attribute list, then
        // we add an entry to it for the attribute record we just added.
        // Note that we can safely assume that an attribute list is
        // present if and only if _AttributeList is non-NULL because
        // we made sure we had read it at the beginning of this method.

        if( _AttributeList != NULL &&
            NewRecord->QueryTypeCode() != $ATTRIBUTE_LIST ) {

            SegmentReference = QuerySegmentReference();

            if (!NewRecord->QueryName(&NewName) ||
                !_AttributeList->AddEntry(NewRecord->QueryTypeCode(),
                                          NewRecord->QueryLowestVcn(),
                                          &SegmentReference,
                                          NewRecord->QueryInstanceTag(),
                                          &NewName)) {

                // So near and yet so far.  We have to back all the
                // way out because we couldn't add an entry for this
                // record to the attribute list.

                memmove( (PBYTE)_FrsData + CurrentRecordOffset,
                         (PBYTE)_FrsData + CurrentRecordOffset +
                                            NewRecord->QueryRecordLength(),
                         _FrsData->FirstFreeByte -
                            (CurrentRecordOffset +
                             NewRecord->QueryRecordLength()) );

                _FrsData->FirstFreeByte -= NewRecord->QueryRecordLength();

                return FALSE;
            }
        }

        Result = TRUE;

    } else if( QueryFileNumber() == MASTER_FILE_TABLE_NUMBER &&
               NewRecord->QueryTypeCode() == $DATA &&
               NewRecord->QueryLowestVcn() == 0 ) {

        // The first chunk of the MFT's $DATA attribute must
        // be in the base File Record Segment.  Evict as many
        // other records as possible.
        //
        if( (TempRecordData = (PATTRIBUTE_RECORD_HEADER)
                              MALLOC( QuerySize() )) == NULL ) {

            DebugPrint( "UNTFS: Can't allocate memory for temporary attribute record.\n" );
            return FALSE;
        }

        EvicteeData = (PATTRIBUTE_RECORD_HEADER)GetNextAttributeRecord( NULL );

        while( EvicteeData != NULL &&
               EvicteeData->TypeCode != $END ) {

            // If this is not an attribute record we can evict,
            // then skip over it; otherwise, move it to a child
            // FRS.  Note that we don't check for the first chunk
            // of the $DATA attribute becuase, after all, that's
            // what we're inserting.
            //
            if( EvicteeData->TypeCode == $STANDARD_INFORMATION ||
                EvicteeData->TypeCode == $ATTRIBUTE_LIST ) {

                EvicteeData = (PATTRIBUTE_RECORD_HEADER)
                              GetNextAttributeRecord( EvicteeData );

            } else {

                // Copy this record to the temporary buffer and
                // delete it from the FRS.
                //
                memcpy( TempRecordData,
                        EvicteeData,
                        EvicteeData->RecordLength );

                if( !TempRecord.Initialize( GetDrive(), TempRecordData ) ) {

                    FREE( TempRecordData );
                    return FALSE;
                }

                DeleteAttributeRecord( EvicteeData );

                // Delete the attribute list entry that corresponds
                // to this attribute record.
                //
                if( _AttributeList != NULL ) {

                    ATTR_LIST_CURR_ENTRY    Entry;

                    Entry.CurrentEntry = NULL;
                    while( _AttributeList->QueryNextEntry( &Entry,
                                                           &CheckType,
                                                           &CheckVcn,
                                                           &CheckSegment,
                                                           &CheckInstance,
                                                           &CheckName ) ) {

                        // It's enough to establish a match if the
                        // segment reference and instance tag match,
                        // but we'll throw in a check for the type
                        // code just to be safe.
                        //
                        if( CheckType == TempRecord.QueryTypeCode() &&
                            CheckInstance == TempRecord.QueryInstanceTag() &&
                            CheckSegment == QuerySegmentReference() ) {

                            _AttributeList->DeleteCurrentEntry( &Entry );
                            break;
                        }
                    }
                }

                // Insert this record into a child FRS.
                //
                if( !InsertExternalAttributeRecord( &TempRecord ) ) {

                    FREE( TempRecordData );
                    return FALSE;
                }

                // No need to advance EvicteeData, since
                // DeleteAttributeRecord will bring the next
                // one down to us.
            }

        }

        FREE( TempRecordData );

        // OK, we've made as much free space as possible.  Recompute
        // the free space; if it's enough, insert the record recursively.
        // Since we only recurse if there's enough free space, and
        // we only fall into this branch if there isn't enough space,
        // we won't get infinite recursion.
        //
        FreeSpace = QueryFreeSpace();

        if( FreeSpace < AttributeListReservation ) {

            FreeSpace = 0;

        } else {

            FreeSpace -= AttributeListReservation;
        }

        if( FreeSpace > NewRecord->QueryRecordLength() ) {

            // It'll fit--go ahead and insert it.
            //
            return( InsertAttributeRecord( NewRecord, FALSE ) );

        } else {

            return FALSE;

        }

    } else {

        // This attribute will be external.  Call the private worker
        // method.

        Result = InsertExternalAttributeRecord( NewRecord );
    }

    //  If this is a base file record segment and we've successfully
    //  inserted an indexed attribute, increment the reference count.

    if( Result &&
        IsBase() &&
        NewRecord->IsResident() &&
        (NewRecord->QueryResidentFlags() & RESIDENT_FORM_INDEXED ) ) {

        _FrsData->ReferenceCount += 1;
    }

    return Result;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::InsertExternalAttributeRecord(
    IN  PNTFS_ATTRIBUTE_RECORD NewRecord
    )
/*++

Routine Description:

    This method adds an external attribute record to the File Record
    Segment.  It is a private worker for InsertAttributeRecord.  (It
    can also be used to move attribute records out of the base segment).

    Note that it is nonvirtual--once the File Record Segment has decided
    to make the attribute record external, it's done the same way for
    all types of File Record Segments.

Arguments:

   AttributeRecord   -- supplies the attribute record to insert

Return Value:

    TRUE upon successful completion.

Notes:

    The Attribute List and Standard Information attributes cannot
    be made external; this method enforces that restriction.


--*/
{
    PNTFS_FILE_RECORD_SEGMENT ChildFrs;
    MFT_SEGMENT_REFERENCE SegmentReference;
    VCN ChildFileNumber;
    ATTRIBUTE_TYPE_CODE TypeCode;
    VCN LowestVcn;
    DSTRING Name;
    USHORT Instance;
    BOOLEAN IsMft, IsMftData;
    ATTR_LIST_CURR_ENTRY    Entry;

    ULONG cluster_size = QueryClusterFactor() * GetDrive()->QuerySectorSize();


    IsMft = ( QueryFileNumber() == MASTER_FILE_TABLE_NUMBER );
    IsMftData = IsMft && ( NewRecord->QueryTypeCode() == $DATA );

    // the standard information and attribute list attributes cannot
    // be made external.

    if( NewRecord->QueryTypeCode() == $STANDARD_INFORMATION ||
        NewRecord->QueryTypeCode() == $ATTRIBUTE_LIST ) {

        return FALSE;
    }

    // The Log File cannot have any external attributes.
    //
    if( !IsBase() &&
        QueryFileNumber() == LOG_FILE_NUMBER ) {

        return FALSE;
    }

    // Note that only Base File Record Segments can have attribute lists.

    if( !IsBase() || !SetupAttributeList() ) {

        return FALSE;
    }

    // OK, at this point, _AttributeList is NULL if and only if
    // the File Record Segment has no attribute list.  If the File
    // Record Segment has no attribute list, we need to create one.

    if (_AttributeList == NULL) {

        if (!(_AttributeList = NEW NTFS_ATTRIBUTE_LIST) ||
            !CreateAttributeList(_AttributeList)) {

            // We can't create an attribute list for this File Record
            // Segment.

            DELETE(_AttributeList);
            return FALSE;
        }
    }

    // Since this is a somewhat rare case, we can indulge ourselves
    // a bit.  Go through the Attribute List and force all the
    // children of this File Record Segment into memory.

    Entry.CurrentEntry = NULL;
    while (_AttributeList->QueryNextEntry( &Entry,
                                           &TypeCode,
                                           &LowestVcn,
                                           &SegmentReference,
                                           &Instance,
                                           &Name )) {

        ChildFileNumber.Set( SegmentReference.LowPart,
                             (LONG) SegmentReference.HighPart );

        if( ChildFileNumber != QueryFileNumber() &&
            SetupChild( ChildFileNumber ) == NULL ) {

            // Error.
            return FALSE;
        }
    }


    // Now go down the list of children and see if any of them
    // will accept this record.  Note that if this is the MFT
    // $DATA attribute, we must check each child before we try
    // to use it to make sure we don't break the bootstrap.
    // we much check each child
    //
    _ChildIterator->Reset();

    while( (ChildFrs =
            (PNTFS_FILE_RECORD_SEGMENT)_ChildIterator->GetNext()) != NULL ) {

        // The MFT requires special handling.  Records for the data
        // attribute must be inserted into child FRS' in a way that
        // preserves the MFT's bootstrapping, ie. the starting VCN of
        // the record must be greater than the VCN (file number times
        // clusters per FRS) of the child.  In addition, $DATA records
        // cannot share a child FRS with any other attribute records.
        //
        if( IsMft ) {

            if (IsMftData &&
                ( ChildFrs->GetNextAttributeRecord( NULL ) != NULL ||
                  NewRecord->QueryLowestVcn() * cluster_size <=
                        ChildFrs->QueryFileNumber() * QuerySize())) {

                // Either this child FRS is not empty, or
                // inserting this record into it will break
                // the MFT's bootstrapping.  Either way,
                // it can't accept this record.
                //
                continue;
            }

            if( ChildFrs->IsAttributePresent( $DATA ) ) {

                // This child FRS already has a $DATA attribute
                // record, so it can't accept any other records.
                //
                continue;
            }
        }

        // This child FRS is eligible to hold this attribute record.
        //
        if( ChildFrs->InsertAttributeRecord( NewRecord ) ) {

            // Success!  Add an appropriate entry to the
            // attribute list.
            //
            SegmentReference = ChildFrs->QuerySegmentReference();

            if( !NewRecord->QueryName( &Name ) ||
                !_AttributeList->AddEntry( NewRecord->QueryTypeCode(),
                                           NewRecord->QueryLowestVcn(),
                                           &SegmentReference,
                                           NewRecord->QueryInstanceTag(),
                                           &Name ) ) {

                DebugPrintTrace(( "UNTFS: Can't add entry to attribute list." ));
                return FALSE;
            }

            return TRUE;
        }
    }

    // We have to allocate a new child File Record Segment.  If
    // This is the MFT File, see if we can grab the reserved FRS.
    //
    if( IsMftData &&
        GetChild( MFT_OVERFLOW_FRS_NUMBER ) == NULL ) {

        // This FRS is the MFT, and it hasn't already grabbed
        // the reserved FRS--grab it now.
        //
        ChildFileNumber = MFT_OVERFLOW_FRS_NUMBER;

    } else if( !_Mft->AllocateFileRecordSegment( &ChildFileNumber, IsMftData ) ) {

        // Can't get a new child File Record Segment.

        return FALSE;
    }

    // Set up the Segment Reference to refer to the Base File
    // Record Segment, ie. this File Record Segment.
    //
    SegmentReference = QuerySegmentReference();

    // Construct the new child File Record Segment and insert
    // the attribute record into it.  Again, make sure we don't
    // violate the MFT bootstrapping requirements.  (Note that
    // we don't have to check the sharing rule for the MFT data
    // attribute because this is a new FRS--it can't contain
    // any conflicting records.
    //
    if( (ChildFrs = NEW NTFS_FILE_RECORD_SEGMENT) == NULL ||
        !ChildFrs->Initialize( ChildFileNumber, _Mft )    ||
        !ChildFrs->Create( &SegmentReference )            ||
        ( IsMftData &&
          NewRecord->QueryLowestVcn() * cluster_size <=
            ChildFrs->QueryFileNumber() * QuerySize() ) ||
        !ChildFrs->InsertAttributeRecord( NewRecord )   ||
        !AddChild( ChildFrs ) ) {

        // That didn't do us any good at all.  Clean up the child
        // and return our failure.

        DELETE( ChildFrs );
        _Mft->FreeFileRecordSegment( ChildFileNumber );

        return FALSE;
    }

    // Note that the Child File Record Segment has passed into the
    // keeping of the children list, so we don't delete it.
    //
    // Add an entry to the attribute list for the new record.
    //
    SegmentReference = ChildFrs->QuerySegmentReference();

    if( !NewRecord->QueryName( &Name ) ||
        !_AttributeList->AddEntry( NewRecord->QueryTypeCode(),
                                   NewRecord->QueryLowestVcn(),
                                   &SegmentReference,
                                   NewRecord->QueryInstanceTag(),
                                   &Name ) ) {

        DebugPrintTrace(( "UNTFS: Can't add entry to attribute list." ));
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Write(
   )
/*++

Routine Description:

    This method writes the File Record Segment.  It does not affect the
    attribute list or the child record segments.

Arguments:

    None.

Return Value:

   TRUE upon successful completion.

--*/
{
   return( NTFS_FRS_STRUCTURE::Write() );
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Flush(
    IN OUT PNTFS_BITMAP     VolumeBitmap,
    IN OUT PNTFS_INDEX_TREE ParentIndex,
    IN     BOOLEAN          FrsIsEmpty
    )
/*++

Routine Description:

    This method is used to commit a file to disk.  It saves the attribute
    list, writes any child record segments that have been brought into
    memory, and writes the File Record Segment itself.

Arguments:

    VolumeBitmap    --  Supplies the volume bitmap.  This parameter may
                        be NULL, in which case non-resident attributes
                        cannot be resized.
    ParentIndex     --  Supplies the directory which indexes this FRS
                        over $FILE_NAME.  May be NULL.

Return Value:

    TRUE upon successful completion.

--*/
{
    DUPLICATED_INFORMATION      DuplicatedInformation;
    PNTFS_FILE_RECORD_SEGMENT   CurrentChild, ChildToDelete;

    // If this is a child FRS, just write it.
    //
    if( !IsBase() ) {

        return( Write() );
    }

    // This FRS is a Base File Record Segment--it may have
    // an attribute list and children, and we have to update
    // the file-name information in the parent index.
    //

    if( !FrsIsEmpty && _AttributeList != NULL &&
        !SaveAttributeList( VolumeBitmap ) ) {

        return FALSE;
    }

    // Update the file name attributes:

    if ( !FrsIsEmpty )
        if( !QueryDuplicatedInformation( &DuplicatedInformation ) ||
            !UpdateFileNames( &DuplicatedInformation, ParentIndex, FALSE ) ) {

            DebugAbort( "Can't update file names in Flush.\n" );
            return FALSE;
        }

    // Flush all the children.  If a child is empty, mark it as
    // unused.
    //
    _ChildIterator->Reset();

    while( (CurrentChild = (PNTFS_FILE_RECORD_SEGMENT)
                           _ChildIterator->GetNext()) != NULL ) {

        if( !CurrentChild->GetNextAttributeRecord( NULL ) ) {


            // This child has no attribute records--we don't
            // need it anymore.
            //
            CurrentChild->ClearInUse();
            CurrentChild->Write();
            _Mft->FreeFileRecordSegment( CurrentChild->QueryFileNumber() );
            ChildToDelete = (PNTFS_FILE_RECORD_SEGMENT)_Children.Remove(_ChildIterator);
            DebugAssert(ChildToDelete == CurrentChild);
            DELETE(ChildToDelete);
            CurrentChild = NULL;
            _ChildIterator->Reset();

        } else if( !CurrentChild->Flush( VolumeBitmap ) ) {

            return FALSE;
        }
    }

    return( Write() );
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryNextAttribute(
    IN  PATTRIBUTE_TYPE_CODE    TypeCode,
    IN  PWSTRING                Name
    )
/*++

Routine Description:

    This method finds the first (attribute type, name) pair in this
    file which is greater than (TypeCode, Name).  Note that it will
    not return the ATTRIBUTE_LIST, if one is present.

Arguments:

    TypeCode    --  supplies the current attribute type code.  Receives
                    the type code of the next attribute.  A returned type
                    code of $END indicates that there are no more attributes.
    Name        --  supplies the current name.  Receives the name of the
                    next attribute.

Return Value:

    TRUE upon successful completion.

Notes:

    This method is useful for iterating through the non-indexed
    attributes of a file, since there can only be one non-indexed
    attribute with a given type code and name in the file.  However,
    it offers no way of dealing with indexed attributes, which may
    be distinguished only by value.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    ULONG CurrentRecordOffset;
    PWSTR NameBuffer = NULL;
    ULONG NameLength;

    DebugAssert( Name );


    if( !SetupAttributeList() ) {

        return FALSE;
    }

    if( _AttributeList != NULL ) {

        return( _AttributeList->QueryNextAttribute( TypeCode, Name ) );
    }

    // This is slightly ugly but necessary.  NTFS attribute names
    // are collated straight, so we can't use the WSTRING name
    // comparison, which relies on the current locale.

    NameLength = Name->QueryChCount();
    NameBuffer = Name->QueryWSTR();

    if( NameBuffer == NULL ) {

        return FALSE;
    }


    // Start at the first attribute record, and iterate forward from
    // there.

   CurrentRecordOffset = _FrsData->FirstAttributeOffset;

   while( CurrentRecordOffset < QuerySize() ) {

        if( !CurrentRecord.Initialize( GetDrive(),
                                       (PBYTE)_FrsData + CurrentRecordOffset,
                                       QuerySize() - CurrentRecordOffset ) ) {

            if( NameBuffer != NULL ) {

                FREE( NameBuffer );
            }

            return FALSE;
        }


        if( CurrentRecord.QueryTypeCode() == $END ||
            CurrentRecord.QueryTypeCode() > *TypeCode ) {

            // Either we're at the end of the list, or we've found
            // an attribute with a type code greater than *TypeCode--
            // either way, we've succeeded.

            break;
        }

        if( CurrentRecord.QueryTypeCode() == *TypeCode ) {

            // This record has the same type code as current
            // type, so we have to compare names.

            if( CurrentRecord.QueryNameLength() > 0 &&
                CountedWCMemCmp( NameBuffer,
                                 NameLength,
                                 CurrentRecord.GetName(),
                                 CurrentRecord.QueryNameLength() ) > 0 ) {

                // This record has a name which is greater than
                // Name, so we're done.

                break;
            }
        }

        // Go on to the next record
        //
        if( CurrentRecord.QueryRecordLength() == 0 ) {

            // Corrupt FRS.
            //
            if( NameBuffer != NULL ) {

                FREE( NameBuffer );
            }
            return FALSE;
        }

      CurrentRecordOffset += CurrentRecord.QueryRecordLength();
   }

    // Check for overflow.

    if( CurrentRecordOffset >= QuerySize() ) {

        if( NameBuffer != NULL ) {

            FREE( NameBuffer );
        }
        return FALSE;
    }

    // Copy the output parameters.

    *TypeCode = CurrentRecord.QueryTypeCode();

    if( *TypeCode != $END ) {

        if (!CurrentRecord.QueryName(Name)) {
            if( NameBuffer != NULL ) {

                FREE( NameBuffer );
            }
            return FALSE;
        }

    } else {

        if (!Name->Initialize("")) {
            if( NameBuffer != NULL ) {

                FREE( NameBuffer );
            }
            return FALSE;
        }
    }

    if( NameBuffer != NULL ) {

        FREE( NameBuffer );
    }
    return TRUE;
}



BOOLEAN
NTFS_FILE_RECORD_SEGMENT::RecoverFile(
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN OUT PNUMBER_SET  BadClusterList,
    IN     UCHAR        VolumeMajorVersion,
    OUT    PULONG       BadClusters,
    OUT    PBIG_INT     BytesRecovered,
    OUT    PBIG_INT     TotalBytes
    )
/*++

Routine Description:

    This method performs recovery on a file record segment.

Arguments:

    VolumeBitmap    --  supplies the volume bitmap.
    BadClusterFile  --  supplies the volume's bad-cluster file
    BadClusters     --  receives the number of bad clusters found in
                        attributes associated with this object.
    BytesRecovered  --  bytes recovered in all attributes subject to
                        recovery.
    TotalBytes      --  total bytes in attributes subject to recovery.

Notes:

    $DATA is the only system-defined attribute which is recovered.
    problems with other system-defined attributes must be handled by
    CHKDSK.

--*/
{
    NTFS_ATTRIBUTE CurrentAttribute;
    NUMBER_SET BadClusterNumSet;

    ATTRIBUTE_TYPE_CODE CurrentAttributeTypeCode;
    DSTRING CurrentAttributeName;
    BIG_INT CurrentBytesRecovered;

    BOOLEAN Error, Modified;

    DebugAssert(IsInUse());
    DebugAssert(IsBase());


    Modified = FALSE;

    if( !BadClusterNumSet.Initialize() ) {

        return FALSE;
    }


    // Force the attribute list, if we have one, into memory.

    if( !SetupAttributeList() ) {

        return FALSE;
    }


    if (!CurrentAttributeName.Initialize("")) {
        return FALSE;
    }


    CurrentAttributeTypeCode = $STANDARD_INFORMATION;

    *BytesRecovered = 0;
    *TotalBytes = 0;

    while( TRUE ) {

        // Determine the type code and name of the next attribute
        // to recover.

        if( !QueryNextAttribute( &CurrentAttributeTypeCode,
                                 &CurrentAttributeName ) ) {

            return FALSE;
        }


        // Are we done yet?

        if( CurrentAttributeTypeCode == $END ) {

            break;
        }

        // System defined attributes other than $DATA are not
        // recovered.

        if( ((VolumeMajorVersion >= 2) ?
             (CurrentAttributeTypeCode < $FIRST_USER_DEFINED_ATTRIBUTE_2) :
             (CurrentAttributeTypeCode <    $FIRST_USER_DEFINED_ATTRIBUTE_1)) &&
            CurrentAttributeTypeCode != $DATA ) {

            continue;
        }


        // Recover the attribute we decided to recover.

        if( !QueryAttribute( &CurrentAttribute,
                             &Error,
                             CurrentAttributeTypeCode,
                             &CurrentAttributeName ) ||
            !CurrentAttribute.RecoverAttribute( VolumeBitmap,
                                                &BadClusterNumSet,
                                                &CurrentBytesRecovered )) {

            return FALSE;
        }

        *BytesRecovered += CurrentBytesRecovered;
        *TotalBytes += CurrentAttribute.QueryValueLength();

        // If the attribute's storage has been modified, I have
        // to save the attribute.

        if( CurrentAttribute.IsStorageModified() ) {

            Modified = TRUE;
            if( !CurrentAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

                return FALSE;
            }
        }
    }

    DebugAssert(BadClusterNumSet.QueryCardinality().GetHighPart() == 0);

    *BadClusters = BadClusterNumSet.QueryCardinality().GetLowPart();

    if( *BadClusters != 0 ) {

        BadClusterList->Add( &BadClusterNumSet );

    }

    // If any of the attributes have been modified, flush the FRS.
    //
    if( Modified && !Flush( VolumeBitmap ) ) {

        return FALSE;
    }

    return TRUE;
}


NTFS_SORT_CODE
NTFS_FILE_RECORD_SEGMENT::SortIndex(
    IN     PCWSTRING    IndexName,
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN     BOOLEAN      DuplicatesAllowed,
    IN     BOOLEAN      CheckOnly
    )
/*++

Routine Description:

    This method sorts an index tree associated with the File
    Record Segment.

Arguments:

    IndexName           --  Supplies the name of the index.
    VolumeBitmap        --  Supplies the bitmap for this volume.
    CheckOnly           --  Supplies a flag which, if true, indicates that
                            this method should only determine whether the
                            index is badly ordered, it should not actually
                            sort it.
    DuplicatesAllowed   --  Supplies a flag that indicates whether this
                            index tolerates duplicate entries.

Return Value:

    A code indicating the result of the sort:

    Possible return codes for SortIndex:

        NTFS_SORT_INDEX_NOT_FOUND       --  this FRS does not contain an
                                            index with the specified name.
        NTFS_SORT_INDEX_WELL_ORDERED    --  the index was not sorted because
                                            it was found to be well-ordered.
        NTFS_SORT_INDEX_BADLY_ORDERED   --  The index was found to be badly
                                            ordered, and it was not sorted.
        NTFS_SORT_INDEX_SORTED          --  The index was sorted and new
                                            attributes were inserted into
                                            the FRS.
        NTFS_INSERT_FAILED              --  An insertion of an index entry
                                            into the new tree failed.
                                            (Probable cause:  out of space.)
        NTFS_SORT_ERROR                 --  Sort failed because of an error.


--*/
{
    NTFS_INDEX_TREE OldTree, NewTree;

    PCINDEX_ENTRY   CurrentEntry;
    PINDEX_ENTRY    NewEntry;

    ULONG           Depth;
    BOOLEAN         Error;

    MFT_SEGMENT_REFERENCE SegmentReference;

    DebugPtrAssert( VolumeBitmap );

    // Get the existing index out of the FRS.

    if( !OldTree.Initialize( GetDrive(),
                             QueryClusterFactor(),
                             VolumeBitmap,
                             GetUpcaseTable(),
                             QuerySize()/2,
                             this,
                             IndexName ) ) {

        return NTFS_SORT_INDEX_NOT_FOUND;
    }

    // Determine whether the index needs to be sorted:

    if( !OldTree.IsBadlyOrdered( &Error, DuplicatesAllowed ) ) {

        if( Error ) {

            // We could not determine whether the index was
            // badly ordered.

            return NTFS_SORT_ERROR;

        } else {

            // The index is well-ordered, so there's nothing to do.
            //
            return NTFS_SORT_INDEX_WELL_ORDERED;
        }
    }

    if( CheckOnly ) {

        // The client doesn't want us to actually sort the index,
        // just to determine whether it's badly ordered.

        return NTFS_SORT_INDEX_BADLY_ORDERED;
    }

    // The index is badly ordered, and the client wants us to
    // sort it.  Initialize a new index tree:
    //
    if( !NewTree.Initialize( OldTree.QueryIndexedAttributeType(),
                             GetDrive(),
                             QueryClusterFactor(),
                             VolumeBitmap,
                             GetUpcaseTable(),
                             OldTree.QueryCollationRule(),
                             OldTree.QueryBufferSize(),
                             QuerySize()/2,
                             IndexName ) ) {

        // Couldn't initialize a new index.
        //
        return NTFS_SORT_ERROR;
    }

    // Iterate through the entries in the old tree, copying them
    // (by value) into the new tree.
    //
    OldTree.ResetIterator();

    while( (CurrentEntry = OldTree.GetNext( &Depth, &Error )) != NULL ) {

        if( !DuplicatesAllowed &&
            NewTree.QueryFileReference( CurrentEntry->AttributeLength,
                                        GetIndexEntryValue( CurrentEntry ),
                                        0,
                                        &SegmentReference,
                                        &Error ) ) {

            // This index does not tolerate duplicate entries; since
            // an entry with the very same name as this one has already
            // been added to the tree, we're skipping this one.
            //
            continue;
        }

        if (CurrentEntry->Length <
            (sizeof(INDEX_ENTRY)+CurrentEntry->AttributeLength)) {
            continue;   // skip bad entry
        }

        if (!(NewEntry = (PINDEX_ENTRY)MALLOC(CurrentEntry->Length))) {
            NewTree.FreeAllocation();
            return NTFS_SORT_ERROR;
        }

        memcpy(NewEntry, CurrentEntry, CurrentEntry->Length);

        if (NewEntry->Flags & INDEX_ENTRY_NODE)
            NewEntry->Length -= sizeof(VCN);
        NewEntry->Flags = 0;

        if( !NewTree.InsertEntry( NewEntry )) {

            NewTree.FreeAllocation();
            FREE( NewEntry );
            return NTFS_SORT_INSERT_FAILED;
        }
        FREE( NewEntry );
    }

    if( Error ) {

        // An error occurred while traversing the old tree.

        NewTree.FreeAllocation();
        return NTFS_SORT_ERROR;
    }

    // We've constructed the new index--save it into this FRS to
    // replace the old one.
    //
    if( !NewTree.Save( this ) ) {

        NewTree.FreeAllocation();
        return NTFS_SORT_ERROR;
    }

    // Clean up the old tree.

    OldTree.FreeAllocation();

    return NTFS_SORT_INDEX_SORTED;
}

NTFS_QUOTA_CODE
NTFS_FILE_RECORD_SEGMENT::VerifyAndFixQuotaDefaultId(
    IN OUT PNTFS_BITMAP VolumeBitmap,
    IN     BOOLEAN      CheckOnly
    )
/*++

Routine Description:

    This method verifies that the default quota ID exists inside the
    Userid2SidQuotaNameData Index.

Arguments:

    VolumeBitmap        --  Supplies the bitmap for this volume.
    CheckOnly           --  Supplies a flag which, if true, indicates that
                            this method should only determine whether the
                            index is badly ordered, it should not actually
                            sort it.

Return Value:

    A code indicating the result of the sort:

    Possible return codes for SortIndex:

        NTFS_QUOTA_INDEX_NOT_FOUND      --  this FRS does not contain an
                                            index with the specified name.
        NTFS_QUOTA_DEFAULT_ENTRY_MISSING--  the default entry was not found
                                            in the index
        NTFS_QUOTA_INDEX_FOUND          --  Found the default Id entry in the
                                            index tree.
        NTFS_QUOTA_INDEX_INSERTED       --  Inserted the default Id entry into
                                            the index tree.
        NTFS_QUOTA_INSERT_FAILED        --  An insertion of the default Id
                                            entry into the index tree failed.
                                            (Probable cause:  out of space.)
        NTFS_QUOTA_ERROR                --  error occurred.  (Possibly out
                                            of memory or out of space.)


--*/
{
    NTFS_INDEX_TREE     OldTree;
    PINDEX_ENTRY        FoundEntry, NewEntry;
    PNTFS_INDEX_BUFFER  ContainingBuffer;
    PQUOTA_USER_DATA    QuotaUserData;
    BOOLEAN             Error;
    DSTRING             IndexName;
    ULONG               Key;
    USHORT              length;

    DebugPtrAssert( VolumeBitmap );

    // Get the existing index out of the FRS.

    if (!IndexName.Initialize(Userid2SidQuotaNameData) ||
        !OldTree.Initialize( GetDrive(),
                             QueryClusterFactor(),
                             VolumeBitmap,
                             GetUpcaseTable(),
                             QuerySize()/2,
                             this,
                             &IndexName ) ) {
        return NTFS_QUOTA_INDEX_NOT_FOUND;   // index not found
    }

    // Search the index for the QUOTA_DEFAULTS_ID record

    Key = QUOTA_DEFAULTS_ID;

    if (!OldTree.QueryEntry(sizeof(ULONG),
                            &Key,
                            0,
                            &FoundEntry,
                            &ContainingBuffer,
                            &Error
                            )) {

        // The default entry not found, let inserts a new one in

        if (ContainingBuffer)
            DELETE(ContainingBuffer);

        if (CheckOnly)
            return NTFS_QUOTA_DEFAULT_ENTRY_MISSING;

        length = QuadAlign(sizeof(INDEX_ENTRY) +
                           sizeof(ULONG) +
                           SIZEOF_QUOTA_USER_DATA);
        if (!(NewEntry = (PINDEX_ENTRY)MALLOC(length)))
            return NTFS_QUOTA_ERROR;

        memset(NewEntry, 0, length);

        NewEntry->DataOffset = sizeof(INDEX_ENTRY)+sizeof(ULONG);
        NewEntry->DataLength = SIZEOF_QUOTA_USER_DATA;
        NewEntry->Length = length;
        NewEntry->AttributeLength = sizeof(ULONG);
        NewEntry->Flags = 0;

        *((ULONG*)GetIndexEntryValue(NewEntry)) = QUOTA_DEFAULTS_ID;

        QuotaUserData = (PQUOTA_USER_DATA)((char*)GetIndexEntryValue(NewEntry) + sizeof(ULONG));
        memset(QuotaUserData, 0, SIZEOF_QUOTA_USER_DATA);

        QuotaUserData->QuotaVersion = QUOTA_USER_VERSION;
        QuotaUserData->QuotaFlags = QUOTA_FLAG_DEFAULT_LIMITS |
                                    QUOTA_FLAG_OUT_OF_DATE;

        QuotaUserData->QuotaThreshold = MAXULONGLONG;
        QuotaUserData->QuotaLimit = MAXULONGLONG;
        NtQuerySystemTime((PLARGE_INTEGER)&(QuotaUserData->QuotaChangeTime));

        if ( !OldTree.InsertEntry( NewEntry )) {
            FREE( NewEntry );
            return NTFS_QUOTA_INSERT_FAILED;
        }

        FREE( NewEntry );

        //
        // replace the old one.
        //
        if( !OldTree.Save( this ) ) {

            return NTFS_QUOTA_ERROR;
        }

        return NTFS_QUOTA_INDEX_INSERTED;

    } else {

        if (ContainingBuffer)
            DELETE(ContainingBuffer);

        return NTFS_QUOTA_INDEX_FOUND;
    }
}


NTFS_SECURITY_CODE
NTFS_FILE_RECORD_SEGMENT::FindSecurityIndexEntryAndValidate(
    IN OUT PNTFS_INDEX_TREE             OldTree,
    IN     PVOID                        Key,
    IN     USHORT                       KeyLength,
    IN     PSECURITY_DESCRIPTOR_HEADER  SecurityDescriptorHeader,
    IN OUT PNTFS_BITMAP                 VolumeBitmap,
    IN     BOOLEAN                      CheckOnly
    )
/*++

Routine Description:

    This method verifies that the given key exists in the specified
    index and that the given security descriptor header matches
    the data in the index entry.  If the given key does not exists
    in the index, one will be inserted into it.

Arguments:

    Key                 --  supplies the search key value
    KeyLength           --  supplies the length of the search key value
    SecurityDescriptorHeader
                        --  supplies the data portion of the index entry
    VolumeBitmap        --  Supplies the bitmap for this volume.
    CheckOnly           --  Supplies a flag which, if true, indicates that
                            this method should only determine whether the
                            index is badly ordered, it should not actually
                            sort it.

Return Value:

    A code indicating the result of the sort:

    Possible return codes for SortIndex:

        NTFS_SECURITY_INDEX_ENTRY_MISSING  --  the specified index entry key
                                               cannot be found in the index
        NTFS_SECURITY_INDEX_FOUND          --  the found entry contains
                                               correct data
        NTFS_SECURITY_INDEX_FIXED          --  the found entry contains invalid
                                               data but is now corrected
        NTFS_SECURITY_INDEX_DATA_ERROR     --  The index was found but the data
                                               data in it is incorrect.
        NTFS_SECURITY_INDEX_INSERTED       --  An index was successfully inserted
                                               into the specified index.
        NTFS_SECURITY_INSERT_FAILED        --  An insertion of an index entry
                                               into the index tree failed.
                                               (Probable cause:  out of space.)
        NTFS_SECURITY_ERROR                --  failed because of an error.
                                               (Probably out of memory or out
                                               of space.)


--*/
{
    PINDEX_ENTRY        foundEntry, newEntry;
    PNTFS_INDEX_BUFFER  containingBuffer;
    BOOLEAN             error;
    USHORT              length;

    DebugPtrAssert( VolumeBitmap );

    // Search the index for the given Key

    if (!OldTree->QueryEntry(KeyLength,
                            Key,
                            0,
                            &foundEntry,
                            &containingBuffer,
                            &error
                            )) {

        if (containingBuffer)
            DELETE(containingBuffer);

        // The entry not found, let inserts a new one in

        if (CheckOnly)
            return NTFS_SECURITY_INDEX_ENTRY_MISSING;

        length = QuadAlign(sizeof(INDEX_ENTRY) +
                                     KeyLength +
                                     sizeof(SECURITY_DESCRIPTOR_HEADER));

        if (!(newEntry = (PINDEX_ENTRY)MALLOC(length)))
            return NTFS_SECURITY_ERROR;

        memset((PVOID)newEntry, 0, length);

        newEntry->DataOffset = sizeof(INDEX_ENTRY)+KeyLength;
        newEntry->DataLength = sizeof(SECURITY_DESCRIPTOR_HEADER);
        newEntry->Length = length;
        newEntry->AttributeLength = KeyLength;
        newEntry->Flags = 0;

        memcpy(GetIndexEntryValue(newEntry), Key, KeyLength);
        memcpy((PCHAR)GetIndexEntryValue(newEntry) + KeyLength,
               (PCHAR)SecurityDescriptorHeader,
               sizeof(SECURITY_DESCRIPTOR_HEADER));

        if ( !OldTree->InsertEntry( newEntry )) {
            FREE( newEntry );
            return NTFS_SECURITY_INSERT_FAILED;
        }

        FREE( newEntry );

        //
        // replace the old one.
        //
        if( !OldTree->Save( this ) ) {

            return NTFS_SECURITY_ERROR;
        }

        return NTFS_SECURITY_INDEX_INSERTED;

    } else {

        if (memcmp((PCHAR)GetIndexEntryValue(foundEntry)+KeyLength,
                   SecurityDescriptorHeader,
                   sizeof(SECURITY_DESCRIPTOR_HEADER))) {

           if (CheckOnly) {
               if (containingBuffer)
                   DELETE(containingBuffer);
               return NTFS_SECURITY_INDEX_DATA_ERROR;
           }

            memcpy((PCHAR)GetIndexEntryValue(foundEntry)+KeyLength,
                   SecurityDescriptorHeader,
                   sizeof(SECURITY_DESCRIPTOR_HEADER));

           if (containingBuffer)
               DELETE(containingBuffer);

            if (!OldTree->DeleteEntry(KeyLength, Key, 0)) {
                return NTFS_SECURITY_ERROR;
            }

            length = QuadAlign(sizeof(INDEX_ENTRY) +
                               KeyLength +
                               sizeof(SECURITY_DESCRIPTOR_HEADER));

            if (!(newEntry = (PINDEX_ENTRY)MALLOC(length)))
                return NTFS_SECURITY_ERROR;

            memset((PVOID)newEntry, 0, length);

            newEntry->DataOffset = sizeof(INDEX_ENTRY)+KeyLength;
            newEntry->DataLength = sizeof(SECURITY_DESCRIPTOR_HEADER);
            newEntry->Length = length;
            newEntry->AttributeLength = KeyLength;
            newEntry->Flags = 0;

            memcpy(GetIndexEntryValue(newEntry), Key, KeyLength);
            memcpy((PCHAR)GetIndexEntryValue(newEntry) + KeyLength,
                   SecurityDescriptorHeader,
                   sizeof(SECURITY_DESCRIPTOR_HEADER));

            if ( !OldTree->InsertEntry( newEntry )) {
                FREE( newEntry );
                return NTFS_SECURITY_INSERT_FAILED;
            }

           FREE( newEntry );

           if (!OldTree->Save(this)) {
               return NTFS_SECURITY_ERROR;
           }

            return NTFS_SECURITY_INDEX_FIXED;
        }

        if (containingBuffer)
           DELETE(containingBuffer);

        return NTFS_SECURITY_INDEX_FOUND;
    }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryDuplicatedInformation(
    OUT PDUPLICATED_INFORMATION DuplicatedInformation
    )
/*++

Routine Description:

    This method queries the FRS for the information which is
    duplicated in File Name attributes.

Arguments:

    DuplicatedInformation   --  Receives the duplicated information.

Return Value:

    TRUE upon successful completion.


--*/
{
    NTFS_ATTRIBUTE          Attribute;
    STANDARD_INFORMATION    StandardInformation;
    EA_INFORMATION          EaInformation;
    REPARSE_DATA_BUFFER     reparse_point;
    ULONG                   BytesRead, ClusterSize;
    BOOLEAN                 Error;

    // Start with a clean slate:
    //
    memset( DuplicatedInformation, 0, sizeof( DUPLICATED_INFORMATION ) );

    // Most of the duplicated information comes from the
    // Standard Information attribute.
    //
    if( !QueryAttribute( &Attribute,
                         &Error,
                         $STANDARD_INFORMATION ) ||
        !Attribute.Read( &StandardInformation,
                         0,
                         sizeof( STANDARD_INFORMATION ),
                         &BytesRead ) ||
        BytesRead != sizeof( STANDARD_INFORMATION ) ) {

        DebugPrintTrace(( "Can't fetch standard information.\n" ));
        return FALSE;
    }

    DuplicatedInformation->CreationTime =
                        StandardInformation.CreationTime;
    DuplicatedInformation->LastModificationTime =
                        StandardInformation.LastModificationTime;
    DuplicatedInformation->LastChangeTime =
                        StandardInformation.LastChangeTime;
    DuplicatedInformation->LastAccessTime  =
                        StandardInformation.LastAccessTime;

    DuplicatedInformation->FileAttributes = StandardInformation.FileAttributes;

    if( _FrsData->Flags & FILE_FILE_NAME_INDEX_PRESENT ) {

        DuplicatedInformation->FileAttributes |= DUP_FILE_NAME_INDEX_PRESENT;
    }

    if( _FrsData->Flags & FILE_VIEW_INDEX_PRESENT ) {

        DuplicatedInformation->FileAttributes |= DUP_VIEW_INDEX_PRESENT;
    }

    // We also need one field from the EA_INFORMATION attribute
    // or the REPARSE_POINT attribute.
    //
    if( !QueryAttribute( &Attribute, &Error, $EA_INFORMATION )) {

        if( Error ) {

            // The Ea Information attribute is present, but we
            // couldn't get it.  Bail out.
            //
            DebugAbort( "Error fetching Ea Information attribute.\n" );
            return FALSE;

        } else if (!QueryAttribute( &Attribute, &Error, $REPARSE_POINT )) {

            if( Error ) {

                // The Reparse Point attribute is present, but we
                // couldn't get it.  Bail out.
                //
                DebugAbort( "Error fetching Reparse Point attribute.\n" );
                return FALSE;
            } else {

                // The Ea Information attribute is not present and there
                // is no Reparse Point, which means this file has no EAs.

                DuplicatedInformation->PackedEaSize = 0;
            }
        } else if ( !Attribute.Read( &reparse_point,
                                     0,
                                     FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                                  GenericReparseBuffer.DataBuffer),
                                     &BytesRead ) ||
                    BytesRead != FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                              GenericReparseBuffer.DataBuffer)) {

            // Couldn't read the Reparse Point data.
            //
            DebugAbort( "Can't read Reparse Point.\n" );
            return FALSE;

        } else {

            // We've got the Reparse Point.
            //
            DuplicatedInformation->ReparsePointTag = reparse_point.ReparseTag;
        }

    } else if( !Attribute.Read( &EaInformation,
                                0,
                                sizeof( EA_INFORMATION ),
                                &BytesRead ) ||
                BytesRead != sizeof( EA_INFORMATION ) ) {

        // Couldn't read the Ea Information data.
        //
        DebugAbort( "Can't read EA Information.\n" );
        return FALSE;

    } else {

        // We've got the Ea Information.
        //
        DuplicatedInformation->PackedEaSize = EaInformation.PackedEaSize;
    }


    // Now we grope the size of the unnamed $DATA attribute and we
    // are done.
    //

    if( !QueryFileSizes( &(DuplicatedInformation->AllocatedLength),
                         &(DuplicatedInformation->FileSize),
                         &Error ) ) {

        if( Error ) {

            // The Data attribute is present, but we couldn't get it.
            //
            DebugAbort( "Error fetching $DATA attribute.\n" );
            return FALSE;

        } else {

            // This file has no unnamed $DATA attribute.
            //
            DuplicatedInformation->AllocatedLength = 0;
            DuplicatedInformation->FileSize = 0;
        }

    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::UpdateFileNames(
    IN     PDUPLICATED_INFORMATION  DuplicatedInformation,
    IN OUT PNTFS_INDEX_TREE         Index,
    IN     BOOLEAN                  IgnoreExternal
    )
/*++

Routine Description:

    This method propagates

Arguments:

    DuplicatedInformation   --  Supplies the duplicated information which
                                is to be propagated into the File Names.
    Index                   --  Supplies the index for the directory which
                                contains this FRS.  It may be NULL, in which
                                case changes are not propagated to the index.
    IgnoreExternal          --  Supplies a flag which, if TRUE, indicates
                                that this method should only update file
                                names in this FRS, and not in its children.

Return Value:

    TRUE upon successful completion.

Notes:

    This method only propagates changes to the supplied index; thus,
    if a file is indexed by more than one directory, changes can
    only be propagated to one directory.  However, all entries for
    this file in the supplied index will be updated.

--*/
{
    NTFS_ATTRIBUTE_RECORD CurrentRecord;
    DSTRING Name;
    MFT_SEGMENT_REFERENCE SegmentReference;

    PNTFS_FILE_RECORD_SEGMENT ChildFrs;
    LCN TargetFileNumber;
    VCN LowestVcn;
    ATTRIBUTE_TYPE_CODE CurrentType;
    PFILE_NAME CurrentName;
    PVOID CurrentRecordData;
    ULONG ValueLength;
    USHORT Tag;

    // Make sure that the supplied index, if any, is constructed
    // over the FILE_NAME attribute:

    if( Index != NULL &&
        Index->QueryIndexedAttributeType() != $FILE_NAME ) {

        DebugAbort( "Updating file names in an index that's not over $FILE_NAME.\n" );
        return FALSE;
    }

    // Force the attribute list, if we have one, into memory.
    //
    if( !SetupAttributeList() ) {

        return FALSE;
    }

    if( !IgnoreExternal &&
        _AttributeList != NULL ) {

        ATTR_LIST_CURR_ENTRY        Entry;

        Entry.CurrentEntry = NULL;
        while (_AttributeList->QueryNextEntry( &Entry,
                                               &CurrentType,
                                               &LowestVcn,
                                               &SegmentReference,
                                               &Tag,
                                               &Name )) {

            if( CurrentType == $FILE_NAME ) {

                // The current entry represents a record for a
                // File Name attribute, which we may wish to
                // update.  Figure out what FRS it's in:

                TargetFileNumber.Set( SegmentReference.LowPart,
                                        (LONG) SegmentReference.HighPart );

                if( TargetFileNumber == QueryFileNumber() ) {

                    // This file name is in the base FRS, ie. in
                    // this FRS.  Call this method recursively,
                    // with IgnoreExternal TRUE to limit the
                    // recursion.

                    if( !UpdateFileNames( DuplicatedInformation,
                                          Index,
                                          TRUE ) ) {
                        return FALSE;
                    }

                } else {

                    // This attribute is in a child FRS.  Get the
                    // child and update any file names in it.  Note
                    // Note that we can ignore external names in
                    // the child, since child FRS's cannot have
                    // children.  (Note also that this will preemptively
                    // update any other names in that child, which is
                    // fine.
                    //
                    if( (ChildFrs = SetupChild( TargetFileNumber )) == NULL ||
                        !ChildFrs->UpdateFileNames( DuplicatedInformation,
                                                    Index,
                                                    TRUE ) ) {

                        return FALSE;
                    }
                }
            }
        }

    } else {

        // Crawl through the records in this FRS looking for File Names.
        //
        CurrentRecordData = NULL;

        while( (CurrentRecordData =
                GetNextAttributeRecord( CurrentRecordData )) != NULL ) {

            // Note that GetNextAttributeRecord always returns a
            // structurally-sound attribute record, which we can
            // pass directly to this flavor of Initialize, which
            // in turn will always succeed.  It is also important
            // that this flavor of initialize will cause the
            // attribute record to use directly the data in the
            // File Record Segment, so we can twiddle it there.
            //
            if( !CurrentRecord.Initialize( GetDrive(), CurrentRecordData ) ) {

                DebugAbort( "Can't initialize attribute record.\n" );
                return FALSE;
            }

            if( CurrentRecord.QueryTypeCode() == $FILE_NAME ) {

                // It's a file name.

                CurrentName = (PFILE_NAME)
                           (CurrentRecord.GetResidentValue() );

                ValueLength = CurrentRecord.QueryResidentValueLength();

                // Perform sanity checks--the attribute must be resident,
                // big enough to be a File Name, and big enough to hold
                // the name it claims to be.
                //
                if( CurrentName == NULL ||
                    ValueLength < sizeof( FILE_NAME ) ||
                    ValueLength < (ULONG)FIELD_OFFSET( FILE_NAME, FileName ) +
                                  CurrentName->FileNameLength ) {

                    DebugAbort( "Corrupt file name.\n" );
                    return FALSE;
                }

                // OK, it's a valid file name.  Update the duplicated
                // information and propagate duplicated information and
                // file name bits back to the index entry.
                //
                memcpy( &(CurrentName->Info),
                        DuplicatedInformation,
                        sizeof( DUPLICATED_INFORMATION ) );

                // Update the corresponding entry in the index.
                //

                SegmentReference = ( IsBase() ) ?
                        QuerySegmentReference() :
                        QueryBaseFileRecordSegment();


                if( Index != NULL &&
                    !Index->UpdateFileName( CurrentName,
                                            SegmentReference ) ) {

                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}



VOID
NTFS_FILE_RECORD_SEGMENT::SetLsn(
    IN  BIG_INT NewLsn
    )
/*++

Routine Description:

    This method sets the Lsn for the File Record Segment
    and any of its children which are in memory.

Arguments:

    NewLsn  --  Supplies the new LSN for this File Record
                Segment and any available children.

Return Value:

    None.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   CurrentChild;

    _FrsData->Lsn = NewLsn.GetLargeInteger();

    _ChildIterator->Reset();

    while( (CurrentChild = (PNTFS_FILE_RECORD_SEGMENT)
                           _ChildIterator->GetNext()) != NULL ) {

        CurrentChild->SetLsn( NewLsn );
    }
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Backtrack(
    OUT PWSTRING Path
    )
/*++

Routine Description:

    This function finds a path from the root to this FRS.  Note
    that it does not detect cycles, and may enter into an infinite
    loop if there is a cycle in the logical directory structure.

    Note that the client must read this FRS before calling Backtrack.

Arguments:

    Path    --  Receives the path.

Return Value:

    TRUE upon successful completion.

--*/
{
    // First, check to see if this is the Root
    //
    if( QueryFileNumber() == ROOT_FILE_NAME_INDEX_NUMBER ) {

        return( Path->Initialize( "\\" ) );
    }

    // Initialize the path to the empty string and then pass it
    // to the worker routine.
    //
    return( Path->Initialize( "" ) &&
            BacktrackWorker( Path ) );
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::BacktrackWorker(
            IN OUT PWSTRING Path
            )
/*++

Routine Description:

    This member function is a private worker routine for Backtrack;
    it performs the actual work of constructing the path from the
    root to this FRS.

Arguments:

    Path    --  Receives the path to this FRS.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE FileNameAttribute;
    NTFS_FILE_RECORD_SEGMENT ParentFrs;
    VCN ParentFileNumber;
    PCFILE_NAME FileName;
    DSTRING FileNameString, Backslash;
    BOOLEAN Error;

    // Short circuit if this is the root--it doesn't add
    // anything to the path.
    //
    if( QueryFileNumber() ==  ROOT_FILE_NAME_INDEX_NUMBER ) {

        return TRUE;
    }

    // Extract a name from the FRS.  Any name will do.
    //
    if( !QueryAttribute( &FileNameAttribute, &Error, $FILE_NAME ) ||
        !FileNameAttribute.IsResident() ) {

        return FALSE;
    }

    FileName = (PCFILE_NAME)FileNameAttribute.GetResidentValue();

    ParentFileNumber.Set( FileName->ParentDirectory.LowPart,
                          (LONG)FileName->ParentDirectory.HighPart );

    // If the parent FRS is not the root, initialize and read it,
    // and then recurse into it.
    //
    if( ParentFileNumber != ROOT_FILE_NAME_INDEX_NUMBER &&
        (!ParentFrs.Initialize( ParentFileNumber, _Mft ) ||
         !ParentFrs.Read() ||
         !ParentFrs.Backtrack( Path ) ) ) {

        return FALSE;
    }

    // Now add this FRS's name to the path.
    //
    if( !Backslash.Initialize( "\\" ) ||
        !FileNameString.Initialize( NtfsFileNameGetName( FileName ),
                                    FileName->FileNameLength ) ||
        !Path->Strcat( &Backslash ) ||
        !Path->Strcat( &FileNameString ) ) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_FILE_RECORD_SEGMENT::AddChild(
    PNTFS_FILE_RECORD_SEGMENT ChildFrs
    )
/*++

Routine Description:

    This method adds a child File Record Segment to the list of
    children.  Management of that File Record Segment then passes
    to the list.

Arguments:

    ChildFrs    -- supplies a pointer to the child File Record Segment.

Return Value:

    TRUE upon successful completion.

--*/
{
    _ChildIterator->Reset();

    return( _Children.Insert( ChildFrs, _ChildIterator ) );
}



PNTFS_FILE_RECORD_SEGMENT
NTFS_FILE_RECORD_SEGMENT::GetChild(
    VCN FileNumber
    )
/*++

Routine Description:

    This method finds a File Record Segment in the list of children
    based on its File Number.

Arguments:

    FileNumber  -- supplies the file number of the desired child.

Return Value:

    A pointer to the desired File Record Segment.  Note that this
    object belongs to the child list, and should not be deleted by
    the client.

    NULL if the desired child could not be found in the list.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT CurrentChild;

    // Spin through the list of children until we run out or find
    // one with the appropriate VCN.

    _ChildIterator->Reset();

    while( (CurrentChild =
            (PNTFS_FILE_RECORD_SEGMENT)_ChildIterator->GetNext()) != NULL &&
           CurrentChild->QueryFileNumber() != FileNumber );

    // If there is a matching child in the list, CurrentChild now points
    // at it; otherwise, CurrentChild is NULL.

    return CurrentChild;
}


PNTFS_FILE_RECORD_SEGMENT
NTFS_FILE_RECORD_SEGMENT::SetupChild(
    IN VCN  FileNumber
    )
/*++

Routine Description:

    This method sets up a child FRS.  If the desired child is already
    in the list, it is returned; otherwise, it is allocated and read
    and added to the list, and the returned.

Arguments:

    FileNumber  --  Supplies the file number of the desired child.

Return Value:

    A pointer to the child FRS, or NULL to indicate error.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT ChildFrs;
    PNTFS_MFT_FILE MftFile;

    if( (ChildFrs = GetChild( FileNumber )) != NULL ) {

        // The child is already in the list.
        //
        return ChildFrs;
    }

    // Allocate a new FRS object, initialize it to be the
    // child we want, read it in, and add it to the list.
    //
    if( (ChildFrs = NEW NTFS_FILE_RECORD_SEGMENT) == NULL ) {

        return NULL;
    }

    if( _Mft != NULL ) {

        // This is an ordinary, run-of-the-mill File Record
        // Segment, so just initialize the child with the
        // same MFT as this object was initialized with.
        //
        if( !ChildFrs->Initialize( FileNumber, _Mft ) ||
            !ChildFrs->Read() ||
            !AddChild( ChildFrs ) ) {

            DELETE( ChildFrs );
            return NULL;
        }

    } else {

        // This File Record Segment is really the
        // MFT file itself, so we have to do some
        // arcane gesticulation.  Since we know this
        // is really an NTFS_MFT_FILE object, we'll
        // dynamically cast it to that class, and
        // then pass it in as the NTFS_MFT_FILE to
        // initialize the child.
        //
        if( QueryClassId() != NTFS_MFT_FILE_cd->QueryClassId() ) {

            DELETE( ChildFrs );
            return FALSE;
        }

        MftFile = (PNTFS_MFT_FILE)( this );

        if( !ChildFrs->Initialize( FileNumber, MftFile ) ||
            !ChildFrs->Read() ||
            !AddChild( ChildFrs ) ) {

            DELETE( ChildFrs );
            return FALSE;
        }
    }

    return ChildFrs;
}


VOID
NTFS_FILE_RECORD_SEGMENT::DeleteChild(
    VCN FileNumber
    )
/*++

Routine Description:

    This method removes a File Record Segment from the list of
    children based on its File Number.

Arguments:

    FileNumber  -- supplies the file number of the child to delete.

Return Value:

    None.

Notes:

    Since the list manages the File Record Segments which it has been
    given, it deletes the File Record Segment in question.

    This method assumes that only one matching child exists (since the
    same File Record Segment should not appear twice in the list).

--*/
{
    PNTFS_FILE_RECORD_SEGMENT CurrentChild, ChildToDelete;

    // Spin through the list of children until we run out or find
    // one with the appropriate VCN.

    _ChildIterator->Reset();

    while( (CurrentChild =
            (PNTFS_FILE_RECORD_SEGMENT)_ChildIterator->GetNext()) != NULL &&
           CurrentChild->QueryFileNumber() != FileNumber );

    // If there is a matching child in the list, the iterator's current
    // state points at it and CurrentChild is non-NULL.

    if( CurrentChild != NULL ) {

        // A matching child was found; remove it from the list
        // and delete it.

        ChildToDelete = (PNTFS_FILE_RECORD_SEGMENT)
                        _Children.Remove( _ChildIterator );

        DebugAssert( ChildToDelete == CurrentChild );

        DELETE( ChildToDelete );
    }
}

BOOLEAN
NTFS_FILE_RECORD_SEGMENT::Delete(
    IN OUT PNTFS_BITMAP         VolumeBitmap
)
/*++

Routine Description:

    This method frees all the attributes within an FRS and finally
    frees the FRS itself.

Arguments:

    VolumeBitmap        - Supplies the volume bitmap.

Return Value:

    TRUE    - Success
    FALSE   - Failure

Notes:

--*/
{
    DSTRING                 name;
    ULONG                   type = 0;
    NTFS_ATTRIBUTE          attrib;
    BOOLEAN                 error;
    BOOLEAN                 rst = TRUE;
    NUMBER_SET              frs_involved;
    ULONG                   index;

    if (!name.Initialize("") ||
        !frs_involved.Initialize())
        return FALSE;

    while (QueryNextAttribute(&type, &name) && type != $END) {
        if (QueryAttribute(&attrib, &error, type, &name)) {
            if (!attrib.IsResident())
                rst = attrib.Resize(0, VolumeBitmap) && rst;
            rst = PurgeAttribute(type, &name) && rst;
            type = 0;
        } else if (error) {
            DebugPrintTrace(("Unable to Query attribute type %d of FRS %d",
                            type, QueryFileNumber().GetLowPart()));
            return FALSE;
        }
    }

    //
    // Delete the attribute list itself if there is one
    //
    if (IsAttributePresent($ATTRIBUTE_LIST)) {
        if (QueryAttributeListAttribute(&attrib, &error)) {
            if (!attrib.IsResident())
                rst = attrib.Resize(0, VolumeBitmap) && rst;
            rst = PurgeAttribute($ATTRIBUTE_LIST) && rst;
        } else if (error) {
            DebugPrintTrace(("Unable to Query attribute list of FRS %d",
                            QueryFileNumber().GetLowPart()));
            return FALSE;
        }
        DELETE(_AttributeList);
    }

    ClearInUse();

    rst = Write() && rst;
    rst = Flush(VolumeBitmap, NULL, TRUE) && rst;

    rst = _Mft->FreeFileRecordSegment(QueryFileNumber()) && rst;

    return rst;
}


UNTFS_EXPORT
BOOLEAN
NTFS_FILE_RECORD_SEGMENT::QueryAttributeListAttribute (
    OUT PNTFS_ATTRIBUTE     AttrList,
    OUT PBOOLEAN            Error
)
/*++

Routine Description:

   This function fetches the attribute list associated with the
   File Record Segment.

Arguments:

    AttrList    --  Receives (ie. is initialized to) the attribute.  Note
                    that this parameter may be uninitialized on entry, and
                    may be left uninitialized if this method fails.
    Error       --  Receives TRUE if the method fails because of an error.

Return Value:

    TRUE upon successful completion.

Notes:

    If the method returns TRUE, *Error should be ignored.  If it
    returns FALSE, *Error will be set to TRUE if the failure resulted
    from an error (out of memory, corrupt structure); otherwise, the
    caller may assume that the attribute is not present.

    This method assumes the attribute list is local to the File Record Segment.

--*/
{
    NTFS_ATTRIBUTE_RECORD Record;

    DebugPtrAssert( AttrList );
    DebugPtrAssert( Error );

    DebugPtrAssert( _FrsData );

    // Assume innocent until proven guilty:

    *Error = FALSE;

    if( !IsAttributePresent( $ATTRIBUTE_LIST, NULL, TRUE ) ) {

      // there is no matching attribute.

        return FALSE;
    }

    // Now that we've determined that the attribute is present,
    // this method can only fail because of an error.

    *Error = TRUE;


    if( !SetupAttributeList() ) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_SETUP_ATTR_LIST,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        return FALSE;
    }

    // Get the first attribute record.

    if (!QueryAttributeRecord(&Record, $ATTRIBUTE_LIST)) {

        PIO_DP_DRIVE    drive = GetDrive();

        if (drive) {
            PMESSAGE msg = drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_CANNOT_FIND_ATTR_LIST_ATTR,
                         "%I64x", QueryFileNumber().GetLargeInteger());
            }
        }

        return FALSE;
    }

    // Initialize the Attribute with the first attribute record.

    if ( !AttrList->Initialize( GetDrive(),
                                QueryClusterFactor(),
                                &Record ) ) {

        return FALSE;
    }

    *Error = FALSE;
    return TRUE;
}

BOOLEAN
NTFS_FILE_RECORD_SEGMENT::PurgeAttributeList (
)
/*++

Routine Description:

   This function purges the attribute list off the File Record Segment.

Arguments:

    N/A

Return Value:

    TRUE upon successful completion.

Notes:
   It is the user's responsibility to make sure that all segment reference
   in the attribute list points back to the base frs.

--*/
{
    DELETE(_AttributeList);
    return PurgeAttribute($ATTRIBUTE_LIST, NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\indxbuff.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    indxbuff.hxx

Abstract:

    This module contains the member function definitions for
    NTFS_INDEX_BUFFER, which models index buffers in an Index
    Allocation attribute.

    These buffers are the component blocks of a b-tree, which
    is rooted in the matching Index Root attribute.

Author:

    Bill McJohn (billmc) 04-Sept-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"
#include "ntfssa.hxx"

#include "drive.hxx"

#include "attrib.hxx"
#include "indxbuff.hxx"

DEFINE_CONSTRUCTOR( NTFS_INDEX_BUFFER, OBJECT );

NTFS_INDEX_BUFFER::~NTFS_INDEX_BUFFER(
    )
{
    Destroy();
}


VOID
NTFS_INDEX_BUFFER::Construct(
    )
/*++

Routine Description:

    This method is the worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _ClustersPerBuffer = 0;
    _BufferSize = 0;
    _ClusterSize = 0;
    _ThisBufferVcn = 0;
    _CollationRule = COLLATION_NUMBER_RULES;
    _UpcaseTable = NULL;
}


VOID
NTFS_INDEX_BUFFER::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _ClustersPerBuffer = 0;
    _ThisBufferVcn = 0;
    _ClusterSize = 0;
    _BufferSize = 0;
    _CollationRule = COLLATION_NUMBER_RULES;
    _UpcaseTable = NULL;
}


BOOLEAN
NTFS_INDEX_BUFFER::Initialize(
    IN PCLOG_IO_DP_DRIVE    Drive,
    IN VCN                  ThisBufferVcn,
    IN ULONG                ClusterSize,
    IN ULONG                ClustersPerBuffer,
    IN ULONG                BufferSize,
    IN COLLATION_RULE       CollationRule,
    IN PNTFS_UPCASE_TABLE   UpcaseTable
    )
/*++

Routine Description:

    This method initializes an NTFS_INDEX_BUFFER.  Note that this class
    is reinitializable.

Arguments:

    Drive               --  supplies the drive on which the index resides.
    ThisBufferVcn       --  supplies the this buffer's VCN within the
                            index allocation attribute for the containing
                            index.
    ClusterSize         --  supplies the size of a cluster on this volume.
    ClustersPerBuffer   --  supplies the number of clusters per index
                            allocation buffer in this index b-tree.
    BufferSize          --  size of the buffer in bytes.
    CollationRule       --  supplies the collation rule for this index.
    UpcaseTable         --  supplies the volume upcase table.

Either the ClustersPerBuffer or the BufferSize may be zero, but not
both.  If BufferSize is zero, then we're doing an old-style buffer where
each buffer is at least one cluster.  If ClustersPerBuffer is zero, then
we're doing a new-style buffer where the buffer size may be a fraction of
the cluster size.

Return Value:

    TRUE upon successful completion.

--*/
{
    DebugPtrAssert( Drive );
    DebugAssert( ClusterSize != 0 );
    DebugAssert( BufferSize != 0 || ClustersPerBuffer != 0 );

    Destroy();

    _ClusterSize = ClusterSize;
    _ClustersPerBuffer = ClustersPerBuffer;
    _BufferSize = BufferSize;
    _ThisBufferVcn = ThisBufferVcn;
    _CollationRule = CollationRule;
    _UpcaseTable = UpcaseTable;

    if( !_Mem.Initialize() ||
        (_Data = (PINDEX_ALLOCATION_BUFFER)
                 _Mem.Acquire( BufferSize,
                               Drive->QueryAlignmentMask() )) == NULL ) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


VOID
NTFS_INDEX_BUFFER::Create(
    IN BOOLEAN  IsLeaf,
    IN VCN      EndEntryDownpointer
    )
/*++

Arguments:

    IsLeaf  --              supplies a flag indicating whether this is a
                            leaf block (TRUE) or a node block (FALSE).
    EndEntryDownpointer --  supplies the B-Tree downpointer for the end
                            entry.  (This parameter is ignored if IsLeaf
                            is TRUE.)

Return Value:

    None.

--*/
{
    PINDEX_ENTRY EndEntry;

    DebugPtrAssert( _Data );

    // The layout of an index buffer is:
    //  Index Allocation Buffer Header
    //  Update Sequence Array
    //  First Entry.

    memset( _Data, 0, QuerySize() );

    // Write the 'FILE' signature in the MultiSectorHeader.

    memcpy( _Data->MultiSectorHeader.Signature,
            "INDX",
            4 );

    // Compute the number of Update Sequence Numbers in the
    // update array.  This number is (see ntos\inc\cache.h):
    //
    //      n/SEQUENCE_NUMBER_STRIDE + 1
    //
    // where n is the number of bytes in the protected structure
    // (in this case, an index allocation buffer ).

    _Data->MultiSectorHeader.UpdateSequenceArraySize =
            (USHORT)(QuerySize()/SEQUENCE_NUMBER_STRIDE + 1);

    _Data->MultiSectorHeader.UpdateSequenceArrayOffset =
        (USHORT)((PBYTE)&(_Data->UpdateSequenceArray) - (PBYTE)_Data);

    _Data->Lsn.LowPart = 0;
    _Data->Lsn.HighPart = 0;

    _Data->ThisVcn = _ThisBufferVcn;
    _Data->IndexHeader.Flags = IsLeaf ? 0 : INDEX_NODE;


    _Data->IndexHeader.FirstIndexEntry =
        QuadAlign( _Data->MultiSectorHeader.UpdateSequenceArrayOffset +
                   _Data->MultiSectorHeader.UpdateSequenceArraySize *
                       sizeof(UPDATE_SEQUENCE_NUMBER));

    // the first entry is the end entry.  The only fields in it that
    // matter are the length, the flags, and the downpointer (if any).

    EndEntry = (PINDEX_ENTRY)((PBYTE)&(_Data->IndexHeader) +
                                 _Data->IndexHeader.FirstIndexEntry);


    EndEntry->Length = NtfsIndexLeafEndEntrySize;
    EndEntry->AttributeLength = 0;
    EndEntry->Flags = INDEX_ENTRY_END;

    if( !IsLeaf ) {

        EndEntry->Flags |= INDEX_ENTRY_NODE;
        EndEntry->Length += sizeof(VCN);
        GetDownpointer(EndEntry) = EndEntryDownpointer;
    }


    _Data->IndexHeader.FirstFreeByte =
            _Data->IndexHeader.FirstIndexEntry + EndEntry->Length;

    _Data->IndexHeader.BytesAvailable =
        QuerySize() - (ULONG)( (PBYTE)&(_Data->IndexHeader) - (PBYTE)_Data );

}



BOOLEAN
NTFS_INDEX_BUFFER::Read(
    IN OUT PNTFS_ATTRIBUTE AllocationAttribute
    )
/*++

Routine Description:

    This method reads the index allocation buffer.

Arguments:

    AllocationAttribute --  supplies the Index Allocation Attribute
                            that describes the allocation for this
                            b-tree.

Return Value:

    TRUE upon successful completion

--*/
{
    ULONG           BytesRead;
    BOOLEAN         Result;
    PINDEX_ENTRY    CurrentEntry;
    ULONG           RemainingSpace, FirstEntryOffset;
    BIG_INT         AttributeOffset;
    PMESSAGE        msg;
    PIO_DP_DRIVE    drive;

    DebugPtrAssert( AllocationAttribute );

    drive = AllocationAttribute->GetDrive();
    DebugAssert(drive);
    msg = drive ? drive->GetMessage() : NULL;

    if (_BufferSize < _ClusterSize) {
        AttributeOffset = NTFS_INDEX_BLOCK_SIZE * QueryVcn();
    } else {
        AttributeOffset = _ClusterSize * QueryVcn();
    }

    Result = AllocationAttribute->Read( _Data,
                                        AttributeOffset,
                                        QuerySize(),
                                        &BytesRead ) &&
             BytesRead == QuerySize() &&
             NTFS_SA::PostReadMultiSectorFixup( _Data,
                                                BytesRead,
                                                drive,
                                                _Data->IndexHeader.FirstFreeByte );

    // if the read succeeded, sanity-check the buffer.
    //
    if( Result ) {

        CurrentEntry = GetFirstEntry();
        FirstEntryOffset = (ULONG)((PBYTE)CurrentEntry - (PBYTE)_Data);

        if( FirstEntryOffset > QuerySize() ) {

            // The first entry pointer is completely wrong.
            //
            Result = FALSE;

        } else {

            RemainingSpace = QuerySize() - FirstEntryOffset;

            while( TRUE ) {

                if( NTFS_INDEX_TREE::IsIndexEntryCorrupt( CurrentEntry,
                                                          RemainingSpace,
                                                          msg ) ) {

                    Result = FALSE;
                    break;
                }

                if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

                    break;
                }

                RemainingSpace -= CurrentEntry->Length;
                CurrentEntry = GetNextEntry( CurrentEntry );
            }
        }
    }

    return Result;
}


BOOLEAN
NTFS_INDEX_BUFFER::Write(
    IN OUT PNTFS_ATTRIBUTE AllocationAttribute
    )
/*++

Routine Description:

    This method writes the index allocation buffer.

Arguments:

    AllocationAttribute --  supplies the Index Allocation Attribute
                            that describes the allocation for this
                            b-tree.

Return Value:

    TRUE upon successful completion

--*/
{
    ULONG BytesWritten;
    BIG_INT Offset;
    BOOLEAN r;

    DebugPtrAssert( AllocationAttribute );

    NTFS_SA::PreWriteMultiSectorFixup( _Data, QuerySize() );

    if (_ClusterSize <= QuerySize()) {
        Offset = _ClusterSize * QueryVcn();
    } else {
        Offset = NTFS_INDEX_BLOCK_SIZE * QueryVcn();
    }

    r = AllocationAttribute->Write( _Data,
                                    Offset,
                                    QuerySize(),
                                    &BytesWritten, NULL ) &&
        BytesWritten == QuerySize();

    NTFS_SA::PostReadMultiSectorFixup( _Data,
                                       QuerySize(),
                                       NULL );

    return r;
}



BOOLEAN
NTFS_INDEX_BUFFER::FindEntry(
    IN      PCINDEX_ENTRY       SearchEntry,
    IN OUT  PULONG              Ordinal,
    OUT     PINDEX_ENTRY*       EntryFound
    )
/*++

Routine Description:

    This method locates an entry in the index buffer.  Note that it
    does not recurse into the buffer's children (if any).  If no matching
    entry is found, it returns the first entry which is greater than
    the desired entry; if the search key is greater than all the entries
    in the buffer, it returns the END entry.

Arguments:

    SearchEntry --  Supplies an entry with the search key and length.
                    (Note that this entry has a meaningless file reference).
    Ordinal     --  supplies an ordinal showing which matching entry
                    to return; see note below.
    EntryFound  --  receives a pointer to the located entry.  Receives
                    NULL if an error has occurred.

Return Value:

    TRUE if a matching entry is found.  If an error occurs, *EntryFound
    is set to NULL.  If no error occurs, and no matching entry is found,
    *EntryFound is set to the next entry (i.e. the point at which the
    search key would be inserted into this buffer).

Notes:

    This method assumes that the index buffer is consistent.

    The ordinal argument indicates how many matching entries should be
    passed over before one is returned.  When an entry is found which
    matches the search key, if *Ordinal is zero, that entry is returned;
    otherwise, *Ordinal is decremented, and the FindEntry goes on to
    the next entry.

    If *Ordinal is INDEX_SKIP, then all matching entries are skipped.

--*/
{
    PINDEX_ENTRY CurrentEntry;
    BOOLEAN Found;
    int CompareResult;

    CurrentEntry = GetFirstEntry();
    Found = FALSE;

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        CompareResult = CompareNtfsIndexEntries( SearchEntry,
                                                 CurrentEntry,
                                                 _CollationRule,
                                                 _UpcaseTable );

        if( CompareResult < 0 ) {

            // The search value is less than the current entry's
            // value, so we've overshot where our search key would
            // be.  Stop (and return the current entry).

            break;

        } else if( CompareResult == 0 ) {

            // The current entry matches the search entry.  Check
            // the ordinal argument to see if we should return this
            // entry or skip it.

            if( *Ordinal == 0 ) {

                Found = TRUE;
                break;

            } else if( *Ordinal != INDEX_SKIP ) {

                *Ordinal -= 1;
            }
        }

        // Haven't found our entry, so we'll just go on to the next.

        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    *EntryFound = CurrentEntry;
    return( Found );
}


BOOLEAN
NTFS_INDEX_BUFFER::InsertEntry(
    IN  PCINDEX_ENTRY   NewEntry,
    IN  PINDEX_ENTRY    InsertPoint
    )
/*++

Routine Description:

    This method inserts an index entry into the buffer.

Arguments:

    NewEntry    --  Supplies the entry to insert.
    InsertPoint --  supplies the point in the buffer at which this entry
                    should be inserted, if known.  This parameter may be
                    NULL, in which case the buffer determines where to
                    insert the new entry.

Return Value:

    TRUE upon successful completion.  A return value of FALSE indicates
    that the entry will not fit in the buffer.

Notes:

    This method assumes that the buffer is consistent.

    InsertPoint should be a pointer previously returned from FindEntry;
    otherwise, this method will go badly astray.

--*/
{
    ULONG Ordinal, BytesToCopy;

    // First, check to see if there's enough room:

    if( _Data->IndexHeader.FirstFreeByte + NewEntry->Length >
        _Data->IndexHeader.BytesAvailable ) {

        return FALSE;
    }

    // We know there's enough space, so we know we'll succeed.

    if( InsertPoint == NULL ) {

        // The client has not supplied the insert point, so we get to
        // figure it out for ourselves.  Fortunately, we can get FindEntry
        // to do our work for us.

        // Note that we don't care what InsertEntry returns--we know it
        // won't hit an error, and we don't care whether there are any
        // matching entries in the buffer.  (If we get a matching buffer,
        // we insert the new one before it, which is just fine.)

        Ordinal = 0;

        FindEntry( NewEntry,
                   &Ordinal,
                   &InsertPoint );

        DebugPtrAssert( InsertPoint );
    }

    // Now we just make room for the entry and jam it in.

    BytesToCopy = _Data->IndexHeader.FirstFreeByte -
                  (ULONG)((PBYTE)InsertPoint - (PBYTE)&(_Data->IndexHeader));

    memmove( (PBYTE)InsertPoint + NewEntry->Length,
             InsertPoint,
             BytesToCopy );

    _Data->IndexHeader.FirstFreeByte += NewEntry->Length;

    memcpy( InsertPoint, NewEntry, NewEntry->Length );

    return TRUE;
}


VOID
NTFS_INDEX_BUFFER::RemoveEntry(
    IN  PINDEX_ENTRY    EntryToRemove
    )
/*++

Routine Description:

    This method removes an entry from the index buffer, closing up
    the buffer over it.

Arguments:

    EntryToRemove   --  supplies a pointer to the entry to remove.

Return Value:

    None.  This method always succeeds.

Notes:

    This method assumes that the index buffer is consistent.

    EntryToRemove must be a pointer that was returned by a previous
    call (with no intervening inserts or deletes) to FindEntry or
    GetFirstEntry.

--*/
{
    PBYTE NextEntry;
    ULONG BytesToCopy;

    NextEntry = (PBYTE)EntryToRemove + EntryToRemove->Length;

    BytesToCopy = _Data->IndexHeader.FirstFreeByte -
                  (ULONG)(NextEntry - (PBYTE)&(_Data->IndexHeader));

    _Data->IndexHeader.FirstFreeByte -= EntryToRemove->Length;

    memmove( EntryToRemove,
             NextEntry,
             BytesToCopy );

}



PINDEX_ENTRY
NTFS_INDEX_BUFFER::FindSplitPoint(
    )
/*++

Routine Description:

    This method finds a point at which the index allocation buffer
    would like to be split.

Arguments:

    None.

Return Value:

    A pointer to the entry which will be promoted in the split.

    Note that we can return any non-end entry, but we cannot return
    the end entry.

--*/
{
    PINDEX_ENTRY CurrentEntry, PreviousEntry, NextEntry;
    ULONG CurrentOffset;


    CurrentOffset = _Data->IndexHeader.FirstIndexEntry;
    CurrentEntry = GetFirstEntry();

    DebugAssert( !(CurrentEntry->Flags & INDEX_ENTRY_END) );

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) &&
           CurrentOffset < _Data->IndexHeader.FirstFreeByte/2 ) {

        PreviousEntry = CurrentEntry;
        CurrentOffset += CurrentEntry->Length;
        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    // We need to make sure we don't pick the last entry in the buffer
    // to split before; the entry just after the split point gets promoted
    // to the parent buffer, which would leave us with an empty buffer.
    //

    if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

        // Oops!  Back up one.  [XXX.mjb: really need to back up *two*
        // in this case, because the last entry is just a marker to hold
        // the flag, it's not a true entry.]
        //

        CurrentEntry = PreviousEntry;

    } else {

        NextEntry = GetNextEntry( CurrentEntry );

        if( NextEntry->Flags & INDEX_ENTRY_END ) {

            CurrentEntry = PreviousEntry;
        }
    }

    return CurrentEntry;
}


VOID
NTFS_INDEX_BUFFER::InsertClump(
    IN ULONG    LengthOfClump,
    IN PCVOID   Clump
    )
/*++

Routine Description:

    This method inserts a clump of entries at the beginning of
    the buffer.  It is used to insert entries into a newly-created
    buffer.

Arguments:

    LengthOfClump   --  supplies the number of bytes to insert
    Clump           --  supplies the source from which the data
                        is to be copied.

Return Value:

    None.

Notes:

    This private method should be used with care; the client must
    ensure that the entries being inserted are valid, and that they
    will not cause the buffer to overflow.

--*/
{
    ULONG BytesToMove;
    PBYTE InsertPoint;

    DebugAssert( _Data->IndexHeader.FirstFreeByte + LengthOfClump <=
               _Data->IndexHeader.BytesAvailable );

    // We'll insert the new entries in front of the first entry in
    // the buffer, which means we have to shift all the existing
    // entries up to make room.

    InsertPoint = (PBYTE)GetFirstEntry();

    BytesToMove = _Data->IndexHeader.FirstFreeByte -
                    _Data->IndexHeader.FirstIndexEntry;

    memmove( InsertPoint + LengthOfClump,
             InsertPoint,
             BytesToMove );

    // Copy the new entries into the space we just created:

    memcpy( InsertPoint,
            Clump,
            LengthOfClump );

    // Adjust the offset of the First Free Byte to reflect
    // what we just did:

    _Data->IndexHeader.FirstFreeByte += LengthOfClump;

}


VOID
NTFS_INDEX_BUFFER::RemoveClump(
    IN ULONG    LengthOfClump
    )
/*++

Routine Description:

    This method removes a clump of entries from the beginning of
    the index buffer.  It's particularly useful when splitting
    a buffer.

Arguments:

    LengthOfClump   --  supplies the number of bytes to remove from
                        the index buffer.

Return Value:

    None.

Notes:

    This private method should be used with care; the client must
    ensure that the number of bytes to be removed covers a valid
    clump of entries, and does not include (or extend past) the
    END entry.

--*/
{
    ULONG BytesToMove;
    PBYTE FirstEntry;

    DebugAssert( LengthOfClump + _Data->IndexHeader.FirstIndexEntry
               < _Data->IndexHeader.FirstFreeByte );

    //  Compute the number of bytes in entries after the clump:

    BytesToMove = _Data->IndexHeader.FirstFreeByte -
                  (LengthOfClump + _Data->IndexHeader.FirstIndexEntry);

    //  Shift those entries down to the beginning of the index
    //  entries in this index buffer.

    FirstEntry = (PBYTE)GetFirstEntry();

    memmove( FirstEntry,
             FirstEntry + LengthOfClump,
             BytesToMove );

    // Adjust the offset of the First Free Byte to reflect
    // what we just did:

    _Data->IndexHeader.FirstFreeByte -= LengthOfClump;
}



BOOLEAN
NTFS_INDEX_BUFFER::IsEmpty(
    )
/*++

Routine Description:

    This method determines whether the buffer is empty.

Arguments:

    None.

Return Value:

    TRUE if the first entry is an END entry.

--*/
{
    PINDEX_ENTRY FirstEntry;

    FirstEntry = GetFirstEntry();

    return( FirstEntry->Flags & INDEX_ENTRY_END );
}


BOOLEAN
NTFS_INDEX_BUFFER::Copy(
    IN  PNTFS_INDEX_BUFFER  p,
    IN  PCLOG_IO_DP_DRIVE   Drive
    )
/*++

Routine Description:

    This method makes a copy of the given index buffer.

Arguments:

    p       - Supplies the index buffer to be copied
    Drive   - Supplies the drive on which the index buffer resides.

Return Value:

    TRUE upon successful completion.

--*/
{
    DebugPtrAssert(p);

    _ThisBufferVcn = p->_ThisBufferVcn;
    _ClusterSize = p->_ClusterSize;
    _ClustersPerBuffer = p->_ClustersPerBuffer;
    _BufferSize = p->_BufferSize;
    _CollationRule = p->_CollationRule;
    _UpcaseTable = p->_UpcaseTable;

    if( !_Mem.Initialize() ||
        (_Data = (PINDEX_ALLOCATION_BUFFER)
                 _Mem.Acquire( _BufferSize,
                               Drive->QueryAlignmentMask() )) == NULL ) {

        Destroy();
        return FALSE;
    }

    memcpy(_Data, p->_Data, _BufferSize);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\indxroot.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    indxroot.hxx

Abstract:

    this module contains the member funciton definitions for the
    NTFS_INDEX_ROOT class, which models the root of an NTFS index

Author:

    Bill McJohn (billmc) 06-Sept-1991

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"

#include "attrib.hxx"
#include "frs.hxx"
#include "indxroot.hxx"
#include "indxtree.hxx"

DEFINE_CONSTRUCTOR( NTFS_INDEX_ROOT, OBJECT );

NTFS_INDEX_ROOT::~NTFS_INDEX_ROOT(
    )
{
    Destroy();
}


VOID
NTFS_INDEX_ROOT::Construct(
    )
/*++

Routine Description:

    Worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _MaximumSize = 0;
    _DataLength = 0;
    _Data = NULL;
    _IsModified = FALSE;
    _UpcaseTable = NULL;

}

VOID
NTFS_INDEX_ROOT::Destroy(
    )
/*++

Routine Description:

    This method cleans up an NTFS_INDEX_ROOT object in preparation
    for destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _MaximumSize = 0;
    _DataLength = 0;
    FREE( _Data );
    _IsModified = FALSE;
    _UpcaseTable = NULL;

}


BOOLEAN
NTFS_INDEX_ROOT::Initialize(
    IN PNTFS_ATTRIBUTE      RootAttribute,
    IN PNTFS_UPCASE_TABLE   UpcaseTable,
    IN ULONG                MaximumSize
    )
/*++

Routine Description:

    This method initializes the index root based on an $INDEX_ROOT
    attribute.  It is used to initialize an index root object for
    an extant index.

Arguments:

    RootAttribute   --  supplies the $INDEX_ROOT attribute for
                        this index.
    UpcaseTable     --  supplies the volume upcase table.
    MaximumSize     --  supplies the maximum size of this index root

Return Value:

    TRUE upon successful completion.

Notes:

    If the existing attribute's value length is greater than the
    supplied maximum size, the maximum size will be adjusted.

--*/
{
    BIG_INT ValueLength;
    ULONG BytesRead;

    DebugPtrAssert( RootAttribute );

    Destroy();

    RootAttribute->QueryValueLength( &ValueLength );

    // Check that the attribute is the correct type and that
    // it is a reasonable size.

    if( RootAttribute->QueryTypeCode() != $INDEX_ROOT ||
        ValueLength.GetHighPart() != 0  ) {

        return FALSE;
    }

    // If the existing attribute is already bigger than the specified
    // maximum size, then increase the maximum size, since it is only
    // provided to give an upper bound on the size of the attribute.

    if( ValueLength.GetLowPart() > MaximumSize ) {

        MaximumSize = ValueLength.GetLowPart();
    }

    _DataLength = ValueLength.GetLowPart();
    _MaximumSize = MaximumSize;
    _IsModified = FALSE;

    if( (_Data = (PINDEX_ROOT)MALLOC( _MaximumSize )) == NULL ) {

        Destroy();
        return FALSE;
    }

    if( !RootAttribute->Read( _Data,
                              0,
                              _DataLength,
                              &BytesRead ) ||
        BytesRead != _DataLength ) {

        Destroy();
        return FALSE;
    }

    _UpcaseTable = UpcaseTable;

    return TRUE;
}


BOOLEAN
NTFS_INDEX_ROOT::Initialize(
    IN ATTRIBUTE_TYPE_CODE  IndexedAttributeType,
    IN COLLATION_RULE       CollationRule,
    IN PNTFS_UPCASE_TABLE   UpcaseTable,
    IN ULONG                ClustersPerBuffer,
    IN ULONG                BytesPerBuffer,
    IN ULONG                MaximumRootSize
    )
/*++

Routine Description:

    This method initializes the index root based on the fundamental
    information of the index.  It is used to initialize an index root
    for a new index.

Arguments:

    IndexedAttributeType    --  supplies the type code of the attribute
                                which is indexed by this index.
    CollationRule           --  supplies the collation rule for this index.
    UpcaseTable             --  supplies the volume upcase table.
    BytesPerBuffer          --  supplies the number of bytes per Index
                                Allocation Buffer in this index.
    MaximumRootSize         --  supplies the maximum size of this index root.

Return Value:

    TRUE upon successful completion.

Notes:

    This method marks the index root as modified, since it is being
    created ex nihilo instead of being read from an attribute.

    It creates an empty leaf index root (ie. with only an END entry).

--*/
{
    PINDEX_ENTRY EndEntry;

    DebugAssert( sizeof( INDEX_ROOT ) % 8 == 0 );
    DebugAssert( sizeof( INDEX_HEADER ) % 8 == 0 );

    Destroy();

    _UpcaseTable = UpcaseTable;
    _MaximumSize = MaximumRootSize;
    _IsModified = TRUE;

    _DataLength = sizeof( INDEX_ROOT ) + NtfsIndexLeafEndEntrySize;

    // check to make sure that an empty index root will fit in the
    // maximum size given.  Note that we also reserve space for a
    // VCN downpointer, in case this index root gets converted into
    // a node by Recreate.

    if( _DataLength + sizeof(VCN) > _MaximumSize ) {

        Destroy();
        return FALSE;
    }

    if( (_Data = (PINDEX_ROOT)MALLOC( _MaximumSize )) == NULL ) {

        Destroy();
        return FALSE;
    }

    memset( _Data, 0, _MaximumSize );

    _Data->IndexedAttributeType = IndexedAttributeType;
    _Data->CollationRule = CollationRule;
    _Data->BytesPerIndexBuffer = BytesPerBuffer;
    _Data->ClustersPerIndexBuffer = (UCHAR)ClustersPerBuffer;
    _Data->IndexHeader.FirstIndexEntry = sizeof( INDEX_HEADER );
    _Data->IndexHeader.FirstFreeByte = sizeof( INDEX_HEADER ) +
                                            NtfsIndexLeafEndEntrySize;
    _Data->IndexHeader.BytesAvailable = _Data->IndexHeader.FirstFreeByte;
    _Data->IndexHeader.Flags = 0;

    // Fill in the end entry.  Its only meaningful fields are Length
    // and Flags.

    EndEntry = GetFirstEntry();

    EndEntry->Length = NtfsIndexLeafEndEntrySize;
    EndEntry->AttributeLength = 0;
    EndEntry->Flags = INDEX_ENTRY_END;

    return TRUE;
}


BOOLEAN
NTFS_INDEX_ROOT::FindEntry(
    IN      PCINDEX_ENTRY       SearchEntry,
    IN OUT  PULONG              Ordinal,
    OUT     PINDEX_ENTRY*       EntryFound
    )
/*++

Routine Description:

    This method locates an entry in the index root.  Note that it does
    not search the index allocation b-tree (if any).


Arguments:

    SearchEntry --  Supplies a search entry, which gives the attribute
                    value to find.
    Ordinal     --  supplies an ordinal showing which matching entry
                    to return; see note below.  A value of INDEX_SKIP
                    indicates that all matching entries should be skipped.
    EntryFound  --  receives a pointer to the located entry.  Receives
                    NULL if an error has occurred.

Return Value:

    TRUE if a matching entry is found.

    If an error occurs, *EntryFound is set to NULL.

    If no error occurs, and no matching entry is found, *EntryFound
    is set to the next entry (i.e. the point at which the search key
    would be inserted into this index root) and the method returns
    FALSE.

Notes:

    This method assumes that the index root is consistent.

    The ordinal argument indicates how many matching entries should be
    passed over before one is returned.  When an entry is found which
    matches the search key, if *Ordinal is zero, that entry is returned;
    otherwise, *Ordinal is decremented, and the FindEntry goes on to
    the next entry.

    If *Ordinal is INDEX_SKIP, all matching entries are skipped.

--*/
{
    PINDEX_ENTRY CurrentEntry;
    BOOLEAN Found;
    int CompareResult;

    CurrentEntry = GetFirstEntry();
    Found = FALSE;

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        CompareResult = CompareNtfsIndexEntries( SearchEntry,
                                                 CurrentEntry,
                                                 _Data->CollationRule,
                                                 _UpcaseTable);

        if( CompareResult < 0 ) {

            // The search value is less than the current entry's
            // value, so we've overshot where our search key would
            // be.  Stop (and return the current entry).

            break;

        } else if( CompareResult == 0 ) {

            // The current entry matches the search entry.  Check
            // the ordinal argument to see if we should return this
            // entry or skip it.

            if( *Ordinal == 0 ) {

                Found = TRUE;
                break;

            } else if( *Ordinal != INDEX_SKIP ) {

                *Ordinal -= 1;
            }
        }

        // Haven't found our entry, so we'll just go on to the next.

        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    *EntryFound = CurrentEntry;
    return( Found );
}


BOOLEAN
NTFS_INDEX_ROOT::InsertEntry(
    IN  PCINDEX_ENTRY   NewEntry,
    IN  PINDEX_ENTRY    InsertPoint
    )
/*++

Routine Description:

    This inserts an index entry into the index root.  It will
    expand the index root (if possible), but it will not split it.

Arguments:

    NewEntry    --  supplies the new entry to be inserted.
    InsertPoint --  supplies the point at which the new entry should be
                    inserted--it may be NULL, in which case the index
                    root should decide for itself.

Return Value:

    TRUE upon successful completion.

Notes:

    A return value of FALSE indicates that there is not enough room
    for the entry in this index root.

    If an insertion point is specified, it must be a pointer returned
    by a previous call to FindEntry or GetFirstEntry (with no intervening
    inserts or deletes).

    This method assumes that the index root and the new entry are
    consistent, which includes that the entry has a downpointer if
    and only if the index root is a node.

--*/
{
    ULONG Ordinal, BytesToMove;


    //  Check to see if there's room.

    if( _DataLength + NewEntry->Length  > _MaximumSize ) {

        return FALSE;
    }

    //  There's enough room, so we're bound to succeed.

    if( InsertPoint == NULL ) {

        // The client has not supplied the insert point, so we get to
        // figure it out for ourselves.  Fortunately, we can get FindEntry
        // to do our work for us.

        // Note that we don't care what InsertEntry returns--we know it
        // won't hit an error, and we don't care whether there are any
        // matching entries in the buffer.  (If we get a matching buffer,
        // we insert the new one before it, which is just fine.)

        Ordinal = 0;

        FindEntry( NewEntry,
                   &Ordinal,
                   &InsertPoint );

        DebugPtrAssert( InsertPoint );
    }


    // Make room for the new entry...

    BytesToMove = _Data->IndexHeader.FirstFreeByte -
                  (ULONG)((PBYTE)InsertPoint - (PBYTE)&(_Data->IndexHeader));

    memmove( (PBYTE)InsertPoint + NewEntry->Length,
             InsertPoint,
             BytesToMove );

    _Data->IndexHeader.FirstFreeByte += NewEntry->Length;
    _Data->IndexHeader.BytesAvailable = _Data->IndexHeader.FirstFreeByte;

    memcpy( InsertPoint, NewEntry, NewEntry->Length );

    _DataLength += NewEntry->Length;

    return TRUE;
}


VOID
NTFS_INDEX_ROOT::RemoveEntry(
    PINDEX_ENTRY EntryToRemove
    )
/*++

Routine Description:

    This method removes an entry from the index root.  Note that it will
    not find a replacement entry for nodes, or perform any other b-tree
    maintenance; it just expunges the entry from the root.

Arguments:

    EntryToRemove   --  supplies the index entry to be removed.  This
                        must be an entry returned by a previous call
                        to FindEntry or GetFirstEntry.

Return Value:

    None.

Notes:

    This method assumes that the index root is consistent.
--*/
{
    PBYTE NextEntry;
    ULONG BytesToMove;


    DebugAssert( (PBYTE)EntryToRemove <
               (PBYTE)&(_Data->IndexHeader) +
                    _Data->IndexHeader.FirstFreeByte );

    DebugAssert( (PBYTE)EntryToRemove >=
               (PBYTE)&(_Data->IndexHeader) +
                    _Data->IndexHeader.FirstIndexEntry );

    NextEntry = (PBYTE)GetNextEntry( EntryToRemove );

    BytesToMove = _Data->IndexHeader.FirstFreeByte -
                  (ULONG)( NextEntry - (PBYTE)&(_Data->IndexHeader) );

    _Data->IndexHeader.FirstFreeByte -= EntryToRemove->Length;
    _Data->IndexHeader.BytesAvailable = _Data->IndexHeader.FirstFreeByte;

    _DataLength -= EntryToRemove->Length;

    memmove( EntryToRemove,
             NextEntry,
             BytesToMove );

}



VOID
NTFS_INDEX_ROOT::Recreate(
    IN BOOLEAN  IsLeaf,
    IN VCN      EndEntryDownpointer
    )
/*++

Routine Description:

    This method recreates the Index Root with only an end entry.

Arguments:

    IsLeaf              --  supplies an indicator whether this index root
                            is a leaf (TRUE) or a node (FALSE).
    EndEntryDownpointer --  supplies the VCN DownPointer for the End
                            Entry.  (If IsLeaf is TRUE, this parameter
                            is ignored.)

Return Value:

    None.

Notes:

    The basic information of the index root is not changed; just the
    index entries and flags.

--*/
{
    PINDEX_ENTRY EndEntry;
    ULONG EndEntrySize;

    _IsModified = TRUE;
    _DataLength = sizeof( INDEX_ROOT ) + NtfsIndexLeafEndEntrySize;

    EndEntrySize = NtfsIndexLeafEndEntrySize;

    if( !IsLeaf ) {

        _Data->IndexHeader.Flags = INDEX_NODE;
        _DataLength += sizeof(VCN);
        EndEntrySize += sizeof( VCN );

    } else {

        _Data->IndexHeader.Flags = 0;
    }

    DebugAssert( _MaximumSize >= _DataLength );

    _Data->IndexHeader.FirstFreeByte = sizeof( INDEX_HEADER ) +
                                            EndEntrySize;

    _Data->IndexHeader.BytesAvailable = _Data->IndexHeader.FirstFreeByte;

    // Fill in the end entry.  Its only meaningful fields are Length,
    // Flags, and downpointer (if any).

    EndEntry = GetFirstEntry();

    memset(&(EndEntry->FileReference), 0, sizeof(FILE_REFERENCE));
    EndEntry->Length = (USHORT)EndEntrySize;
    EndEntry->AttributeLength = 0;
    EndEntry->Flags = INDEX_ENTRY_END;

    if( !IsLeaf ) {

        EndEntry->Flags |= INDEX_ENTRY_NODE;
        GetDownpointer( EndEntry ) = EndEntryDownpointer;
    }
}


BOOLEAN
NTFS_INDEX_ROOT::Write(
    PNTFS_ATTRIBUTE RootAttribute
    )
/*++

Routine Description:

    This method writes the index root to the supplied attribute.

Arguments:

    RootAttribute   --  supplies the INDEX_ROOT attribute.

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG BytesWritten;

    // Resize the attribute to the correct size, and then write
    // the root's data to it.  Since this attribute is always
    // resident, pass in NULL for the bitmap.
    //

    return( RootAttribute->IsResident() &&
            RootAttribute->Resize( _DataLength, NULL ) &&
            RootAttribute->Write( _Data,
                                  0,
                                  _DataLength,
                                  &BytesWritten,
                                  NULL ) &&
            BytesWritten == _DataLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\indxchk.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    indxchk.cxx

Abstract:

    This module implements the index verification stage of chkdsk.

Author:

    Norbert P. Kusters (norbertk) 10-Feb-92

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"

//#define TIMING_ANALYSIS     1

extern "C" {
    #include <stdio.h>
#if defined(TIMING_ANALYSIS)
    #include <time.h>
#endif
}

#include "ntfssa.hxx"

#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrib.hxx"
#include "attrdef.hxx"
#include "mft.hxx"
#include "numset.hxx"
#include "indxtree.hxx"
#include "attrcol.hxx"
#include "ifssys.hxx"
#include "digraph.hxx"
#include "ifsentry.hxx"

// This global flag is used to signal that incorrect duplicated
// information was found in some of the file name indices on the
// disk.

STATIC BOOLEAN  FileSystemConsistencyErrorsFound = FALSE;

#define SET_TRUE(x)  ((x)=TRUE)

#define MAX_NUMBER_OF_BANDS         10

#define FRS_DATA_RECORD_MAX_SIZE    250

//
// A replicate of the structure defined in ntos\rtl\gentable.c
//
typedef struct _TABLE_ENTRY_HEADER {
    RTL_SPLAY_LINKS     SplayLinks;
    LIST_ENTRY          ListEntry;
    LONGLONG            UserData;
} TABLE_ENTRY_HEADER, *PTABLE_ENTRY_HEADER;

BOOLEAN
NTFS_SA::ValidateIndices(
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    OUT     PDIGRAPH                    DirectoryDigraph,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN OUT  PNUMBER_SET                 BadClusters,
    IN      USHORT                      Algorithm,
    IN      BOOLEAN                     SkipEntriesScan,
    IN      BOOLEAN                     SkipCycleScan,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine validates the EAs and indices on the volume.  A complete
    list of all files which may (or may not) contain EAs or indices is
    supplied.  This, along with a valid Mft makes this validation possible.

Arguments:

    ChkdskInfo              - Supplies the current chkdsk information.
    DirectoryDigraph        - Returns a digraph of the directory structure.
    Mft                     - Supplies a valid MFT.
    AttributeDefTable       - Supplies the attribute definition table.
    ChkdskReport            - Supplies the current chkdsk report to be updated
                                by this routine.
    BadClusters             - Supplies the bad cluster list.
    SkipEntriesScan         - Supplies if index entries checking should be skipped.
    SkipCycleScan           - Supplies if cycles within directory tree should be checked.
    FixLevel                - Supplies the fix level.
    Message                 - Supplies an outlet for messages.
    DiskErrorsFound         - Supplies whether or not disk errors have been
                                found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    ULONG                       i, j;
    NTFS_ATTRIBUTE              bitmap_attrib;
    NTFS_ATTRIBUTE              root_attrib;
    NTFS_ATTRIBUTE              alloc_attrib;
    NTFS_BITMAP                 alloc_bitmap;
    PINDEX_ROOT                 index_root;
    ATTRIBUTE_TYPE_CODE         indexed_attribute_type;
    BOOLEAN                     alloc_present;
    BOOLEAN                     need_write;
    BOOLEAN                     complete_failure;
    PVOID                       bitmap_value;
    ULONG                       bitmap_length;
    ULONG                       attr_def_index;
    BOOLEAN                     tube;
    BOOLEAN                     ErrorInAttribute;
    NTFS_INDEX_TREE             index;
    BOOLEAN                     changes;
    ULONG                       percent_done = 0;
    ULONG                       new_percent = 0;
    BIG_INT                     num_file_names = 0;
    BOOLEAN                     error_in_index;
    BOOLEAN                     duplicates_allowed;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    DSTRING                     index_name;
    NTFS_MFT_INFO               mft_info;
    BOOLEAN                     files_with_too_many_filenames;

    SYSTEM_BASIC_INFORMATION    sys_basic_info;
    NTSTATUS                    status;
    BIG_INT                     pages_for_mft_info, pages_for_others;
    BIG_INT                     pages_needed, pages_available;
    ULONG                       bytes_per_frs;
    BIG_INT                     total_bytes_needed, bytes_needed;
    BIG_INT                     max_mem_use_for_mft_info;
    ULONG64                     vm_pages;
    ULONG64                     max_vm_pages;

    LONG                        order = -1;

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time_t                      time1, time2;
    time_t                      timel1, timel2;
    PCHAR                       timestr;
#endif

    DebugAssert(ChkdskInfo);
    DebugAssert(Mft);
    DebugAssert(ChkdskReport);
    DebugAssert(Message);

    if (SkipEntriesScan || Algorithm == 0) {
        if (Algorithm == 0) {
            Message->DisplayMsg(MSG_CHK_NTFS_SLOWER_ALGORITHM);
        } else
            Algorithm = 0;
    } else {

        //
        // Obtain number of physical pages and page size first
        //
        status = NtQuerySystemInformation(SystemBasicInformation,
                                          &sys_basic_info,
                                          sizeof(sys_basic_info),
                                          NULL);

        if (!NT_SUCCESS(status)) {
            DebugPrintTrace(("UNTFS: NtQuerySystemInformation(SystemBasicInformation) failed (%x)\n", status));
            return FALSE;
        }

        vm_pages = (sys_basic_info.MaximumUserModeAddress -
                    sys_basic_info.MinimumUserModeAddress)/sys_basic_info.PageSize;
        max_vm_pages = vm_pages;

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: Page Size = %x\n", sys_basic_info.PageSize));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: User Virtual pages = %I64x\n", vm_pages));
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: Physical pages = %x\n", sys_basic_info.NumberOfPhysicalPages));

        if (sys_basic_info.NumberOfPhysicalPages < vm_pages) {
            vm_pages = sys_basic_info.NumberOfPhysicalPages;
        }



#if defined(_AUTOCHECK_)
        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: AvailablePages = %x\n", ChkdskInfo->AvailablePages));

        if (ChkdskInfo->AvailablePages < vm_pages)
            vm_pages = ChkdskInfo->AvailablePages;
#endif

        KdPrintEx((DPFLTR_AUTOCHK_ID, DPFLTR_INFO_LEVEL,
                   "UNTFS: Final pages available = %I64x\n", vm_pages));

        if (Algorithm != CHKDSK_ALGORITHM_NOT_SPECIFIED &&
            Algorithm > ChkdskInfo->BaseFrsCount) {
            Message->DisplayMsg(MSG_CHK_NTFS_ADJUST_INDEX_PASSES, "%d", Algorithm);
            Algorithm = max(1, (USHORT)ChkdskInfo->BaseFrsCount);
        }

        //
        // Figure out the approximate amount of memory needed
        //
        pages_for_mft_info =
            (ChkdskInfo->BaseFrsCount *
             (sizeof(NTFS_FRS_INFO)-sizeof(_NTFS_FILE_NAME_INFO)) +
             ChkdskInfo->TotalNumFileNames *
             sizeof(_NTFS_FILE_NAME_INFO) +
             (sys_basic_info.PageSize - 1)
            )/sys_basic_info.PageSize;

        pages_for_others = ChkdskInfo->NumFiles;

        bytes_per_frs = ((FIELD_OFFSET(TABLE_ENTRY_HEADER, UserData)+
                          sizeof(CHILD_ENTRY)+sizeof(PVOID)+sizeof(USHORT)*2)*8+4);
                                    // 44.5(32-bit) or 64.5(64-bit) bytes/frs scaled up by 8
                                    // Here are the four bitmaps: mft_bitmap,
                                    // FilesWithIndices, FilesWhoNeedData,
                                    // FilesWithReparsePoint
                                    // plus 36(32-bit) or 56(64-bit) bytes for each edge
                                    // plus 2 bytes for NumFileNames
                                    // plus 2 bytes for ReferenceCount
                                    // plus sizeof(PVOID) bytes for mft_info

        if (SkipCycleScan)
            bytes_per_frs -= ((sizeof(CHILD_ENTRY)+
                               FIELD_OFFSET(TABLE_ENTRY_HEADER, UserData))*8);// less edge scaled by 8

        pages_for_others = ((pages_for_others*bytes_per_frs) +
                            Mft->GetVolumeBitmap()->QuerySize() +
                            (sys_basic_info.PageSize * 8 - 1))/
                            (sys_basic_info.PageSize * 8); // include the volume_bitmap

        pages_needed = pages_for_others + pages_for_mft_info;

        // leave 10% margin
        pages_available = vm_pages;
        pages_available = (pages_available * 9)/10;

        if (Algorithm == CHKDSK_ALGORITHM_NOT_SPECIFIED &&
            pages_for_others > pages_available) {

            Algorithm = 0;  // use old & slow algorithm

            if (pages_needed > max_vm_pages) {
                Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_FILES_TO_RUN_AT_FULL_SPEED);
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_MORE_MEMORY_IS_NEEDED_TO_RUN_AT_FULL_SPEED, "%d",
                                    max(1, ((pages_needed - pages_available)*sys_basic_info.PageSize/1024/1024)));
            }


        } else if (Algorithm == 1 ||
                   (Algorithm == CHKDSK_ALGORITHM_NOT_SPECIFIED &&
                    pages_needed <= pages_available)) {
            Algorithm = 1;  // perfect, use the fastest algorithm
            max_mem_use_for_mft_info = -1;
        } else {

            // not enough memory to do it in one pass
            // let see if it can be done in multiple pass

            if (Algorithm == CHKDSK_ALGORITHM_NOT_SPECIFIED) {

                if (pages_needed > max_vm_pages) {
                    Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_FILES_TO_RUN_AT_FULL_SPEED);
                } else {
                    Message->DisplayMsg(MSG_CHK_NTFS_MORE_MEMORY_IS_NEEDED_TO_RUN_AT_FULL_SPEED, "%d",
                                        max(1, ((pages_needed - pages_available)*sys_basic_info.PageSize/1024/1024)));
                }

                total_bytes_needed = 0;

                max_mem_use_for_mft_info =
                    (pages_available - pages_for_others) * sys_basic_info.PageSize;

                //
                // figure out how many passes is needed
                // by counting how many base frs and how many names in each of them
                //

                Algorithm = 1;  // at least one pass

                for (i=0; i<ChkdskInfo->NumFiles; i++) {

                    if (ChkdskInfo->NumFileNames[i] != 0) {

                        bytes_needed =
                            (sizeof(NTFS_FRS_INFO)-sizeof(_NTFS_FILE_NAME_INFO)) +
                             ChkdskInfo->NumFileNames[i] * sizeof(_NTFS_FILE_NAME_INFO);

                        total_bytes_needed += bytes_needed;
                        if (total_bytes_needed > max_mem_use_for_mft_info) {
                            total_bytes_needed = bytes_needed;
                            Algorithm++;
                            if (Algorithm > MAX_NUMBER_OF_BANDS) {
                                Algorithm = 0;
                                Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_PASSES, "%d", MAX_NUMBER_OF_BANDS);
                                break;
                            }
                        }
                    }
                }
            } else
                max_mem_use_for_mft_info = -1;

            if (Algorithm) {
                //
                // recalculate max_mem_use_for_mft_info so as to even out the
                // usage of memory
                //
                bytes_needed = (pages_for_mft_info * sys_basic_info.PageSize+Algorithm)/Algorithm;
                if (max_mem_use_for_mft_info != -1) {
                    DebugAssert(bytes_needed <= max_mem_use_for_mft_info);
                }
                max_mem_use_for_mft_info = bytes_needed;
                Message->DisplayMsg(MSG_CHK_NTFS_PASSES_NEEDED, "%d", Algorithm);
            }
        }
    }

    if (!DirectoryDigraph->Initialize(ChkdskInfo->NumFiles)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_NTFS_CHECKING_INDICES, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 2, GetNumberOfStages());
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time1);
    timestr = ctime(&time1);
    timestr[strlen(timestr)-1] = 0;
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", "Before stage 2: ", timestr);
#endif

    if (Algorithm == 0) {

        if (SkipEntriesScan) {
            if (!ChkdskInfo->IndexEntriesToCheck.Initialize(ChkdskInfo->NumFiles,
                                                            TRUE)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            ChkdskInfo->IndexEntriesToCheckIsSet = FALSE;
        }

        ChkdskInfo->TotalNumFileNames += ((ChkdskInfo->NumFiles/16) + 1);

        for (i = 0; i < ChkdskInfo->NumFiles; i++) {

            if ((i & 0xF) == 0) {
                num_file_names += 1;
            }

            if (ChkdskInfo->FilesWithIndices.IsFree(i, 1)) {

                new_percent = (((num_file_names)*90) / ChkdskInfo->TotalNumFileNames).GetLowPart();
                if (new_percent != percent_done) {
                    percent_done = new_percent;
        