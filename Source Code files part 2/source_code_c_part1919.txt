aphicsCaps |= NV_WKS_GRAPHICS_CAPS_LOGIC_OPS      ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_NV15_ALINES    ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_NV15_ALINES    ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_2SIDED_LIGHTING) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_2SIDED_LIGHTING;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_QUADRO_GENERIC ;
            if (ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_UBB ) 
                pGetCapsOut->flGraphicsCaps |= NV_WKS_GRAPHICS_CAPS_UBB ;

            pGetCapsOut->ulMaxClipRects = HWGFXCAPS_MAXCLIPS(ppdev);

            if ((ppdev->hwGfxCaps & NV_CFG_GRAPHICS_CAPS_QUADRO_GENERIC))
            {
                ULONG ulPFDCaps=0;
                ASSERT(pGetCapsOut->flGraphicsCaps & NV_WKS_GRAPHICS_CAPS_QUADRO_GENERIC);

                pGetCapsOut->flWksCaps |= NV_WKS_CAPS_WORKSTATION_BOARD;

                bOglPfdCheckFlags(ppdev, &ulPFDCaps);

                if (ulPFDCaps & WIN_PFD_SUPPORTS_OVERLAYS)
                    pGetCapsOut->flWksCaps |= NV_WKS_CAPS_OVERLAY_CAPABLE;

                if (ulPFDCaps & WIN_PFD_SUPPORTS_STEREO)
                    pGetCapsOut->flWksCaps |= NV_WKS_CAPS_STERO_CAPABLE;
            }

            pHeadOut->lResult = NV_WKS_RESULT_SUCCESS;
            break;
        }

        case SUBESC_WKS_WINDOW_STEREOMODE:
        {
            CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjIn , sizeof(NV_WKS_WINDOW_STEREOMODE_IN ), lRet, pHeadOut, NV_WKS_RESULT_ERROR_INSIZE );
            CHECK_CJ_AND_GOTO_EXIT_IF_FAIL(cjOut, sizeof(NV_WKS_WINDOW_STEREOMODE_OUT), lRet, pHeadOut, NV_WKS_RESULT_ERROR_OUTSIZE);

            if (!bWksWindowStereoSupport(ppdev, pvIn, pvOut))
            {
                // severe error!
                goto Exit;
            }

            break;
        }

        default:
        {
            // unsupported escape
            if (cjOut >= sizeof(NV_WKS_HEAD_OUT))
            {
                pHeadOut->ulSize  = sizeof(NV_WKS_HEAD_OUT); // can only feed header
                pHeadOut->lResult = NV_WKS_RESULT_ERROR_SUBESC_NOT_SUPPORTED;
            }
            break;
        }
    }

    lRet = WKS_ESC_SUCCEED; // escape handled

Exit:
    return (lRet);
}


//*************************************************************************
// bWksWindowStereoSupport
//
// handles SUBESC_WKS_WINDOW_STEREOMODE escape. In and out structures 
// must be valid.
//
// NOTE: example escape code below
//
// return: FALSE - failed, pWindowStereoModeOut not valid
//         TRUE  - succeeded, pWindowStereoModeOut valid
//*************************************************************************
static BOOL bWksWindowStereoSupport(
    IN     PPDEV ppdev,
    IN     NV_WKS_WINDOW_STEREOMODE_IN  *pWindowStereoModeIn ,
       OUT NV_WKS_WINDOW_STEREOMODE_OUT *pWindowStereoModeOut)
{
    BOOL                        bRet            = FALSE;
    NV_OPENGL_CLIENT_INFO_LIST *clientList      = NULL;
    NV_OPENGL_CLIENT_INFO      *clientInfo      = NULL;
    BOOL                        bStereoClient   = FALSE;

    ASSERT(NULL != ppdev               );
    ASSERT(NULL != pWindowStereoModeIn );
    ASSERT(NULL != pWindowStereoModeOut);

    pWindowStereoModeOut->hwnd = pWindowStereoModeIn->hwnd;


    // work on specified window?
    if (NULL != pWindowStereoModeIn->hwnd)
    {
        // Set or query for specified window
        clientList = OglFindClientInfoFromHWnd(ppdev, pWindowStereoModeIn->hwnd);

        if (NULL != clientList)
        {
            clientInfo = &clientList->clientInfo;

            bStereoClient = bOglIsStereoClient(clientInfo);

            switch (pWindowStereoModeIn->ulMode)
            {
                case NV_WKS_WINDOW_STEREOMODE_ENABLE :
                case NV_WKS_WINDOW_STEREOMODE_DISABLE:
                {
                    if (bStereoClient)
                    {
                        // set stereo clients stereo mode
                        clientInfo->bStereoDisabled = (NV_WKS_WINDOW_STEREOMODE_DISABLE == pWindowStereoModeIn->ulMode) ? TRUE : FALSE;

                        //
                        // KEY: Update stereo mode now!
                        //
                        bOglStereoModeUpdate(ppdev);

                        pWindowStereoModeOut->ulMode      = clientInfo->bStereoDisabled ? NV_WKS_WINDOW_STEREOMODE_DISABLED 
                                                                                        : NV_WKS_WINDOW_STEREOMODE_ENABLED;
                        pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_SUCCESS;
                    }
                    else
                    {
                        // error, cannot set stereo mode on monoscopic window
                        pWindowStereoModeOut->ulMode      = NV_WKS_WINDOW_STEREOMODE_NO_STEREO_HWND;
                        pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_ERROR_PARAMETER;
                    }
                    break;
                }
                case NV_WKS_WINDOW_STEREOMODE_QUERY:
                {
                    if (bStereoClient)
                    {
                        pWindowStereoModeOut->ulMode  = clientInfo->bStereoDisabled ? NV_WKS_WINDOW_STEREOMODE_DISABLED 
                                                                                    : NV_WKS_WINDOW_STEREOMODE_ENABLED;
                    }
                    else
                    {
                        pWindowStereoModeOut->ulMode  = NV_WKS_WINDOW_STEREOMODE_NO_STEREO_HWND;
                    }
                    // succeed because it's a query
                    pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_SUCCESS;
                    break;
                }
            }
        }
        else
        {
            // error, given window not found
            pWindowStereoModeOut->ulMode      = NV_WKS_WINDOW_STEREOMODE_INVALID_HWND;
            pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_ERROR_PARAMETER;
        }
    } 
    else
    {
        // No window given, query only!

        switch (pWindowStereoModeIn->ulMode)
        {
            case NV_WKS_WINDOW_STEREOMODE_QUERY:
            {
                if (0==cOglStereoClients(ppdev))
                {
                    pWindowStereoModeOut->ulMode = NV_WKS_WINDOW_STEREOMODE_NO_STEREO;
                }
                else
                {
                    if (ppdev->bOglStereoActive)
                        pWindowStereoModeOut->ulMode = NV_WKS_WINDOW_STEREOMODE_ENABLED;
                    else
                        pWindowStereoModeOut->ulMode = NV_WKS_WINDOW_STEREOMODE_DISABLED;
                }

                pWindowStereoModeOut->hdr.lResult    = NV_WKS_RESULT_SUCCESS;
                break;
            }
            case NV_WKS_WINDOW_STEREOMODE_ENABLE :
            case NV_WKS_WINDOW_STEREOMODE_DISABLE:
            {
                // error, not allowed without window
                pWindowStereoModeOut->ulMode      = NV_WKS_WINDOW_STEREOMODE_INVALID_HWND;
                pWindowStereoModeOut->hdr.lResult = NV_WKS_RESULT_ERROR_PARAMETER;
                break;
            }
            default:
            {
                // error, unkown parameter
                pWindowStereoModeOut->hdr.lResult            = NV_WKS_RESULT_ERROR_PARAMETER;
                break;
            }
        }
    }

    bRet = TRUE;

    return (bRet);
}



#if 0 

// 
// Example code, please do not delete!
//

/* 
// SUBESC_WKS_GET_CAPS
{
    HDC                 hDC;
    NV_WKS_GET_CAPS_IN  wksGetCapsIn;
    NV_WKS_GET_CAPS_OUT wksGetCapsOut;
    int                 iResult;

    hDC = GetDC(hWnd); // NOTE: a NULL hWnd will fail on Windows 2000 multiscreen

    if (NULL != hDC)
    {

        ZeroMemory(&wksGetCapsIn,  sizeof(NV_WKS_GET_CAPS_IN));
        ZeroMemory(&wksGetCapsOut, sizeof(NV_WKS_GET_CAPS_OUT));

        NV_WKS_INIT_HEAD_IN(&wksGetCapsIn, SUBESC_WKS_GET_CAPS, sizeof(NV_WKS_GET_CAPS_IN), sizeof(NV_WKS_GET_CAPS_OUT), 0);

        iResult = ExtEscape(hDC,                         // handle to DC
                            ESC_NV_WKS_APP_SUPPORT,      // escape function
                            sizeof(NV_WKS_GET_CAPS_IN),  // size of input structure
                            (LPCSTR)&wksGetCapsIn,       // input structure
                            sizeof(NV_WKS_GET_CAPS_OUT), // size of output structure
                            (LPSTR)&wksGetCapsOut);      // output structure
        if (iResult > 0)
        {
            // Escape succeeded, wksGetCapsOut valid
            if (   (sizeof(NV_WKS_GET_CAPS_OUT) == wksGetCapsOut.hdr.ulSize) // expected size must match
                && (wksGetCapsOut.hdr.ulVersion >= NV_WKS_VERSION)           // driver must at least have this version of interface
                && (wksGetCapsOut.hdr.lResult   >  0) )                      // no error
            {
                // Succeeded!
                //
                // TODO: add code to work with 
                //  wksGetCapsOut.flGraphicsCaps;
                //  wksGetCapsOut.ulMaxClipRects;
                //  wksGetCapsOut.flWksCaps;
            }
            else
            {
                // ERROR: Any internal error in usage of escape (sizes, state of driver, ...)
            }
        }
        else if (0 == iResult)
        {
            // ERROR: Escape not implemented
        }
        else // iResult < 0
        {
            // ERROR: Escape failed
        }

        ReleaseDC(hWnd, hDC);
    }
    else
    {
        // ERROR: couldn't retrieve a HDC
    }
}


//SUBESC_WKS_WINDOW_STEREOMODE

//*************************************************************************
// bNvWksWindowStereomodeSelect
//
// enables or disables stereo mode on given window. The function will only 
// succeed if the window is an OpenGL window that has a stereo pixelformat 
// selected.
//
// return: TRUE  - succeeded, returns current status to pbNewStereoStatus
//         FALSE - failed, pbNewStereoStatus not touched
//
// FNicklisch 21.11.2000: new
//*************************************************************************
BOOL bNvWksWindowStereomodeSelect(
    IN     HWND hWnd,               // hwnd of stereo window
       OUT BOOL bStereoModeEnable,  // TRUE: enable stereo mode, FALSE: disable stereo mode
       OUT BOOL *pbNewStereoStatus)   // pointer to return status or NULL
{
    BOOL                         bRet          = FALSE;
    NV_WKS_WINDOW_STEREOMODE_IN  wksWindowStereomodeIn ;
    NV_WKS_WINDOW_STEREOMODE_OUT wksWindowStereomodeOut;
    size_t                       inSize ;
    size_t                       outSize;
    int                          iResult;
    HDC                          hDC;

    hDC = GetDC(hWnd);

    if (NULL != hDC)
    {
        inSize  = sizeof(NV_WKS_WINDOW_STEREOMODE_IN );
        outSize = sizeof(NV_WKS_WINDOW_STEREOMODE_OUT);

        ZeroMemory(&wksWindowStereomodeIn , inSize );
        ZeroMemory(&wksWindowStereomodeOut, outSize);

        NV_WKS_INIT_HEAD_IN(&wksWindowStereomodeIn, SUBESC_WKS_WINDOW_STEREOMODE, inSize, outSize, 0);

        wksWindowStereomodeIn.hwnd   = hWnd;
        wksWindowStereomodeIn.ulMode = bStereoModeEnable ? NV_WKS_WINDOW_STEREOMODE_ENABLE : NV_WKS_WINDOW_STEREOMODE_DISABLE;

        iResult = ExtEscape(hDC,                             // handle to DC
                            ESC_NV_WKS_APP_SUPPORT,          // escape function
                            inSize,                          // size of input structure
                            (LPCSTR)&wksWindowStereomodeIn, // input structure
                            outSize,                         // size of output structure
                            (LPSTR)&wksWindowStereomodeOut); // output structure

        if (iResult > 0)
        {
            if (   (outSize == wksWindowStereomodeOut.hdr.ulSize)           // expected size must match
                && (wksWindowStereomodeOut.hdr.ulVersion >= NV_WKS_VERSION) // driver must at least have this version of interface
                && (wksWindowStereomodeOut.hdr.lResult   == NV_WKS_RESULT_SUCCESS) )            // no error
            {
                if (wksWindowStereomodeOut.hwnd != hWnd)
                {
                    // ERROR, wrong out hwnd
                }
                else
                {
                    switch (wksWindowStereomodeOut.ulMode)
                    {
                        case NV_WKS_WINDOW_STEREOMODE_DISABLED:
                        {
                            if (pbNewStereoStatus)
                                *pbNewStereoStatus = FALSE;
                            bRet = TRUE;
                            break;
                        }

                        case NV_WKS_WINDOW_STEREOMODE_ENABLED:
                        {
                            if (pbNewStereoStatus)
                                *pbNewStereoStatus = TRUE;
                            bRet = TRUE;
                            break;
                        }

                        default:
                        {
                            // any error, wrong usage of escape
                            break;
                        }
                    }
                }
            }
            else
            {
                // ERROR: Any internal error in usage of escape (sizes, state of driver, ...)
            }
        }
        else if (0 == iResult)
        {
            // ERROR: Escape not implemented
        }
        else // iResult < 0
        {
            // ERROR: Escape failed
        }
        ReleaseDC(hWnd,hDC);
    }

    return (bRet);
}
  
    

  
    
*/
#endif

// End of wksappsupport.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsregistry.c ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsregistry.c
//
// FNicklisch 09/14/2000: New, derived from registry.c
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files

#include "precomp.h"
#ifdef USE_WKS_ELSA_TOOLS
#include "wkselsatoolsdebug.h"
#include "wkselsatoolsescape.h"
#include "wkselsatoolstoolbox.h"
#include "ELSAESC.h"

// export header file
#include <wkselsatoolsregistry.h>



/*
** Registry.c
**
** Copyright (c) 1999, ELSA AG, Aachen (Germany)
**
** Internal Registry interface 
**
*/


// Code from ELSAESC.h that is in the driver but isn't used and reported yet
#define SUBESC_ET_SET_VALUE_DEFAULT         0x2111111A // set default (any type)
// In structure (Tool -> driver):
// Input Structure to set a registry default for either DWORD or a STRING
// Output Structure ET_SET_VALUE_RET
typedef struct tagET_SET_VALUE_DEFAULT
{
  ET_QUERY hdr;     // size and subescape SUBESC_ET_SET_VALUE_DEFAULT

  DWORD    dwID;    // ID of value to set (ET_VALUE_...)
  DWORD    dwType;  // must be ET_VALUE_TYPE_DWORD, ET_VALUE_TYPE_STRING, ...

} ET_SET_VALUE_DEFAULT, *PET_SET_VALUE_DEFAULT;

static BOOL bRegQueryAgainstInternalStatus(
      PPDEV           ppdev, 
  IN  DWORD           dwSubEsc, 
  IN  ET_QUERY_VALUE *petQueryValue,
  IN  ULONG           cjOut, 
  OUT VOID           *pvOut,
  OUT LONG           *plRet);

/*
** lEscRegistryValue
**
** escape wrapper for all registry interface calls.
** It checks in/out interface structure sizes,
** and dispatches the sub escapes.
**
** return: ESC_SUCCESS        function succeded without error            
**         ESC_NOTSUPPORTED   function not supported                     
**         ESC_ERROR          function supported but error while working 
**
** FNicklis 08.12.98: New
*/

LONG lEscRegistryValue(
  PPDEV    ppdev,                                               
  ULONG    dwSubEsc, 
  ULONG    cjIn ,
  VOID    *pvIn ,
  ULONG    cjOut,
  VOID    *pvOut)
{
  LONG   lRet   = ESC_ERROR; // Default error 
  HANDLE hDriver;

  DBG_TRACE_IN(DBG_LVL_FLOW0, lEscRegistryValue);

  ASSERT(NULL!=ppdev);
  ASSERT(NULL!=pvIn);
  ASSERT(cjIn >= sizeof(ET_QUERY));

#ifdef MULTI_BOARD
  hDriver = hGetBoardhDriver(ppdev, ET_QUERY_GET_BOARD(pvIn));
#else
  hDriver = ppdev->hDriver;
#endif

  switch (dwSubEsc)
  {
    case SUBESC_ET_QUERY_VALUE_STRING:  
    case SUBESC_ET_QUERY_VALUE_DWORD :   
    case SUBESC_ET_QUERY_VALUE_BINARY:
    {
      if (cjIn < sizeof(ET_QUERY_VALUE))
      {
        DBG_ERROR("cjIn < sizeof(ET_QUERY_VALUE)");
        break;
      }

      if (!bRegQueryAgainstInternalStatus(ppdev, dwSubEsc, (ET_QUERY_VALUE *)pvIn, cjOut, pvOut, &lRet))
      {
        // call not handled internaly, go through registry
        lRet = lRegEtQueryValue(hDriver, dwSubEsc, (ET_QUERY_VALUE *)pvIn, cjOut, pvOut);
      }

      break;
    }

    case SUBESC_ET_SET_VALUE_STRING:
    case SUBESC_ET_SET_VALUE_DWORD :
    case SUBESC_ET_SET_VALUE_BINARY:
    {
      if ( (NULL==pvOut) ||
           (sizeof(ET_SET_VALUE_RET) > cjOut) )
      {
        DBG_ERROR("SUBESC_ET_SET_VALUE_STRING/DWORD cjOut to small");
        break;
      }

      lRet = lRegEtSetValue(hDriver, dwSubEsc, pvIn, cjIn, (ET_SET_VALUE_RET *)pvOut);
      break;
    }

    default:
    {
      ASSERTDD(dwSubEsc==SUBESC_ET_QUERY_VALUE_STRING,"unhandled and not supported sub escape");
      lRet = ESC_NOTSUPPORTED;
      break;
    }
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetESC_RETURN(lRet) ));
  return (lRet);
}


// *******************************************************************************************
// * Begin of functions manipulationg registry via ID code
// *******************************************************************************************

/*
** lRegEtQueryValue 
**
** Esc interface to retrieve any driver handled registry key
**
** return : ESC_SUCCESS      ( 1) : function finished successfully
**          ESC_NOTSUPPORTED ( 0) : ERROR: iEsc or SubEsc not supported
**          ESC_ERROR        (-1) : ERROR: any other error (wrong feeding)
**
** 141098 MSchwarz: New
** FNicklis 21.10.98: fixed interface mischmasch
*/
LONG lRegEtQueryValue(
  IN  HANDLE          hDriver, 
  IN  DWORD           dwSubEsc, 
  IN  ET_QUERY_VALUE *petQueryValue,
  IN  ULONG           cjOut, 
  OUT VOID           *pvOut)
{
  LONG  lRet      = ESC_ERROR;
  LONG  lResult   = REG_ERROR;
  DWORD dwID;     // recalulated and modified Key ID
  DWORD dwType;   // recalulated and modified type identifier

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegEtQueryValue);
  ASSERTDD(NULL!=petQueryValue,"");
  DBG_PRINTX(DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, petQueryValue->dwID);

  ASSERT(NULL!=hDriver);

  // Save exit on user error!
  if ( NULL==pvOut )
  {
    ASSERTDD(NULL!=pvOut, "lRegEtQueryValue:");
    goto Exit;
  }

  // check if we get the default only
  dwType = petQueryValue->dwType;
  dwID   = petQueryValue->dwID;
  if (bBitsTest(dwType,ET_VALUE_DEFAULT_FLAG))
  {
    // mask out the default type flag 
    vBitsClear(&dwType,ET_VALUE_DEFAULT_FLAG);
    // use our internal ID bit for defaults retrieval
    dwID   = INTERNAL_ET_VALUE_DEFAULT | petQueryValue->dwID;
  }

  // now decide if to get a DWORD or a String
  switch( dwSubEsc )
  {
    case SUBESC_ET_QUERY_VALUE_DWORD:
    {
      ET_VALUE_DWORD *petValueDWord = (ET_VALUE_DWORD*)pvOut;

      if (ET_VALUE_TYPE_DWORD != dwType) // must be DWord now, as Default flag is removed
      {
        DBG_ERROR("wrong type");
        break;
      }

      // Don't touch output before we have checked it!
      if (  ( sizeof(ET_VALUE_DWORD)!= cjOut )
          ||( sizeof(ET_VALUE_DWORD)!= petQueryValue->hdr.dwOutSize )  )
      {
        DBG_ERROR("outbuffer to small");
        break;
      }

      petValueDWord->dwSize   = sizeof(ET_VALUE_DWORD);
      petValueDWord->dwID     = petQueryValue->dwID;

      lResult = lRegGetIdDWord( hDriver, dwID, &petValueDWord->dwValue );

      // We handled the escape. Now we test and set for possible conditions and errors
      switch (lResult)
      {
        case REG_OK:      petValueDWord->dwFlags  = ET_VALUE_OK;
                          break;

        case REG_DEFAULT: petValueDWord->dwFlags  = ET_VALUE_DEFAULT;
                          break;

        case REG_ERROR:   petValueDWord->dwFlags  = ET_VALUE_UNKNOWN;
                          break;

        default :         RIP("lRegEtQueryValue: unknown lResult recieved from lRegGetIdxxx");
                          break;
      }

      vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "petValueDWord->dwFlags",petValueDWord->dwFlags);
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure

      vDbg_PrintET_VALUE_DWORD(DBG_LVL_FLOW1, "petValueDWord", petValueDWord);
      break;
    }

    case SUBESC_ET_QUERY_VALUE_STRING:
    {
      ET_VALUE_STRING *petValueString = (ET_VALUE_STRING*)pvOut;

      if (ET_VALUE_TYPE_STRING != dwType) // must be String now, as Default flag is removed
      {
        DBG_ERROR("wrong type");
        break;
      }

      // Don't touch output before we have checked it!
      if (  ( sizeof(ET_VALUE_STRING)!= cjOut )
          ||( sizeof(ET_VALUE_STRING)!= petQueryValue->hdr.dwOutSize )  )
      {
        DBG_ERROR("outbuffer to small");
        break;
      }

      petValueString->dwSize   = sizeof(ET_VALUE_STRING);
      petValueString->dwID     = petQueryValue->dwID;

      lResult = lRegGetIdSz( hDriver, dwID, petValueString->szValue, ET_MAX_STRING );

      // We handled the escape. Now we test and set for possible conditions and errors
      switch (lResult)
      {
        case REG_OK:      petValueString->dwFlags  = ET_VALUE_OK;
                          break;

        case REG_DEFAULT: petValueString->dwFlags  = ET_VALUE_DEFAULT;
                          break;

        case REG_ERROR:   petValueString->dwFlags  = ET_VALUE_UNKNOWN;
                          break;

        default :         RIP("lRegEtQueryValue: unknown lResult recieved from lRegGetIdxxx");
                          break;
      }

      vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "petValueString->dwFlags",petValueString->dwFlags);
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure

      vDbg_PrintET_VALUE_STRING(DBG_LVL_FLOW1, "petValueString", petValueString);
      break;
    }

    case SUBESC_ET_QUERY_VALUE_BINARY:
    {
      ET_VALUE_BINARY *petValueBinary = (ET_VALUE_BINARY*)pvOut;

      if (ET_VALUE_TYPE_BINARY != dwType) // must be binary now, as Default flag is removed
      {
        DBG_ERROR("wrong type");
        break;
      }

      // Don't touch output before we have checked it!
      if (  ( sizeof(ET_VALUE_BINARY) >= cjOut )
          ||( sizeof(ET_VALUE_BINARY) >= petQueryValue->hdr.dwOutSize )  )
      {
        DBG_ERROR("outbuffer to small");
        break;
      }

      petValueBinary->dwSize   = cjOut;
      petValueBinary->dwID     = petQueryValue->dwID;

      lResult = lRegGetIdBinary( hDriver, dwID, petValueBinary->ajData, cjOut-sizeof(ET_VALUE_BINARY));

      // We handled the escape. Now we test and set for possible conditions and errors
      switch (lResult)
      {
        case REG_OK:      petValueBinary->dwFlags  = ET_VALUE_OK;
                          break;

        case REG_DEFAULT: petValueBinary->dwFlags  = ET_VALUE_DEFAULT;
                          break;

        case REG_ERROR:   petValueBinary->dwFlags  = ET_VALUE_UNKNOWN;
                          break;

        default :         RIP("lRegEtQueryValue: unknown lResult recieved from lRegGetIdxxx");
                          break;
      }

      vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "petValueBinary->dwFlags",petValueBinary->dwFlags);
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure

      break;
    }

    default:
    {
      DISPDBG((DBG_LVL_ERROR, "lRegEtQueryValue: invalid dwSubEsc:0x%x",dwSubEsc));
      lRet = ESC_NOTSUPPORTED;
      break;
    }
  }

Exit:
#ifdef DBG
  if (petQueryValue->dwType & ET_VALUE_DEFAULT_FLAG)
  {
    ASSERTDD((ESC_SUCCESS==lRet), "default was queried, why did we fail?");
    DISPDBGCOND( ((((ET_VALUE_DWORD *)pvOut)->dwFlags)!=ET_VALUE_UNKNOWN) && (ET_VALUE_DEFAULT!=((ET_VALUE_DWORD *)pvOut)->dwFlags), (DBG_LVL_ERROR, "default was queried, why don't we report this? dwFlags:0x%x", ((ET_VALUE_DWORD *)pvOut)->dwFlags));
  }
#endif
  ASSERTDD((ESC_SUCCESS==lRet)||(ESC_NOTSUPPORTED==lRet)||(ESC_ERROR==lRet), "assumed interface has changed!");

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetESC_RETURN(lRet) ));

  return lRet;
}

//*******************************************************************************************
// 081098 MSchwarz 
// FNicklis 21.10.98: fixed return values
LONG lRegEtSetValue(
  IN  HANDLE            hDriver, 
  IN  DWORD             dwSubEsc, 
  IN  VOID             *pvIn, 
  IN  ULONG             cjIn, 
  OUT ET_SET_VALUE_RET *pSetValueRet)
{
  LONG     lRet      = ESC_ERROR; // Default error 
  LONG     lResult   = REG_ERROR; // Default error

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegEtSetValue);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX,"dwID:0x%x",(pvIn) ? ((ET_SET_VALUE_DWORD*)pvIn)->dwID : -1));

  ASSERT(NULL!=hDriver);
  ASSERT(NULL!=pvIn);

  // now decide if to set a DWORD or a String
  switch( dwSubEsc )
  {
    case SUBESC_ET_SET_VALUE_DWORD:
    {
      ET_SET_VALUE_DWORD *petSetDWord = pvIn;

      if ( sizeof(ET_SET_VALUE_DWORD) > cjIn )
      {
        DBG_ERROR("sizeof(ET_SET_VALUE_DWORD) > cjIn");
        break;
      }

      pSetValueRet->dwID = petSetDWord->dwID; // return structure nees ID
      lResult = lRegSetIdDWord( hDriver, petSetDWord->dwID, 
                                petSetDWord->dwValue );

      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
      break;

    }
    case SUBESC_ET_SET_VALUE_STRING:
    {
      ET_SET_VALUE_STRING *petSetString = pvIn;

      if ( sizeof(ET_SET_VALUE_STRING) > cjIn )
      {
        DBG_ERROR("sizeof(ET_SET_VALUE_DWORD) > cjIn");
        break;
      }

      pSetValueRet->dwID = petSetString->dwID; // return structure nees ID
      lResult = lRegSetIdSz( hDriver, petSetString->dwID, 
                             petSetString->szValue);
  
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
      break;
    }

    case SUBESC_ET_SET_VALUE_BINARY:
    {
      ET_SET_VALUE_BINARY *petSetBinary = pvIn;

      if ( sizeof(ET_SET_VALUE_BINARY) > cjIn )
      {
        DBG_ERROR("sizeof(ET_SET_VALUE_BINARY) > cjIn");
        break;
      }

      ASSERT(petSetBinary->hdr.dwSize==cjIn);
      pSetValueRet->dwID = petSetBinary->dwID; // return structure nees ID
      
      lResult = lRegSetIdBinary(hDriver, 
                                petSetBinary->dwID, 
                                (const BYTE *)petSetBinary->ajData,
                                cjIn-ET_SET_VALUE_BINARY_HDR_SIZE);
  
      lRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
      break;
    }

    default:
    {
      ASSERTDD(dwSubEsc==SUBESC_ET_SET_VALUE_DWORD, " invalid dwSubEsc");
      lRet = ESC_NOTSUPPORTED;
      break;
    }
  }

  // Handle return values and output buffer 
  // set bitfield in return structure
  // ERROR and SUCCESS should feed the output buffer error flags!
  if (ESC_NOTSUPPORTED!=lRet)
  {
    pSetValueRet->dwSize = sizeof(ET_SET_VALUE_RET);

    // We handled the escape, filled the out structure. 
    // Now we test and set for possible conditions and errors
    switch (lResult)
    {
      case REG_OK:      pSetValueRet->dwFlags  = ET_VALUE_OK;
                        break;

      case REG_DEFAULT: pSetValueRet->dwFlags  = ET_VALUE_DEFAULT;
                        break;

      case REG_ERROR:   pSetValueRet->dwFlags  = ET_VALUE_UNKNOWN;
                        break;

      default :         RIP("lRegEtSetValue: unknown lResult recieved from lRegSetIdDxx");
                        break;
    }

    vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "pSetValueRet->dwFlags",pSetValueRet->dwFlags);
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetESC_RETURN(lRet) ));

  return lRet;
}

/*
** lRegGetIdBinary
** lRegGetIdDWord
** lRegGetIdSz
** lRegGetIdMultiSz
**
** Read nByte or a DWORD out of the registry form the key matching dwID.
** The result is stored to pjData, pulData or pstrData.
**
** NOTE: String functions work on ascii/ansi strings. WCHAR conversion is done once
** in the miniport layer.
**
** For easier code handling all functions use lRegGetIdBinary. So we have
** one path to the registry only!
**
** returns: REG_OK:      operation successful, output data valid
**          REG_DEFAULT: operation successful but default value returned, output data valid
**          REG_ERROR:   operation failed, output data not valid
**
** MSchwarz 09.10.98: New
** FNicklis 23.10.98: Fixed error handling and functionality
*/
LONG lRegGetIdBinary(
  IN  HANDLE hDriver, 
  IN  DWORD  dwID, 
  OUT BYTE  *pjData, 
  IN  DWORD  nByte )
{
  LONG                lRet                  = REG_ERROR;  // ERROR
  IOCTL_ID_TRANSFER*  piit;
  ULONG               ulLength;
  ULONG               ulReturnedDataLength  = 0;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetIdBinary);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID),dwID));

  ASSERTDD(hDriver != NULL, "check environment");
  ASSERTDD(pjData  != NULL, "check caller's interface");
  ASSERTDD(nByte   != 0,    "check caller's interface");

  ulLength  =  sizeof(IOCTL_ID_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegGetIdBinary
  //
  if( piit )
  {
    DWORD dwWIN32Error=(DWORD)-1;  // IOCTL returns Win32 error code

    piit->dwId        = dwID;
    piit->dwDataSize  = nByte;

#if 0 // FNicklisch 14.09.00: unused
        dwWIN32Error = EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_ID_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_ID_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);
#else
        RIP("later");
#endif // FNicklisch 14.09.00: unused

    if (NO_ERROR == dwWIN32Error)
    {
      // only copy data on success or default

      ASSERTDD(ulReturnedDataLength==ulLength, "check params");

      lRet = piit->lReturnCode;                     // set error code
      RtlCopyMemory( pjData, piit->ajData, nByte ); // copy data to output buffer
    }

    EngFreeMem( piit );
  }
  else
  {
    DBG_ERROR("EngAllocMem failed");
  }

  ASSERTDD((lRet==REG_OK) || (lRet==REG_DEFAULT) || (lRet==REG_ERROR), "unknown return value!");

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

/*
** lRegGetIdDWord see above
**
** FNicklis 23.10.98: New
*/
LONG lRegGetIdDWord(
  IN  HANDLE hDriver, 
  IN  DWORD  dwID, 
  OUT DWORD *pulData)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetIdDWord);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID),dwID));
  DBGFLAGSNEW(DBG_LVL_2WARNING);// switch of lazy redundant debug info

  lRet = lRegGetIdBinary(hDriver, dwID, (BYTE *)pulData, sizeof(DWORD));

  DBGFLAGSOLD();
  DISPDBGCOND((REG_ERROR==lRet),(DBG_LVL_WARNING, "WARNING: REG_ERROR in lRegGetIdDWord on dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID),dwID));
  DISPDBG((DBG_LVL_FLOW0,"ulData:0x%x %s",( (NULL!=pulData)? (*pulData) : (-1) ), (REG_DEFAULT==lRet) ? "(default)": (REG_ERROR==lRet) ? "!!ERROR!!":""));

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," (%s)",(lRet==REG_OK) ? "REG_OK" : ((lRet==REG_DEFAULT) ? "REG_DEFAULT" :"REG_ERROR") ));

  return lRet;
}

/*
** lRegGetIdSz see above
**
** FNicklis 23.10.98: New
*/
LONG lRegGetIdSz(
  IN  HANDLE hDriver, 
  IN  DWORD  dwID, 
  OUT PSTR   pstrData, 
  IN  DWORD  nByte)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetIdSz);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID&INTERNAL_ET_VALUE_KEY_ID_ONLY_MASK),(dwID&INTERNAL_ET_VALUE_KEY_ID_ONLY_MASK)));
  DBGFLAGSNEW(DBG_LVL_2WARNING);// switch of lazy redundant debug info

  lRet = lRegGetIdBinary(hDriver, dwID, (BYTE *)pstrData, nByte);

  DBGFLAGSOLD();
  DISPDBG((DBG_LVL_FLOW0,"pstrData:%s %s",((REG_ERROR!=lRet)?pstrData:"--- invalid data ---"), (REG_DEFAULT==lRet) ? "(default)": (REG_ERROR==lRet) ? "!!ERROR!!":""));

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

/*
** lRegGetIdMultiSz see above
**
** FNicklis 23.10.98: New
*/
LONG lRegGetIdMultiSz(
  IN  HANDLE hDriver, 
  IN  DWORD  dwID, 
  OUT PSTR   pstrData, 
  IN  DWORD  nByte)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetIdMultiSz);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:%s (0x%x)",szDbg_GetET_VALUE_IDName(dwID),dwID));
  DBGFLAGSNEW(DBG_LVL_2WARNING);// switch of lazy redundant debug info
  
  lRet = lRegGetIdBinary(hDriver, dwID, (BYTE *)pstrData, nByte);

  DBGFLAGSOLD();
  DISPDBG((DBG_LVL_FLOW0,"pstrData:%s %s",((REG_ERROR!=lRet)?pstrData:"--- invalid data ---"), (REG_DEFAULT==lRet) ? "(default)": (REG_ERROR==lRet) ? "!!ERROR!!":""));

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

// *******************************************************************************************

/*
** lRegSetIdBinary
** lRegSetIdDWord 
** lRegSetIdSz 
** lRegSetIdMultiSz 
**
** writes nByte byte or a DWORD to the registry key matching dwID. 
** pjData and pstrData are pointers to a nByte sized buffer, 
** ulData is the value to write.
**
** NOTE: String functions work on ascii/ansi strings. WCHAR conversion is done once
** in the miniport layer.
**
** returns: REG_OK:      operation successful, data written
**          REG_ERROR:   operation failed, data not written
**         (REG_DEFAULT): a future extension could return this, if this was the default data
**
** MSchwarz 09.10.98: New
** FNicklis 23.10.98: Fixed error handling and functionality
*/
LONG lRegSetIdBinary(
  IN       HANDLE hDriver, 
  IN       DWORD  dwID, 
  IN const BYTE  *pjData, 
  IN       DWORD  nByte)
{
  LONG                lRet                 = REG_ERROR;

  IOCTL_ID_TRANSFER*  piit;
  ULONG               ulLength;
  ULONG               ulReturnedDataLength = 0;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegSetIdBinary);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:0x%x (%s), pjData:0x%x, nByte:%d",dwID,szDbg_GetET_VALUE_IDName(dwID),pjData,nByte));

  ASSERTDD(hDriver != NULL, "check environment");

  ASSERTDD(pjData  != NULL, "check caller's interface");
  ASSERTDD(nByte   != 0,    "check caller's interface");

  ulLength = sizeof(IOCTL_ID_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);

  if( piit )
  {
    DWORD dwWIN32Error=(DWORD)-1;  // IOCTL returns Win32 error code

    piit->dwId        = dwID;
    piit->dwDataSize  = nByte;
    //piit->dwDataType  = REG_BINARY;
    RtlCopyMemory( piit->ajData, pjData, nByte );

#if 0 // FNicklisch 14.09.00: unused
        //  call IOCTL vstatIoctlRegSetIdBinary
    dwWIN32Error = EngDeviceIoControl( hDriver,
                                       IOCTL_VIDEO_REG_ID_TRANSFER_SET,
                                       (VOID*)(piit),ulLength,
                                       (VOID*)(piit),0,
                                       &ulReturnedDataLength);
#else
        RIP("later");
#endif // FNicklisch 14.09.00: unused
    if (NO_ERROR == dwWIN32Error)
    {
      ASSERTDD(ulReturnedDataLength==ulLength, "check params");

      lRet = piit->lReturnCode; // set error code

      if ( REG_DEFAULT==lRet )
      {
        // only default set returns default return code!
        if (!bBitsTest(dwID,INTERNAL_ET_VALUE_DEFAULT))
        {
          lRet = REG_OK;
        }
      }
    }

    EngFreeMem( piit );
  }
  else
  {
    DBG_ERROR("EngAllocMem failed");
  }

  ASSERTDD((lRet==REG_OK) || (lRet==REG_ERROR), "unknown return value!");

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

/*
** lRegSetIdDWord see above
**
** FNicklis 23.10.98: New
*/
LONG lRegSetIdDWord(
  IN HANDLE hDriver, 
  IN DWORD  dwID, 
  IN DWORD  ulData)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegSetIdDWord);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:0x%x, ulData:0x%x",dwID,ulData));

  lRet = lRegSetIdBinary(hDriver, dwID, (const BYTE *)&ulData, sizeof(DWORD));

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," (%s)",(lRet==REG_OK) ? "REG_OK" : ((lRet==REG_DEFAULT) ? "REG_DEFAULT" :"REG_ERROR") ));
  return lRet;
}

/*
** lRegSetIdSz see above
**
** FNicklis 23.10.98: New
*/
LONG lRegSetIdSz(
 IN       HANDLE hDriver, 
 IN       DWORD  dwID, 
 IN const PSTR   pstrData)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegSetIdSz);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," dwID:0x%x, pstrData:%s",dwID,pstrData));

  lRet = lRegSetIdBinary(hDriver, dwID, (const BYTE *)pstrData, strlen(pstrData)+1/*ulStrTrueLen(pstrData)*/);

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetREG_RETURN(lRet) ));

  return lRet;
}

/*
** lRegSetIdMultiSz see above
**
** FNicklis 23.10.98: New
*/
LONG lRegSetIdMultiSz(
 IN       HANDLE hDriver, 
 IN       DWORD  dwID, 
 IN const PSTR   pstrData, 
 IN       DWORD  nByte )
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetIdMultiSz);

  lRet = lRegSetIdBinary(hDriver, dwID, (const BYTE *)pstrData, nByte);

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," (%s)",(lRet==REG_OK) ? "REG_OK" : ((lRet==REG_DEFAULT) ? "REG_DEFAULT" :"REG_ERROR") ));

  return lRet;
}

//*******************************************************************************************
// 081098 MSchwarz 
// FNicklis 21.10.98: fixed return values
LONG lRegEtDefaultValue(
  IN  HANDLE                hDriver, 
  IN  ET_SET_VALUE_DEFAULT *pDefaultValue, 
  OUT ET_SET_VALUE_RET     *pSetValueRet)
{
  LONG     lRet      = ESC_ERROR; // Default error 
  LONG     lResult   = REG_ERROR; // Default error

  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegEtDefaultValue);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX,"dwID:0x%x",(pDefaultValue) ? pDefaultValue->dwID : -1));

  ASSERT(NULL!=hDriver);
  ASSERT(NULL!=pDefaultValue);
  ASSERT(NULL!=pSetValueRet);

  RtlZeroMemory(pSetValueRet, sizeof(ET_SET_VALUE_RET));

  // preset return structure to error
  pSetValueRet->dwSize = sizeof(ET_SET_VALUE_RET);
  pSetValueRet->dwID   = pDefaultValue->dwID;
  pSetValueRet->dwFlags= ET_VALUE_UNKNOWN; // default error

  // To make code writing and debugging easier I implement this in
  // a two step way. First I read the default from the Miniport,
  // then I write this value again.

  // This helps me to keep the code easy, as I only need to modify
  // the miniports query function.

  // Mask out the default flag as it is useless in this call

  switch (pDefaultValue->dwType & ~ET_VALUE_DEFAULT_FLAG)
  {
    case ET_VALUE_TYPE_DWORD:
    {
      DWORD dwDefault;

      lResult = lRegGetIdDWord(
        hDriver, 
        INTERNAL_ET_VALUE_DEFAULT | pDefaultValue->dwID, 
        &dwDefault);

      if (lResult==REG_ERROR)
      {
        DBG_ERROR("lRegGetIdDWord failed");
        pSetValueRet->dwFlags= ET_VALUE_UNKNOWN;
      }
      else
      {      
        lResult = lRegSetIdDWord(
          hDriver, 
          pDefaultValue->dwID,
          dwDefault);
      }
      break;
    }

    case ET_VALUE_TYPE_STRING:
    {
      PSTR pszDefault;

      // allocate temporary buffer
      if (bAllocMem((PVOID *)&pszDefault, sizeof(ET_MAX_STRING), ALLOC_TAG))
      {
        // add default flag to read the default.
        lResult = lRegGetIdSz(
          hDriver, 
          INTERNAL_ET_VALUE_DEFAULT | pDefaultValue->dwID, 
          pszDefault,
          ET_MAX_STRING);

        if (lResult==REG_ERROR)
        {
          DBG_ERROR("lRegGetIdSz failed");
          pSetValueRet->dwFlags= ET_VALUE_UNKNOWN;
        }
        else 
        {      
          // write the default read above again!
          lResult = lRegSetIdSz(
            hDriver, 
            pDefaultValue->dwID,
            pszDefault);
        }

        // free temporary buffer again
        bFreeMem((PVOID *)&pszDefault, sizeof(ET_MAX_STRING));
      }
      break;
    }

    default:
      ASSERTDD(pDefaultValue->dwType==ET_VALUE_TYPE_STRING, "unkown ET_VALUE_TYPE_xx");
      break;
  }

  if (REG_ERROR != lResult)
  {
    pSetValueRet->dwFlags= ET_VALUE_DEFAULT;
  }
  else
  {
    DBG_ERROR("failed to set the default value");
  }

  // The escape doesn't fail! 
  // But error codes are stored in the return structure
  lRet = ESC_SUCCESS;

  DBG_TRACE_OUT(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED, lRet);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX, " (%s)",szDbg_GetESC_RETURN(lRet) ));

  return lRet;
}

// *******************************************************************************************
// * End of functions manipulationg registry via ID code
// *******************************************************************************************

#if 0 // FNicklis seems to be unused code...

//*******************************************************************************************
// 091098 MSchwarz 
LONG lRegGetValueBinary( HANDLE hDriver, PSTR pstrValue, BYTE* pjData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                  =  REG_ERROR;  // ERROR
  ULONG               ulReturnedDataLength  =  0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegGetValueBinary);

  ASSERTDD(hDriver != NULL, "lRegGetValueBinary");
  ASSERTDD(pjData  != NULL, "lRegGetValueBinary");
  ASSERTDD(nByte   != 0,    "lRegGetValueBinary");

  ulLength  =  sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegGetValueBinary
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_BINARY;

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_SZ_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);

    RtlCopyMemory( pjData, piit->ajData, nByte );

    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 091098 MSchwarz 
LONG lRegSetValueBinary( HANDLE hDriver, PSTR pstrValue, BYTE* pjData, DWORD nByte )
{

  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                =  REG_ERROR;
  ULONG               ReturnedDataLength  =  0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetValueBinary);

  //  call IOCTL 
  ASSERTDD(hDriver != NULL, "lRegSetValueBinary");
  ASSERTDD(pjData  != NULL, "lRegSetValueBinary");
  ASSERTDD(nByte   != 0,    "lRegSetValueBinary");

  ulLength = sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegSetValueBinary
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_BINARY;
    RtlCopyMemory( piit->ajData, pjData, nByte );

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_SET,
                                     (VOID*)(piit),ulLength,
                                     (VOID*)(piit),0,
                                     &ReturnedDataLength);
    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 091098 MSchwarz 
LONG lRegGetValueDWord( HANDLE hDriver, PSTR pstrValue, DWORD* pulData )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                  =  REG_ERROR;  // ERROR
  ULONG               ulReturnedDataLength  =  0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0|DBG_LVL_NOLINEFEED,lRegGetValueDWord);
  DISPDBG((DBG_LVL_FLOW0|DBG_LVL_NOPREFIX," pstrValue:%s",pstrValue));

  ASSERTDD(hDriver != NULL, "lRegGetValueDWord");
  ASSERTDD(pulData != NULL, "lRegGetValueDWord");

  ulLength  =  sizeof(IOCTL_SZ_TRANSFER) + sizeof(DWORD);

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegGetValueDWord
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = sizeof(DWORD);
    piit->dwDataType  = REG_DWORD;

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_SZ_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);

    RtlCopyMemory( pulData, piit->ajData, sizeof(DWORD) );

    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 121098 MSchwarz 
LONG lRegSetValueDWord( HANDLE hDriver, PSTR pstrValue, DWORD* pulData )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                =  REG_ERROR;
  ULONG               ReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetValueDWord);

  ASSERTDD(hDriver != NULL, "lRegSetValueDWord");
  ASSERTDD(pulData != NULL, "lRegSetValueDWord");

  ulLength = sizeof(IOCTL_SZ_TRANSFER) + sizeof(DWORD);

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegSetValueDWord
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = sizeof(DWORD);
    piit->dwDataType  = REG_DWORD;
    RtlCopyMemory( piit->ajData, pulData, sizeof(DWORD) );

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_SET,
                                     (VOID*)(piit),ulLength,
                                     (VOID*)(piit),0,
                                     &ReturnedDataLength);
    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 141098 MSchwarz 
LONG lRegGetValueSz( HANDLE hDriver, PSTR pstrValue, PSTR pstrData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                  =  REG_ERROR;  // ERROR
  ULONG               ulReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegGetValueSz);

  ASSERTDD(hDriver  != NULL, "lRegGetValueSz");
  ASSERTDD(pstrData != NULL, "lRegGetValueSz");

  ulLength  =  sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegGetValueSz
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_SZ;

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_SZ_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);

    RtlCopyMemory( pstrData, piit->ajData, nByte );

    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 141098 MSchwarz 
LONG lRegSetValueSz( HANDLE hDriver, PSTR pstrValue, PSTR pstrData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                =  REG_ERROR;
  ULONG               ReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetValueSz);

  ASSERTDD(hDriver  != NULL, "lRegSetValueSz");
  ASSERTDD(pstrData != NULL, "lRegSetValueSz");

  ulLength = sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctlRegSetValueSz
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_SZ;
    RtlCopyMemory( piit->ajData, pstrData, nByte );

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_SET,
                                     (VOID*)(piit),ulLength,
                                     (VOID*)(piit),0,
                                     &ReturnedDataLength);
    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 141098 MSchwarz 
LONG lRegGetValueMultiSz( HANDLE hDriver, PSTR pstrValue, PSTR pstrData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                  =  REG_ERROR;  // ERROR
  ULONG               ulReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegGetValueMultiSz);

  ASSERTDD(hDriver  != NULL, "lRegGetValueMultiSz");
  ASSERTDD(pstrData != NULL, "lRegGetValueMultiSz");

  ulLength  =  sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctRegGetValueMultiSz
  //
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_MULTI_SZ;

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_GET,
                                     (VOID*)(piit),sizeof(IOCTL_SZ_TRANSFER),
                                     (VOID*)(piit),ulLength,
                                     &ulReturnedDataLength);

    RtlCopyMemory( pstrData, piit->ajData, nByte );

    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}

//*******************************************************************************************
// 141098 MSchwarz 
LONG lRegSetValueMultiSz( HANDLE hDriver, PSTR pstrValue, PSTR pstrData, DWORD nByte )
{
  IOCTL_SZ_TRANSFER*  piit;
  ULONG               ulLength;
  LONG                lRet                =  REG_ERROR;
  ULONG               ReturnedDataLength  =   0;
  //  <0 Error  
  // ==0 OK
  //  >0 Default
  DBG_TRACE_IN(DBG_LVL_FLOW0,lRegSetValueMultiSz);

  ASSERTDD(hDriver  != NULL, "lRegSetValueMultiSz");
  ASSERTDD(pstrData != NULL, "lRegSetValueMultiSz");

  ulLength = sizeof(IOCTL_SZ_TRANSFER) + nByte;

  piit = EngAllocMem( FL_ZERO_MEMORY, ulLength, ALLOC_TAG);
  //  call IOCLTRL vstatIoctRegSetValueMultiSz
  if( piit )
  {
    strcpy( piit->szId, pstrValue );
    piit->dwDataSize  = nByte;
    piit->dwDataType  = REG_MULTI_SZ;
    RtlCopyMemory( piit->ajData, pstrData, nByte );

    lRet = (LONG)EngDeviceIoControl( hDriver,
                                     IOCTL_VIDEO_REG_SZ_TRANSFER_SET,
                                     (VOID*)(piit),ulLength,
                                     (VOID*)(piit),0,
                                     &ReturnedDataLength);
    EngFreeMem( piit );
  }

  DBG_TRACE_OUT(DBG_LVL_FLOW0,lRet);

  return lRet;
}
#endif
//*******************************************************************************************

/*
** bRegRead (single board)
**
** Initialize driver with information taken out of registry...
**
** returns TRUE if successful
**
** FNicklis 22.10.98: derived from bPageflipModeUpdate
*/
BOOL bRegRead(PPDEV ppdev)
{
  BOOL  bRet     = FALSE;
  ULONG ulSwitch = FALSE;// used as boolean to read registry

  DBG_TRACE_IN(DBG_LVL_FLOW0, bRegRead);

#if 0 // ELSA-FNicklis 04.07.00: unused
    if ( (1==ppdev->cjPelSize) ||                  // 8 bpp
       (ppdev->cyMemory < (ppdev->cyScreen*2)) ) // front, Z
  {
    // 3D not possible

    DBG_ERROR("No room for SB-OpenGL, disable OpenGL");    
    v3DCapsClear((ULONG)0xFFFFFFFF); // clear all bits!

    v3DCapsClear(FL_3DCAPS_3D_POSSIBLE) ;
    v3DCapsClear(FL_3DCAPS_HARDWARE_ACCELERATION);
  }
  else
  {
    // 3D possible!
    ULONG ulBuffers = 0;     // number of decided buffers
    BOOL  bDouble   = TRUE;  // try double buffering
    BOOL  bPageflip = FALSE; // allow pageflipping
    BOOL  bOverlay  = FALSE; // overlay not default
    BOOL  bStereo   = FALSE; // overlay not default

    // We have an accelerated board but...
    v3DCapsSet(FL_3DCAPS_3D_POSSIBLE);

    // ...perhaps it is disabled by the user 
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_DISABLE, &ulSwitch ) )
    {
      ulSwitch = TRUE; // default is 3D on
    }

    // disable != 0 (TRUE) -> not enabled
    if (0 != ulSwitch)
    {
      // 3D acceleration disabled
      v3DCapsClear(FL_3DCAPS_HARDWARE_ACCELERATION);
    }
    else
    {
      // 3D acceleration enabled
      v3DCapsSet(FL_3DCAPS_HARDWARE_ACCELERATION);
    }

    // Check memory capabilities
    bDouble  = bOpenGLDoubleBufferPossible(ppdev);
    bStereo  = bOpenGLStereoBufferPossible(ppdev);
    bOverlay = bOpenGLOverlayBufferPossible(ppdev);


    // write double buffer state
    if (REG_ERROR == lRegSetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS, (bDouble ? 2 : 1)) )
    {
      DBG_ERROR("lRegSetIdDWord failed: ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS");
    }

    // Set Pixelformats PFD_SUPPORT_GDI flag?
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PFD_SUPPORT_GDI, &ulSwitch) )
      ulSwitch = TRUE;

    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_SUPPORT_GDI);
    else
      v3DCapsClear(FL_3DCAPS_PFD_SUPPORT_GDI);

    // configure SWBC layer
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS, &ulSwitch) )
      ulSwitch = FALSE;

    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_FORCEGDIBROADCAST);
    else
      v3DCapsClear(FL_3DCAPS_FORCEGDIBROADCAST);

    // check double buffer user settings
    if (bDouble)
    {
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS, &ulBuffers ) )
        ulBuffers = 2;
    }
    else
      ulBuffers = 1;

    // check double buffer capabilities
    if (ulBuffers > 1)
    {
      v3DCapsSet(FL_3DCAPS_PFD_DOUBLEBUFFER);

      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_ALIGNED_SURFACES, &ulSwitch ) )
        ulSwitch = 0;
      if (0 != ulSwitch)
        v3DCapsSet(FL_3DCAPS_ALIGNED_SURFACES);
      else
        v3DCapsClear(FL_3DCAPS_ALIGNED_SURFACES);
        
      // check ForceSingleBuffered
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_FORCE_SINGLEBUFFERED, &ulSwitch ) )
        ulSwitch = 0;
      if (0 != ulSwitch)
        v3DCapsSet(FL_3DCAPS_FORCE_SINGLEBUFFERD);
      else
        v3DCapsClear(FL_3DCAPS_FORCE_SINGLEBUFFERD);

      //
      // We always support blitted swap buffers, but do we need PFDs that
      // only can blit?
      //
      // Check if we export PFD_SWAP_COPY DrvDescribePixelformat
      //
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY, &ulSwitch) )
        ulSwitch=1;
      if (ulSwitch)
        v3DCapsSet(FL_3DCAPS_PFD_SWAP_COPY);
      else
        v3DCapsClear(FL_3DCAPS_PFD_SWAP_COPY);

#ifdef RUN_WITH_NVIDIA_MINIPORT 
      bPageflip = FALSE;
#else //RUN_WITH_NVIDIA_MINIPORT 
      //
      // Check if we allow pageflipping, else we would force buffer blits
      //
      // ulSwitch = 0 on Riva TNT! // cannot do HBlank-flip on NV4, so disable pageflipping
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING, &ulSwitch ) )
        ulSwitch = 1; // allow pageflip

      if (0!=ulSwitch)
        bPageflip = TRUE;
#endif//RUN_WITH_NVIDIA_MINIPORT 
    }
    else
    {
      // double buffering disabled
      bDouble  = FALSE; // no double
      v3DCapsClear( FL_3DCAPS_PFD_DOUBLEBUFFER
                   |FL_3DCAPS_PFD_SWAP_COPY);
    }

    //
    // Check vblank user settings
    //
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT, &ulSwitch ) )
      ulSwitch = FALSE;

    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_VBLANKWAIT);           // wait for vblank
    else
      v3DCapsClear(FL_3DCAPS_VBLANKWAIT);

    //
    // Set page flip capabilities
    //
    if (bPageflip)
    {
      // Pageflipping allowed and possible - clear the force buffer blit bit
      v3DCapsSet(FL_3DCAPS_PAGEFLIP);          // try a pageflip in swap buffers

      // export PFD_SWAP_EXCHANGE in DrvDescribePixelformat?
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE, &ulSwitch) )
        ulSwitch = 1;
      if (ulSwitch)
      { // export Swap_exchange in pixelformat
        v3DCapsSet(FL_3DCAPS_PFD_SWAP_EXCHANGE);
      }
      else
      {
        v3DCapsClear(FL_3DCAPS_PFD_SWAP_EXCHANGE);
      }
    }
    else
    {
      // not possible to do pagefliping or tripple buffering
      v3DCapsClear( FL_3DCAPS_PAGEFLIP
                   |FL_3DCAPS_PFD_SWAP_EXCHANGE);
    }

    // Check OpenGL DMA Flush -> don't flip or blit
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_DISABLEDMAFLUSHES, &ulSwitch ) )
      ulSwitch = 0;

    // Disable ICD rendering: Bits:0x1==ICD only, 2==Display driver
    if (ulSwitch&0x2) 
      v3DCapsSet(FL_3DCAPS_NODMAFLUSH);
    else
      v3DCapsClear(FL_3DCAPS_NODMAFLUSH);

    // Export Buffer Region extension?
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_KTX_BUFFERREGIONS, &ulSwitch ) )
      ulSwitch = 1;

    // Disable ICD rendering: Bits:0x1==ICD only, 2==Display driver
    if (ulSwitch) 
      v3DCapsSet(FL_3DCAPS_KTXBUFFERREGIONS);
    else
      v3DCapsClear(FL_3DCAPS_KTXBUFFERREGIONS);


    // Export Buffer Region extension?
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_KTX_SWAPHINTS, &ulSwitch ) )
      ulSwitch = 1;
    // Disable ICD rendering: Bits:0x1==ICD only, 2==Display driver
    if (ulSwitch) 
      v3DCapsSet(FL_3DCAPS_KTXSWAPHINTS);
    else
      v3DCapsClear(FL_3DCAPS_KTXSWAPHINTS);


    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_DISABLE_STENCIL, &ulSwitch ) )
      ulSwitch = 0; // don't disable stencil by default
    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_DISABLE_STENCIL);
    else
      v3DCapsClear(FL_3DCAPS_PFD_DISABLE_STENCIL);


    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_OPENGL_DISABLE_ALPHA, &ulSwitch ) )
      ulSwitch = 0; // don't disable stencil by default
    if (ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_DISABLE_ALPHA);
    else
      v3DCapsClear(FL_3DCAPS_PFD_DISABLE_ALPHA);

    //
    // Set stereo capabilities
    //
    if (REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT, &ulSwitch) )
      ulSwitch = 0; // don't use stereo by default

    if(    (bStereo)
        && (0!=ulSwitch) 
      )
    {
      v3DCapsSet(FL_3DCAPS_PFD_STEREO);

      if (REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS, &ulSwitch) )
        ulSwitch = 0; // don't force stereo buffers by default
      if( 0!=ulSwitch )
        v3DCapsSet(FL_3DCAPS_FORCE_STEREO);
      else
        v3DCapsClear(FL_3DCAPS_FORCE_STEREO);
    }
    else
    {
      v3DCapsClear(FL_3DCAPS_PFD_STEREO);
      v3DCapsClear(FL_3DCAPS_FORCE_STEREO);
    }

    //
    // Set overlay capabilities
    //
    if (REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES, &ulSwitch) )
      ulSwitch = 0; // don't use overlay by default

    if (   bOverlay
        && (0!=ulSwitch) )
    {
      v3DCapsSet(FL_3DCAPS_PFD_OVERLAYS);
      v3DCapsSet(FL_3DCAPS_OVERLAYS_VIA_FRONT); // MSchwarz 2.11.99:  refer to o_overlay.c: 4. 1st comment
      v3DCapsSet(FL_3DCAPS_OVERLAY_SWBC);
      // Set swap layer caps
      if (REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS, &ulSwitch) )
        ulSwitch = 1; // allow swap layerbuffers by default
      if (ulSwitch)
        v3DCapsSet(FL_3DCAPS_PFD_SWAP_LAYER_BUFFERS);
      else
        v3DCapsClear(FL_3DCAPS_PFD_SWAP_LAYER_BUFFERS);
    }
    else
    {
      if (0!=ulSwitch)
      {
        DBG_ERROR("Want overlay but not enough offscreen");
      }
      v3DCapsClear(FL_3DCAPS_PFD_OVERLAYS);
      v3DCapsClear(FL_3DCAPS_PFD_SWAP_LAYER_BUFFERS);
    }

    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_FORCE_STENCIL, &ulSwitch ) )
      ulSwitch = 0; // don't disable stencil by default
    if (0!=ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_FORCE_STENCIL);
    else
      v3DCapsClear(FL_3DCAPS_PFD_FORCE_STENCIL);

    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_ICDINTERFACE_FORCE_MORETHAN16BITZ, &ulSwitch ) )
      ulSwitch = 0; // don't disable stencil by default
    if (0!=ulSwitch)
      v3DCapsSet(FL_3DCAPS_PFD_FORCE_MORETHAN16BITZ);
    else
      v3DCapsClear(FL_3DCAPS_PFD_FORCE_MORETHAN16BITZ);

    //
    // Determine if ICD awaits client or board relative clip rects within shared info
    // Documentaion in o_Clipping.c
    //
    // NOTE: This key has no default, so set it here in all cases!
    v3DCapsClear(FL_3DCAPS_CLIENTRELATIVECLIPRECTS);
    v3DCapsClear(FL_3DCAPS_BOARDRELATIVECLIPRECTS);
    if ( REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS, &ulSwitch) )
    {
      if (bIsSingleScreen(ppdev))
        ulSwitch = DEFAULT_OPENGL_CLIENTCLIPRECTS_1BOARD; // use single board default
      else
        ulSwitch = DEFAULT_OPENGL_CLIENTCLIPRECTS_NBOARD; // use multi boarddefault
    }
    else
    {
      DBG_WARNING("INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS overwritten by registry!");
    }
    
    switch (ulSwitch)
    {
      case CCT_DESKTOPRELATIVE: 
        // desktop relative clip rects
        break;
      case CCT_BOARDRELATIVE:   
        // board relative
        v3DCapsSet(FL_3DCAPS_BOARDRELATIVECLIPRECTS);
        break;
      case CCT_CLIENTRELATIVE: 
        // client relative
        v3DCapsSet(FL_3DCAPS_CLIENTRELATIVECLIPRECTS);
        break;
      case CCT_CLIENTANDBOARDRELATIVE: 
        // board and client relative
        v3DCapsSet(FL_3DCAPS_BOARDRELATIVECLIPRECTS);
        v3DCapsSet(FL_3DCAPS_CLIENTRELATIVECLIPRECTS);
        break;
      default:
        v3DCapsSet(FL_3DCAPS_BOARDRELATIVECLIPRECTS);
        v3DCapsSet(FL_3DCAPS_CLIENTRELATIVECLIPRECTS);
        ASSERTDD(DEFAULT_OPENGL_CLIENTCLIPRECTS_1BOARD==ulSwitch, "set to client and board relative");
        break;
    }

    #if BETA_VERSION
    if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_OPENGL_NO_ICD_CALLBACK, &ulSwitch ) )
      ulSwitch = 0;
    if (0!=ulSwitch)
      v3DCapsSet(FL_3DCAPS_NO_ICD_CALLBACK);  
    else
      v3DCapsClear(FL_3DCAPS_NO_ICD_CALLBACK);
    #endif    

    #ifdef DBG
      if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_DBG_OPENGLBUFFERNO, &ulSwitch ) )
        ulSwitch = FALSE;

      if (ulSwitch)
        v3DCapsSet(FL_3DCAPS_DBG_PRINTBUFFERNUMBER);  
      else
        v3DCapsClear(FL_3DCAPS_DBG_PRINTBUFFERNUMBER);
    #endif
    vDbg_Printfl3DCapabilities(DBG_LVL_FLOW0, "ppdev->fl3DCapabilities", ppdev);
  }

#ifdef DBG
#ifdef _WIN64
  v3DCapsSet(FL_3DCAPS_DBG_PRINTBUFFERNUMBER);
#endif

  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_DBG_CHECKHEAPINTEGRITY, (DWORD *)&bDbg_CheckHeap) )
    bDbg_CheckHeap = TRUE;

  DBG_PRINTB(DBG_LVL_FLOW0, bDbg_CheckHeap);
#endif

#if BETA_VERSION
  if ( REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_DBG_SURFACENEVERATBOTTOM, &ulSwitch) )
    ulSwitch = 0;

  if (0!=ulSwitch)
  {
    DBG_WARNING("We override the Heaps HEAP_ALLOC_TYPE_POS_BOTTOM flag now!");
    v2DCapsSet(FL_2DCAPS_SURFACENEVERATBOTTOM);
  }
  else
    v2DCapsClear(FL_2DCAPS_SURFACENEVERATBOTTOM);
  
  if ( REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_HELPERFLAGS, &ppdev->flRegHelperFlags) )
    ppdev->flRegHelperFlags = 0;

  // Read reserved keys for internal and temporary usage.
  // Never check in code that uses ulRegReserved0-9!
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED0, &ppdev->ulRegReserved0) )
    ppdev->ulRegReserved0 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED1, &ppdev->ulRegReserved1) )
    ppdev->ulRegReserved1 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED2, &ppdev->ulRegReserved2) )
    ppdev->ulRegReserved2 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED3, &ppdev->ulRegReserved3) )
    ppdev->ulRegReserved3 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED4, &ppdev->ulRegReserved4) )
    ppdev->ulRegReserved4 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED5, &ppdev->ulRegReserved5) )
    ppdev->ulRegReserved5 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED6, &ppdev->ulRegReserved6) )
    ppdev->ulRegReserved6 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED7, &ppdev->ulRegReserved7) )
    ppdev->ulRegReserved7 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED8, &ppdev->ulRegReserved8) )
    ppdev->ulRegReserved8 = 0;
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_RESERVED9, &ppdev->ulRegReserved9) )
    ppdev->ulRegReserved9 = 0;
#endif

  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_DDRAWSUPPORT_OVERLAYSHRINK, &ulSwitch ) )
    ulSwitch = 0;
  
  //  Skuklik: 09.02.2000
  //  0002.0115.5432.CBUE
  //  to fix misbehavior with mediamatics DVD Express
  //  Enabling support for OverlayShrink in DDraw causes fails in HCT (TDDraw) 
  //  CASE 12: Consume all Vid Mem Test (TC 6.1.1) fails
  //  So just turn on this feature if needed by an application, and disable it by default

  if (0!=ulSwitch)
    v2DCapsSet(FL_2DCAPS_SUPPORT_OVERLAYSHRINK);  
  else
    v2DCapsClear(FL_2DCAPS_SUPPORT_OVERLAYSHRINK);

  vDbg_Printfl2DCapabilities(DBG_LVL_FLOW0, "ppdev->fl2DCapabilities", ppdev);

  bRet = TRUE;
#endif // ELSA-FNicklis 04.07.00: unused

  DBG_TRACE_OUT(DBG_LVL_FLOW0, bRet);
  return (bRet);
}

#if DBG
// ELSA-FNicklis 14.04.00: global to help masking of punt flags below.
FLONG flDbgPunt=0xFFFFFFFF;
#endif

/*
** bRegInit
**
** Initialize registry stuff and read driver init values.
**
** FNicklis 27.05.1999: Moved DrvEnableSurface stuff to this function.
*/
BOOL bRegInit(PPDEV ppdev)
{
  ULONG ulSwitch;
  BOOL  bRet = FALSE;

#if 0 // ELSA-FNicklis 04.07.00: unused
    ASSERT(NULL!=ppdev);
  ASSERT(NULL!=ppdev->hDriver);

  // MSchwarz 161098 moved it from RegRead because EnableHardware needs the value
  if(REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_GDI_DMABUFFERSIZE, &ppdev->DmaPushBufTotalSize))
  {
    ppdev->DmaPushBufTotalSize = DMAPUSH_BUFFER_SIZE;
    DISPDBG((DBG_LVL_ERROR, "ERROR in %s failed to read %s: ppdev->DmaPushBufTotalSize: 0x%x",
      szDbg_TRACE_GetCurrentFn(),
      szDbg_GetET_VALUE_IDName(ET_VALUE_DW_GDI_DMABUFFERSIZE), 
      ppdev->DmaPushBufTotalSize));
  }

  // Need at least 8kb buffer to run properly
  if (ppdev->DmaPushBufTotalSize < ((8 KB) + sizeof(DWORD)))
    ppdev->DmaPushBufTotalSize = DMAPUSH_BUFFER_SIZE;

  if(REG_ERROR == lRegGetIdDWord(ppdev->hDriver, ET_VALUE_DW_GDI_DMAPADDING, &ppdev->ulDmaPadding))
  {
    ppdev->ulDmaPadding = DMAPUSH_PADDING;
    DISPDBG((DBG_LVL_ERROR, "ERROR in %s failed to read %s: ppdev->DmaPushBufTotalSize: 0x%x",
      szDbg_TRACE_GetCurrentFn(),
      szDbg_GetET_VALUE_IDName(ET_VALUE_DW_GDI_DMAPADDING), 
      ppdev->ulDmaPadding));
  }

  // at least one DWORD at the end
  if (ppdev->ulDmaPadding < sizeof(DWORD))
    ppdev->ulDmaPadding = sizeof(DWORD);

  // Need at least 8kb buffer to run properly
  if (ppdev->DmaPushBufTotalSize-ppdev->ulDmaPadding < (8 KB))
  {
    DBG_ERROR("Fallback to default DmaPushBufTotalSize and ulDmaPadding");
    ppdev->ulDmaPadding    = DMAPUSH_PADDING;
    ppdev->DmaPushBufTotalSize = DMAPUSH_BUFFER_SIZE;
  }


  //
  // Support HW lines
  //
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_GDI_HWLINES, &ulSwitch) )
    ulSwitch = FALSE;
  if (ulSwitch)
    v2DCapsSet(FL_2DCAPS_HWLINES);  
  else
    v2DCapsClear(FL_2DCAPS_HWLINES);


  //
  // Enable device bitmaps
  //
#ifdef _WIN64
  // FNicklis IA-64: ToDo - portation not complete!
  #pragma message ("  FNicklis IA-64: ToDo: disabled FL_2DCAPS_ENABLEDEVICEBITMAPS "__FILE__)
  DISPDBG((DBG_LVL_IA64, "FNicklis IA-64: ToDo: disabled FL_2DCAPS_ENABLEDEVICEBITMAPS %s %d",__FILE__,__LINE__));
  v2DCapsClear(FL_2DCAPS_ENABLEDEVICEBITMAPS);
#else
#ifndef RUN_WITH_NVIDIA_MINIPORT 
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_GDI_ENABLEDEVICEBITMAPS, &ulSwitch) )
    ulSwitch = TRUE;
  if (ulSwitch)
    v2DCapsSet(FL_2DCAPS_ENABLEDEVICEBITMAPS);
  else
#endif //RUN_WITH_NVIDIA_MINIPORT 
  {
    DBG_WARNING("FNicklis IA-64: ToDo: disabled FL_2DCAPS_ENABLEDEVICEBITMAPS");
    v2DCapsClear(FL_2DCAPS_ENABLEDEVICEBITMAPS);
  }
#endif


  //
  // Read GDI DMA-buffer allocation type
  //
#if (_WIN32_WINNT >= 0x0500)
  DISPDBG((DBG_LVL_FLOW0, "AGP needed for W2K initialization of miniport"));
  v2DCapsSet(FL_2DCAPS_AGP_DMA);

#else
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_GDI_AGP_DMA, &ulSwitch) )
  {
    ulSwitch = FALSE;
    DISPDBG((DBG_LVL_ERROR, "ERROR in %s failed to read %s: ulSwitch: %s",
      szDbg_TRACE_GetCurrentFn(),
      szDbg_GetET_VALUE_IDName(ET_VALUE_DW_GDI_AGP_DMA), 
      szBOOL(ulSwitch)));
  }
  if (ulSwitch)
    v2DCapsSet(FL_2DCAPS_AGP_DMA);
  else
    v2DCapsClear(FL_2DCAPS_AGP_DMA);
#endif // ELSA-FNicklis 09.05.00: unused


  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, ET_VALUE_DW_GDI_FRAMEBUFFER_DMA, &ulSwitch) )
  {
    ulSwitch = FALSE;
    DISPDBG((DBG_LVL_ERROR, "ERROR in %s failed to read %s: ulSwitch: %s",
      szDbg_TRACE_GetCurrentFn(),
      szDbg_GetET_VALUE_IDName(ET_VALUE_DW_GDI_FRAMEBUFFER_DMA), 
      szBOOL(ulSwitch)));
  }
  if (ulSwitch)
    v2DCapsSet(FL_2DCAPS_FRAMEBUFFER_DMA);
  else
    v2DCapsClear(FL_2DCAPS_FRAMEBUFFER_DMA);

  vDbg_Printfl2DCapabilities(DBG_LVL_FLOW0, "ppdev->fl2DCapabilities", ppdev);

#if BETA_VERSION
#ifdef RUN_WITH_NVIDIA_MINIPORT 
      DISPDBG((DBG_LVL_WARNING, "ELSA-FNicklis 14.04.00: ppdev->flPunt %s %d",__FILE__,__LINE__));
      ppdev->flPunt = (
                      FL_PUNT_DRVFILLPATH          
                    | FL_PUNT_DRVCOPYBITS          
                    | FL_PUNT_DRVBITBLT                                 
                    | FL_PUNT_DRVLINETO            
                    | FL_PUNT_DRVPAINT             
                    | FL_PUNT_DRVSTRETCHBLT        
                    | FL_PUNT_DRVSTROKEPATH        
                    | FL_PUNT_DRVTEXTOUT           
                    | FL_PUNT_DRVMOVEPOINTER       
                    | FL_PUNT_DRVSETPOINTERSHAPE   
                    | FL_PUNT_DRVCREATEDEVICEBITMAP
                    | FL_PUNT_DRVSETPALETTE                
                    | FL_PUNT_CHANNELSWITCH
                    | FL_PUNT_SYNCH
                    ) 
#if DBG
                    & flDbgPunt
#endif
                    ;
#else
  // FNicklis IA-64: Added dynamic punt possiblity
  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_GDI_PUNTFLAGS, &ppdev->flPunt) )
  {
    #ifdef _WIN64
      // FNicklis IA-64: ToDo - portation not complete!
      #pragma message ("  FNicklis IA-64: ToDo: ppdev->flPunt "__FILE__)
      DISPDBG((DBG_LVL_IA64, "FNicklis IA-64: ToDo: ppdev->flPunt %s %d",__FILE__,__LINE__));
      ppdev->flPunt = FL_PUNT_DRVFILLPATH          
                    | FL_PUNT_DRVCOPYBITS          
                    | FL_PUNT_DRVBITBLT                                 
                    | FL_PUNT_DRVLINETO            
                    | FL_PUNT_DRVPAINT             
                    | FL_PUNT_DRVSTRETCHBLT        
                    | FL_PUNT_DRVSTROKEPATH        
                    | FL_PUNT_DRVTEXTOUT           
                    | FL_PUNT_DRVMOVEPOINTER       
                    | FL_PUNT_DRVSETPOINTERSHAPE   
                    | FL_PUNT_DRVCREATEDEVICEBITMAP
                    | FL_PUNT_DRVSETPALETTE                
                    | FL_PUNT_CHANNELSWITCH
                    | FL_PUNT_SYNCH
                    ;
    #else
      ppdev->flPunt = 0; // don't punt anything
    #endif
  }
#endif
  if (0!=ppdev->flPunt)
  {
    vDbg_PrintFL_PUNT_Flags(DBG_LVL_WARNING, "ppdev->flPunt", ppdev->flPunt);
  }
#endif


  if (REG_ERROR == lRegGetIdDWord( ppdev->hDriver, INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP, &ppdev->ulOverlayBPP) )
  {
    ASSERT(0!=ppdev->cjPelSize);
    ppdev->ulOverlayBPP = ppdev->cjPelSize * 8; // bits per pixel => TC overlay in TC, 16bpp overlay in 16bpp
  }
  else
  {
    DISPDBG((DBG_LVL_WARNING, "Overwrite for INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP:%d", ppdev->ulOverlayBPP));
  }

  bRet = TRUE;
#endif // ELSA-FNicklis 04.07.00: unused
  return(bRet);
}


/*
** bRegQueryAgainstInternalStatus (single board)
**
** Esc interface to retrieve any driver handled registry key
**
** NOTE: Don't disable keys using the flags set by the keys! Else 
**       yout wont be able to enable again!
**
** plRet : ESC_SUCCESS      ( 1) : function finished successfully
**         ESC_NOTSUPPORTED ( 0) : ERROR: iEsc or SubEsc not supported
**         ESC_ERROR        (-1) : ERROR: any other error (wrong feeding)
** return: TRUE                  : Escape handled, plRet and pvOut valid
**         FALSE                 : Escape not handled, do it through registry
**
** FNicklis 05.03.1999: New
** FNicklis 25.10.1999: Added first valid return values
*/
static BOOL bRegQueryAgainstInternalStatus(
      PPDEV           ppdev, 
  IN  DWORD           dwSubEsc, 
  IN  ET_QUERY_VALUE *petQueryValue,
  IN  ULONG           cjOut, 
  OUT VOID           *pvOut,
  OUT LONG           *plRet)
{
  ET_VALUE_DWORD *petValueDWord = (ET_VALUE_DWORD*)pvOut;
  LONG            bRet          = FALSE; // not handled (default)
  DWORD           dwType;                // recalulated and modified type identifier
  BOOL            bDisableKey   = FALSE; // Key disabled 
  BOOL            bValueSet     = FALSE; // We have a value to return, stored to petValueDWord->dwValue

  DBG_TRACE_IN(DBG_LVL_FLOW0_NLF,bRegQueryAgainstInternalStatus);
  ASSERT(NULL!=petQueryValue);
  DBG_PRINTX(DBG_LVL_FLOW0_NP, petQueryValue->dwID);

  ASSERT(NULL!=ppdev);

  if (dwSubEsc==SUBESC_ET_QUERY_VALUE_DWORD)
  {
    // Don't touch output before we have checked it!
    if (   ( NULL==pvOut )
        || ( sizeof(ET_VALUE_DWORD)!= cjOut )
        || ( sizeof(ET_VALUE_DWORD)!= petQueryValue->hdr.dwOutSize )  )
    {
      DBG_ERROR("Outbuffer to small or invalid data:");
      DISPDBG((DBG_LVL_ERROR, "sizeof(ET_VALUE_DWORD)=%d, cjOut=%d, petQueryValue->hdr.dwOutSize:%d", sizeof(ET_VALUE_DWORD), cjOut,petQueryValue->hdr.dwOutSize));
      bRet   = TRUE;      // handled, but cannot work correctly
      *plRet = ESC_ERROR; // return error to escape
      goto Exit;
    }
    // Ok
  }
  else
  {
    //
    // Only handle dwords by now!
    //
    goto Exit;
  }

  // check if we get the default only
  dwType = petQueryValue->dwType;

  // first check the Keys we don't want to support!
  switch (petQueryValue->dwID)
  {
    case ET_VALUE_DW_ICDINTERFACE_DISABLE:
    {
#if 0 // ELSA-FNicklis 04.07.00: unused
      if (!b3DCapsTest(FL_3DCAPS_3D_POSSIBLE))
      {
        bDisableKey=TRUE;
      }
#endif // ELSA-FNicklis 04.07.00: unused
      break;
    }

    // Keys that are not available in single buffered resolutions:
    case ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING:
    case ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT:
    case ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY:
    case ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE:
    case ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS:
    case ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS:
    {
      #if 0 // ELSA-FNicklis 04.07.00: unused
      if (!bOpenGLDoubleBufferPossible(ppdev))
      {
        bDisableKey=TRUE;
      }
      #endif // ELSA-FNicklis 04.07.00: unused
      break;
    }

    // Keys that are not available in non overlay capable resolutions:
    case ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS:
    case ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES  :
    {
      #if 0 // ELSA-FNicklis 04.07.00: unused
      if (!bOpenGLOverlayBufferPossible(ppdev))
      {
        bDisableKey=TRUE;
      }
      #endif // ELSA-FNicklis 04.07.00: unused
      break;
    }

    #if 0 // ELSA-FNicklis 04.07.00: unused
    case INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP         :
    {
      if (!bOpenGLOverlayBufferPossible(ppdev))
      {
        bDisableKey=TRUE;
      }
      else
      {
        petValueDWord->dwValue = ppdev->ulOverlayBPP;
        bValueSet = TRUE;
      }
      break;
    }
    #endif // ELSA-FNicklis 04.07.00: unused

#if 0 // ELSA-FNicklis 04.07.00: unused
    // Keys that are not available in non stereo capable resolutions:
    case ET_VALUE_DW_ICDINTERFACE_PFD_STEREO:
    case ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS:
    case ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT:
    {
      if (!bOpenGLStereoBufferPossible(ppdev))
      {
        bDisableKey=TRUE;
      }
      break;
    }
#endif // ELSA-FNicklis 04.07.00: unused
  }

  if (bValueSet)
  {
    //
    // Did find an internal value, no need to go to registry!
    //
    petValueDWord->dwSize   = sizeof(ET_VALUE_DWORD);
    petValueDWord->dwID     = petQueryValue->dwID;
    petValueDWord->dwFlags  = ET_VALUE_OK;

    *plRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
    bRet = TRUE;
  }
  else if (bDisableKey)
  {
    // did we find a key want to disable

    // NOTE: Don't disable keys using the flags set by the keys! Else 
    //       yout wont be able to enable again!
    petValueDWord->dwSize   = sizeof(ET_VALUE_DWORD);
    petValueDWord->dwID     = petQueryValue->dwID;
    petValueDWord->dwFlags  = ET_VALUE_UNKNOWN;

    vDbg_PrintET_VALUE_RETdwFlags(DBG_LVL_FLOW1, "petValueDWord->dwFlags",petValueDWord->dwFlags);
    *plRet = ESC_SUCCESS; // Handle errors in dwFlags of return structure
    bRet = TRUE;
  }
  else 
  {
    goto Exit;
  }

  // defaults that have to be handled must go through miniport!
  if (bBitsTest(dwType,ET_VALUE_DEFAULT_FLAG))
  {
    vBitsClear(&dwType,ET_VALUE_DEFAULT_FLAG);
    goto Exit;
  }

  if (ET_VALUE_TYPE_DWORD != dwType) // must be DWord now, as Default flag is removed
  {
    DBG_ERROR("internal error: returning wrong type");
    bRet   = TRUE; // handled, but cannot work correctly
    *plRet = ESC_ERROR;
    goto Exit;
  }
  
Exit:
  DBG_TRACE_OUT(DBG_LVL_FLOW0, bRet);

  return bRet;
}

#endif //USE_WKS_ELSA_TOOLS
// End of wkselsatoolsregistry.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsdebug.c ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsdebug.c
//
// Debug code 
//
// FNicklisch 09/14/2000: New, derived from debug.c
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files
#include "precomp.h"
#ifdef USE_WKS_ELSA_TOOLS
#include "ELSAESC.h"
#include "wkselsatoolsescape.h"
#include "wkselsatoolstoolbox.h"
#include "wkselsatoolsregistry.h"

#if DBG
// export header file
#include <wkselsatoolsdebug.h>


// FNicklis 21.10.98: New sub escapes defined
DBG_NAMEINDEX aDbgETSubEscName[]=
{
  // Sub escapes, common for Windows 95 and Windows NT:
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_VERSION_INFO     ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_VALUE_STRING     ), 
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_VALUE_DWORD      ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_VALUE_BINARY     ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_SET_VALUE_STRING       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SET_VALUE_DWORD        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SET_VALUE_BINARY       ),

  // 0x30-0x4F reserved for WINman
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN_DATA_GET        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN_DATA_SET        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN_DDC_EDID_GET    ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN2_DATA_GET       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN2_DATA_SET       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_WINMAN2_DDC_EDID_GET   ),

  // 0x50-0x6F reserved for elsa directdraw caps
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETCAPS            ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETFEATURES        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_SETFEATURES        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETVIDMEMINFO      ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETCOLORADJUSTMENT ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_SETCOLORADJUSTMENT ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_SETGAMMARAMP       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETGAMMARAMP       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_EDD_GETCOLORCAPSLIMITS ),

  // 0x100-0x11F reserved for Video-In / -Out Escapes
  //
  DBG_MAKE_NAMEINDEX(SUBESC_ET_VIDEO_DMACOPYSM        ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_VIDEO_OUTCONTROL       ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_RMAPI_CONFIGSETGET     ),

  // 0x200-0x21F reserved for all tools to decide if they are
  //             allowed to pop up, only to be used in combination
  //             with a resctricted call RES_ESC_ELSA_TOOL
  //
  DBG_MAKE_NAMEINDEX(SUBESC_STEREO_TOOL               ),

  // 0x300-0x3FF reserved for hardware status and control
  //
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_TEMPERATURE      ),
  
  
  // ********************************************************
  // Windows 95 sub escapes:

  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_MONITORKEY_REGPATH    ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_D3DSETTINGS_REGPATH   ),

  // ********************************************************
  // Windows NT sub escapes:

  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_OPENGLICD_REGPATH),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_DUO_ESC_GETPANELINFO   ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_DUO_ESC_SETPANELINFO   ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_POWERLIB_START         ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_POWERLIB_EXIT          ),

  // 0x10-0x2F reserved for driver internal escapes
  DBG_MAKE_NAMEINDEX(SUBESC_ET_GETREGISTER            ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SETREGISTER            ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_MODIFYREGISTER         ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SCROLL                 ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_GFXOPTIONQUERY         ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_NOTIFYDRIVER           ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SAA                    ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_DDSURFOVERRIDE         ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_MULTIBOARDSETUP        ),

  DBG_MAKE_NAMEINDEX(SUBESC_ET_DPMS                   ),

  // 0x30- ... Common driver Escapes
  DBG_MAKE_NAMEINDEX(SUBESC_ET_SETWINDOW_STEREOMODE   ),
  DBG_MAKE_NAMEINDEX(SUBESC_ET_QUERY_ICDCLIENTINFO    ),
};

char *szDbg_GetETSubEscName(LONG SubEscNr)
{
  return (DBG_GETDBG_NAMEINDEX(aDbgETSubEscName, SubEscNr));
}

// 17.09.1998 FNicklis: New
char *pszDbg_GetFLOH(FLOH floh)
{
  static char pszRet[80];

  pszRet[0]='\0'; // delete string 

  if (0!=floh)
  {
    strcpy( pszRet, "(");

    if (floh & FLOH_ONLY_IF_ROOM) 
    {  // Don't kick stuff out of offscreen memory to make room
      strcat( pszRet, "FLOH_ONLY_IF_ROOM");
      floh &= ~FLOH_ONLY_IF_ROOM;
      if (floh)
        strcat( pszRet, "+");
    }

    if (floh & FLOH_MAKE_PERMANENT) 
    { // Allocate a permanent entry
      strcat( pszRet, "FLOH_MAKE_PERMANENT");
      floh &= ~FLOH_MAKE_PERMANENT;
      if (floh)
        strcat( pszRet, "+");
    }

    if (floh & FLOH_RESERVE) // Allocate an off-screen entry,
    {
      strcat( pszRet, "FLOH_RESERVE");
      floh &= ~FLOH_RESERVE;
      if (floh)
        strcat( pszRet, "+");
    }

    if (floh)
    {
      strcat( pszRet, "unknown");
    }

    strcat( pszRet, ")");
  }
  return (pszRet);
}

// FN new, taken from old glint sources

VOID vDbg_PrintPOINTL(FLONG flFlags, PCHAR pcString, const POINTL *pptl)
{
  if (pptl)
  {
    DISPDBG((flFlags, "%s: x:%-5d y:%-5d",pcString, pptl->x, pptl->y));
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));
  }
}

VOID vDbg_PrintRECTL(FLONG flFlags, PCHAR pcString, const RECTL *prcl)
{
  if (prcl)
  {
    DISPDBG((flFlags, "%s: l:%-5d t:%-5d r:%-5d b:%-5d (w:%-5d h:%-5d)", pcString,
      prcl->left, prcl->top, prcl->right, prcl->bottom, prcl->right-prcl->left,prcl->bottom-prcl->top));
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));
  }
}


VOID vDbg_PrintSIZEL(FLONG flFlags, PCHAR pcString, const SIZEL *psiz)
{
  if (psiz)
  {
    DISPDBG((flFlags, "%s: cx:%08x cy:%08x",
      pcString, psiz->cx, psiz->cy));
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));
  }
}

VOID vDbg_PrintCLIPOBJiDComplexity(FLONG flFlags, BYTE iDComplexity)
{
  switch(iDComplexity)
  {
    case DC_TRIVIAL:
      DISPDBG((flFlags, " DC_TRIVIAL"));
      break;
    case DC_RECT:   
      DISPDBG((flFlags, " DC_RECT"));
      break;
    case DC_COMPLEX:
      DISPDBG((flFlags, " DC_COMPLEX"));
      break;
    default: 
      DISPDBG((flFlags, " DC_??:0x%x",iDComplexity));
      break;
  }
}

VOID vDbg_PrintCLIPOBJiFComplexity(FLONG flFlags, BYTE iFComplexity)
{
  switch(iFComplexity)
  {
    case FC_RECT:    
      DISPDBG((flFlags, "FC_RECT"));
      break;
    case FC_RECT4:   
      DISPDBG((flFlags, "FC_RECT4"));
      break;
    case FC_COMPLEX: 
      DISPDBG((flFlags, "FC_COMPLEX"));
      break;
    default: 
      DISPDBG((flFlags, "FC_??:0x%x",iFComplexity));
      break;
  }
}

VOID vDbg_PrintCLIPOBJ(FLONG flFlags, PCHAR pcString, const CLIPOBJ *pco)
{
  if (pco)
  {
    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: 0x%p, iUniq:%08x ", pcString, pco, pco->iUniq));

    vDbg_PrintCLIPOBJiDComplexity(flFlags|DBG_LVL_NOLINEFEED|DBG_LVL_NOPREFIX, pco->iDComplexity);
    DISPDBG((flFlags|DBG_LVL_NOLINEFEED|DBG_LVL_NOPREFIX, " "));
    vDbg_PrintCLIPOBJiFComplexity(flFlags|DBG_LVL_NOPREFIX, pco->iFComplexity);

    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: ", pcString));
    vDbg_PrintRECTL(flFlags|DBG_LVL_NOPREFIX, "rclBounds", &pco->rclBounds);
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));
  }
}

#ifndef PAL_DC
// NT 3.51
#define PAL_DC		      0x00000010
#define PAL_FIXED	      0x00000020
#define PAL_FREE	      0x00000040
#define PAL_MANAGED	    0x00000080
#define PAL_NOSTATIC	  0x00000100
#define PAL_MONOCHROME	0x00000200
#define PAL_DITHER	    0x00000400
#endif

DBG_NAMEINDEX aDbgXLATEOBJiTypeNames[] =
{
  DBG_MAKE_NAMEINDEX(PAL_DC        ),
  DBG_MAKE_NAMEINDEX(PAL_FIXED     ),
  DBG_MAKE_NAMEINDEX(PAL_FREE      ),
  DBG_MAKE_NAMEINDEX(PAL_MANAGED   ),
  DBG_MAKE_NAMEINDEX(PAL_NOSTATIC  ),
  DBG_MAKE_NAMEINDEX(PAL_MONOCHROME),
  DBG_MAKE_NAMEINDEX(PAL_DITHER	   ),
  DBG_MAKE_NAMEINDEX(PAL_INDEXED   ),
  DBG_MAKE_NAMEINDEX(PAL_BITFIELDS ),
  DBG_MAKE_NAMEINDEX(PAL_RGB       ),
  DBG_MAKE_NAMEINDEX(PAL_BGR       ),
};

/*
** Find string matching ulIndex out of DBG_NAMEINDEX array pNameIndex
*/
char *szDbg_GetDBG_NAMEINDEX(IN const DBG_NAMEINDEX *pNameIndex, IN LONG lEntries, IN ULONG ulIndex)
{
  char *szRet=NULL;

  while (lEntries)
  {
    if (pNameIndex->ulIndex == ulIndex)
    { 
      szRet=pNameIndex->szName;
      break;
    }
    pNameIndex++;
    lEntries--;
  }
  
  if (szRet==NULL)
    szRet="unknown\0??????????????????????"; // Added space to allow strange things on the pointer returned!

  return (szRet);
}

char *szDbg_GetXLATEOBJiTypeName(ULONG fl)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgXLATEOBJiTypeNames, sizeof(aDbgXLATEOBJiTypeNames)/sizeof(aDbgXLATEOBJiTypeNames[0]), fl));
}

VOID vDbg_PrintXLATEOBJiType(FLONG flFlags, USHORT iType)
{
  vDbg_PrintflCapabilities(
    flFlags, 
    "", 
    szDbg_GetXLATEOBJiTypeName,
    (ULONG)iType);
}

VOID vDbg_PrintXLATEOBJflXlate(FLONG flFlags, FLONG flXlate)
{
  if (flXlate & XO_TRIVIAL) 
    DISPDBG( (flFlags, " XO_TRIVIAL"));
  if (flXlate & XO_TABLE) 
    DISPDBG( (flFlags, " XO_TABLE  "));
  if (flXlate & XO_TO_MONO) 
    DISPDBG( (flFlags, " XO_TO_MONO")); 
  if (flXlate & 0x00000008) 
    DISPDBG( (flFlags, " XO_FROM_CMYK")); 
  if (flXlate & 0x00000010) 
    DISPDBG( (flFlags, " XO_DEVICE_ICM")); 
  if (flXlate & 0x00000020) 
    DISPDBG( (flFlags, " XO_HOST_ICM")); 

#if (_WIN32_WINNT >= 0x500)
  #if ((XO_FROM_CMYK != 0x00000008) || (XO_DEVICE_ICM != 0x00000010) || (XO_HOST_ICM != 0x00000020))
    #error Check DDK defintions for XLATES flags!
  #endif
#endif

  if (!(flXlate & (XO_TO_MONO | XO_TABLE | XO_TRIVIAL | 0x00000008 | 0x00000010 | 0x00000020))) 
    DISPDBG( (flFlags, " XO_??? (0x%x)", flXlate));
}

VOID vDbg_PrintXLATEOBJ(FLONG flFlags, PCHAR pcString, const XLATEOBJ *pxlo)
{
  if (pxlo)
  {
    DISPDBG((flFlags, "%s: 0x%p", pcString, pxlo));
    DISPDBG((flFlags, "%s: iUniq:0x%x, cEntries:%d, pulXlate:0x%p", pcString, pxlo->iUniq, pxlo->cEntries, pxlo->pulXlate));

    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: flXlate:0x%x ", pcString, pxlo->flXlate));
    vDbg_PrintXLATEOBJflXlate(flFlags|DBG_LVL_NOPREFIX, pxlo->flXlate);
    
    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: iSrcType:0x%x ", pcString, pxlo->iSrcType));
    vDbg_PrintXLATEOBJiType(flFlags|DBG_LVL_NOPREFIX, pxlo->iSrcType);

    DISPDBG((flFlags|DBG_LVL_NOLINEFEED, "%s: iDstType:0x%x ", pcString, pxlo->iDstType));
    vDbg_PrintXLATEOBJiType(flFlags|DBG_LVL_NOPREFIX, pxlo->iDstType);
  }
  else
  {
    DISPDBG((flFlags, "%s: NULL", pcString));   
  }
  DISPDBG((flFlags, "."));   
}

VOID vDbg_PrintSURFOBJiType(FLONG flFlags, USHORT  iType)
{
  switch(iType)
  {
    case STYPE_BITMAP:    DISPDBG( (flFlags," STYPE_BITMAP")); 
                          break;
    case STYPE_DEVBITMAP: DISPDBG( (flFlags, " STYPE_DEVBITMAP")); 
                          break;
    case STYPE_DEVICE:    DISPDBG( (flFlags," STYPE_DEVICE")); 
                          break;
    default:              DISPDBG( (flFlags," STYPE_? 0x%x",iType)); 
                          break;
  }
}

VOID vDbg_PrintSURFOBJiBitmapFormat(FLONG flFlags, ULONG iBitmapFormat)
{
  switch (iBitmapFormat)
  {
    case BMF_8RLE:    DISPDBG((flFlags, " BMF_8RLE" )); break;
    case BMF_4RLE:    DISPDBG((flFlags, " BMF_4RLE" )); break;
    case BMF_32BPP:   DISPDBG((flFlags, " BMF_32BPP")); break;
    case BMF_24BPP:   DISPDBG((flFlags, " BMF_24BPP")); break;
    case BMF_16BPP:   DISPDBG((flFlags, " BMF_16BPP")); break;
    case BMF_8BPP:    DISPDBG((flFlags, " BMF_8BPP" )); break;
    case BMF_4BPP:    DISPDBG((flFlags, " BMF_4BPP" )); break;
    case BMF_1BPP:    DISPDBG((flFlags, " BMF_1BPP" )); break;
    default:          DISPDBG((flFlags, " BMF_?:0x%x",iBitmapFormat));break;
  }
}

VOID vDbg_PrintSURFOBJ(FLONG flFlags, PCHAR pcString, const SURFOBJ *pso)
{
  //char pjPlatz[100];

  if (pso)
  {
    DISPDBG((flFlags|DBG_LVL_NOLINEFEED,"%s: 0x%p ", pcString, pso));   
    vDbg_PrintSURFOBJiType(flFlags|DBG_LVL_NOPREFIX|DBG_LVL_NOLINEFEED, pso->iType);
    DISPDBG((flFlags|DBG_LVL_NOPREFIX|DBG_LVL_NOLINEFEED," "));
    vDbg_PrintSURFOBJiBitmapFormat(flFlags|DBG_LVL_NOPREFIX, pso->iBitmapFormat);

    DISPDBG((flFlags,"%s: dhsurf:0x%p, hsurf:0x%p, phpdev:0x%p, hdev:0x%p", pcString,
             pso->dhsurf, pso->hsurf, pso->dhpdev, pso->hdev)); 

    DISPDBG((flFlags,"%s: sizlBitmap: cx:%d, cy:%d, cjBits:0x%x, pvBits:0x%p", pcString,
          pso->sizlBitmap.cx,pso->sizlBitmap.cy, pso->cjBits,pso->pvBits));

    DISPDBG((flFlags,"%s: pvScan0:0x%p, lDelta:0x%x, iUniq:0x%x, fjBmp:%08x", pcString,
          pso->pvScan0,pso->lDelta, pso->iUniq, pso->fjBitmap));    
  }
  else
  {
    DISPDBG((flFlags,"%s: NULL", pcString));   
  }
}

/*
** DBG_TRACE_DUMP
** 
** prints the trace dump of all known functions on the stack
** 
** FNicklis 02.10.1998: New
*/

VOID vDbg_PrintTRACE_DUMP(FLONG flDbgLvl)
{
#if 0 // FNicklisch 14.09.00: unused
  DISPDBG((flDbgLvl,"DBG_TRACE_DUMP printing call stack"));
  if (lDbgUnhandledFnStack>0)
  {
    DISPDBG((flDbgLvl,"  %3d-%d (%d) calls not catched",lDbgUnhandledFnStack+lDbgFnStack,lDbgFnStack,lDbgUnhandledFnStack));
  }
  else
  {
    LONG l;
    for (l=lDbgFnStack-1; l>=0; l--)
      DISPDBG((flDbgLvl,"  %3d: %s at 0x%p",l,aDbgFnStack[l].szName,aDbgFnStack[l].pfn));
  }
#endif // FNicklisch 14.09.00: unused
}

char *szDbg_TRACE_GetCurrentFn(VOID)
{
#if 0 // FNicklisch 14.09.00: unused
  static LONG lCount=0;
  if ( (lDbgFnStack<1) || (lDbgUnhandledFnStack>0) )
    return ("unknown");

  if (   (lCount<20)
      && (NULL==aDbgFnStack[lDbgFnStack-1].szName) )
  {
    DISPDBG((DBG_LVL_ERROR, "ERROR in szDbg_TRACE_GetCurrentFn: corrupt function stack..."));
    vDbg_PrintTRACE_DUMP(DBG_LVL_ERROR);
    lCount++;
  }

  return (aDbgFnStack[lDbgFnStack-1].szName);
#else
  return ("unknown");
#endif // FNicklisch 14.09.00: unused
}


/*
** define an array with all RegEscapeIDs
*/
DBG_NAMEINDEX aDbgExceptionCode[] =
{
  DBG_MAKE_NAMEINDEX(STATUS_WAIT_0                  ),
  DBG_MAKE_NAMEINDEX(STATUS_ABANDONED_WAIT_0        ),
  DBG_MAKE_NAMEINDEX(STATUS_USER_APC                ),
  DBG_MAKE_NAMEINDEX(STATUS_TIMEOUT                 ),
  DBG_MAKE_NAMEINDEX(STATUS_PENDING                 ),
  DBG_MAKE_NAMEINDEX(STATUS_SEGMENT_NOTIFICATION    ),
  DBG_MAKE_NAMEINDEX(STATUS_GUARD_PAGE_VIOLATION    ),
  DBG_MAKE_NAMEINDEX(STATUS_DATATYPE_MISALIGNMENT   ),
  DBG_MAKE_NAMEINDEX(STATUS_BREAKPOINT              ),
  DBG_MAKE_NAMEINDEX(STATUS_SINGLE_STEP             ),
  DBG_MAKE_NAMEINDEX(STATUS_ACCESS_VIOLATION        ),
  DBG_MAKE_NAMEINDEX(STATUS_IN_PAGE_ERROR           ),
  DBG_MAKE_NAMEINDEX(STATUS_INVALID_HANDLE          ),
  DBG_MAKE_NAMEINDEX(STATUS_NO_MEMORY               ),
  DBG_MAKE_NAMEINDEX(STATUS_ILLEGAL_INSTRUCTION     ),
  DBG_MAKE_NAMEINDEX(STATUS_NONCONTINUABLE_EXCEPTION),
  DBG_MAKE_NAMEINDEX(STATUS_INVALID_DISPOSITION     ),
  DBG_MAKE_NAMEINDEX(STATUS_ARRAY_BOUNDS_EXCEEDED   ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_DENORMAL_OPERAND  ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_DIVIDE_BY_ZERO    ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_INEXACT_RESULT    ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_INVALID_OPERATION ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_OVERFLOW          ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_STACK_CHECK       ),
  DBG_MAKE_NAMEINDEX(STATUS_FLOAT_UNDERFLOW         ),
  DBG_MAKE_NAMEINDEX(STATUS_INTEGER_DIVIDE_BY_ZERO  ),
  DBG_MAKE_NAMEINDEX(STATUS_INTEGER_OVERFLOW        ),
  DBG_MAKE_NAMEINDEX(STATUS_PRIVILEGED_INSTRUCTION  ),
  DBG_MAKE_NAMEINDEX(STATUS_STACK_OVERFLOW          ),
  DBG_MAKE_NAMEINDEX(STATUS_CONTROL_C_EXIT          ),
};

char *szDbg_GetExceptionCode(DWORD dwID)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgExceptionCode, sizeof(aDbgExceptionCode)/sizeof(aDbgExceptionCode[0]), (LONG)dwID));
}

DBG_NAMEINDEX aDbgET_SET_VALUE_RETdwFlags[] =
{
  DBG_MAKE_NAMEINDEX(ET_VALUE_OK     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_REBOOT ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DEFAULT),
  DBG_MAKE_NAMEINDEX(ET_VALUE_BLOCKED),
  DBG_MAKE_NAMEINDEX(ET_VALUE_ERROR	),
  DBG_MAKE_NAMEINDEX(ET_VALUE_UNKNOWN),
};

// get single string out of aDbgET_SET_VALUE_RETdwFlags matching dwFlags
char *szDbg_GetET_SET_VALUE_RETdwFlags(DWORD dwFlags)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgET_SET_VALUE_RETdwFlags, sizeof(aDbgET_SET_VALUE_RETdwFlags)/sizeof(aDbgET_SET_VALUE_RETdwFlags[0]), dwFlags));
}

// get complete description to dwFlags 
VOID vDbg_PrintET_VALUE_RETdwFlags(
  FLONG flDbgLvl, 
  PCHAR pcString, 
  DWORD dwFlags)
{
  vDbg_PrintflCapabilities(
    flDbgLvl, 
    pcString, 
    szDbg_GetET_SET_VALUE_RETdwFlags,
    dwFlags);
}

DBG_NAMEINDEX aDbgESC_RETURN[] =
{
  DBG_MAKE_NAMEINDEX(ESC_SUCCESS     ),
  DBG_MAKE_NAMEINDEX(ESC_NOTSUPPORTED),
  DBG_MAKE_NAMEINDEX(ESC_ERROR       ),
};

// get single string out of aDbgESC_RETURN matching dwFlags
char *szDbg_GetESC_RETURN(LONG lRet)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgESC_RETURN, sizeof(aDbgESC_RETURN)/sizeof(aDbgESC_RETURN[0]), (ULONG)lRet));
}

DBG_NAMEINDEX aDbgREG_RETURN[] =
{
  DBG_MAKE_NAMEINDEX(REG_ERROR  ),
  DBG_MAKE_NAMEINDEX(REG_OK     ),
  DBG_MAKE_NAMEINDEX(REG_DEFAULT),
};

// get single string out of aDbgREG_RETURN matching dwFlags
char *szDbg_GetREG_RETURN(LONG lRet)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgREG_RETURN, sizeof(aDbgREG_RETURN)/sizeof(aDbgREG_RETURN[0]), (ULONG)lRet));
}


/*
** define an array with all RegEscapeIDs
*/
DBG_NAMEINDEX aDbgET_VALUE_IDs[] =
{
  // Windows 9x
  //
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_MCLK                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_NVCLK                            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_OVERCLOCK_ENABLE                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_OVERCLOCK_CRASHSTATUS            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_DEFAULT_MCLK                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_D3DOGL_DEFAULT_NVCLK                    ),

  // Windows NT
  //
  // Basic/system 0x20000000-0x200000ff
  //#define ET_VALUE_SZ_IMAGEPATH                               0x20000000
  //#define ET_VALUE_SZ_INSTALLEDDISPLAYDRIVERS                 0x20000001

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DESKTOPONMAXIMIZE                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_ENABLEDEVICEBITMAPS                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_ENABLEPCIDISCONNECT                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_EXPORTONLYDOUBLEBUFFERMODES         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_NTEAMPRIVATEKEY                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_P6ENABLEUSWC                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_REVERSESCREENORDER                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_USEGETACCESSRANGES                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_USELCDPANEL                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VERTICALSCREENORDER                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_WAITFORFIFOS                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DEVICEORIGINX                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DEVICEORIGINY                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DEVICESIZEX                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DEVICESIZEY                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VISUALORIGINX                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VISUALORIGINY                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VISUALSIZEX                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_VISUALSIZEY                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DELLXXL                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_PERMEDIACLOCKSPEED                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_GLINTCLOCKSPEED                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_GLINTGAMMACLOCKSPEED                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_GLINTDELTACLOCKSPEED                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_HWLINES                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_FIFOEXTRA_P2            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_FIFOEXTRA               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_FIFOUSAGE               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_EXPORTMULTIBOARDMODES   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_SURFACESONBANKBOUNDARIES            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DMABUFFERSIZE                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_DMAPADDING                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_BOARD_PATTERN                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_AGP_DMA                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GDI_FRAMEBUFFER_DMA                     ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_MAP_FRAMEBUFFER                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_MAP_GLINTMMIO                           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_MAP_DELTAMMIO                           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_MAP_LOCALBUFFER                         ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_PPRO_ENABLEWCB                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ALPHA_MIATA                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_PRINTANDCHECKRENDERSTATE                ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_BIN_GDI_GAMMARAMP                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_BIN_OEM_MODELIST                           ),

  // ICDInterface.* 0x20000100-0x200001ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_DISABLE                    ),
  //DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_DOUBLEBUFFER               ),
  //DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_MAXDOUBLEBUFFER            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_NUMBEROFDISPLAYBUFFERS     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_MAXNUMBEROFDISPLAYBUFFERS  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_SUPPORTSINGLEBUFFEREDGDI   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_SUPPORTDOUBLEBUFFEREDGDI   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_EXPORTALPHA                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_SUPPORTOVERLAYPLANES       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_VBLANKWAIT                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PAGEFLIPPING               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_LBWIDTH                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_SIZEOFBUFFER               ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_DUALTXLBMOVES              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_EXTENDEDPAGEFLIP           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FNSENDDATATST              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FULLSCNTOPBORDER           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_LBSIZE                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSDMA          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_P2ENABLEBYPASSPATCH        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PAGEFLIPFORCESYNC          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_TEXTURESIZE                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_USESOFTWAREWRITEMASK       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_USESINGLETX                ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_EXPORTCOLORINDEX           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_OPENGLICDNAME              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_OPENGLICDELSAOGLNAME       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFDREDUCTION               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_STEREOFORCEBUFFERS         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_STEREOLEFTEYETOP           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_STEREOSUPPORT              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_TEXTURESMARTCACHE          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_TEXTURETRANSIENTONLY       ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_MAXTEXTURESIZE             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_TYPE_COLORINDEX        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_LBPATCHED                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_DUALGLINTWINDOWMOVES       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FORCEGDIBROADCASTINGINOGLVIEWS),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_STEREO                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_LAYER_BUFFERS     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_SUPPORT_GDI            ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FORCE_STENCIL              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_FORCE_MORETHAN16BITZ       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_TEXTURE_REDUCE_FACTOR      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_COPY              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_ICDINTERFACE_PFD_SWAP_EXCHANGE          ),

  // GLintDMA.* 0x20000200-0x2000024f
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_NUMBEROFBUFFERS                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_NUMBEROFSUBBUFFERS             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_SIZEOFBUFFERS                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_CACHEDBUFFERS                  ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_ENABLE                              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTDMA_SUPPORTAGPONBX                 ),
  
  //above...DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_ENABLE                              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_RATE                                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_SIDEBANDADDRESSING                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_REQUEST_DEPTH                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_FAST_WRITES                         ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_DMAWAITFORPOLL                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_CACHING                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_AGP_MSWORKAROUND                        ),
  

  // GLintIRQ.* 0x20000250-0x200002ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_GLINTIRQ_ENABLE                         ),

  // OpenGL.* 0x20000300-0x200003ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_USEHIQUALITYTEXTURE              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_UNIXCONFORM                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DOUBLEWRITE                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEFASTCLEAR                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEMIPMAPS                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_TEXTURECOMPRESSION               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ENABLEP2ANTIALIAS                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORTOPENGLVERSION11           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCETRUECOLOR16BIT              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORTSOFTIMAGE_351             ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DRAWLINEENDS                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ENABLEFIFOACCESS                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEDELTA                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MXDISABLEMIPMAPS                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCENNTEXFILTER                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEDMAFLUSHES                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEGXCULL                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_INVERTGXCFORMAT                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PERSPECTIVECORRECTION            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_REALLOCBLOCKSIZE                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLEDLISTTEXTURES             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DELTANODRAW                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ENABLEBYPASSPATCH                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ENABLEBYPASSDMA                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCENESTEDDMA                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLETRIANGLEPACKET            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PRESERVETRUECOLORTEXTURES        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DUALTXPRO                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_VERTEXCOOPTMAX                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_NVVVOPTIMIZATION                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MIPMAPCONTROL                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLETEXTUREPATCHING           ),
  
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_USEGIDCLIPPING                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PLACEMIPMAPSINALTERNATEBANKS     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLETEXTUREMANAGERLRU         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORTPRODESIGNER               ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DMAMAXCOUNT                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MAXTEXTURESIZE                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MINVIDMEMTEXWIDTH                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MAXTEXHEAPSIZE                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_LIGHTINGANALYSIS                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_LIGHTPICKINGOVERRIDE             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_STATISTICS                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_BENCHING                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_USEKATMAI                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_VERTEXCACHESIZE                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PIXELTUBE                        ),

  // OpenGL AGP settings
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_AGP_DMA                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_AGP_TEXTURES                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCE_AGP_TEXTURES               ),

  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCE_CLIPPING                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ERRORLOG                         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DUMPLOG                          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MCAD_MODE                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_SUPPORT_P2_CI4TEXTURES           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FORCE_SINGLEBUFFERED             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_ALIGNED_SURFACES                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_FRAMEBUFFER_DMA                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_AUTODESKEXTENSIONS               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_USESENDDATAESCAPE                ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLE_STENCIL                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DISABLE_ALPHA                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_PREFER_AGP_TEXTURES              ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_DMAMINPUSHCOUNT_SENDDATA         ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_OPENGL_MULTIBOARD                       ),

  
    
  // Heidi/Kinetix.* 0x20000400-0x200004ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_HEIDI_USEEXCLUSIVE                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_HEIDI_USELINEARTEXTUREFILTER            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_BUFFERREGIONS                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_SWAPHINTS                           ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_ELSABUFFERREGIONS                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_BUFFER_REGIONS_FULL                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_KTX_BUFFER_REGIONS_FIX                  ),

  // HardwareInformation.* 0x20000500-0x200005ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_HARDWAREINFORMATION_ADAPTERSTRING       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_HARDWAREINFORMATION_CHIPTYPE            ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_HARDWAREINFORMATION_DACTYPE             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_HARDWAREINFORMATION_MEMORYSIZE          ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_BOARDNAME                               ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_DESCRIPTION                             ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_SERNUM                                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_SZ_HARDWAREINFORMATION_BIOSSTRING          ),

  // DDraw ids    0x20000600-0x200006ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_DDRAWMULTIBOARDPRIMARY                  ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_DDRAWENABLEVIDEOIO                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_DDRAWMULTIBOARDHW_ENABLE                ),

  // LCD Panel    0x20000700-0x200007ff
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELBORDERLEFTRIGHT                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELBORDERTOPBOTTOM                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELSTEPLEFTRIGHT                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELSTEPTOPBOTTOM                   ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELPANSTARTXRES                    ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELSTRETCHXRES                     ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELSINGLEMODE                      ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELENABLECRT                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELENABLELCD                       ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELENABLETV                        ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELTRUECOLORDITHER                 ),
  DBG_MAKE_NAMEINDEX(ET_VALUE_DW_LCDPANELTVFLICKERFILTER                 ),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED0),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED1),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED2),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED3),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED4),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED5),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED6),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED7),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED8),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_RESERVED9),
  
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED0),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED1),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED2),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED3),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED4),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED5),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED6),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED7),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED8),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ICDRESERVED9),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ERAZOR_II ),

  
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_CORE_CLOCK        ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MEMORY_CLOCK      ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MEMORY_TIMING     ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_STANDARDTIMINGS),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_SCRAMBLEMODE   ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_SCRAMBLESETTINGS),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_DBG_OPENGLBUFFERNO    ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_DBG_CHECKHEAPINTEGRITY),
                                                                
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HELPERFLAGS           ),

// Keys used by the multiboard wrapper to store WINman2 modes (Binary)
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET0),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET1),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET2),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET3),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET4),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET5),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET6),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET7),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET8),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET9),

// Keys used by the single board driver to store WINman2 modes (Binary)
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET0),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET1),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET2),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET3),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET4),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET5),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET6),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET7),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET8),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET9),

// tetris tiling configuration
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_TETRIS_TILING),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_TETRIS_MODE  ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_TETRIS_SHIFT ),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_DBG_SURFACENEVERATBOTTOM       ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_FORCESOFTWARE           ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_DBGFLAGSOVERRIDE        ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_DBGMAXLOCALERRORCOUNT   ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_DBGTRACETOFILE          ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_USE_DISPLAYDRIVER_BUFFER),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_FORCE_TIMING                ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_ACQUIREMUTEXFORKICKOFF  ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS         ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_CLIENTRELATIVECLIPRECTS ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_USE_ELSA_INITCODE           ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_SHUTDOWN                    ),

  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_NO_ICD_CALLBACK         ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP              ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_SZ_OEM_VERSION                    ),
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_GDI_PUNTFLAGS                  ),
                                                                         
  DBG_MAKE_NAMEINDEX(INTERNAL_ET_VALUE_DW_HW_ONDMACRASH                  ),
};


char *szDbg_GetET_VALUE_IDName(DWORD dwID)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgET_VALUE_IDs, sizeof(aDbgET_VALUE_IDs)/sizeof(aDbgET_VALUE_IDs[0]), (LONG)dwID));
}


#define FL_CAPS_TOGGLE_STEP 3 // needed by vDbg_Printfl2DCapabilities and vDbg_Printfl3DCapabilities
                              // print as much cap strings in one line

/*
** vDbg_PrintflCapabilities
**
** prints line with all set capabilities
**
*/
VOID vDbg_PrintflCapabilities(
  FLONG flDbgFlags, 
  const PCHAR pcString, 
  char *(szFlCaps)(ULONG),  // function pointer to stringizer function (szDbg_GetFL_2DCAPSName)
  FLONG flPrint)
{
  if (0==flPrint)
    DISPDBG((flDbgFlags, "%s: 0 (nothing set)", pcString));
  else
  {
    ULONG ul;
    LONG lToggle = 0;

    DISPDBG((flDbgFlags, "%s: 0x%x", pcString,flPrint));
    for (ul=0; ul<32; ul++)
    {
      if ( bBitsTest(flPrint,1<<ul) )
      {
        if (0==(lToggle % FL_CAPS_TOGGLE_STEP)) // only two in one line
        {
          if (lToggle)
            DISPDBG((flDbgFlags|DBG_LVL_NOPREFIX, " ")); // linefeed
          DISPDBG((flDbgFlags|DBG_LVL_NOLINEFEED, "%s: %s ", pcString, szFlCaps(1<<ul)));
        }
        else
        {
          DISPDBG((flDbgFlags|DBG_LVL_NOPREFIX|DBG_LVL_NOLINEFEED, "%s", szFlCaps(1<<ul)));
        }
        lToggle++;
      }
    }

    DISPDBG((flDbgFlags|DBG_LVL_NOPREFIX, " ")); // linefeed
  }
}


VOID vDbg_PrintET_VERSION(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const ET_VERSION *pVersion)
{
  if (NULL==pVersion)
    DISPDBG((flDbgFlags, "%s: NULL (ET_VERSION *)", pcString));
  else
  {
    DISPDBG((flDbgFlags, "%s: 0x%p (ET_VERSION *)", pcString, pVersion));
    DISPDBG((flDbgFlags, "%s dwFlags         : 0x%x", pcString, pVersion->dwFlags ));
    DISPDBG((flDbgFlags, "%s dwAlign1        : 0x%x", pcString, pVersion->dwAlign1));
    DISPDBG((flDbgFlags, "%s dwNTMajor       : %d",   pcString, pVersion->dwNTMajor       ));
    DISPDBG((flDbgFlags, "%s dwNTMinor       : %d",   pcString, pVersion->dwNTMinor       ));
    DISPDBG((flDbgFlags, "%s dwNTBuildMajor  : %d",   pcString, pVersion->dwNTBuildMajor  ));
    DISPDBG((flDbgFlags, "%s dwNTBuildMinor  : %d",   pcString, pVersion->dwNTBuildMinor  ));
    DISPDBG((flDbgFlags, "%s dwNTReserved0   : 0x%x", pcString, pVersion->dwNTReserved0   ));
    DISPDBG((flDbgFlags, "%s dwNTReserved1   : 0x%x", pcString, pVersion->dwNTReserved1   ));
    DISPDBG((flDbgFlags, "%s dwNTCapabilities: 0x%x", pcString, pVersion->dwNTCapabilities));
    DISPDBG((flDbgFlags, "%s dwNTVersionStamp: 0x%x", pcString, pVersion->dwNTVersionStamp));
    DISPDBG((flDbgFlags, "%s szVersion       : %s", pcString, pVersion->szVersion));
  }
}


VOID vDbg_PrintET_VERSION_INFO(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const ET_VERSION_INFO *pVersionInfo)
{
  if (NULL==pVersionInfo)
    DISPDBG((flDbgFlags, "%s: NULL (ET_VERSION_INFO *)", pcString));
  else
  {
    char szTemp[100] = {0};
    char *szPtr;
    if (strlen(pcString)<100)
      strcpy(szTemp,pcString);
    szPtr = szTemp+strlen(szTemp);
    DISPDBG((flDbgFlags, "%s: 0x%p (ET_VERSION_INFO *)", pcString, pVersionInfo));
    DISPDBG((flDbgFlags, "%s dwSize: 0x%x", pcString, pVersionInfo->dwSize));
    if (strlen(pcString)+strlen("Version") < 100)
      strcpy(szPtr,"Version");
    else
      strcpy(szTemp,"Version");
    vDbg_PrintET_VERSION(flDbgFlags, szTemp, &pVersionInfo->Version);
    DISPDBG((flDbgFlags, "%s szRegDriverKey:%s", pcString, pVersionInfo->szRegDriverKey));
  }
}

DBG_NAMEINDEX aDbgDrvINDEX[] =
{
  DBG_MAKE_NAMEINDEX(INDEX_DrvEnablePDEV           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvCompletePDEV         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDisablePDEV          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvEnableSurface        ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDisableSurface       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvAssertMode           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvResetPDEV            ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvCreateDeviceBitmap   ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDeleteDeviceBitmap   ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvRealizeBrush         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDitherColor          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStrokePath           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvFillPath             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStrokeAndFillPath    ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvPaint                ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvBitBlt               ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvCopyBits             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStretchBlt           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSetPalette           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvTextOut              ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvEscape               ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDrawEscape           ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFont            ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFontTree        ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFontData        ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSetPointerShape      ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvMovePointer          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvLineTo               ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSendPage             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStartPage            ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvEndDoc               ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStartDoc             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvGetGlyphMode         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSynchronize          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSaveScreenBits       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvGetModes             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvFree                 ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDestroyFont          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFontCaps        ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvLoadFontFile         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvUnloadFontFile       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvFontManagement       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryTrueTypeTable   ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryTrueTypeOutline ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvGetTrueTypeFile      ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryFontFile        ),
  #if (_WIN32_WINNT <= 0x400) // not supported under NT5
  DBG_MAKE_NAMEINDEX(INDEX_UNUSED5                 ),
  #endif
  DBG_MAKE_NAMEINDEX(INDEX_DrvQueryAdvanceWidths   ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSetPixelFormat       ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDescribePixelFormat  ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvSwapBuffers          ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvStartBanding         ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvNextBand             ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvGetDirectDrawInfo    ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvEnableDirectDraw     ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvDisableDirectDraw    ),
  DBG_MAKE_NAMEINDEX(INDEX_DrvQuerySpoolType       ),
};

char *szDbg_GetDrvINDEX(ULONG ulIndex)
{
  return (szDbg_GetDBG_NAMEINDEX(aDbgDrvINDEX, sizeof(aDbgDrvINDEX)/sizeof(aDbgDrvINDEX[0]), ulIndex));
}

/*
** vDbg_PrintET_VALUE_DWORD
** vDbg_PrintET_VALUE_STRING
**
** Print ELSAESC structures.
**
** FNicklis 11.05.1999: New
*/
VOID vDbg_PrintET_VALUE_DWORD(
  FLONG           flDebugFlags, 
  PCHAR           pcString,   
  ET_VALUE_DWORD *petDWord)
{
  ASSERT(NULL!=pcString);
  if (NULL==petDWord)
  {
    DISPDBG((flDebugFlags, "%s = NULL", pcString));
  }
  else
  {
    DISPDBG((flDebugFlags, "%s.dwSize:0x%08x, .dwID:0x%08x, .dwValue:0x%08x (%d), .dwFlags:0x%08x (%s)", pcString, 
      petDWord->dwSize, petDWord->dwID, petDWord->dwValue, petDWord->dwValue, petDWord->dwFlags, szDbg_GetET_SET_VALUE_RETdwFlags(petDWord->dwFlags)));
  }
}
  
VOID vDbg_PrintET_VALUE_STRING(
  FLONG            flDebugFlags, 
  PCHAR            pcString,   
  ET_VALUE_STRING *petString)
{
  ASSERT(NULL!=pcString);
  if (NULL==petString)
  {
    DISPDBG((flDebugFlags, "%s = NULL", pcString));
  }
  else
  {
    DISPDBG((flDebugFlags, "%s.dwSize:0x%08x, .dwID:0x%08x, .szValue:%s, .dwFlags:0x%08x (%s)", pcString, 
      petString->dwSize, petString->dwID, petString->szValue, petString->dwFlags, szDbg_GetET_SET_VALUE_RETdwFlags(petString->dwFlags)));
  }
}

#endif //DBG
#endif //USE_WKS_ELSA_TOOLS
// End of wkselsatoolsdebug.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wksappsupport.h ===
#ifndef _WKSAPPSUPPORT_H
#define _WKSAPPSUPPORT_H
/**************************************************************************
** wksappsupport.h
**
** This module handles the ESC_NV_WKS_APP_SUPPORT escape to 
** support the workstation tools interface.
**
** Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
**
** THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
** NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
** IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
**
** FNicklisch 09.11.2000: New
**************************************************************************/

LONG lWksAppSupport(SURFOBJ *pso, 
                    ULONG cjIn, VOID *pvIn,
                    ULONG cjOut, VOID *pvOut);

#define WKS_ESC_SUCCEED      1
#define WKS_ESC_UNSUPPORTED  0
#define WKS_ESC_FAILED      -1

#endif // _WKSAPPSUPPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsescape.h ===
#ifndef _WKSELSATOOLSESCAPE_H
#define _WKSELSATOOLSESCAPE_H
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsescape.h
//
// FNicklisch 09/14/2000: New, derived from EscapeTools.h
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

#ifdef USE_WKS_ELSA_TOOLS

#define ESC_SUCCESS         1     // function succeded without error
#define ESC_NOTSUPPORTED    0     // function not supported
#define ESC_ERROR         (-1)    // function supported but error while working

LONG lEscapeTools( 
  SURFOBJ *pso,
  ULONG    cjIn,
  VOID    *pvIn,
  ULONG    cjOut,
  VOID    *pvOut);

#endif //USE_WKS_ELSA_TOOLS
#endif // _WKSELSATOOLSESCAPE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsescape.c ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsescape.c
//
// Handles ESC_ELSA_TOOLS calls to driver
//
// FNicklisch 09/14/2000: New, derived from EscapeTools.c
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files
#include "precomp.h"
#include "nvVer.h"
#include "excpt.h"
#ifdef USE_WKS_ELSA_TOOLS
#include "ELSAESC.h"
#include "wkselsatoolsdebug.h"
#include "wkselsatoolsregistry.h"
#include "wkselsatoolstoolbox.h"

// export header file
#include "wkselsatoolsescape.h"


#define szStrCpy strcpy
#define szStrCat strcat

static LONG lQueryEtVersionInfo(
  IN  PPDEV            ppdev, 
  OUT ET_VERSION_INFO *pVersionInfo);

static LONG lQueryOpenGlIcdRegPath(
      PPDEV                 ppdev,
  OUT ET_OPENGLICD_REGPATH *pIcdRegPath);

static LONG lEscET_EDD_GETGAMMARAMP(IN const  PPDEV                 ppdev, 
                                    IN const  ET_QUERY*             pET_Query, 
                                    OUT       PET_EDD_GETGAMMARAMP  pETGetGammaRamp);

static LONG lEscET_EDD_SETGAMMARAMP(IN        PPDEV ppdev, 
                                    IN const  PET_EDD_SETGAMMARAMP  pETSetGammaRamp, 
                                    OUT       PET_SET_VALUE_RET     pETSetValueRet);

static LONG lEscET_SET_VALUE_BINARY(IN        PPDEV ppdev, 
                                    IN const  PET_SET_VALUE_BINARY  pETSetValueBinary, 
                                    OUT       PET_SET_VALUE_RET     pETSetValueRet);

static LONG lEscET_DPMS(
  IN     PPDEV             ppdev, 
  IN     ET_DPMS_IN  *pIn, 
     OUT ET_DPMS_OUT *pOut);

static LONG lEscET_QUERY_TEMPERATURE(
  IN    PPDEV                 ppdev, 
  IN    ET_QUERY             *petQuery, 
    OUT ET_QUERY_TEMPERATURE *petTemperature);

/*
** lEscapeTools
**
** handles all escape function calls regarding the ELSA escape interface.
**
** return: ESC_SUCCESS:      ok, returned data valid
**         ESC_NOTSUPPORTED: failed, esc not supported, input data ignored, output data invalid
**         ESC_ERROR:        failed, returned data invalid
*/
LONG lEscapeTools( 
  SURFOBJ *pso  ,
  ULONG    cjIn ,
  VOID    *pvIn ,
  ULONG    cjOut,
  VOID    *pvOut)
{
  LONG  lRet = ESC_NOTSUPPORTED; // Default error 

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lEscapeTools);
  
  ASSERTDD(NULL!=pso, "lEscapeTools:");

#ifndef RUN_WITH_NVIDIA_MINIPORT 
  // We need a minimum of ET_QUERY to understand the subescape!
  if ( (NULL == pvIn) || 
       (cjIn < sizeof(ET_QUERY)) )
  {
    DBG_ERROR("cjIn<sizeof(ET_QUERY)");
    lRet = ESC_ERROR;
    goto Exit;
  } 
  else 
  {
    ET_QUERY *pEtQuery;
    PPDEV     ppdev;
    DWORD     dwSubEsc;

    ppdev = (struct _PDEV *)pso->dhpdev;

    ASSERT(NULL!=ppdev);

    pEtQuery = (ET_QUERY *)pvIn;
    dwSubEsc = pEtQuery->dwSubEsc;

    DISPDBG((DBG_LVL_SUBENTRY, "dwSubEsc:0x%x (%s), ulBoard:%d", 
      dwSubEsc, szDbg_GetETSubEscName(dwSubEsc), pEtQuery->dwBoard));

    if ( (NULL!=pvOut) && (cjOut>0) )
    {
      if (cjOut!=pEtQuery->dwOutSize)
      {
        DISPDBG((DBG_LVL_ERROR, "ERROR in %s: %d==cjOut != pEtQuery->dwOutSize==%d",
          szDbg_TRACE_GetCurrentFn(),cjOut,pEtQuery->dwOutSize));
        DISPDBG((DBG_LVL_ERROR, "ERROR in %s: dwSubEsc:0x%x (%s), ulBoard:%d", 
          szDbg_TRACE_GetCurrentFn(),dwSubEsc, szDbg_GetETSubEscName(dwSubEsc), pEtQuery->dwBoard));
        lRet = ESC_ERROR;
        goto Exit;
      }

      // clear output buffer before anyone touches it!
      RtlZeroMemory(pvOut, cjOut);
    }

    switch (dwSubEsc)
    {  
      // VERSION_INFO
      // return version nummbers, registry path and 
      case SUBESC_ET_QUERY_VERSION_INFO:
      {
        if ( (NULL==pvOut) || 
             (sizeof(ET_VERSION_INFO) != cjOut) )
        {
          DISPDBG((DBG_LVL_ERROR, "ERROR in DrvEscape: SUBESC_ET_QUERY_VERSION_INFO cjOut:%d != pEtQuery->dwOutSize:%d != sizeof(ET_VERSION_INFO):%d",cjOut, pEtQuery->dwOutSize, sizeof(ET_VERSION_INFO)));
          break;
        }

        lRet = lQueryEtVersionInfo(ppdev, (ET_VERSION_INFO *)pvOut);
        break; 
      }

      case SUBESC_ET_WINMAN2_DATA_SET:
      case SUBESC_ET_WINMAN2_DATA_GET:
      case SUBESC_ET_WINMAN2_DDC_EDID_GET:
      {
        //lRet = lEscWINman2(ppdev, dwSubEsc, cjIn, pvIn, cjOut, pvOut);
        break;
      }

      // APPSET
      // queries ICDs registry path and information about ICD name
      case SUBESC_ET_QUERY_OPENGLICD_REGPATH:
      {
        if ( (NULL==pvOut) || 
             (sizeof(ET_OPENGLICD_REGPATH) > cjOut) ) 
        {
          DBG_ERROR("SUBESC_ET_QUERY_OPENGLICD_REGPATH cjOut to small");
          break;
        }

        // FNicklisch 14.09.00: lRet = lQueryOpenGlIcdRegPath(ppdev, (ET_OPENGLICD_REGPATH *)pvOut);
        break;
      }

      case SUBESC_ET_QUERY_VALUE_BINARY:  
      case SUBESC_ET_QUERY_VALUE_STRING:  
      case SUBESC_ET_QUERY_VALUE_DWORD:   
      case SUBESC_ET_SET_VALUE_STRING:  
      case SUBESC_ET_SET_VALUE_DWORD:  
      //case SUBESC_ET_SET_VALUE_DEFAULT:
      {
        // FNicklisch 14.09.00: lRet = lEscRegistryValue(ppdev, dwSubEsc, cjIn, pvIn, cjOut, pvOut);
        break;
      }

#if 0 // FNicklisch 14.09.00: unused
      // POWERLIB
      case SUBESC_ET_POWERLIB_START:  
      {
        if( !ppdev )
          break;
        // increase number of started powerlibs
        ppdev->pElsaPDEV->nPowerLibsStarted++;
        // switch on hardwarelines, witch won't pass the WHQL
        lRet = ESC_SUCCESS;
        break;
      }

      case SUBESC_ET_POWERLIB_EXIT:  
      {
        ppdev = pPDEVGetFromPso( pso );
        if( !ppdev )
          break;
        // are there any powerlibs left ?
        if( ppdev->pElsaPDEV->nPowerLibsStarted )
          ppdev->pElsaPDEV->nPowerLibsStarted--;
        // if tere are no powerlibs left, clear flag
        lRet = ESC_SUCCESS;
        break;
      }
#endif // FNicklisch 14.09.00: unused

      case SUBESC_ET_QUERY_ICDCLIENTINFO:
      {
        lRet = ESC_ERROR;
        break;
      }

      case SUBESC_ET_EDD_SETGAMMARAMP:

          if((cjIn  == sizeof(ET_EDD_SETGAMMARAMP)) && 
             (cjIn  == pEtQuery->dwSize)            &&
             (pvOut != NULL)                        &&
             (cjOut == sizeof(ET_SET_VALUE_RET))    &&
             (cjOut == pEtQuery->dwOutSize))
          {
            // FNicklisch 14.09.00: lRet = lEscET_EDD_SETGAMMARAMP(ppdev, (ET_EDD_SETGAMMARAMP*)pvIn, (ET_SET_VALUE_RET*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;
      
      case SUBESC_ET_EDD_GETGAMMARAMP:

          if((cjIn  == sizeof(ET_QUERY))            &&
             (cjIn  == pEtQuery->dwSize)            &&
             (pvOut != NULL)                        &&
             (cjOut == sizeof(ET_EDD_GETGAMMARAMP)) &&
             (cjOut == pEtQuery->dwOutSize) )
          {
            // FNicklisch 14.09.00: lRet = lEscET_EDD_GETGAMMARAMP(ppdev, (ET_QUERY*)pvIn, (ET_EDD_GETGAMMARAMP*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;
      
      case SUBESC_ET_SET_VALUE_BINARY:
          if((cjIn  >= sizeof(ET_SET_VALUE_BINARY_HDR_SIZE))  &&
             (cjIn  == pEtQuery->dwSize)                      &&
             (pvOut != NULL)                                  &&
             (cjOut == sizeof(ET_SET_VALUE_RET))              &&
             (cjOut == pEtQuery->dwOutSize) )
          {
            lRet = lEscET_SET_VALUE_BINARY(ppdev, (ET_SET_VALUE_BINARY*)pvIn, (ET_SET_VALUE_RET*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;

      case SUBESC_ET_DPMS:
          if((cjIn  == sizeof(ET_DPMS_IN))  &&
             (cjIn  == pEtQuery->dwSize)         &&
             (pvOut != NULL)                     &&
             (cjOut == sizeof(ET_DPMS_OUT)) &&
             (cjOut == pEtQuery->dwOutSize) )
          {
            // FNicklisch 14.09.00: lRet = lEscET_DPMS(ppdev, (ET_DPMS_IN*)pvIn, (ET_DPMS_OUT*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;

      case SUBESC_ET_QUERY_TEMPERATURE:
          if((cjIn  == sizeof(ET_QUERY))  &&
             (cjIn  == pEtQuery->dwSize)         &&
             (pvOut != NULL)                     &&
             (cjOut == sizeof(ET_QUERY_TEMPERATURE)) &&
             (cjOut == pEtQuery->dwOutSize) )
          {
            // FNicklisch 14.09.00: lRet = lEscET_QUERY_TEMPERATURE(ppdev, (ET_QUERY*)pvIn, (ET_QUERY_TEMPERATURE*)pvOut);
          }
          else
          {
            lRet = ESC_ERROR;
          }
          break;

      default:
      {
        DISPDBG((DBG_LVL_WARNING, "WARNING in ulEscapeTools: Unsuported sub escape: %s, 0x%x",szDbg_GetETSubEscName(dwSubEsc),dwSubEsc));
        lRet=ESC_NOTSUPPORTED; // Not supported
        break;
      }
    } // .. switch
  } // .. if cjIn else ..
Exit:
#endif
  if (ESC_ERROR==lRet) 
  {
    EngSetLastError(ERROR_INVALID_PARAMETER); 
  }

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);

  return lRet;
}

#ifndef RUN_WITH_NVIDIA_MINIPORT 

//*******************************************************************************************
/*
** lQueryEtVersionInfo
**
** is a tools escape function, that returns the drivers
** registry path, version number and capability flags.
**
** return: ESC_ERROR:   failed, returned data invalid
**         ESC_SUCCESS: ok, returned data valid
*/
#if 1
// local information
#pragma message ("  FNicklis: use the other lQueryEtVersionInfo if finally tested!")
static LONG lQueryEtVersionInfo(
  IN  PPDEV            ppdev, 
  OUT ET_VERSION_INFO *pVersionInfo)
{
  LONG              lRet  = ESC_ERROR;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY,lQueryEtVersionInfo);

  ASSERTDD(NULL!=ppdev,        "");
  ASSERTDD(NULL!=pVersionInfo, "");

  pVersionInfo->dwSize = sizeof(ET_VERSION_INFO);

  szStrCpy( pVersionInfo->szRegDriverKey,    "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\nv4" );
  szStrCpy( pVersionInfo->Version.szVersion, NV_VERSION_MS_STRING_NT4);

  pVersionInfo->Version.dwFlags           = 0;
  #if defined (BETA_VERSION)
  pVersionInfo->Version.dwFlags          |= ET_VER_BETA_DRIVER; 
  #endif
  pVersionInfo->Version.dwNTMajor         = 4;
  pVersionInfo->Version.dwNTMinor         = 0;
  pVersionInfo->Version.dwNTBuildMajor    = 1381;
  pVersionInfo->Version.dwNTBuildMinor    = NV_DRIVER_VERSION_NUMBER;

  // validate capabilities
  pVersionInfo->Version.dwNTVersionStamp  = ET_VERSION_STAMP10;
  // FNicklisch 14.09.00: if ( b2DCapsTest(FL_2DCAPS_CV_BOARD) )
  {
    pVersionInfo->Version.dwNTCapabilities |= ET_VERSION_CAPS_CV_PRODUCT;
  }

  // We always have 3D boards in CV!
  // pVersionInfo->Version.dwNTCapabilities |= ET_VERSION_CAPS_2D_BOARD_ONLY;

  // FNicklisch 14.09.00: vDbg_PrintET_VERSION_INFO(DBG_LVL_FLOW1, "pVersionInfo", pVersionInfo);

  lRet = ESC_SUCCESS;

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY,lRet);

  return lRet;
}

#else
// FNicklis informationvia IOCTL
static LONG lQueryEtVersionInfo(
  IN  PPDEV            ppdev, 
  OUT ET_VERSION_INFO *pVersionInfo)
{
  LONG  lRet    = ESC_ERROR;
  LONG  lResult = 0;
  DWORD dwReturnedDataLength;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY,lQueryEtVersionInfo);

  ASSERTDD(NULL!=ppdev,        "");
  ASSERTDD(NULL!=pVersionInfo, "");

  lResult = (LONG)EngDeviceIoControl( ppdev->hDriver,
                                      IOCTL_VIDEO_GET_ET_VERSION_INFO,
                                      NULL,0,
                                      (VOID*)pVersionInfo,sizeof(ET_VERSION_INFO),
                                      &dwReturnedDataLength);

  if (NO_ERROR==lResult)
  {  
    ASSERT(pVersionInfo->dwSize==sizeof(ET_VERSION_INFO));
    ASSERT(pVersionInfo->dwSize==dwReturnedDataLength);

    lRet = ESC_SUCCESS;
  }

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY,lRet);

  return lRet;
}
#endif

//*******************************************************************************************
static LONG lQueryOpenGlIcdRegPath(
      PPDEV                 ppdev,
  OUT ET_OPENGLICD_REGPATH *pIcdRegPath)
{
  LONG                   lRet   = ESC_ERROR;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lQueryOpenGlIcdRegPath);

  ASSERTDD(NULL!=ppdev,       "");
  ASSERTDD(NULL!=pIcdRegPath, "");

  pIcdRegPath->dwSize = sizeof(ET_OPENGLICD_REGPATH);

  szStrCpy(pIcdRegPath->szRegICDKey,  "\\REGISTRY\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\OpenGLDrivers\\\0");
  szStrCat(pIcdRegPath->szRegICDKey, "RIVATNT");

  // Default String build by environment
  szStrCpy(pIcdRegPath->szRegICDName, "nvoglnt");

  DBG_PRINTS(DBG_LVL_FLOW1, pIcdRegPath->szRegICDKey);
  DBG_PRINTS(DBG_LVL_FLOW1, pIcdRegPath->szRegICDName);

  lRet = ESC_SUCCESS;

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);

  return lRet;
}



#define GAMMA_TABLE_ENTRIES (256 * 3)

// CSchalle 8/25/99 2:21:09 PM: new
static LONG lEscET_EDD_GETGAMMARAMP(IN const  PPDEV                 ppdev, 
                                    IN const  ET_QUERY*             pET_Query, 
                                    OUT       PET_EDD_GETGAMMARAMP  pETGetGammaRamp)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lEscET_EDD_GETGAMMARAMP);

  ASSERT(ppdev            != NULL);
  ASSERT(pET_Query        != NULL);
  ASSERT(pETGetGammaRamp  != NULL);

  if(nvGetGammaRamp(ppdev, &pETGetGammaRamp->red[0]) == 256)
  {
    pETGetGammaRamp->dwResult = ET_VALUE_OK;
    pETGetGammaRamp->dwSize   = sizeof(ET_EDD_GETGAMMARAMP);
    lRet                      = ESC_SUCCESS;
  }
  else
  {
    pETGetGammaRamp->dwResult = ET_VALUE_BLOCKED;
    pETGetGammaRamp->dwSize   = 0;
    lRet                      = ESC_ERROR;
  }

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);
  return lRet;
}


// CSchalle 8/25/99 2:08:44 PM: new
static LONG lEscET_EDD_SETGAMMARAMP(IN        PPDEV ppdev, 
                                    IN const  PET_EDD_SETGAMMARAMP  pETSetGammaRamp, 
                                    OUT       PET_SET_VALUE_RET     pETSetValueRet)
{
  LONG lRet;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lEscET_EDD_SETGAMMARAMP);

  ASSERT(ppdev           != NULL);
  ASSERT(pETSetGammaRamp != NULL);
  ASSERT(pETSetValueRet  != NULL);

  // prepare output structure
  RtlZeroMemory(pETSetValueRet, sizeof(ET_SET_VALUE_RET));
  pETSetValueRet->dwSize  = sizeof(ET_SET_VALUE_RET);

  if(nvSetGammaRamp(ppdev, &pETSetGammaRamp->red[0]) == 256)
  {
    pETSetValueRet->dwFlags = ET_VALUE_OK;
    lRet                    = ESC_SUCCESS;
  }
  else
  {
    pETSetValueRet->dwFlags = ET_VALUE_BLOCKED;
    lRet                    = ESC_ERROR;
  }

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);
  return lRet;
}

// CSchalle 8/26/99 3:17:22 PM:new
// FNicklis 05.10.1999: Allow all IDs and not only ET_VALUE_BIN_GDI_GAMMARAMP
static LONG lEscET_SET_VALUE_BINARY(IN        PPDEV ppdev, 
                                    IN const  PET_SET_VALUE_BINARY  pETSetValueBinary, 
                                    OUT       PET_SET_VALUE_RET     pETSetValueRet)
{
  LONG  lRet = ESC_ERROR;
  LONG  lSize;

  ASSERT(ppdev              != NULL);
  ASSERT(pETSetValueBinary  != NULL);
  ASSERT(pETSetValueRet     != NULL);

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lEscET_SET_VALUE_BINARY);

  // prepare output structure
  pETSetValueRet->dwID    = pETSetValueBinary->dwID;
  pETSetValueRet->dwSize  = sizeof(ET_SET_VALUE_RET);
  pETSetValueRet->dwFlags = ET_VALUE_UNKNOWN;

  // calculate amount of data behind dwData
  lSize = pETSetValueBinary->hdr.dwSize - ET_SET_VALUE_BINARY_HDR_SIZE;

  switch(pETSetValueBinary->dwID)
  {
    case ET_VALUE_BIN_GDI_GAMMARAMP:
    {

      __try // never trust...
      {
        ASSERT(lSize == GAMMA_TABLE_ENTRIES * sizeof(USHORT));

        // refuse to store partial table, or in palettized modes!
        if(lSize                == GAMMA_TABLE_ENTRIES * sizeof(USHORT) && 
           ppdev->iBitmapFormat >  BMF_8BPP)
        {
          if(REG_OK == lRegSetIdBinary(ppdev->hDriver, 
                                       ET_VALUE_BIN_GDI_GAMMARAMP, 
                                       (const BYTE *)pETSetValueBinary->ajData, 
                                       lSize))
          {
            DISPDBG((DBG_LVL_ERROR, "storing gamma table to registry..."));

            pETSetValueRet->dwFlags = ET_VALUE_OK;
      
            lRet                    = ESC_SUCCESS;
          }
        }
        else
        {
          DISPDBG((DBG_LVL_ERROR, "refusing to store gamma table of size %d at BMF %d", lSize, ppdev->iBitmapFormat));
        }
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
        DISPDBG((DBG_LVL_ERROR, "ERROR in lEscET_SET_VALUE_BINARY: Exception failed with: %s",szDbg_GetExceptionCode(GetExceptionCode())));
      }
      break;
    }

    default: 
    {
      // write lSize Bytes to registry key with dwID
      if(REG_OK == lRegSetIdBinary(ppdev->hDriver, 
                                   pETSetValueBinary->dwID, 
                                   (const BYTE *)pETSetValueBinary->ajData, 
                                   lSize))
      {
        // succeeded 
        pETSetValueRet->dwFlags = ET_VALUE_OK;      
        lRet                    = ESC_SUCCESS;
      }
      break;
    }
  }
  
  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);

  return lRet;
}


/*
** lEscET_DPMS
**
** handles ET_DPMS ELSA escape.
**
** return: ESC_SUCCESS:      ok, returned data valid
**         ESC_ERROR:        failed, returned data invalid
**
** FNicklis 28.09.1999: New
** FNicklis 06.10.1999: Use IOCTL to Miniport
*/
static LONG lEscET_DPMS(
  IN     PPDEV        ppdev, 
  IN     ET_DPMS_IN  *pIn, 
     OUT ET_DPMS_OUT *pOut)
{
  LONG  lRet    = ESC_ERROR;
  LONG  lResult = 0;
  DWORD dwReturnedDataLength;


  DBG_TRACE_IN(DBG_LVL_SUBENTRY_NLF, lEscET_DPMS);
  DISPDBG((DBG_LVL_SUBENTRY_NPLF, " pIn:0x%x, pOut:0x%x",pIn,pOut));

  ASSERT(NULL!=ppdev);
  ASSERT(NULL!=pIn);

#if 0 // FNicklisch 14.09.00: not supported yet
    lResult = (LONG)EngDeviceIoControl( ppdev->hDriver,
                                      IOCTL_VIDEO_ET_DPMS,
                                      (VOID*)pIn, sizeof(ET_DPMS_IN),
                                      (VOID*)pOut,sizeof(ET_DPMS_OUT),
                                      &dwReturnedDataLength);

  if (NO_ERROR==lResult)
  {  
    ASSERT(pOut->dwSize==sizeof(ET_DPMS_OUT));
    ASSERT(pOut->dwSize==dwReturnedDataLength);

    // remember set mode!
    ppdev->pElsaPDEV->lDPMSMode = pOut->lMode;

    lRet = ESC_SUCCESS;
  }

#endif // FNicklisch 14.09.00: not supported yet

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY,lRet);

  return lRet;
}

/*
** lEscET_QUERY_TEMPERATURE
**
** handles ET_QUERY_TEMPERATUR ELSA escape.
**
** return: ESC_SUCCESS:      ok, returned data valid
**         ESC_ERROR:        failed, returned data invalid
**
** FNicklis 30.09.1999: New
*/
static LONG lEscET_QUERY_TEMPERATURE(
  IN    PPDEV                 ppdev, 
  IN    ET_QUERY             *petQuery, 
    OUT ET_QUERY_TEMPERATURE *petTemperature)
{
  LONG lRet=ESC_ERROR;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY_NLF, lEscET_QUERY_TEMPERATURE);
#if 0 // ELSA-FNicklis 04.07.00: unused
    DISPDBG((DBG_LVL_SUBENTRY_NPLF, " petQuery:0x%x, petTemperature:0x%x",petQuery,petTemperature));

  ASSERT(NULL!=ppdev);
  ASSERT(NULL!=petQuery);
  ASSERT(NULL!=petTemperature);

  petTemperature->dwSize              = sizeof(ET_QUERY_TEMPERATURE);

  // set capabilities of driver e.g. ET_TEMPERATURE_FANSLOW | ET_TEMPERATURE_OVERTEMP
  petTemperature->dwTemperatureCaps   = 0;                          

  // set error status: e.g. ET_TEMPERATURE_FANSLOW if fan irq occured
  // get this from miniport, where irq handler receives fan irqs
  petTemperature->dwTemperatureStatus = (DWORD) flGetTemperatureStatus(ppdev->pElsaPDEV->pHDE); 

  // unused for now
  petTemperature->dwTemperatureValue  = 0;                          

  lRet=ESC_SUCCESS;
#endif // ELSA-FNicklis 04.07.00: unused

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRet);
  return (lRet);
}
        
#endif //RUN_WITH_NVIDIA_MINIPORT 
#endif //USE_WKS_ELSA_TOOLS
// End of wkselsatoolsescape.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsdebug.h ===
#ifndef _WKSELSATOOLSDEBUG_H
#define _WKSELSATOOLSDEBUG_H
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsdebug.h
//
// compatibility code only 
//
// FNicklisch 09/14/2000: New, derived from ELSA debug.h
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

#ifdef USE_WKS_ELSA_TOOLS
#if DBG

#define DISPDBGCOND(cond,arg)                 if(cond)DebugPrint arg; else NULL
#define DBG_CURRENTPOSITION DISPDBG((0, "file:%s, line:%d",__FILE__,__LINE__))

#ifdef i386
#define DBG_HW_INDEP_BREAK { __asm {int 3} }
#else
#define DBG_HW_INDEP_BREAK EngDebugBreak()
#endif

#undef RIP
// FN more comfortable RIP
#define RIP(text)                                     \
  {                                                   \
    ENG_TIME_FIELDS localTime;                        \
    EngQueryLocalTime(&localTime);                    \
    DebugPrint(0, "RIP %s in %s, %d at %02d:%02d on %02d.%02d.%04d", \
      text?text:"",__FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
    DBG_HW_INDEP_BREAK;                                        \
    DebugPrint(0, "RIP %s in %s, %d at %02d:%02d on %02d.%02d.%04d", \
      text?text:"",__FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
  }

#ifdef _WIN64 
  // FNicklis IA-64: Rip that only works on IA64
  #define RIP_IA64(text)                                                           \
    DebugPrint(0, "RIP %s: FNicklis IA-64: Code possibly crashes on IA64",text?text:""); \
    RIP(text)
#else 
  #define RIP_IA64(text)
#endif

#define DBGBREAK()                                    \
  {                                                   \
    ENG_TIME_FIELDS localTime;                        \
    EngQueryLocalTime(&localTime);                    \
    DebugPrint(0, "BREAK in %s, %d at %02d:%02d on %02d.%02d.%04d", \
      __FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
    DBG_HW_INDEP_BREAK;                                        \
    DebugPrint(0, "BREAK in %s, %d at %02d:%02d on %02d.%02d.%04d", \
      __FILE__,__LINE__,localTime.usHour,localTime.usMinute,localTime.usDay,localTime.usMonth,localTime.usYear);\
  }

#undef ASSERTDD
// FN more comfortable ASSERTDD
#define ASSERTDD(condition, text)                                  \
  if (FALSE==(condition))                                          \
  {                                                                \
    DebugPrint(0, "ASSERTION \"%s\" failed: %s (%s,%d)",#condition, text,__FILE__,__LINE__); \
    DBG_TRACE_DUMP(0);                                             \
    DBGBREAK(); /* No more output (text) needed! */                 \
    DebugPrint(0, "ASSERTION \"%s\" failed: %s (%s,%d)",#condition, text,__FILE__,__LINE__); \
  }

#undef ASSERT // remove if defined!
#define ASSERT(condition) ASSERTDD(condition,"")
#define DBG_LVL_SWITCHFLAG      0 // ( BIT(31) ) // DON'T USE THIS, BECAUSE THIS IS THE FLAG TO SWITCH
                                            // BETWEEN FLAGED ANS UNFLAGED DEBUGLEVEL

#define DBG_LVL_0               0 // ( DBG_LVL_SWITCHFLAG | BIT(0)|BIT(1)|BIT(2)|BIT(3)) // bit 0-3 but not break!
#define DBG_LVL_ENTRY           5 // ( DBG_LVL_SWITCHFLAG | BIT(0) ) // for Entry to driver function
#define DBG_LVL_PARAM           7 // ( DBG_LVL_SWITCHFLAG | BIT(1) ) // info for functions parameter
#define DBG_LVL_OPENPARAM       8 // ( DBG_LVL_SWITCHFLAG | BIT(2) ) // db want's it for extended info for functions parameter
#define DBG_LVL_PUNT            4 // ( DBG_LVL_SWITCHFLAG | BIT(3) ) // when punting function to engine

#define DBG_LVL_1               0 // ( DBG_LVL_SWITCHFLAG | BIT(4)|BIT(5)|BIT(6)|BIT(7)) // bit 4-7
#define DBG_LVL_SUBENTRY        6 // ( DBG_LVL_SWITCHFLAG | BIT(4) ) // Output for sub entry/function
#define DBG_LVL_FLOW0           8 // ( DBG_LVL_SWITCHFLAG | BIT(5) ) // 
#define DBG_LVL_FLOW1           9 // ( DBG_LVL_SWITCHFLAG | BIT(6) )
#define DBG_LVL_FLOW2           10// ( DBG_LVL_SWITCHFLAG | BIT(7) )

#define DBG_LVL_2               0 // ( DBG_LVL_SWITCHFLAG | BIT(8)|BIT(9)|BIT(10)|BIT(11)) // bit 8-11
#define DBG_LVL_IA64            7 // ( DBG_LVL_SWITCHFLAG | BIT(8) )  // for output that is not for others interest
#define DBG_LVL_DB              1 // ( DBG_LVL_SWITCHFLAG | BIT(9) )
#define DBG_LVL_FN              1 // ( DBG_LVL_SWITCHFLAG | BIT(10) )
#define DBG_LVL_UNUSED11        10// ( DBG_LVL_SWITCHFLAG | BIT(11) )

#define DBG_LVL_3               0 // ( DBG_LVL_SWITCHFLAG | BIT(12)|BIT(13)|BIT(14)|BIT(15))
#define DBG_LVL_MS              1 // ( DBG_LVL_SWITCHFLAG | BIT(12) )
#define DBG_LVL_UNUSED13        10// ( DBG_LVL_SWITCHFLAG | BIT(13) ) // ***unused
#define DBG_LVL_UNUSED14        10// ( DBG_LVL_SWITCHFLAG | BIT(14) ) // ***unused
#define DBG_LVL_UNUSED15        10// ( DBG_LVL_SWITCHFLAG | BIT(15) ) // ***unused

#define DBG_LVL_4               0 // ( DBG_LVL_SWITCHFLAG | BIT(16)|BIT(17)|BIT(18)|BIT(19))
#define DBG_LVL_WARNING         2 // ( DBG_LVL_SWITCHFLAG | BIT(16) ) // for Warnings that aren't as severe as errors
#define DBG_LVL_ERROR           1 // ( DBG_LVL_SWITCHFLAG | BIT(17) ) // for output that isn't as severe as an failed assertion
#define DBG_LVL_UNUSED18        10// ( DBG_LVL_SWITCHFLAG | BIT(18) ) // ***unused
#define DBG_LVL_UNUSED19        10// ( DBG_LVL_SWITCHFLAG | BIT(19) ) // ***unused

#define DBG_LVL_5               0 // ( DBG_LVL_SWITCHFLAG | BIT(20)|BIT(21)|BIT(22)|BIT(23))
#define DBG_LVL_OUTS            10// ( DBG_LVL_SWITCHFLAG | BIT(20) ) // for data passed to HW
#define DBG_LVL_TEST            1 // ( DBG_LVL_SWITCHFLAG | BIT(21) ) // for temporay output, don't check in code to source safe with TEST set!
#define DBG_LVL_CONTEXT         10 // ( DBG_LVL_SWITCHFLAG | BIT(22) ) // for all output relating to contexts
#define DBG_LVL_UNUSED23        10 // ( DBG_LVL_SWITCHFLAG | BIT(23) ) // ***unused

#define DBG_LVL_6               0 // ( DBG_LVL_SWITCHFLAG | BIT(24)|BIT(25)|BIT(26)|BIT(27))
#define DBG_LVL_SWBC            8 // ( DBG_LVL_SWITCHFLAG | BIT(24) ) // for all output relating to sowftware broadcasting
#define DBG_LVL_RECT            10// ( DBG_LVL_SWITCHFLAG | BIT(25) ) // for all output relating to rectangles
#define DBG_LVL_HEAP            10// ( DBG_LVL_SWITCHFLAG | BIT(26) ) // for all output relating to heap
#define DBG_LVL_SYNC            10// ( DBG_LVL_SWITCHFLAG | BIT(27) ) // for all output relating to chip synchronization

// Signaling flags 
#define DBG_LVL_7               0 // ( BIT(28)|BIT(29)|BIT(30)|BIT(31) )
#define DBG_LVL_ENUMERATE       0 // ( BIT(28) ) // to enumerate lists, arrays etc instead of printing only pointer or one element
#define DBG_LVL_NOPREFIX        0 // ( BIT(29) ) // DebugPrint without prefix
#define DBG_LVL_NOLINEFEED      0 // ( BIT(30) ) // DebugPrint without linefeed
#define DBG_LVL_BIT31           0 // ( BIT(31) ) // DON'T USE THIS, BECAUSE THIS IS THE FLAG TO SWITCH
//                                          // BETWEEN FLAGGED AND UNFLAGGED DEBUGLEVEL

// Shorcuts to enable continuous lines (used by FN only?)
// Example:   DBG_TRACE_IN(DBG_LVL_SUBENTRY_NLF, functionX);           // continue line
//            DISPDBG((DBG_LVL_SUBENTRY_NPLF, "ppdev: 0x%x", ppdev));  // continued line to be continued again
//            DISPDBG((DBG_LVL_SUBENTRY_NP,   ", index: %d", index));  // continued line finished now
//            DBG_PRINTD(DBG_LVL_FLOW0, index);                        // new line (only to show result)
//          will print 
//            NV0:  functionX { ppdev:0x12345678, index: 4
//            NV0:    index: 4                            
#define DBG_LVL_ENTRY_NLF         ( DBG_LVL_ENTRY    | DBG_LVL_NOLINEFEED )
#define DBG_LVL_ENTRY_NPLF        ( DBG_LVL_ENTRY    | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_ENTRY_NP          ( DBG_LVL_ENTRY    | DBG_LVL_NOPREFIX   )
#define DBG_LVL_SUBENTRY_NLF      ( DBG_LVL_SUBENTRY | DBG_LVL_NOLINEFEED )
#define DBG_LVL_SUBENTRY_NPLF     ( DBG_LVL_SUBENTRY | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_SUBENTRY_NP       ( DBG_LVL_SUBENTRY | DBG_LVL_NOPREFIX   )
#define DBG_LVL_FLOW0_NLF         ( DBG_LVL_FLOW0    | DBG_LVL_NOLINEFEED )
#define DBG_LVL_FLOW0_NPLF        ( DBG_LVL_FLOW0    | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_FLOW0_NP          ( DBG_LVL_FLOW0    | DBG_LVL_NOPREFIX   )
#define DBG_LVL_FLOW1_NLF         ( DBG_LVL_FLOW1    | DBG_LVL_NOLINEFEED )
#define DBG_LVL_FLOW1_NPLF        ( DBG_LVL_FLOW1    | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_FLOW1_NP          ( DBG_LVL_FLOW1    | DBG_LVL_NOPREFIX   )
#define DBG_LVL_FLOW2_NLF         ( DBG_LVL_FLOW2    | DBG_LVL_NOLINEFEED )
#define DBG_LVL_FLOW2_NPLF        ( DBG_LVL_FLOW2    | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_FLOW2_NP          ( DBG_LVL_FLOW2    | DBG_LVL_NOPREFIX   )
#define DBG_LVL_TEST_NLF          ( DBG_LVL_TEST     | DBG_LVL_NOLINEFEED )
#define DBG_LVL_TEST_NPLF         ( DBG_LVL_TEST     | DBG_LVL_NOPREFIX   | DBG_LVL_NOLINEFEED)
#define DBG_LVL_TEST_NP           ( DBG_LVL_TEST     | DBG_LVL_NOPREFIX   )

// Shortcuts (lower levels include higher - more important - levels)
#define DBG_LVL_2ERROR         (DBG_LVL_ERROR)
#define DBG_LVL_2WARNING       (DBG_LVL_2ERROR|DBG_LVL_WARNING)
#define DBG_LVL_2TEST          (DBG_LVL_2ERROR|DBG_LVL_TEST)
#define DBG_LVL_2ENTRY         (DBG_LVL_2WARNING|DBG_LVL_ENTRY)
#define DBG_LVL_2SUBENTRY      (DBG_LVL_2ENTRY|DBG_LVL_SUBENTRY)
#define DBG_LVL_2FLOW          (DBG_LVL_2SUBENTRY|DBG_LVL_FLOW0|DBG_LVL_FLOW1)
#define DBG_LVL_2DB            (DBG_LVL_2FLOW|DBG_LVL_DB|DBG_LVL_TEST)
#define DBG_LVL_2FN            (DBG_LVL_2FLOW|DBG_LVL_FN|DBG_LVL_TEST)
#define DBG_LVL_2SK            (DBG_LVL_2FLOW|DBG_LVL_SK|DBG_LVL_TEST)
#define DBG_LVL_2MS            (DBG_LVL_2FLOW|DBG_LVL_MS|DBG_LVL_TEST)
#define DBG_LVL_FULLOUTPUT     (DBG_LVL_0|DBG_LVL_1|DBG_LVL_4|DBG_LVL_5|DBG_LVL_6) // All but break, user depending and anoying output

#define DBG_LVL_FULLFN (DBG_LVL_FULLOUTPUT & ~(DBG_LVL_FLOW2|DBG_LVL_OUTS|DBG_LVL_HEAP))
#define DBG_LVL_FULLDB (DBG_LVL_FULLOUTPUT & ~DBG_LVL_OUTS)

#define DBG_LVL_CHECK(flDbgFlags,flFlag) ((flDbgFlags & ~DBG_LVL_7) & flFlag) // mask out signalling flags




extern VOID DebugGetFlagsAddress(void);
// In this array the global Debugflags are stored
#if 0 // FNicklisch 14.09.00: unused
extern FLONG flDbgFlags[DBG_MAX_GROUPS];
extern FLONG flDbgFlagsReset;
extern LONG  DebugLevel;
extern char szDbgStandardDebugPrefix[70];

// This variable conatines the stored flags local (!) to every module
static ULONG SavedFlags = 0; // **FN** 191196
#endif // FNicklisch 14.09.00: unused

#define DBGFLAGSSET(drventry,dbgflags) //                 { flDbgFlags[(drventry)]=(dbgflags); }
#define DBGFLAGSNEW(dbgflags)          //                 { SavedFlags=flDbgFlags[flDbgFlags[DBG_ACTUAL_FUNCTION]]; DBGFLAGSSET(flDbgFlags[DBG_ACTUAL_FUNCTION],dbgflags); }
#define DBGFLAGSOLD()                  //                 { flDbgFlags[flDbgFlags[DBG_ACTUAL_FUNCTION]]=SavedFlags; }

VOID vDbg_PrintPOINTL(FLONG flFlags, PCHAR pcString, const POINTL *pptl);
VOID vDbg_PrintRECTL(FLONG flFlags, PCHAR pcString, const RECTL *prcl);
VOID vDbg_PrintRECTLArray(FLONG flFlags, PCHAR pcString, const RECTL *prcl, LONG c);
VOID vDbg_PrintSIZEL(FLONG flFlags, PCHAR pcString, const SIZEL *psiz);

VOID vDbg_PrintCLIPOBJ(FLONG flFlags, PCHAR pcString, const CLIPOBJ *pco);
VOID vDbg_PrintCLIPOBJiDComplexity(FLONG flFlags, BYTE iDComplexity);
VOID vDbg_PrintCLIPOBJiFComplexity(FLONG flFlags, BYTE iFComplexity);

VOID vDbg_PrintXLATEOBJ(FLONG flFlags, PCHAR pcString, const XLATEOBJ *pxlo);
VOID vDbg_PrintXLATEOBJiType(FLONG flFlags, USHORT iType);
VOID vDbg_PrintXLATEOBJflXlate(FLONG flFlags, FLONG flXlate);

VOID vDbg_PrintSURFOBJ(FLONG flFlags, PCHAR pcString, const SURFOBJ *pso);
VOID vDbg_PrintSURFOBJiType(FLONG flFlags, USHORT  iType);
VOID vDbg_PrintSURFOBJiBitmapFormat(FLONG flFlags, ULONG iBitmapFormat);
char *szDbg_GetEscapeName(ULONG ulEsc);
char *szDbg_GetETSubEscName(LONG SubEscNr);

char *szDbg_TRACE_GetCurrentFn(VOID);
VOID vDbg_TRACE_IN(FLONG flDbgFlags, char *szFunction, PFN pfn);
VOID vDbg_TRACE_OUT(FLONG flDbgFlags, char *szRetVal, ULONG ulRetVal);
VOID vDbg_PrintTRACE_DUMP(FLONG flDbgLvl);

#define DBG_TRACE_IN(flDbgFlags,function) //vDbg_TRACE_IN((FLONG)flDbgFlags,#function,(PFN)function)
// FNicklis IA-64: Bad truncaton of a pointer to 32 bit!
#define DBG_TRACE_OUT(flDbgFlags,retVal)  //vDbg_TRACE_OUT((FLONG)flDbgFlags,#retVal,(ULONG)((ULONG_PTR)(retVal)))
#define DBG_TRACE_DUMP(flDbgLvl) //vDbg_PrintTRACE_DUMP(flDbgLvl)
#define DBG_ERROR(szText)   {static ULONG ulOutCount=0; if(ulOutCount++ <20) DISPDBG((DBG_LVL_ERROR, "ERROR in %s called by %s: %s",szDbg_TRACE_GetCurrentFn(),szGetApplicationName(), szText));}
#define DBG_WARNING(szText) {static ULONG ulOutCount=0; if(ulOutCount++ <20) DISPDBG((DBG_LVL_WARNING, "WARNING in %s called by %s: %s",szDbg_TRACE_GetCurrentFn(),szGetApplicationName(), szText));}
#define DBG_TEST(szText)    DISPDBG((DBG_LVL_TEST, "Testline in %s: %s (remove this output now:%s, line:%d!)",szDbg_TRACE_GetCurrentFn(),szText,__FILE__,__LINE__))
// FNicklis IA-64: Bad truncaton of a pointer to 32 bit!
#define DBG_PRINTX(flDbgFlags,variable) DISPDBG((flDbgFlags, "%s:0x%x",#variable,(ULONG)((ULONG_PTR)(variable))))
#define DBG_PRINTD(flDbgFlags,variable) DISPDBG((flDbgFlags, "%s:%d",#variable,variable))
#define DBG_PRINTS(flDbgFlags,variable) DISPDBG((flDbgFlags, "%s:%s",#variable,variable))
#define DBG_PRINTB(flDbgFlags,variable) DISPDBG((flDbgFlags, "%s:%s",#variable,variable?"TRUE":"FALSE"))

// FNicklis IA-64: Bad truncaton of a pointer to 32 bit!
#define DBG_TESTX(variable) DISPDBG((DBG_LVL_TEST, "%s: %s:0x%x",szDbg_TRACE_GetCurrentFn(),#variable,(ULONG)((ULONG_PTR)(variable))))
#define DBG_TESTD(variable) DISPDBG((DBG_LVL_TEST, "%s: %s:%d",szDbg_TRACE_GetCurrentFn(),#variable,variable))
#define DBG_TESTS(variable) DISPDBG((DBG_LVL_TEST, "%s: %s:%s",szDbg_TRACE_GetCurrentFn(),#variable,variable))
#define DBG_TESTB(variable) DISPDBG((DBG_LVL_TEST, "%s: %s:%s",szDbg_TRACE_GetCurrentFn(),#variable,variable?"TRUE":"FALSE"))

#define FL_DBG_CHECK_PTRONLY      0x00
#define FL_DBG_CHECK_NEXT         0x01
#define FL_DBG_CHECK_PREV         0x02
#define FL_DBG_CHECK_NEXTEMPTY    0x04
#define FL_DBG_CHECK_LIST         0x08
#define FL_DBG_CHECK_MEMORY       0x10

#define FL_DBG_CHECK_LINK         (FL_DBG_CHECK_NEXT |FL_DBG_CHECK_PREV)
#define FL_DBG_CHECK_LINKMEM      (FL_DBG_CHECK_NEXT |FL_DBG_CHECK_PREV|FL_DBG_CHECK_MEMORY)
#define FL_DBG_CHECK_LINKS        (FL_DBG_CHECK_NEXT |FL_DBG_CHECK_PREV|FL_DBG_CHECK_NEXTEMPTY)
#define FL_DBG_CHECK_LINKSMEM     (FL_DBG_CHECK_NEXT |FL_DBG_CHECK_PREV|FL_DBG_CHECK_NEXTEMPTY|FL_DBG_CHECK_MEMORY)
#define FL_DBG_CHECK_LINKLIST     (FL_DBG_CHECK_LINK |FL_DBG_CHECK_LIST)
#define FL_DBG_CHECK_LINKLISTMEM  (FL_DBG_CHECK_LINK |FL_DBG_CHECK_LIST|FL_DBG_CHECK_MEMORY)
#define FL_DBG_CHECK_LINKSLIST    (FL_DBG_CHECK_LINKS|FL_DBG_CHECK_LIST)
#define FL_DBG_CHECK_LINKSLISTMEM (FL_DBG_CHECK_LINKS|FL_DBG_CHECK_LIST|FL_DBG_CHECK_MEMORY)

#define FL_DBG_CHECK_ALL          (0xFF)

BOOL bDbg_CheckHeapNode(const struct _memory_t *pHeap,const struct _memory_t *pNode, FLONG flCheck);
VOID vDbg_CheckHeapIntegrity(FLONG flDbgLvl, char *szText, const struct _memory_t *pHeap);
VOID vDbg_Print_memory_t(FLONG flDbgLvl, char *szText, const struct _memory_t *pHeap);
char *szDbg_GetET_VALUE_IDName(DWORD dwID);


extern LONG Void;
#define DBGVOID Void

extern BOOL bDbg_CheckHeap;

VOID vDbg_Printfl2DCapabilities(
  FLONG flDbgFlags, 
  PCHAR pcString, 
  const PPDEV ppdev);

VOID vDbg_PrintET_VERSION(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const struct tagET_VERSION *pVersion);

VOID vDbg_PrintET_VERSION_INFO(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const struct tagET_VERSION_INFO *pVersionInfo);

char *szDbg_GetExceptionCode(DWORD dwID);

void vDbg_PrintBitBltParams(ULONG ulFlags,SURFOBJ  *psoTrg,    
                                          SURFOBJ  *psoSrc,
                                          SURFOBJ  *psoMask,
                                          CLIPOBJ  *pco,
                                          XLATEOBJ *pxlo,
                                          RECTL    *prclTrg,
                                          POINTL   *pptlSrc,
                                          POINTL   *pptlMask,
                                          BRUSHOBJ *pbo,
                                          POINTL   *pptlBrush,
                                          ROP4     rop4);
void vDbg_PrintCopyBitsParams(ULONG ulFlags,  
                              SURFOBJ*  psoTrg,
                              SURFOBJ*  psoSrc,
                              CLIPOBJ*  pco,
                              XLATEOBJ* pxlo,
                              RECTL*    prclTrg,
                              POINTL*   pptlSrc);

#define PBB_DBG(arg)      vDbg_PrintBitBltParams    arg
#define PCB_DBG(arg)      vDbg_PrintCopyBitsParams  arg

char *szDbg_GetET_SET_VALUE_RETdwFlags(DWORD dwFlags);
char *szDbg_GetESC_RETURN(LONG lRet);
VOID vDbg_PrintET_VALUE_RETdwFlags(
  FLONG flDbgLvl, 
  PCHAR pcString, 
  DWORD dwFlags);

VOID vDbg_PrintflCaps(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  const PPDEV ppdev);

VOID vDbg_PrintBRUSHOBJ(FLONG flDbgFlags,PCHAR pcString,const BRUSHOBJ* pbo);
VOID vDbg_PrintExportedFunctions(FLONG flDbgLvl,PCHAR pcString, const DRVENABLEDATA *pded);
#if MULTI_BOARD
VOID vDbg_PrintFunctionTable(FLONG flDbgLvl, PCHAR pcString, const APFN* papfn);
VOID vDbg_PrintBlitDirectionTable( FLONG flDbgLvl, IN const PPDEV ppdev );
#endif
VOID vDbg_PrintPATHOBJ(
  FLONG    flDebugFlags, 
  PCHAR    pcString,   
  PATHOBJ *ppo);

VOID vDbg_PrintET_QUERY(
  IN       FLONG     flDebugFlags, 
  IN const PCHAR     pcString,   
  IN const struct tagET_QUERY *petQuery);
VOID vDbg_PrintET_WINMAN2_DATA_GET(
  IN       FLONG                flDebugFlags, 
  IN const PCHAR                pcString,   
  IN const struct tagET_WINMAN2_DATA_GET *pWINmanDataGet);
VOID vDbg_PrintET_WINMAN2_DATA_SET(
  IN       FLONG                flDebugFlags, 
  IN const PCHAR                pcString,   
  IN const struct tagET_WINMAN2_DATA_SET *pWINmanDataSet);
VOID vDbg_PrintET_WINMAN2_DATA_BRD_R(
  IN       FLONG                  flDebugFlags, 
  IN const PCHAR                  pcString,   
  IN const struct tagET_WINMAN2_DATA_BRD_R *pWINmanDataBrd);
VOID vDbg_PrintET_WINMAN2_DATA_BRD_RW(
  IN       FLONG                   flDebugFlags, 
  IN const PCHAR                   pcString,   
  IN const struct tagET_WINMAN2_DATA_BRD_RW *pWINmanDataBrdRW);
char *szDbg_GetWINMAN_SETName(ULONG fl);
char *szDbg_GetWINMAN_RESULTName(ULONG fl);
VOID vDbg_PrintflWINMAN_MOD(
  FLONG flDbgFlags, 
  PCHAR pcString,   
  DWORD dwDrvModFlags);
VOID vDbg_PrintVIDEO_MODE_INFORMATION(
  FLONG flDebugFlags, 
  PCHAR pcString,   
  struct _VIDEO_MODE_INFORMATION *pVideoModeInformation);
char *szDbg_GetREG_RETURN(LONG lRet);
VOID vDbg_PrintDEVMODEW(
  FLONG     flDebugFlags, 
  PCHAR     pcString,   
  struct _devicemodeW *pDevMode);
char *szDbg_GetDrvINDEX(ULONG ulIndex);

VOID vDbg_PrintET_VALUE_DWORD(
  FLONG           flDebugFlags, 
  PCHAR           pcString,   
  struct tagET_VALUE_DWORD *petDWord);

VOID vDbg_PrintET_VALUE_STRING(
  FLONG            flDebugFlags, 
  PCHAR            pcString,   
  struct tagET_VALUE_STRING *petString);

VOID vDbg_PrintSURFACE_flType(
  IN       FLONG flDbgLvl, 
  IN const PSTR  pjString, 
  IN       FLONG fl);

VOID vDbg_PrintSURFACE(
  IN       FLONG flDbgLvl, 
  IN const PSTR  pjString, 
  IN const struct _SURFACE *pSurface);

#if 0 // ELSA-FNicklis 25.04.00: unused
VOID vDbgFIFO(PPDEV ppdev, ULONG ulDbgLevel);
#define DBG_FIFO vDbgFIFO
#endif // ELSA-FNicklis 25.04.00: unused

// Not supported yet, disabled for debug and free!
#define vDbg_PrintGDIINFO(flDbgLvl, pgdiinfo)
#define vDbg_PrintDD_HALINFO(flDbgLvl,pcString,phalinfo)
#define vDbg_PrintSPS_FLAGS(flDbgLvl,ulSPS_FLAGS)
#define vDbg_PrintSPS_RETURNS(flDbgLvl,ulSPS_FLAGS)


typedef struct _DBG_NAMEINDEX
{
  ULONG ulIndex;
  char *szName;
} DBG_NAMEINDEX;

#define DBG_MAKE_NAMEINDEX(id) {(ULONG)id, #id}
char *szDbg_GetDBG_NAMEINDEX(IN const struct _DBG_NAMEINDEX *pNameIndex, IN LONG lEntries, IN ULONG ulIndex);
#define DBG_GETDBG_NAMEINDEX(array, ulIndex) szDbg_GetDBG_NAMEINDEX((array), sizeof(array)/sizeof((array)[0]), ulIndex)
VOID vDbg_PrintflCapabilities(
  FLONG flDbgFlags, 
  const PCHAR pcString, 
  char *(szFlCaps)(ULONG),  // function pointer to stringizer function (szDbg_GetFL_2DCAPSName)
  FLONG flPrint);

#define szBOOL(expression) ( (expression) ? "TRUE" : "FALSE" )

// If we are not in a debug environment, we want all of the debug
// information to be stripped out.

/* ********************************************************************** */
/* ********************************************************************** */
/* ********************************************************************** */

#else
/* ********************************************************************** */
/* ********************************************************************** */
/* ********************************************************************** */

#define DBGBREAK()
#define EngDebugBreak()
#define DISPDBG(arg)
#define DISPDBGCOND(cond,arg)
#define STATEDBG(level)
#define LOGDBG(arg)
#define RIP(x)
#define RIP_IA64(x)
#define ASSERTDD(condition,text)
#define ASSERT(condition)
#define DBG_CURRENTPOSITION 

#define DBGFLAGSSET(drventry,dbgflags)
#define DBGFLAGSNEW(dbgflags)
#define DBGFLAGSOLD()                 

#define pszDbg_GetFLOH(floh)

#define vDbg_PrintPOINTL(flFlags,pcString,pptl)
#define vDbg_PrintRECTL(flFlags,pcString,prcl)
#define vDbg_PrintRECTLArray(flFlags,pcString,prcl,c)
#define vDbg_PrintSIZEL(flFlags,pcString,psiz)

#define vDbg_PrintCLIPOBJ(flFlags,pcString,pco)
#define vDbg_PrintCLIPOBJiDComplexity(flFlags,iDComplexity)
#define vDbg_PrintCLIPOBJiFComplexity(flFlags,iFComplexity)

#define vDbg_PrintXLATEOBJ(flFlags,pcString,pxlo)
#define vDbg_PrintXLATEOBJiType(flFlags,iType)
#define vDbg_PrintXLATEOBJflXlate(flFlags,flXlate)

#define vDbg_PrintSURFOBJ(flFlags,pcString,pso)
#define vDbg_PrintSURFOBJiType(flFlags,iType)
#define vDbg_PrintSURFOBJiBitmapFormat(flFlags,iBitmapFormat)
#define szDbg_GetEscapeName(ulEsc)
#define szDbg_GetETSubEscName(SubEscNr)

#define DBG_TRACE_IN(flDbgFlags,function)
#define DBG_TRACE_OUT(flDbgFlags,retVal)
#define DBG_TRACE_DUMP(ulDbgLvl)
#define DBG_ERROR(szText)
#define DBG_WARNING(szText)
#define DBG_TEST(szText)
#define DBG_PRINTX(flDbgFlags,variable)
#define DBG_PRINTD(flDbgFlags,variable)
#define DBG_PRINTS(flDbgFlags,variable)
#define DBG_PRINTB(flDbgFlags,variable)

#define DBG_TESTX(variable)
#define DBG_TESTD(variable)
#define DBG_TESTS(variable)
#define DBG_TESTB(variable)

#define bDbg_CheckHeapNode(pHeap,pNode,flCheck)
#define vDbg_CheckHeapIntegrity(flDbgLvl, szText, pHeap)
#define vDbg_Print_memory_t(flDbgLvl, szText, pHeap)
#define szDbg_GetET_VALUE_IDName(dwID)

#define vDbg_Printfl2DCapabilities(flDbgLvl,szText,ppdev)
#define vDbg_PrintET_VERSION(flDbgLvl,szText,pVersion)
#define vDbg_PrintET_VERSION_INFO(flDbgLvl,szText,pVersionInfo)
#define szDbg_GetExceptionCode(dwID)
#define PBB_DBG(arg)
#define PCB_DBG(arg)
#define szDbg_GetET_SET_VALUE_RETdwFlags(dwFlags)
#define szDbg_GetESC_RETURN(lRet)
#define vDbg_PrintET_VALUE_RETdwFlags(flDbgLvl,pcString,dwFlags)
#define vDbg_PrintflCaps(flDbgFlags,pcString,ppdev)
#define vDbg_PrintBRUSHOBJ(flDbgFlags,pcString,pbo)
#define vDbg_PrintExportedFunctions(flDbgLvl,pcString,ded)
#define vDbg_PrintFunctionTable(flDbgLvl, pcString, papfn)
#define vDbg_PrintBlitDirectionTable(flDbgLvl, ppdev)
#define vDbg_PrintPATHOBJ(flDebugFlags,pcString,ppo)

#define vDbg_PrintET_QUERY(flDebugFlags,pcString,petQuery)
#define vDbg_PrintET_WINMAN2_DATA_GET(flDebugFlags,pcString,pWINmanDataGet)
#define vDbg_PrintET_WINMAN2_DATA_SET(flDebugFlags,pcString,pWINmanDataSet)
#define vDbg_PrintET_WINMAN2_DATA_BRD_R(flDebugFlags,pcString,pWINmanDataBrd)
#define vDbg_PrintET_WINMAN2_DATA_BRD_RW(flDebugFlags,pcString,pWINmanDataBrdRW)
#define szDbg_GetWINMAN_SETName(fl)
#define szDbg_GetWINMAN_RESULTName(fl)
#define vDbg_PrintflWINMAN_MOD(flDbgFlags,pcString,dwDrvModFlags)
#define vDbg_PrintVIDEO_MODE_INFORMATION(flDebugFlags,pcString,pVideoModeInformation)
#define szDbg_GetREG_RETURN(lRet)
#define vDbg_PrintDEVMODEW(flDebugFlags,pcString,pDevMode)
#define szDbg_GetDrvINDEX(ulIndex)
#define vDbg_PrintET_VALUE_DWORD(flDebugFlags,pcString,petDWord)
#define vDbg_PrintET_VALUE_STRING(flDebugFlags,pcString,petString)

#define vDbg_PrintSURFACE_flType(flDbgLvl, pjString, fl)
#define vDbg_PrintSURFACE(flDbgLvl, pjString, pSurface)


// Not supported yet, disabled for debug and free!
#define vDbg_PrintGDIINFO(flDbgLvl, pgdiinfo)
#define vDbg_PrintDD_HALINFO(flDbgLvl,pcString,phalinfo)
#define vDbg_PrintSPS_FLAGS(flDbgLvl,ulSPS_FLAGS)
#define vDbg_PrintSPS_RETURNS(flDbgLvl,ulSPS_FLAGS)
#define DBG_FIFO(ppdev, ulDbgLevel) 

#define vDbg_PrintFL_PUNT_Flags(flDbgLvl, pjString, flFlags)
#define bDbg_VerifySURFOBJ(pso)

#endif // DBG

#endif // USE_WKS_ELSA_TOOLS
#endif // _WKSELSATOOLSDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolstoolbox.c ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolstoolbox.c
//
// Toolbox with helper functions
//
// FNicklisch 09/14/2000: New, derived from toolbox.c
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

// import header files
#include "precomp.h"
#include "excpt.h"
#ifdef USE_WKS_ELSA_TOOLS
#include "wkselsatoolsdebug.h"

// export header file
#include "wkselsatoolstoolbox.h"

// for shared memory issues we need some page aligned memory tiles
// to describe these, use the ALIGN_DESC struct AND the corresponding
// bAllocMemPageAligned and bFreeMemPageAligned routines in toolbox.c

// struct to describe an aligned pointer

typedef struct _ALIGN_DESC
{
  ULONG ulMagic;
  ULONG ulSizeTotal;          // size of the total allocated size
  ULONG ulSizeAligned;        // size of the aligned potrion of the mem chunk
  PVOID pvAligned;            // has to be the 2nd last element
  PVOID pvAnchor;             // has to be the last element
}
ALIGN_DESC;

//******************************Public*Data*********************************\
// MIX translation table
//
// Translates a mix 1-16, into an old style Rop 0-255.
//
//**************************************************************************/
// 220998 MSchwarz moved it here
BYTE ajMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = ajMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = ajMix[mix & 0xFF]
};

#if 0 // FNicklisch 14.09.00: unused
#ifdef _C_TOOLBOX_H

// enable  c_Toolbox.c
#define THIS_IS_A_VALID_TOOLBOX_C_FILE

//
// FNicklis 29.10.98:
//
// It seems to be a little bit strange, but I want to reuse the
// same code shared with the miniport.
//
#include "c_ToolBox.c"

// disable c_Toolbox.c
#undef THIS_IS_A_VALID_TOOLBOX_C_FILE
#endif //_C_TOOLBOX_H
#endif // FNicklisch 14.09.00: unused

#ifdef DBG
LONG lDbgAllocCount=0;
#endif

/*
** bAllocMem
** bFreeMem
**
** Wrapper functions to allocate and free memory where NTDDK.h 
** cannot be included
**
** Needs a pointer to a pointer to the buffer to be allocated, in both cases
**
** return: TRUE  success
**         FALSE error, bjBuffer isn't touched! Don't check for NULL then!
**
** Usage:
**   ...
**   BYTE *pjBuffer;
**
**   if ( !bAllocMem(&pjBuffer, ulSize) )
**   {
**     //  error: malloc failed!
**   }
**   else
**   {
**     // alloc succeded, do the work
**     ...
**     // free buffer again
**     bFreeMem(&pjBuffer);
**   }
**
** FNicklis 23.10.98: New
*/
// Own version!

BOOL bAllocMem(PVOID *ppBuffer, ULONG nByte, ULONG ulTag)
{
  BOOL  bRet = TRUE;
  PVOID pTemp;

  DBG_TRACE_IN(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bAllocMem);

  ASSERTDD(NULL!=ppBuffer,  "you should not call this function with invalid pointer!");
  ASSERTDD(0!=nByte,        "you should not call this function if you don't need memory!");
  ASSERTDD(0!=ulTag,        "please give me a valid ulTag, or ALLOC_TAG as default!");

  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " *ppBuffer:0x%x, nByte:%d, ulTag:0x%x",*ppBuffer,nByte,ulTag));

  pTemp = EngAllocMem(FL_ZERO_MEMORY, nByte, ulTag);

  // on error don't touch input value
  if (NULL==pTemp)
  {
    DBG_ERROR("EngAllocMem failed");
    DISPDBG((DBG_LVL_ERROR, "  didn't get %d byte, ulTag:0x%x",nByte, ulTag));
    bRet = FALSE;
    goto Exit;
  }

  #ifdef DBG
  ASSERTDD(0==((ULONG_PTR)pTemp & 3), "We need a DWORD aligned pointer!");
  lDbgAllocCount++;
  #endif

  // here is your buffer
  *ppBuffer = pTemp;

Exit:
  DBG_TRACE_OUT(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bRet);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " (*ppBuffer:0x%x)",*ppBuffer));
  return TRUE;
}

#ifdef DBG
BOOL bFreeMem(PVOID *ppBuffer, ULONG nDebugOnlyByteToClear)
#else
BOOL _bFreeMem(PVOID *ppBuffer)
#endif
{
  BOOL bRet=TRUE;

  DBG_TRACE_IN(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bFreeMem);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " *ppBuffer:0x%x, nDebugOnlyByteToClear:%d",*ppBuffer, nDebugOnlyByteToClear));

  ASSERTDD(NULL!=ppBuffer,  "you should not call this function with invalid pointer!");
  ASSERTDD(NULL!=*ppBuffer, "you should not call this function without alloctated memory!");

#ifdef DBG
  if (nDebugOnlyByteToClear)
  {
    memset(*ppBuffer, 0xCD, nDebugOnlyByteToClear);
    //RtlZeroMemory(*ppBuffer, nByteToClear);
    lDbgAllocCount--;
  }
  ASSERTDD(lDbgAllocCount>=0, "freed mored memory than allocated");
#endif

  // free and invalidate buffer
  EngFreeMem(*ppBuffer);
  *ppBuffer = NULL;

  DBG_TRACE_OUT(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bRet);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " (*ppBuffer:0x%x)",*ppBuffer));
  return (bRet);
}


/*
**  bAllocMemPageAligned allocates memory that begins at the start of a page 
**
**  ALIGN_DESC is the describer sturct
**  What it does:
**  - places a memory ALIGN_DESC in the gap between the aligned pointer and
**    the start of allocated memory
**  - to ensure that there is enough space to hold ALIGN_DESC it adds the size of 
**    ALIGN_DESC to the size of memory to allocate
**  - it adds one more mem page to the size to allocate cause at least W2K
**    never gives us page aligned memory and we have to use the succeeding page
**  - it allocates the chunk of memory (to get the anchor pointer)
**  - it increments this (anchor) by the size of ALIGN_DESC
**    and rounds the resulting pointer up to the begin of the next page (so we ensure that
**    there will be enough space for ALIGN_DESC) and get the aligned pointer (the result)
**  - it places the ALIGN_DESC directly before the alinged pointer so that we can
**    access it just by subtracting sizeof(ALIGN_DESC) from the align pointer
**  - it fills the ALIGN_DESC with a magic, the anchor and aligned pointer
**    and the total and aligned size
**  - it returns only the align pointer !!!
**
**  Author: Dietmar Bouge' @ ELSA AG 
**  Date  : 12.08.1999
*/

#if 0 // ELSA-FNicklis 04.07.00: unused
BOOL bAllocMemPageAligned(IN OUT PVOID     *ppvAlign, 
                          IN     ULONG      ulSize,   // size to allocate
                          IN     ULONG      ulTag)    // memory tag
{
  BOOL  bRet = TRUE;
  ALIGN_DESC *pAlignDesc;
  ULONG ulSizeTotal;
  BYTE  *pjAnchor;      // prefere BYTE type for arithmetic
  BYTE  *pjAligned;     // prefere BYTE type for arithmetic

  DBG_TRACE_IN(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bAllocMemPageAligned);
  ASSERTDD(ppvAlign != NULL, "");
  ASSERTDD(ulSize > 0, "");

  // space for the memory and our admin struct
  ulSizeTotal   = ROUND_TO_PAGES(ulSize + sizeof(ALIGN_DESC));

  // NOTE: on W2K after Beta 3 EngAllocMem returns pointers starting
  //       with an offset of 0x10, so we don't get page aligned memory
  //       just by allocating more than a page!!!
  // 
  ulSizeTotal   += PAGE_SIZE;

  pjAnchor    = (BYTE *)EngAllocMem(FL_ZERO_MEMORY, ulSizeTotal, ulTag);

  // calculate the closest possible pjAligned
  pjAligned   = pjAnchor + sizeof(ALIGN_DESC);

  // advance to next page aligned spot
  pjAligned   = (BYTE *)ROUND_TO_PAGES(pjAligned);

  // calc pAlignPtr so that pAlignPtr->pvAnchor is to be found directly before pjAligned 
  // -> &pAlignPtr->pvAnchor == (pjAligned - sizeof(PVOID))
  pAlignDesc  = (ALIGN_DESC *)(pjAligned - sizeof(ALIGN_DESC));
  ASSERTDD( (VOID *)(pjAligned - sizeof(PVOID)) == &pAlignDesc->pvAnchor, "");
  ASSERTDD((BYTE *)pAlignDesc >= pjAnchor, "");

  // FNicklis IA-64: Use macro for page size
  ASSERT(0 == (PtrToUlong(pjAligned) & PAGE_MASK));

  // on error don't touch input value
  if (NULL == pjAnchor)
  {
    DBG_ERROR("bAllocMemPageAligned failed");
    DISPDBG((DBG_LVL_ERROR, "  didn't get %d bytes, ulTag:0x%x",ulSize, ulTag));
    bRet = FALSE;
  }
  else
  {
#ifdef DBG
    lDbgAllocCount++;
#endif
    pAlignDesc->ulMagic        = 'ELSA';
    pAlignDesc->pvAnchor       = pjAnchor;
    pAlignDesc->pvAligned      = pjAligned;
    pAlignDesc->ulSizeTotal    = ulSizeTotal;
    pAlignDesc->ulSizeAligned  = ulSize;
  }
  *ppvAlign = pjAligned;

  DBG_TRACE_OUT(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bRet);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " *ppvAlign:0x%x",*ppvAlign));
  return bRet;
}


/*
** bFreeMemPageAligned frees page aligned memory chunks
**
**  ALIGN_DESC is the describer sturct
**  What it does:
**  - in debug builds it checks whether this pointer is valid by checking the alignment
**  - it decrements the incoming pointer by size of  ALIGN_DEST to get a pointer to the
**    ALIGN_DEST
**  - in debug builds it zeros the whole chunk of mem to avoid later use of invalid data
**  - it frees the memory using the anchor
**  - it zeros the incoming pointer
**
**  Author: Dietmar Bouge' @ ELSA AG 
**  Date  : 12.08.1999
*/ 
BOOL bFreeMemPageAligned(IN OUT PVOID     *ppvAlign) 
{
  BOOL  bRet = TRUE;
  ALIGN_DESC *pAlignDesc;
  BYTE *pjAnchor;
  ULONG ulSizeTotal;

  DBG_TRACE_IN(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bFreeMemPageAligned);
  ASSERTDD(ppvAlign != NULL, "");

  // incoming pointers have to be page aligned here
  // FNicklis IA-64: Use macro for page size
  ASSERT(0 == (PtrToUlong((BYTE *)(*ppvAlign)) & PAGE_MASK));

  pAlignDesc = (ALIGN_DESC *)(((BYTE *)(*ppvAlign)) - sizeof(ALIGN_DESC));
  ASSERTDD(pAlignDesc->ulMagic == 'ELSA', "");
  ASSERTDD(pAlignDesc->pvAligned == (*ppvAlign), "");

  pjAnchor = (BYTE *)(pAlignDesc->pvAnchor);
  ulSizeTotal = pAlignDesc->ulSizeTotal;


#ifdef DBG
  // zero out struct to avoid use of invalid data
  RtlZeroMemory(pjAnchor, ulSizeTotal);
#endif

  EngFreeMem(pjAnchor);

  // zero out struct to avoid use of invalid data
  *ppvAlign = NULL;

  DBG_TRACE_OUT(DBG_LVL_FLOW2|DBG_LVL_NOLINEFEED, bRet);
  DISPDBG((DBG_LVL_FLOW2|DBG_LVL_NOPREFIX, " *ppvAlign:0x%x",*ppvAlign));
  return bRet;
}
#endif // ELSA-FNicklis 04.07.00: unused



//
// CSchalle 30.10.98: helper routine - (disassembled NT 4.0 user mode function)
//
#if !i386 || _WIN32_WINNT >= 0x0500
typedef HANDLE (*P_PS_GET_CURRENT_PROCESS_ID)(void);
#endif

#pragma warning(disable: 4035)  // no return value
DWORD GetCurrentProcessID(VOID)
{
  #if i386 && _WIN32_WINNT >= 0x0400
  __asm
  {
    mov eax, fs:[0x18]
    mov eax, [eax + 0x20] // return value in eax
  }
  #else
  HANDLE hPID = NULL;
  HANDLE hDLL;

  hDLL = EngLoadImage(L"NTOSKRNL.EXE");
  if (hDLL)
  {
    P_PS_GET_CURRENT_PROCESS_ID pfPsGetCurrentProcessId;

    pfPsGetCurrentProcessId = (P_PS_GET_CURRENT_PROCESS_ID)EngFindImageProcAddress(hDLL, "PsGetCurrentProcessId");
    if (pfPsGetCurrentProcessId)
    {
      // does NOT work in FREE mode
      hPID = pfPsGetCurrentProcessId();
    }
    EngUnloadImage(hDLL);
  }
  return (DWORD)hPID;
  #endif

}
#pragma warning(default: 4035)  // no return value


/*
** szGetApplicationName
**
** Returns the name of the current process calling the driver
** or NULL, if not available.
** For now only in Debug mode, only on NT 4.0, only on I386
**
** 160797 KGysbers, FNicklis
*/
CHAR *szGetApplicationName(VOID)
{
  CHAR *szRet="unknown"; // default error exit

#if defined (i386)

  // Ask KGysbers for more information about the following asm code
  __asm 
  {
    mov eax,fs:[124h]
    mov eax,[eax+44h]
    add eax,1dch
    mov szRet,eax
  }

  __try 
  { // to read each byte of the string
    CHAR cDummy;
    CHAR *szHlp = szRet; // Don't destroy the original pointer

    while (*szHlp) 
    {
      cDummy = *szHlp++; // Access all bytes until we find a EOS
    }
  }
  __except(EXCEPTION_EXECUTE_HANDLER)
  {
    // We failed, be sure there is a save exit
    DISPDBG((DBG_LVL_ERROR, "ERROR in szGetApplicationName: Exception failed with: %s",szDbg_GetExceptionCode(GetExceptionCode()) ));
    
    szRet="unknown"; // default error exit
  } 
#else
  // FNicklis IA-64: Cannot use IA-32 assembler on IA-64
  // FNicklis IA-64: ToDo - portation not complete!
  #pragma message ("  FNicklis IA-64: ToDo: szGetApplicationName "__FILE__)
  DISPDBG((DBG_LVL_IA64, "FNicklis IA-64: ToDo: szGetApplicationName %s %d",__FILE__,__LINE__));
#endif // (i386)

  // make sure, that we return a vailid pointer here!
  ASSERT(NULL!=szRet);
  ASSERT(strlen(szRet)<MAX_PATH);

  return szRet;
} // szGetApplicationName


#if 0 // FNicklisch 14.09.00: unused
ULONG ulLog2(ULONG ulValue)
{
  #if defined (i386)
    __asm 
    {
      mov ecx, [ulValue]
      bsf eax, ecx
    }
  #else
    int d = 1, iter = -1;
    do 
    {
      d *= 2;
      iter++;
    } 
    while (d <= ulValue);
    return iter;
  #endif
  // return value in eax
}
#endif // FNicklisch 14.09.00: unused

/*
** STRING FUNCTIONS
**
** The following routines are an extension or an alternate 
** inteface to the runtime library functions (Rtl*) to handle
** string, here at first of type UNICODE_STRING.
** 
** The name of each function is build using the scheme (without the blanks):
**
** E_ DestType Function [SrcType]
**
** with
** 
** DestTypes/SrcTypes:
**  UStr - UNICODE_STRING, each character of size WCHAR
**  WStr - WSTR, zero terminated string, each character of size WCHAR
**  AStr - ANSI_STRING same as STRING, each character of size CHAR
**  Str  - STR, zero terminated string, each character of size CHAR
**
** Function:
**  Len      - Returns Length in bytes 
**  TrueLen  - Returns Length in bytes including trailing 0
**  Init     - Initializes the string which includes memory allocation
**  InitMulti- Initializes the string which includes memory allocation and presetting
**  Free     - Frees the allocated mem and initializes all members to 0
**  Cat      - Concatenates a string and someting else (String, value...)
**
** All with strings handled here are delimited wihtin here with the 
** trailing zero.
**
** FN 21.01.97 New
*/

// Len returnes lenght in bytes (not including trailing zero)

ULONG ulStrLen(IN PSTR pString)
{
  PCHAR pTemp=pString;
  
  if (pTemp)
    while (*pTemp) 
      pTemp++;

  // FNicklis IA-64: Usage of 32 bit is save here
  return ((ULONG)(pTemp-pString));
}

ULONG ulWStrLen(IN PWSTR pString)
{
  PWCHAR pTemp=pString;
  
  if (pTemp)
    while (*pTemp) 
      pTemp++;

  // FNicklis IA-64: Usage of 32 bit is save here
  return ((ULONG)(pTemp-pString));
}

// TrueLen returnes lenght in bytes used by characters and trailing zero

ULONG ulStrTrueLen(IN PSTR pString)
{
  ULONG ulRet=ulStrLen(pString);

  if(ulRet)
    return (ulRet+1);
  else
    return (0);
}

ULONG ulWStrTrueLen(IN PWSTR pString)
{
  ULONG ulRet=ulWStrLen(pString);

  if(ulRet)
    return (ulRet+1);
  else
    return (0);
}


PSTR szStrCpy(OUT PSTR szTrg, IN const PSTR szSrc)
{
  RtlMoveMemory(szTrg, szSrc, ulStrTrueLen(szSrc)*sizeof(CHAR));
  return (szTrg);
}

PSTR szStrCat(OUT PSTR szTrg, IN const PSTR szSrc)
{
  return (szStrCpy(szTrg+ulStrLen(szTrg), szSrc));
}

PSTR szStrCpyWStr (OUT PSTR szTrg, IN const PWSTR wszSrc)
{
  PSTR  szRet  = szTrg;

  ASSERTDD(NULL != szTrg, "szStrCpyWStr");
  ASSERTDD(NULL != wszSrc,"szStrCpyWStr");

  if (szTrg && wszSrc) 
  {
    PWSTR wszRun = (PWSTR)wszSrc;
    while (*wszRun) 
    {
      *szTrg++ = (CHAR)(*wszRun++ & 0xff);
      ASSERTDD((szTrg-szRet)<2000, "running out of assumed limit of 2000 chars");
    }
    *szTrg = 0;
  }
  
  return szRet;
}

PSTR szStrCatWStr (OUT PSTR szTrg, IN const PWSTR wszSrc)
{
  return (szStrCpyWStr(szTrg+ulStrLen(szTrg), wszSrc));
}


PWSTR wszWStrCpy    (OUT PWSTR wszTrg, IN const PWSTR wszSrc)
{
  RtlMoveMemory(wszTrg, wszSrc, ulWStrTrueLen(wszSrc)*sizeof(WCHAR));
  return (wszTrg);
}

PWSTR wszWStrCat    (OUT PWSTR wszTrg, IN const PWSTR wszSrc)
{
  return (wszWStrCpy(wszTrg+ulWStrLen(wszTrg), wszSrc));
}

PWSTR wszWStrCpyStr (OUT PWSTR wszTrg, IN const PSTR  szSrc)
{
  PWSTR wszRet = wszTrg;

  ASSERTDD(NULL != wszTrg,"wszWStrCpyStr");
  ASSERTDD(NULL != szSrc,"wszWStrCpyStr");

  if (wszTrg && szSrc) 
  {
    PSTR szRun = (PSTR)szSrc;
    while (*szRun) 
    {
      *wszTrg++ = (WCHAR)(*szRun++ & 0xff);
      ASSERTDD((wszTrg-wszRet)<2000, "running out of assumed limit of 2000 chars");
    }
    *wszTrg = 0;
  }
  
  return wszRet;
}

PWSTR wszWStrCatStr(OUT PWSTR wszTrg, IN const PSTR  szSrc)
{
  return (wszWStrCpyStr(wszTrg+ulWStrLen(wszTrg), szSrc));
}

#if DBG
#ifndef BOOL
#define BOOL int
#endif

VOID vDbg_Check_c_ToolBox(VOID)
{
  static BOOL bFirstRun=TRUE;

  if (bFirstRun)
  {
    CHAR   sz[30];
    USHORT wsz[30];
    USHORT wsz2[30];
    
    bFirstRun=FALSE;

    // CHAR

    // staring with "012" == 3 chars
    szStrCpy(sz, "012");
    ASSERTDD(sz[0]=='0' && sz[1]=='1' && sz[2]=='2' && sz[3]=='\0', "szStrCpy not working");
    ASSERTDD(ulStrLen(sz)==3,     "ulStrLen not working");
    ASSERTDD(ulStrTrueLen(sz)==4, "ulStrTrueLen not working");

    // adding "345" -> "012345" == 6 chars
    szStrCat(sz, "345");
    ASSERTDD(sz[0]=='0' && sz[1]=='1' && sz[2]=='2' && sz[3]=='3' && sz[4]=='4' && sz[5]=='5' && sz[6]=='\0', "szStrCat not working");
    ASSERTDD(ulStrLen(sz)==6,     "ulStrLen after szStrCat not working");

    // WCHAR
    // staring with "ABC" == 3 chars
    wszWStrCpy(wsz, (const PWSTR)L"ABC");
    ASSERTDD(wsz[0]=='A' && wsz[1]=='B' && wsz[2]=='C' && wsz[3]=='\0', "wszWStrCpy not working");
    ASSERTDD(ulWStrLen(wsz)==3,     "ulWStrLen not working");
    ASSERTDD(ulWStrTrueLen(wsz)==4, "ulWStrTrueLen not working");

    // adding "DEF" -> "ABCDEF" == 6 chars
    wszWStrCat(wsz, (const PWSTR)L"DEF");
    ASSERTDD(wsz[0]=='A' && wsz[1]=='B' && wsz[2]=='C' && wsz[3]=='D' && wsz[4]=='E' && wsz[5]=='F' && wsz[6]=='\0', "wszWStrCat not working");
    ASSERTDD(ulWStrLen(wsz)==6,     "ulWStrLen after wszWStrCat not working");

    wszWStrCpy(wsz2, wsz);

    // WCHAR -> CHAR

    // staring with L"012" == 3 chars
    szStrCpyWStr(sz, (const PWSTR)L"012");
    ASSERTDD(sz[0]=='0' && sz[1]=='1' && sz[2]=='2' && sz[3]=='\0', "szStrCpyWStr not working");
    ASSERTDD(ulStrLen(sz)==3,     "ulStrLen after szStrCpyWStr not working");
    ASSERTDD(ulStrTrueLen(sz)==4, "ulStrTrueLen after szStrCpyWStr not working");

    // adding L"345" -> "012345" == 6 chars
    szStrCatWStr(sz, (const PWSTR)L"345");
    ASSERTDD(sz[0]=='0' && sz[1]=='1' && sz[2]=='2' && sz[3]=='3' && sz[4]=='4' && sz[5]=='5' && sz[6]=='\0', "szStrCatWStr not working");
    ASSERTDD(ulStrLen(sz)==6,     "ulStrLen after szStrCatWStr not working");

    // CHAR -> WCHAR
    // staring with "ABC" == 3 chars
    wszWStrCpyStr(wsz, "abc");
    ASSERTDD(wsz[0]=='a' && wsz[1]=='b' && wsz[2]=='c' && wsz[3]=='\0', "wszWStrCpyStr not working");
    ASSERTDD(ulWStrLen(wsz)==3,     "ulWStrLen after wszWStrCpyStr not working");
    ASSERTDD(ulWStrTrueLen(wsz)==4, "ulWStrTrueLen after wszWStrCpyStr not working");

    // adding "def" -> "abcdef" == 6 chars
    wszWStrCatStr(wsz, "def");
    ASSERTDD(wsz[0]=='a' && wsz[1]=='b' && wsz[2]=='c' && wsz[3]=='d' && wsz[4]=='e' && wsz[5]=='f' && wsz[6]=='\0', "wszWStrCatStr not working");
    ASSERTDD(ulWStrLen(wsz)==6,     "ulWStrLen after wszWStrCatStr not working");

    // WCHAR -> CHAR
    // adding L"abcdef" to "012345" -> "012345abcdef"
    szStrCatWStr(sz, wsz);
    ASSERTDD(ulStrLen(sz)==12,      "ulStrLen not working, final test");

    // WCHAR -> CHAR
    // adding "012345abcdef" to l"abcdef" -> l"abcdef012345abcdef"
    wszWStrCatStr(wsz, sz);
    ASSERTDD(ulWStrLen(wsz)==18,         "ulWStrLen not working, final test");
    ASSERTDD(ulWStrTrueLen(wsz)==19,     "ulWStrTrueLen not working, final test");

    ASSERTDD(wsz[ 0]=='a' && wsz[ 1]=='b' && wsz[ 2]=='c' && wsz[ 3]=='d' && wsz[ 4]=='e' && wsz[ 5]=='f', "wszWStrCatStr not working");
    ASSERTDD(wsz[ 6]=='0' && wsz[ 7]=='1' && wsz[ 8]=='2' && wsz[ 9]=='3' && wsz[10]=='4' && wsz[11]=='5', "wszWStrCatStr not working");
    ASSERTDD(wsz[12]=='a' && wsz[13]=='b' && wsz[14]=='c' && wsz[15]=='d' && wsz[16]=='e' && wsz[17]=='f', "wszWStrCatStr not working");

  }
}
#endif


#endif //USE_WKS_ELSA_TOOLS
// End of wkselsatoolstoolbox.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv3cur.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV3CUR.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the hardware cursor
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        .list

        .data

;**********************************************************************
; Tables are used to convert MONO mask. Ones convert to 7fffh and zeros to 0
; The AND mask is used to add transparency bit. Zero in AND mask converts
; to 8000h, 1 to zero.
;**********************************************************************


MonoTable   dd  0                       ; MONO 00 
            dd  7fff0000h               ; MONO 01 (bits need to be transposed)
            dd  00007fffh               ; MONO 10 (bits need to be transposed)
            dd  7fff7fffh               ; MONO 11
            
AndTable    dd  80008000h               ; MONO 00
            dd  00008000h               ; MONO 01 (bits need to be transposed)
            dd  80000000h               ; MONO 10 (bits need to be transposed)
            dd  0                       ; MONO 11

;
;  stack based params and local variables
;

NV3_LOAD_CURSOR_DATA_STRUC          struc

; Feel free to add any local variables here:

NV3LCD_Row_Count            dd      ?
NV3LCD_Byte_Count           dd      ?

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV3LCD_ebp                  dd      ?
NV3LCD_esi                  dd      ?
NV3LCD_edi                  dd      ?
NV3LCD_ebx                  dd      ?
NV3LCD_RetAddr              dd      ?
NV3LCD_SrcPtr               dd      ?
NV3LCD_DestPtr              dd      ?

NV3_LOAD_CURSOR_DATA_STRUC          ends

NV3_LOAD_CURSOR_DATA_PARM_SIZE     equ     7 * 4

; --------

NV3_CURSOR_CHECKSUM_STRUC          struc

; Feel free to add any local variables here:

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV3CHK_ebx                  dd      ?
NV3CHK_ebp                  dd      ?
NV3CHK_esi                  dd      ?
NV3CHK_RetAddr              dd      ?
NV3CHK_SrcPtr               dd      ?

NV3_CURSOR_CHECKSUM_STRUC          ends

NV3_CURSOR_CHECKSUM_PARM_SIZE     equ     5 * 4



;*******************************************************************************
; Defines for NV Hardware
; Currently, channels are used as follows:
;   IMAGE_FROM_CPU          Channel 0
;   BLIT                    Channel 1
;   IMAGE_MONO_FROM_CPU     Channel 2
;   RECTANGLE               Channel 3
;   ROP_SOLID               Channel 4
;   IMAGE_PATTERN           Channel 5
;   CLIP                    Channel 6
;   IMAGE_SOLID             Channel 7      
;*******************************************************************************

IMAGE_FROM_CPU_FREECOUNT           equ    ( (0*8192) + 16 )
BLIT_FREECOUNT                     equ    ( (1*8192) + 16 )
IMAGE_MONO_FROM_CPU_FREECOUNT      equ    ( (2*8192) + 16 )
RECTANGLE_FREECOUNT                equ    ( (3*8192) + 16 )
ROP_SOLID_FREECOUNT                equ    ( (4*8192) + 16 )
IMAGE_PATTERN_FREECOUNT            equ    ( (5*8192) + 16 )
CLIP_FREECOUNT                     equ    ( (6*8192) + 16 )
IMAGE_SOLID_FREECOUNT              equ    ( (7*8192) + 16 )


IMAGE_MONO_FROM_CPU_MONODATA_0      equ    ( (2*8192) + 400h )
IMAGE_MONO_FROM_CPU_MONODATA_1      equ    ( (2*8192) + 404h )
IMAGE_MONO_FROM_CPU_MONODATA_2      equ    ( (2*8192) + 408h )
IMAGE_MONO_FROM_CPU_MONODATA_3      equ    ( (2*8192) + 40ch )
IMAGE_MONO_FROM_CPU_MONODATA_4      equ    ( (2*8192) + 410h )
IMAGE_MONO_FROM_CPU_MONODATA_5      equ    ( (2*8192) + 414h )
IMAGE_MONO_FROM_CPU_MONODATA_6      equ    ( (2*8192) + 418h )
IMAGE_MONO_FROM_CPU_MONODATA_7      equ    ( (2*8192) + 41ch )
IMAGE_MONO_FROM_CPU_MONODATA_8      equ    ( (2*8192) + 420h )
IMAGE_MONO_FROM_CPU_MONODATA_9      equ    ( (2*8192) + 424h )
IMAGE_MONO_FROM_CPU_MONODATA_10     equ    ( (2*8192) + 428h )
IMAGE_MONO_FROM_CPU_MONODATA_11     equ    ( (2*8192) + 42ch )
IMAGE_MONO_FROM_CPU_MONODATA_12     equ    ( (2*8192) + 430h )
IMAGE_MONO_FROM_CPU_MONODATA_13     equ    ( (2*8192) + 434h )
IMAGE_MONO_FROM_CPU_MONODATA_14     equ    ( (2*8192) + 438h )
IMAGE_MONO_FROM_CPU_MONODATA_15     equ    ( (2*8192) + 43ch )

        .code

;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV3LoadCursorData@8
        
NV3LoadCursorData@8 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV3_LOAD_CURSOR_DATA_STRUC) - NV3_LOAD_CURSOR_DATA_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   eax = Current 16bpp pel
        ;   edx = BitMask
        ;   ebx = Current dword from AND mask
        ;   ecx = Current dword from MONO mask
        ;   esi = Ptr to Source Image data
        ;   ebp = Ptr to Mono Image data        
        ;   edi = Ptr to Destination Data
        ;**********************************************************************
    
        mov     esi,[esp].NV3LCD_SrcPtr             ; Ptr to AND mask
        mov     ebp,esi                             ; Get ptr to MONO mask
        add     ebp,128                             ;  (128 bytes from beginning)
        mov     edi,[esp].NV3LCD_DestPtr            ; Ptr to current destination

        ;**********************************************************************
        ; 
        ; For Each row
        ;   For Each Dword
        ;      For Each Bit   
        ;        Store 16bpp pel corresponding to the bits in
        ;        the AND mask and MONO mask
        ;
        ;**********************************************************************

NV3LCD_Init_Variables:

        mov     [esp].NV3LCD_Row_Count,32           ; We'll be parsing 32 rows
        xor     edx,edx

NV3LCD_Get_Next_Dword:
        mov     [esp].NV3LCD_Byte_Count,4           ; 8 pels (4 inner loops) per byte
        mov     ebx,[esi]                           ; Get 1st dword of AND mask data
        mov     ecx,[ebp]                           ; Get 1st dword of MONO mask data
        
        ;**********************************************************************
        ; Load 16bpp pels - uses tables to convert ones to 7fffh and zeros to 0
        ; Also uses table to add transparency bit from AND mask. Zero in AND mask
        ; converts to 8000h, 1 to zero.
        ;**********************************************************************
                
NV3LCD_Get_Next_Byte:

        rol     cl,2                                ; first 2 pels
        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]
        
        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        
        shr     ebx,8                               ; next byte of AND mask
        shr     ecx,8                               ; next byte of MONO mask
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        dec     [esp].NV3LCD_Byte_Count             ; Continue with next 2 pels
        jnz     NV3LCD_Get_Next_Byte                ; Continue parsing this byte

        ;**********************************************************************
        ; We need to get the next dwords for the masks
        ;**********************************************************************

NV3LCD_Check_Next_Dword:

        add     esi,4                               ; Next AND mask dword
        add     ebp,4                               ; Next MONO mask dword

        ;**********************************************************************
        ; We've read 1 row (1 dword's worth of source data)   
        ;**********************************************************************

NV3LCD_Check_Row_Count:

        dec     [esp].NV3LCD_Row_Count              ; Check the Row count
        jnz     NV3LCD_Get_Next_Dword               ; Continue parsing the bits

        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV3LCD_Done:

        add     esp,(size NV3_LOAD_CURSOR_DATA_STRUC) - NV3_LOAD_CURSOR_DATA_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     8

NV3LoadCursorData@8 endp


;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV3Load16x16CursorData@8
        
NV3Load16x16CursorData@8 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV3_LOAD_CURSOR_DATA_STRUC) - NV3_LOAD_CURSOR_DATA_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   eax = Current 16bpp pel
        ;   edx = BitMask
        ;   ebx = Current dword from AND mask
        ;   ecx = Current dword from MONO mask
        ;   esi = Ptr to Source Image data
        ;   ebp = Ptr to Mono Image data        
        ;   edi = Ptr to Destination Data
        ;**********************************************************************
    
        mov     esi,[esp].NV3LCD_SrcPtr             ; Ptr to AND mask
        mov     ebp,esi                             ; Get ptr to MONO mask
        add     ebp,64                              ;  (64 bytes from beginning)
        mov     edi,[esp].NV3LCD_DestPtr            ; Ptr to current destination

        ;**********************************************************************
        ; 
        ; For Each row
        ;   For Each Dword
        ;      For Each Bit   
        ;        Store 16bpp pel corresponding to the bits in
        ;        the AND mask and MONO mask
        ;
        ;**********************************************************************

NV3_16x16_LCD_Init_Variables:

        mov     [esp].NV3LCD_Row_Count,16           ; We'll be parsing 16 rows
        xor     edx,edx

NV3_16x16_LCD_Get_Next_Dword:
        mov     [esp].NV3LCD_Byte_Count,2           ; 4 pels (4 inner loops) per byte
        mov     ebx,[esi]                           ; Get 1st word of AND mask data
        mov     ecx,[ebp]                           ; Get 1st word of MONO mask data
        
        ;**********************************************************************
        ; Load 16bpp pels - uses tables to convert ones to 7fffh and zeros to 0
        ; Also uses table to add transparency bit from AND mask. Zero in AND mask
        ; converts to 8000h, 1 to zero.
        ;**********************************************************************
                
NV3_16x16_LCD_Get_Next_Byte:

        rol     cl,2                                ; first 2 pels
        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]
        
        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        rol     cl,2                                ; next 2 pels
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        mov     dl,cl
        and     dl,3
        rol     bl,2
        mov     eax,MonoTable[edx*4]
        mov     dl,bl
        and     dl,3
        
        shr     ebx,8                               ; next byte of AND mask
        shr     ecx,8                               ; next byte of MONO mask
        or      eax,AndTable[edx*4]

        mov     [edi],eax
        add     edi,4                               ; Store the 2 16bpp pels

        dec     [esp].NV3LCD_Byte_Count             ; Continue with next 2 pels
        jnz     NV3_16x16_LCD_Get_Next_Byte         ; Continue parsing this byte

        ;**********************************************************************
        ; Blank out remaining 'width' portion of 32x32 cursor  (clear 16 pels)
        ;**********************************************************************

        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        
        ;**********************************************************************
        ; We need to get the next words for the masks
        ;**********************************************************************

NV3_16x16_LCD_Check_Next_Dword:

        add     esi,4                               ; Next AND mask word
        add     ebp,4                               ; Next MONO mask word

        ;**********************************************************************
        ; We've read 1 row (1 dword's worth of source data)   
        ;**********************************************************************

NV3_16x16_LCD_Check_Row_Count:

        dec     [esp].NV3LCD_Row_Count              ; Check the Row count
        jnz     NV3_16x16_LCD_Get_Next_Dword        ; Continue parsing the bits

        ;**********************************************************************
        ; Blank out remaining 'height' portion of 32x32 cursor (clear out 16 lines * 32 pels = 512 pels = 256 dwords)
        ;**********************************************************************

        mov     [esp].NV3LCD_Row_Count,256           
NV3_16x16_Continue_Clearing:
        mov     [edi],00000000h                     ; 
        add     edi,4                               ; Store the 2 16bpp pels
        dec     [esp].NV3LCD_Row_Count              ; Check the Row count
        jnz     NV3_16x16_Continue_Clearing         ; Continue clearing out cursor


        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV3_16x16_LCD_Done:

        add     esp,(size NV3_LOAD_CURSOR_DATA_STRUC) - NV3_LOAD_CURSOR_DATA_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     8

NV3Load16x16CursorData@8 endp



;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV3CursorChecksum@4
        
NV3CursorChecksum@4 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    esi
        push    ebp
        push    ebx
        
        sub     esp,(size NV3_CURSOR_CHECKSUM_STRUC) - NV3_CURSOR_CHECKSUM_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   esi = Ptr to Source Image data
        ;   ecx = number of dwords
        ;   eax = top checksum
        ;   ebx = bottom checksum
        ;
        ; NOTE: Calculating a simplified checksum for the entire image
        ;       is NOT sufficient, because we get the same checksum value
        ;       if 2 images are horizontal mirror images of each other.
        ;       To avoid this case, we calculate a checksum for the top
        ;       and bottom half. If they are the same, then we need to
        ;       return a flag value that we can't distinguish this particular
        ;       image (i.e. we'll reload the cursor image completely)
        ;**********************************************************************
    
        mov     esi,[esp].NV3CHK_SrcPtr             ; Ptr to cursor masks
        xor     eax,eax                             ; Clear top checksum value
        xor     ebx,ebx                             ; Clear bottom checksum value

        ;**********************************************************************
        ; Calculate checksum for 1st half of AND mask
        ;**********************************************************************
        
        mov     ecx,8                               ; Top half of mask 
NV3CHK_CheckSumLoop1:

        mov     edx,[esi]                           ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     eax,edx
        mov     edx,[esi+4]                         ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     ebx,edx
        add     esi,8                               ; Next dword
        dec     ecx
        jnz     short NV3CHK_CheckSumLoop1          ; Parse dwords at a time

        ;**********************************************************************
        ; Calculate checksum for 2nd half of AND mask
        ;**********************************************************************
        
        mov     ecx,8                               ; Bottom half of mask 
NV3CHK_CheckSumLoop2:

        mov     edx,[esi]                           ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     ebx,edx
        mov     edx,[esi+4]                         ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     eax,edx
        add     esi,8                               ; Next dword
        dec     ecx
        jnz     short NV3CHK_CheckSumLoop2          ; Parse dwords at a time
        

        ;**********************************************************************
        ; Calculate checksum for 1st half of MONO mask
        ;**********************************************************************
        
        mov     ecx,8                               ; Top half of mask 
NV3CHK_CheckSumLoop3:

        mov     edx,[esi]                           ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     eax,edx
        mov     edx,[esi+4]                         ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     ebx,edx
        add     esi,8                               ; Next dword
        dec     ecx
        jnz     short NV3CHK_CheckSumLoop3          ; Parse dwords at a time
        

        ;**********************************************************************
        ; Calculate checksum for 2nd half of MONO mask
        ;**********************************************************************
        
        mov     ecx,8                               ; Bottom half of mask 
NV3CHK_CheckSumLoop4:

        mov     edx,[esi]                           ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     ebx,edx
        mov     edx,[esi+4]                         ; Get current dword
        add     edx,ecx
        rol     edx,cl
        add     eax,edx
        add     esi,8                               ; Next dword
        dec     ecx
        jnz     short NV3CHK_CheckSumLoop4          ; Parse dwords at a time
        
        ;**********************************************************************
        ; Check if we've got a mirror image.
        ; If so, then we return a flag value telling the calle to 
        ; reload the cursor image
        ;**********************************************************************

        cmp     eax,ebx                             ; Mirror image?
        jne     short NV3CHK_Done                   ; N: Just return
        mov     eax, 12345678h                      ; Return a flag value
                
        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV3CHK_Done:

        add     esp,(size NV3_CURSOR_CHECKSUM_STRUC) - NV3_CURSOR_CHECKSUM_PARM_SIZE

        pop     ebx
        pop     ebp
        pop     esi

        ret     4

NV3CursorChecksum@4 endp

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv4blit.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV4BLIT.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated Blt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc                     ;calling convention cmacros
        include i386\strucs.inc
        .list

        .data

;*******************************************************************************
; Dma Push version of structure
;*******************************************************************************

NV4_DMAPUSH_TRANSFER_BLITDATA_STRUC          struc

; Feel free to add any local variables here:

DwordsNeeded                dd      ?
NextScanInc                 dd      ?
RemainingDwordsPerDstScan   dd      ?
LocalHeight                 dd      ?

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV4DTBDS_ebp         dd      ?
NV4DTBDS_esi         dd      ?
NV4DTBDS_edi         dd      ?
NV4DTBDS_ebx         dd      ?
NV4DTBDS_RetAddr     dd      ?
passedPpdev          dd      ?
BytesPerDstScan      dd      ?
Height               dd      ?
NextScanPtr          dd      ?
ScanInc              dd      ?

NV4_DMAPUSH_TRANSFER_BLITDATA_STRUC          ends

NV4_DMAPUSH_TRANSFER_BLITDATA_PARM_SIZE     equ     10 * 4

        .code


extrn       NV_DmaPush_Wrap@8:NEAR
extrn       NV_DmaPush_CheckWrapped@8:NEAR
extrn       NV4_DmaPushSend@4:NEAR


;---------------------------Public-Routine------------------------------;
;
; Routine to output a memory bitmap to the screen using the DMA push
; buffer.
;
;-----------------------------------------------------------------------;

align 4

        public NV4_DmaPush_Transfer_MemToScreen_Data@20


NV4_DmaPush_Transfer_MemToScreen_Data@20 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp, (size NV4_DMAPUSH_TRANSFER_BLITDATA_STRUC) - NV4_DMAPUSH_TRANSFER_BLITDATA_PARM_SIZE
        mov     ebp, esp                        ; points to parameters and local vars

        cld                                     ; Default to going forward
        xor     eax, eax
        mov     ecx, [ebp].Height               ; Number of scanlines to output
        mov     ebx, [ebp].passedPpdev          ; Ptr to pdev
        or      ecx, ecx                        ; If zero scanliness
        jz      TransferDone                    ; nothing to draw
        
        mov     [ebp].LocalHeight, ecx          ; Save height parameter
        mov     esi, [ebp].ScanInc
        mov     [ebx].nvDmaCachedFreeCount, eax ; init free count to zero

        mov     edx, [ebx].nvDmaCount
        mov     edi, [ebx].nvDmaFifo            ; pointer to DMA buffer
        mov     ecx, [ebp].BytesPerDstScan      ; number of BYTES in one scanline
        shl     edx, 2                          ; offset in DMA buffer
                                                ;  to point to next scanline
        shl     esi, 2                          ; byte increment to next scanline                                                    
        add     edi, edx                        ; offset to current location
                                                ;  in DMA buffer
        mov     edx, ecx                        ; BytesPerDstScan                                                
        
        cmp     edx, MAX_INDEXED_IMAGE_DWORDS*4 ; if more bytes than hardware can handle
        jl      NormalScanlineTransfer          ; then need to adjust RemainingDwordsPerDstScan
                                                ;  value
        sub     edx, MAX_INDEXED_IMAGE_DWORDS*4 ; adjust remaining byte count

NormalScanlineTransfer:
        sub     esi, ecx                        ; number of bytes to increment
        shr     edx, 2                          ; number of whole DWORDS in
                                                ;  remaining scanline
        shr     ecx, 2                          ; number of DWORDS in scanline
        
        mov     [ebp].RemainingDwordsPerDstScan, edx ; save dwords needed in main loop
        add     ecx, 4                          ; add max overhead for DMA push cmd data

        mov     [ebp].NextScanInc, esi          ; save increment to next scanline
        mov     [ebp].DwordsNeeded, ecx         ; save max number of DWORDS needed
                                                ;  in push buffer for each scanline

;*************************************************************************
;
;   Output source bitmap to DMA push buffer.
;
;   EBX - ppdev
;   EDI - offset to current location in DMA buffer
;
;*************************************************************************

TransferBitmapLoop:

        mov     ecx, [ebp].DwordsNeeded         ; number of DWORDS in one scanline
                                                ;  with max overhead
        sub     [ebx].nvDmaCachedFreeCount, ecx ; overhead per glyph
        jg      HaveRoomForScanline             ; have enough room in DMA buffer
                                                ;   for current scanline

    ;*************************************************************************
    ;
    ; Get current free count in DMA buffer. Updates ppdev->nvDmaCachedFreeCount.
    ; This is similar to the NV_DMAPUSH_CHECKFREE C macro.
    ;
    ; NOTE: updates ppdev->nvDmaCount to equal local nvDmaCount
    ;
    ; EBX - ppdev
    ; ECX - number of DWORDS needed in DMA buffer
    ; EDI - offset to current location in DMA buffer
    ;
    ;*************************************************************************

        ;******************************************************************
        ; Kickoff buffer when not enough room in cached buffer free count
        ;******************************************************************

        mov     edx, [ebx].nvDmaChannel
        sub     edi, [ebx].nvDmaFifo            ; offset within DMA buffer
        
        shr     edi, 2                          ; convert to dwords
        mov     [ebx].nvDmaCount, edi           ; update ppdev->nvDmaCount

        push    ecx        
        push    ebx
        push    ebx
        call    NV4_DmaPushSend@4
        pop     ebx
        pop     ecx

        cmp     [ebx].nvDmaWrapFlag, FALSE      ;ppdev->nvDmaWrapFlag
        jne     short CheckDmaWrapped

    ;*************************************************************************
    ;
    ; WRAP_FLAG = FALSE. Check if we need to wrap around.
    ;
    ; EBX - ppdev
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

        mov     eax, [ebx].DmaPushBufTotalSize  ;
        shr     eax, 2                          ;
        sub     eax, DMAPUSH_PADDING            ;
        sub     eax, [ebx].nvDmaCount           ; less current nvDmaCount
        sub     eax, ecx                        ; less number of DWORDS needed
        jge     UpdateFreeCount                 ; have enough room in DMA buffer
        
    ;*************************************************************************
    ;
    ; Need to wrap.
    ;
    ; EBX - ppdev
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

GoWrapDmaBuffer:

        push    ecx                             ; DWORDS needed - parameter
        push    ebx                             ; ppdev - parameter
        call    NV_DmaPush_Wrap@8               ; (ppdev, DWORDS_NEEDED)
        jmp     ZeroFreeCount                   ; need to check next time

    ;*************************************************************************
    ;
    ; WRAP_FLAG = TRUE. We are currently wrapped around (DMA count < Get Ptr)
    ;
    ; EBX - ppdev
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

CheckDmaWrapped:

        push    ecx                             ; DWORDS needed - parameter
        push    ebx                             ; ppdev - parameter
        call    NV_DmaPush_CheckWrapped@8       ; (ppdev, DWORDS_NEEDED)

    ;*************************************************************************
    ;
    ; Set free count. This will be zero if we are wrapped. This way, we will
    ; force a check until buffer is not wrapped. 
    ;
    ;*************************************************************************

ZeroFreeCount:
        mov     ebx, [ebp].passedPpdev          ; reload ppdev
        xor     eax, eax                        ; set freecount to zero - will
                                                ;  force check next pass

    ;*************************************************************************
    ;
    ; WRAP_FLAG = FALSE. Check if we need to wrap around.
    ;
    ; EAX - number of free dwords in DMA push buffer
    ; EBX - ppdev
    ;
    ;*************************************************************************

UpdateFreeCount:
        mov     [ebx].nvDmaCachedFreeCount, eax
        mov     edx, [ebx].nvDmaCount
        mov     edi, [ebx].nvDmaFifo            ; pointer to DMA buffer
        shl     edx, 2                          ; offset in DMA buffer
        add     edi, edx                        ; offset to current location
                                                ;  in DMA buffer

    ;*************************************************************************
    ;
    ; Have room in DMA buffer, now output scanline.
    ;
    ; EBX - ppdev
    ; EDI - offset to current location in DMA buffer
    ;
    ;*************************************************************************

HaveRoomForScanline:

        mov     eax, [ebp].BytesPerDstScan
        mov     esi, [ebp].NextScanPtr
        
        cmp     eax, MAX_INDEXED_IMAGE_DWORDS*4 ; if more bytes than hardware can handle
        jge     TransferBigScanline             ; then output max dwords
                                                ; (jump away for performance since
                                                ;  this almost never happens and processors
                                                ;  want to fall through conditional jumps)

    ;*************************************************************************
    ;
    ; Handle remaining dwords.
    ;
    ; EAX - number of bytes in scanline to output
    ; EBX - ppdev
    ; EDI - offset to current location in DMA buffer
    ; ESI - offset to current location in source bitmap
    ;
    ;*************************************************************************
    
TransferRemainingDwords:

        mov     edx, [ebp].RemainingDwordsPerDstScan ; rounded up dwords in scanline
        mov     ecx, edx                        ; total dwords remaining
        test    edx, edx
        jz      TransferRemainingBytes          ; no more dwords to send, check
                                                ;  whether bytes to output
                                                
        shl     ecx, 18                         ; convert bytes to #Dwords for header
        or      ecx, IMAGE_FROM_CPU_SUBCHANNEL OR NV061_COLOR0
        mov     DWORD PTR [edi], ecx
        add     edi, 4

        mov     ecx, edx                        ; total dwords remaining
        rep     movsd
        
    ;*************************************************************************
    ;
    ;   Handle remaining bytes. Note: This is necessary because the end of the
    ;   bitmap is not always an even number of dwords from the start. Also,
    ;   the bitmap often begins at the highest scanline and progresses backwards.
    ;   For this reason, you can't just special case the last line.
    ;
    ;   EAX - number of bytes in scanline to output
    ;   EBX - ppdev
    ;   EDI - offset to current location in DMA buffer
    ;   ESI - offset to current location in source bitmap
    ;
    ;*************************************************************************

TransferRemainingBytes:
    
        and     eax, 3                          ; bytes leftover
        jz      NextScanline                    ; no bytes to draw, scanline finished

        mov     DWORD PTR [edi], IMAGE_FROM_CPU_SUBCHANNEL OR NV061_COLOR0 OR (1 SHL 18)
        add     edi, 4
        
        mov     ecx, eax                        ; remaining bytes
        rep     movsb
        add     edi, 4                          ; update DMA buffer to next DWORD
        sub     edi, eax

    ;******************************************************************
    ;
    ; All data from scanline is copied to DMA push buffer. Now update
    ; NextScanPtr to point to offset of next source scanline.
    ;
    ;   EBX - ppdev
    ;   EDI - offset to current location in DMA buffer
    ;   ESI - offset to current location in source bitmap
    ;
    ;******************************************************************

NextScanline:
        
        add     esi, [ebp].NextScanInc          ; points to next scanline
        mov     [ebp].NextScanPtr, esi          ; save update bitmap pointer
        dec     [ebp].LocalHeight               ; if more scanlines to draw
        jnz     TransferBitmapLoop              ; then draw next scanline
        
    ;******************************************************************
    ;
    ; All data from scanline is copied to DMA push buffer. 
    ; Kickoff buffer after last scanline
    ;
    ;   EBX - ppdev
    ;   EDI - offset to current location in DMA buffer
    ;
    ;******************************************************************

        mov     esi, [ebx].nvDmaChannel
        sub     edi, [ebx].nvDmaFifo            ; offset within DMA buffer
        
        shr     edi, 2                          ; convert to dwords
        mov     [ebx].nvDmaCount, edi           ; update ppdev->nvDmaCount

        push    ebx
        call    NV4_DmaPushSend@4

TransferDone:
        
        add     esp,(size NV4_DMAPUSH_TRANSFER_BLITDATA_STRUC) - NV4_DMAPUSH_TRANSFER_BLITDATA_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     20

    ;*************************************************************************
    ;
    ;   Output the maximum amount of dwords allowed by hardware. Only need to
    ;   do this once, since no scanlines will be 2 times MAX_INDEXED_IMAGE_DWORDS
    ;
    ;   This code was moved from above loop for performance, since this rarely happens
    ;   and processors' branch prediction wants to fall through conditional jumps.
    ;
    ;   EAX - number of bytes in scanline
    ;   EBX - ppdev
    ;   EDI - offset to current location in DMA buffer
    ;   ESI - offset to current location in source bitmap
    ;
    ;*************************************************************************

TransferBigScanline:

        mov     DWORD PTR [edi], IMAGE_FROM_CPU_SUBCHANNEL OR NV061_COLOR0 OR (MAX_INDEXED_IMAGE_DWORDS SHL 18)
        add     edi, 4

        mov     ecx, MAX_INDEXED_IMAGE_DWORDS
        rep     movsd
        
        sub     eax, MAX_INDEXED_IMAGE_DWORDS*4 ; number of bytes left in scanline
        jmp     TransferRemainingDwords         ; output rest of dwords in scanline

NV4_DmaPush_Transfer_MemToScreen_Data@20 endp



end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolstoolbox.h ===
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolstoolbox.h
//
// FNicklisch 09/14/2000: New, derived from toolbox.h and others
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//
#ifndef _WKSELSATOOLSTOOLBOX_H
#define _WKSELSATOOLSTOOLBOX_H

#ifdef USE_WKS_ELSA_TOOLS
/*
** common code used in miniport and display driver
*/

ULONG ulStrLen(IN PSTR pString);
ULONG ulStrTrueLen(IN PSTR pString);
ULONG ulWStrLen(IN PWSTR pString);
ULONG ulWStrTrueLen(IN PWSTR pString);

PSTR  szStrCpy     (OUT PSTR  pTrg, IN const PSTR  pSrc);
PSTR  szStrCat     (OUT PSTR  pTrg, IN const PSTR  pSrc);
PSTR  szStrCpyWStr (OUT PSTR  pTrg, IN const PWSTR pSrc);
PSTR  szStrCatWStr (OUT PSTR  pTrg, IN const PWSTR pSrc);
PWSTR wszWStrCpy    (OUT PWSTR pTrg, IN const PWSTR pSrc);
PWSTR wszWStrCat    (OUT PWSTR pTrg, IN const PWSTR pSrc);
PWSTR wszWStrCpyStr (OUT PWSTR pTrg, IN const PSTR  pSrc);
PWSTR wszWStrCatStr (OUT PWSTR pTrg, IN const PSTR  pSrc);

#ifdef DBG
VOID vDbg_Check_c_ToolBox(VOID);
#else
#define vDbg_Check_c_ToolBox()
#endif

// FNicklis IA-64: Need a pointer size here
// calculate offset in 32 bit ULONG between two pointers
ULONG __inline ulPtrOffsetInByte(IN PVOID pv1, IN PVOID pv2)
{
  // FNicklis IA-64: Usage of 32 bit is save here
  return( (ULONG)((ULONG_PTR)((BYTE*)pv1 - (BYTE*)pv2)) );
}

// FNicklis 21.10.98 20:40:19: New
__inline VOID vBitsSet(IN OUT FLONG *pflValue, IN FLONG flSetBits)
{
  *pflValue |= flSetBits;
}

// FNicklis 21.10.98 20:40:19: New
__inline VOID vBitsClear(IN OUT FLONG *pflValue, IN FLONG flClearBits)
{
  *pflValue &= (~flClearBits);
}

__inline int bBitsTest(IN FLONG flValue, IN FLONG flTestBits)
{
  return ( (flValue & flTestBits) == flTestBits ); // exact match on each bit!
}

/*
** Memory allocation
*/
BOOL bAllocMem(PVOID *ppBuffer, ULONG nByte, ULONG ulTag);

BOOL bAllocMemPageAligned(IN OUT PVOID     *ppvAlign,
                      IN     ULONG      ulSize, // size to allocate
                      IN     ULONG      ulTag); // memory tag
BOOL bFreeMemPageAligned(IN OUT PVOID     *ppvAlign);

#ifdef DBG
BOOL bFreeMem(PVOID *ppBuffer, ULONG nDebugOnlyByteToClear);
#else
BOOL _bFreeMem(PVOID *ppBuffer); // one parameter only
#define bFreeMem(ppBuffer,nDebugOnlyByteToClear) _bFreeMem(ppBuffer)
#endif

__inline BOOL bRectAlloc(RECTL **pprcl, LONG c, ULONG ulTag)
{
  return (bAllocMem((PVOID *)pprcl, c*sizeof(RECTL), ulTag));
}

__inline BOOL bRectFree(RECTL **pprcl)
{
  return (bFreeMem((PVOID *)pprcl,0)); // don't know how much to free!
}

DWORD GetCurrentProcessID(VOID);
CHAR *szGetApplicationName(VOID);


#endif // USE_WKS_ELSA_TOOLS
#endif // _WKSELSATOOLSTOOLBOX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv3text.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV3TEXT.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated text blt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        .list

        .data

;
;  stack based params and local variables
;

NV3_TRANSFER_TEXT_STRUC          struc

; Feel free to add any local variables here:

NV3TS_RightCase            dd      ?
NV3TS_pjSrcScan            dd      ?
NV3TS_SrcIntStep           dd      ?
NV3TS_DstStride            dd      ?
NV3TS_XCount               dd      ?
NV3TS_yDst                 dd      ?
NV3TS_pdev                 dd      ?

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV3TS_ebp                  dd      ?
NV3TS_esi                  dd      ?
NV3TS_edi                  dd      ?
NV3TS_ebx                  dd      ?
NV3TS_RetAddr              dd      ?
NV3TS_NumDwordsPerGlyph    dd      ?
NV3TS_FreeCountPtr         dd      ?
NV3TS_GlyphDataPtr         dd      ?
NV3TS_NvChannelPtr         dd      ?

NV3_TRANSFER_TEXT_STRUC          ends

NV3_TRANSFER_TEXT_PARM_SIZE     equ     9 * 4

;*******************************************************************************
; Defines for NV Hardware
; Currently, channels are used as follows:
;   IMAGE_FROM_CPU          Channel 0
;   BLIT                    Channel 1
;   IMAGE_MONO_FROM_CPU     Channel 2
;   RECT_AND_TEXT           Channel 2
;   RECTANGLE               Channel 3
;   ROP_SOLID               Channel 4
;   IMAGE_PATTERN           Channel 5
;   CLIP                    Channel 6
;   IMAGE_SOLID             Channel 7
;*******************************************************************************

IMAGE_FROM_CPU_FREECOUNT           equ    ( (0*8192) + 16 )
BLIT_FREECOUNT                     equ    ( (1*8192) + 16 )
IMAGE_MONO_FROM_CPU_FREECOUNT      equ    ( (2*8192) + 16 )
RECT_AND_TEXT_FREECOUNT            equ    ( (2*8192) + 16 )
RECTANGLE_FREECOUNT                equ    ( (3*8192) + 16 )
ROP_SOLID_FREECOUNT                equ    ( (4*8192) + 16 )
IMAGE_PATTERN_FREECOUNT            equ    ( (5*8192) + 16 )
CLIP_FREECOUNT                     equ    ( (6*8192) + 16 )
IMAGE_SOLID_FREECOUNT              equ    ( (7*8192) + 16 )

RECT_AND_TEXT_MONODATA_0      equ    ( (2*8192) + 1000h )
RECT_AND_TEXT_MONODATA_1      equ    ( (2*8192) + 1004h )
RECT_AND_TEXT_MONODATA_2      equ    ( (2*8192) + 1008h )
RECT_AND_TEXT_MONODATA_3      equ    ( (2*8192) + 100ch )
RECT_AND_TEXT_MONODATA_4      equ    ( (2*8192) + 1010h )
RECT_AND_TEXT_MONODATA_5      equ    ( (2*8192) + 1014h )
RECT_AND_TEXT_MONODATA_6      equ    ( (2*8192) + 1018h )
RECT_AND_TEXT_MONODATA_7      equ    ( (2*8192) + 101ch )
RECT_AND_TEXT_MONODATA_8      equ    ( (2*8192) + 1020h )
RECT_AND_TEXT_MONODATA_9      equ    ( (2*8192) + 1024h )
RECT_AND_TEXT_MONODATA_10     equ    ( (2*8192) + 1028h )
RECT_AND_TEXT_MONODATA_11     equ    ( (2*8192) + 102ch )
RECT_AND_TEXT_MONODATA_12     equ    ( (2*8192) + 1030h )
RECT_AND_TEXT_MONODATA_13     equ    ( (2*8192) + 1034h )
RECT_AND_TEXT_MONODATA_14     equ    ( (2*8192) + 1038h )
RECT_AND_TEXT_MONODATA_15     equ    ( (2*8192) + 103ch )

        .code

;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV3_Transfer_Text_Data@16

NV3_Transfer_Text_Data@16 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV3_TRANSFER_TEXT_STRUC) - NV3_TRANSFER_TEXT_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   ebx = Number of dwords remaining
        ;   ecx = Current rep mov index
        ;   edx = Current Free Count
        ;   esi = Ptr to Glyph Image data
        ;   edi = Ptr to current user channel location
        ;   ebp = Ptr to NV User Channel
        ;**********************************************************************

        mov     ebp,[esp].NV3TS_NvChannelPtr        ; Get pointer to NV channel
        add     ebp,RECT_AND_TEXT_MONODATA_0        ; EDI ptr to data array in user channel
        mov     edi,ebp                             ; EDI pts to user channel location
        mov     ebx,[esp].NV3TS_NumDwordsPerGlyph   ; Number of DWORDS to output
        mov     esi,[esp].NV3TS_GlyphDataPtr        ; Ptr to GLYPH Image data
        mov     edx,[esp].NV3TS_FreeCountPtr        ; Ptr to current cached free count
        movzx   edx,word ptr [edx]                  ; Get current free count

        ;**********************************************************************
        ;
        ; Output 4 Dwords at a time
        ;
        ;**********************************************************************

NV3TTD_Check_For_4Dwords:

        cmp     ebx,4                               ; Q: Any more Dwords to output?
        jb      short NV3TTD_Check_For_1Dwords      ;  N: Less than 4 dwords remaining

NV3TTD_4Dwords_Chk_FreeCount:

        cmp     edx,4*4                             ; Q: Enough room to output 4 dwords?
        jae     short NV3TTD_4Dwords_UpdateFreeCount;  Y: Send the data

NV3TTD_4Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+RECT_AND_TEXT_FREECOUNT-RECT_AND_TEXT_MONODATA_0] ; Get freecount from hardware
        jmp     short NV3TTD_4Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV3TTD_4Dwords_UpdateFreeCount:

        sub     edx,4*4                             ; Update cached freecount

NV3TTD_4Dwords_SendData:

        mov     eax,[esi]
        mov     [edi],eax
        mov     eax,[esi+4]
        mov     [edi],eax
        mov     eax,[esi+8]
        mov     [edi],eax
        mov     eax,[esi+12]
        mov     [edi],eax
        sub     ebx,4
        add     esi,16
        jmp     short NV3TTD_Check_For_4Dwords      ; Loop thr remaining data

        ;**********************************************************************
        ;
        ; Output 1 thru 3 Dwords at a time
        ;
        ;**********************************************************************

NV3TTD_Check_For_1Dwords:

        cmp     ebx,0                               ; Q: Any more Dwords to output?
        jbe     short NV3TTD_Done                   ;  N: All done, exit

NV3TTD_1Dwords_Chk_FreeCount:

        cmp     edx,1*4                             ; Q: Enough room to output 1 dword?
        jae     short NV3TTD_1Dwords_UpdateFreeCount;  Y: Send the data

NV3TTD_1Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+RECT_AND_TEXT_FREECOUNT-RECT_AND_TEXT_MONODATA_0] ; Get freecount from hardware
        jmp     short NV3TTD_1Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV3TTD_1Dwords_UpdateFreeCount:

        sub     edx,1*4                             ; Update cached freecount

NV3TTD_1Dwords_SendData:

        mov     eax,[esi]                           ; Get source dword
        mov     [ebp],eax                           ; Output dword to monochrome array
        dec     ebx                                 ; Next dword
        jz      short NV3TTD_Done                   ; Check if we're done
        add     esi,1*4                             ; Next dword of glyph data
        jmp     short NV3TTD_1Dwords_Chk_FreeCount  ; Continue with remaining dwords

        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV3TTD_Done:

        mov     eax,[esp].NV3TS_FreeCountPtr        ; Make sure to update
        mov     word ptr [eax],dx                   ;   cached free count

        add     esp,(size NV3_TRANSFER_TEXT_STRUC) - NV3_TRANSFER_TEXT_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     16

NV3_Transfer_Text_Data@16 endp




end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\wkselsatoolsregistry.h ===
#ifndef _WKSELSATOOLSREGISTRY_H
#define _WKSELSATOOLSREGISTRY_H
//*****************************Module*Header******************************
//
// Module Name: wkselsatoolsregistry.h
//
// FNicklisch 09/14/2000: New, derived from registry.h and others...
//
// This part of code was taken from the code bought from ELSA. Parts of 
// it is used to get the workstation tools, application and features up
// and running. It is implemented on a temporary base and will be replaced
// by a NVIDIA propritary interface as soon as possible.
// Don't care about the code not necessariliy used.
//
// Copyright (c) 1999-2000, ELSA AG, Aachen (Germany)
// Copyright (c) 2000 NVidia Corporation. All Rights Reserved.
//

#ifdef USE_WKS_ELSA_TOOLS
// Errorcodes returned by DrvEscape
#define REG_ERROR   -1
#define REG_OK       0
#define REG_DEFAULT  1

// copies of this structures are located in m_registry.h for the miniport side of this
// information. If values are changed, change them in m_registry.h, too

//*******************************************************************************************
// 131098 MSchwarz 
// structures to transfer data throught the EngDeviceIoControl function 
// between driver and miniport for Registry settings
// therefore 4 IOCTL_VIDEO constants are defined:
// IOCTL_VIDEO_REG_ID_TRANSFER_SET  : set value with key decoded with ID
// IOCTL_VIDEO_REG_SZ_TRANSFER_GET  : get value with key decoded with ID
// IOCTL_VIDEO_REG_ID_TRANSFER_SET  : set value with key given as String
// IOCTL_VIDEO_REG_SZ_TRANSFER_GET  : get value with key given as  String

#define MAX_STRING 260

#pragma warning(disable:4200) // nonstandard extension used : zero-sized array in struct/union
typedef struct tagIOCTL_ID_TRANSFER
{
  ULONG dwId;                 // ELSA_ESC ID to set
  ULONG dwDataSize;           // sizeof( Data ) without sizeof( dwSize / dwType / dwId )
  ULONG dwDataType;           // Type of Data ( REG_SZ, REG_BINARY, etc )
  LONG  lReturnCode;          // REG_OK, REG_DEFAULT, (REG_ERROR) ...
  CHAR  ajData[0];            // complete Data to move
} IOCTL_ID_TRANSFER, *PIOCTL_ID_TRANSFER;


typedef struct tagIOCTL_SZ_TRANSFER
{
  CHAR  szId[MAX_STRING];     // the key in Registry to set
  ULONG dwDataSize;           // sizeof( Data ) without sizeof( dwSize / dwType / dwId )
  ULONG dwDataType;           // Type of Data ( REG_SZ, REG_BINARY, etc )
  LONG  lReturnCode;          // REG_OK, REG_DEFAULT, (REG_ERROR) ...
  CHAR  ajData[0];            // complete Data to move
} IOCTL_SZ_TRANSFER, *PIOCTL_SZ_TRANSFER;
#pragma warning(default:4200) // nonstandard extension used : zero-sized array in struct/union

//*******************************************************************************************


// driver internal registry IDs, reserved are for free temporary use!

// ********************************************************
// query/set values identifier: 
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1              Bit No
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 
//  +-------+-------+-----------------------------------------------+
//  |o o o o|r r r r|                                          code |
//  +-------+-------+-----------------------------------------------+
//
//  o = bitfield defining OS dependencies
//    0       = no specific OS
//    0x1     = Win9x
//    0x2     = Win NT
//    0x4,0x8 = unused
//  r = bitfield reserved for driver internal stuff.
//    This field must be 0 in all IDs-codes called via ExtEscape!

#define INTERNAL_ET_VALUE_DEFAULT        0x01000000 // Use internal default instead of registry value
#define INTERNAL_ET_VALUE_unused0        0x02000000
#define INTERNAL_ET_VALUE_unused1        0x04000000
#define INTERNAL_ET_VALUE_HIDDEN_KEYS    0x08000000 // BIT to test internaly used keys

#define INTERNAL_ET_VALUE_KEY_ID_ONLY_MASK (~(INTERNAL_ET_VALUE_DEFAULT))

// hidden and internal driver keys, used within the driver only
#define INTERNAL_ET_VALUE_DW_RESERVED0  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 0) // Reserved 0
#define INTERNAL_ET_VALUE_DW_RESERVED1  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 1) // Reserved 1
#define INTERNAL_ET_VALUE_DW_RESERVED2  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 2) // Reserved 2
#define INTERNAL_ET_VALUE_DW_RESERVED3  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 3) // Reserved 3
#define INTERNAL_ET_VALUE_DW_RESERVED4  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 4) // Reserved 4
#define INTERNAL_ET_VALUE_DW_RESERVED5  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 5) // Reserved 5
#define INTERNAL_ET_VALUE_DW_RESERVED6  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 6) // Reserved 6
#define INTERNAL_ET_VALUE_DW_RESERVED7  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 7) // Reserved 7
#define INTERNAL_ET_VALUE_DW_RESERVED8  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 8) // Reserved 8
#define INTERNAL_ET_VALUE_DW_RESERVED9  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 9) // Reserved 9

#define INTERNAL_ET_VALUE_DW_ICDRESERVED0  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 10) // ICD Reserved 0
#define INTERNAL_ET_VALUE_DW_ICDRESERVED1  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 11) // ICD Reserved 1
#define INTERNAL_ET_VALUE_DW_ICDRESERVED2  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 12) // ICD Reserved 2
#define INTERNAL_ET_VALUE_DW_ICDRESERVED3  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 13) // ICD Reserved 3
#define INTERNAL_ET_VALUE_DW_ICDRESERVED4  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 14) // ICD Reserved 4
#define INTERNAL_ET_VALUE_DW_ICDRESERVED5  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 15) // ICD Reserved 5
#define INTERNAL_ET_VALUE_DW_ICDRESERVED6  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 16) // ICD Reserved 6
#define INTERNAL_ET_VALUE_DW_ICDRESERVED7  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 17) // ICD Reserved 7
#define INTERNAL_ET_VALUE_DW_ICDRESERVED8  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 18) // ICD Reserved 8
#define INTERNAL_ET_VALUE_DW_ICDRESERVED9  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 19) // ICD Reserved 9

#define INTERNAL_ET_VALUE_DW_ERAZOR_II   ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 20)    // temporary keys used for not implemented features

// internal keys
#define INTERNAL_ET_VALUE_DW_CORE_CLOCK          ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 21)
#define INTERNAL_ET_VALUE_DW_MEMORY_CLOCK        ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 22)
#define INTERNAL_ET_VALUE_DW_MEMORY_TIMING       ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 23)
#define INTERNAL_ET_VALUE_DW_HW_STANDARDTIMINGS  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 24)
#define INTERNAL_ET_VALUE_DW_HW_SCRAMBLEMODE     ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 25)
#define INTERNAL_ET_VALUE_DW_HW_SCRAMBLESETTINGS ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 26)

#define INTERNAL_ET_VALUE_DW_DBG_OPENGLBUFFERNO     ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 27)
#define INTERNAL_ET_VALUE_DW_DBG_CHECKHEAPINTEGRITY ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 28)

#define INTERNAL_ET_VALUE_DW_HELPERFLAGS              ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 29)

// Keys used by the multiboard wrapper to store WINman2 modes (Binary)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET0 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 30)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET1 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 31)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET2 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 32)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET3 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 33)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET4 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 34)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET5 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 35)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET6 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 36)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET7 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 37)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET8 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 38)
#define INTERNAL_ET_VALUE_DW_MB2D_ET_WINMAN2_DATA_GET9 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 39)

// Keys used by the single board driver to store WINman2 modes (Binary)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET0 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 40)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET1 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 41)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET2 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 42)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET3 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 43)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET4 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 44)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET5 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 45)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET6 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 46)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET7 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 47)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET8 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 48)
#define INTERNAL_ET_VALUE_DW_ET_WINMAN2_DATA_GET9 ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 49)

// tetris tiling configuration
#define INTERNAL_ET_VALUE_DW_HW_TETRIS_TILING    ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 50)
#define INTERNAL_ET_VALUE_DW_HW_TETRIS_MODE      ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 51)
#define INTERNAL_ET_VALUE_DW_HW_TETRIS_SHIFT     ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 52)

#define INTERNAL_ET_VALUE_DW_DBG_SURFACENEVERATBOTTOM      ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 54)
#define INTERNAL_ET_VALUE_DW_OPENGL_FORCESOFTWARE          ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 55)
#define INTERNAL_ET_VALUE_DW_OPENGL_DBGFLAGSOVERRIDE       ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 56)
#define INTERNAL_ET_VALUE_DW_OPENGL_DBGMAXLOCALERRORCOUNT  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 57)
#define INTERNAL_ET_VALUE_DW_OPENGL_DBGTRACETOFILE         ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 58)
#define INTERNAL_ET_VALUE_DW_OPENGL_USE_DISPLAYDRIVER_BUFFER ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 59)// FALSE use DirectDraw-Buffer ; TRUE: use DisplayDriverBuffer via OGLESC
#define INTERNAL_ET_VALUE_DW_HW_FORCE_TIMING               ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 60)
#define INTERNAL_ET_VALUE_DW_OPENGL_ACQUIREMUTEXFORKICKOFF ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 61)
#define INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS         ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 62)
#define INTERNAL_ET_VALUE_DW_OPENGL_CLIENTRELATIVECLIPRECTS INTERNAL_ET_VALUE_DW_OPENGL_CLIENTCLIPRECTS // old for compatibility only!
#define INTERNAL_ET_VALUE_DW_HW_USE_ELSA_INITCODE           ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 63)  
#define INTERNAL_ET_VALUE_DW_HW_SHUTDOWN                    ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 64) // FL_SHUTDOWN_GART, ...

#define INTERNAL_ET_VALUE_DW_OPENGL_NO_ICD_CALLBACK         ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 65) // if set the display driver doesn't call the ICD for FLIP callbacks
#define INTERNAL_ET_VALUE_DW_OPENGL_OVERLAYBPP              ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 66) // Bits per pixel used for overlay
#define INTERNAL_ET_VALUE_SZ_OEM_VERSION                    ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 67) // OEM build detection (e.g. for DELL drivers)
#define INTERNAL_ET_VALUE_DW_GDI_PUNTFLAGS                  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 68) // flags to punt drv functions FL_PUNT_DRVCOPYBITS,...

#define INTERNAL_ET_VALUE_DW_HW_ONDMACRASH                  ((ET_VALUE_OS_WINNT|INTERNAL_ET_VALUE_HIDDEN_KEYS) + 69) // How to react on a resource manager crash dump 


LONG lEscRegistryValue(
  PPDEV    ppdev,
  ULONG    ulSubEsc, 
  ULONG    cjIn ,
  VOID    *pvIn ,
  ULONG    cjOut,
  VOID    *pvOut);

LONG lRegEtQueryValue(
  IN         HANDLE             hDriver, 
  IN         DWORD              dwSubEsc, 
  IN  struct tagET_QUERY_VALUE *petQueryValue,
  IN         ULONG              cjOut, 
  OUT        VOID              *pvOut);

LONG lRegEtSetValue(
  IN         HANDLE               hDriver, 
  IN         DWORD                dwSubEsc, 
  IN         VOID                *pvIn, 
  IN         ULONG                cjIn, 
  OUT struct tagET_SET_VALUE_RET *pSetValueRet);

LONG lRegEtDefaultValue(
  IN         HANDLE                   hDriver, 
  IN  struct tagET_SET_VALUE_DEFAULT *pDefaultValue, 
  OUT struct tagET_SET_VALUE_RET     *pSetValueRet);

LONG lRegGetIdBinary ( IN HANDLE hDriver, IN DWORD dwID,      OUT BYTE  *pjData,   IN DWORD nByte );
LONG lRegGetIdDWord  ( IN HANDLE hDriver, IN DWORD dwID,      OUT DWORD *pulData );
LONG lRegGetIdSz     ( IN HANDLE hDriver, IN DWORD dwID,      OUT PSTR   pstrData, IN DWORD nByte );
LONG lRegGetIdMultiSz( IN HANDLE hDriver, IN DWORD dwID,      OUT PSTR   pstrData, IN DWORD nByte );

LONG lRegSetIdBinary ( IN HANDLE hDriver, IN DWORD dwID, const IN BYTE  *pjData,   IN DWORD nByte );
LONG lRegSetIdDWord  ( IN HANDLE hDriver, IN DWORD dwID,       IN DWORD  ulData );
LONG lRegSetIdSz     ( IN HANDLE hDriver, IN DWORD dwID, const IN PSTR   pstrData);
LONG lRegSetIdMultiSz( IN HANDLE hDriver, IN DWORD dwID, const IN PSTR   pstrData, IN DWORD nByte );

#endif // USE_WKS_ELSA_TOOLS
#endif // _WKSELSATOOLSREGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv1blit.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV1BLIT.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated Blt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        .list

        .data

;
;  stack based params and local variables
;

NV1_TRANSFER_BLITDATA_STRUC          struc

; Feel free to add any local variables here:

NV1TBDS_RightCase            dd      ?
NV1TBDS_pjSrcScan            dd      ?
NV1TBDS_SrcIntStep           dd      ?
NV1TBDS_DstStride            dd      ?
NV1TBDS_XCount               dd      ?
NV1TBDS_yDst                 dd      ?
NV1TBDS_pdev                 dd      ?

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

NV1TBDS_ebp                  dd      ?
NV1TBDS_esi                  dd      ?
NV1TBDS_edi                  dd      ?
NV1TBDS_ebx                  dd      ?
NV1TBDS_RetAddr              dd      ?
NV1TBDS_BytesPerDstScan      dd      ?
NV1TBDS_FreeCountPtr         dd      ?
NV1TBDS_Height               dd      ?
NV1TBDS_NextScanPtr          dd      ?
NV1TBDS_ScanInc              dd      ?
NV1TBDS_NvChannelPtr         dd      ?

NV1_TRANSFER_BLITDATA_STRUC          ends

NV1_TRANSFER_BLITDATA_PARM_SIZE     equ     11 * 4

;*******************************************************************************
; Defines for NV Hardware
; Currently, channels are used as follows:
;   IMAGE_FROM_CPU          Channel 0
;   BLIT                    Channel 1
;   IMAGE_MONO_FROM_CPU     Channel 2
;   RECTANGLE               Channel 3
;   ROP_SOLID               Channel 4
;   IMAGE_PATTERN           Channel 5
;   CLIP                    Channel 6
;   IMAGE_SOLID             Channel 7
;*******************************************************************************

IMAGE_FROM_CPU_FREECOUNT           equ    ( (0*8192) + 16 )
BLIT_FREECOUNT                     equ    ( (1*8192) + 16 )
IMAGE_MONO_FROM_CPU_FREECOUNT      equ    ( (2*8192) + 16 )
RECTANGLE_FREECOUNT                equ    ( (3*8192) + 16 )
ROP_SOLID_FREECOUNT                equ    ( (4*8192) + 16 )
IMAGE_PATTERN_FREECOUNT            equ    ( (5*8192) + 16 )
CLIP_FREECOUNT                     equ    ( (6*8192) + 16 )
IMAGE_SOLID_FREECOUNT              equ    ( (7*8192) + 16 )


IMAGE_FROM_CPU_DATA_0      equ    ( (0*8192) + 400h )
IMAGE_FROM_CPU_DATA_1      equ    ( (0*8192) + 404h )
IMAGE_FROM_CPU_DATA_2      equ    ( (0*8192) + 408h )
IMAGE_FROM_CPU_DATA_3      equ    ( (0*8192) + 40ch )
IMAGE_FROM_CPU_DATA_4      equ    ( (0*8192) + 410h )
IMAGE_FROM_CPU_DATA_5      equ    ( (0*8192) + 414h )
IMAGE_FROM_CPU_DATA_6      equ    ( (0*8192) + 418h )
IMAGE_FROM_CPU_DATA_7      equ    ( (0*8192) + 41ch )
IMAGE_FROM_CPU_DATA_8      equ    ( (0*8192) + 420h )
IMAGE_FROM_CPU_DATA_9      equ    ( (0*8192) + 424h )
IMAGE_FROM_CPU_DATA_10     equ    ( (0*8192) + 428h )
IMAGE_FROM_CPU_DATA_11     equ    ( (0*8192) + 42ch )
IMAGE_FROM_CPU_DATA_12     equ    ( (0*8192) + 430h )
IMAGE_FROM_CPU_DATA_13     equ    ( (0*8192) + 434h )
IMAGE_FROM_CPU_DATA_14     equ    ( (0*8192) + 438h )
IMAGE_FROM_CPU_DATA_15     equ    ( (0*8192) + 43ch )
IMAGE_FROM_CPU_DATA_16     equ    ( (0*8192) + 440h )
IMAGE_FROM_CPU_DATA_17     equ    ( (0*8192) + 444h )
IMAGE_FROM_CPU_DATA_18     equ    ( (0*8192) + 448h )
IMAGE_FROM_CPU_DATA_19     equ    ( (0*8192) + 44ch )
IMAGE_FROM_CPU_DATA_20     equ    ( (0*8192) + 450h )
IMAGE_FROM_CPU_DATA_21     equ    ( (0*8192) + 454h )
IMAGE_FROM_CPU_DATA_22     equ    ( (0*8192) + 458h )
IMAGE_FROM_CPU_DATA_23     equ    ( (0*8192) + 45ch )
IMAGE_FROM_CPU_DATA_24     equ    ( (0*8192) + 460h )
IMAGE_FROM_CPU_DATA_25     equ    ( (0*8192) + 464h )
IMAGE_FROM_CPU_DATA_26     equ    ( (0*8192) + 468h )
IMAGE_FROM_CPU_DATA_27     equ    ( (0*8192) + 46ch )
IMAGE_FROM_CPU_DATA_28     equ    ( (0*8192) + 470h )
IMAGE_FROM_CPU_DATA_29     equ    ( (0*8192) + 474h )
IMAGE_FROM_CPU_DATA_30     equ    ( (0*8192) + 478h )
IMAGE_FROM_CPU_DATA_31     equ    ( (0*8192) + 47ch )

        .code

;---------------------------Public-Routine------------------------------;
;
;-----------------------------------------------------------------------;

        public NV1_Transfer_MemToScreen_Data@24


NV1_Transfer_MemToScreen_Data@24 proc near

        ;**********************************************************************
        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;
        ;**********************************************************************

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV1_TRANSFER_BLITDATA_STRUC) - NV1_TRANSFER_BLITDATA_PARM_SIZE  ; make room for local variables

        ;**********************************************************************
        ; Register Usage:
        ;   ebp = Ptr to NV User Channel
        ;   eax = Dwords remaining in current scanline
        ;   ebx = Current scanline (reverse index)
        ;   ecx = Used by Rep Mov string copy
        ;   edx = Current Free Count
        ;   esi = Ptr to Image data
        ;   edi = Ptr to data array in user channel
        ;**********************************************************************

        mov     ebp,[esp].NV1TBDS_NvChannelPtr      ; Get pointer to NV channel
        add     ebp,IMAGE_FROM_CPU_DATA_0           ; EDI ptr to data array in user channel
        mov     ebx,[esp].NV1TBDS_Height            ; Number of scanlines to output
        mov     edx,[esp].NV1TBDS_FreeCountPtr      ; Ptr to current cached free count
        movzx   edx,word ptr [edx]                  ; Get current free count
        cld                                         ; Default to going forward

        ;**********************************************************************
        ; Make sure there are scanlines to output
        ;**********************************************************************

        cmp     ebx,0                               ; Make sure we have data to output
        jle     NV1TBD_Done                         ; Otherwise just quit

        ;**********************************************************************
        ; Main loop
        ;**********************************************************************


NV1TBD_Scanline_Loop:

        mov     esi,[esp].NV1TBDS_NextScanPtr       ; Ptr to image data
        mov     eax,[esp].NV1TBDS_BytesPerDstScan   ; Number of DWORDS per scanline

        ;**********************************************************************
        ;
        ; Output 31 Dwords at a time
        ;
        ;**********************************************************************

NV1TBD_Check_For_31Dwords:

        cmp     eax,31*4                            ; Q: Any more Dwords to output?
        jb      short NV1TBD_Check_For_16Dwords     ;  N: Less than 31 dwords remaining

NV1TBD_31Dwords_Chk_FreeCount:

        cmp     edx,31*4                            ; Q: Enough room to output 31 dwords?
        jae     short NV1TBD_31Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_31Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_31Dwords_Chk_FreeCount ; Check if FIFO is ready yet

NV1TBD_31Dwords_UpdateFreeCount:

        sub     edx,31*4                            ; Update cached freecount

NV1TBD_31Dwords_SendData:

        mov     ecx,31                              ; 16 dwords
        mov     edi,ebp                             ; ESI pts to source image data
        rep     movsd                               ; Copy 16 dwords
        sub     eax,31*4                            ; Decrement number of bytes we've done
        jmp     short NV1TBD_Check_For_31Dwords     ; Loop thru remaining data



        ;**********************************************************************
        ;
        ; Output 16 Dwords at a time
        ;
        ;**********************************************************************

NV1TBD_Check_For_16Dwords:

        cmp     eax,16*4                            ; Q: Any more Dwords to output?
        jb      short NV1TBD_Check_For_8Dwords      ;  N: Less than 16 dwords remaining

NV1TBD_16Dwords_Chk_FreeCount:

        cmp     edx,16*4                            ; Q: Enough room to output 16 dwords?
        jae     short NV1TBD_16Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_16Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_16Dwords_Chk_FreeCount ; Check if FIFO is ready yet

NV1TBD_16Dwords_UpdateFreeCount:

        sub     edx,16*4                            ; Update cached freecount

NV1TBD_16Dwords_SendData:

        mov     ecx,16                              ; 16 dwords
        mov     edi,ebp                             ; ESI pts to source image data
        rep     movsd                               ; Copy 16 dwords
        sub     eax,16*4                            ; Decrement number of bytes we've done
        jmp     short NV1TBD_Check_For_16Dwords     ; Loop thru remaining data


        ;**********************************************************************
        ;
        ; Output 8 Dwords at a time
        ;
        ;**********************************************************************

NV1TBD_Check_For_8Dwords:

        cmp     eax,8*4                             ; Q: Any more Dwords to output?
        jb      short NV1TBD_Check_For_4Dwords      ;  N: Less than 8 dwords remaining

NV1TBD_8Dwords_Chk_FreeCount:

        cmp     edx,8*4                             ; Q: Enough room to output 8 dwords?
        jae     short NV1TBD_8Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_8Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_8Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV1TBD_8Dwords_UpdateFreeCount:

        sub     edx,8*4                             ; Update cached freecount

NV1TBD_8Dwords_SendData:

        mov     ecx,8                               ; 8 dwords
        mov     edi,ebp                             ; ESI pts to source image data
        rep     movsd                               ; Copy 8 dwords
        sub     eax,8*4                             ; Decrement number of bytes we've done
        jmp     short NV1TBD_Check_for_8Dwords      ; Loop thr remaining data


        ;**********************************************************************
        ;
        ; Output 4 Dwords at a time
        ;
        ;**********************************************************************

NV1TBD_Check_For_4Dwords:

        cmp     eax,4*4                             ; Q: Any more Dwords to output?
        jae     short NV1TBD_4Dwords_Chk_FreeCount  ;  Y: Output remaining dwords
        jmp     short NV1TBD_Check_For_1Dwords      ;  N: Less than 4 dwords remaining

NV1TBD_4Dwords_Chk_FreeCount:

        cmp     edx,4*4                             ; Q: Enough room to output 4 dwords?
        jae     short NV1TBD_4Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_4Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_4Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV1TBD_4Dwords_UpdateFreeCount:

        sub     edx,4*4                             ; Update cached freecount

NV1TBD_4Dwords_SendData:

        mov     ecx,4                               ; 4 dwords
        mov     edi,ebp                             ; ESI pts to source image data
        rep     movsd                               ; Copy 4 dwords
        sub     eax,4*4                             ; Decrement number of bytes we've done
        jmp     short NV1TBD_Check_for_4Dwords      ; Loop thr remaining data

        ;**********************************************************************
        ;
        ; Output 1 Dword at a time
        ;
        ;**********************************************************************


NV1TBD_Check_For_1Dwords:

        cmp     eax,4                               ; Q: Any more Dwords to output?
        jb      short NV1TBD_Check_For_Pad          ;  N: Check for pad bytes

NV1TBD_1Dwords_Chk_FreeCount:

        cmp     edx,4*3                             ; Q: Assume worst case 3 dwords
        jae     short NV1TBD_1Dwords_UpdateFreeCount;  Y: Send the data

NV1TBD_1Dwords_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_1Dwords_Chk_FreeCount  ; Check if FIFO is ready yet

NV1TBD_1Dwords_UpdateFreeCount:
        mov     ecx,eax                             ; Get number of bytes
        shr     ecx,2                               ; div 4 = # dwords
        shl     ecx,2                               ; Convert to div4 num bytes
        sub     edx,ecx                             ; Update cached freecount, ASSUME
        sub     eax,ecx
        shr     ecx,2                               ; Back to num dwords

NV1TBD_1Dwords_SendData:

        mov     edi,ebp                             ; EDI ptr to data array in user channel
        rep     movsd                               ; Copy remaining dwords

NV1TBD_Check_For_Pad:
        or      eax,eax                             ; Any bytes left?
        jbe     NV1TBD_Advance_Scanline             ; N, go to next scan

NV1TBD_Pad_Bytes_Chk_FreeCount:

        cmp     edx,1*4                             ; Q: Assume worst case 1 dword
        jae     short NV1TBD_Pad_Bytes_UpdateFreeCount;  Y: Send the data

NV1TBD_Pad_Bytes_WaitForEngine:

        movzx   edx,Word Ptr [ebp+IMAGE_FROM_CPU_FREECOUNT-IMAGE_FROM_CPU_DATA_0] ; Get freecount from hardware
        jmp     short NV1TBD_Pad_Bytes_Chk_FreeCount  ; Check if FIFO is ready yet

NV1TBD_Pad_Bytes_UpdateFreeCount:

        sub     edx,1*4                             ; Update cached freecount, ASSUME
                                                    ; WORST CASE 1 dword sent

NV1TBD_Pad_Bytes_SendData:

        mov     ecx,eax                             ; Finish off remaining bytes

NV1TBD_Pad_Bytes_Get_Next:
        lodsb
        dec     ecx
        or      ecx,ecx                             ; Done yet?
        jz      NV1TBD_Send_Pad_Bytes
        xchg    ah,al                               ; Save last byte
        lodsb                                       ; Get next byte
        xchg    ah,al                               ; Restore byte order
        dec     ecx
        or      ecx,ecx                             ; Done yet?
        jz      NV1TBD_Send_Pad_Bytes
        mov     cl,byte ptr [esi]
        shl     ecx,16
        or      eax,ecx                             ; EAX = pad byte(s)

NV1TBD_Send_Pad_Bytes:
        mov     edi,ebp                             ; EDI ptr to data array in user channel
        stosd                                       ; Copy pad bytes

        ;**********************************************************************
        ; Advance to next scanline
        ;**********************************************************************

NV1TBD_Advance_Scanline:

        dec     ebx                                 ; Next scanline
        jz      short NV1TBD_Done                   ; Check if we're done
        mov     eax,[esp].NV1TBDS_ScanInc           ; Get number of bytes to advance src
        shl     eax,2                               ; Convert dwords to bytes
        add     [esp].NV1TBDS_NextScanPtr,eax       ; Next src scanline
        jmp     NV1TBD_Scanline_Loop                ; Loop thru entire image

        ;**********************************************************************
        ; All done, restore stack and return to caller
        ;**********************************************************************

NV1TBD_Done:

        mov     eax,[esp].NV1TBDS_FreeCountPtr      ; Make sure to update
        mov     word ptr [eax],dx                   ;   cached free count

        add     esp,(size NV1_TRANSFER_BLITDATA_STRUC) - NV1_TRANSFER_BLITDATA_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     24

NV1_Transfer_MemToScreen_Data@24 endp



end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\nv4text.asm ===
;******************************* Module Header *********************************
;
; Module Name: NV4TEXT.ASM
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated text blt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        .list

FALSE                       EQU 0
TRUE                        EQU 1
LLNULL                      EQU 0ff00ff00h
FONT_REJECTED_TAG           EQU 0ffffffffh
FONTFIXEDPITCHSHIFT         EQU 7
FONTFIXEDPITCH              EQU 1 SHL FONTFIXEDPITCHSHIFT
MAXFONTCACHESIZE            EQU FONTFIXEDPITCH * MAXGLYPHS
MAXGLYPHSIZE                EQU (FONTFIXEDPITCH-4)
MAXGLYPHS                   EQU 256
MAXGLYPHINDEX               EQU 255
MAXFONTS                    EQU 16

FontCacheInfoStruc struc

    FontCacheId         dd  LLNULL
    FontPitchAndOffset  dd  LLNULL
    pFontInfoPrev       dd  LLNULL
    pFontInfoNext       dd  LLNULL
    FontCacheGlyphInfo  dd  MAXGLYPHS dup (0)

FontCacheInfoStruc ends

FONTCACHEINFOHEADERSIZE EQU 16      ; size of first 4 DWORDS in FontCachInfoStruc
                                    ; before glyph data

        .data

LRUFontInfoNode         dd  LLNULL
MRUFontInfoNode         dd  LLNULL


; Remove structure since font caching is turned off. This buffer should be
; allocated at initialization instead of here anyway.
;
;FontCacheInfo           db (MAXFONTS * sizeof(FontCacheInfoStruc)) dup (0)
FontCacheInfo           dd ?

;
;  stack based params and local variables
;


NV4_DrawFastGlyphs_STRUC          struc

; Feel free to add any local variables here:

gWidth                  dd      ?
localNvDmaCount         dd      ?
localNvDmaFifoPtr       dd      ?
missingGlyphFlag        dd      ?
numBytesPerScan         dd      ?
numDwordsPerGlyph       dd      ?
originalPgpParm         dd      ?
ptlOriginx              dd      ?   ;PointL
ptlOriginy              dd      ?
clipRight               dd      ?
clipBottom              dd      ?
saveESI                 dd      ?
saveEDX                 dd      ?
saveGlyphCount          dd      ?
saveNvDmaCount          dd      ?
savePgp                 dd      ?
savePpdev               dd      ?
ulCharIncLocal          dd      ?
fontInfoBuffer          db      (size FONTINFO) dup (?)

; Don't add any fields below here without modifying XXX_STRUC_SIZE!

DFG_ebp                 dd      ?
DFG_esi                 dd      ?
DFG_edi                 dd      ?
DFG_ebx                 dd      ?
DFG_RetAddr             dd      ?
pso                     dd      ?
pstro                   dd      ?
pfo                     dd      ?
prclClip                dd      ?
pgpParm                 dd      ?
glyphCount              dd      ?

NV4_DrawFastGlyphs_STRUC          ends

NV4_DrawFastGlyphs_PARM_SIZE     equ     11 * 4


        .code

extrn       FONTOBJ_vGetInfo@12:NEAR
extrn       NV_DmaPush_Wrap@8:NEAR
extrn       NV_DmaPush_CheckWrapped@8:NEAR


;******************************************************************************
;
;   CheckDMAFreeCount - Get current free count in DMA buffer. If not enough
;       space, then calls Vidal's routines to make sure there is room in
;       the DMA buffer. Then gets new DMA buffer free count. This routine is
;       similar to the NV_DMAPUSH_CHECKFREE C macro.
;
;   NOTE: requires ppdev.nvDmaCount to equal local nvDmaCount
;
;   INPUT:  EBP - stack pointer
;           ECX - number of DWORDS needed in DMA buffer
;   OUTPUT: EAX = free count
;           updates localNvDmaCount when ppdev->nvDmaCount is updated
;
;******************************************************************************

align 4

CheckDMAFreeCount   proc

        mov     ebx, [ebp].savePpdev        ; ppdev
        mov     edx, [ebx].nvDmaCount       ; ppdev->nvDmaCount
        cmp     [ebx].nvDmaWrapFlag, FALSE
        jne     short CheckDmaWrapped

    ;*************************************************************************
    ; WRAP_FLAG = FALSE. Check if we need to wrap around.
    ;
    ; EBX - ppdev
    ; EBP - stack pointer
    ; ECX - number of DWORDS needed in DMA buffer
    ; EDX - nvDmaCount
    ;
    ;*************************************************************************

        mov     eax, [ebx].DmaPushBufCanUseSize ;
        sub     eax, edx                    ; less current nvDmaCount
        sub     eax, ecx                    ; less number of DWORDS needed
        jl      GoWrapDmaBuffer
        
        mov     [ebx].nvDmaCachedFreeCount, eax
        ret                                 ; enough room - return new freecount

    ;*************************************************************************
    ; Need to wrap.
    ;
    ; EBX - ppdev
    ; EBP - stack pointer
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

GoWrapDmaBuffer:
        push    ecx                         ; save dwords needed
        push    ecx                         ; DWORDS needed - parameter
        push    ebx                         ; ppdev - parameter
        call    NV_DmaPush_Wrap@8           ; (ppdev, DWORDS_NEEDED)
        pop     ecx                         ; restore dwords needed
        mov     ebx, [ebp].savePpdev
        mov     edx, [ebx].nvDmaCount
        mov     [ebp].localNvDmaCount, edx  ; update local nvDmaCount

CheckDMADone:
        mov     [ebx].nvDmaCachedFreeCount, 0
        ret

    ;*************************************************************************
    ; WRAP_FLAG = TRUE. We are currently wrapped around (DMA count < Get Ptr)
    ;
    ; EBX - ppdev
    ; EBP - stack pointer
    ; ECX - number of DWORDS needed in DMA buffer
    ;
    ;*************************************************************************

CheckDmaWrapped:

        push    ecx                         ; save dwords needed
        push    ecx                         ; DWORDS needed - parameter
        push    ebx                         ; ppdev - parameter
        call    NV_DmaPush_CheckWrapped@8   ; (ppdev, DWORDS_NEEDED)
        pop     ecx                         ; restore dwords needed
        mov     ebx, [ebp].savePpdev
        mov     edx, [ebx].nvDmaCount
        mov     [ebp].localNvDmaCount, edx  ; update local nvDmaCount
        mov     [ebx].nvDmaCachedFreeCount, 0
        ret

CheckDMAFreeCount   endp


;******************************************************************************
;
;   NV4_DrawFastGlyphs
;
;   SURFOBJ*    pso
;   STROBJ*     pstro
;   FONTOBJ*    pfo
;   RECTL*      prclClip
;   GLYPHPOS*   pgpParm
;   ULONG       glyphCount
;
;******************************************************************************

align 4
        public NV4_DrawFastGlyphs@24

NV4_DrawFastGlyphs@24 proc near

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size NV4_DrawFastGlyphs_STRUC) - NV4_DrawFastGlyphs_PARM_SIZE
        cld

        mov     ebx, [esp].pso
        mov     ecx, 6                      ; overhead for caching string
        mov     ebx, [ebx].dhpdev           ; pso->dhpdev points to pdev
        mov     esi, [ebx].nvDmaCount       ; ppdev->nvDmaCount
        mov     eax, [ebx].nvDmaFifo
        mov     [esp].savePpdev, ebx
        mov     [esp].localNvDmaCount, esi   ; save local copy
        mov     [esp].localNvDmaFifoPtr, eax ; save local copy

    ;*************************************************************************
    ; Get current free count in DMA buffer.
    ;
    ; NOTE: requires ppdev.nvDmaCount to equal local nvDmaCount
    ;
    ; INPUT:  EBP - stack pointer
    ;         ECX - number of DWORDS needed in DMA buffer
    ; OUTPUT: EAX = free count
    ;         updates localNvDmaCount when ppdev->nvDmaCount is updated
    ;
    ;*************************************************************************

        add     ecx, [esp].glyphCount       ; number of glyphs + overhead for push buffer check
        mov     ebp, esp
        call    CheckDMAFreeCount           ; gets free count
        mov     ebx, [esp].savePpdev
        mov     eax, [esp].pstro
        mov     edi, [eax].ulCharInc        ; space between glyphs if non-zero
        mov     [esp].ulCharIncLocal, edi   ; save glyph increment

    ;*************************************************************************
    ;
    ; Clip rectangle
    ;
    ; CLIP_POINT0_C = prclClip->top << 16 | prclClip->left
    ; CLIP_POINT1_C = prclClip->bottom <<16 | prclClip->right
    ;
    ; For bottom right, use MIN(prclClip->bottom, MAX_CX_CY_MEMORY_VALUE) << 16 ||
    ;                       MIN(prclClip->right,  ppdev->cxScreen)
    ;
    ; This is necessary because the bottom and right values in the clipping
    ; rectangle are sometimes too large for the current frame buffer and these
    ; values screw up the hardware.
    ;       
    ; EBX - ppdev
    ;
    ;*************************************************************************

        mov     ecx, [esp].localNvDmaCount
        shl     ecx, 2                      ; offset into DMA buffer
        mov     esi, [esp].localNvDmaFifoPtr
        mov     eax, [esp].prclClip

        mov     [esi+ecx], RECT_AND_TEXT_SUBCHANNEL OR NV04A_CLIP_POINT0_C OR (2 SHL 18)

        mov     edx, [eax].ytop             ; prclClip->top
        mov     edi, [eax].xleft            ; prclClip->left
        shl     edx, 16                     ; prclClip->top << 16
        and     edi, 0ffffh
        or      edx, edi

        mov     [esi+ecx+4], edx            ; NV04A_CLIP_POINT0_C

    ;*************************************************************************
    ;
    ; Clip right, bottom
    ;
    ; EAX - prclClip
    ; EBX - ppdev
    ; ECX - localNvDmaCount*4
    ; ESI - nvDmaFifo
    ;
    ;*************************************************************************

        mov     edi, [eax].xright           ; prclClip->right
        mov     edx, [eax].ybottom          ; prclClip->bottom
        cmp     edi, [ebx].cxScreen
        jl      @f
        
        mov     edi, [ebx].cxScreen
@@:
        mov     [esp].clipRight, edi        ; save right clip for later checking
        
        cmp     edx, MAX_CX_CY_MEMORY_VALUE
        jl      @f
        
        mov     edx, MAX_CX_CY_MEMORY_VALUE
@@:
        mov     [esp].clipBottom, edx       ; save bottom clip for later checking
        shl     edx, 16
        and     edi, 0ffffh
        or      edx, edi
        mov     [esi+ecx+8], edx            ; NV04A_CLIP_POINT1_C

        add     ecx, 12                     ; number of bytes written to DMA buffer
        shr     ecx, 2                      ; convert to dwords
        mov     [esp].localNvDmaCount, ecx  ; update local nvDmaCount
        mov     [esp].saveNvDmaCount, ecx   ; save buffer pointer here in case
                                            ; need to back up if invalid text data
        mov     eax, [esp].pgpParm
        mov     [esp].originalPgpParm, eax  ; save starting pgp

        cmp     [ebx].fontCacheEnabled, FALSE ; if caching turned off
        je      DrawGlyphsWithoutCache      ; then draw glyphs without caching

    ;*************************************************************************
    ; Find the font in the FontCacheInfo table if it exists.
    ;*************************************************************************

        mov     [esp].missingGlyphFlag, FALSE
        mov     edx, [esp].pfo               ; Font object
        mov     ebx, [edx].pvConsumer        ; check if font has been cached
        cmp     ebx, FONT_REJECTED_TAG       ; can't cache this font
        je      DrawGlyphsWithoutCache       ; draw glyphs the old way

        or      ebx, ebx                     ; if zero then not cached
        je      CacheNewFont                 ; so cache font

    ;*************************************************************************
    ; EBX = offset to FontCacheInfo entry
    ;*************************************************************************

        mov     eax, [ebx].FontCacheId       ; font handle
        cmp     eax, [edx].iUniq             ; pfo.iUniq = font handle
        jne     CacheFontAgain               ; font was bumped - cache again

    ;*************************************************************************
    ; Found the font in cache.  Update the MRU and LRU font info linkedlist
    ;
    ; EBX - pointer to FontCacheInfo entry for this font
    ;
    ;*************************************************************************

CachedFontFound:

        cmp     ebx, LRUFontInfoNode
        jne     MakeFontMRU                 ; if we are not in LRU then don't worry

        mov     edi, [ebx].pFontInfoPrev    ; CurFontInfo at LRU.  Remove it
        test    edi, edi
        js      OutputCachedFont            ; current font is only font in linked list

        mov     LRUFontInfoNode, edi
        mov     [edi].pFontInfoNext, LLNULL ; null for linked list

MakeFontMRU:
        cmp     ebx, MRUFontInfoNode
        je      OutputCachedFont            ; done if MRU font ptr is correct

        mov     esi, [ebx].pFontInfoPrev    ; esi  = CurFontInfo->Prev
        mov     edi, [ebx].pFontInfoNext    ; edi  = CurFontInfo->Next
        mov     [esi].pFontInfoNext, edi    ; CurFontInfo->Prev->Next
                                            ;     = CurFontInfo->Next
        test    edi, edi
        js      short @f
        mov     [edi].pFontInfoPrev, esi    ; CurFontInfo->Next->Prev
                                            ;     = CurFontInfo->Prev
@@:
        mov     esi, MRUFontInfoNode        ; Update MRU list
        mov     MRUFontInfoNode, ebx
        mov     [ebx].pFontInfoNext, esi    ; CurFontInfo->Next = OldMRUFontInfo
        mov     [ebx].pFontInfoPrev, LLNULL ; CurFontInfo->Prev = NULL
        mov     [esi].pFontInfoPrev, ebx    ; points to new MRU

    ;*************************************************************************
    ; EBX - ptr to FontCacheInfo entry for current font
    ;*************************************************************************

OutputCachedFont:

        mov     esi, [esp].localNvDmaFifoPtr
        mov     edi, [esp].localNvDmaCount
        shl     edi, 2
        add     esi, edi                    ; nvDmaFifo[nvDmaCount]
        mov     eax, [ebx].FontPitchAndOffset
        mov     dword ptr [esi], RECT_AND_TEXT_SUBCHANNEL OR NV04A_FONTF OR (1 SHL 18)
        mov     [esi+4], eax                ; set font info

        mov     eax, [esp].glyphCount       ; number of glyphs to draw
        shl     eax, 18                     ; bits 31:18 had glyph count
        or      eax, RECT_AND_TEXT_SUBCHANNEL OR NV04A_CHARACTER_COLOR1_F
        mov     [esi+8], eax                ; number of dwords to send
        add     esi, 12                     ; update nvDmaCount

    ;*************************************************************************
    ;
    ; EBX - ptr to FontCacheInfo entry for current font
    ;*************************************************************************

        mov     eax, [esp].pgpParm
        mov     ecx, [esp].pstro
        mov     edi, [eax].gp_x             ; pgp->ptl.x
        mov     edx, [eax].gp_y             ; pgp->ptl.y

        shl     edi, 8
        shl     edx, 20
        and     edi, 0fff00h                ; shouldn't be necessary, but just in case
        or      edx, edi                    ; y bits 31:20, x bits 19:8

        add     ebx, FONTCACHEINFOHEADERSIZE

;*****************************************************************************
;
; Loop through all the unclipped glyphs for this string with caching
;
; EAX - pgp
; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
; ESI - ptr to nvDmaFifo[nvDmaCount]
;
;*****************************************************************************

CachedGlyphWhichLoop:
        mov     edi, [esp].glyphCount       ; number of glyphs in string
        cmp     [esp].ulCharIncLocal, 0
        jnz     CachedGlyphFixedLoop        ; ulCharInc is used for glyph positions

    ;*************************************************************************
    ;
    ; Loop through all glyphs. Glyph positions are not fixed, that is, ulCharInc
    ; is zero and the pgp contains the glyph spacing.
    ;
    ;*************************************************************************

CachedGlyphLoop:

    ;*************************************************************************
    ; Get the size (in pixels) of the monochrome bitmap and
    ; get pointer to BYTE aligned glyph bitmap
    ;*************************************************************************

        mov     ecx, [eax].gp_hg            ; glyph index in pgp
        cmp     ecx, MAXGLYPHINDEX
        jg      NotValidGlyph

        mov     ecx, [ebx+ecx*4]            ; saved XY and glyph index
        cmp     ecx, LLNULL                 ; if null
        je      LoadMissingGlyphsToCache    ; then need to load glyph

        add     ecx, edx                    ; add the glyph based XY org
        add     eax, (size GLYPHPOS)        ; pgp++
        mov     [esi], ecx                  ; output glyph from cache
        add     esi, 4                      ; nvDmaFifoPtr++

    ;*************************************************************************
    ; Check for more glyphs in string
    ;*************************************************************************

        dec     edi                         ; more glyphs to draw?
        jle     DrawCachedGlyphsDone        ; no - exit

    ;*************************************************************************
    ; Update to next glyph and update to next x and y value
    ;
    ; EAX - pgp
    ; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
    ; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
    ; EDI - number of glyphs in string
    ; ESI - ptr to nvDmaFifo[nvDmaCount]
    ;
    ;*************************************************************************

        mov     ecx, [eax].gp_x             ; pgp->ptl.x
        mov     edx, [eax].gp_y             ; pgp->ptl.y
        shl     ecx, 8
        shl     edx, 20
        and     ecx, 0fff00h                ; shouldn't be necessary, but just in case
        or      edx, ecx
        jmp     CachedGlyphLoop             ; yes - continue with next glyph

    ;*************************************************************************
    ; Update DMA buffer
    ;
    ; ESI - ptr to nvDmaFifo[nvDmaCount]
    ;
    ;*************************************************************************

DrawCachedGlyphsDone:
        sub     esi, [esp].localNvDmaFifoPtr
        shr     esi, 2
        mov     [esp].localNvDmaCount, esi  ; update nvDmaCount
        jmp     DrawGlyphsDone

;*****************************************************************************
;
; Loop through all the unclipped glyphs for this string with caching. Use
; ulCharInc to position each glyph in string
;
; EAX - pgp
; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
; EDI - number of glyphs in string
; ESI - ptr to nvDmaFifo[nvDmaCount]
;
;*****************************************************************************

CachedGlyphFixedLoop:

    ;*************************************************************************
    ; Get the size (in pixels) of the monochrome bitmap and
    ; get pointer to BYTE aligned glyph bitmap
    ;*************************************************************************

        mov     ecx, [eax].gp_hg            ; glyph index in pgp
        cmp     ecx, MAXGLYPHINDEX
        jg      NotValidGlyph

        mov     ecx, [ebx+ecx*4]            ; saved XY and glyph index
        cmp     ecx, LLNULL                 ; if null
        je      LoadMissingGlyphsToCache    ; then need to load glyph

        add     ecx, edx                    ; add the glyph based XY org
        mov     [esi], ecx                  ; output glyph from cache
        add     esi, 4                      ; nvDmaFifoPtr++

    ;*************************************************************************
    ; Check for more glyphs in string
    ;*************************************************************************

        dec     edi                         ; more glyphs to draw?
        jle     DrawCachedGlyphsDone        ; no - exit

    ;*************************************************************************
    ; Update to next glyph and update to next x and y value
    ;
    ; EAX - pgp
    ; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
    ; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
    ; EDI - number of glyphs in string
    ; ESI - ptr to nvDmaFifo[nvDmaCount]
    ;
    ;*************************************************************************

        add     eax, (size GLYPHPOS)
        mov     ecx, [esp].ulCharIncLocal
        shl     ecx, 8
        add     edx, ecx                    ; if ulCharInc is non-zero
                                            ; then ptlOrigin.x += ulCharInc
        jmp     CachedGlyphFixedLoop        ; continue with next glyph

;*****************************************************************************
;
; Glyph has not been cached, so update current DMA pointers in case caching is
; aborted and try to cache rest of glyphs now.
;
; EAX - pgp
; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
; EDX - destination x and y in hardware format: Y bits 31:20, X bits 19:8
; EDI - number of glyphs left to draw
; ESI - ptr to nvDmaFifo[nvDmaCount]
;
;*****************************************************************************

LoadMissingGlyphsToCache:

        sub     ebx, FONTCACHEINFOHEADERSIZE
        mov     [esp].pgpParm, eax          ; save current pgp
        mov     [esp].glyphCount, edi       ; update number of glyphs left
        mov     [esp].saveESI, esi          ; DMA pointer
        mov     [esp].saveEDX, edx          ; destination x and y position

        mov     edi, [ebx].FontPitchAndOffset
        mov     [esp].missingGlyphFlag, TRUE
        and     edi, 0fffffffh              ; clear pitch
        jmp     LoadGlyphsToCache

;******************************************************************************
;
; Font is not cached because it is new. Check if we can fit the font into
; the offscreen memory cache.
;
; EDX - pfo - pointer to font object
;
;******************************************************************************

align 4

CacheNewFont:

        lea     ebx, [esp].fontInfoBuffer
        mov     ecx, size FONTINFO
        push    ebx                         ; &fontInfo
        push    ecx                         ; size (FONTINFO)
        push    edx                         ; pfo
        call    FONTOBJ_vGetInfo@12         ; FONTOBJ_vGetInfo (pfo, cjSize, pfontInfo)

        lea     eax, [esp].fontInfoBuffer
        mov     edx, [esp].pfo
        mov     ecx, [eax].cjMaxGlyph1
        cmp     ecx, MAXGLYPHSIZE
        jle     LoadFontToCache

        mov     [edx].pvConsumer, FONT_REJECTED_TAG
        jmp     DrawGlyphsWithoutCache

    ;**************************************************************************
    ;
    ; Font is not cached, either because it is new or because it was bumped from
    ; the cache. So if we can cache the font, load it to offscreen memory.
    ;
    ; First, an entry in our FontCacheInfo table. If the FontCacheInfo table
    ; is full, the LRU font is freed to make room for the new font.
    ;
    ;  EDX - pfo - pointer to font object
    ;
    ;**************************************************************************

align 4

CacheFontAgain:
LoadFontToCache:

        mov     ebx, offset FontCacheInfo
        xor     ecx, ecx
        mov     eax, LLNULL                 ; NULL

FindFreeEntry:
        cmp     eax, [ebx].FontCacheID      ; if not null
        jne     ContinueLookingForEntry     ; then keep looking

    ;*************************************************************************
    ; Found empty entry in table
    ;
    ;  EBX = ptr of FontCacheInfo entry
    ;  ECX = index in FontCacheInfo table
    ;
    ;*************************************************************************

GotFontCacheInfo:

        mov     esi, [esp].savePpdev
        mov     eax, MAXFONTCACHESIZE
        imul    eax, ecx
        mov     edi, [esi].fontCacheOffset
        add     edi, eax
        mov     eax, LLNULL
        jmp     GotFontCacheOffset

ContinueLookingForEntry:
        inc     ecx
        add     ebx, (size FontCacheInfoStruc)  ; each entry is fixed (256 DWORDS)
        cmp     ecx, MAXFONTS
        jl      short FindFreeEntry

    ;*************************************************************************
    ; Free LRU font and initialize font info entry to empty
    ;
    ;  EAX = LLNULL - null for font info structure and linked list 0ff00ff00h
    ;
    ;*************************************************************************

        mov     ebx, LRUFontInfoNode
        mov     edi, ebx                            ; init the font entry to empty
        mov     esi, [ebx].pFontInfoPrev
        mov     [esi].pFontInfoNext, eax            ; set to LLNULL
        mov     LRUFontInfoNode, esi
        mov     ebp, [ebx].FontPitchAndOffset       ; save font offset for reuse

        mov     ecx, ((size FontCacheInfoStruc)/4)  ; note: LLNULL == 0ff00ff00h
        rep     stosd
        mov     edi, ebp                            ; font pitch and offset
        and     edi, 0fffffffh                      ; clear pitch info

    ;*************************************************************************
    ; Initialize FontCacheInfo Header
    ;
    ;  EAX = LLNULL
    ;  EBX = ptr of FontCacheInfo entry
    ;  EDX = pfo
    ;  EDI = font cache offset
    ;
    ;*************************************************************************

GotFontCacheOffset:

        mov     ecx, FONTFIXEDPITCHSHIFT SHL 28 ; pitch in 31:28
        or      ecx, edi                        ; load offset
        mov     [ebx].FontPitchAndOffset, ecx   ; save pitch/offset to font cache
        mov     esi, [edx].iUniq                ; pfo.iUniq - font handle
        mov     [ebx].FontCacheID, esi          ; save FontCacheID (handle)
        mov     [edx].pvConsumer, ebx           ; save ptr to FontCacheInfo entry
        cmp     eax, LRUFontInfoNode            ; if LRUFont == LLNULL then
        jne     short @f                        ; LRUFont = CurFontInfo
        mov     LRUFontInfoNode, ebx
@@:
        mov     esi, MRUFontInfoNode
        mov     [ebx].pFontInfoNext, esi        ; CurFontInfo->Next = SecondMRU
        mov     [ebx].pFontInfoPrev, eax        ; CurFontInfo->Prev = LLNULL
        mov     MRUFontInfoNode, ebx            ; MRUFont = CurFontInfo
        cmp     esi, eax                        ; if OldMRU != LLNULL then
        je      short LoadGlyphsToCache
        mov     [esi].pFontInfoPrev, ebx        ; CurFontInfo->Prev = OldMRU

;*****************************************************************************
;
; Load all glyphs in font to offscreen cache and save info in FontCacheInfo
;
; EBX - ptr to FontCacheInfo entry
; EDI - offset into frame buffer where font cache resides
;
;*****************************************************************************

LoadGlyphsToCache:

        mov     eax, [esp].savePpdev
        add     ebx, FONTCACHEINFOHEADERSIZE    ; points to glyph entries
        add     edi, [eax].pjFrameBufbase             ; frame buffer offset
        mov     eax, [esp].pgpParm
        mov     ecx, [esp].glyphCount
        mov     [esp].saveGlyphCount, ecx

    ;*************************************************************************
    ; Load all glyphs
    ;
    ; saveGlyphCount - temporary copy of glyph count
    ; EAX - pgp
    ; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
    ; EDI - ptr to font cache in frame buffer
    ;
    ;*************************************************************************

LoadGlyphLoop:

        mov     edx, [eax].gp_hg            ; glyph index
        cmp     edx, MAXGLYPHINDEX          ; 255 - max value for hardware design
        jg      NextGlyph                   ; can't cache glyph

        cmp     [ebx+edx*4], LLNULL         ; check if glyph is cached
        jne     NextGlyph                   ; glyph already cached

        mov     [esp].savePgp, eax
        mov     ecx, [eax].gp_pgdf
        mov     ecx, [ecx].gdf_pgb
        mov     eax, [ecx].gb_y
        shl     eax, 16
        or      ax, word ptr [ecx].gb_x
        jns     short @f

        sub     eax, 10000h                 ; need to adjust for later addition
                                            ; with x and y positions

@@:
        shl     ax, 4                       ; x in 19:8
        shl     eax, 4                      ; y in 31:20
        or      eax, edx                    ; glyph index in 7:0 NOTE: edx <= 255
        mov     [ebx+edx*4], eax            ; save glyph data in FontCacheInfo table
        shl     edx, FONTFIXEDPITCHSHIFT

        lea     esi, [ecx].gb_aj            ; offset to glyph
        mov     eax, [ecx].gb_cy            ; height
        mov     ebp, [ecx].gb_cx            ; width
        add     ebp, 7                      ; byte packed - round to next byte
        and     ebp, 0fff8h                 ; number of bits - byte packed
        mov     ecx, ebp                    ; save width bits
        imul    ecx, eax                    ; bits in glyph
        add     ecx, 31
        shr     ecx, 5                      ; number of dwords in glyph

        shl     eax, 16
        or      eax, ebp                    ; high word is height, low word is width
        mov     [edi+edx], eax              ; save glyph width and height first

    ;*************************************************************************
    ; load and save glyph data to offscreen memory
    ;
    ; EBX - ptr to FontCacheInfo.FontCacheGlyphInfo for current font
    ; ECX - number of dword in glyph bitmap
    ; EDX - glyph index
    ; EDI - offset to font cache in frame buffer
    ;
    ;*************************************************************************

        mov     ebp, edi                    ; save offset to start of font cache
        lea     edi, [edi+edx+4]            ; offset to glyph in cache
        rep     movsd                       ; save glyph bitmap
        mov     edi, ebp                    ; restore offset to font cache
        mov     eax,[esp].savePgp           ; pgp for current glyph

NextGlyph:
        add     eax, (size GLYPHPOS)        ; next glyph
        dec     [esp].saveGlyphCount        ; check if more glyphs to cache
        jnz     LoadGlyphLoop               ; cache next glyph

        sub     ebx, FONTCACHEINFOHEADERSIZE  ; point to FontCacheInfo entry
        cmp     [esp].missingGlyphFlag, FALSE ; if interrupted drawing to cache glyph
        je      CachedFontFound               ; then continue drawing glyphs

        add     ebx, FONTCACHEINFOHEADERSIZE  ; FontCacheInfo.FontCacheGlyphInfo
        mov     edx, [esp].saveEDX            ; destination x and y position
        mov     esi, [esp].saveESI            ; DMA pointer
        mov     eax, [esp].pgpParm            ; restore current pgp
        mov     [esp].missingGlyphFlag, FALSE ; reset flag
        jmp     CachedGlyphWhichLoop


    ;*************************************************************************
    ; Glyph can't be cached because it's index exceeds the hardware's capacity.
    ; This rarely happens, so just start from the beginning and draw the string
    ; the old way.
    ;*************************************************************************

NotValidGlyph:
        mov     eax, [esp].originalPgpParm  ; original pgp
        mov     [esp].pgpParm, eax          ; restore pgp
        mov     eax, [esp].saveNvDmaCount   ; original DMA count
        mov     [esp].localNvDmaCount, eax

;*****************************************************************************
;*****************************************************************************
;*****************************************************************************
;
; Draw glyph loop with checking for clipping without caching.
;
;*****************************************************************************

DrawGlyphsWithoutCache:

        mov     eax, [esp].pgpParm          ; ptr to glyphPos
        mov     ebx, [eax].gp_pgdf          ; ptr to glyph definition
        mov     ebx, [ebx].gdf_pgb          ; EBX = pgb (ptr to glyph bits)

    ;*************************************************************************
    ; ptlOrigin = Origin of glyph in bitmap + position on screen
    ;
    ; EAX - pgp
    ; EBX - pgb
    ;
    ;*************************************************************************

        mov     esi, [esp].pstro
        mov     edi, [ebx].gb_x             ; pgb->ptlOrigin.x
        mov     edx, [ebx].gb_y             ; pgb->ptlOrigin.y
        add     edi, [eax].gp_x             ; pgp->ptl.x
        add     edx, [eax].gp_y             ; pgp->ptl.y

        mov     [esp].ptlOriginx, edi
        mov     eax, [esp].prclClip
        mov     [esp].ptlOriginy, edx

    ;*************************************************************************
    ; Check if bounding box for string is within clipping rectangle
    ;
    ; EAX - prclClip
    ; EBX - pgb
    ; ESI - pstro
    ;
    ;*************************************************************************

        mov     ecx, [esp].clipRight
        mov     edi, [eax].xleft            ; prclClip->xleft
        mov     edx, [eax].ytop
        mov     eax, [esp].clipBottom

    ;*************************************************************************
    ; Trivial rejection
    ;*************************************************************************

        cmp     ecx, [esi].rclBGxleft       ; right clip < left of rect?
        jl      DrawGlyphsDone              ; yes - done

        cmp     eax, [esi].rclBGytop        ; bottom clip < top of rect
        jl      DrawGlyphsDone              ; yes - done

        cmp     edi, [esi].rclBGxright      ; left clip > right of rect?
        jg      DrawGlyphsDone              ; yes - done

        cmp     edx, [esi].rclBGybottom     ; top clip > bottom of rect?
        jg      DrawGlyphsDone              ; yes - done

    ;*************************************************************************
    ; Eliminate beginning glyphs that are clipped on the left
    ;
    ; EBX - pgb  pointer to glyphbits
    ; ECX - clipRight
    ; EDI - rclClip.xleft
    ;
    ;*************************************************************************

        mov     eax, [esp].pgpParm          ; pgp

PreClipString:
        mov     edx, [ebx].gb_cx            ; pgb->sizlBitmap.cx
        add     edx, [esp].ptlOriginx
        cmp     edx, edi                    ; if glyph not clipped
        jg      DrawGlyphSetup              ; then continue

        dec     [esp].glyphCount            ; one less glyph
        jle     DrawGlyphsDone              ; nothing to draw

        add     eax, (size GLYPHPOS)        ; next pgp
        mov     [esp].pgpParm, eax
        mov     ebx, [eax].gp_pgdf          ; pgp->pgdf

        mov     edx, [esp].ulCharIncLocal
        mov     ebx, [ebx].gdf_pgb          ; pgb
        add     [esp].ptlOriginx, edx       ; if ulCharInc is non-zero
                                            ; then ptlOrigin.x += ulCharInc
        test    edx, edx
        jnz     PreClipString               ; continue with next glyph

        mov     ecx, [ebx].gb_x             ; pgb->ptlOrigin.x
        add     ecx, [eax].gp_x             ; pgp->ptl.x
        mov     [esp].ptlOriginx, ecx

        mov     edx, [ebx].gb_y             ; pgb->ptlOrigin.y
        add     edx, [eax].gp_y             ; pgp->ptl.y
        mov     [esp].ptlOriginy, edx
        jmp     PreClipString               ; continue with next glyph

;*****************************************************************************
;
; Loop through all the clipped glyphs for this string
;
; EBX - pgb
;
;*****************************************************************************

DrawGlyphSetup:

        mov     edi, [esp].localNvDmaCount
        shl     edi, 2
        add     edi, [esp].localNvDmaFifoPtr

    ;*************************************************************************
    ; Get the size (in pixels) of the monochrome bitmap and
    ; get pointer to BYTE aligned glyph bitmap
    ;
    ; EBX - pgb
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

ClipGlyphLoop:
        mov     edx, [ebx].gb_cx            ; pgb->sizlBitmap.cx
        mov     ecx, [ebx].gb_cy            ; pgb->sizlBitmap.cy
        test    ecx, ecx
        jz      CheckMoreGlyphs             ; nothing to output

        and     edx, 0ffffh                 ; must be word
        mov     [esp].gWidth, edx

    ;*************************************************************************
    ;
    ; Check if glyph is clipped and skip if so. Note that we can't just exit now
    ; and assume every glyph will be clipped since this is not the case for italic
    ; or other glyphs with backups. It will also fail DCT test.
    ;
    ;*************************************************************************
        mov     eax, [esp].ptlOriginy
        mov     esi, [esp].ptlOriginx
        cmp     eax, [esp].clipBottom
        jg      CheckMoreGlyphs             ; char is clipped
        
        cmp     esi, [esp].clipRight
        jg      CheckMoreGlyphs             ; char is clipped
        
    ;*************************************************************************
    ; As far as I can tell, the beginning of the glyph (according to the
    ; GLYPHBITS structure) appears to always start on a DWORD boundary.
    ; In addition, the DDK specifies that the bits will always be DWORD padded
    ; at the end. So let's just deal with DWORDS for performance.
    ;*************************************************************************
    ;*************************************************************************
    ; Specify SizeInWidth as multiple of 8 since the incoming glyph data is
    ; always row ordered and BYTE packed. We will always output up to a
    ; BYTE boundary. The excess pixels will get clipped according to the width
    ; we specify in Size. 'SizeIn' corresponds to the amount of data that the
    ; NV Engine expects to receive, and it specifies how the data will be
    ; layed out on the screen.
    ;
    ; EBX - pgb
    ; ECX - glyph height
    ; EDX - glyph width
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

        add     edx, 7                      ; width + 7
        and     edx, 0fff8h                 ; byte boundary for byte packed
        mov     eax, ecx                    ; save height
        shl     ecx, 16                     ; height in high word
        or      ecx, edx                    ; height <<16 | sizeInWidth
        shr     edx, 3                      ; divide by 8 for number of bytes
        mov     [esp].numBytesPerScan, edx
        mul     edx                         ; #bytes in glyph

        add     eax, 3
        shr     eax, 2                      ; number of dwords for the glyph
        mov     [esp].numDwordsPerGlyph, eax

    ;*************************************************************************
    ;
    ; Check freecount
    ;
    ; EAX - num Dwords in glyph bitmap
    ; EBX - pgb
    ; ECX - SizeIn = height <<16 | sizeInWidth
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

        mov     edx, [esp].savePpdev
        mov     esi, [esp].localNvDmaFifoPtr
        add     eax, 5                      ; overhead for each glyph
        sub     [edx].nvDmaCachedFreeCount, eax   ; overhead per glyph
        jg      SetParmsForGlyph            ; have enough room in DMA buffer

        sub     edi, esi
        shr     edi, 2
        mov     [edx].nvDmaCount, edi       ; ppdev->nvDmaCount = localNvDmaCount
        mov     [esp].localNvDmaCount, edi

        mov     ebp, esp                    ; save stack pointer
        push    ebx                         ; save pgb
        push    ecx                         ; save SizeIn
        mov     ecx, eax                    ; number of dwords needed
        call    CheckDmaFreeCount
        pop     ecx                         ; restore SizeIn
        pop     ebx                         ; restore pgb
        mov     edi, [esp].localNvDmaCount
        shl     edi, 2
        add     edi, [esp].localNvDmaFifoPtr

    ;*************************************************************************
    ; Set parameters for glyph
    ;
    ; EBX - pgb
    ; ECX - SizeIn = height <<16 | sizeInWidth
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

SetParmsForGlyph:

        mov     eax, [esp].ptlOriginy
        mov     [edi], RECT_AND_TEXT_SUBCHANNEL OR NV04A_SIZE_IN_E OR (3 SHL 18)
        mov     [edi+4], ecx                ; SIZE_IN_E = height <<16 | sizeInWidth
        and     ecx, 0ffff0000h             ; clear sizeInWidth
        or      ecx, [esp].gWidth
        mov     [edi+8], ecx                ; SIZE_OUT_E = height <<16 | width
        shl     eax, 16                     ; ptlOrigin.y < 16
        mov     ecx, [esp].ptlOriginx
        and     ecx, 0ffffh
        or      eax, ecx
        mov     [edi+12], eax               ; ptlOrigin.y < 16 |    ptlOrigin.x
        add     edi, 16                     ; update nvDmaFifo to point to nvDmaCount

    ;*************************************************************************
    ; Blast out the data as fast as possible
    ;
    ; EBX - pgb
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

        lea     esi, DWORD PTR [ebx].gb_aj  ; pgb->aj ptr to monochrome bitmap

        mov     eax, [esp].NumDwordsPerGlyph
        mov     ecx, eax
        cmp     eax, MAXMONODWORDS
        jg      BigLoop
        
        shl     eax, 18                     ; number of dwords in bits 31:18
        or      eax, RECT_AND_TEXT_SUBCHANNEL OR NV04A_MONOCHROME_COLOR1_C
        mov     [edi], eax                  ; setup for glyph bitmap that follows
        add     edi, 4                      ; update nvDmaFifo to point to nvDmaCount
        rep     movsd

    ;*************************************************************************
    ; Check for more glyphs in string
    ;
    ; EDI - NvDmaPtr[NvDmaCount]
    ;
    ;*************************************************************************

CheckMoreGlyphs:
        dec     [esp].glyphCount            ; more glyphs to draw?
        jle     UpdateDMACountAndExit       ; no - exit

    ;*************************************************************************
    ; Update to next glyph
    ;*************************************************************************

        mov     eax, [esp].pgpParm
        add     eax, (size GLYPHPOS)
        mov     [esp].pgpParm, eax
        mov     ebx, [eax].gp_pgdf
        mov     ebx, [ebx].gdf_pgb          ; ptr to glyph bits

    ;*************************************************************************
    ; Update to next x and y value
    ;
    ; EAX - pgp
    ; EBX - pgb
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

        mov     edx, [esp].ulCharIncLocal
        mov     ecx, edx
        add     ecx, [esp].ptlOriginx       ; if ulCharInc is non-zero
                                            ; then ptlOrigin.x += ulCharInc
        test    edx, edx                    ; ulCharInc is valid
        jnz     short @f                    ; check if next glyph is clipped

        mov     ecx, [ebx].gb_x             ; pgb->ptlOrigin.x
        mov     edx, [ebx].gb_y             ; pgb->ptlOrigin.y
        add     ecx, [eax].gp_x             ; pgp->ptl.x
        add     edx, [eax].gp_y             ; pgp->ptl.y
        mov     [esp].ptlOriginy, edx

@@:
        mov     [esp].ptlOriginx, ecx
        jmp     ClipGlyphLoop               ; Continue with next glyph

    ;*************************************************************************
    ; Update local DMA buffer values
    ;
    ; EDI - nvDmaFifo+nvDmaCount
    ;
    ;*************************************************************************

UpdateDMACountAndExit:

        mov     esi, [esp].localNvDmaFifoPtr
        sub     edi, esi
        shr     edi, 2
        mov     [esp].localNvDmaCount, edi  ; ppdev->nvDmaCount = localNvDmaCount

    ;*************************************************************************
    ; Update DMA buffer values
    ;
    ; localNvDmaCount - has current count of entries in DMA buffer
    ;
    ;*************************************************************************

DrawGlyphsDone:
        mov     ebx, [esp].savePpdev
        mov     eax, [esp].localNvDmaCount
        mov     [ebx].nvDmaCount, eax       ; ppdev->nvDmaCount = localNvDmaCount
        add     esp,(size NV4_DrawFastGlyphs_STRUC) - NV4_DrawFastGlyphs_PARM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     24

    ;*************************************************************************
    ; More than MAXMONODWORDS in glyph. Need to break it up and send
    ; MAXMONODWORDS at a time. This requires some extra overhead that needs to
    ; be subtracted from the free count.
    ;
    ; ECX - Number of DWORDS
    ; EDI - NvDmaPtr[NvDmaCount]
    ; ESI - ptr to glyph bitmap
    ;
    ;*************************************************************************

BigLoop:
        mov     edx, [esp].savePpdev
        mov     eax, ecx                    ; number of DWORDS in glyph - use to
                                            ; calculate additional overhead
        add     eax, MAXMONODWORDS-1
        shr     eax, MAXMONOSHIFT           ; number of extra DMA entries for setup
        sub     [edx].nvDmaCachedFreeCount, eax   ; overhead per glyph
        jg      SetupBigLoop                ; have enough room in DMA buffer

        add     eax, ecx                    ; add number of DWORDS in glyph for
                                            ; total DWORDS needed from DMA buffer
        sub     edi, [esp].localNvDmaFifoPtr
        shr     edi, 2
        mov     [edx].nvDmaCount, edi       ; ppdev->nvDmaCount = localNvDmaCount
        mov     [esp].localNvDmaCount, edi
        
        mov     ebp, esp                    ; save stack pointer
        push    esi                         ; save ptr to glyph bitmap
        push    ecx                         ; save number of dwords in glyph
        mov     ecx, eax                    ; number of extra dwords needed in buffer
        call    CheckDmaFreeCount
        pop     ecx                         ; restore number of dwords in glyph
        pop     esi                         ; restore ptr to glyph bitmap
        mov     edi, [esp].localNvDmaCount
        shl     edi, 2
        add     edi, [esp].localNvDmaFifoPtr

    ;*************************************************************************
    ; ECX - Number of DWORDS
    ; EDI - NvDmaPtr[NvDmaCount]
    ; ESI - ptr to glyph bitmap
    ;*************************************************************************

SetupBigLoop:
        mov     edx, ecx                    ; number of dwords in glyph

SendMaxDwords:
        mov     [edi], (MAXMONODWORDS SHL 18) OR RECT_AND_TEXT_SUBCHANNEL OR NV04A_MONOCHROME_COLOR1_C
        add     edi, 4

        mov     ecx, MAXMONODWORDS
        sub     edx, MAXMONODWORDS
        rep     movsd

        cmp     edx, MAXMONODWORDS
        jge     SendMaxDwords

    ;*************************************************************************
    ; Send remaining dwords
    ;
    ; ECX = 0 after REP MOVSD
    ; EDX = number of dwords in bitmap remaining to be written to DMA buffer
    ; EDI - NvDmaPtr[NvDmaCount]
    ; ESI - ptr to glyph bitmap
    ;
    ;*************************************************************************

        or      ecx, edx                    ; rest of dwords
        jz      CheckMoreGlyphs             ; zero - continue

        mov     eax, edx                    ; rest of dwords
        shl     eax, 18                     ; put in bits 31:18
        or      eax, RECT_AND_TEXT_SUBCHANNEL OR NV04A_MONOCHROME_COLOR1_C
        mov     [edi], eax                  ; set up for bitmap data
        add     edi, 4

        rep     movsd
        jmp     CheckMoreGlyphs

NV4_DrawFastGlyphs@24 endp

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\i386\strucs.inc ===
;*************************** Include File Header *******************************
;
; Module Name: strucs.inc
;
; Most of these definitions are pulled straight from winddi.h.  We have
; to copy these here because we don't have any good 'h2inc' C-include-to-
; Asm-include program for NT.
;
; Copyright (c) 1993-1995 Microsoft Corporation
;
;*******************************************************************************

;*******************************************************************************
;*                                                                             *
;*   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
;*                                                                             *
;*******************************************************************************

; !!! CAUTION CAUTION !!! See Note !!!
DMAPUSH_BUFFER_SIZE EQU 200000h      ; NOTE: If you change this value here, change
DMAPUSH_PADDING     EQU 32           ;       it also in DRIVER.H
; !!! CAUTION CAUTION !!!

FALSE                       EQU 0
TRUE                        EQU 1
MAX_CX_CY_MEMORY_VALUE      EQU 7fffh   ; Hardware limitation

BMF_1BPP            equ     1
BMF_4BPP            equ     2
BMF_8BPP            equ     3
BMF_16BPP           equ     4
BMF_24BPP           equ     5
BMF_32BPP           equ     6

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL              STRUC
ptl_x               DD      0
ptl_y               DD      0
POINTL              ENDS

;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL               STRUC
sizl_cx             DD      0
sizl_cy             DD      0
SIZEL               ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;

RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends

;-----------------------------------------------------------------------;
; Constants for accessing frame buffer via pfnBankSelectMode
;-----------------------------------------------------------------------;

BANK_OFF            equ     0
BANK_ON             equ     1
BANK_ON_NO_WAIT     equ     2

;-----------------------------------------------------------------------;
; Definition of our realized brush structures.
;
; NOTE: Changes to these structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

RBRUSH              struc           ; /* rb, prb */
rb_fl                   dd  ?
rb_bTransparent         dd  ?
rb_ulForeColor          dd  ?
rb_ulBackColor          dd  ?
rb_ptlBrushOrg          db  (size POINTL) dup(?)
rb_apbe                 dd  ?

; I haven't declared rb_aulPattern because we don't know the size of the
; rb_apbe array here.

RBRUSH              ends

BRUSHENTRY          struc           ; /* be, pbe */
be_prbVerify            dd  ?
be_x                    dd  ?
be_y                    dd  ?
BRUSHENTRY          ends

NV04ControlDma  struc
    reserved        dd  10h dup(?)
    ChannelPut      dd  ?
    ChannelGet      dd  ?
NV04ControlDma  ends

SURFOBJ struc
    dhsurf          dd  ?
    hsurf           dd  ?
    dhpdev          dd  ?
    hdev            dd  ?
    sizlBitmapx     dd  ?
    sizlBitmapy     dd  ?
    cjBits          dd  ?
    pvBits          dd  ?
    pvScan0         dd  ?
    lDelta          dd  ?
    iSOUniq         dd  ?
    iBitmapFormat   dd  ?
    iType           dw  ?
    fjBitmap        dw  ?
SURFOBJ ends

PDEV_ASM    struc
    NVSignature         dd      ?   ; Unique NV signature
    xOffset             dd      ?   ; Pixel offset from (0, 0) to current
    yOffset             dd      ?   ;  DFB located in off-screen memory
    pjMmBase            dd      ?   ; We'll use it as a ptr to our NV Channel
    GrStatusReg         dd      ?   ; We'll use it as a ptr to our Gr Status Reg
    FbConfig0Reg        dd      ?   ; We'll use it as a ptr to our Fb Config0 Reg
    FbStartAddr         dd      ?   ; We'll use it as a ptr to our Fb Start Addr
    DACRegs             dd      ?   ; We'll use it as a ptr to our Cursor registers
    PRMCIORegs          dd      ?   ; NV3 PRMCIO Regs
    PRMVIORegs          dd      ?   ; NV3 PRMVIO Regs
    PRAMDACRegs         dd      ?   ; NV3 PRAMDAC Regs
    PRAMINRegs          dd      ?   ; NV3 PRAMIN Regs
    PGRAPHRegs          dd      ?   ; NV3 PGRAPH Regs
    PFIFORegs           dd      ?   ; NV3 PFIFO Regs
    FbBufferToggle      dd      ?   ; 0 or 1 (denotes frame buffer)
    pjFrameBufbase      dd      ?   ; pjFrameBuf base pointing to the base of frame buffer
    pjScreen            dd      ?   ; Points to base screen address
    lDelta              dd      ?   ; Distance from one scan to the next.
    cjPelSize           dd      ?   ; 1 if 8bpp, 2 if 16bpp, 3 if 24bpp, 4 if 32bpp
    iBitmapFormat       dd      ?   ; BMF_8BPP or BMF_16BPP or BMF_32BPP (color depth
    iBoard              dd      ?   ; Logical multi-board identifier (default zero)
    fontCacheOffset     dd      ?   ; Offset into font cache offscreen area
    fontCacheEnabled    dd      ?   ; Offset into font cache offscreen area
    flCaps              dd      ?   ; Capabilities flags
    flStatus            dd      ?   ; Status flags
    bEnabled            dd      ?   ; In graphics mode (not full-screen)

    hDriver             dd      ?   ; Handle to \Device\Screen
    hdevEng             dd      ?   ; Engine's handle to PDEV

    cxScreen            dd      ?   ; Visible screen width
    cyScreen            dd      ?   ; Visible screen height
    cxMemory            dd      ?   ; Width of Video RAM
    cyMemory            dd      ?   ; Height of Video RAM
    cBitsPerPel         dd      ?   ; Bits per pel (8, 15, 16, 24 or 32)
    cbFrameBuf          dd      ?   ; Size of frame buffer in bytes
    AlphaEnableValue    dd      ?   ; Global alpha enable value

    DmaPushEnabled2D    dd      ?
    DmaPushBufTotalSize dd      ?
    DmaPushBufCanUseSize dd     ?
    DmaPushBufMinSize   dd      ?
    nvDmaPushHandle     dd      ?
    nvDmaFifo           dd      ?
    nvDmaCount          dd      ?
    nvDmaChannel        dd      ?
    nvDmaCachedGet      dd      ?
    nvDmaCachedPut      dd      ?
    nvDmaPreviousPut    dd      ?
    nvDmaWrapFlag       dd      ?
    nvDmaCachedFreeCount dd     ?
    nvDmaFlushFixDwordPtr dd    ?
    nvDmaFlushFixDummyValue dd    ?
    
PDEV_ASM    ends

;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;

RECT_AND_TEXT_SUBCHANNEL    EQU 2*8192
NV04A_CLIP_POINT0_C         EQU 07ECh
NV04A_CLIP_POINT1_C         EQU 07F0h
NV04A_MONOCHROME_COLOR1_C   EQU 0800h
NV04A_SIZE_IN_E             EQU 0BF4h
NV04A_SIZE_OUT_E            EQU 0BF8h
NV04A_POINT_E               EQU 0BFCh
NV04A_FONTF                 EQU 0FF0h
NV04A_CHARACTER_COLOR1_F    EQU 1000h
MAXMONODWORDS               EQU 1 SHL MAXMONOSHIFT  ; 128
MAXMONOSHIFT                EQU 7

;-----------------------------------------------------------------------;
; Definitions for image from CPU output
;-----------------------------------------------------------------------;

IMAGE_FROM_CPU_SUBCHANNEL   EQU 0*8192
MAX_INDEXED_IMAGE_DWORDS    EQU 1792
NV061_COLOR0                EQU 400h

GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends

GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends

GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

STROBJ  struc
    cGlyphs          dd  ?       ; # of glyphs to render
    flAccel          dd  ?       ; accel flags
    ulCharInc        dd  ?       ; non-zero only if fixed pitch font, equal to advanced width.
    rclBGxleft       dd  ?       ; bk ground  rect of the string in device coords
    rclBGytop        dd  ?       ; bk ground  rect of the string in device coords
    rclBGxright      dd  ?       ; bk ground  rect of the string in device coords
    rclBGybottom     dd  ?       ; bk ground  rect of the string in device coords
    pgp              dd  ?       ; If non-NULL then has all glyphs.
    pwszOrg          dd  ?       ; pointer to original unicode string.
STROBJ  ends

FONTINFO  struc
    cjThis           dd  ?       ; size of FONTINFO structure in bytes
    flCaps           dd  ?       ; capabilities flag
    cGlyphsSupported dd  ?       ; number of glyphs in the font
    cjMaxGlyph1      dd  ?       ; size oflargest glyph in 1 bit/pixel
    cjMaxGlyph4      dd  ?       ; size oflargest glyph in 4 bit/pixel
    cjMaxGlyph8      dd  ?       ; size oflargest glyph in 8 bit/pixel
    cjMaxGlyph32     dd  ?       ; size oflargest glyph in 32 bit/pixel
FONTINFO  ends

FONTOBJ   struc
    iUniq            dd  ?       ;
    iface            dd  ?       ;
    cxMax            dd  ?       ;
    flFontType       dd  ?       ;
    iTTUniq          dd  ?       ;
    iFile            dd  ?       ;
    sizeLogResPpix   dd  ?       ;
    sizeLogResPpiy   dd  ?       ;
    ulStyleSize      dd  ?       ;
    pvConsumer       dd  ?       ;
    pvProducer       dd  ?       ;
FONTOBJ   ends

;-----------------------------------------------------------------------;
; Macro to do a simple RET, with no stack stuff, in a proc.
;-----------------------------------------------------------------------;

PLAIN_RET macro
        db      0c3h
        endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\arb_fifo.h ===
#ifndef _ARB_FIFO_H

#define ARB_FIFO_H

#define DEFAULT_GR_LWM 100
#define DEFAULT_VID_LWM 100
#define DEFAULT_GR_BURST_SIZE 256
#define DEFAULT_VID_BURST_SIZE 128


typedef struct {
  int gdrain_rate;
  int vdrain_rate;
  int mdrain_rate;

  int gburst_size;
  int vburst_size;
  char vid_en;
  char gr_en;
  int wcmocc, wcgocc, wcvocc, wcvlwm, wcglwm;
  int by_gfacc;
  char vid_only_once;
  char gr_only_once;
  char first_vacc;
  char first_gacc;
  char first_macc;
  int vocc;
  int gocc;
  int mocc;
  char cur;
  char engine_en;
  char converged;
  int priority;
} arb_info;


// the following structures are used by nv3

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;  //Burst size
  int video_burst_size;   // Burst size

  int graphics_hi_priority; // FBI arbitration
  int media_hi_priority;

  int rtl_values;
  int valid;  // good values


} fifo_info;
typedef struct {

  int pix_bpp;          /* 8, 16 or 32 */

  char enable_video; /* Video scalar enabled */
  char gr_during_vid; /* Graphic displays during video */
  char enable_mp; /* Media Port enabled */

  int memory_width;  /* 64 or 128 bits */

  int video_scale; /* video scale factor */

  long pclk_khz; /* Pixel clock, in KHz */
  long mclk_khz; /* Memory clock, in KHz */

  int mem_page_miss; /* Memory page miss penalty */
  int mem_latency;  /* Memory latency */

  char mem_aligned; /* FB is aligned on a 256 byte boundry */
} sim_state;


// the following structures are used by nv4

typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;
  int video_burst_size;

  int valid;  // good values

} nv4_fifo_info;

typedef struct {
  int pclk_khz;
  int mclk_khz;
  int nvclk_khz;
  char mem_page_miss;
  char mem_latency; //cas_latency
  int memory_width;
  char enable_video;
  char gr_during_vid;
  char pix_bpp;
  char mem_aligned;
  char enable_mp;
} nv4_sim_state;




#define VIDEO       0
#define GRAPHICS    1
#define MPORT       2
#define ENGINE      3


#define GFIFO_SIZE  320     /* Graphics Fifo Sizes */
#define GFIFO_SIZE_128  256     /* Graphics Fifo Sizes */
#define MFIFO_SIZE  120 /* MP  Fifo Sizes */
#define VFIFO_SIZE  256 /* Video Fifo Sizes */

#define ABS(a)  (a>0?a:-a)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv4\nvdat.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVDAT.C
//
// Abstract:
//
//     This module contains all the global data used by the NV driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "cmdcnst.h"
#include "modes.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//***************************************************************************************
//
// NV4 supported modes,
//
// 8bpp - all modes, all refresh rates supported
// 16bpp - all modes, all refresh rates supported
// 32bpp - 1280x1024 max at 100Hz, 1600x1200 max at 75Hz, 1920x1080 max at 72Hz, 1920x1200 max at 60Hz
//
//***************************************************************************************

U016 fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS][NUM_REFRESHES][NUM_ELEMENTS] =
{
    //**************************************************************************************
    // 640x480 at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 640,480,8, 60},
    {FALSE, 640,480,8, 70},
    {FALSE, 640,480,8, 72},
    {FALSE, 640,480,8, 75},
    {FALSE, 640,480,8, 85},
    {FALSE, 640,480,8, 100},
    {FALSE, 640,480,8, 120}
    },
    {
    {FALSE, 640,480,15, 60},
    {FALSE, 640,480,15, 70},
    {FALSE, 640,480,15, 72},
    {FALSE, 640,480,15, 75},
    {FALSE, 640,480,15, 85},
    {FALSE, 640,480,15, 100},
    {FALSE, 640,480,15, 120}
    },
    {
    {FALSE, 640,480,16, 60},
    {FALSE, 640,480,16, 70},
    {FALSE, 640,480,16, 72},
    {FALSE, 640,480,16, 75},
    {FALSE, 640,480,16, 85},
    {FALSE, 640,480,16, 100},
    {FALSE, 640,480,16, 120}
    },
    {
    {FALSE, 640,480,24, 60},
    {FALSE, 640,480,24, 70},
    {FALSE, 640,480,24, 72},
    {FALSE, 640,480,24, 75},
    {FALSE, 640,480,24, 85},
    {FALSE, 640,480,24, 100},
    {FALSE, 640,480,24, 120}
    },
    {
    {FALSE, 640,480,32, 60},
    {FALSE, 640,480,32, 70},
    {FALSE, 640,480,32, 72},
    {FALSE, 640,480,32, 75},
    {FALSE, 640,480,32, 85},
    {FALSE, 640,480,32, 100},
    {FALSE, 640,480,32, 120}
    },

    //***********************************************************************************
    // 320x240 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,240,8, 60},
    {FALSE, 320,240,8, 70},
    {FALSE, 320,240,8, 72},
    {FALSE, 320,240,8, 75},
    {FALSE, 320,240,8, 85},
    {FALSE, 320,240,8, 100},
    {FALSE, 320,240,8, 120}
    },
    {
    {FALSE, 320,240,15, 60},
    {FALSE, 320,240,15, 70},
    {FALSE, 320,240,15, 72},
    {FALSE, 320,240,15, 75},
    {FALSE, 320,240,15, 85},
    {FALSE, 320,240,15, 100},
    {FALSE, 320,240,15, 120}
    },
    {
    {FALSE, 320,240,16, 60},
    {FALSE, 320,240,16, 70},
    {FALSE, 320,240,16, 72},
    {FALSE, 320,240,16, 75},
    {FALSE, 320,240,16, 85},
    {FALSE, 320,240,16, 100},
    {FALSE, 320,240,16, 120}
    },
    {
    {FALSE, 320,240,24, 60},
    {FALSE, 320,240,24, 70},
    {FALSE, 320,240,24, 72},
    {FALSE, 320,240,24, 75},
    {FALSE, 320,240,24, 85},
    {FALSE, 320,240,24, 100},
    {FALSE, 320,240,24, 120}
    },
    {
    {FALSE, 320,240,32, 60},
    {FALSE, 320,240,32, 70},
    {FALSE, 320,240,32, 72},
    {FALSE, 320,240,32, 75},
    {FALSE, 320,240,32, 85},
    {FALSE, 320,240,32, 100},
    {FALSE, 320,240,32, 120}
    },
    //***********************************************************************************
    // 320x400 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,400,8, 70},
    {FALSE, 320,400,8, 70},
    {FALSE, 320,400,8, 72},
    {FALSE, 320,400,8, 75},
    {FALSE, 320,400,8, 85},
    {FALSE, 320,400,8, 100},
    {FALSE, 320,400,8, 120}
    },
    {
    {FALSE, 320,400,15, 70},
    {FALSE, 320,400,15, 70},
    {FALSE, 320,400,15, 72},
    {FALSE, 320,400,15, 75},
    {FALSE, 320,400,15, 85},
    {FALSE, 320,400,15, 100},
    {FALSE, 320,400,15, 120}
    },
    {
    {FALSE, 320,400,16, 70},
    {FALSE, 320,400,16, 70},
    {FALSE, 320,400,16, 72},
    {FALSE, 320,400,16, 75},
    {FALSE, 320,400,16, 85},
    {FALSE, 320,400,16, 100},
    {FALSE, 320,400,16, 120}
    },
    {
    {FALSE, 320,400,24, 70},
    {FALSE, 320,400,24, 70},
    {FALSE, 320,400,24, 72},
    {FALSE, 320,400,24, 75},
    {FALSE, 320,400,24, 85},
    {FALSE, 320,400,24, 100},
    {FALSE, 320,400,24, 120}
    },
    {
    {FALSE, 320,400,32, 70},
    {FALSE, 320,400,32, 70},
    {FALSE, 320,400,32, 72},
    {FALSE, 320,400,32, 75},
    {FALSE, 320,400,32, 85},
    {FALSE, 320,400,32, 100},
    {FALSE, 320,400,32, 120}
    },
    //***********************************************************************************
    // 400x300 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 400,300,8, 60},
    {FALSE, 400,300,8, 70},
    {FALSE, 400,300,8, 72},
    {FALSE, 400,300,8, 75},
    {FALSE, 400,300,8, 85},
    {FALSE, 400,300,8, 100},
    {FALSE, 400,300,8, 120}
    },
    {
    {FALSE, 400,300,15, 60},
    {FALSE, 400,300,15, 70},
    {FALSE, 400,300,15, 72},
    {FALSE, 400,300,15, 75},
    {FALSE, 400,300,15, 85},
    {FALSE, 400,300,15, 100},
    {FALSE, 400,300,15, 120}
    },
    {
    {FALSE, 400,300,16, 60},
    {FALSE, 400,300,16, 70},
    {FALSE, 400,300,16, 72},
    {FALSE, 400,300,16, 75},
    {FALSE, 400,300,16, 85},
    {FALSE, 400,300,16, 100},
    {FALSE, 400,300,16, 120}
    },
    {
    {FALSE, 400,300,24, 60},
    {FALSE, 400,300,24, 70},
    {FALSE, 400,300,24, 72},
    {FALSE, 400,300,24, 75},
    {FALSE, 400,300,24, 85},
    {FALSE, 400,300,24, 100},
    {FALSE, 400,300,24, 120}
    },
    {
    {FALSE, 400,300,32, 60},
    {FALSE, 400,300,32, 70},
    {FALSE, 400,300,32, 72},
    {FALSE, 400,300,32, 75},
    {FALSE, 400,300,32, 85},
    {FALSE, 400,300,32, 100},
    {FALSE, 400,300,32, 120}
    },
    //***********************************************************************************
    // 480x360 at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 480,360,8, 60},
    {FALSE, 480,360,8, 70},
    {FALSE, 480,360,8, 72},
    {FALSE, 480,360,8, 75},
    {FALSE, 480,360,8, 85},
    {FALSE, 480,360,8, 100},
    {FALSE, 480,360,8, 120}
    },
    {
    {FALSE, 480,360,15, 60},
    {FALSE, 480,360,15, 70},
    {FALSE, 480,360,15, 72},
    {FALSE, 480,360,15, 75},
    {FALSE, 480,360,15, 85},
    {FALSE, 480,360,15, 100},
    {FALSE, 480,360,15, 120}
    },
    {
    {FALSE, 480,360,16, 60},
    {FALSE, 480,360,16, 70},
    {FALSE, 480,360,16, 72},
    {FALSE, 480,360,16, 75},
    {FALSE, 480,360,16, 85},
    {FALSE, 480,360,16, 100},
    {FALSE, 480,360,16, 120}
    },
    {
    {FALSE, 480,360,24, 60},
    {FALSE, 480,360,24, 70},
    {FALSE, 480,360,24, 72},
    {FALSE, 480,360,24, 75},
    {FALSE, 480,360,24, 85},
    {FALSE, 480,360,24, 100},
    {FALSE, 480,360,24, 120}
    },
    {
    {FALSE, 480,360,32, 60},
    {FALSE, 480,360,32, 70},
    {FALSE, 480,360,32, 72},
    {FALSE, 480,360,32, 75},
    {FALSE, 480,360,32, 85},
    {FALSE, 480,360,32, 100},
    {FALSE, 480,360,32, 120}
    },

    //***********************************************************************************
    // 512x384. at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 512,384,8, 60},
    {FALSE, 512,384,8, 70},
    {FALSE, 512,384,8, 72},
    {FALSE, 512,384,8, 75},
    {FALSE, 512,384,8, 85},
    {FALSE, 512,384,8, 100},
    {FALSE, 512,384,8, 120},
    },
    {
    {FALSE, 512,384,15, 60},
    {FALSE, 512,384,15, 70},
    {FALSE, 512,384,15, 72},
    {FALSE, 512,384,15, 75},
    {FALSE, 512,384,15, 85},
    {FALSE, 512,384,15, 100},
    {FALSE, 512,384,15, 120},
    },
    {
    {FALSE, 512,384,16, 60},
    {FALSE, 512,384,16, 70},
    {FALSE, 512,384,16, 72},
    {FALSE, 512,384,16, 75},
    {FALSE, 512,384,16, 85},
    {FALSE, 512,384,16, 100},
    {FALSE, 512,384,16, 120},
    },
    {
    {FALSE, 512,384,24, 60},
    {FALSE, 512,384,24, 70},
    {FALSE, 512,384,24, 72},
    {FALSE, 512,384,24, 75},
    {FALSE, 512,384,24, 85},
    {FALSE, 512,384,24, 100},
    {FALSE, 512,384,24, 120},
    },
    {
    {FALSE, 512,384,32, 60},
    {FALSE, 512,384,32, 70},
    {FALSE, 512,384,32, 72},
    {FALSE, 512,384,32, 75},
    {FALSE, 512,384,32, 85},
    {FALSE, 512,384,32, 100},
    {FALSE, 512,384,32, 120},
    },
    //*************************************************************************************
    // 640x400.  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 640,400,8, 70},
    {FALSE, 640,400,8, 70},
    {FALSE, 640,400,8, 72},
    {FALSE, 640,400,8, 75},
    {FALSE, 640,400,8, 85},
    {FALSE, 640,400,8, 100},
    {FALSE, 640,400,8, 120}
    },
    {
    {FALSE, 640,400,15, 70},
    {FALSE, 640,400,15, 70},
    {FALSE, 640,400,15, 72},
    {FALSE, 640,400,15, 75},
    {FALSE, 640,400,15, 85},
    {FALSE, 640,400,15, 100},
    {FALSE, 640,400,15, 120}
    },
    {
    {FALSE, 640,400,16, 70},
    {FALSE, 640,400,16, 70},
    {FALSE, 640,400,16, 72},
    {FALSE, 640,400,16, 75},
    {FALSE, 640,400,16, 85},
    {FALSE, 640,400,16, 100},
    {FALSE, 640,400,16, 120}
    },
    {
    {FALSE, 640,400,24, 70},
    {FALSE, 640,400,24, 70},
    {FALSE, 640,400,24, 72},
    {FALSE, 640,400,24, 75},
    {FALSE, 640,400,24, 85},
    {FALSE, 640,400,24, 100},
    {FALSE, 640,400,24, 120}
    },
    {
    {FALSE, 640,400,32, 70},
    {FALSE, 640,400,32, 70},
    {FALSE, 640,400,32, 72},
    {FALSE, 640,400,32, 75},
    {FALSE, 640,400,32, 85},
    {FALSE, 640,400,32, 100},
    {FALSE, 640,400,32, 120}
    },

    //***********************************************************************************
    // 320x200  at 8,15,16,24 and 32bpp
    //***********************************************************************************
    {
    {FALSE, 320,200,8, 70},
    {FALSE, 320,200,8, 70},
    {FALSE, 320,200,8, 72},
    {FALSE, 320,200,8, 75},
    {FALSE, 320,200,8, 85},
    {FALSE, 320,200,8, 100},
    {FALSE, 320,200,8, 120}
    },
    {
    {FALSE, 320,200,15, 70},
    {FALSE, 320,200,15, 70},
    {FALSE, 320,200,15, 72},
    {FALSE, 320,200,15, 75},
    {FALSE, 320,200,15, 85},
    {FALSE, 320,200,15, 100},
    {FALSE, 320,200,15, 120}
    },
    {
    {FALSE, 320,200,16, 70},
    {FALSE, 320,200,16, 70},
    {FALSE, 320,200,16, 72},
    {FALSE, 320,200,16, 75},
    {FALSE, 320,200,16, 85},
    {FALSE, 320,200,16, 100},
    {FALSE, 320,200,16, 120}
    },
    {
    {FALSE, 320,200,24, 70},
    {FALSE, 320,200,24, 70},
    {FALSE, 320,200,24, 72},
    {FALSE, 320,200,24, 75},
    {FALSE, 320,200,24, 85},
    {FALSE, 320,200,24, 100},
    {FALSE, 320,200,24, 120}
    },
    {
    {FALSE, 320,200,32, 70},
    {FALSE, 320,200,32, 70},
    {FALSE, 320,200,32, 72},
    {FALSE, 320,200,32, 75},
    {FALSE, 320,200,32, 85},
    {FALSE, 320,200,32, 100},
    {FALSE, 320,200,32, 120}
    },

    //**************************************************************************************
    // 800x600.  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 800,600,8, 60},
    {FALSE, 800,600,8, 70},
    {FALSE, 800,600,8, 72},
    {FALSE, 800,600,8, 75},
    {FALSE, 800,600,8, 85},
    {FALSE, 800,600,8, 100},
    {FALSE, 800,600,8, 120}
    },
    {
    {FALSE, 800,600,15, 60},
    {FALSE, 800,600,15, 70},
    {FALSE, 800,600,15, 72},
    {FALSE, 800,600,15, 75},
    {FALSE, 800,600,15, 85},
    {FALSE, 800,600,15, 100},
    {FALSE, 800,600,15, 120}
    },
    {
    {FALSE, 800,600,16, 60},
    {FALSE, 800,600,16, 70},
    {FALSE, 800,600,16, 72},
    {FALSE, 800,600,16, 75},
    {FALSE, 800,600,16, 85},
    {FALSE, 800,600,16, 100},
    {FALSE, 800,600,16, 120}
    },
    {
    {FALSE, 800,600,24, 60},
    {FALSE, 800,600,24, 70},
    {FALSE, 800,600,24, 72},
    {FALSE, 800,600,24, 75},
    {FALSE, 800,600,24, 85},
    {FALSE, 800,600,24, 100},
    {FALSE, 800,600,24, 120}
    },
    {
    {FALSE, 800,600,32, 60},
    {FALSE, 800,600,32, 70},
    {FALSE, 800,600,32, 72},
    {FALSE, 800,600,32, 75},
    {FALSE, 800,600,32, 85},
    {FALSE, 800,600,32, 100},
    {FALSE, 800,600,32, 120}
    },
    //**************************************************************************************
    // 960x720  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 960,720,8, 60},
    {FALSE, 960,720,8, 70},
    {FALSE, 960,720,8, 72},
    {FALSE, 960,720,8, 75},
    {FALSE, 960,720,8, 85},
    {FALSE, 960,720,8, 100},
    {FALSE, 960,720,8, 120}
    },
    {
    {FALSE, 960,720,15, 60},
    {FALSE, 960,720,15, 70},
    {FALSE, 960,720,15, 72},
    {FALSE, 960,720,15, 75},
    {FALSE, 960,720,15, 85},
    {FALSE, 960,720,15, 100},
    {FALSE, 960,720,15, 120}
    },
    {
    {FALSE, 960,720,16, 60},
    {FALSE, 960,720,16, 70},
    {FALSE, 960,720,16, 72},
    {FALSE, 960,720,16, 75},
    {FALSE, 960,720,16, 85},
    {FALSE, 960,720,16, 100},
    {FALSE, 960,720,16, 120}
    },
    {
    {FALSE, 960,720,24, 60},
    {FALSE, 960,720,24, 70},
    {FALSE, 960,720,24, 72},
    {FALSE, 960,720,24, 75},
    {FALSE, 960,720,24, 85},
    {FALSE, 960,720,24, 100},
    {FALSE, 960,720,24, 120}
    },
    {
    {FALSE, 960,720,32, 60},
    {FALSE, 960,720,32, 70},
    {FALSE, 960,720,32, 72},
    {FALSE, 960,720,32, 75},
    {FALSE, 960,720,32, 85},
    {FALSE, 960,720,32, 100},
    {FALSE, 960,720,32, 120}
    },
    //**************************************************************************************
    // 1024x768  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1024,768,8, 60},
    {FALSE, 1024,768,8, 70},
    {FALSE, 1024,768,8, 72},
    {FALSE, 1024,768,8, 75},
    {FALSE, 1024,768,8, 85},
    {FALSE, 1024,768,8, 100},
    {FALSE, 1024,768,8, 120}
    },
    {
    {FALSE, 1024,768,15, 60},
    {FALSE, 1024,768,15, 70},
    {FALSE, 1024,768,15, 72},
    {FALSE, 1024,768,15, 75},
    {FALSE, 1024,768,15, 85},
    {FALSE, 1024,768,15, 100},
    {FALSE, 1024,768,15, 120}
    },
    {
    {FALSE, 1024,768,16, 60},
    {FALSE, 1024,768,16, 70},
    {FALSE, 1024,768,16, 72},
    {FALSE, 1024,768,16, 75},
    {FALSE, 1024,768,16, 85},
    {FALSE, 1024,768,16, 100},
    {FALSE, 1024,768,16, 120}
    },
    {
    {FALSE, 1024,768,24, 60},
    {FALSE, 1024,768,24, 70},
    {FALSE, 1024,768,24, 72},
    {FALSE, 1024,768,24, 75},
    {FALSE, 1024,768,24, 85},
    {FALSE, 1024,768,24, 100},
    {FALSE, 1024,768,24, 120}
    },
    {
    {FALSE, 1024,768,32, 60},
    {FALSE, 1024,768,32, 70},
    {FALSE, 1024,768,32, 72},
    {FALSE, 1024,768,32, 75},
    {FALSE, 1024,768,32, 85},
    {FALSE, 1024,768,32, 100},
    {FALSE, 1024,768,32, 120}
    },
    //*************************************************************************************
    // 1152x864  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 1152,864,8, 60},
    {FALSE, 1152,864,8, 70},
    {FALSE, 1152,864,8, 72},
    {FALSE, 1152,864,8, 75},
    {FALSE, 1152,864,8, 85},
    {FALSE, 1152,864,8, 100},
    {FALSE, 1152,864,8, 120}
    },
    {
    {FALSE, 1152,864,15, 60},
    {FALSE, 1152,864,15, 70},
    {FALSE, 1152,864,15, 72},
    {FALSE, 1152,864,15, 75},
    {FALSE, 1152,864,15, 85},
    {FALSE, 1152,864,15, 100},
    {FALSE, 1152,864,15, 120}
    },
    {
    {FALSE, 1152,864,16, 60},
    {FALSE, 1152,864,16, 70},
    {FALSE, 1152,864,16, 72},
    {FALSE, 1152,864,16, 75},
    {FALSE, 1152,864,16, 85},
    {FALSE, 1152,864,16, 100},
    {FALSE, 1152,864,16, 120}
    },
    {
    {FALSE, 1152,864,24, 60},
    {FALSE, 1152,864,24, 70},
    {FALSE, 1152,864,24, 72},
    {FALSE, 1152,864,24, 75},
    {FALSE, 1152,864,24, 85},
    {FALSE, 1152,864,24, 100},
    {FALSE, 1152,864,24, 120}
    },
    {
    {FALSE, 1152,864,32, 60},
    {FALSE, 1152,864,32, 70},
    {FALSE, 1152,864,32, 72},
    {FALSE, 1152,864,32, 75},
    {FALSE, 1152,864,32, 85},
    {FALSE, 1152,864,32, 100},
    {FALSE, 1152,864,32, 120}
    },
    //*************************************************************************************
    // 1280x1024  at 8,15,16,24 and 32bpp
    //*************************************************************************************
    {
    {FALSE, 1280,1024,8, 60},
    {FALSE, 1280,1024,8, 70},
    {FALSE, 1280,1024,8, 72},
    {FALSE, 1280,1024,8, 75},
    {FALSE, 1280,1024,8, 85},
    {FALSE, 1280,1024,8, 100},
    {FALSE, 1280,1024,8, 120}
    },
    {
    {FALSE, 1280,1024,15, 60},
    {FALSE, 1280,1024,15, 70},
    {FALSE, 1280,1024,15, 72},
    {FALSE, 1280,1024,15, 75},
    {FALSE, 1280,1024,15, 85},
    {FALSE, 1280,1024,15, 100},
    {FALSE, 1280,1024,15, 120}
    },
    {
    {FALSE, 1280,1024,16, 60},
    {FALSE, 1280,1024,16, 70},
    {FALSE, 1280,1024,16, 72},
    {FALSE, 1280,1024,16, 75},
    {FALSE, 1280,1024,16, 85},
    {FALSE, 1280,1024,16, 100},
    {FALSE, 1280,1024,16, 120}
    },
    {
    {FALSE, 1280,1024,24, 60},
    {FALSE, 1280,1024,24, 70},
    {FALSE, 1280,1024,24, 72},
    {FALSE, 1280,1024,24, 75},
    {FALSE, 1280,1024,24, 85},
    {FALSE, 1280,1024,24, 100},
    {FALSE, 1280,1024,24, 100}
    },
    {
    {FALSE, 1280,1024,32, 60},
    {FALSE, 1280,1024,32, 70},
    {FALSE, 1280,1024,32, 72},
    {FALSE, 1280,1024,32, 75},
    {FALSE, 1280,1024,32, 85},
    {FALSE, 1280,1024,32, 100},
    {FALSE, 1280,1024,32, 100}
    },
    //**************************************************************************************
    // 1600x1024  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1600,1024,8, 60},
    {FALSE, 1600,1024,8, 70},
    {FALSE, 1600,1024,8, 72},
    {FALSE, 1600,1024,8, 76},
    {FALSE, 1600,1024,8, 85},
    {FALSE, 1600,1024,8, 85},
    {FALSE, 1600,1024,8, 85}
     },
    {
    {FALSE, 1600,1024,15, 60},
    {FALSE, 1600,1024,15, 70},
    {FALSE, 1600,1024,15, 72},
    {FALSE, 1600,1024,15, 76},
    {FALSE, 1600,1024,15, 85},
    {FALSE, 1600,1024,15, 85},
    {FALSE, 1600,1024,15, 85}
     },
    {
    {FALSE, 1600,1024,16, 60},
    {FALSE, 1600,1024,16, 70},
    {FALSE, 1600,1024,16, 72},
    {FALSE, 1600,1024,16, 76},
    {FALSE, 1600,1024,16, 85},
    {FALSE, 1600,1024,16, 85},
    {FALSE, 1600,1024,16, 85}
     },
    {
    {FALSE, 1600,1024,24, 60},
    {FALSE, 1600,1024,24, 70},
    {FALSE, 1600,1024,24, 72},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76},
    {FALSE, 1600,1024,24, 76}
     },
    {
    {FALSE, 1600,1024,32, 60},
    {FALSE, 1600,1024,32, 70},
    {FALSE, 1600,1024,32, 72},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76},
    {FALSE, 1600,1024,32, 76}
     },
    //**************************************************************************************
    // 1600x1200  at 8,15,16,24 and 32bpp
    //**************************************************************************************
    {
    {FALSE, 1600,1200,8, 60},
    {FALSE, 1600,1200,8, 70},
    {FALSE, 1600,1200,8, 72},
    {FALSE, 1600,1200,8, 75},
    {FALSE, 1600,1200,8, 85},
    {FALSE, 1600,1200,8, 85},
    {FALSE, 1600,1200,8, 85}
     },
    {
    {FALSE, 1600,1200,15, 60},
    {FALSE, 1600,1200,15, 70},
    {FALSE, 1600,1200,15, 72},
    {FALSE, 1600,1200,15, 75},
    {FALSE, 1600,1200,15, 85},
    {FALSE, 1600,1200,15, 85},
    {FALSE, 1600,1200,15, 85}
     },
    {
    {FALSE, 1600,1200,16, 60},
    {FALSE, 1600,1200,16, 70},
    {FALSE, 1600,1200,16, 72},
    {FALSE, 1600,1200,16, 75},
    {FALSE, 1600,1200,16, 85},
    {FALSE, 1600,1200,16, 85},
    {FALSE, 1600,1200,16, 85}
     },
    {
    {FALSE, 1600,1200,24, 60},
    {FALSE, 1600,1200,24, 70},
    {FALSE, 1600,1200,24, 72},
    {FALSE, 1600,1200,24, 75},
    {FALSE, 1600,1200,24, 85},
    {FALSE, 1600,1200,24, 85},
    {FALSE, 1600,1200,24, 85}
     },
    {
    {FALSE, 1600,1200,32, 60},
    {FALSE, 1600,1200,32, 70},
    {FALSE, 1600,1200,32, 72},
    {FALSE, 1600,1200,32, 75},
    {FALSE, 1600,1200,32, 85},
    {FALSE, 1600,1200,32, 85},
    {FALSE, 1600,1200,32, 85}
     },
     //**************************************************************************************
     // 1800x1440  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60},
     {FALSE, 1800,1440,8, 60}
      },
     {
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60},
     {FALSE, 1800,1440,15, 60}
      },
     {
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60},
     {FALSE, 1800,1440,16, 60}
      },
     {
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60},
     {FALSE, 1800,1440,24, 60}
      },
     {
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60},
     {FALSE, 1800,1440,32, 60}
      },
     //**************************************************************************************
     // 1920x1080  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1920,1080,8, 60},
     {FALSE, 1920,1080,8, 70},
     {FALSE, 1920,1080,8, 72},
     {FALSE, 1920,1080,8, 75},
     {FALSE, 1920,1080,8, 85},
     {FALSE, 1920,1080,8, 85},
     {FALSE, 1920,1080,8, 85}
      },
     {
     {FALSE, 1920,1080,15, 60},
     {FALSE, 1920,1080,15, 70},
     {FALSE, 1920,1080,15, 72},
     {FALSE, 1920,1080,15, 75},
     {FALSE, 1920,1080,15, 85},
     {FALSE, 1920,1080,15, 85},
     {FALSE, 1920,1080,15, 85}
      },
     {
     {FALSE, 1920,1080,16, 60},
     {FALSE, 1920,1080,16, 70},
     {FALSE, 1920,1080,16, 72},
     {FALSE, 1920,1080,16, 75},
     {FALSE, 1920,1080,16, 85},
     {FALSE, 1920,1080,16, 85},
     {FALSE, 1920,1080,16, 85}
      },
     {
     {FALSE, 1920,1080,24, 60},
     {FALSE, 1920,1080,24, 70},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72},
     {FALSE, 1920,1080,24, 72}
      },
     {
     {FALSE, 1920,1080,32, 60},
     {FALSE, 1920,1080,32, 70},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72},
     {FALSE, 1920,1080,32, 72}
      },
     //**************************************************************************************
     // 1920x1200  at 8,15,16,24 and 32bpp
     //**************************************************************************************
     {
     {FALSE, 1920,1200,8, 60},
     {FALSE, 1920,1200,8, 70},
     {FALSE, 1920,1200,8, 72},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75},
     {FALSE, 1920,1200,8, 75}
      },
     {
     {FALSE, 1920,1200,15, 60},
     {FALSE, 1920,1200,15, 70},
     {FALSE, 1920,1200,15, 72},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75},
     {FALSE, 1920,1200,15, 75}
      },
     {
     {FALSE, 1920,1200,16, 60},
     {FALSE, 1920,1200,16, 70},
     {FALSE, 1920,1200,16, 72},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75},
     {FALSE, 1920,1200,16, 75}
      },
     {
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60},
     {FALSE, 1920,1200,24, 60}
      },
     {
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60},
     {FALSE, 1920,1200,32, 60}
      }
};
//******************************************************************************
// Use a slightly different mode table for NV4
//******************************************************************************


MODEDESC mib[] =             // Our Mode List
{
//    +------- vmode                                max DCLK     ------+
//    |      +----- imode                           row offset   -----+|
//    |      |      +----- std_modetbl              y resolution ----+||
//    |      |      |      +----- ext_modetbl       x resolution ---+|||
//    |      |      |      |     +----- tv_modetbl                  ||||
//    |      |      |      |     |     +----- crtc_override         ||||
//    |      |      |      |     |     |     +----- bits per pixel  ||||
//    |      |      |      |     |     |     |    +-----------------+|||
//    |      |      |      |     |     |     |    |     +------------+||
//    |      |      |      |     |     |     |    |     |     +-------+|
//    |      |      |      |     |     |     |    |     |     |    +---+
//    V      V      V      V     V     V     V    V     V     V    V
    {0x100, 0x5B, PACKED, 0x11, 0x05, 0x06,  8,  640,  400,  640, MAX_DCLK},  // Mode 100 - 640x400    8bpp
    {0x101, 0x5F, PACKED, 0x01, 0x06, 0xFF,  8,  640,  480,  640, MAX_DCLK},  // Mode 101 - 640x480    8bpp
    {0x102, 0x58, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode 102 - 800x600    4bpp
    {0x102, 0x6A, PLANAR, 0x02, 0x03, 0x07,  4,  800,  600,  100, MAX_ATC },  // Mode  6A - 800x600    4bpp
    {0x103, 0x5C, PACKED, 0x03, 0x07, 0x08,  8,  800,  600,  800, MAX_DCLK},  // Mode 103 - 800x600    8bpp
    {0x104, 0x5D, PLANAR, 0x04, 0x03, 0x0A,  4, 1024,  768, 1024, MAX_ATC },  // Mode 104 - 1024x768   4bpp
    {0x105, 0x5E, PACKED, 0x05, 0xff, 0x0B,  8, 1024,  768, 1024, MAX_DCLK},  // Mode 105 - 1024x768   8bpp
    {0x106, 0x5A, PLANAR, 0x06, 0x03, 0x0D,  4, 1280, 1024,  160, MAX_ATC },  // Mode 106 - 1280x1024  4bpp
    {0x107, 0x6B, PACKED, 0x07, 0xff, 0x0E,  8, 1280, 1024, 1280, MAX_DCLK},  // Mode 107 - 1280x1024  8bpp
    {0x10E, 0x78, PACKED, 0x0D, 0x00, 0x00, 16,  320,  200,  640, MAX_DCLK},  // Mode 10E - 320x200   16bpp
    {0x10F, 0x20, PACKED, 0x12, 0x00, 0x00, 32,  320,  200, 1280, MAX_DCLK},  // Mode 10F - 320x200 32bpp
    {0x111, 0x6E, PACKED, 0x0E, 0x06, 0xFF, 16,  640,  480, 1280, MAX_DCLK},  // Mode 111 - 640x480 16bpp
    {0x112, 0x21, PACKED, 0x19, 0x06, 0xFF, 32,  640,  480, 2560, MAX_DCLK},  // Mode 112 - 640x480 32bpp
    {0x114, 0x6F, PACKED, 0x0F, 0x07, 0x08, 16,  800,  600, 1600, MAX_DCLK},  // Mode 114 - 800x600 16bpp
    {0x115, 0x22, PACKED, 0x1A, 0x07, 0x08, 32,  800,  600, 3200, MAX_DCLK},  // Mode 115 - 800x600 32bpp
    {0x117, 0x72, PACKED, 0x10, 0xff, 0x0B, 16, 1024,  768, 2048, MAX_DCLK},  // Mode 117 - 1024x768 16bpp
    {0x118, 0x3F, PACKED, 0x1C, 0xff, 0x0B, 32, 1024,  768, 4096, MAX_DCLK},  // Mode 118 - 1024x768 32bpp
    {0x11A, 0x44, PACKED, 0x2F, 0xff, 0x0E, 16, 1280, 1024, 2560, MAX_DCLK},  // Mode 11A - 1280x1024 16bbp
    {0x130, 0x30, PACKED, 0x1E, 0x00, 0x00,  8,  320,  200,  320, MAX_DCLK},  // Mode 130 - 320x200  8bbp
    {0x131, 0x31, PACKED, 0x1F, 0x02, 0x02,  8,  320,  400,  320, MAX_DCLK},  // Mode 131 - 320x400 8bpp
    {0x132, 0x32, PACKED, 0x27, 0x02, 0x02, 16,  320,  400,  640, MAX_DCLK},  // Mode 132 - 320x400 16bpp
    {0x133, 0x33, PACKED, 0x13, 0x02, 0x02, 32,  320,  400, 1280, MAX_DCLK},  // Mode 133 - 320x400 32bpp
    {0x134, 0x34, PACKED, 0x20, 0x01, 0x01,  8,  320,  240,  320, MAX_DCLK},  // Mode 134 - 320x240 8bpp
    {0x135, 0x35, PACKED, 0x28, 0x01, 0x01, 16,  320,  240,  640, MAX_DCLK},  // Mode 135 - 320x240 16
    {0x136, 0x36, PACKED, 0x14, 0x01, 0x01, 32,  320,  240, 1280, MAX_DCLK},  // Mode 136 - 320x240 32
    {0x137, 0x37, PACKED, 0x21, 0x03, 0x03,  8,  400,  300,  400, MAX_DCLK},  // Mode 137 - 400x300 8
    {0x138, 0x38, PACKED, 0x29, 0x03, 0x03, 16,  400,  300,  800, MAX_DCLK},  // Mode 138 - 400x300 16
    {0x139, 0x39, PACKED, 0x15, 0x03, 0x03, 32,  400,  300, 1600, MAX_DCLK},  // Mode 139 - 400x300 32
    {0x13A, 0x3A, PACKED, 0x23, 0x04, 0x05,  8,  512,  384,  512, MAX_DCLK},  // Mode 13A - 512x384 8
    {0x13B, 0x3B, PACKED, 0x2B, 0x04, 0x05, 16,  512,  384, 1024, MAX_DCLK},  // Mode 13B - 512x384 16
    {0x13C, 0x3C, PACKED, 0x17, 0x04, 0x05, 32,  512,  384, 2048, MAX_DCLK},  // Mode 13C - 512x384 32
    {0x13D, 0x3D, PACKED, 0x2C, 0x05, 0x06, 16,  640,  400, 1280, MAX_DCLK},  // Mode 13D - 640x400 16
    {0x13E, 0x3E, PACKED, 0x18, 0x05, 0x06, 32,  640,  400, 2560, MAX_DCLK},  // Mode 13E - 640x400 32
    {0x141, 0x41, PACKED, 0x25, 0xff, 0x0C,  8, 1152,  864, 1152, MAX_DCLK},  // Mode 141 - 1152x864 8
    {0x142, 0x42, PACKED, 0x2E, 0xff, 0x0C, 16, 1152,  864, 2304, MAX_DCLK},  // Mode 142 - 1152x864 16
    {0x143, 0x43, PACKED, 0x1D, 0xff, 0x0C, 32, 1152,  864, 4608, MAX_DCLK},  // Mode 143 - 1152x864 32
    {0x145, 0x45, PACKED, 0x26, 0xFF, 0x0F,  8, 1600, 1200, 1600, MAX_DCLK},  // Mode 145 - 1600x1200 8
    {0x146, 0x46, PACKED, 0x30, 0xFF, 0x0F, 16, 1600, 1200, 3200, MAX_DCLK},  // Mode 146 - 1600x1200 16
    // more TV modes?
    {0x147, 0x47, PACKED, 0x22, 0xFF, 0x04,  8,  480,  360,  480, MAX_DCLK},  // Mode 147 - 480x360 8
    {0x148, 0x48, PACKED, 0x2A, 0xFF, 0x04, 16,  480,  360,  960, MAX_DCLK},  // Mode 148 - 480x360 16
    {0x149, 0x49, PACKED, 0x16, 0xFF, 0x04, 32,  480,  360, 1920, MAX_DCLK},  // Mode 149 - 480x360 32
    {0x14A, 0x4A, PACKED, 0x24, 0xff, 0x09,  8,  960,  720,  960, MAX_DCLK},  // Mode 14A - 960x720 8
    {0x14B, 0x4B, PACKED, 0x2D, 0xff, 0x09, 16,  960,  720, 1920, MAX_DCLK},  // Mode 14B - 960x720 16
    {0x14C, 0x4C, PACKED, 0x1B, 0xff, 0x09, 32,  960,  720, 3840, MAX_DCLK},  // Mode 14C - 960x720 32
    {0x14D, 0x4D, PACKED, 0x31, 0xff, 0x0E, 32, 1280, 1024, 5120, MAX_DCLK},  // Mode 14D - 1280x1024 32
    {0x14E, 0x4E, PACKED, 0x32, 0xFF, 0x0F, 32, 1600, 1200, 6400, MAX_DCLK},  // Mode 14E - 1600x1200 32

    // JJV - New Modes
    {0x14F, 0x80, PACKED, 0x33, 0xFF, 0x10,  8, 1800, 1440, 1800, MAX_DCLK},    // Mode 14F - 1800x1440 8
    {0x150, 0x81, PACKED, 0x34, 0xFF, 0x11, 16, 1800, 1440, 3600, MAX_DCLK},    // Mode 150 - 1800x1440 16
    {0x151, 0x82, PACKED, 0x35, 0xFF, 0x12,  8, 1920, 1080, 1920, MAX_DCLK},    // Mode 151 - 1920x1080 8
    {0x152, 0x83, PACKED, 0x36, 0xFF, 0x13, 16, 1920, 1080, 3840, MAX_DCLK},    // Mode 152 - 1920x1080 16
    {0x153, 0x84, PACKED, 0x37, 0xFF, 0x14, 32, 1920, 1080, 7680, MAX_DCLK},    // Mode 153 - 1920x1080 32
    {0x154, 0x85, PACKED, 0x38, 0xFF, 0x15,  8, 1920, 1200, 1920, MAX_DCLK},    // Mode 154 - 1920x1200 8
    {0x155, 0x86, PACKED, 0x39, 0xFF, 0x16, 16, 1920, 1200, 3840, MAX_DCLK},    // Mode 155 - 1920x1200 16
    {0x156, 0x87, PACKED, 0x3A, 0xFF, 0x17, 32, 1920, 1200, 7680, MAX_DCLK},    // Mode 156 - 1920x1200 32
    // JJV - New Modes

    // VEL - New Dell Specific Modes
    {0x157, 0x88, PACKED, 0x3B, 0xFF, 0x18,  8, 1600, 1024, 1600, MAX_DCLK},  // Mode 157 - 1600x1024 8
    {0x158, 0x89, PACKED, 0x3C, 0xFF, 0x19, 16, 1600, 1024, 3200, MAX_DCLK},  // Mode 158 - 1600x1024 16
    {0x159, 0x8A, PACKED, 0x3D, 0xFF, 0x1A, 32, 1600, 1024, 6400, MAX_DCLK},  // Mode 159 - 1600x1024 32
    // VEL - New Dell Specific Modes

    {0xFFFF,0xFF, 0xFF,   0xFF, 0xFF, 0xFF,  0,    0,    0,    0, 0}          // List Terminator
};


CRTC_OVERRIDE crt_override[] =       // Mode overide table for CRTC
{
    // 0. Mode 20h, 78h / VESA Mode 10Eh, 10Fh
    //    320x200 16-bit/32-bit color graphics
    { 0x28, 0x18, 0x08, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0xC0, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 1. Mode 34h,35h,36h / VESA Mode 134h,135h,136h
    //       320x240 16-bit Color Graphics (8x8 font, 40x30 "Text")
    { 0x28, 0x1D, 0x08, 0xE3, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0x0B, 0x3E, 0xC0, 0xEA, 0x0C, 0xDF, 0xDF, 0x0C },

    // 2. Mode 31h,32h,33h / VESA Mode 131h,132h,133h
    //    320x400 16-bit Color Graphics (8x16 font, 40x25 "Text")
    { 0x28, 0x18, 0x10, 0x63, 0x01, 0x2D, 0x27, 0x27, 0x91, 0x2A, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 3. Mode 37h,38h,39h / VESA Mode 137h,138h,139h
    //       400x300 16-bit Color Graphics (8x8 font, 50x37 "Text")
    { 0x32, 0x24, 0x08, 0x2B, 0x01, 0x3D, 0x31, 0x31, 0x81, 0x35, 0x1D,
      0x72, 0xF0, 0xE0, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 4. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       480x360 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x3C, 0x2C, 0x08, 0xEB, 0x01, 0x49, 0x3B, 0x3B, 0x8D, 0x40, 0x08,
      0xE8, 0xF0, 0xE0, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },

    // 5. Mode 3Ah,3Bh,3Ch / VESA Mode 13Ah,13Bh,13Ch
    //       512x384 16-bit Color Graphics (8x8 font, 64x48 "Text")
    { 0x40, 0x2F, 0x08, 0xEB, 0x01, 0x4F, 0x3F, 0x3F, 0x93, 0x43, 0x0B,
      0x24, 0xF5, 0xE0, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // 6. Mode 5Bh / VESA Mode 100h / Internal Mode 26h
    //       640x400 8-bit Color Graphics (8x16 font, 80x25 "Text")
    { 0x50, 0x18, 0x10, 0x63, 0x01, 0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
      0xBF, 0x1F, 0x40, 0x9C, 0x0E, 0x8F, 0x8F, 0xC0 },

    // 7. Internal Mode 9
    // Mode 58 / VESA Mode 6A / VESA Mode 102 800x600x4
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6B, 0x1B,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 8. Mode 6F / VESA Mode 114h / Internal Mode 24h
    //       800x600 16-bit Color Graphics (8x16 font, 100x37 "Text")
    { 0x64, 0x24, 0x10, 0x2B, 0x01, 0x7F, 0x63, 0x63, 0x83, 0x6A, 0x1A,
      0x72, 0xF0, 0x60, 0x59, 0x0D, 0x57, 0x57, 0x73 },

    // 9. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       960x720 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x78, 0x2C, 0x10, 0xEB, 0x01, 0x97, 0x77, 0x77, 0x9B, 0x7F, 0x0B,
      0xE8, 0xF0, 0x60, 0xD1, 0x04, 0xCF, 0xCF, 0xE9 },

    // A. Mode B
    // Mode 5D / VESA Mode 104 1024x768x4
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x85, 0x96,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // B. Mode 72 / VESA Mode 117h / Internal Mode 25h
    //       1024x768 16-bit Color Graphics (8x16 font, 128x48 "Text")
    { 0x80, 0x2F, 0x10, 0xEB, 0x01, 0xA3, 0x7F, 0x7F, 0x87, 0x84, 0x95,
      0x24, 0xF5, 0x60, 0x03, 0x09, 0xFF, 0xFF, 0x25 },

    // C. Mode 41h/42h/43h / VESA Mode 141,142,143
    // 1152x864x16
    { 0x90, 0x35, 0x10, 0x2B, 0x01, 0xB9, 0x8F, 0x8F, 0x9D, 0x9A, 0x89,
      0x7D, 0xFF, 0x60, 0x61, 0x04, 0x5F, 0x5F, 0x7E },

    // D. Internal Mode F
    // Mode 5A / VESA Mode 106 1280x1024x4
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xAA, 0x1A,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },

    // E. Internal Mode 10
    // Mode 6B / VESA Mode 107 1280x1024x8
    { 0xA0, 0x3F, 0x10, 0x2B, 0x01, 0xCF, 0x9F, 0x9F, 0x93, 0xA9, 0x19,
      0x28, 0x5A, 0x60, 0x01, 0x04, 0xFF, 0xFF, 0x29 },

    // F. Mode 45h/46h / VESA Mode 145,146
    // 1600x1200x16
    { 0xC8, 0x4A, 0x10, 0x2B, 0x01, 0x03, 0xC7, 0xC7, 0x87, 0xD1, 0x09,
      0xE0, 0x10, 0x40, 0xB1, 0x04, 0xAF, 0xAF, 0xE1 },

    // JJV - Start
    // 10. Mode ?
    // 1880x1440x8
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },

    // 11. Mode ?
    // 1880x1440x16
    { 0xE1, 0x59, 0x10, 0x2B, 0x01, 0x2E, 0xE0, 0xE0, 0x92, 0xF2, 0x8B,
      0xD0, 0x1F, 0x40, 0xA1, 0x24, 0x9F, 0x9F, 0xD1 },

    // 12. Mode ?
    // 1920x1080x8
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 13. Mode ?
    // 1920x1080x16
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 14. Mode ?
    // 1920x1080x32
    { 0xF0, 0x42, 0x10, 0x2B, 0x01, 0x3D, 0xEF, 0xEF, 0x81, 0x00, 0x1A,
      0x5C, 0x10, 0x40, 0x39, 0x2C, 0x37, 0x37, 0x5D },

    // 15. Mode ?
    // 1920x1200x8
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },

    // 16. Mode ?
    // 1920x1200x16
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },

    // 17. Mode ?
    // 1920x1200x32
    { 0xF0, 0x4A, 0x10, 0x2B, 0x01, 0x3F, 0xEF, 0xEF, 0x83, 0x01, 0x1B,
      0xD8, 0x10, 0x40, 0xB0, 0x23, 0xAF, 0xAF, 0xD9 },
    // JJV - End

    // 18. Mode ?
    // 1600x1024x8
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 },

    // 19. Mode ?
    // 1600x1024x16
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 },

    // 1A. Mode ?
    // 1600x1024x32
    { 0xC8, 0x3F, 0x10, 0x2B, 0x01, 0x07, 0xC7, 0xC7, 0x8B, 0xD6, 0x0B,
      0x22, 0x5A, 0x60, 0x00, 0x23, 0xFF, 0xFF, 0x23 }
    // VEL - End



};

//******************************************************************************
// NV4 specific data
//******************************************************************************
//
// NV4 Fifo/Watermark settings (100MHz/100MHz operation)
//
MODESET_FIFO DACFifoTable[] =
{
    { 440, 0x20, 0x03, 0x20, 0x04 },
    { 460, 0x21, 0x03, 0x21, 0x04 },
    { 480, 0x23, 0x03, 0x23, 0x04 },
    { 500, 0x26, 0x03, 0x26, 0x04 },
    { 520, 0x27, 0x03, 0x27, 0x04 },
    { 540, 0x27, 0x03, 0x27, 0x04 },
    { 560, 0x29, 0x03, 0x29, 0x04 },
    { 580, 0x2b, 0x03, 0x2b, 0x04 },
    { 600, 0x2e, 0x03, 0x2e, 0x04 },
    { 620, 0x31, 0x03, 0x31, 0x04 },
    { 640, 0x32, 0x02, 0x32, 0x04 },
    { 660, 0x32, 0x02, 0x32, 0x04 },
    { 680, 0x33, 0x02, 0x33, 0x04 },
    { 700, 0x34, 0x02, 0x34, 0x04 },
    { 720, 0x36, 0x02, 0x36, 0x04 },
    { 740, 0x3a, 0x01, 0x3a, 0x04 },
    {0xFFFF, 0x3f, 0x01, 0x3f, 0x04}    // max marker
};


#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\acpi.c ===
//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nvos.h"

#include "rm.h"
#include "nvcm.h"
#include "modeext.h"

#if (_WIN32_WINNT >= 0x500)
ULONG
NVGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );

#endif  // #if (_WIN32_WINNT >= 0x500)

#if defined(ALLOC_PRAGMA)
#if (_WIN32_WINNT >= 0x500)
#pragma alloc_text(PAGE, NVGetChildDescriptor)
#endif  // #if (_WIN32_WINNT >= 0x500)
#endif  // #if defined(ALLOC_PRAGMA)

ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);

BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG  ulDisplayIndex,
    PUCHAR QueryBuffer,
    ULONG  BufferSize);

#ifdef NVPE
VP_STATUS NVRegistryCallbackPnpId(PVOID HwDeviceExtension, PVOID Context, PWSTR ValueName, PVOID ValueData, ULONG ValueLength);
#endif

extern VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
extern VP_STATUS NVGetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    );
extern VP_STATUS NVSetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    );


BOOLEAN NVInitialize_DacsAndEDID(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bBootTime);
ULONG MaskToDeviceType(ULONG ulDeviceMask);
ULONG MaskToFindModeEntryDeviceType(ULONG ulDeviceMask);
VOID  ChoosePrimaryDevice(PHW_DEVICE_EXTENSION HwDeviceExtension, NVTWINVIEWDATA *pData);
BOOLEAN  bQueryinSpanningMode(PHW_DEVICE_EXTENSION hwDeviceExtension);
BOOLEAN  bAllowHotKeyInSpanningMode(PHW_DEVICE_EXTENSION hwDeviceExtension);

BOOLEAN  bQueryInFSDOSorVGAMode(PHW_DEVICE_EXTENSION hwDeviceExtension);
BOOLEAN  bQuerySpanDualDevicesSame(PHW_DEVICE_EXTENSION hwDeviceExtension, ULONG ulDeviceMask0, ULONG ulDeviceMask1);
BOOLEAN ACPIValidateChildStateShouldFail(PHW_DEVICE_EXTENSION hwDeviceExtension);

extern VOID EnterFPCode(VOID *pSave, VOID *pMutex);
extern VOID ExitFPCode(VOID *pSave, VOID *pMutex);
extern int FindModeEntry (LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew);
extern VOID HandleDualviewHeads(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bEnableDualView);

//**************************************************************************
// NT 5.0 specific entry points.
//**************************************************************************

#if (_WIN32_WINNT >= 0x0500)
//
// Returns the corresponding nVidia device mask given a ACPI hardware ID.
// If the ACPIHwId is an invalid device, returns 0.
//
ULONG ACPIHwIdToMask( ULONG ACPIHwId)
{
    switch (ACPIHwId)
    {
    // Refer to Table A-2 of Appenidix A of the document
    // "ACPI extensions for Display Adapters" for a list 
    // of the "commonly used device IDs"
    case QUERY_ACPI_CRT_ID:
        // This is the Monitor. Our device mask is 0x1 for the CRT.
        return (0x1);
    case QUERY_ACPI_DFP_ID:
        // This is the DFP. Our device mask is 0x10000 for the DFP.
        return(0x10000);
    case QUERY_ACPI_TV_ID:
        // This is the TV. Our device mask is 0x100 for the TV.
        return(0x100);
    case 0:
        // Other device. What do we do here?
        VideoDebugPrint((0,"Oops! ChildEnumInfo->ACPIHwId is 0. Not sure what we do here!\n"));
        return(0);
    default:
        VideoDebugPrint((1,"OOps! Error: Unknown ACPIHwID: 0x%x\n", ACPIHwId));
        return(0);
    }
}

//
// Returns TRUE if we are in spanning mode. else returns FALSE
//
BOOLEAN  bQueryInSpanningMode(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    NV_DESKTOP_INFO * pInfo;
    pInfo = &hwDeviceExtension->DeskTopInfo;

    //
    // Detect if we are in spanning mode.
    //
    if (MULTIMON_MODE(pInfo->ulDesktopWidth, pInfo->ulDesktopHeight))
    {
        return(TRUE);
    }

    //
    // Handle the special resolution of 6x4, 8x6 and 10x7 which are present in spanning modes also.
    //
    if (pInfo->ulTwinView_State == NVTWINVIEW_STATE_SPAN)
    {
        return(TRUE);

    }

    //
    // We are ins tandard or clone mode.
    //
    return(FALSE);

}

//
// Returns TRUE if we are in FSDOS or VGA mode. else returns FALSE
//
BOOLEAN  bQueryInFSDOSorVGAMode(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    NV_DESKTOP_INFO * pInfo;
    pInfo = &hwDeviceExtension->DeskTopInfo;

    //
    // Detect if we are in full screen mode.
    // Or if we are in VGA mode (such as via the F8 option of "VGA mode" at bootup time.
    // Here we want to pass VALIDATE_CHILD_DEVICE but fail SET_CHILD_DEVICE so that the OS will
    // call the VBIOS to do the switching. Note that the GET_CHILD_STATE has to be consistent with the
    // devices specified in VALIDATE_CGILD_DEVICE and SET_CHILD_DEVICE.
    //
    if (hwDeviceExtension->SystemModeSetHasOccurred && pInfo->ulDesktopMode == 0)
    {
        return(TRUE);
    }
    if (hwDeviceExtension->SystemModeSetHasOccurred == 0)
    {
        return(TRUE);
    }
    //
    // We are in high res mode.
    //
    return(FALSE);
}

//
// Returns TRUE if
// - system is currently in spanning mode. AND
// - same devices being used
//
BOOLEAN  bQuerySpanDualDevicesSame(PHW_DEVICE_EXTENSION hwDeviceExtension, ULONG ulDeviceMask0, ULONG ulDeviceMask1)
{
    ULONG ulCombinedMask_Current;
    ULONG ulCombinedMask_Requested;
    NV_DESKTOP_INFO * pInfo;
    pInfo = &hwDeviceExtension->DeskTopInfo;
    
    if (bQueryInSpanningMode(hwDeviceExtension))
    {
        ulCombinedMask_Current = pInfo->ulDeviceMask[0] | pInfo->ulDeviceMask[1];
        ulCombinedMask_Requested = ulDeviceMask0 | ulDeviceMask1;
        if (ulCombinedMask_Current == ulCombinedMask_Requested)
        {
            return(TRUE);
        }
    }
    return(FALSE);
}

//
// Returns TRUE we should do HK switches in spanning mode.
// By default, we disallow HK switches in spanning mode except when one or both of the external devices
// (CRT or TV) has been disconnected and the NVSVC has been started.
//
BOOLEAN  bAllowHotKeyInSpanningMode(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    NV_DESKTOP_INFO * pInfo;
    ULONG ulExternalDeviceMask;
    ULONG ulDeviceMask, ulHead, i, ulTmp;
    pInfo = &hwDeviceExtension->DeskTopInfo;

    //
    // sanity check. Make sure we are called for spanning mode.
    //
    if (pInfo->ulTwinView_State != NVTWINVIEW_STATE_SPAN)
    {
        return(TRUE);
    }
    //
    // Construct device masks of the external devices (TV or CRT) being used in the spanning mode.
    //
    ulExternalDeviceMask = 0;
    for (i=0; i < pInfo->ulNumberDacsActive; i++)
    {
        ulHead = pInfo->ulDeviceDisplay[i];
        ulDeviceMask = pInfo->ulDeviceMask[ulHead];
        if (ulDeviceMask & (BITMASK_ALL_CRT | BITMASK_ALL_TV))
        {
            ulExternalDeviceMask |= ulDeviceMask;
        }
    }
    //
    // Now check to see if all of these are still connected
    //
    ulTmp = ulExternalDeviceMask;
    if (!RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                        NV_CFGEX_CHECK_CONNECTED_DEVICES, &ulTmp, 
                        sizeof(ULONG)))
    {
        VideoDebugPrint((1, "Something wrong. RM failed for CHECK_CONNECTED_DEVICES\n"));
        return(FALSE);
    }
    if (ulTmp != ulExternalDeviceMask)
    {
        //
        // We need to allow the HK switch since one or both of the external devices are missing.
        // We can do the switch only if the NVSVC has started.
        //
        if (hwDeviceExtension->ulNVSVCStatus == NVSVC_STATUS_STARTED)
        {
            return(TRUE);
        }
    }
    return(FALSE);
}

//
// Returns TRUE if we should not do hot key swtiches.
// Returns FALSE if we should do hot key switches.
// The current set of conditions for which we do not do hotkeying are
// 1. we are in full screen DOS mode. Let BIOS handle it.
// 2. we are in spanning mode.
// 3. Video app is active: BUGBUG: Not implemented yet.
//
BOOLEAN ACPIValidateChildStateShouldFail(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    NV_DESKTOP_INFO * pInfo;

    pInfo = &hwDeviceExtension->DeskTopInfo;
    

    // Note: The FSDOS or VGA mode boot case are now handled in nvSetChildState() call.

    // Detect if we are in spanning mode.
    if (bQueryInSpanningMode(hwDeviceExtension))
    {
        //
        // We ignore hotkeys in spanning mode if the external device (either CRT or TV) is absent.
        //
        if (!bAllowHotKeyInSpanningMode(hwDeviceExtension))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

//
// Writes the current mode info to the registry so that the DrvEnablePdev() in the display driver can
// force GDI to use the same mode across hotkey switches. By default, GDI remembers the mode
// on each devices and tries to use that remembered mode.
//
VOID ACPIToshibaModeToRegistry(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    TOSHIBA_HOTKEY_MODE sMode;
    NV_DESKTOP_INFO *pInfo;
    ULONG ulPrimaryHead;

    pInfo = &hwDeviceExtension->DeskTopInfo;
    ulPrimaryHead = pInfo->ulDeviceDisplay[0];

    // The display driver should invalidate this registry entry by writing the ValidMode field to zero
    // after it uses this info in either DrvEnablePdev() or DrvAssertMode(). GDI calls DrvAssertMode() if 
    // the same desktop is maintained. GDI calls DrvEnablePdev() if the remembered mode is different than the
    // current desktop for this device.
    // Also, the FindAdapter() boottime routine should set this field
    // to zero if this registry entry exists. This is to handle the pathologicl case of when the user has hit the 
    // hotkey function key but the system is powered off before the corresponding DrvEnablePdev() or DrvAssertMode()
    // is received.
    sMode.ValidMode = 1;
    sMode.Width = (USHORT)pInfo->ulDesktopWidth;
    sMode.Height = (USHORT)pInfo->ulDesktopHeight;
    sMode.Depth = (USHORT)pInfo->ulDisplayPixelDepth[ulPrimaryHead];
    sMode.RefreshRate = (USHORT)pInfo->ulDisplayRefresh[ulPrimaryHead];

    // Write the info to registry.
    VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"ForceGDIMode",
                                       &sMode,
                                       sizeof(TOSHIBA_HOTKEY_MODE));

}

//
// Handler for hot key switching for switching into single device configuration.
// Blows away any info existing in the TwinViewInfo registry structure (if it exists).
// Writes the full TwinViewInfo structure appropriately.
//
VOID ACPISingleDeviceSwitch(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulDeviceMask)
{
    NVTWINVIEWDATA Data;
    NVTWINVIEWDATA * pData;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData0;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData1;
    ULONG ulPrimaryHead;
    NV_DESKTOP_INFO *pInfo;
    ULONG GDIWidth, GDIHeight, GDIRefreshRate, GDIDepth, GDIPrimaryHead;
    ULONG i;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;
    ULONG ulRet;

    // FindModeEntry() related fields.
    LPDISPDATA  lpDispData;
    LPMODEINFO  lpModeDesc;
    LPMODEOUT   lpModeOut;
    LPMODEINFO  lpModeNew;
    ULONG       ulFrequencyHead;
    DISPDATA    DispData;
    MODEINFO    ModeDesc;
    MODEOUT     ModeOut;
    MODEINFO    ModeNew;
    ULONG       ulDeviceType, ulTVFormat, ulIndex;
    LPEDID_UNIT pEdidUnit;


    ulDeviceType = MaskToDeviceType(ulDeviceMask);
    ulIndex = ConvertDeviceMaskToIndex(ulDeviceMask);
    pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulIndex];
    ulTVFormat = NTSC_M; // Hardcoded. Does not matter. Display driver InitMultiMon() gets the correct TVFormat.
    pInfo = &HwDeviceExtension->DeskTopInfo;

    pData = &Data;
    pData->dwState = NVTWINVIEW_STATE_NORMAL;
    pData->dwOrientation = 0;
    pData->dwAllDeviceMask = pInfo->ulAllDeviceMask;
    pData->dwConnectedDeviceMask = pInfo->ulConnectedDeviceMask;
    pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
    pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];

    // Initialize the rectangles to zeros.
    pData->DeskTopRectl.left = 0;
    pData->DeskTopRectl.top = 0;
    pData->DeskTopRectl.right = 0;
    pData->DeskTopRectl.bottom = 0;

    for (i=0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;

        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];
        pDevData->VirtualRectl.left = 0;
        pDevData->VirtualRectl.top = 0;
        pDevData->VirtualRectl.right = 0;
        pDevData->VirtualRectl.bottom = 0;
        pDevData->PhysicalRectl.left = 0;
        pDevData->PhysicalRectl.top = 0;
        pDevData->PhysicalRectl.right = 0;
        pDevData->PhysicalRectl.bottom = 0;
        pDevData->dwBpp = 0;
        pDevData->dwRefresh = 0;
        pDevData->dwDeviceMask = BITMASK_INVALID_DEVICE;
        pDevData->dwDeviceType = INVALID_DEVICE_TYPE;
        pDevData->dwTVFormat = 0;
        pDevData->dwNumPhysModes = 0;
        pDevData->dwNumVirtualModes = 0;
    }


    // Get our current desktop info
    GDIWidth = pInfo->ulDesktopWidth;
    GDIHeight = pInfo->ulDesktopHeight;

    // If currently we are in spanning mode, we need to half the resolution. Careful of the special
    // 6x4, 8x6 and 10x7 modes in spanning mode.
    if (bQueryInSpanningMode(HwDeviceExtension))
    {
        if HORIZONTAL_MODE(GDIWidth, GDIHeight)
        {
            GDIWidth /= 2;
        }
        else
        if VERTICAL_MODE(GDIWidth, GDIHeight)
        {
            GDIHeight /= 2;
        }
    }

    
    GDIPrimaryHead = pInfo->ulDeviceDisplay[0];
    GDIRefreshRate = pInfo->ulDisplayRefresh[GDIPrimaryHead];
    GDIDepth = pInfo->ulDisplayPixelDepth[GDIPrimaryHead];

    // Set the desktopRectl with this info.
    // Note that we _have_ to maintain the same width, height and depth. We could get away with
    // a different refresh rate.
    pData->DeskTopRectl.right = GDIWidth;
    pData->DeskTopRectl.bottom = GDIHeight;


    // Ask the resman what head to use for this device.
    // Ask ResMan what head to use.
    nvConfig.DevicesConfig = ulDeviceMask;
    nvConfig.OldDevicesConfig = 0;
    nvConfig.OldDevicesAllocationMap = 0;
    nvConfig.DevicesAllocationMap = 0;


    if (!RmConfigGetExKernel (HwDeviceExtension->DeviceReference, 
                              NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
    {

        VideoDebugPrint((0, "ACPISingleDeviceSwitch - Cannot get DEVICES_CONFIG value from RM\n"));
    }
    else
    {
        if (nvConfig.DevicesAllocationMap > 1)
        {
            VideoDebugPrint((0,"Oops! Invalid DevAllocationMap from RM: 0x%x\n",nvConfig.DevicesAllocationMap));
        }


        if (nvConfig.DevicesAllocationMap == 0)
        {
            pDevData0->dwDeviceMask = ulDeviceMask;
            pDevData0->dwDeviceType = ulDeviceType;
            pDevData0->dwTVFormat = ulTVFormat;
            pDevData0->VirtualRectl.right = GDIWidth;
            pDevData0->VirtualRectl.bottom = GDIHeight;
            pDevData0->PhysicalRectl.right = GDIWidth;
            pDevData0->PhysicalRectl.bottom = GDIHeight;
            pDevData0->dwBpp = GDIDepth;
            pDevData0->dwRefresh = GDIRefreshRate;

            pDevData1->dwDeviceMask = BITMASK_INVALID_DEVICE;
            pData->dwDeviceDisplay[0] = 0;
            pData->dwDeviceDisplay[1] = 1;
        }
        if (nvConfig.DevicesAllocationMap == 1)
        {
            pDevData1->dwDeviceMask = ulDeviceMask;
            pDevData1->dwDeviceType = ulDeviceType;
            pDevData1->VirtualRectl.right = GDIWidth;
            pDevData1->VirtualRectl.bottom = GDIHeight;
            pDevData1->PhysicalRectl.right = GDIWidth;
            pDevData1->PhysicalRectl.bottom = GDIHeight;
            pDevData1->dwBpp = GDIDepth;
            pDevData1->dwRefresh = GDIRefreshRate;

            pDevData0->dwDeviceMask = BITMASK_INVALID_DEVICE;
            pData->dwDeviceDisplay[0] = 1;
            pData->dwDeviceDisplay[1] = 0;
        }
    }

    ulPrimaryHead = pData->dwDeviceDisplay[0];


    // Now see if the current desktop can be supported natively on this device.
    // If so, we will use the same dimensions for the physical mode also.
    // Otherwise, we will have to use pan-scan.
    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;

    ulFrequencyHead = ulPrimaryHead;
    if (ulPrimaryHead == 1 && ulDeviceType != MONITOR_TYPE_VGA)
    {
        ulFrequencyHead = 0;
    }
    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    if (pEdidUnit->Valid)
    {
        lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
    }
    else
    {
        lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
    }
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwCRTCIndex = ulPrimaryHead;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    // Now validate against the pixel frequency of the head.
    lpModeDesc->dwXRes = GDIWidth;
    lpModeDesc->dwYRes = GDIHeight;
    lpModeDesc->dwBpp  = GDIDepth;
    lpModeDesc->dwRefreshRate   = GDIRefreshRate;
    lpModeDesc->dwOriginalRefreshRate = GDIRefreshRate;
    lpModeDesc->dwDevType  = MaskToFindModeEntryDeviceType(ulDeviceMask);
    lpModeDesc->dwTVFormat = ulTVFormat;

    lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(ulDeviceMask);
    lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(ulDeviceMask);
    lpModeDesc->MIDevData.cFormat   = (CHAR)ulTVFormat;
    lpModeDesc->MIDevData.cReserved = 0x0;

    // Call the modeset DLL to see if this mode is valid.
    // We are not interested in the mode timings but just to see if this is a valid mode.
    VideoDebugPrint((1,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                     lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((1,"ulDeviceMask: 0x%x, ulIndex: %d, MonitorInfType: 0x%x, EDIDBufferValid: 0x%x\n",
                     ulDeviceMask, ulIndex, lpDispData->dwMonitorInfType, pEdidUnit->Valid)); 


    if (ulDeviceType == MONITOR_TYPE_NTSC || ulDeviceType == MONITOR_TYPE_PAL)
    {
        ulRet = 0;

        if (HwDeviceExtension->ulTVEncoderType == NV_ENCODER_BROOKTREE_871)
        {
            if (lpModeDesc->dwXRes > 1024 || lpModeDesc->dwYRes > 768 || lpModeDesc->dwRefreshRate != 60)
            { 
                // Not a valid mode. Limit it to 1024x768x60HZ.
                ulRet = 1; // Any non-zero value will do.
                lpModeNew->dwXRes = 1024;
                lpModeNew->dwYRes = 768;
                lpModeNew->dwBpp = lpModeDesc->dwBpp;
                lpModeNew->dwRefreshRate = 60; 
                lpModeNew->dwDevType = lpModeDesc->dwDevType;
                lpModeNew->dwOriginalRefreshRate = lpModeDesc->dwRefreshRate;
            }
        }
        else if (lpModeDesc->dwXRes > 800 || lpModeDesc->dwYRes > 600 || lpModeDesc->dwRefreshRate != 60)
        {
            // Not a valid mode. Limit to 800x600x60
                ulRet = 1; // Any non-zero value will do.
                lpModeNew->dwXRes = 800;
                lpModeNew->dwYRes = 600;
                lpModeNew->dwBpp = lpModeDesc->dwBpp;
                lpModeNew->dwRefreshRate = 60; 
                lpModeNew->dwDevType = lpModeDesc->dwDevType;
                lpModeNew->dwOriginalRefreshRate = lpModeDesc->dwRefreshRate;
        }
    }
    else
    {
        // Not TV. Ask the common modeset code.
        EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
        ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                              lpModeDesc, lpModeOut, lpModeNew);
        ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    }

    VideoDebugPrint((1,"ulRet: 0x%x\n",ulRet));
    VideoDebugPrint((1,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                     lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((1,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                     lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

    if (ulRet != 0)
    {
        // This mode is not physically supported.
        // Use the recommended physically supported mode info - width, height and refresh.
        // We can not change the depth.
        if (ulPrimaryHead == 0)
        {
            pDevData0->PhysicalRectl.right = lpModeNew->dwXRes;
            pDevData0->PhysicalRectl.bottom = lpModeNew->dwYRes;
            pDevData0->dwRefresh = lpModeNew->dwRefreshRate;
        }
        if (ulPrimaryHead == 1)
        {
            pDevData1->PhysicalRectl.right = lpModeNew->dwXRes;
            pDevData1->PhysicalRectl.bottom = lpModeNew->dwYRes;
            pDevData1->dwRefresh = lpModeNew->dwRefreshRate;
        }
    }

    NVSetRegistryTwinviewInfo(HwDeviceExtension, pData);

    // For Toshiba, update the desired desktop mode info.
    if (HwDeviceExtension->UseHotKeySameMode)
    {
        ACPIToshibaModeToRegistry(HwDeviceExtension);
    }

    // Update the DesktopInfo structure of hwDevExtension since DrvGetModes() will get called before
    // DrvASsertMode().
    pInfo->ulNumberDacsActive = 1;
    for (i = 0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;
        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];

        pInfo->ulDeviceDisplay[i] = pData->dwDeviceDisplay[i];
        pInfo->ulDeviceMask[i] = pDevData->dwDeviceMask;
        pInfo->ulDeviceType[i] = pDevData->dwDeviceType;
        pInfo->ulTVFormat[i] = pDevData->dwTVFormat;
    }
    return;
}


//
// Handler for hot key switching for switching into dual device configuration.
// Blows away any info existing in the TwinViewInfo registry structure (if it exists).
// Writes the full TwinViewInfo structure appropriately.
//
VOID ACPIDualDeviceSwitch(PHW_DEVICE_EXTENSION hwDeviceExtension, ULONG ulDeviceMask0, ULONG ulDeviceMask1)
{
    NVTWINVIEWDATA Data;
    NVTWINVIEWDATA * pData;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData0;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData1;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;
    ULONG ulHead;
    NV_DESKTOP_INFO *pInfo;
    ULONG GDIWidth, GDIHeight, GDIRefreshRate, GDIDepth, GDIPrimaryHead;
    ULONG i;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;
    ULONG ulRet;
    ULONG ulIndex;
    PHW_DEVICE_EXTENSION HwDeviceExtension;
    ULONG ulTmp;

    #define CRT_MASK 0x1
    #define DFP_MASK 0x10000
    #define TV_MASK 0x100

    // FindModeEntry() related fields.
    LPDISPDATA lpDispData;
    LPMODEINFO lpModeDesc;
    LPMODEOUT  lpModeOut;
    LPMODEINFO lpModeNew;
    ULONG ulFrequencyHead;
    DISPDATA DispData;
    MODEINFO ModeDesc;
    MODEOUT  ModeOut;
    MODEINFO ModeNew;
    ULONG ulDeviceType0, ulTVFormat0, ulIndex0;
    ULONG ulDeviceType1, ulTVFormat1, ulIndex1;

    HwDeviceExtension = hwDeviceExtension;


    if (ulDeviceMask0 > ulDeviceMask1)
    {
        // For ease of interacting with the resman to get the devices_configuration, we want to keep
        // deviceMask0 to be the lesser of the mask
        ulTmp = ulDeviceMask0;
        ulDeviceMask0 = ulDeviceMask1;
        ulDeviceMask1 = ulTmp;
    }

    ulDeviceType0 = MaskToDeviceType(ulDeviceMask0);
    ulIndex0 = ConvertDeviceMaskToIndex(ulDeviceMask0);
    ulTVFormat0 = NTSC_M; // Hardcoded. Does not matter. Display driver InitMultiMon() gets the correct TVFormat.
    ulDeviceType1 = MaskToDeviceType(ulDeviceMask1);
    ulIndex1 = ConvertDeviceMaskToIndex(ulDeviceMask1);
    ulTVFormat1 = NTSC_M; // Hardcoded. Does not matter. Display driver InitMultiMon() gets the correct TVFormat.

    pInfo = &HwDeviceExtension->DeskTopInfo;

    pData = &Data;
    pData->dwState = NVTWINVIEW_STATE_CLONE;
    pData->dwOrientation = 0;
    pData->dwAllDeviceMask = pInfo->ulAllDeviceMask;
    pData->dwConnectedDeviceMask = pInfo->ulConnectedDeviceMask;
    pData->dwDeviceDisplay[0] = 0;
    pData->dwDeviceDisplay[1] = 1;
    pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
    pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];

    // Initialize the rectangles to zeros.
    pData->DeskTopRectl.left = 0;
    pData->DeskTopRectl.top = 0;
    pData->DeskTopRectl.right = 0;
    pData->DeskTopRectl.bottom = 0;

    for (i=0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;

        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];
        pDevData->VirtualRectl.left = 0;
        pDevData->VirtualRectl.top = 0;
        pDevData->VirtualRectl.right = 0;
        pDevData->VirtualRectl.bottom = 0;
        pDevData->PhysicalRectl.left = 0;
        pDevData->PhysicalRectl.top = 0;
        pDevData->PhysicalRectl.right = 0;
        pDevData->PhysicalRectl.bottom = 0;
        pDevData->dwBpp = 0;
        pDevData->dwRefresh = 0;
        pDevData->dwDeviceMask = BITMASK_INVALID_DEVICE;
        pDevData->dwDeviceType = INVALID_DEVICE_TYPE;
        pDevData->dwTVFormat = 0;
        pDevData->dwNumPhysModes = 0;
        pDevData->dwNumVirtualModes = 0;
    }


    // Get our current desktop info
    
    GDIWidth = pInfo->ulDesktopWidth;
    GDIHeight = pInfo->ulDesktopHeight;
    GDIPrimaryHead = pInfo->ulDeviceDisplay[0];
    GDIRefreshRate = pInfo->ulDisplayRefresh[GDIPrimaryHead];
    GDIDepth = pInfo->ulDisplayPixelDepth[GDIPrimaryHead];

    // Set the desktopRectl with this info.
    // Note that we _have_ to maintain the same width, height and depth. We could get away with
    // a different refresh rate.
    pData->DeskTopRectl.right = GDIWidth;
    pData->DeskTopRectl.bottom = GDIHeight;

    for (i=0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;

        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];
        pDevData->VirtualRectl.right = GDIWidth;
        pDevData->VirtualRectl.bottom = GDIHeight;
        pDevData->PhysicalRectl.right = GDIWidth;
        pDevData->PhysicalRectl.bottom = GDIHeight;
        pDevData->dwBpp = GDIDepth;
        pDevData->dwRefresh = GDIRefreshRate;
    }


    // Ask the resman what head to use for these devices.
    // Ask ResMan what head to use.
    nvConfig.DevicesConfig = ulDeviceMask0 | ulDeviceMask1;
    nvConfig.OldDevicesConfig = 0;
    nvConfig.OldDevicesAllocationMap = 0;
    nvConfig.DevicesAllocationMap = 0;


    if (!RmConfigGetExKernel (HwDeviceExtension->DeviceReference, 
                              NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
    {

        VideoDebugPrint((0, "ACPIDualDeviceSwitch - Cannot get DEVICES_CONFIG value from RM\n"));
    }
    else
    {
        // We got a successful head assignment for both the devices.
        switch (nvConfig.DevicesAllocationMap)
        {
        case 0x10:
            // Head assignment 1, 0
            pDevData0->dwDeviceMask = ulDeviceMask0;
            pDevData0->dwDeviceType = ulDeviceType0;
            pDevData0->dwTVFormat = ulTVFormat0;
            pDevData1->dwDeviceMask = ulDeviceMask1;
            pDevData1->dwDeviceType = ulDeviceType1;
            pDevData1->dwTVFormat = ulTVFormat1;
            break;
        case 0x01:
            // Head assignment 0, 1
            pDevData0->dwDeviceMask = ulDeviceMask1;
            pDevData0->dwDeviceType = ulDeviceType1;
            pDevData0->dwTVFormat = ulTVFormat1;
            pDevData1->dwDeviceMask = ulDeviceMask0;
            pDevData1->dwDeviceType = ulDeviceType0;
            pDevData1->dwTVFormat = ulTVFormat0;
            break;
        default:
            VideoDebugPrint((0,"Oops! Unexpected head allocationMap: 0x%x\n",  nvConfig.DevicesAllocationMap));
            break;
        }

        // The combinations we have are: CRT+DFP, DFP+TV, CRT+TV.
        // Make sure the primary head is preferably CRT, DFP, TV in that order because they typically support
        // more number of modes in that order. One of clone mode's restriction is that all modes must
        // be natively supported by the primary device per Peter Daifuku's specs.
        if ((pDevData0->dwDeviceMask == DFP_MASK && pDevData1->dwDeviceMask == CRT_MASK) ||
            (pDevData0->dwDeviceMask == TV_MASK && pDevData1->dwDeviceMask == DFP_MASK) ||
            (pDevData0->dwDeviceMask == TV_MASK && pDevData1->dwDeviceMask == CRT_MASK))
        {
            // Swap the heads.
            pData->dwDeviceDisplay[0] = 1;
            pData->dwDeviceDisplay[1] = 0;
        }
        else
        {
            // Keep the same order
            pData->dwDeviceDisplay[0] = 0;
            pData->dwDeviceDisplay[1] = 1;
        }
    }

    


    // Now see if the current desktop can be supported natively on this device.
    // If so, we will use the same dimensions for the physical mode also.
    // Otherwise, we will have to use pan-scan.
    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;

    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    lpModeDesc->dwXRes = GDIWidth;
    lpModeDesc->dwYRes = GDIHeight;
    lpModeDesc->dwBpp = GDIDepth;
    lpModeDesc->dwRefreshRate = GDIRefreshRate;
    lpModeDesc->dwOriginalRefreshRate = GDIRefreshRate;

    for (i = 0; i < NV_NO_DACS; i++)
    {
        LPEDID_UNIT pEdidUnit;
        ulHead = pData->dwDeviceDisplay[i];
        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[ulHead];
        ulIndex = ConvertDeviceMaskToIndex(pDevData->dwDeviceMask);
        pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulIndex];
        ulFrequencyHead = ulHead;
        if (ulHead == 1 && pDevData->dwDeviceType != MONITOR_TYPE_VGA)
        {
            ulFrequencyHead = 0;
        }
        if (pEdidUnit->Valid)
        {
            lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
        }
        else
        {
            lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
        }
        lpDispData->dwCRTCIndex = ulHead;
        lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
        lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
        lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];

        // Now validate against the pixel frequency of the head.

        lpModeDesc->dwDevType  = MaskToFindModeEntryDeviceType(pDevData->dwDeviceMask);
        lpModeDesc->dwTVFormat = pDevData->dwTVFormat;

        lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(pDevData->dwDeviceMask);
        lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(pDevData->dwDeviceMask);
        lpModeDesc->MIDevData.cFormat   = (CHAR)pDevData->dwTVFormat;
        lpModeDesc->MIDevData.cReserved = 0x0;

        // Call the modeset DLL to see if this mode is valid.
        // We are not interested in the mode timings but just to see if this is a valid mode.
        VideoDebugPrint((1,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                         lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                         lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
        VideoDebugPrint((1,"ulDeviceMask: 0x%x, ulIndex: %d, MonitorInfType: 0x%x, EDIDBufferValid: 0x%x\n",
                         pDevData->dwDeviceMask, ulIndex, lpDispData->dwMonitorInfType, pEdidUnit->Valid)); 

        if (pDevData->dwDeviceType == MONITOR_TYPE_NTSC || pDevData->dwDeviceType == MONITOR_TYPE_PAL)
        {
            ulRet = 0;

            if (HwDeviceExtension->ulTVEncoderType == NV_ENCODER_BROOKTREE_871) 
            {
                if (lpModeDesc->dwXRes > 1024 || lpModeDesc->dwYRes > 768 || lpModeDesc->dwRefreshRate != 60)
                { 
                    // Not a valid mode. Limit it to 1024x768x60HZ.
                    ulRet = 1; // Any non-zero value will do.
                    lpModeNew->dwXRes = 1024;
                    lpModeNew->dwYRes = 768;
                    lpModeNew->dwBpp = lpModeDesc->dwBpp;
                    lpModeNew->dwRefreshRate = 60; 
                    lpModeNew->dwDevType = lpModeDesc->dwDevType;
                    lpModeNew->dwOriginalRefreshRate = lpModeDesc->dwRefreshRate;
                }
            }
            else if (lpModeDesc->dwXRes > 800 || lpModeDesc->dwYRes > 600 || lpModeDesc->dwRefreshRate != 60)
            {
                // Not a valid mode. Limit to 800x600x60
                ulRet = 1; // Any non-zero value will do.
                lpModeNew->dwXRes = 800;
                lpModeNew->dwYRes = 600;
                lpModeNew->dwBpp = lpModeDesc->dwBpp;
                lpModeNew->dwRefreshRate = 60; 
                lpModeNew->dwDevType = lpModeDesc->dwDevType;
                lpModeNew->dwOriginalRefreshRate = lpModeDesc->dwRefreshRate;
            }
        }
        else
        {
            EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
            ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                                  lpModeDesc, lpModeOut, lpModeNew);
            ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
        }

        VideoDebugPrint((1,"ulRet: 0x%x\n",ulRet));
        VideoDebugPrint((1,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                         lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                         lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
        VideoDebugPrint((1,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                         lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                         lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

        if (ulRet != 0)
        {
            // This mode is not physically supported.
            // Use the recommended physically supported mode info - width, height and refresh.
            // We can not change the depth.

            pDevData->PhysicalRectl.right = lpModeNew->dwXRes;
            pDevData->PhysicalRectl.bottom = lpModeNew->dwYRes;
            pDevData->dwRefresh = lpModeNew->dwRefreshRate;

        }

    }

    // Update the DesktopInfo structure of hwDevExtension since DrvGetModes() will get called before
    // DrvASsertMode().
    pInfo->ulNumberDacsActive = 2;
    for (i = 0; i < NV_NO_DACS; i++)
    {
        NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;
        pDevData = &pData->NVTWINVIEWUNION.nvtwdevdata[i];

        pInfo->ulDeviceDisplay[i] = pData->dwDeviceDisplay[i];
        pInfo->ulDeviceMask[i] = pDevData->dwDeviceMask;
        pInfo->ulDeviceType[i] = pDevData->dwDeviceType;
        pInfo->ulTVFormat[i] = pDevData->dwTVFormat;
    }

    ChoosePrimaryDevice(HwDeviceExtension, pData);

    NVSetRegistryTwinviewInfo(HwDeviceExtension, pData);

    // For Toshiba, update the desired desktop mode info.
    if (HwDeviceExtension->UseHotKeySameMode)
    {
        ACPIToshibaModeToRegistry(HwDeviceExtension);
    }

     return;
}

//
// Reads the latest connected device mask into the hwDeviceExtension. 
// This is required for Dell. This is a no-op for Toshiba since the 
// connected device mask never changes.
//
VOID GetConnectedDevicesMask(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    ULONG ulPrev;
    NV_DESKTOP_INFO *pDeskTopInfo;

    pDeskTopInfo = (NV_DESKTOP_INFO *)&hwDeviceExtension->DeskTopInfo;
    ulPrev = hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask;
    pDeskTopInfo->ulConnectedDeviceMask = pDeskTopInfo->ulAllDeviceMask;

    if (RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                            NV_CFGEX_CHECK_CONNECTED_DEVICES, &pDeskTopInfo->ulConnectedDeviceMask, 
                            sizeof(pDeskTopInfo->ulConnectedDeviceMask)))
    {

        //
        // success.
        //
        if (pDeskTopInfo->ulConnectedDeviceMask == 0)
        {
            VideoDebugPrint((0,"Oops! ConnectedDevicemask is 0. Assume a CRT\n"));
            pDeskTopInfo->ulConnectedDeviceMask = 0x1;
        }
    }
    else
    {
        //
        // The resman had issues with our request, so spew a warning
        //
        VideoDebugPrint((0, "GetConnectedDevicesMask() -  RmConfigGetExKernel() returned error for NV_CFGEX_CHECK_CONNECTED_DEVICESI\n"));
    }

    //
    // If the new connected device mask is different than the previous one,
    // print a informational debug message.
    //
    if (ulPrev != pDeskTopInfo->ulConnectedDeviceMask)
    {
        VideoDebugPrint((1, "GetConnectedDevicesMask(): Previous ConnectedDevMask: 0x%x different than newConnectedMask: 0x%x\n",
                         ulPrev, pDeskTopInfo->ulConnectedDeviceMask));
    }
    else
    {
        VideoDebugPrint((2, "GetConnectedDevicesMask(): Previous ConnectedDevMask: 0x%x Matches with newConnectedMask: 0x%x\n",
                         ulPrev, pDeskTopInfo->ulConnectedDeviceMask));
    }
}


ULONG
NVGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )

/*++

Routine Description:

    Enumerate all devices controlled by the nVidia graphics chip.
    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    ChildIndex        - Index of the child the system wants informaion for.

    pChildType        - Type of child we are enumerating - monitor, I2C ...

    pChildDescriptor  - Identification structure of the device (EDID, string)

    ppHwId            - Private unique 32 bit ID to passed back to the miniport

    pMoreChildren     - Should the miniport be called

Return Value:

    TRUE if the child device existed, FALSE if it did not.

Note:

    In the event of a failure return, none of the fields are valid except for
    the return value and the pMoreChildren field.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG                Status;
    ULONG                ulDacs;
    ULONG                ulDeviceMask, i, EDIDIndex;
    LPEDID_UNIT          pEdidUnit;

    //
    // Everytime enter here, need to invalidate EDID first
    //
    if (hwDeviceExtension->bNeedRetrieveEDID)
    {
        NVInitialize_DacsAndEDID(hwDeviceExtension, FALSE);
        hwDeviceExtension->bNeedRetrieveEDID = FALSE;
    }

    switch (ChildEnumInfo->ChildIndex) {

    case 0:
        //
        // This system supports ACPI. So mark it so. Note that only laptops seem to call this.
        // Desktops do not call this case.
        //
        hwDeviceExtension->ACPISystem = 1;
        if (hwDeviceExtension->pDualViewAssociatedDE)
        {
            hwDeviceExtension->pDualViewAssociatedDE->ACPISystem = 1;
        }

        //
        // Convert the ACPI Id to a device mask.
        //
        ulDeviceMask = ACPIHwIdToMask(ChildEnumInfo->ACPIHwId);
        if (ulDeviceMask == 0)
        {
            Status = VIDEO_ENUM_NO_MORE_DEVICES;
            return(Status);
        }
        
        //
        // Convert it's mask into an index inorder to retrieve it's EDID structure.
        //
        EDIDIndex = ConvertDeviceMaskToIndex(ulDeviceMask);
        pEdidUnit = hwDeviceExtension->EdidCollection->HeadMaps[EDIDIndex];


        //
        // If the device is a DFP and the registry tells us not to export the EDID, 
        // do not export the EDID.
        // This is to fix Win2k PnP bug of failing to install new PnP monitors
        //
        if (ulDeviceMask == 0x10000 && hwDeviceExtension->DFPAsDefaultMonitor)
        {
            VideoDebugPrint((1, "Not exporting the EDID for DFP per the registry setting\n"));
            *pChildType = Monitor;
            *pHwId = ChildEnumInfo->ACPIHwId;
            Status = VIDEO_ENUM_MORE_DEVICES;
            break;
        }

        //
        // Now we know our device mask. Return the EDID of this device, if it has a valid EDID.
        //
        if (pEdidUnit->Valid)
        {
            // Transfer the real EDID data. 
            VideoPortMoveMemory(pvChildDescriptor, pEdidUnit->EDIDBuffer, pEdidUnit->Size);
        }


        //
        // Set the child type as monitor
        //
        *pChildType = Monitor;

        //
        // Set the UID same as the ACPIHwId
        //
        *pHwId = ChildEnumInfo->ACPIHwId;
        Status = VIDEO_ENUM_MORE_DEVICES;
        break;


    case 1:
    case 2:
        //
        // If we are on a ACPI system (such as a laptop), we do not want to handle this case.
        // This case will handle non-ACPI systems (such as desktops).
        //
        if (hwDeviceExtension->ACPISystem)
        {
            Status = VIDEO_ENUM_INVALID_DEVICE;
            break;
        }

        //
        // For Dualview, we are going to return 2 CRT children
        //
        if (hwDeviceExtension->pDualViewAssociatedDE == NULL && 
            ChildEnumInfo->ChildIndex == 2)
        {
            Status = VIDEO_ENUM_INVALID_DEVICE;
            break;
        }

        //
        // This is the last device we enumerate.  Tell the system we don't
        // have any more.
        //
        *pChildType = Monitor;

        //**********************************************************************
        // Unattended install with Intel 810 present:
        // Make sure to SKIP this call, if the device has NOT been mapped!!!
        // (Skip this function if currently running unattended install with
        // an Intel 810)
        //**********************************************************************

        //
        // Obtain the EDID structure via DDC.
        //

        if ( (hwDeviceExtension->DeviceMappingFailed == FALSE) &&
             (GetDdcInformation(HwDeviceExtension,
                                ChildEnumInfo->ChildIndex-1,
                                (PUCHAR) pvChildDescriptor,
                                ChildEnumInfo->ChildDescriptorSize))    )
        {
            *pHwId = QUERY_MONITOR_ID + (ChildEnumInfo->ChildIndex-1);

            VideoDebugPrint((1, "NvGetChildDescriptor - successfully read EDID structure\n"));

        } else {

            //
            // Alway return TRUE, since we always have a monitor output
            // on the card and it just may not be a detectable device.
            //

            *pHwId = QUERY_NONDDC_MONITOR_ID + (ChildEnumInfo->ChildIndex-1);

            VideoDebugPrint((1, "NvGetChildDescriptor - DDC not supported\n"));

        }

        Status = VIDEO_ENUM_MORE_DEVICES;
        break;

#ifdef NVPE
        case 3:

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_cap",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVCAP_I2C_DEVICE_ID;
                    *pChildType = Other;
                    //VideoPortMoveMemory(pvChildDescriptor, L"nvcap", sizeof(L"nvcap")); //strPnpId, wcslen(strPnpId));
                    Status = VIDEO_ENUM_MORE_DEVICES;  // we want to be called again...
                }
                else
                    Status = VIDEO_ENUM_INVALID_DEVICE;

                break;

        case 4:

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_xbar",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVXBAR_I2C_DEVICE_ID;
                    *pChildType = Other;
                    Status = VIDEO_ENUM_MORE_DEVICES;  // we want to be called again...
                }
                else
                    Status = VIDEO_ENUM_INVALID_DEVICE;

                break;

        case 5:

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_tuner",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVTUNER_I2C_DEVICE_ID;
                    *pChildType = Other;
                    Status = VIDEO_ENUM_MORE_DEVICES;  // we want to be called again...
                }
                else
                    Status = VIDEO_ENUM_INVALID_DEVICE;

                break;
        case 6:

                // read pnpid of child capture driver from registry...
                Status = VideoPortGetRegistryParameters(
                                HwDeviceExtension,
                                L"pnpid_tvsnd",
                                FALSE,
                                NVRegistryCallbackPnpId,
                                (PVOID)(pvChildDescriptor));
                if (Status == NO_ERROR)
                {
                    // Check to see if I2C hardware is available
                    //if (I2cHardwarePresent())

                    *pHwId = NVTVSND_I2C_DEVICE_ID;
                    *pChildType = Other;
                    Status = VIDEO_ENUM_MORE_DEVICES;  // we want to be called again...
                }
                else
                    Status = VIDEO_ENUM_INVALID_DEVICE;

                break;

#endif  // #ifdef NVPE

    case 7:
        //
        // Miniport will enumerate TV as a child device if the SBIOS has not done so. This is the 
        // case with Dell laptop where the SBIOS does not enumerate TV as an ACPI device 0x200 and hence
        // miniport would never get any power management calls for TV.
        //
        if (hwDeviceExtension->EnumerateTVAsACPIDevice)
        {
            VideoDebugPrint((1, "NvGetChildDescriptor(): case 6: For TV: returning 0x200\n"));
            //
            // 0x200 is the ACPI recommended HwDevID for TV. (QUERY_ACPI_TV_ID)
            //
            *pHwId = QUERY_ACPI_TV_ID;
            *pChildType = Monitor;
            Status = VIDEO_ENUM_MORE_DEVICES;
            break;
        }
        else
        {
            VideoDebugPrint((1, "NvGetChildDescriptor(): case 6: Not enumerating TV\n"));
            //
            // The return status should be VIDEO_ENUM_INVALID_DEVICE so that the OS enumerates further for more
            // devices.
            //
            Status = VIDEO_ENUM_INVALID_DEVICE;
            break;
        }
        break;

    case DISPLAY_ADAPTER_HW_ID:

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        Status = VIDEO_ENUM_MORE_DEVICES;
        break;


    default:

        hwDeviceExtension->bNeedRetrieveEDID = TRUE;
        Status = VIDEO_ENUM_NO_MORE_DEVICES;
        break;
    }


    return Status;
}

VP_STATUS
NVGetChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )
{
    ULONG *pOut;
    ULONG *pIn;
    ULONG ulACPIHwId, ulDeviceMask, ulHead;
    ULONG i;
    ULONG ulFoundActiveMatch;
    NVTWINVIEWDATA sData;
    NVTWINVIEW_DEVICE_TYPE_DATA * pDevData;
    ULONG NVCplInitiated;
    ULONG RegStatus, TwinViewInfoRegStatus;
    ULONG ulCombinedMask;

    RequestPacket->StatusBlock->Information = sizeof(ULONG);

    if (RequestPacket->OutputBufferLength < sizeof(ULONG))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_GET_CHILD_STATE - ERROR_INSUFFICIENT_OUTPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if (RequestPacket->InputBufferLength < sizeof(ULONG))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_GET_CHILD_STATE - ERROR_INSUFFICIENT_INPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    pOut = (ULONG *) RequestPacket->OutputBuffer;
    pIn = (ULONG *) RequestPacket->InputBuffer;
    ulACPIHwId = *pIn;

    VideoDebugPrint((1, "\nW32StartIO - GetChildState: HWId: 0x%x\n",ulACPIHwId));

    if (hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 2)
    {
        if (hwDeviceExtension->pDualViewAssociatedDE)
        {
            if (hwDeviceExtension->ACPISystem == 0)
            {
                if (ulACPIHwId == QUERY_NONDDC_MONITOR_ID ||
                    ulACPIHwId == QUERY_MONITOR_ID)
                {
                    *pOut = 1 | ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) ? VIDEO_CHILD_DETACHED : 0);
                    VideoDebugPrint((1,"FAIL: NONDDC_MONITOR_ID/DDC_MONITOR_ID\n"));
                    return NO_ERROR;
                }
                if (ulACPIHwId == QUERY_NONDDC_MONITOR_ID2 ||
                    ulACPIHwId == QUERY_MONITOR_ID2)
                {
                    *pOut = 1 | ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) ? 0 : VIDEO_CHILD_DETACHED);
                    VideoDebugPrint((1,"FAIL: DDC_MONITOR_ID\n"));
                    return NO_ERROR;
                }
            }
            else
            {
                ASSERT((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE) != 0);
                //
                // Dualview is enabled on an laptop.  All children need to be re-assigned
                //
                if ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON) &&
                    (hwDeviceExtension->pDualViewAssociatedDE->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON))
                {
                    NV_DESKTOP_INFO *pDeskTop = &hwDeviceExtension->DeskTopInfo;
                    ULONG drivingDeviceId = 0;
                    
                    ulDeviceMask = pDeskTop->ulDeviceMask[pDeskTop->ulDeviceDisplay[0]];
                    
                    if (ulDeviceMask & BITMASK_ALL_CRT)
                        drivingDeviceId = QUERY_ACPI_CRT_ID;
                    else if (ulDeviceMask & BITMASK_ALL_DFP)
                        drivingDeviceId = QUERY_ACPI_DFP_ID;
                    else if (ulDeviceMask & BITMASK_ALL_TV)
                        drivingDeviceId = QUERY_ACPI_TV_ID;
                    
                    *pOut = (drivingDeviceId == ulACPIHwId) ? 1 : VIDEO_CHILD_DETACHED;
                    return NO_ERROR;
                }
            }
        }

        else if (hwDeviceExtension->ACPISystem == 0)
        {
            //
            // If the device is the  generic DDC or NON_DDC monitors that we report on desktop systems
            // (i.e. non-ACPI systems), return TRUE.
            //
            if (ulACPIHwId == QUERY_NONDDC_MONITOR_ID ||
                ulACPIHwId == QUERY_MONITOR_ID)
            {
                *pOut = TRUE;
                VideoDebugPrint((1,"SUCCESS: NONDDC_MONITOR_ID/DDC_MONITOR_ID\n"));
                return NO_ERROR;
            }
        }

    }

    //
    // For single headed cards on non-ACPI systems (such as desktops), 
    // we want to enable the "hide modes" checkbox in the NT panel,
    // so return TRUE.
    //
    if ((hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 1) &&
        (hwDeviceExtension->ACPISystem == 0))
    {
        if (ulACPIHwId == QUERY_NONDDC_MONITOR_ID ||
            ulACPIHwId == QUERY_MONITOR_ID)
        {
            *pOut = TRUE;
            VideoDebugPrint((1,"SUCCESS: NONDDC_MONITOR_ID/DDC_MONITOR_ID\n"));
            return NO_ERROR;
        }
    }

    //
    // Read in the twinview info structure
    //
    TwinViewInfoRegStatus = NVGetRegistryTwinviewInfo(hwDeviceExtension, &sData);
    if ((TwinViewInfoRegStatus == NO_ERROR) && (hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 2))
    {
        if (sData.dwState == NVTWINVIEW_STATE_SPAN)
        {
            VideoDebugPrint((1,"FAIL: Spanning mode: Don't remember this resolution\n"));
            *pOut = FALSE;
            return NO_ERROR;
        }
    }


    //
    // Special cases. If we a modeswitch via nVidia panel is initiated or a modeswitch via hotkey is
    // pending, use the desired devices from the twinViewInfo structure from the registry.
    // Otherwise, sometimes the taskbar gets confused and does not resize correctly.
    // We need to do this only for the laptops since desktops does not have this "confused taskbar" problem
    // as we enumerate only one child device for the desktops.
    //
    NVCplInitiated = 0;
    RegStatus = VideoPortGetRegistryParameters(hwDeviceExtension,
                               L"NVCplInduceModeSetInitiated",
                               FALSE,
                               NVRegistryCallback,
                               &(NVCplInitiated));
    if ((RegStatus == NO_ERROR && NVCplInitiated == 1 && hwDeviceExtension->ACPISystem == 1) ||
        (hwDeviceExtension->ulHotKeyPending == 1 && hwDeviceExtension->ACPISystem == 1))
    {
        //
        // Build up the device masks from the TwinViewInfo structure if present.
        //
        RegStatus = NVGetRegistryTwinviewInfo(hwDeviceExtension, &sData);
        if (TwinViewInfoRegStatus == NO_ERROR)
        {
            ASSERT(sData.dwState == NVTWINVIEW_STATE_CLONE || sData.dwState == NVTWINVIEW_STATE_NORMAL);

            if (sData.dwState == NVTWINVIEW_STATE_CLONE)
            {
                ulCombinedMask = 0;
                pDevData = &sData.NVTWINVIEWUNION.nvtwdevdata[0];
                ulCombinedMask |= pDevData->dwDeviceMask;
                pDevData = &sData.NVTWINVIEWUNION.nvtwdevdata[1];
                ulCombinedMask |= pDevData->dwDeviceMask;
            }
            if (sData.dwState == NVTWINVIEW_STATE_NORMAL)
            {
                ulCombinedMask = 0;
                ulHead = sData.dwDeviceDisplay[0];
                pDevData = &sData.NVTWINVIEWUNION.nvtwdevdata[ulHead];
                ulCombinedMask |= pDevData->dwDeviceMask;
            }

            //
            // Now compare the device mask
            //
            ulDeviceMask = ACPIHwIdToMask(ulACPIHwId);
            if (ulCombinedMask & ulDeviceMask)
            {
                // The requested device is one of nvPanel specified devices. So return success.
                *pOut = TRUE;
                VideoDebugPrint((1,"SUCCESS: nvPanel/HK Initiated Spanning mode: Active\n"));
                return NO_ERROR;
            }
            else
            {
                // This device is not one of the nvPanel specified devices. So return failure by returning FALSE.
                VideoDebugPrint((1,"FAIL: nvPanel/HK Initiated Spanning mode: not present\n"));
                *pOut = FALSE;
                return NO_ERROR;
            }
        } // if TwinViewInfo registry structure
    } //if nvCpl initiated or HK pending


    //
    // Check if we are in spanning mode.  Don't want to do mode prunning here
    //
    if (bQueryInSpanningMode(hwDeviceExtension))
    {
        *pOut = FALSE;
        VideoDebugPrint((1,"GetChildState: Inactive for Spanning\n"));
        return NO_ERROR;
    }

    // See if the device actually exists.
    if (ulACPIHwId == 0)
    {
        // Ignore devId 0 for now. Return success.
        *pOut = TRUE;
    
    }
    ulDeviceMask = ACPIHwIdToMask(ulACPIHwId);

    if (!(hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask & ulDeviceMask))
    {
        // This device is not currently present. So return failure by returning FALSE.
        VideoDebugPrint((1,"FAIL: not present\n"));
        *pOut = FALSE;
        return NO_ERROR;
    }

    // The device is present. Now see if the device is one of the active devices.
    ulFoundActiveMatch = 0;
    for (i = 0; i < hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
    {
        ulHead = hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
        if (hwDeviceExtension->DeskTopInfo.ulDeviceMask[ulHead] == ulDeviceMask)
        {
            // We found the head for which this requested device is attached.
            ulFoundActiveMatch = 1;
        }
    }

    if (ulFoundActiveMatch)
    {
        // The requested device is one of currently active device. So return success.
        *pOut = TRUE;
        VideoDebugPrint((1,"SUCCESS: Active\n"));
    }
    else
    {
        // The requested device is not one of currently active device. So return failure.
        *pOut = FALSE;
        VideoDebugPrint((1,"FAIL: not Active\n"));
    }
    return NO_ERROR;
}

VP_STATUS
NVValidateChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )
{
    ULONG *pOut;
    VIDEO_CHILD_STATE_CONFIGURATION *pIn;
    VIDEO_CHILD_STATE * pChildState;
    ULONG ulACPIHwId, ulDeviceMask, ulHead;
    ULONG i, j;
    ULONG ulFoundActiveMatch;

    RequestPacket->StatusBlock->Information = sizeof(ULONG);

    if (RequestPacket->OutputBufferLength < sizeof(ULONG))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION - ERROR_INSUFFICIENT_OUTPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if (RequestPacket->InputBufferLength < sizeof(VIDEO_CHILD_STATE_CONFIGURATION))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION - ERROR_INSUFFICIENT_INPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    pOut = (ULONG *) RequestPacket->OutputBuffer;
    pIn = (VIDEO_CHILD_STATE_CONFIGURATION *) RequestPacket->InputBuffer;

    if (ACPIValidateChildStateShouldFail(hwDeviceExtension))
    {
        // We are in full screen DOS mode or spanning mode. So let the BIOS handle the hot keys.
        // This device is not currently present. So return failure by returning 0.
        *pOut = 0;
        VideoDebugPrint((1,"FAIL: curently in FSDOS or Spanning\n"));
        return NO_ERROR;
    }

    if (hwDeviceExtension->pDualViewAssociatedDE)
    {
        if ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON) &&
            (hwDeviceExtension->pDualViewAssociatedDE->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON))
        {
            // Disable Hotkey Switch if under Dualview
            *pOut = 0;
            VideoDebugPrint((1,"FAIL: curently in FSDOS or Spanning\n"));
            return NO_ERROR;
        }
    }

    //
    // Refresh the connected device mask. 
    //
    GetConnectedDevicesMask(hwDeviceExtension);

    // Enumerate the devices. See if the device actually exists.
    // Even if one of the devices is invalid, we return failure.
    VideoDebugPrint((1, "pIN->Count: %d\n", pIn->Count));
    for (i=0; i < pIn->Count; i++)
    {
        pChildState =  &(pIn->ChildStateArray[i]);
        ulACPIHwId = pChildState->Id;
        VideoDebugPrint((1, "    HwID: 0x%x, State: 0x%x\n", pChildState->Id, pChildState->State));
        if (ulACPIHwId == 0)
        {
            // continue on to processing the next device. Ignore devId 0 for now. 
            continue;
        }
        ulDeviceMask = ACPIHwIdToMask(ulACPIHwId);
        //
        // Check against the connected devices only if this device state is to be turned on.
        // The DDK specs does not say what the behavior should be based on the device state.
        // If the state is to be turned off, then it does not matter if the device is present
        // or not, so I don't return any failure in this case. Again, note that this is a subjective
        // call on my part.
        //
        if (pChildState->State == 1)
        {
            if (!(hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask & ulDeviceMask))
            {
                // This device is not currently present. So return failure by returning 1.
                *pOut = 0;
                VideoDebugPrint((1, "FAIL: Not present\n"));
                return NO_ERROR;
            }
        }
    }
    VideoDebugPrint((1, "Return *pOut: 0x%x\n", *pOut));
    return NO_ERROR;
}

VP_STATUS
NVSetChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )
{
    VIDEO_CHILD_STATE_CONFIGURATION *pIn;
    VIDEO_CHILD_STATE * pChildState;
    ULONG ulACPIHwId, ulDeviceMask, ulHead;
    ULONG i, j;
    ULONG ulFoundActiveMatch;
    ULONG GDIWidth, GDIHeight;
    ULONG ulDeviceMask0 = 0, ulDeviceMask1 = 0;
    ULONG ulNumTurnOn = 0;
    NV_DESKTOP_INFO * pInfo;

    pInfo = &hwDeviceExtension->DeskTopInfo;
    
    if (RequestPacket->InputBufferLength < sizeof(VIDEO_CHILD_STATE_CONFIGURATION))
    {
        VideoDebugPrint((0, "IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION - ERROR_INSUFFICIENT_INPUT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // Detect if we are in spanning mode.
    if (bQueryInSpanningMode(hwDeviceExtension))
    {
        if (!bAllowHotKeyInSpanningMode(hwDeviceExtension))
        {
            // we can not return failure here since the OS will then try to use the 
            // system BIOS. So we do a fake success return here.
            VideoDebugPrint((1,"FAIL: currently in Span mode\n"));
            return NO_ERROR;
        }
    }


    pIn = (VIDEO_CHILD_STATE_CONFIGURATION *) RequestPacket->InputBuffer;

    // Count the number of devices that need to be turned on.
    // We can handle turning only 1 or 2 devices.
    VideoDebugPrint((1,"pIN->Count: %d\n",pIn->Count));
    for (i = 0; i < pIn->Count; i++)
    {
        pChildState =  &(pIn->ChildStateArray[i]);
        if (pChildState->State == 1)
        {
            ulNumTurnOn++;
        }
        VideoDebugPrint((1,"    HwID: 0x%x, State: 0x%x\n",pChildState->Id, pChildState->State));
    }

    // sanity check
    if (ulNumTurnOn <= 0 || ulNumTurnOn > 2)
    {
        // return success anyway.
        VideoDebugPrint((0,"Oops! ACPI SetDevice count is invalid: 0x%x\n",ulNumTurnOn));
        return NO_ERROR;
    }

    // Enumerate the devices. See if the device actually exists.
    // Even if one of the devices is invalid, we return failure.
    for (i = 0; i < pIn->Count; i++)
    {
        pChildState =  &(pIn->ChildStateArray[i]);
        ulACPIHwId = pChildState->Id;
        if (ulACPIHwId == 0)
        {
            VideoDebugPrint((0,"Oops! Don't know how to handle Device of zero in SetDevice\n"));
            return ERROR_INVALID_PARAMETER;
        }
        ulDeviceMask = ACPIHwIdToMask(ulACPIHwId);
        //
        // Check against the connected devices only if this device state is to be turned on.
        // The DDK specs does not say what the behavior should be based on the device state.
        // If the state is to be turned off, then it does not matter if the device is present
        // or not, so I don't return any failure in this case. Again, note that this is a subjective
        // call on my part.
        //
        if (pChildState->State == 1)
        {
            if (!(hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask & ulDeviceMask))
            {
                // This device is not currently present. So return failure by returning 1.
                VideoDebugPrint((0,"Oops! DeviceMask: 0x%x is not in the ConnectedDeviceMask: 0x%x\n",
                                 ulDeviceMask,hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask)); 
                return ERROR_INVALID_PARAMETER;
            }
        }

        // If the state of the device is set to 0, I don't know how to handle it.
        if (pChildState->State == 1)
        {
            // Initialize the first and second head's device masks.
            if (ulDeviceMask0 == 0)
            {
                ulDeviceMask0 = ulDeviceMask;
            }
            if (ulDeviceMask0 != 0)
            {
                // We have already set the DeviceMask0. So now set DeviceMask1
                ulDeviceMask1 = ulDeviceMask;
            }
        }

    }

    // Handle the case when we were called to turn off one device and turn on another
    if (pIn->Count == 2 && ulNumTurnOn == 1)
    {
        // see which of the two devices were asked to be turned on.
        if (ulDeviceMask1)
        {
            ulDeviceMask0 = ulDeviceMask1;
        }

    }
    // We were called with valid devices. Handle the single device and dual device cases separately.
    if (ulNumTurnOn == 1)
    {
        ACPISingleDeviceSwitch(hwDeviceExtension, ulDeviceMask0);
    }
    if (ulNumTurnOn == 2)
    {
        //
        // Special case. if we are in spanning mode and the two requested devices are the same, we do 
        // nothing and return success.
        //
        if (bQuerySpanDualDevicesSame(hwDeviceExtension, ulDeviceMask0, ulDeviceMask1))
        {
            VideoDebugPrint((1,"In spanning mode and same devices. So doing dummy return in nvSetChildState()\n")); 
            //
            // Now set the hotkeyPending flag so that the display driver does not obey BOOT_DEVICES.
            //
            hwDeviceExtension->ulHotKeyPending = 1;
            return NO_ERROR;
        }
        ACPIDualDeviceSwitch(hwDeviceExtension, ulDeviceMask0, ulDeviceMask1);
        //
        // Irrespective of dell or toshiba, if we get here, we know both dacs are connected.
        // So set NumDacConnected to 2. This handles the special case of hot plugging CRT on
        // Dell and getAvailableModes() in the display driver will still be thinking there is only
        // one dac connected as no device scan would have been done.
        //
        hwDeviceExtension->DeskTopInfo.ulNumberDacsConnected = 2;
    }

    // Now set the hotkeyPending flag.
    hwDeviceExtension->ulHotKeyPending = 1;

    //
    // Detect if we are in full screen DOS mode.
    // Or if we are in VGA mode (such as via the F8 option of "VGA mode" at bootup time.
    // Here we want to pass VALIDATE_CHILD_DEVICE but fail SET_CHILD_DEVICE so that the OS will
    // call the VBIOS to do the switching. Note that the GET_CHILD_STATE has to be consistent with the
    // devices specified in VALIDATE_CGILD_DEVICE and SET_CHILD_DEVICE.
    //
    if (bQueryInFSDOSorVGAMode(hwDeviceExtension))
    {
        VideoDebugPrint((1,"FAIL: currently in FSDOS or VGA mode\n"));
        //
        // Unset the hotkeyPending flag since we are not really doing the device switching but the VBIOS is.
        //
        hwDeviceExtension->ulHotKeyPending = 0;
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}


//**************************************************************************************
//
// Function: NVSwitchDualView
//
// DESCRIPTION:
//  Anotify from GDI about switching to Dual View(MHS) or Single View mode.
//
// PARAMETERS:
//  pHwDeviceExtension  Points to per-display(view) device extension.
//  dwDualViewEnable    1 : View will be enabled
//                      0 : View will be disabled
//
// RETURN VALUE:
//  Status code.
//
//**************************************************************************************

VP_STATUS
NVSwitchDualView(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG                dwViewEnable
    )
{
    PHW_DEVICE_EXTENSION pHwDE1;

    VideoDebugPrint ((0, "****SwitchDualView: %s : %s\n", 
                      ((hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) ? "Secondary" : "Primary"),
                      (dwViewEnable? "On" : "Off")));

    //
    // Assume GDI always call in order of Primary, Secondary. Only after all view be called, 
    // we can decide it will be in SingleView or DualView and then take actions 
    //

    if (dwViewEnable)
        hwDeviceExtension->ulDualViewStatus |= DUALVIEW_STATUS_VIEW_ON;
    else
        hwDeviceExtension->ulDualViewStatus &= ~DUALVIEW_STATUS_VIEW_ON;

    //
    // In the primary view call, we just set/clear ViewOn flags. 
    //        
    if (!(hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY))
    {
        return NO_ERROR;
    }

    pHwDE1 = hwDeviceExtension->pDualViewAssociatedDE;
    if ((pHwDE1->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON) && 
        (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_VIEW_ON))
    {
        HandleDualviewHeads(pHwDE1, TRUE);
    }
    else
    {
        HandleDualviewHeads(pHwDE1, FALSE);
    }
    return NO_ERROR;
}

#endif // #if (_WIN32_WINNT >= 0x0500)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv4\nv4.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV4.C
//
// Abstract:
//
//     This is code specific to NV4
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

//
// Used to turn on MultiDevice support for NT 4 (smae is used for the display driver)
//
//#define NT4_MULTI_DEV


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvMultiMon.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"
#include "vesadata.h"

#include "nvos.h"
#include "rm.h"

#include "nvreg.h"
#include "nvcm.h"
#include "nv_name.h"

#include "cr11_ref.h"

VOID FlatPanelCrtc(U016);
VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID NV_ReadAndCopyRegistryData(PHW_DEVICE_EXTENSION,WCHAR *,U016 *);
VOID LoadDefaultRegistrySwitchValues(PHW_DEVICE_EXTENSION);
VOID BubbleSort(PHW_DEVICE_EXTENSION,PMODE_ENTRY,ULONG);
VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
VOID NV4ChipFBPowerSave(PHW_DEVICE_EXTENSION);
VOID NV4ChipFBPowerRestore(PHW_DEVICE_EXTENSION);
VOID NV4SaveInstanceMemory(PHW_DEVICE_EXTENSION);
VOID NV4RestoreInstanceMemory(PHW_DEVICE_EXTENSION);
VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension);

//
// To fix a soft reboot hang on the laptops.
//
#if (_WIN32_WINNT >= 0x0500)
extern BOOLEAN
NVResetHW(
    PVOID hwDeviceExtension,
    ULONG Column,
    ULONG Rows
    );
#endif

//******************************************************************************
// External Declarations
//******************************************************************************

extern U016 ModeSetTable[];
extern U016 DMTOverrideTable[][13];
extern CRTC_OVERRIDE crt_override[];
extern EXTREGS eregs[];
extern U016 tblClockFreq[];
extern U016 VBESetModeEx(PHW_DEVICE_EXTENSION, U016, PGTF_TIMINGS, PDMT_OVERRIDES, U016);
extern VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION pHwDevExt);
extern MODESET_FIFO DACFifoTable[];
extern unsigned int GTFTimingTable[][12];
extern U016 ValidModeTable[];
extern U016 registry_data[];

extern ULONG my_strcmp(PUCHAR ,PUCHAR);
extern VOID my_strupr(PUCHAR);
extern VOID my_strcpy(PUCHAR , PUCHAR);

extern VOID NV10ChipFBPowerSave(PHW_DEVICE_EXTENSION);
extern VOID NV10ChipFBPowerRestore(PHW_DEVICE_EXTENSION);
extern VOID NV10SaveInstanceMemory(PHW_DEVICE_EXTENSION);
extern VOID NV10RestoreInstanceMemory(PHW_DEVICE_EXTENSION);

extern ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);


//******************************************************************************
// Global tables default registry settings
// (Type, ValueName, SwitchIsPresent, Offset of structure member)
//******************************************************************************

NT_NV_REGISTRY_SWITCH_OFFSET Nv_Registry_Switch_Offset_Table[] =
    {


// STUB OUT FOR NOW SINCE \common\NVREG.H is constantly changing 
// and breaking the NT build.  When NVREG.H settles down, then
// we can put this function back in

    { IS_DWORD , "PLACEHOLDER" ,                                offsetof(NT_NV_REGISTRY, Display.DisplayType)                   }

//    //**************************************************************************
//    // Display Registry Switch Names
//    //**************************************************************************
//
//    { IS_STRING , NV4_REG_DRV_LAST_DEVICE ,                   offsetof(NT_NV_REGISTRY, Display.LastDisplayDevice[0])          },
//    { IS_STRING , NV4_REG_DRV_LAST_CRT_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastCRTMode[0])                },
//    { IS_STRING , NV4_REG_DRV_LAST_DFP_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastDFPMode[0])                },
//    { IS_STRING , NV4_REG_DRV_LAST_NTSC_MODE ,                offsetof(NT_NV_REGISTRY, Display.LastNTSCMode[0])               },
//    { IS_STRING , NV4_REG_DRV_LAST_PAL_MODE ,                 offsetof(NT_NV_REGISTRY, Display.LastPALMode[0])                },
//    { IS_STRING , NV4_REG_DRV_CRT_MODE ,                      offsetof(NT_NV_REGISTRY, Display.CRTMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_DFP_MODE ,                      offsetof(NT_NV_REGISTRY, Display.DFPMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_NTSC_MODE ,                     offsetof(NT_NV_REGISTRY, Display.NTSCMode[0])                   },
//    { IS_STRING , NV4_REG_DRV_PAL_MODE ,                      offsetof(NT_NV_REGISTRY, Display.PALMode[0])                    },
//    { IS_STRING , NV4_REG_DRV_DEFAULT_CRT_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.DefaultCRTRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_DEFAULT_DFP_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.DefaultDFPRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_OPTIMAL_CRT_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.OptimalCRTRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_OPTIMAL_DFP_VERT_REFRESH_RATE , offsetof(NT_NV_REGISTRY, Display.OptimalDFPRefreshRate[0])      },
//    { IS_STRING , NV4_REG_DRV_DISPLAY_DEVICE_TYPE ,           offsetof(NT_NV_REGISTRY, Display.DisplayDeviceType[0])          },
//    { IS_DWORD , "Display Type" ,                             offsetof(NT_NV_REGISTRY, Display.DisplayType)                   },
//    { IS_DWORD , "TV Type" ,                                  offsetof(NT_NV_REGISTRY, Display.TVType)                        },
//    { IS_DWORD  , NV4_REG_DRV_MONITOR_TIMING ,                offsetof(NT_NV_REGISTRY, Display.MonitorTiming)                 },
//    { IS_DWORD  , NV4_REG_DRV_CURSOR_ALPHA ,                  offsetof(NT_NV_REGISTRY, Display.CursorAlpha)                   },
//
//
//    //**************************************************************************
//    // DirectDraw Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , NV4_REG_VPE_ENABLE ,                         offsetof(NT_NV_REGISTRY, DirectDraw.VPENABLE)                   },
//    { IS_DWORD , NV4_REG_OVL_MODE ,                           offsetof(NT_NV_REGISTRY, DirectDraw.OverlayMode)                },
//    { IS_DWORD , NV4_REG_OVLCC_ENABLE ,                       offsetof(NT_NV_REGISTRY, DirectDraw.OverlayColorControlEnable)  },
//    { IS_DWORD , NV4_REG_OVLCC_BRIGHTNESS ,                   offsetof(NT_NV_REGISTRY, DirectDraw.OverlayBrightness)          },
//    { IS_DWORD , NV4_REG_OVLCC_CONTRAST ,                     offsetof(NT_NV_REGISTRY, DirectDraw.OverlayContrast)            },
//    { IS_DWORD , NV4_REG_OVLCC_HUE ,                          offsetof(NT_NV_REGISTRY, DirectDraw.OverlayHue)                 },
//    { IS_DWORD , NV4_REG_OVLCC_SATURATION ,                   offsetof(NT_NV_REGISTRY, DirectDraw.OverlaySaturation)          },
//    { IS_DWORD , NV4_REG_OVLCC_GAMMA ,                        offsetof(NT_NV_REGISTRY, DirectDraw.OverlayGamma)               },
//    { IS_DWORD , NV4_REG_OVLCC_SHARPNESS ,                    offsetof(NT_NV_REGISTRY, DirectDraw.OverlaySharpness)           },
//
//    //**************************************************************************
//    // Direct3d Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , D3D_REG_ANTIALIASENABLE_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.ANTIALIASENABLE)              },
//    { IS_DWORD , D3D_REG_CKCOMPATABILITYENABLE_STRING ,       offsetof(NT_NV_REGISTRY, Direct3D.COLORKEYCOMPATABILITYENABLE)  },
//    { IS_DWORD , "CONTROLTRAFFIC"                    ,        offsetof(NT_NV_REGISTRY, Direct3D.CONTROLTRAFFIC)               },
//    { IS_DWORD , D3D_REG_DIRECTMAPENABLE_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.DIRECTMAPENABLE)              },
//    { IS_DWORD , D3D_REG_FOGTABLEENABLE_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.FOGTABLENABLE)                },
//    { IS_DWORD , D3D_REG_LOGOENABLE_STRING ,                  offsetof(NT_NV_REGISTRY, Direct3D.LOGOENABLE)                   },
//    { IS_DWORD , D3D_REG_SSYNCENABLE_STRING ,                 offsetof(NT_NV_REGISTRY, Direct3D.SCENESYNCENABLE)              },
//    { IS_DWORD , D3D_REG_TILINGENABLE_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.TILINGENABLE)                 },
//    { IS_DWORD , D3D_REG_USERMIPMAPENABLE_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.USERMIPMAPENABLE)             },
//    { IS_DWORD , D3D_REG_VIDEOTEXTUREENABLE_STRING ,          offsetof(NT_NV_REGISTRY, Direct3D.VIDEOTEXTUREENABLEENABLE)     },
//    { IS_DWORD , D3D_REG_VSYNCENABLE_STRING ,                 offsetof(NT_NV_REGISTRY, Direct3D.VSYNCENABLE)                  },
//    { IS_DWORD , D3D_REG_WBUFFERENABLE_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.WENABLE)                      },
//    { IS_DWORD , D3D_REG_Z24ENABLE_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.Z24ENABLE)                    },
//    { IS_DWORD , D3D_REG_AAMETHOD_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.AAMETHOD)                     },
//    { IS_DWORD , D3D_REG_AUTOMIPMAPMETHOD_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.AUTOMIPMAPMETHOD)             },
//    { IS_DWORD , D3D_REG_CKREF_STRING ,                       offsetof(NT_NV_REGISTRY, Direct3D.CKREF)                        },
//    { IS_DWORD , "DX6ENABLE" ,                                offsetof(NT_NV_REGISTRY, Direct3D.DX6ENABLE)                    },
//    { IS_DWORD , D3D_REG_MIPMAPDITHERMODE_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.ANISOTOPIC4TAP)               },
//    { IS_DWORD , D3D_REG_PAL8TEXCONVERT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.PAL8TEXTURECONVERT)           },
//    { IS_DWORD , "PMTRIGGER" ,                                offsetof(NT_NV_REGISTRY, Direct3D.PMTRIGGER)                    },
//    { IS_DWORD , D3D_REG_TEXELALIGNMENT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.TEXELALIGNMENT)               },
//    { IS_DWORD , D3D_REG_VALIDATEZMETHOD_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.VALIDATEZMETHOD)              },
//    { IS_DWORD , D3D_REG_WFORMAT16_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.W16FORMAT)                    },
//    { IS_DWORD , D3D_REG_WFORMAT32_STRING ,                   offsetof(NT_NV_REGISTRY, Direct3D.W32FORMAT)                    },
//    { IS_DWORD , D3D_REG_AGPTEXCUTOFF_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.AGPTEXCUTOFF)                 },
//    { IS_DWORD , D3D_REG_D3DCONTEXTMAX_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.D3DCONTEXTMAX)                },
//    { IS_DWORD , D3D_REG_D3DTEXTUREMAX_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.D3DTEXTUREMAX)                },
//    { IS_DWORD , D3D_REG_DMAMINPUSHCOUNT_STRING ,             offsetof(NT_NV_REGISTRY, Direct3D.DMAMINPUSHCOUNT)              },
//    { IS_DWORD , D3D_REG_LODBIAS_STRING ,                     offsetof(NT_NV_REGISTRY, Direct3D.LODBIASADJUST)                },
//    { IS_DWORD , D3D_REG_MINVIDTEXSIZE_STRING ,               offsetof(NT_NV_REGISTRY, Direct3D.MINVIDEOTEXSIZE)              },
//    { IS_DWORD , D3D_REG_AUTOMIPMAPLEVELS_STRING ,            offsetof(NT_NV_REGISTRY, Direct3D.MIPMAPLEVELS)                 },
//    { IS_DWORD , D3D_REG_PERFSTRATEGY_STRING ,                offsetof(NT_NV_REGISTRY, Direct3D.PERFSTRATEGY)                 },
//    { IS_DWORD , D3D_REG_PRERENDERLIMIT_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.NOVSYNCPREREDNERLIMIT)        },
//    { IS_DWORD , D3D_REG_PUSHBUFFERSIZEMAX_STRING ,           offsetof(NT_NV_REGISTRY, Direct3D.DMAPUSHBUFFERSIZEMAX)         },
//    { IS_DWORD , D3D_REG_TEXHEAPSIZEMAX_STRING ,              offsetof(NT_NV_REGISTRY, Direct3D.TEXHEAP)                      },
//    { IS_DWORD , D3D_REG_WSCALE16_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.WSCALE16)                     },
//    { IS_DWORD , D3D_REG_WSCALE24_STRING ,                    offsetof(NT_NV_REGISTRY, Direct3D.WSCALE24)                     },
//
//    //**************************************************************************
//    // System Registry Switch Names
//    //**************************************************************************
//
//    { IS_DWORD , "Reserved1" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved2" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved3" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved4" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved5" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved6" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved7" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved8" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved9" ,                                offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved10" ,                               offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },
//    { IS_DWORD , "Reserved11" ,                               offsetof(NT_NV_REGISTRY, System.Super7Compat)                  },

    };
    

//******************************************************************************
// Global tables for registry mode table data
//******************************************************************************

U016 NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5M64_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV5ULTRA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV10GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11M_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV11GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 CRUSH11_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15DDR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15BR_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV15GL_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_1_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_2_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
U016 NV20_3_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];


//******************************************************************************
// Global tables for Monitor restriction mode list data
//******************************************************************************
U016 MonitorRestrictionModeList0_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];  // For head0
U016 MonitorRestrictionModeList1_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];  // For head1

// global device extension pointer - We need it to distinguish between NV3/NV4..
extern PHW_DEVICE_EXTENSION HwDeviceExtension;

extern VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );


extern VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

__inline static size_t cbStrLenW(
    IN UNALIGNED const WCHAR *wsz)
{
    size_t cbWsz = 0;

    for(; *wsz; wsz++)
        cbWsz += sizeof( WCHAR);

    return( cbWsz + sizeof( WCHAR));
}

#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
// Tables used by DPMS_SetPowerState (NT5 only)
//******************************************************************************

UCHAR tblDPMSStates[4]      = { 0, 2, 1, 4 }                    ;   //on, stdby, suspend, off
UCHAR tblDPMSSettings[4]    = { 0x000, 0x080, 0x040, 0x0C0 }    ;

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV_ATCOff(PHW_DEVICE_EXTENSION);
VOID NV_ATCOn(PHW_DEVICE_EXTENSION);
VOID NV_ResetATCFlipFlop(PHW_DEVICE_EXTENSION);

#endif


//******************************************************************************
// Use a slightly different mode timing table for NV4
//******************************************************************************


//
// CRTC Timings modes for 60Hz, 70Hz, 72Hz, 75Hz, 85Hz, 100Hz, 120Hz
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use floating point).
//
// Horizontal Total, Start, End
// Vertical Total, Start, End
// DotClock, Refresh
// HSync polarity
// VSync polarity
//
// Max out all the modes above our pixclk (~250).
//
U016 ModeTimingTable[NUMBER_OF_MODES*NUMBER_OF_RATES][10] =
{
    //0:
    // Settings for 1600x1200:
    2160,1704,1880,1242,1201,1204,16096,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1249,1201,1204,19025,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1251,1201,1204,19600,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1253,1201,1204,20599,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //1:
    // Settings for 1280x1024:
    1712,1360,1496,1060,1025,1028,10888,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1066,1025,1028,12894,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1067,1025,1028,13275,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1069,1025,1028,13854,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1744,1376,1512,1075,1025,1028,15936,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1760,1376,1520,1085,1025,1028,19096,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //2:
    // Settings for 1152x864:
    1520,1216,1336,895,865,868,8162 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,900,865,868,9677 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,901,865,868,9964 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,902,865,868,10499,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,907,865,868,11965,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1568,1232,1360,915,865,868,14347,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1584,1240,1368,926,865,868,17601,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //3:
    // Settings for 1024x768:
    1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,800,769,772,7616 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,801,769,772,7843 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,802,769,772,8180 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1376,1088,1200,807,769,772,9439 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //1392,1096,1208,814,769,772,11331,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1392,1096,1208,814,769,772,11370,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,823,769,772,13905,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //4:
    // Settings for 960x720:
    1248,1008,1104,746,721,724,5586 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,750,721,724,6636 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,751,721,724,6835 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,752,721,724,7219 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,756,721,724,8225 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1296,1024,1128,763,721,724,9888 ,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1312,1032,1136,772,721,724,12154,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //5:
    // Settings for 800x600:
    1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,625,601,604,4550,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,626,601,604,4687,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,627,601,604,4891,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1056,840,928,630,601,604,5655,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1072,848,936,636,601,604,6818,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,643,601,604,8395,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //6:
    // Settings for 640x480:
    800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,500,481,484,2856,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,501,481,484,2943,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,502,481,484,3072,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,505,481,484,3571,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,509,481,484,4316,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,515,481,484,5241,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //7:
    // Settings for 640x400:
    //There is no 60Hz timings for 640x400 as defined by IBM VGA
    //784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2508,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,421,401,404,2920,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,424,401,404,3528,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //8:
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    672,536,592,795,769,772,3205,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    672,536,592,800,769,772,3763,7000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,801,769,772,3968,7200,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,802,769,772,4138,7500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,807,769,772,4719,8500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,814,769,772,5600,10000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,

    //9:
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    624,504,552,746,721,724,2793,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,750,721,724,3360,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,751,721,724,3461,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,752,721,724,3610,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,756,721,724,4113,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,763,721,724,5005,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //10:
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    512,416,456,622,601,604,1911,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,625,601,604,2310,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,626,601,604,2380,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,627,601,604,2483,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,630,601,604,2827,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,636,601,604,3358,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //11:
    // Settings for 320x400:
    //
    // !!! This mode should never be set !!! since DDraw doesn't support it yet
    //
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //12:
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    400,328,360,497,481,484,1193,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,500,481,484,1400,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,501,481,484,1501,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,502,481,484,1566,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,505,481,484,1786,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,509,481,484,2117,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //13:
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //14:
    // Settings for 1920x1200:
    2592,2048,2256,1242,1201,1204,19316,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1249,1201,1204,22802,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1251,1201,1204,23635,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1253,1201,1204,24659,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //15:
    // Settings for 1920x1080:
    2576,2040,2248,1118,1081,1084,17280,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1124,1081,1084,20520,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1126,1081,1084,21144,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1128,1081,1084,22064,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //16:
    // Settings for 1800x1440:
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

//17:
    // Settings for 1600x1024:
    2144,1704,1872,1060,1025,1028,13636,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2160,1704,1880,1066,1025,1028,16118,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2160,1704,1880,1067,1025,1028,16594,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

// An OEM Customer wants a SPECIFIC timing...which is NOT GTF or DMT compliant ...so we'll accomodate them...
// (They're using a widescreen Sony monitor)

// Standard GTF
//    2176,1712,1888,1070,1025,1028,17695,7600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

// OEM requested
    2096,1632,1792,1070,1027,1030,17045,7600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,


    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1075,1025,1028,19883,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,


};

//******************************************************************************
// Forward Function Declarations
//******************************************************************************
VP_STATUS
NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

BOOLEAN
NVGetNVInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );


VOID NV4_UpdateArbitrationSettings(PHW_DEVICE_EXTENSION);

BOOL NV4SetMode(PHW_DEVICE_EXTENSION,PMODE_ENTRY);
VOID NV_SetColorLookup(PHW_DEVICE_EXTENSION,PVIDEO_CLUT,ULONG);
VOID NV4_InitPalette(PHW_DEVICE_EXTENSION);
ULONG NVMapMemoryRanges(PVOID HwDeviceExtension);
ULONG NVMapFrameBuffer(PVOID HwDeviceExtension);
//BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PVIDEO_ACCESS_RANGE,PULONG);
BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PULONG);
VOID NV4EnableCursor(PHW_DEVICE_EXTENSION);
ULONG NVMapVgaPaletteRegisters(PHW_DEVICE_EXTENSION);
VOID NV4_ProgramTV( U008 );

//******************************************************************************
//
//  Function: NVSetMode()
//
//  Routine Description:
//
//      This routine sets the adapter into the requested mode.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      Mode - Pointer to the structure containing the information about the
//          font to be set.
//
//      ModeSize - Length of the input buffer supplied by the user.
//
//  Return Value:
//
//      ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
//          for the input data.
//
//      ERROR_INVALID_PARAMETER if the mode number is invalid.
//
//      NO_ERROR if the operation completed successfully.
//
//******************************************************************************

VP_STATUS NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    )


    {

    PMODE_ENTRY pRequestedMode;             // NV specific
    VP_STATUS status;
    USHORT usDataSet, usTemp, usDataClr;
    PUSHORT  pBios = NULL;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    ULONG OutData;
    LONG x_inc,y_inc;
    ULONG x,y;
    ULONG i;
    ULONG Data;
    PMODE_ENTRY ModeEntry;

    PHWINFO NVInfo;

    VideoDebugPrint((1, "NVSetMode - entry\n"));

    //**************************************************************************
    // Check if the size of the data in the input buffer is large enough.
    //**************************************************************************

    if (ModeSize < sizeof(VIDEO_MODE))
    {

        VideoDebugPrint((1, "SetMode - ERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //**************************************************************************
    // Init pointer to Mode data (NV3 or NV4)
    //**************************************************************************

    ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);


    //**************************************************************************
    // Check to see if we are requesting a valid mode
    //**************************************************************************

    if ( (Mode->RequestedMode >= HwDeviceExtension->NumRegistryModes)   ||
         (!ModeEntry[Mode->RequestedMode].ValidMode)  )
        {

        VideoDebugPrint((1, "SetMode - ERROR_INVALID_PARAMETER\n"));
        return ERROR_INVALID_PARAMETER;

        }


    //**************************************************************************
    // Our driver maps video memory first, and then sets the mode.
    // However, the Dumb Frame Buffer drivers sets the mode FIRST, and
    // then maps the video memory.  So first check to see if we've
    // got a valid frame buffer ptr, before we clear memory.
    //**************************************************************************

    if (HwDeviceExtension->FrameBufferPtr !=NULL)
        {
        //**********************************************************************
        // Clear the framebuffer prior to setting the video mode.
        // This is for aesthetics only.
        // Back up 1Mb to make absolutely sure we don't walk over any instance memory
        //**********************************************************************
        for (i = 0; i < ( (HwDeviceExtension->AdapterMemorySize-0x100000) >> 2); i++)
            {
            ((PULONG) HwDeviceExtension->FrameBufferPtr)[i] = 0;
            }
        }

    //**************************************************************************
    // Get pointer to the requested mode
    //**************************************************************************
    if(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_VIRTUAL_DESKTOP)
    {
        PMODE_ENTRY pDesktopMode; 
        ULONG ulDac;
        ULONG ulWidth;
        ULONG ulHeight;
        ULONG ulRefresh;
        ULONG ulPixelDepth;

        pDesktopMode = &(ModeEntry[Mode->RequestedMode]);

        // Display driver is setting mode through class for both DAC.
        // Miniport driver set to the primary dac by default;
        ulDac = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[0];
        ulWidth = HwDeviceExtension->DeskTopInfo.ulDisplayWidth[ulDac];
        ulHeight = HwDeviceExtension->DeskTopInfo.ulDisplayHeight[ulDac];
        ulRefresh = HwDeviceExtension->DeskTopInfo.ulDisplayRefresh[ulDac];
        ulPixelDepth = HwDeviceExtension->DeskTopInfo.ulDisplayPixelDepth[ulDac];

        for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)   
        {
            if(!ModeEntry[i].ValidMode)
                continue;

            if( (ModeEntry[i].Depth == ulPixelDepth) &&
                (ModeEntry[i].RefreshRate == ulRefresh) &&
                (ModeEntry[i].Width == ulWidth) &&
                (ModeEntry[i].Height == ulHeight) )
            {
                Mode->RequestedMode = i;
                break;
            }
        }
        if(i == HwDeviceExtension->NumRegistryModes)
            return (ERROR_INVALID_PARAMETER);
    }

    pRequestedMode = &(ModeEntry[Mode->RequestedMode]);

    //**************************************************************************
    // Initialize the Graphics Mode and Engine.
    //**************************************************************************

    if (NV4SetMode(HwDeviceExtension, pRequestedMode) == FALSE)
        return(ERROR_NOT_ENOUGH_MEMORY);

    //**************************************************************************
    // Store the new mode value.
    //**************************************************************************

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

#if _WIN32_WINNT >= 0x0500
    HwDeviceExtension->ulDualViewStatus |= DUALVIEW_STATUS_GRAPHICS_MODE;
#endif

    VideoDebugPrint((1, "NVSetMode - exit\n"));
    return NO_ERROR;

    } //end NVSetMode()


//******************************************************************************
//
//  Function:   NVGetNVInfo()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN NVGetNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    PHWINFO NVInfo;
    ULONG refresh;
    ULONG i,j;
    ULONG Size;
    BOOLEAN status=TRUE;
    ULONG   FullChipId,ChipId;
    ULONG   TopOfFB;
    U016    rc;
    PCI_SLOT_NUMBER slot;

    //**************************************************************************
    // Get ptr to NVInfo structure and clear it out.
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    VideoPortZeroMemory(NVInfo, sizeof(HWINFO));


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // WIN2K:   We need to determine what chip we're running on for Win2K!
    //          This was NOT obtained in NVIsPresent, so we need to
    //          determine it HERE, because we now have access to the
    //          the hardware registers !!
    //**************************************************************************

    ChipId = REG_RD32(NV_PBUS_PCI_NV_0);
    ChipId >>= 16;                              // Get top 16 bits (bits 16 thru 31)
    ChipId &= 0xffff;                           // Just look at 16 bits

    FullChipId = ChipId;                        // Save complete id
    ChipId &= 0xfffc;                           // Ignore Sub Revisions 1 thru 3

    switch (ChipId)
        {
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04:

            //******************************************************************
            // NV4 (original TNT)
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV4_DEVICE_NV4_ID;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0:

            //******************************************************************
            // NV5 (TNT2)   ID = 28
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV5_DEVICE_NV5_ID;

            //******************************************************************
            // NV5 (TNT2 ULTRA)  ID = 29
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1)
                HwDeviceExtension->ulChipID     = NV5ULTRA_DEVICE_NV5ULTRA_ID;


            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0:

            //******************************************************************
            // VANTA (ID = 2C)
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV5VANTA_DEVICE_NV5VANTA_ID;

            //******************************************************************
            // (TNT2 Model 64) (ID = 2D)
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1)
                HwDeviceExtension->ulChipID     = NV5MODEL64_DEVICE_NV5MODEL64_ID;

            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0:

            //******************************************************************
            // NV0A
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV0A_DEVICE_NV0A_ID;
            break;

        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0:

            //******************************************************************
            // NV10
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV10_DEVICE_NV10_ID;

            //******************************************************************
            // NV10DDR (NV10 DDR)  ID = 101
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1)
                HwDeviceExtension->ulChipID     = NV10DDR_DEVICE_NV10DDR_ID;

            //******************************************************************
            // NV10GL (NV10 GL)  ID = 103
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3)
                HwDeviceExtension->ulChipID     = NV10GL_DEVICE_NV10GL_ID;


            break;


        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID0:

            //******************************************************************
            // NV11 ID = 110
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV11_DEVICE_NV11_ID;

            //******************************************************************
            // NV11DDR (NV11 DDR)  ID = 111
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID1)
                HwDeviceExtension->ulChipID     = NV11DDR_DEVICE_NV11DDR_ID;

            //******************************************************************
            // NV11M (NV11 Mobile)  ID = 112
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID2)
                HwDeviceExtension->ulChipID     = NV11M_DEVICE_NV11M_ID;

            //******************************************************************
            // NV11GL (NV11 GL)  ID = 113
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID3)
                HwDeviceExtension->ulChipID     = NV11GL_DEVICE_NV11GL_ID;

            break;


        case NV_CONFIG_PCI_NV_0_DEVICE_ID_CRUSH11_DEVID0:

            //******************************************************************
            // Crush11 ID = 1A0
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV11_DEVICE_CRUSH11_ID;

            break;
               
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0:

            //******************************************************************
            // NV15 ID = 150
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV15_DEVICE_NV15_ID;

            //******************************************************************
            // NV15DDR (NV15 DDR)  ID = 151
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1)
                HwDeviceExtension->ulChipID     = NV15DDR_DEVICE_NV15DDR_ID;

            //******************************************************************
            // NV15BR (NV15 BR)  ID = 152
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2)
                HwDeviceExtension->ulChipID     = NV15BR_DEVICE_NV15BR_ID;


            //******************************************************************
            // NV15GL (NV15 GL)  ID = 153
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3)
                HwDeviceExtension->ulChipID     = NV15GL_DEVICE_NV15GL_ID;


            break;

        
        case NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID0:

            //******************************************************************
            // NV20 ID = 200
            //******************************************************************
            HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_ID;

            //******************************************************************
            // NV20 ID = 201
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID1)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_1_ID;

            //******************************************************************
            // NV20 ID = 202
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID2)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_2_ID;

            //******************************************************************
            // NV20 ID = 203
            //******************************************************************

            if (FullChipId == NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID3)
                HwDeviceExtension->ulChipID     = NV20_DEVICE_NV20_3_ID;

            break;


        default:

            //******************************************************************
            // Unsupported Chip
            //******************************************************************
            status=FALSE;
            return(status);
        }
#endif


    //**************************************************************************
    // Now that we're using a Resource Manager, the majority of the
    // NVInfo structure fields are no longer used (These values were used
    // in the older 1.00 driver).  Since they're no longer used, just
    // zero them out.
    //**************************************************************************

    NVInfo->Pram.CurrentSize        = 0;
    NVInfo->Pram.HashTableAddr      = 0;
    NVInfo->Pram.HashDepth          = 0;
    NVInfo->Pram.FifoRunoutAddr     = 0;
    NVInfo->Pram.RunOutMask         = 0;
    NVInfo->Pram.FifoContextAddr    = 0;
    NVInfo->Pram.FreeInstSize       = 0;
    NVInfo->Pram.FreeInstBase       = 0;
    NVInfo->Dac.CursorImageInstance = 0;


    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID))
    {
        switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_CFG,_BUS))
        {
            case NV_PFB_CFG_BUS_64:
                NVInfo->Dac.InputWidth = 64;
                break;
            case NV_PFB_CFG_BUS_128:
                NVInfo->Dac.InputWidth = 128;
                break;
            case NV_PFB_CFG_BUS_32:
                NVInfo->Dac.InputWidth = 32;
                break;
        }
    }
    else if ((HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
             (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
    {
        NVInfo->Dac.InputWidth = 128;
    }
    else
    {
        switch (PFB_REG_RD_DRF(PFB_Base, _PFB, _BOOT_0, _RAM_WIDTH_128))
        {
            case NV_PFB_BOOT_0_RAM_WIDTH_128_OFF:
                NVInfo->Dac.InputWidth = 64;
                break;
            case NV_PFB_BOOT_0_RAM_WIDTH_128_ON:
                NVInfo->Dac.InputWidth = 128;
                break;
        }
    }

    //**************************************************************************
    // Get Chip revision and implementation
    //**************************************************************************

//    NVInfo->Chip.Implementation = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_IMPLEMENTATION);
//    NVInfo->Chip.Revision = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_FIB_REVISION);
//    NVInfo->Chip.Architecture = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_ARCHITECTURE);
//    NVInfo->Chip.Manufacturer = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_MANUFACTURER);

    //**************************************************************************
    // Get memory type
    //**************************************************************************

//    NVInfo->Framebuffer.RamType = PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV,_BOOT_0,_STRAP_RAM_TYPE) ==
//                            NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO ? BUFFER_DRAM : BUFFER_VRAM;

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)         ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)         ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)       ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)         ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)     ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)         ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))

    {
        NVInfo->Framebuffer.RamSize = PFB_REG_RD32(PFB_Base,NV_PFB_CSTATUS);
        NVInfo->Framebuffer.RamSizeMb = NVInfo->Framebuffer.RamSize >> 20;
    }
    else if  (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)
    {
        slot.u.AsULONG = 0x0;    // make sure all fields are initialized
        slot.u.bits.DeviceNumber   = 0;
        slot.u.bits.FunctionNumber = 1;

        HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                              0,                    // bus number
                              slot.u.AsULONG,       // slot number
                              &TopOfFB,             // buffer
                              CR_CMC_CFG0 & 0xFF,   // config space offset
                              sizeof(ULONG));       // buffer size

        NVInfo->Framebuffer.RamSizeMb =
                            CR_DRF_VAL(_CMC, _CFG0, _TOP_OF_FB, TopOfFB) + 1;
        NVInfo->Framebuffer.RamSize = NVInfo->Framebuffer.RamSizeMb << 20;
       
    }
    else
    {
        //**************************************************************************
        // Get amount of VRAM
        // NOTE: These values are DIFFERENT from those defined in NV3 !!
        //**************************************************************************

        switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0, _RAM_AMOUNT))
            {
            case NV_PFB_BOOT_0_RAM_AMOUNT_32MB:
                NVInfo->Framebuffer.RamSizeMb = 32;
                NVInfo->Framebuffer.RamSize   = 0x02000000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
                NVInfo->Framebuffer.RamSizeMb = 4;
                NVInfo->Framebuffer.RamSize   = 0x00400000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_8MB:
                NVInfo->Framebuffer.RamSizeMb = 8;
                NVInfo->Framebuffer.RamSize   = 0x00800000;
                break;
            case NV_PFB_BOOT_0_RAM_AMOUNT_16MB:
                NVInfo->Framebuffer.RamSizeMb = 16;
                NVInfo->Framebuffer.RamSize   = 0x01000000;
                break;
            default:
                //******************************************************************
                // Invalid memory configuration
                //******************************************************************
                status=FALSE;
                return(status);
            }


        //**************************************************************************
        // Check for UMA usage
        //
        // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
        // bit fields to zero.
        //**************************************************************************

        if (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
            switch (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA_SIZE))
            {
                case NV_PFB_BOOT_0_UMA_SIZE_2M:
                    NVInfo->Framebuffer.RamSizeMb = 2;
                    NVInfo->Framebuffer.RamSize   = 0x00200000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_4M:
                    NVInfo->Framebuffer.RamSizeMb = 4;
                    NVInfo->Framebuffer.RamSize   = 0x00400000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_6M:
                    NVInfo->Framebuffer.RamSizeMb = 6;
                    NVInfo->Framebuffer.RamSize   = 0x00600000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_8M:
                    NVInfo->Framebuffer.RamSizeMb = 8;
                    NVInfo->Framebuffer.RamSize   = 0x00800000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_10M:
                    NVInfo->Framebuffer.RamSizeMb = 10;
                    NVInfo->Framebuffer.RamSize   = 0x00A00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_12M:
                    NVInfo->Framebuffer.RamSizeMb = 12;
                    NVInfo->Framebuffer.RamSize   = 0x00C00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_14M:
                    NVInfo->Framebuffer.RamSizeMb = 14;
                    NVInfo->Framebuffer.RamSize   = 0x00E00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_16M:
                    NVInfo->Framebuffer.RamSizeMb = 16;
                    NVInfo->Framebuffer.RamSize   = 0x01000000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_18M:
                    NVInfo->Framebuffer.RamSizeMb = 18;
                    NVInfo->Framebuffer.RamSize   = 0x01200000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_20M:
                    NVInfo->Framebuffer.RamSizeMb = 20;
                    NVInfo->Framebuffer.RamSize   = 0x01400000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_22M:
                    NVInfo->Framebuffer.RamSizeMb = 22;
                    NVInfo->Framebuffer.RamSize   = 0x01600000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_24M:
                    NVInfo->Framebuffer.RamSizeMb = 24;
                    NVInfo->Framebuffer.RamSize   = 0x01800000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_26M:
                    NVInfo->Framebuffer.RamSizeMb = 26;
                    NVInfo->Framebuffer.RamSize   = 0x01A00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_28M:
                    NVInfo->Framebuffer.RamSizeMb = 28;
                    NVInfo->Framebuffer.RamSize   = 0x01C00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_30M:
                    NVInfo->Framebuffer.RamSizeMb = 30;
                    NVInfo->Framebuffer.RamSize   = 0x01E00000;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_32M:
                    NVInfo->Framebuffer.RamSizeMb = 32;
                    NVInfo->Framebuffer.RamSize   = 0x02000000;
                    break;
                default:
                    //******************************************************************
                    // Invalid memory configuration
                    //******************************************************************
                    status=FALSE;
                    return(status);
            }
    }

    //**************************************************************************
    // Default to 640x480x16x1 framebuffer with VGA timing
    //**************************************************************************

    NVInfo->Framebuffer.DpmLevel          = 0;
    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.Depth             = 16;
    NVInfo->Framebuffer.RefreshRate       = 60;
    NVInfo->Framebuffer.Count             = 1;
    NVInfo->Framebuffer.ActiveCount       = 1;
    NVInfo->Framebuffer.ActiveMask        = 1;
    NVInfo->Framebuffer.Current           = 0;
    NVInfo->Framebuffer.FlipUsageCount    = 0;
    NVInfo->Framebuffer.FlipTo            = 0;
    NVInfo->Framebuffer.FlipFrom          = 0;
    NVInfo->Framebuffer.UpdateFlags       = 0;
    NVInfo->Framebuffer.HorizFrontPorch   = 0;
    NVInfo->Framebuffer.HorizSyncWidth    = 0;
    NVInfo->Framebuffer.HorizBackPorch    = 0;
    NVInfo->Framebuffer.HorizDisplayWidth = 0;
    NVInfo->Framebuffer.VertFrontPorch    = 0;
    NVInfo->Framebuffer.VertSyncWidth     = 0;
    NVInfo->Framebuffer.VertBackPorch     = 0;
    NVInfo->Framebuffer.VertDisplayWidth  = 0;
    NVInfo->Framebuffer.HSyncPolarity     = 0;
    NVInfo->Framebuffer.VSyncPolarity     = 0;
    NVInfo->Framebuffer.CSync             = 0;
    NVInfo->Framebuffer.ConfigPageHeight  = 0;
    NVInfo->Pram.CurrentSize              = 0;
    NVInfo->Pram.AvailableSize[0]         =  NV_PRAM_DEVICE_SIZE_5_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[1]         =  NV_PRAM_DEVICE_SIZE_9_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[2]         =  NV_PRAM_DEVICE_SIZE_17_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
    NVInfo->Pram.AvailableSize[3]         =  NV_PRAM_DEVICE_SIZE_33_5_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;

    //**************************************************************************
    // Default Refresh Rate
    //**************************************************************************

    NVInfo->Framebuffer.RefreshRate = 60;
    NVInfo->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    NVInfo->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;

    //**************************************************************************
    // Default resolution
    //**************************************************************************

    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.HorizDisplayWidth = 640;
    NVInfo->Framebuffer.VertDisplayWidth  = 480;
    NVInfo->Framebuffer.Depth             = 16;

    //**************************************************************************
    // Determine refresh rate
    //**************************************************************************

    if (NVInfo->Framebuffer.RefreshRate < 70)
       refresh = 0;
    if (NVInfo->Framebuffer.RefreshRate < 72)
        refresh = 1;
    else if (NVInfo->Framebuffer.RefreshRate < 75)
        refresh = 2;
    else if (NVInfo->Framebuffer.RefreshRate < 85)
        refresh = 3;
    else if (NVInfo->Framebuffer.RefreshRate < 100)
        refresh = 4;
    else if (NVInfo->Framebuffer.RefreshRate < 120)
        refresh = 5;
    else
        refresh = 6;

    //**************************************************************************
    // Update the DAC flags and types
    //**************************************************************************

    NVInfo->Dac.UpdateFlags = 0;
    NVInfo->Dac.FinishFlags = 0;

    //**************************************************************************
    // Initialize the cursor data (transparent)
    //**************************************************************************

//    NVInfo->Dac.CursorType = DAC_CURSOR_TWO_COLOR_XOR;
    NVInfo->Dac.CursorEmulation = FALSE;
    NVInfo->Dac.CursorExclude= FALSE;
    NVInfo->Dac.CursorColor1 = 0x00000000;
    NVInfo->Dac.CursorColor2 = 0x00ffffff;
    NVInfo->Dac.CursorColor3 = 0x00000000;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[0][i] = 0x00;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[1][i] = 0xff;

    for (i=0;i<32;i++)
        for (j=0;j<32;j++)
            NVInfo->Dac.CursorColorImage[i][j]= 0x00000000;

    //**************************************************************************
    // Initialize palette to gray scale
    //**************************************************************************

    for (i=0;i<256;i++)
        NVInfo->Dac.Palette[i] = (i<<16) | (i<<8) | i;

    //**************************************************************************
    // Initialize Power Management state
    //**************************************************************************

    NVInfo->Dac.DpmLevel = 0;

    //**************************************************************************
    // Initialize Video Clock
    //**************************************************************************

    NVInfo->Dac.VClk= 0;

    //**************************************************************************
    // return success
    //**************************************************************************

    return(status);
    }

VOID NVUpdateRegNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    PWSTR   pwszChip, pwszAdapterString;
    ULONG   i, cbChip, cbAdapterString;

    pwszChip = L"NVxx";
    cbChip = sizeof(L"NVxx");
    pwszAdapterString = L"NVxx";
    cbAdapterString = sizeof(L"NVxx");

    for(i = 0; i < sizeof(sChipInfo) / sizeof(CHIP_INFO); i++)
    {
        if (HwDeviceExtension->ulChipID == sChipInfo[i].ulDevID)
        {
            pwszChip = sChipInfo[i].pwszChip;
            cbChip = cbStrLenW(pwszChip);
            pwszAdapterString = sChipInfo[i].pwszAdapterString; 
            cbAdapterString = cbStrLenW(pwszAdapterString);
            break;
        }
    }

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   L"Integrated RAMDAC",
                                   sizeof(L"Integrated RAMDAC") );

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &(HwDeviceExtension->NvInfo.Framebuffer.RamSize),
                                   sizeof(ULONG));
    }


//******************************************************************************
//
//  Function:   NV4SetMode
//
//  Routine Description:
//
//  Arguments:
//
//  Return Value:
//
//******************************************************************************

BOOL NV4SetMode(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        PMODE_ENTRY RequestedMode  )
    {
    PHWINFO NVInfo;
    PUCHAR crtc;
    ULONG OffScreenMemory;
    ULONG OnScreenMemory;
    UCHAR  mode, bitdepth, doubled;
    USHORT vesaMode;
    VIDEO_REQUEST_PACKET requestPacket;
    STATUS_BLOCK statusblock;
    PDMT_OVERRIDES pDMTOverrides;
    U016   UseDMTFlag;
    ULONG CurrentValue;
    BOOLEAN bRefreshRateDefault;
    MODE_TIMING_VALUES timingInfo;
    GTF_TIMINGS vbe_timings;
    unsigned int vesaStatus;
    ULONG result;
    
    //**************************************************************************
    //    Current Issues with New Style Modeset Code:
    //
    //    1) NT 3.51 will no longer work with new style modeset code, because
    //       RmSetMode calls RmUnloadState and RmLoadState.
    //       (NT 3.51 does not work with a Resource Manager to my knowledge).
    //
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    NVInfo->Framebuffer.HorizDisplayWidth   = RequestedMode->Width;
    NVInfo->Framebuffer.VertDisplayWidth    = RequestedMode->Height;
    NVInfo->Framebuffer.Depth               = RequestedMode->Depth;
    NVInfo->Framebuffer.RefreshRate         = RequestedMode->RefreshRate;

    if ( !(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
    {

        // Added to support GTF or DMT method selection under WinNT4 and Win2K
        if (HwDeviceExtension->bUseGTF)
        {

            //**********************************************************************
            // Here we use GTF timings as requested by the user
            //**********************************************************************

            vesaStatus = vesaGetGTFTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                           NVInfo->Framebuffer.VertDisplayWidth,    
                                           NVInfo->Framebuffer.RefreshRate,
                                           &timingInfo);

            if (vesaStatus)
            {
                // Could not find a GTF timing for this mode
                return(FALSE);
            }

        }
        else
        {

            //**************************************************************************
            // Here we use DMT timings  (instead of GTF timings)
            //**************************************************************************

            vesaStatus = vesaGetDMTTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                           NVInfo->Framebuffer.VertDisplayWidth,    
                                           NVInfo->Framebuffer.RefreshRate,
                                           &timingInfo);

            //**************************************************************************
            // If DMT timings don't exist for this mode, use the GTF timings
            //**************************************************************************

            if (vesaStatus)
            {

                //**********************************************************************
                // Set mode using GTF timings if DMT timings don't exist
                //**********************************************************************

                vesaStatus = vesaGetGTFTimings(NVInfo->Framebuffer.HorizDisplayWidth ,
                                               NVInfo->Framebuffer.VertDisplayWidth,    
                                               NVInfo->Framebuffer.RefreshRate,
                                               &timingInfo);

                if (vesaStatus)
                {
                    // Could not find a DMT / GTF timing for this mode
                    return(FALSE);
                }
            }
        }
    }




    //**************************************************************************
    // Still need to make sure the 'global' hwdevice variable is in sync.
    // (We need to eventually get rid of this global hwdev variable !!!)
    //**************************************************************************

    SetGlobalHwDev(HwDeviceExtension);

    //**************************************************************************
    // Unlock the registers
    //**************************************************************************

    NV_OEMEnableExtensions(HwDeviceExtension);          

    //**************************************************************************
    // Determine which modes are 'doubled'
    //**************************************************************************

    doubled = 0;  

    if ((NVInfo->Framebuffer.VertDisplayWidth == 384 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 360 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 300 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 240 )  || 
        (NVInfo->Framebuffer.VertDisplayWidth == 200 ))   
        {
        doubled = 1;
        }
        
    if( !(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
    {
        //**************************************************************************
        // Pass the timings to the RM and let it set the mode (via DacProgramCRTC)
        // as well as fixup the modeset arbitration.
        //**************************************************************************


        if (RmSetMode(HwDeviceExtension->DeviceReference,
                  timingInfo.HorizontalVisible,
                  timingInfo.HorizontalBlankStart,
                  timingInfo.HorizontalRetraceStart,
                  timingInfo.HorizontalRetraceEnd,
                  timingInfo.HorizontalBlankEnd,
                  timingInfo.HorizontalTotal,
                  timingInfo.VerticalVisible,
                  timingInfo.VerticalBlankStart,
                  timingInfo.VerticalRetraceStart,
                  timingInfo.VerticalRetraceEnd,
                  timingInfo.VerticalBlankEnd,
                  timingInfo.VerticalTotal,
                  NVInfo->Framebuffer.Depth,
                  NVInfo->Framebuffer.RefreshRate,
                  NVInfo->Framebuffer.HorizDisplayWidth ,
                  NVInfo->Framebuffer.VertDisplayWidth,  
                  timingInfo.PixelClock,
                  timingInfo.HSyncpolarity,
                  timingInfo.VSyncpolarity,
                  doubled) != TRUE)
        {
        return(FALSE);
        }
    }
    //**************************************************************************
    // Save these values off so when we come back from hibernation,
    // we'll know what values to restore
    //**************************************************************************

    HwDeviceExtension->LastWidth        = NVInfo->Framebuffer.HorizDisplayWidth; 
    HwDeviceExtension->LastHeight       = NVInfo->Framebuffer.VertDisplayWidth;
    HwDeviceExtension->LastDepth        = NVInfo->Framebuffer.Depth;
    HwDeviceExtension->LastRefreshRate  = NVInfo->Framebuffer.RefreshRate;


    //**************************************************************************
    // Ask the RM if overlay is allowed at this resolution
    //**************************************************************************

    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_OVERLAY_ALLOWED,&result) ;

    if (result)
        HwDeviceExtension->bHwVidOvl = TRUE;
    else        
        HwDeviceExtension->bHwVidOvl = FALSE;

    //**************************************************************************
    // TV cursor adjust code
    //**************************************************************************

    if (HwDeviceExtension->TvIsPresent)
        {
        U008  ht,hrs,hbs,tvhbe,tvhbs;

        //**********************************************************************
        // Unlock the registers
        //**********************************************************************

        NV_OEMEnableExtensions(HwDeviceExtension);          

        //**********************************************************************
        // Calculate cursor min and max values (in pixels) for TV.
        //**********************************************************************

        CRTC_RD(NV_CIO_CR_HDT_INDEX, ht);   // h total
        CRTC_RD(NV_CIO_CR_HRS_INDEX, hrs);  // h retrace start
        CRTC_RD(NV_CIO_CR_HBS_INDEX, hbs);  // h blank start
        tvhbe = (U008) PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_TV_HBLANK_END);
        tvhbs = (U008) PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_TV_HBLANK_START);

        NVInfo->Dac.TVCursorMin = (ht+5-(hrs-2))*8 - tvhbe;
        NVInfo->Dac.TVCursorMax = (ht+5-((hrs-2)+hbs+1))*8 - tvhbs;
//        NVInfo->Dac.TVCursorMin += 20; // What should these values actually be?
//        NVInfo->Dac.TVCursorMax += 20; // What should these values actually be?
        NVInfo->Dac.TVCursorMin = 0;     // Set to zero for now   
        NVInfo->Dac.TVCursorMax = 0;     // Set to zero for now


        }
        

    //**************************************************************************
    // WHQL fixup code:
    //
    // The following code should probably be removed, and is leftover
    // code from the OLD style modeset code.  But we NEED to check
    // that the NEW style modeset code (ie RmSetMode) does indeed set
    // the following registers correctly.  Otherwise, this could cause
    // various WHQL tests to fail.  So for now, leave this code INTACT!
    //**************************************************************************

    {
    //**************************************************************************
    // Specify 5:5:5 or 5:6:5 format
    // ModeSet code currently defaults to 5:6:5 (in OEMSetRegs)
    //**************************************************************************

    if (RequestedMode->Depth == 16)
        {
        //**********************************************************************
        // Currently the display driver only handles 5:5:5 format...
        // So for now, just specify 5:5:5 always until we add the 5:6:5 specific modes
        //**********************************************************************
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,
            (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _16)) |
               (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)));
        }

    else if (RequestedMode->Depth == 8)
        {
        // if 8 bit mode, make sure we're using an 8bit palette
        //if (pDev.Framebuffer.Depth == 8)
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,
                (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)) );
        }

    //**************************************************************************
    // Make sure Bit 20 is always set for 32bpp modes
    //**************************************************************************

    if (RequestedMode->Depth == 32)
        {
        CurrentValue = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_GENERAL_CONTROL);
        CurrentValue |= (DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS)) ;
        PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,CurrentValue);
        }


    //**************************************************************************
    // Make sure to turn off 2D dithering.  Otherwise, HCT tests will fail!
    //**************************************************************************

    CurrentValue = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_DEBUG_3);

    //**************************************************************************
    // Mask off the 2d dither bits
    //**************************************************************************

    CurrentValue &= (~ ( (DRF_DEF(_PGRAPH, _DEBUG_3, _POSTDITHER_2D, _ENABLED )) |
                         (DRF_DEF(_PGRAPH, _DEBUG_3, _PREDITHER_2D, _ENABLED )) ));


    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_3,CurrentValue);

    }
    

    //**************************************************************************
    // If flat panel is present, make sure to clear out the following registers
    // because video bios's after 09/02/99 may touch these registers.
    // These registers should probably get cleared in dacSetFlatPanelMode in the RM
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {
        REG_WR32(NV_PRAMDAC_FP_DEBUG_1, 0x00000000);
        REG_WR32(NV_PRAMDAC_FP_DEBUG_2, 0x00000000);
        }


    //**************************************************************************
    // Another ALI 1541 workaround fix
    //**************************************************************************


    if (HwDeviceExtension->AliChipset_Problem_Found==TRUE)
    
        {

        //**********************************************************************
        //
        // This chipset has another bug, confirmed by ALI, where it cannot
        // accept fast DEVSEL# at 100MHz bus speeds.  We cannot adjust our
        // DEVSEL# speeds, but we can delay our TRDY by one clock cycle, which
        // should have the same effect.
        //
        // Note that we (NV) have seen no improvement in any of the ALI1541
        // issues with this change, but ALI is adament there is a bug in the 1541
        // having to do with this logic.  Better safe than sorry.
        //
        // This bit is present in NV4, NV5, and NV10.
        //
        //**********************************************************************

        CurrentValue = REG_RD32(NV_PBUS_DEBUG_1);
        CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_DEBUG_1_PCIS_WRITE));
        REG_WR32(NV_PBUS_DEBUG_1,  CurrentValue);

        }
               

    return(TRUE);
    } // end NV4SetMode()

//******************************************************************************
//
// Function: NV_SetColorLookup()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )
    {
    ULONG i;

    //**************************************************************************
    // wait for vblank
    //**************************************************************************
    if(HwDeviceExtension->curMonitorPowerState == VideoPowerOn)
    {
        if(HwDeviceExtension->curAdapterPowerState == VideoPowerOn)
        {
            while (!(PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08));
        }
    }

    //**************************************************************************
    //  Specify first palette register
    //**************************************************************************
    USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_WRITE_MODE_ADDRESS, (UCHAR) ClutBuffer->FirstEntry);

    //**************************************************************************
    //  Set CLUT registers directly on the hardware
    //**************************************************************************

    for (i = 0; i < ClutBuffer->NumEntries; i++)
        {
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Red);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Green);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Blue);
        }

    }

//******************************************************************************
//
// Function: NV4_SetPixMixBits()
//
// Routine Description: Set the NV_PRAMDAC_GENERAL_CONTROL_PIXMIX to 
//                      NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_SetPixMixBits(
    PHW_DEVICE_EXTENSION    HwDeviceExtension
)
{
    ULONG   ulGeneralCtrl;

    ulGeneralCtrl = PRAMDAC_REG_RD32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL);

    //
    //  Set NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON
    //

    ulGeneralCtrl |= 0x30;
    PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_GENERAL_CONTROL,ulGeneralCtrl);
}

//******************************************************************************
//
// Function: NV4_InitPalette()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_InitPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
    {
    USHORT i;

    //**************************************************************************
    // Blast out our palette values.  First Init to index 0
    //**************************************************************************
    USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_WRITE_MODE_ADDRESS, (UCHAR) 0);

    //**************************************************************************
    // Init to a gray scale so something will appear instead of just black
    // 256 * 3 (for each R,G, and B component)
    //**************************************************************************

    for (i = 0; i < 256; i++)
        {
        //**********************************************************************
        // Just initialize to a gray scale for now.
        //**********************************************************************
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        USERDAC_REG_WR08(USERDAC_Base, NV_USER_DAC_PALETTE_DATA, (UCHAR) i);
        }

    return;


    }


//******************************************************************************
//
// Function:    NVMapMemoryRanges()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NVMapMemoryRanges(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PHYSICAL_ADDRESS CrtcRange;
    PHYSICAL_ADDRESS TimerRange;
    PHYSICAL_ADDRESS NV_PhysBaseAddress;
    PHYSICAL_ADDRESS NV_PhysFBAddress;
    ULONG CrtcLength;
    ULONG TimerLength;
    ULONG NV_RegisterLength;
    ULONG NV_FrameBufferLength;
    PHWREG CrtcAddress;
    PHWREG TimerAddress;
    PHWREG NV_LinearBaseAddress;
    PHWREG NV_LinearFBAddress;
    PHYSICAL_ADDRESS ConfigPciRange;
    ULONG ConfigPciLength;
    PHWREG ConfigPciAddress;
    ULONG CurrentValue;

    //**************************************************************************
    // Make SURE to always ENABLE bus mastering!  Our chip needs it ENABLED !!
    // (Some DELL Bios's disable bus mastering on our card)
    //**************************************************************************

    //**************************************************************************
    // First get access to the CONFIG_PCI_NV1 register
    //**************************************************************************

    ConfigPciRange.HighPart  = 0x00000000;
    ConfigPciRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    ConfigPciRange.LowPart   += NV_PBUS_PCI_NV_1;
    ConfigPciLength          = 0x1000;   // Arbitrary 4k length

    ConfigPciAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         ConfigPciRange,
                                         ConfigPciLength, FALSE);
    if (ConfigPciAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Config PCI Reg\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Make sure bus mastering is always ENABLED !!  (Bit 2)
    // Read current value then enable the bus_master bit.
    //**************************************************************************

    CurrentValue = TEMP_REG_RD32(ConfigPciAddress);
    CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_PCI_NV_1_BUS_MASTER));
    TEMP_REG_WR32(ConfigPciAddress,  CurrentValue);

    //**************************************************************************
    // Free up this temporary range
    //**************************************************************************

    VideoPortFreeDeviceBase(hwDeviceExtension, ConfigPciAddress);


    //**************************************************************************
    // Make SURE to disable VBLANK and TIMER interrupts on startup!
    // (Some COMPAQ systems do not reset the chip, so these interrupts
    // may inadvertently get left enabled.  These interrupts (vblank/timer) then
    // enter our interrupt handler before its ready to accept them)
    //**************************************************************************

    //**************************************************************************
    // First get access to VBLANK interrupt enable register
    //**************************************************************************

    CrtcRange.HighPart  = 0x00000000;
    CrtcRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    CrtcRange.LowPart   += NV_PCRTC_INTR_EN_0;
    CrtcLength          = 0x1000;   // Arbitrary 4k length

    CrtcAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         CrtcRange,
                                         CrtcLength, FALSE);
    if (CrtcAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Crtc Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Get access to TIMER interrupt enable register
    //**************************************************************************

    TimerRange.HighPart  = 0x00000000;
    TimerRange.LowPart   = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    TimerRange.LowPart   += NV_PTIMER_INTR_EN_0 ;
    TimerLength          = 0x1000;   // Arbitrary 4k length

    TimerAddress=VideoPortGetDeviceBase(hwDeviceExtension,
                                         TimerRange,
                                         TimerLength, FALSE);
    if (TimerAddress==NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Timer Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Make sure these interrupts are always DISABLED initially!
    //**************************************************************************

    TEMP_REG_WR32(CrtcAddress,  0x00000000);
    TEMP_REG_WR32(TimerAddress, 0x00000000);

    //**************************************************************************
    // Free up these temporary ranges
    //**************************************************************************

    VideoPortFreeDeviceBase(hwDeviceExtension, CrtcAddress);
    VideoPortFreeDeviceBase(hwDeviceExtension, TimerAddress);

    //**************************************************************************
    // Map entire NV register space
    //**************************************************************************

    NV_PhysBaseAddress.HighPart = 0x00000000;
    NV_PhysBaseAddress.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    NV_RegisterLength           = 0x1000000;    // 16M

    if ( (  NV_LinearBaseAddress = VideoPortGetDeviceBase(hwDeviceExtension,
                                                          NV_PhysBaseAddress,
                                                          NV_RegisterLength, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PGRAPH Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }
    hwDeviceExtension->NvRegisterBase = NV_LinearBaseAddress;

    //**************************************************************************
    // Initialize the 'individual' memory ranges
    //**************************************************************************

    hwDeviceExtension->NV1_Lin_PMC_Registers    = NV_LinearBaseAddress + (DEVICE_BASE(NV_PMC)/4);
    hwDeviceExtension->NV1_Lin_PFB_Registers    = NV_LinearBaseAddress + (DEVICE_BASE(NV_PFB)/4);
    hwDeviceExtension->NV1_Lin_PFIFO_Registers  = NV_LinearBaseAddress + (DEVICE_BASE(NV_PFIFO)/4);
    hwDeviceExtension->NV1_Lin_PBUS_Registers   = NV_LinearBaseAddress + (DEVICE_BASE(NV_PBUS)/4);
    hwDeviceExtension->NV1_Lin_PGRAPH_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PGRAPH)/4);
    hwDeviceExtension->NV1_Lin_PEXTDEV_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_PEXTDEV)/4);
    hwDeviceExtension->NV3_Lin_PRMVIO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PRMVIO)/4);
    hwDeviceExtension->NV3_Lin_PRMCIO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PRMCIO)/4);
    hwDeviceExtension->NV3_Lin_PRAMDAC_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_PRAMDAC)/4);
    hwDeviceExtension->NV3_Lin_USERDAC_Registers= NV_LinearBaseAddress + (DEVICE_BASE(NV_USER_DAC)/4);
    hwDeviceExtension->NV3_Lin_PVIDEO_Registers = NV_LinearBaseAddress + (DEVICE_BASE(NV_PVIDEO)/4);
    hwDeviceExtension->NV1_Lin_USER_Registers   = NV_LinearBaseAddress + (DEVICE_BASE(NV_USER)/4);
    hwDeviceExtension->pBios = (PUCHAR)(&((hwDeviceExtension->NvRegisterBase)->Reg008[DEVICE_BASE(NV_PRAMIN)]));

    //**************************************************************************
    // Return successful
    //**************************************************************************

    return(NO_ERROR);

    } // NVMapMemoryRanges()

//******************************************************************************
//
// Function:    NVMapFrameBuffer()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NVMapFrameBuffer(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VIDEO_MEMORY_INFORMATION memoryInformation;
    PHWINFO NVInfo;
    PHYSICAL_ADDRESS NVFrameBuffer;
    ULONG inIoSpace;
    ULONG status;
    ULONG MapMemoryAdjust;

    //**************************************************************************
    // Get the amount of memory available on the card
    // (Determined in GetNVInfo)
    //**************************************************************************

    NVInfo = &(hwDeviceExtension->NvInfo);
    memoryInformation.VideoRamLength = NVInfo->Framebuffer.RamSize;

    //**************************************************************************
    // Set VideoRamBase to zero, to map range at any location in the
    // logical address space of the current process
    //**************************************************************************

    memoryInformation.VideoRamBase = 0;

    //**************************************************************************
    // Get the physical address of the frame buffer
    //**************************************************************************

    NVFrameBuffer.HighPart = 0x00000000;
    NVFrameBuffer.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
    NVFrameBuffer.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;

    //**************************************************************************
    // Always set write combining for NT4.0 or later
    // Do NOT set it for NT 3.51 !!!!
    //**************************************************************************

#if (_WIN32_WINNT >= 0x0400)
    inIoSpace = VIDEO_MEMORY_SPACE_P6CACHE;
#else
    inIoSpace = 0;
#endif

    //**************************************************************************
    // When calling RmPostNvDevice, and passing in our ptr to the frame buffer,
    // RmPostNvDevice needs to read and write a little bit PAST the end
    // of video memory in order to size it.  
    // 
    // So, in order to accomodate this and prevent a fatal exception error, 
    // we'll allocate just a little bit more memory than the actual amount needed. 
    // (Only necessary for Win2k or better)
    //**************************************************************************

    MapMemoryAdjust = memoryInformation.VideoRamLength;

#if (_WIN32_WINNT >= 0x0500)
    MapMemoryAdjust += BIOS_MEM_SIZE_ADJUST_FACTOR;
#endif


    status = VideoPortMapMemory(hwDeviceExtension,
                                 NVFrameBuffer,
                                 &(MapMemoryAdjust),
                                 &(inIoSpace),
                                 &(memoryInformation.VideoRamBase));


#if _WIN32_WINNT < 0x0500

    //**************************************************************************
    // Special Case unattended setup issue:
    //
    //      Normally, a 32Mb video card will install successfully on a system 
    //      with 32Mb of system memory, when the display driver is installed manually.
    //
    //      However, UNATTENDED setup of a 32Mb video card on a system with 32Mb
    //      may fail.  And what makes matters worse is that during unattended setup,
    //      the driver is usually installed BEFORE the service packs are applied.
    //      (Display driver should REALLY be installed AFTER the service pack is applied)
    //
    //      To alleviate this situation and allow a 32Mb video card to be installed
    //      via unattended setup, we'll try just allocating 16Mb if the above VideoPortMapMemory 
    //      call fails.  This is REALLY not valid (and may result in the driver
    //      not working correctly), but it will allow the driver to install
    //      and get past unattended setup.
    //
    //      After the service pack is applied, subsequent VideoPortMapMemory calls should 
    //      then succeed with no problem.    
    //       
    //**************************************************************************

    if (status != NO_ERROR)
        {

        NVInfo->Framebuffer.RamSizeMb = 16;
        NVInfo->Framebuffer.RamSize   = 0x01000000;

        memoryInformation.VideoRamLength = NVInfo->Framebuffer.RamSize;
        memoryInformation.VideoRamBase = 0;


        status = VideoPortMapMemory(hwDeviceExtension,
                                     NVFrameBuffer,
                                     &(memoryInformation.VideoRamLength),
                                     &(inIoSpace),
                                     &(memoryInformation.VideoRamBase));
        }
#endif



    hwDeviceExtension->FrameBufferPtr = memoryInformation.VideoRamBase;
    hwDeviceExtension->FrameBufferBase= memoryInformation.VideoRamBase;

    //**************************************************************************
    // If this call fails, driver should revert back to standard VGA
    //**************************************************************************

    return(status);



    }


//******************************************************************************
//
// Function: NVIsPresent()
//
// Routine Description:
//
// Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//
//******************************************************************************


BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION HwDeviceExtension,
                      PULONG NV1Slot)

    {
    USHORT  usVendorId;
    USHORT  usDeviceId;
    ULONG   ulSlot     = 0;
    ULONG   i;

        //
        // NOTE: the board detection part in this routine was moved into DetectNextDevice (see the bottom of this file)
        // 


        //**********************************************************************
        // Init NV memory range offset values to zero
        //**********************************************************************

        for (i=0 ; i<NV_NUM_RANGES ;i++)
          {
          RangeOffsets[i].ulOffset = 0;
          RangeOffsets[i].ulLength = 0;
          }

        //**********************************************************************
        // Initialize the actual offset values
        //**********************************************************************

        RangeOffsets[NV_PMC_INDEX].ulOffset = DEVICE_BASE(NV_PMC);
        RangeOffsets[NV_PMC_INDEX].ulLength = DEVICE_EXTENT(NV_PMC);

        RangeOffsets[NV_PFB_INDEX].ulOffset = DEVICE_BASE(NV_PFB);
        RangeOffsets[NV_PFB_INDEX].ulLength = DEVICE_EXTENT(NV_PFB);

        RangeOffsets[NV_PFIFO_INDEX].ulOffset = DEVICE_BASE(NV_PFIFO);
        RangeOffsets[NV_PFIFO_INDEX].ulLength = DEVICE_EXTENT(NV_PFIFO);

        RangeOffsets[NV_PBUS_INDEX].ulOffset = DEVICE_BASE(NV_PBUS);
        RangeOffsets[NV_PBUS_INDEX].ulLength = DEVICE_EXTENT(NV_PBUS);

        RangeOffsets[NV_PGRAPH_INDEX].ulOffset = DEVICE_BASE(NV_PGRAPH);
        RangeOffsets[NV_PGRAPH_INDEX].ulLength = DEVICE_EXTENT(NV_PGRAPH);

        RangeOffsets[NV_PEXTDEV_INDEX].ulOffset = DEVICE_BASE(NV_PEXTDEV);
        RangeOffsets[NV_PEXTDEV_INDEX].ulLength = DEVICE_EXTENT(NV_PEXTDEV);

        RangeOffsets[NV_PRMVIO_INDEX].ulOffset = DEVICE_BASE(NV_PRMVIO);
        RangeOffsets[NV_PRMVIO_INDEX].ulLength = DEVICE_EXTENT(NV_PRMVIO);

        RangeOffsets[NV_PRMCIO_INDEX].ulOffset = DEVICE_BASE(NV_PRMCIO);
        RangeOffsets[NV_PRMCIO_INDEX].ulLength = DEVICE_EXTENT(NV_PRMCIO);

        RangeOffsets[NV_PRAMDAC_INDEX].ulOffset = DEVICE_BASE(NV_PRAMDAC);
        RangeOffsets[NV_PRAMDAC_INDEX].ulLength = DEVICE_EXTENT(NV_PRAMDAC);

        RangeOffsets[NV_USERDAC_INDEX].ulOffset = DEVICE_BASE(NV_USER_DAC);
        RangeOffsets[NV_USERDAC_INDEX].ulLength = DEVICE_EXTENT(NV_USER_DAC);

        RangeOffsets[NV_PVIDEO_INDEX].ulOffset = DEVICE_BASE(NV_PVIDEO);
        RangeOffsets[NV_PVIDEO_INDEX].ulLength = DEVICE_EXTENT(NV_PVIDEO);

        //**********************************************************************
        // Currently allows us to write to 64k of PRAMIN memory
        //**********************************************************************

        RangeOffsets[NV_PRAMIN_INDEX].ulOffset = (ULONG) (DEVICE_BASE(NV_PRAMIN) - DEVICE_BASE(NV_PDFB));
        RangeOffsets[NV_PRAMIN_INDEX].ulLength = 0x10000;

        RangeOffsets[NV_USER_INDEX].ulOffset = DEVICE_BASE(NV_USER);
        RangeOffsets[NV_USER_INDEX].ulLength = 0x10000;

        //**********************************************************************
        // Just allocate memory for the GRAPHICS STATUS register
        // Allocate minimal 16 bytes because we're only mapping 1 register
        //**********************************************************************

        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulOffset = NV_PGRAPH_STATUS;
        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulLength = 16;

        //**********************************************************************
        // Setmode still uses PFB_CONFIG
        //**********************************************************************

        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulOffset = NV_PFB_CONFIG_0;
        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulLength = 16;

        //**********************************************************************
        // DUMB FRAME BUFFER location
        // The actual amount of memory is determined later in NV_GetNVInfo,
        // but for now, just default to 4Mb.  This value will be fixed up
        // in NV_GetNVInfo so that IOCTL_VIDEO_MAP_MEMORY will subsequently
        // map in the correct number of bytes.
        //**********************************************************************

        RangeOffsets[NV_PDFB_INDEX].ulOffset = 0x0;
        RangeOffsets[NV_PDFB_INDEX].ulLength =  0x400000;

        return(TRUE);
    }



//******************************************************************************
//
// Function:    MiniportGetRegistryValue
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

BOOL MiniportGetRegistryValue
    (PHW_DEVICE_EXTENSION HwDeviceExtension,
     U032 Type,
     char *Node,
     char *Name,
     VOID *pData)

    {
    ULONG NumRegValueEntries = sizeof(Nv_Registry_Switch_Offset_Table) / sizeof(NT_NV_REGISTRY_SWITCH_OFFSET);    
    ULONG i=0;   
    BOOL FoundFlag = FALSE;
    ULONG FoundIndex;
    BOOL status;
    char *RegValuePtr;
    char TempNameString[REG_STRING_DATA_MAX];
    WCHAR parameterName[80];
    

    //**************************************************************************
    // This function is called by the RM to get registry switch values.
    // Normally, the RM expects a 'Win9x' type registry, with various levels
    // of keys.  But with WinNT, all our registry switches must fit in
    // ONE key (ie. a flat structure).
    //
    // This routine attempts to find the registry switch name in our
    // registry switch table.  If it's present, we return the value (or string) back.
    // Otherwise, we return false   
    //**************************************************************************

    //**************************************************************************
    // First convert the registry value name string, and
    // convert to all upper case
    //**************************************************************************
    
    my_strcpy(TempNameString,Name);
    my_strupr(TempNameString);
    
    //**************************************************************************
    // Next, Search our registry table to see if this registry switch exists
    // in our 'local' registry structure.
    //**************************************************************************
        
    while ( (i < NumRegValueEntries) && (FoundFlag == FALSE) )
        {
        //**********************************************************************
        // Convert the registry switch names in our local registry table to upper case
        //**********************************************************************

        my_strupr(&Nv_Registry_Switch_Offset_Table[i].RegName[0]);

        //**********************************************************************
        // Now compare and see if this registry switch exists in our table
        // If so, then get the index into our registry switch table.
        //**********************************************************************
        
        status = my_strcmp(&Nv_Registry_Switch_Offset_Table[i].RegName[0], TempNameString);
        if (status == 0)
            {
            FoundFlag = TRUE;
            FoundIndex = i;
            }
                        
        i++;                
        }


    //**************************************************************************
    // If the registry switch was found in our table, then
    // get the corresponding value from our RegistrySwitch structure 
    // in our HwDeviceExtension.  Otherwise, return FALSE. 
    //**************************************************************************

    if (FoundFlag==TRUE)

        {

        if (Type == IS_STRING)

            {
            //******************************************************************
            // Copy the String value
            //******************************************************************

            RegValuePtr = (CHAR *) ((PUCHAR)&HwDeviceExtension->NV_Registry_Table + Nv_Registry_Switch_Offset_Table[FoundIndex].Offset); 
            my_strcpy(pData, RegValuePtr);
            }

        else if (Type == IS_DWORD)

            {
            //******************************************************************
            // Return the DWORD value
            //******************************************************************

            RegValuePtr = (CHAR *) ((PUCHAR)&HwDeviceExtension->NV_Registry_Table + Nv_Registry_Switch_Offset_Table[FoundIndex].Offset); 
            *(ULONG *)pData = *(ULONG *)RegValuePtr;
            

            //******************************************************************
            // Check if we should IGNORE the registry value
            //******************************************************************

            if ( *(ULONG *)pData == IGNORE_REGISTRY_SWITCH)
                return(FALSE);



            }
                
        return(TRUE);
        }
                
          
    else

        {

        //**********************************************************************
        // Unknown registry switch encountered.
        // This may happen if the RM is looking at a Win9x registry switch
        // and it hasn't been added to the NT registry switch table.
        // 
        // In that case, just read the registry switch as a normal
        // value entry (instead of inside our own local NT registry structure)
        // First, convert the parameter into a unicode string
        //**********************************************************************


        for (i = 0; Name[i]; i++)
            {
            parameterName[i] = Name[i];
            }
        parameterName[i] = (WCHAR)NULL;


        status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       parameterName,
                                       FALSE,
                                       NVReadRegistrySwitchesCallback,
                                       (ULONG *)pData);

        if (status == NO_ERROR)
            return(TRUE);
        else
            return(FALSE);            

        }
        
                    
       
    }
    

//******************************************************************************
//
// Function:    LoadRegistrySettings
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID LoadRegistrySettings(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG status;

    //**************************************************************************
    // There are 2 ways we can store registry switches for our NT driver:
    // 
    //   1) Store each registry switch in its own value entry
    //
    //      Advantages:     Easy to edit individual entries with RegEdit
    //      Disadvantages:  Lots of value entries are created which clutter
    //                      up the registry key.  If we need to delete them,
    //                      we may have to delete the entries one by one.
    //
    //   2) Store ALL the registry switches as a chunk in one value entry
    //         
    //      Advantages:     All the registry switches are in one place, not as unwieldly
    //      Disadvantes:    Not as easy to edit individual entries with RegEdit.
    //                          
    // 
    //   For now, we'll go with option 2) and store the switches as
    //   one chunk in a Value Entry.
    //**************************************************************************

    //**************************************************************************
    // First, check and see if our NT registry value entry (which contains our
    // local registry switches) is present or not.  If it's present, then
    // just read it straight into our registry structure.
    //**************************************************************************

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"NVREGSWITCHES",
                                       FALSE,
                                       NVReadRegistrySwitchesCallback,
                                       &(HwDeviceExtension->NV_Registry_Table));

    if (status == NO_ERROR)
        {
        return;
        }
        
    else
    
        {
        //**********************************************************************
        // If the registry value entry was NOT present, then
        //   1) Load up our registry structure with default values, then
        //   2) Write the registry structure to the registry.   
        //**********************************************************************

        LoadDefaultRegistrySwitchValues(HwDeviceExtension);
                
        //**********************************************************************
        // Write the registry switches to the registry as one binary chunk (a structure)
        //**********************************************************************

        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"NVREGSWITCHES",
                                       &(HwDeviceExtension->NV_Registry_Table),
                                       sizeof(HwDeviceExtension->NV_Registry_Table));

        return;        
        }

    }
    

//******************************************************************************
//
// Function:    LoadDefaultRegistrySwitchValues
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID LoadDefaultRegistrySwitchValues(
    PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG status;

// STUB OUT FOR NOW SINCE \common\NVREG.H is constantly changing 
// and breaking the NT build.  When NVREG.H settles down, then
// we can put this function back in

//    //**************************************************************************
//    // Default DISPLAY registry switch values        
//    //**************************************************************************
//
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastDisplayDevice[0]),     NV4_REG_DRV_LAST_DEVICE_CRT );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastCRTMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastDFPMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastNTSCMode[0]),          "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.LastPALMode[0]),           "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.CRTMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DFPMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.NTSCMode[0]),              "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.PALMode[0]),               "640,480,8,60"  );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DefaultCRTRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.DefaultDFPRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.OptimalCRTRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.OptimalDFPRefreshRate[0]), "60" );
//    my_strcpy(&(HwDeviceExtension->NV_Registry_Table.Display.MonitorTiming[0]),          NV4_REG_DRV_MONITOR_TIMING_DMT);
//
//    HwDeviceExtension->NV_Registry_Table.Display.DisplayType =                           DISPLAY_TYPE_MONITOR;
//    HwDeviceExtension->NV_Registry_Table.Display.TVType =                                DISPLAY_TYPE_MONITOR;
//    HwDeviceExtension->NV_Registry_Table.Display.CursorAlpha =                           0;
//
//    //**************************************************************************
//    // Default DIRECTDRAW registry switch values        
//    //**************************************************************************
//
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.VPENABLE                    = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayMode                 = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayColorControlEnable   = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayBrightness           = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayContrast             = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayHue                  = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlaySaturation           = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlayGamma                = 0;
//    HwDeviceExtension->NV_Registry_Table.DirectDraw.OverlaySharpness            = 0;
//
//    //**************************************************************************
//    // Default DIRECT3D registry switch values        
//    //**************************************************************************
//
//    HwDeviceExtension->NV_Registry_Table.Direct3D.ANTIALIASENABLE               = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.COLORKEYCOMPATABILITYENABLE   = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.CONTROLTRAFFIC                = 0;             
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DIRECTMAPENABLE               = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.FOGTABLENABLE                 = 0;              
//    HwDeviceExtension->NV_Registry_Table.Direct3D.LOGOENABLE                    = 0;                 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.SCENESYNCENABLE               = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TILINGENABLE                  = 0;                
//    HwDeviceExtension->NV_Registry_Table.Direct3D.USERMIPMAPENABLE              = 0;            
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VIDEOTEXTUREENABLEENABLE      = 0;    
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VSYNCENABLE                   = 0;                 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WENABLE                       = 0;                     
//    HwDeviceExtension->NV_Registry_Table.Direct3D.Z24ENABLE                     = 0;                   
//
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AAMETHOD                      = D3D_REG_AAMETHOD_MIN;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AUTOMIPMAPMETHOD              = D3D_REG_AUTOMIPMAPMETHOD_BILINEAR; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.CKREF                         = D3D_REG_CKREF_MIN;                       
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DX6ENABLE                     = 0;                   
//    HwDeviceExtension->NV_Registry_Table.Direct3D.ANISOTOPIC4TAP                = D3D_REG_MIPMAPDITHERMODE_DISABLE;  
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PAL8TEXTURECONVERT            = D3D_REG_PAL8TEXCONVERT_NONE; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PMTRIGGER                     = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TEXELALIGNMENT                = D3D_REG_TEXELALIGNMENT_ZOH_CENTER;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.VALIDATEZMETHOD               = D3D_REG_VALIDATEZMETHOD_FLEXIBLE;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.W16FORMAT                     = D3D_REG_WFORMAT_FIXED;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.W32FORMAT                     = D3D_REG_WFORMAT_FIXED;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.AGPTEXCUTOFF                  = D3D_REG_DEFAULT_AGPTEXCUTOFF;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.D3DCONTEXTMAX                 = D3D_REG_DEFAULT_D3DCONTEXTMAX; 
//    HwDeviceExtension->NV_Registry_Table.Direct3D.D3DTEXTUREMAX                 = D3D_REG_DEFAULT_D3DTEXTUREMAX;  
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DMAMINPUSHCOUNT               = D3D_REG_DEFAULT_DMAMINPUSHCOUNT;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.LODBIASADJUST                 = D3D_REG_DEFAULT_LODBIASADJUST;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.MINVIDEOTEXSIZE               = D3D_REG_DEFAULT_MINVIDEOTEXSIZE;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.MIPMAPLEVELS                  = D3D_REG_DEFAULT_MIPMAPLEVELS;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.PERFSTRATEGY                  = 0;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.NOVSYNCPREREDNERLIMIT         = D3D_REG_DEFAULT_PRERENDERLIMIT;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.DMAPUSHBUFFERSIZEMAX          = D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.TEXHEAP                       = D3D_REG_DEFAULT_TEXHEAPSIZEMAX;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WSCALE16                      = D3D_REG_DEFAULT_WSCALE16;
//    HwDeviceExtension->NV_Registry_Table.Direct3D.WSCALE24                      = D3D_REG_DEFAULT_WSCALE24;
//
//    //**************************************************************************
//    // Default SYSTEM registry switch values        
//    //**************************************************************************
//                    
//    HwDeviceExtension->NV_Registry_Table.System.Super7Compat                    = 0;    
//    HwDeviceExtension->NV_Registry_Table.System.FlipOnHSync                     = 0;     
//    HwDeviceExtension->NV_Registry_Table.System.FilterOverride                  = 0;  
//    HwDeviceExtension->NV_Registry_Table.System.NoNT4AGP                        = 0;        
//    HwDeviceExtension->NV_Registry_Table.System.George                          = IGNORE_REGISTRY_SWITCH;          
//    HwDeviceExtension->NV_Registry_Table.System.Gracie                          = IGNORE_REGISTRY_SWITCH;          
//    HwDeviceExtension->NV_Registry_Table.System.TVOutOnPrimary                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.Enable256Burst                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.DisableMPCDetect                = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.MemoryOverride                  = IGNORE_REGISTRY_SWITCH;  
//    HwDeviceExtension->NV_Registry_Table.System.RTLOverride                     = IGNORE_REGISTRY_SWITCH;  
//
//    //**************************************************************************
//    // Default NVTWEAK Control Panel registry switch values ?       
//    //**************************************************************************

    }
    
//******************************************************************************
//
// Function:   BuildAvailableModesTable
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID BuildAvailableModesTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {

    U016 i;
    U016 NumGTFModes;    
    U016 GTFWidth,GTFHeight,GTFDepth,GTFRefresh;
    U016 RegWidth,RegHeight,RegDepth,RegRefresh;
    U032 *GTFModePtr;
    U016 *RegDataPtr;
    U016 *ValidModePtr, *BaseOfValidModeTable;
    BOOL FoundRefreshFlag;
    ULONG status;
    PMODE_ENTRY PModePtr;            
    ULONG widthDivide = 1, heightDivide = 1; // For NV11 MultiHead support.
    

    //**************************************************************************
    // The NVx_MODES modetable entries for each chip type will always be stored 
    // in the \device0 key, since the INF doesn't appear to be able to store them
    // in device1,device2, etc...   As a result, we always store and get modetable
    // registry data from the \device0 key for ALL chip types, and then save them
    // off in global mode tables. Essentially, all modetable registry data will
    // only be read when the FIRST nv device is found.   
    //    
    // That is, VideoPortGetRegistryParameters() will SUCCEED when reading the
    // mode table value entries from \device0, but will FAIL when it tries 
    // to read them from \device1\2\3...because the modetable entries won't be present!
    //
    // We use global modedata tables, so that we can copy modetable data
    // into the hwdeviceextension of each device found.
    //
    // The following is a simplified explanation:
    //
    // 1) hkey_local_machine\system\currentcontrolset\services\nv4\device0\
    //      
    //       nv4_modes      -> This value entry contains mode data for nv4
    //       nv5_modes      -> This value entry contains mode data for nv5
    //       nv5m64_modes   -> This value entry contains mode data for nv5m64
    //       nvvanta_modes  -> This value entry contains mode data for nvvanta
    //       etc...
    //
    // 2) When ..\NVx\device0 is found, all the mode data will be read from the
    //    registry into the global mode data tables:
    //
    //       NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       etc....
    //
    // 3) For each device, the mode data for the corresponding chip
    //    type is copied into the ValidModeData in the device's
    //    hwDeviceExtension->ValidModeTable[]
    //  
    //**************************************************************************
                    
    //**************************************************************************
    // Init the global modedata tables with an 0xFFFF terminator.
    // That way, we can tell if the mode registry data was sucessfully copied.
    // (This could happen if the driver was not properly installed, using an
    // INF without mode table data)
    //
    // We ONLY initialize these mode tables the first time the driver is initialized.
    // We can tell by looking at the first entry, which should be 8bpp, width=640,
    // height=480).
    //**************************************************************************

    if ( !( (NV4_registry_data[0] == 8) && (NV4_registry_data[1] == 640) && (NV4_registry_data[2] == 480) && (NV4_registry_data[3] == 60)) )
        {    
        NV4_registry_data[0]        = 0xFFFF ;
        NV5_registry_data[0]        = 0xFFFF ;
        NV0A_registry_data[0]       = 0xFFFF ;
        NVVANTA_registry_data[0]    = 0xFFFF ; 
        NV5M64_registry_data[0]     = 0xFFFF ;
        NV5ULTRA_registry_data[0]   = 0xFFFF ; 
        NV10_registry_data[0]       = 0xFFFF ;
        NV10DDR_registry_data[0]    = 0xFFFF ;
        NV10GL_registry_data[0]     = 0xFFFF ;

        NV11_registry_data[0]       = 0xFFFF ;
        NV11DDR_registry_data[0]    = 0xFFFF ;
        NV11M_registry_data[0]      = 0xFFFF ;
        NV11GL_registry_data[0]     = 0xFFFF ;
        CRUSH11_registry_data[0]    = 0xFFFF ;

        NV15_registry_data[0]       = 0xFFFF ;
        NV15DDR_registry_data[0]    = 0xFFFF ;
        NV15BR_registry_data[0]     = 0xFFFF ;
        NV15GL_registry_data[0]     = 0xFFFF ;

        NV20_registry_data[0]       = 0xFFFF ;
        NV20_1_registry_data[0]     = 0xFFFF ;
        NV20_2_registry_data[0]     = 0xFFFF ;
        NV20_3_registry_data[0]     = 0xFFFF ;

            
        //*********************************************************************
        // Now copy the registry data per each specific chip type
        // and copy it into our mode tables
        //*********************************************************************

        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV4_MODES",         &(NV4_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5_MODES",         &(NV5_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV0A_MODES",        &(NV0A_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NVVANTA_MODES",     &(NVVANTA_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5M64_MODES",      &(NV5M64_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV5ULTRA_MODES",    &(NV5ULTRA_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10_MODES",        &(NV10_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10DDR_MODES",     &(NV10DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV10GL_MODES",      &(NV10GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11_MODES",        &(NV11_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11DDR_MODES",     &(NV11DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11M_MODES",       &(NV11M_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV11GL_MODES",      &(NV11GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"CRUSH11_MODES",     &(CRUSH11_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15_MODES",        &(NV15_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15DDR_MODES",     &(NV15DDR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15BR_MODES",      &(NV15BR_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV15GL_MODES",      &(NV15GL_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_MODES",        &(NV20_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_1_MODES",      &(NV20_1_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_2_MODES",      &(NV20_2_registry_data[0] ));
        NV_ReadAndCopyRegistryData(HwDeviceExtension, L"NV20_3_MODES",      &(NV20_3_registry_data[0] ));



        }
    
    //**************************************************************************
    // 
    // GTFTimingTable Format in vesadata.c (ulong values):
    //
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //  WIDTH, HEIGHT, REFRESH, ....timing values
    //
    // Registry Data Format (word values)
    //
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
    //  etc...    
    //  0,
    //
    // ValidModeTable[]  (2 bytes each data item)
    //
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  TRUE or FALSE, WIDTH, HEIGHT, DEPTH, REFRESH, 
    //  ..
    //  ..
    //   
    //**************************************************************************

    //**************************************************************************
    // This variable is used to keep track of how many modes
    // are initially specified in the REGISTRY.  These modes will 
    // be trimmed down further according to the amount of video memory on the card.
    // The final number of modes available will be stored in 
    //
    //  hwDeviceExtension->NumAvailableModes;
    //
    //**************************************************************************

    HwDeviceExtension->NumRegistryModes=0;

    //**************************************************************************
    // We allow modes according to the following:
    //
    //    1) What modes are actually available in vesadata.c (in the GTFTimingTable)
    //       We use the GTF table because it's a superset of the DMT table,
    //       in terms of the modes which are supported
    //    2) What modes are specified in the registry
    // 
    //**************************************************************************

    NumGTFModes =  (USHORT)vesaGetNumGTFEntries();

    //**************************************************************************
    // Get ptr to valid mode table (which we build here)
    //**************************************************************************

    ValidModePtr            = &(HwDeviceExtension->ValidModeTable[0]);
    BaseOfValidModeTable    = &(HwDeviceExtension->ValidModeTable[0]);

    //**************************************************************************
    // Build the ValidModeTable.  
    //
    // We allow modes which are:
    //
    //      1) Available in the GTFTimingTable    AND 
    //      2) Specified in the registry
    //
    // The GTF table does NOT specify depths.  The registry data DOES specify bit depths.
    // 
    // NOTE: If for some reason, the mode table was NOT initialized
    //       (ie...the mode table was not found in the registry), we'll
    //       default to ALL modes specified in the GTFTimingTable
    //
    //**************************************************************************

    //**************************************************************************
    // Determine which mode table to use
    //**************************************************************************

    switch (HwDeviceExtension->ulChipID)

        {
        case NV4_DEVICE_NV4_ID:

            RegDataPtr = &NV4_registry_data[0];                                    
            break;

        case NV5_DEVICE_NV5_ID:

            RegDataPtr = &NV5_registry_data[0];                                    
            break;

        case NV0A_DEVICE_NV0A_ID:

            RegDataPtr = &NV0A_registry_data[0];                                    
            break;

        case NV5VANTA_DEVICE_NV5VANTA_ID:

            RegDataPtr = &NVVANTA_registry_data[0];                                    
            break;

        case NV5MODEL64_DEVICE_NV5MODEL64_ID:

            RegDataPtr = &NV5M64_registry_data[0];                                    
            break;

        case NV5ULTRA_DEVICE_NV5ULTRA_ID:

            RegDataPtr = &NV5ULTRA_registry_data[0];                                    
            break;

        case NV10_DEVICE_NV10_ID:

            RegDataPtr = &NV10_registry_data[0];                                    
            break;

        case NV10DDR_DEVICE_NV10DDR_ID:

            RegDataPtr = &NV10DDR_registry_data[0];                                    
            break;

        case NV10GL_DEVICE_NV10GL_ID:

            RegDataPtr = &NV10GL_registry_data[0];                                    
            break;

        case NV11_DEVICE_NV11_ID:

            RegDataPtr = &NV11_registry_data[0];                                    
            break;

        case NV11DDR_DEVICE_NV11DDR_ID:

            RegDataPtr = &NV11DDR_registry_data[0];                                    
            break;

        case NV11M_DEVICE_NV11M_ID:

            RegDataPtr = &NV11M_registry_data[0];                                    
            break;

        case NV11GL_DEVICE_NV11GL_ID:

            RegDataPtr = &NV11GL_registry_data[0];                                    
            break;

        case NV11_DEVICE_CRUSH11_ID:

            RegDataPtr = &CRUSH11_registry_data[0];                                    
            break;


        case NV15_DEVICE_NV15_ID:

            RegDataPtr = &NV15_registry_data[0];                                    
            break;

        case NV15DDR_DEVICE_NV15DDR_ID:

            RegDataPtr = &NV15DDR_registry_data[0];                                    
            break;

        case NV15BR_DEVICE_NV15BR_ID:

            RegDataPtr = &NV15BR_registry_data[0];                                    
            break;


        case NV15GL_DEVICE_NV15GL_ID:

            RegDataPtr = &NV15GL_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_ID:

            RegDataPtr = &NV20_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_1_ID:

            RegDataPtr = &NV20_1_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_2_ID:

            RegDataPtr = &NV20_2_registry_data[0];                                    
            break;

        case NV20_DEVICE_NV20_3_ID:

            RegDataPtr = &NV20_3_registry_data[0];                                    
            break;

        default:

            RegDataPtr = &NV4_registry_data[0];                                    
            break;

        }


    //**************************************************************************
    // Parse each line from the registry.
    // For each refresh rate (of each mode), check if the refresh is present in the
    // vesa data table.  If so, then it's a valid mode. 
    // Registry data is terminated with 0xffff
    //**************************************************************************

    while (*RegDataPtr != 0xffff)
        {
        RegDepth   = *(RegDataPtr);             // Get Depth from registry
        RegWidth   = *(RegDataPtr+1);           // Get Width from registry
        RegHeight  = *(RegDataPtr+2);           // Get Height from registry

        //**********************************************************************
        // Advance to the registry refresh rates for this particular mode
        //**********************************************************************

        RegDataPtr+=3;

        //**********************************************************************
        // Each mode entry in the registry data is NULL terminated.
        // Parse all refresh rates for this mode, and see if they're
        // also present in the vesadata GTF timing table
        //**********************************************************************

        while (*RegDataPtr !=0)
            {        
            RegRefresh  = *(RegDataPtr++);      // Get Refresh from registry data

            //******************************************************************
            // Search the vesa GTF table to see if this mode is supported
            //******************************************************************

            i=0;
            GTFModePtr = &(GTFTimingTable[i][0]);
            FoundRefreshFlag = FALSE;              

            while ( (i<NumGTFModes) && (FoundRefreshFlag == FALSE) )
                {                                                       
                //**************************************************************
                // Get width,height,refresh from GTF table
                //**************************************************************

                GTFWidth = (U016)(*(GTFModePtr));           // Get Width from GTF
                GTFHeight = (U016)(*(GTFModePtr+1));        // Get Height from GTF
                GTFRefresh = (U016)(*(GTFModePtr+2));       // Get Refresh*100
                GTFRefresh /= 100;                          // Normalize the value
                                   
                //**************************************************************
                // See if we found a match in the GTF table
                //**************************************************************

                if (MULTIMON_MODE(RegWidth, RegHeight)) 
                    {
                    if (HORIZONTAL_MODE(RegWidth, RegHeight))
                        {
                            widthDivide = 2;
                            heightDivide = 1;
                        }
                    else
                        {
                        if (VERTICAL_MODE(RegWidth, RegHeight))
                            {
                            widthDivide = 1;
                            heightDivide = 2;
                            }
                        }
                    }
                        
                    {
                    //**********************************************************
                    // Generate 8bpp entry for this refresh rate
                    //**********************************************************

                    *ValidModePtr      = TRUE;              // Valid Flag
                    *(ValidModePtr+1)  = RegWidth;          // Width
                    *(ValidModePtr+2)  = RegHeight;         // Height
                    *(ValidModePtr+3)  = RegDepth;          // Depth                                                                 
                    *(ValidModePtr+4)  = RegRefresh;        // Refresh                                                               
                    ValidModePtr +=5;                       // Next Valid Mode

                    //**********************************************************
                    // Keep track of how many modes have currently been specified
                    //**********************************************************

                    HwDeviceExtension->NumRegistryModes++;

                    //**********************************************************
                    // DEBUG safety check
                    // Make sure we never go past the end of the
                    // allocated valid mode table. (back off 30 words from end of table)
                    //**********************************************************

                    if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2) ))
                        {
                        VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                        VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                        }
                
                    FoundRefreshFlag = TRUE;
                    }
                
                //**************************************************************
                // Advance to next GTF entry
                // (12 items per each mode entry in the GTF timing table)
                //**************************************************************

                GTFModePtr += 12;
                i++;


                } // while (i < NumGTFModes)...
                
            } // while (*RegDataPtr !=0)...


        //**********************************************************************
        // Skip past null terminator
        //**********************************************************************

        RegDataPtr++;
                
        } // while (*RegDataPtr != 0xffff)...

    
    // Print the master mode list for debugging purposes.
    {
        MODE_ENTRY *PModeEntry;
        VideoDebugPrint((7,"buildAvailableModes(): Printing Master Mode List: NumRegstryModes: %d\n", HwDeviceExtension->NumRegistryModes));
        RegDataPtr = &HwDeviceExtension->ValidModeTable[0];
    
         
        for (i=0; i < HwDeviceExtension->NumRegistryModes; i++)
        {
            VideoDebugPrint((7,"%d, (%d, %d), %d bpp, %d HZ\n",
                            *(RegDataPtr + 0),
                            *(RegDataPtr + 1),
                            *(RegDataPtr + 2),
                            *(RegDataPtr + 3),
                            *(RegDataPtr + 4)));
           RegDataPtr += 5;
        }
        VideoDebugPrint((7,"End.................\n"));
    }

        // Read in the Monitor restriction mode lists for each head.
        ReadMonitorRestrictionModeList (HwDeviceExtension);
                
    }




//******************************************************************************
//
// Function:   NV_ReadAndCopyRegistryData
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_ReadAndCopyRegistryData(
PHW_DEVICE_EXTENSION HwDeviceExtension,
WCHAR *ModeDataNameStr,
U016 *DstRegDataPtr)

    {
    U016 *SrcRegDataPtr;
    ULONG status;
        
    //**************************************************************************
    // Parse INF and determine which modes to support
    //
    // WARNING:  When reading modetable registry data, the registry callback
    //           routine gets called SEVERAL times for each modetable. That is,
    //           it does NOT get called once for each table as one would expect.
    //           Instead, the registry callback routine gets called for EACH line
    //           appended to the string.  But the CONTEXT ptr does NOT automatically
    //           get incremented.  So we'll have to keep track of it MANUALLY,
    //           so we can continue storing data from where we last left off.
    //           See the registry callback function for more information.
    //**************************************************************************

    HwDeviceExtension->RegistryDataOffset = 0;

    //**************************************************************************
    // The NVx_MODES modetable entries for each chip type will always be stored 
    // in the \device0 key, since the INF doesn't appear to be able to store them
    // in device1,device2, etc...   As a result, we always store and get modetable
    // registry data from the \device0 key for ALL chip types, and then save them
    // off in global mode tables. Essentially, all modetable registry data will
    // only be read when the FIRST nv device is found.   
    //    
    // That is, VideoPortGetRegistryParameters() will SUCCEED when reading the
    // mode table value entries from \device0, but will FAIL when it tries 
    // to read them from \device1\2\3...because the modetable entries won't be present!
    //
    // We use global modedata tables, so that we can copy modetable data
    // into the hwdeviceextension of each device found.
    //
    // The following is a simplified explanation:
    //
    // 1) hkey_local_machine\system\currentcontrolset\services\nv4\device0\
    //      
    //       nv4_modes      -> This value entry contains mode data for nv4
    //       nv5_modes      -> This value entry contains mode data for nv5
    //       nv5m64_modes   -> This value entry contains mode data for nv5m64
    //       nvvanta_modes  -> This value entry contains mode data for nvvanta
    //       etc...
    //
    // 2) When nvx\device0 is found, all the mode data will be read from the
    //    registry into the global mode data tables:
    //
    //       NV4_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV5_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NV0A_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       NVVANTA_registry_data[MAX_STRING_REGISTRY_DATA_WORDS];
    //       etc....
    //
    // 3) For each device, the mode data for the corresponding chip
    //    type is copied into the ValidModeData in the device's
    //    hwDeviceExtension->ValidModeTable[]
    //  
    //**************************************************************************

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       ModeDataNameStr,
                                       FALSE,
                                       NVRegistryCallback,
                                       &registry_data[0]);

    if (status == NO_ERROR)
        {
        //**********************************************************************
        // Terminate the temporary registry data buffer with 0xffff !
        //**********************************************************************

        registry_data[HwDeviceExtension->RegistryDataOffset / 2] = 0xffff;

        //**********************************************************************
        // Now copy the registry data per specific chip type
        //**********************************************************************
        
        SrcRegDataPtr= &(registry_data[0]);
        
        while (*SrcRegDataPtr != 0xffff)
            {
            *DstRegDataPtr = *SrcRegDataPtr;// Copy the data
            
            DstRegDataPtr++;
            SrcRegDataPtr++;            
            }
    
        *DstRegDataPtr = 0xffff;           // Null terminate the list

        }
    else
        {
        //**********************************************************************
        // Error Case (when VideoPortGetRegistryParameters fails because
        // the ValueEntry for the mode data is NOT present)
        //
        // The NVx_MODES keys are only located in the \device0 key.
        // That is, ALL the registry mode data tables are copied when the FIRST
        // device is installed.  When additional instances of the adapter
        // are found, we don't no need to do anything since we've already
        // copied the data.
        //**********************************************************************
        
        }


    }
                                




//******************************************************************************
//
// Function:   BubbleSort
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID BubbleSort(
PHW_DEVICE_EXTENSION HwDeviceExtension,
PMODE_ENTRY BaseModePtr,
ULONG NumModes)

    {

    ULONG i,j;
    PMODE_ENTRY LeftModePtr, RightModePtr;
    MODE_ENTRY TempMode;


    //**************************************************************************
    // Sort by height
    //**************************************************************************

    for (i=0; i < NumModes; i++)
        {
        for (j=NumModes-1; j > i; j--)
            {
            LeftModePtr  = &BaseModePtr[j-1];
            RightModePtr = &BaseModePtr[j];                

            if (LeftModePtr->Height > RightModePtr->Height)
                {
                //**************************************************************
                // Swap mode entries, smaller modes first
                //**************************************************************
                
                TempMode = (*LeftModePtr);
                (*LeftModePtr)  = (*RightModePtr);
                (*RightModePtr) = TempMode;
                
                }

            }
            
        }


    //**************************************************************************
    // Sort by depth
    //**************************************************************************

    for (i=0; i < NumModes; i++)
        {
        for (j=NumModes-1; j > i; j--)
            {
            LeftModePtr  = &BaseModePtr[j-1];
            RightModePtr = &BaseModePtr[j];                

            if (LeftModePtr->Depth > RightModePtr->Depth)
                {
                //**************************************************************
                // Swap mode entries, smaller depths first
                //**************************************************************
                
                TempMode = (*LeftModePtr);
                (*LeftModePtr)  = (*RightModePtr);
                (*RightModePtr) = TempMode;
                
                }

            }
            
        }
        
        
        
    }
    

//******************************************************************************
//
// Function:   NV_OEMEnableExtensions
//
// Routine Description:
//
//    Unlock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    U008 lock;

    //**************************************************************************
    // For NV4, registers are locked using the NV_CIO_SR_LOCK register
    // (That is,the locking mechanism has been moved to CRTC register space,
    // where it should have been in the first place).  We need to
    // use the NV4_REF header file, so this function is locatedin NV4.C
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);


    }


//******************************************************************************
//
// Function:   NV4 OEMDisableExtensions
//
// Routine Description:
//
//    Lock the CRTC registers
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_OEMDisableExtensions(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    U008 lock;

    //**************************************************************************
    // For NV4, registers are locked using the NV_CIO_SR_LOCK register
    // (That is,the locking mechanism has been moved to CRTC register space,
    // where it should have been in the first place).  We need to
    // use the NV4_REF header file, so this function is locatedin NV4.C
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);

    }


//******************************************************************************
//
// Function:   NV4_OEMSetRegs
//
// Routine Description:
//
//       OEMSetRegs - Set extended registers (standard VGA has been set)
//
//       Entry:  ES:DI = Standard VGA parameter pointer
//               DS = Seg0
//       Exit:   None
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_OEMSetRegs(MODEDESC *mi)
{
    U016  wv;                     // Write value{
    U016  i, c;
    U032   lwv;
    U032   lrv;
    U008   cv;

    //*************************************************************************
    // NV4 version of this function is slightly different than
    // the NV3 version. (565 mode and TV stuff)
    //*************************************************************************

    if (mi->mdCMode != 0xFF)        // Do we have a CRTC Override Table?
    {
        // Yep - program it
        WritePriv08(NV_PRMVIO_MISC__WRITE, crt_override[mi->mdCMode].CO_Misc);

        wv = crt_override[mi->mdCMode].CO_ClockMode;
        wv <<= 8;
        wv |= 0x01;
        WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01

        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);    // Read CR11
        wv &= 0x7FFF;               // Unlock CR0-7
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR11

        // Do CR0-CR8 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, 8, (U008 *)&(crt_override[mi->mdCMode].HTotal));

        wv = crt_override[mi->mdCMode].CO_CellHeight;
        wv <<= 8;
        wv |= 0x09;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR09

        // Do CR10-CR12 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x10, 0x03, (U008 *)&(crt_override[mi->mdCMode].CO_VSyncStart));

        // Do CR15-CR16 sequentially
        LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0x15, 0x02, (U008 *)&(crt_override[mi->mdCMode].CO_VBlankStart));
    }

    // Program Extended Registers

    wv = eregs[mi->mdEMode].xrOffset;
    wv <<= 13;
    wv &= 0xE000;                   // Clear start address bits
    wv |= 0x19;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR19

    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    wv &= 0xC0FF;                   // Preserve sync disables
    wv |= 0x3800;                   // Set reserved bits and text mode

    c = (eregs[mi->mdEMode].xrFlags);

    if (c & 0x01)
        wv |= 0x0100;               // Set address wrap

    i = (eregs[mi->mdEMode].xrVOver);
    i &= 0x20;
    i >>= 0x03;
    wv |= (i << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A

    // Default Fifo
    wv = 0x011B;                    // Default CR1B value for VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A

    wv = c;
    wv &= 0x06;
    wv <<= 8;
    wv |= 0x1C;                     // CR1C

    i = (eregs[mi->mdEMode].xrPixFmt);
    i &= 0x30;                      // Mask off chain-4 optimize bits
    i >>= 1;            // (shr 4-3?)

    wv |= (i << 8);                 // Set chain 4 optimize bits
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1A


    wv = 0x001D;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1D

    wv = 0x001E;                    // Clear CR1D & 1E
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Write CR1E

    wv = 0x1020;                    // Fifo Setting for Standar VGA modes
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set low water mark at CR20

    c = (eregs[mi->mdEMode].xrVOver); // Vertical Overflow
    c &= 0x1F;                      // Mask our bits

    i = (eregs[mi->mdEMode].xrOffset);
    i &= 0x08;                      // Bit 3
    i <<= 2;                        // Move to bit 5
    c |= i;
    wv =  (c << 8) | 0x25;          // Write data to CR25
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR25


    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv &= 0xF8FF;                   // Preserve sync disables

    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0x07;                      // Set bits [2:0] - clear rest
    wv |= (c << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR28

    c = eregs[mi->mdEMode].xrPixFmt;
    c &= 0xC0;
    c >>= 6;

    i = eregs[mi->mdEMode].xrVOver;
    i &= 0xC0;
    i >>= 4;
    c |= i;
    wv = ((c << 8) | 0x2D);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);  // Set CR2D

    wv = 0x29;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
    wv = 0x2A;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);


    //**************************************************************************
    // Don't touch CR33 if we're on a flat panel
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

        // Do CR29-32
        for (i = 0x30; i <= 0x32; i++)
            {
            wv = (U016)i;
            WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
            }

        }

    else

        {


        // Do CR29-33
        for (i = 0x30; i <= 0x33; i++)
            {
            wv = (U016)i;
            WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
            }

        }


    wv = (((eregs[mi->mdEMode].xrIntlace) << 8) | 0x39);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

    //**************************************************************************
    // Don't set clock if we're on a flat panel
    //**************************************************************************

    //OEMSetClock(eregs[mi->mdEMode].xrClkSel);
    if (HwDeviceExtension->FlatPanelIsPresent != TRUE)
        OEMSetClock(tblClockFreq[eregs[mi->mdEMode].xrClkSel]);

    wv = (((eregs[mi->mdEMode].xrVOffset) << 8) | 0x13);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

    //**************************************************************************
    // No TV support yet for NV class chips
    //**************************************************************************

//    if (isTV())

    if (HwDeviceExtension->TvIsPresent)

        {
            NV4_ProgramTV( mi->mdTVMode );
        }

#if 0
    //
    // Set VCLK divide by 2 setting
    //
    wv = (eregs[mi->mdEMode].xrPixFmt);
    lwv = (U032)(wv & 0x08);

    lwv <<= (DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO) - 3);

    // Read current coefficient
    //
    // Note that this code preserves the VPLL_BYBASS bit which is nessesary for TV
    lrv = ReadPriv32(NV_PRAMDAC_PLL_COEFF_SELECT);

    // Mask off the bits we'll use.
    //
    // NOTE: Careful: the BIT definitions have CHANGED from NV3 to NV4 !!!!
    //
    lrv &= (U032)(((U032)(1L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO)) |
           ((U032)(1L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE))) |
           ((U032)(7L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE)))) ^ -1L);

    lrv |= lwv;         // Set the VCLK Ratio

    // Now we have to set to programmed VPLL based on XTAL
    //
    // NOTE: Careful: the BIT definitions have CHANGED from NV3 to NV4 !!!!
    //
    lrv |= (U032)(2L << DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE));

    WritePriv32(lrv, NV_PRAMDAC_PLL_COEFF_SELECT);
#endif


    //**************************************************************************
    // If flat panel, we may need to adjust CRTC's
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)

        FlatPanelCrtc(mi->mdXRes);

    else

        WritePriv32(0x10000700, NV_PRAMDAC_PLL_COEFF_SELECT);

    //**************************************************************************
    // If flat panel, leave DAC alone
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent != TRUE)

        {

        lrv = ReadPriv32(NV_PRAMDAC_GENERAL_CONTROL);

        lrv &= (U032)(((1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE)) |
                 (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE)) |
                 (1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC))) ^ -1L);

        lrv |= (U032)(1L << DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE));

        wv = (eregs[mi->mdEMode].xrOffset);
        lwv = (U032)(wv & 0x80);       // Set 565 Mode

        lwv <<= (DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE) - 7L);

        lrv |= lwv;

        cv = (eregs[mi->mdEMode].xrFlags);
        cv ^= (U008)-1;
        cv &= 0x08;                 // Isolate DAC width

        lwv = (U032)(cv);          // Dac Width
        lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_BPC) - 3L);

        lrv |= lwv;

        cv = (eregs[mi->mdEMode].xrPixFmt);
        cv ^= (U008)-1;                   // Invert
        cv &= 0x02;                 // Isolate index/gamma bit

        lwv = (U032)(cv);

        //KJK lwv <<= (U032)(DRF_SHIFT(NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE) - 1L);
        lrv |= lwv;

        WritePriv32(lrv, NV_PRAMDAC_GENERAL_CONTROL);

        // Disable tiling
        lrv = ReadPriv32(NV_PFB_CONFIG_0);
        lrv &= (U032)((1L << DRF_SHIFT(NV_PFB_CONFIG_0_TILING)) ^ -1L);
        lrv |= (NV_PFB_CONFIG_0_TILING_DISABLED << DRF_SHIFT(NV_PFB_CONFIG_0_TILING));

        //**********************************************************************
        // Do NOT touch this register for NV10 !!
        //**********************************************************************

        if ( !((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
               (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
               (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
               (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
               (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
               (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
               (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
               (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
               (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID)))

            {
               WritePriv32(lrv, NV_PFB_CONFIG_0);
            }
            

        }


    WritePriv08(NV_PRMCIO_CRX__COLOR, 0x18);    // Select CR18 (why?)


}



//******************************************************************************
//
// Function:   NV4_ProgramTV
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_ProgramTV(U008 tvmode)

    {
    // TODO:
    }


//******************************************************************************
//
// Function:   NVGetMonitorType
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVGetMonitorType(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG result;
    PHWINFO NVInfo;
    NV_CFGEX_GET_EDID_PARAMS EdidParams;
    ULONG EdidBufferSize;
    
        
    //**************************************************************************
    // Get ptr to NVInfo structure 
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);
    
    //**************************************************************************
    // Ask the RM what's attached to the card (Flat Panel/Monitor/ or TV)
    //**************************************************************************

    HwDeviceExtension->TvIsPresent              = FALSE;
    HwDeviceExtension->FlatPanelIsPresent       = FALSE; 

    //**************************************************************************
    // By default, a standard VGA monitor is attached.
    // Check if either a Flat Panel or TV is attached
    //**************************************************************************

    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_MONITOR_TYPE ,&result) ;

    if (result == MONITOR_TYPE_FLAT_PANEL)
        {
        HwDeviceExtension->FlatPanelIsPresent   = TRUE;

        //**********************************************************************
        // Get max resolution supported by this display type
        //**********************************************************************

        RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_SCREEN_MAX_WIDTH ,&HwDeviceExtension->MaxFlatPanelWidth) ;

        RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_SCREEN_MAX_HEIGHT ,&HwDeviceExtension->MaxFlatPanelHeight) ;

        }

    // GK: HACKHACK: Temporary. Once we verify the EDID info per head, we don't need any of this MaxFlatPanelWidth stuff.
    if (HwDeviceExtension->MaxFlatPanelWidth == 0)
    {
        HwDeviceExtension->MaxFlatPanelWidth = 1024;
    }
    if (HwDeviceExtension->MaxFlatPanelHeight == 0)
    {
        HwDeviceExtension->MaxFlatPanelHeight = 768;
    }


    if ((result == MONITOR_TYPE_NTSC) || (result == MONITOR_TYPE_PAL))
        HwDeviceExtension->TvIsPresent          = TRUE;

    //**************************************************************************
    // This TV code used to work on NV3.. Need to test on NV4 or better...
    //**************************************************************************

   if (HwDeviceExtension->TvIsPresent)                // NO TV support yet !
       {
       // don't diff between NTSC & PAL for now
       NVInfo->Framebuffer.MonitorType = NV_MONITOR_NTSC;

       // Preset the default values
       NVInfo->Framebuffer.Underscan_x = DST_X_RES;
       NVInfo->Framebuffer.Scale_x = X_RES << 20;
       NVInfo->Framebuffer.Scale_x /= NVInfo->Framebuffer.Underscan_x;

       NVInfo->Framebuffer.Underscan_y = DST_Y_RES;
       NVInfo->Framebuffer.Scale_y = Y_RES << 20;
       NVInfo->Framebuffer.Scale_y /= NVInfo->Framebuffer.Underscan_y;

       // No filtering needed for NV5 or better
       NVInfo->Framebuffer.FilterEnable = 0;
       }
    else
       {
       NVInfo->Framebuffer.MonitorType = NV_MONITOR_VGA;

       // If filtering gets enabled for VGA, assume 1:1 scaling
       NVInfo->Framebuffer.Underscan_x = X_RES;
       NVInfo->Framebuffer.Scale_x = (1 << 20);        // default to 1:1

       NVInfo->Framebuffer.Underscan_y = Y_RES;
       NVInfo->Framebuffer.Scale_y = (1 << 20);

       // Assume filtering is disabled
       NVInfo->Framebuffer.FilterEnable = 0;
       }



    }

//******************************************************************************
//
// Function:   NV_FixLowWaterMark
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV_FixLowWaterMark(U016 clock)

    {
    U016  wv;
    U032   lwv;
    U016  i;
    U032  clockMHz;

    wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    wv >>= 8;
    wv &= 0x03;       // mask pixel format bits

    // Check dac format
    if (wv)
        {
        wv--;
        clockMHz = clock;
        clockMHz <<= (U008)wv;
        clockMHz /= 100;

        for (i = 0; clockMHz > DACFifoTable[i].Freq ; i++)
            ;   // Find the proper FIFO value
        
        if  ( (HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
              (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
              (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
              (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
              (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
              (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
              (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
              (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
              (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        
            {
            // for NV10, bit 4 is the 128-bit bit.
            lwv = ReadPriv32(NV_PFB_CFG) & 0x00000010L;
            }
        else
            {
            // Bit 2 is the 128-bit bit.
            lwv = ReadPriv32(NV_PFB_BOOT_0) & 0x00000004L;
            }

        if (lwv)
            {
            // 128 bit
            // Do WV first, as I get's blown away
            wv = ((DACFifoTable[i].LowWaterMark128) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize128) << 8) | 0x1B;

            }
        else
            {
            // 64 bit
            wv = ((DACFifoTable[i].LowWaterMark64) << 8) | 0x20;
            i  = ((DACFifoTable[i].BurstSize64) << 8) | 0x1B;
            }

        WriteIndexed(NV_PRMCIO_CRX__COLOR, i);
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);
        }
    }





//******************************************************************************
//
// Function:   NV_OEMGetMemSize
//
// Routine Description:
//
//
//       OEMGetMemSize - Return the pre-calculated memory size
//
//       Entry:  None
//       Exit:   AX = Number of 64K blocks
//
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

U016 NV_OEMGetMemSize(VOID)
{
    U032 msize;
    U016 ms;


    if  ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
         (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
         (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
         (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
         (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
         (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
         (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
         (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
         (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
    {
        ms = (U016)(PFB_REG_RD32(PFB_Base,NV_PFB_CSTATUS) >> 16);
    }
    else
    {
        //*************************************************************************
        // NV4 version of this function is slightly different than
        // the NV3 version. (We want to use #DEFINES from NV4_REF for NV4,
        // and #DEFINES from NV3_REF for NV3)
        //*************************************************************************

        msize = ReadPriv32(NV_PFB_BOOT_0) & 0x00000003;
        ms = (U016)msize;

        if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_4MB)
            ms = 64;            // 4MB
        else if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_8MB)
            ms = 128;           // 8MB
        else if (ms == NV_PFB_BOOT_0_RAM_AMOUNT_16MB)
            ms = 256;           // 16MB
        else
            ms = 512;           // 32Mb

        //**************************************************************************
        // Check for UMA usage
        //
        // Note that this is only valid for NV0A, but the other NV4 variants hardwire these
        // bit fields to zero.
        //**************************************************************************

        if (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA) == NV_PFB_BOOT_0_UMA_ENABLE)
        {
            switch (PFB_REG_RD_DRF(PFB_Base,_PFB, _BOOT_0, _UMA_SIZE))
            {
                case NV_PFB_BOOT_0_UMA_SIZE_2M:
                    ms = 2 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_4M:
                    ms = 4 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_6M:
                    ms = 6 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_8M:
                    ms = 8 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_10M:
                    ms = 10 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_12M:
                    ms = 12 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_14M:
                    ms = 14 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_16M:
                    ms = 16 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_18M:
                    ms = 18 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_20M:
                    ms = 20 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_22M:
                    ms = 22 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_24M:
                    ms = 24 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_26M:
                    ms = 26 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_28M:
                    ms = 28 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_30M:
                    ms = 30 << 4;
                    break;
                case NV_PFB_BOOT_0_UMA_SIZE_32M:
                    ms = 32 << 4;
                    break;
            }
        }
    }

    return ms;

}




//******************************************************************************
//
// Function:   NV4_dacCalculateArbitration
//
// Routine Description:
//
//      Calculate the closest arbitration values for a given system configuration
//
//      NOTE: Please excuse this code.  In comes from the hardware group...
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4_dacCalculateArbitration
(
           nv4_fifo_info *fifo,
           nv4_sim_state  *arb
)
{
  int data, m,n,p, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
  int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
  int found, mclk_extra, mclk_loop, cbs, m1, p1;
  int xtal_freq, mclk_freq, pclk_freq, nvclk_freq, mp_enable;
  int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
  int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
  int craw, vraw;
  fifo->valid = 1;
  pclk_freq = arb->pclk_khz; // freq in KHz
  mclk_freq = arb->mclk_khz;
  nvclk_freq = arb->nvclk_khz;
  pagemiss = arb->mem_page_miss;
  cas = arb->mem_latency;
  width = arb->memory_width >> 6;
  video_enable = arb->enable_video;
  color_key_enable = arb->gr_during_vid;
  bpp = arb->pix_bpp;
  align = arb->mem_aligned;
  mp_enable = arb->enable_mp;
  clwm = 0;
  vlwm = 0;
  cbs = 128;
  pclks = 2; // lwm detect.

  nvclks = 2; // lwm -> sync.
  nvclks += 2; // fbi bus cycles (1 req + 1 busy)
  nvclks += 1; // fbi reqsync

  mclks = 5; // Fifo
  mclks += 3; // MA0 -> MA2
  mclks += 1; // pad->out
  mclks += cas; // Cas Latency.
  mclks += 1; // pad in
  mclks += 1; // latch data
  mclks += 1; // fifo load
  mclks += 1; // fifo write
  mclk_extra = 3; // Margin of error

  nvclks += 2; // fifo sync
  nvclks += 1; // read data
  nvclks += 1; // fbi_rdata
  nvclks += 1; // crtfifo load

  if(mp_enable)
    mclks+=4; // Mp can get in with a burst of 8.
  // Extra clocks determined by heuristics

  nvclks += 0;
  pclks += 0;
  found = 0;
  while(found != 1) {
    fifo->valid = 1;
    found = 1;
    mclk_loop = mclks+mclk_extra;
    us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
    us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
    us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
    if(video_enable) {
      video_drain_rate = pclk_freq * 2; // MB/s
      crtc_drain_rate = pclk_freq * bpp/8; // MB/s

      vpagemiss = 2; // self generating page miss
      vpagemiss += 1; // One higher priority before

      crtpagemiss = 2; // self generating page miss

      vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;
      else
    video_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;

      us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

      vlwm = us_video * video_drain_rate/(1000*1000);
      vlwm++; // fixed point <= float_point - 1.  Fixes that
      vbs = 128;

      if(vlwm > 128) vbs = 64;
      if(vlwm > (256-64)) vbs = 32;

      if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
    video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
      else
    video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =
    us_video  // Wait for video
    +video_fill_us // Wait for video to fill up
    +cpm_us // CRT Page miss
    +us_m + us_n +us_p // other latency
    ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    } else {
      crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

      crtpagemiss = 2; // self generating page miss
      crtpagemiss += 1; // MA0 page miss
      cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
      us_crt =  cpm_us + us_m + us_n + us_p ;
      clwm = us_crt * crtc_drain_rate/(1000*1000);
      clwm++; // fixed point <= float_point - 1.  Fixes that
    }
    /*
      Overfill check:

      */

    m1 = clwm + cbs - 512; /* Amount of overfill */
    p1 = m1 * pclk_freq / mclk_freq; /* pclk cycles to drain */
    p1 = p1 * bpp / 8; // bytes drained.

    if((p1 < m1) && (m1 > 0)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
    }
    else if(video_enable){
      if((clwm > 511) || (vlwm > 255)) {
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    } else {
      if(clwm > 519){ // Have some margin
    fifo->valid = 0;
    found = 0;
    if(mclk_extra ==0)   found = 1; // Can't adjust anymore!
    mclk_extra--;
      }
    }
    craw = clwm;
    vraw = vlwm;
    if(clwm < 384) clwm = 384;
    if(vlwm < 128) vlwm = 128;
    data = (int)(clwm);
    //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
    fifo->graphics_lwm = data;   fifo->graphics_burst_size = 128;
    //    fifo->craw = craw;

    data = (int)((vlwm+15));
    //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
    fifo->video_lwm = data;  fifo->video_burst_size = vbs;
  }
}



//******************************************************************************
//
// Function:   NV4_UpdateArbitrationSettings
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV4_UpdateArbitrationSettings
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{

    nv4_fifo_info fifo_data;
    nv4_sim_state sim_data;
    U008 i, lock;
    U032 M, N, O, P , crystal , NVClk, VClk;

    //
    // Determine current strap crystal frequency (in Hz)
    //
    if (PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K)
        crystal = 13500000;
    else if (PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV, _BOOT_0, _STRAP_CRYSTAL) == NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180)
        crystal = 14318180;



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _MPLL_COEFF, _PDIV);
    O = 1;

    HwDeviceExtension->NvInfo.Dac.MPllM = M;
    HwDeviceExtension->NvInfo.Dac.MPllN = N;
    HwDeviceExtension->NvInfo.Dac.MPllO = O;
    HwDeviceExtension->NvInfo.Dac.MPllP = P;
    if ( (!P) && (HwDeviceExtension->ulChipID == NV4_DEVICE_NV4_ID))
        P = 1;      // never really zero
    HwDeviceExtension->NvInfo.Dac.MClk  = (N * crystal / (1 << P) / M);



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base, _PRAMDAC, _VPLL_COEFF, _PDIV);
    O = 1;

    HwDeviceExtension->NvInfo.Dac.VPllM = M;
    HwDeviceExtension->NvInfo.Dac.VPllN = N;
    HwDeviceExtension->NvInfo.Dac.VPllO = O;
    HwDeviceExtension->NvInfo.Dac.VPllP = P;
    VClk = HwDeviceExtension->NvInfo.Dac.VClk  = (N * crystal / (1 << P) / M);



    M = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _MDIV);
    N = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _NDIV);
    P = PRAMDAC_REG_RD_DRF(PRAMDAC_Base,_PRAMDAC, _NVPLL_COEFF, _PDIV);
    O = 1;

    NVClk  = (N * crystal / (1 << P) / M);

    //
    // Last minute kludge to work around bug in NV4 arbitration
    // algorithm.
    //

    if (((HwDeviceExtension->NvInfo.Framebuffer.Depth < 16) && (VClk > 180000000)) ||
        ((HwDeviceExtension->NvInfo.Framebuffer.Depth == 16) && (VClk > 130000000)) ||
        ((HwDeviceExtension->NvInfo.Framebuffer.Depth > 16) && (VClk > 80000000)))
       HwDeviceExtension->bHwVidOvl = FALSE;
    else
        {
        //
        // Build the sim table as if hw video overlay was enabled
        //
        sim_data.pix_bpp        = (UCHAR)HwDeviceExtension->NvInfo.Framebuffer.Depth;
        sim_data.enable_video   = 1;
        sim_data.enable_mp      = 0;
        sim_data.memory_width   = HwDeviceExtension->NvInfo.Dac.InputWidth;;
        sim_data.mem_latency    = 3;
        sim_data.mem_aligned    = 1;
        sim_data.mem_page_miss  = 10;
        sim_data.gr_during_vid  = 0;
        sim_data.pclk_khz       = HwDeviceExtension->NvInfo.Dac.VClk / 1000;    // in kHz, not MHz
        sim_data.mclk_khz       = HwDeviceExtension->NvInfo.Dac.MClk / 1000;    // in kHz, not MHz
        sim_data.nvclk_khz      = NVClk / 1000;                                 // in kHz, not MHz

        //
        // Get those new numbers
        //
        NV4_dacCalculateArbitration(&fifo_data, &sim_data);
        HwDeviceExtension->bHwVidOvl = (fifo_data.valid != 0);
        }

    //
    // Build the sim table using current system settings
    //
    sim_data.pix_bpp        = (UCHAR)HwDeviceExtension->NvInfo.Framebuffer.Depth;
    sim_data.enable_video   = 0;
    sim_data.enable_mp      = 0;
    sim_data.memory_width   = HwDeviceExtension->NvInfo.Dac.InputWidth;;
    sim_data.mem_latency    = (char)PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _CAS_LATENCY); // 3
    sim_data.mem_aligned    = 1;
    sim_data.mem_page_miss  = (char)(PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _RAS_RAS)  +  PFB_REG_RD_DRF(PFB_Base,_PFB, _CONFIG_1, _READ_TO_PCHG)); // 10
    sim_data.gr_during_vid  = 0;
    sim_data.pclk_khz       = HwDeviceExtension->NvInfo.Dac.VClk / 1000;    // in kHz, not MHz
    sim_data.mclk_khz       = HwDeviceExtension->NvInfo.Dac.MClk / 1000;    // in kHz, not MHz
    sim_data.nvclk_khz      = NVClk / 1000;                                 // in kHz, not MHz


    //
    // Get those new numbers
    //
    NV4_dacCalculateArbitration(&fifo_data, &sim_data);

    //
    // If valid settings found, update the hardware
    //
    if (fifo_data.valid)
    {
        //
        // Set the DAC FIFO Thresholds and burst size
        //
        PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_THRES, fifo_data.video_lwm >> 1);
        switch (fifo_data.video_burst_size)
        {
            case 128:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 3);
                break;

            case 64:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 2);
                break;

            case 32:
                PVIDEO_REG_WR32(PVIDEO_Base, NV_PVIDEO_FIFO_BURST, 1);
                break;
        }


        //
        // Update the CRTC watermarks
        //
        // Unlock CRTC extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);

        //
        // Set the CRTC watermarks and burst size
        //
        CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, fifo_data.graphics_lwm >> 3);

        switch (fifo_data.graphics_burst_size)
        {
            case 256:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 4);
                break;

            case 128:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 3);
                break;

            case 64:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 2);
                break;

            case 32:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 1);
                break;

            case 16:
                CRTC_WR(NV_CIO_CRE_FF_INDEX, 0);
                break;
        }

        //
        // Relock if necessary
        //
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE);

        return;
    }
    else
        //
        // No valid setting was found!!!  Either we fail this configuration
        // or we live with the current default settings for this mode.
        //
        return;

}


//******************************************************************************
//
// Function:    NVEnableBusMastering()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVEnableBusMastering(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;

    //**************************************************************************
    // Make sure bus mastering is always ENABLED !!  (Bit 2)
    // Read current value then enable the bus_master bit.
    //**************************************************************************

    CurrentValue = REG_RD32(NV_PBUS_PCI_NV_1);
    CurrentValue |= (1 << DRF_SHIFT(NV_PBUS_PCI_NV_1_BUS_MASTER));
    REG_WR32(NV_PBUS_PCI_NV_1,  CurrentValue);

    }

//******************************************************************************
//
// Function:    NVSaveSpecificRegistersForPwrMgmt()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;

    //**************************************************************************
    // This code was copied from ..\nvalloc\win9x\vxd\osapi.c 
    // for the case NVRM_API_POWER_DOWN:
    //**************************************************************************

    //**************************************************************************
    // Save off instance memory, mainly because the Win9x DX7 driver
    // allocates DMA contexts, but doesn't free them up. (One time init)
    // If we lose power , then all instance memory associated with those
    // DMA contexts are gone.  So we need to save instance mem here before we power down.
    //**************************************************************************
    NV4SaveInstanceMemory(HwDeviceExtension);

    //**************************************************************************
    // Save off miscellaneous registers not reloaded by RmLoadState
    //**************************************************************************

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        {
        NV10ChipFBPowerSave(HwDeviceExtension);
        }
                
    else

        {
        NV4ChipFBPowerSave(HwDeviceExtension);
        }

    }


//******************************************************************************
//
// Function:    NVRestoreSpecificRegistersForPwrMgmt()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG CurrentValue;


    //**************************************************************************
    // Restore chip dependent FB power registers
    //**************************************************************************

    if ((HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)       ||
        (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)       ||
        (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)     ||
        (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)    ||
        (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)       ||
        (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID) ||
        (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)   ||
        (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)   ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)       ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)     ||
        (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID))
        {
        NV10ChipFBPowerRestore(HwDeviceExtension);
        }

    else
                    
        {
        NV4ChipFBPowerRestore(HwDeviceExtension);
        }


    //**************************************************************************
    // Save off instance memory, mainly because Win9x DX7 driver
    // allocates DMA contexts, but doesn't free them up.
    // If we lose power , then all instance memory associated with those
    // DMA contexts are gone.  So we need to save them here before we power down.
    //**************************************************************************
    NV4RestoreInstanceMemory(HwDeviceExtension);

    }


//******************************************************************************
//
// Function:    NV4ChipFBPowerSave()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4ChipFBPowerSave (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    // power down mode - max out memory refresh value
    HwDeviceExtension->Power_refresh = REG_RD32(NV_PFB_DEBUG_0);               // refresh
    FLD_WR_DRF_NUM(_PFB, _DEBUG_0, _REFRESH_COUNTX64, 0x01);       // max refresh
    // Chip has been init'd with the BIOS init tables, unless the BIOS
    // has an incompatible structure and the table was not found, in which case
    // we used a default table, which may not have the correct RAM config, so
    // we save away the current config for restoration above.
    HwDeviceExtension->Power_PfbBoot0     = REG_RD32(NV_PFB_BOOT_0);               // RAM config
    HwDeviceExtension->Power_PfbConfig0   = REG_RD32(NV_PFB_CONFIG_0);           // RAM config
    HwDeviceExtension->Power_PfbConfig1   = REG_RD32(NV_PFB_CONFIG_1);           // RAM config
    HwDeviceExtension->Power_PextdevBoot0 = REG_RD32(NV_PEXTDEV_BOOT_0);       // READ STRAP REG
    HwDeviceExtension->Power_PfifoRamHT   = REG_RD32(NV_PFIFO_RAMHT);
    HwDeviceExtension->Power_PfifoRamRO   = REG_RD32(NV_PFIFO_RAMRO);
    HwDeviceExtension->Power_PfifoRamFC   = REG_RD32(NV_PFIFO_RAMFC);
    }
    
 
//******************************************************************************
//
// Function:    NV4ChipFBPowerRestore()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4ChipFBPowerRestore (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    // power up mode - restore previous refresh value
    U032 D0_DELAY_RETRIES = 10; 
    U032 retry = 0;             
    U032 i;                     

    REG_WR32(NV_PFB_DEBUG_0, HwDeviceExtension->Power_refresh);          // refresh
    REG_WR32(NV_PFB_BOOT_0,  HwDeviceExtension->Power_PfbBoot0);         // RAM config
    REG_WR32(NV_PFB_CONFIG_0, HwDeviceExtension->Power_PfbConfig0);      // RAM config
    REG_WR32(NV_PFB_CONFIG_1, HwDeviceExtension->Power_PfbConfig1);      // RAM config

//  A delay seems to be necessary for i820 on Win9x.
//  The problem hasn't been demonstrated on W2K, but its here for safety
//  Reading NV_PMC_ENABLE is simply a convenient delay    
    while (REG_RD32(NV_PEXTDEV_BOOT_0) != HwDeviceExtension->Power_PextdevBoot0) 
    {
        for (i=0; i<2000; i++) 
        {
            REG_RD32(NV_PMC_ENABLE);
        }
        REG_WR32(NV_PEXTDEV_BOOT_0, HwDeviceExtension->Power_PextdevBoot0);    // WRITE STRAP REG
        retry++;
        if (retry == D0_DELAY_RETRIES) 
            break;
    }

    REG_WR32(NV_PFIFO_RAMHT, HwDeviceExtension->Power_PfifoRamHT);      
    REG_WR32(NV_PFIFO_RAMRO, HwDeviceExtension->Power_PfifoRamRO);      
    REG_WR32(NV_PFIFO_RAMFC, HwDeviceExtension->Power_PfifoRamFC);      

    // Touching the CONFIG_0 register messes up the VGA text screen.
    // Unfortunately, SetMode doesn't occur for a while, so this garbage text screen
    // may linger for a while,  so we'll blank the screen to hide it.
    // (SetMode will turn it back on)
    
    REG_RD32(NV_PRMCIO_INP0__COLOR);  // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);    // Turn off screen at AR
    REG_RD32(NV_PRMCIO_INP0__COLOR);  // Reset ATC FlipFlop
    }
    

//******************************************************************************
//
// Function:    NV4SaveInstanceMemory()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4SaveInstanceMemory(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 *fb_sv;
    U032 i;
                
    fb_sv = (U032 *)&(HwDeviceExtension->SavedInstanceMemory[0]);
    
    for(i=0; i < ((HwDeviceExtension->TotalInstanceMemory)/4); i++)
         *fb_sv++ = REG_RD32(NV_PRAMIN_DATA032(i));   // from the top--64k BIOS + instance memory
                                                      // this actually decrements from the top
    }

//******************************************************************************
//
// Function:    NV4RestoreInstanceMemory()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV4RestoreInstanceMemory(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 *fb_sv;
    U032 data;
    U032 i;
                    
    fb_sv = (U032 *)&(HwDeviceExtension->SavedInstanceMemory[0]);
    
    for(i=0; i < ((HwDeviceExtension->TotalInstanceMemory)/4); i++)
       {
       data = *fb_sv++;
       REG_WR32(NV_PRAMIN_DATA032(i), data);
       }            

    }


//******************************************************************************
//
// Function:    NVEnableVGASubsystem()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVEnableVGASubsystem(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {


    //**************************************************************************
    // Make sure VGA IO subsystem is alive !!!
    //**************************************************************************

    REG_WR08(NV_PRMVIO_VSE2,  1);


    }

//******************************************************************************
//
// Function:    NVClearMutexPmeAudBuff0()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVClearMutexPmeAudBuff0(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    // Do nothing, this function is only used by NV3
    }


//******************************************************************************
//
// Function:    NVExtractBiosImage()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NVExtractBiosImage(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    UCHAR *buffer;
    UCHAR char1,char2;
    U032 CurrentValue;
    U032 i;
    
    //**************************************************************************
    // Get ptr to buffer where we'll store the bios image
    //**************************************************************************

    buffer = (UCHAR *)(&(HwDeviceExtension->SavedBiosImageArray[0]));

    char1 = REG_RD08(DEVICE_BASE(NV_PROM) + 0);
    char2 = REG_RD08(DEVICE_BASE(NV_PROM) + 1);

    //**************************************************************************
    // First attempt to get the BIOS image from PROM
    // (Look for the 55,AA signature)
    //**************************************************************************
    
    if ((char1 == 0x55) && (char2 == 0xAA))
    {
        //**********************************************************************
        // Read BIOS image via PROM
        //**********************************************************************
        for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
        {
            buffer[i] = REG_RD08(DEVICE_BASE(NV_PROM) + i);
        }
    }
    else
    {
#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN64)
        UCHAR *pVideoRomData;
        pVideoRomData = VideoPortGetRomImage(HwDeviceExtension, NULL, 0, SAVED_BIOS_IMAGE_SIZE);

        if(pVideoRomData != NULL)
        {
            char1 = pVideoRomData[0];
            char2 = pVideoRomData[1];
        }

        if ((char1 == 0x55) && (char2 == 0xAA))
        {
            for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
            {
                buffer[i] = pVideoRomData[i];
            }
        }
        else
#endif // WINN32_WINNT >= 0x0500 NT5 only
        {
            //**********************************************************************
            // Otherwise, get BIOS image from PRAMIN
            //**********************************************************************

            for (i = 0; i < SAVED_BIOS_IMAGE_SIZE; i++)
            {
                buffer[i] = REG_RD08(DEVICE_BASE(NV_PRAMIN) + i);
            }
        }
    }            
}

//******************************************************************************
//
// Function:    FlatPanelCrtc
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

// some CRTC bit definitions
// CR07
#define VT08    1
#define VT09    0x20
#define VRS08   0x04
#define VRS09   0x80
#define EXT_VRS 0x84
#define VDE08   0x02
#define VDE09   0x40
#define VBS08   0x08
// CR09
#define VBS09   0x20
// CR25
#define VT10    0x01
#define VDE10   0x02
#define VRS10   0x04
#define VBS10   0x08

VOID FlatPanelCrtc( U016 XRes )
{
U032    DacHcrtc, DacHt, Ht, Hrs, Hre, DacVcrtc, DacVt, Vt, Vrs, Vre, Vbs, data32;
U016    Attr, Seq;
U008    Cr07, Cr09, Cr11, Cr25;

    // Make sure to always default to centered mode for now
    // Read the current control register value, and force it to be centered
    
    data32 = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_FP_TG_CONTROL);

    // Clear out all the bits

    data32 &= (~ ((DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _NATIVE )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _HORIZ )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _VERT  )) |
                  (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _BOTH  ))   ));

    // Force it to be centered (automatic centering)
    data32 |= (DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER ));
    
    PRAMDAC_REG_WR32(PRAMDAC_Base, NV_PRAMDAC_FP_TG_CONTROL,data32);


    // check for pixel doubled modes
    if (XRes < 640)
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }

    // Make sure attr is set correctly
    Cr07 = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    Ht = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x00)>>8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)((Ht-3)<<8 | 0x04));   // HRS
    Hre = ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05)>>8) & 0xe0);    // read CR05 and mask 4:0
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(((Ht-2) | Hre)<<8 | 0x05));   // HRE = Ht - 2, CR04[4:0]

    // gather VT bits
    Vt = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x06)>>8);
    Cr07 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07)>>8);
    Cr25 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25)>>8);
    if (Cr07 & VT08)
        Vt |= 0x0100;
    if (Cr07 & VT09)
        Vt |= 0x0200;
    if (Cr25 & VT10)
        Vt |= 0x0400;

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vrs<<8 | 0x10));
    Cr07 &= ~EXT_VRS;
    if (Vrs & 0x100) Cr07 |= VRS08;
    if (Vrs & 0x200) Cr07 |= VRS09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    if (Vrs & 0x400) Cr25 |= VRS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));

    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    Cr11 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11)>>8);
    Vre |= (Cr11 & 0xf0);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vre<<8 | 0x11));

    // VBS = VRS
    Cr09 = (U008)(ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09)>>8);
    Vbs = Vrs;

    // write VBS
    Cr07 &= ~VBS08;
    if (Vbs & 0x100) Cr07 |= VBS08;
    Cr09 &= ~VBS09;
    if (Vbs & 0x200) Cr09 |= VBS09;
    Cr25 &= ~VBS10;
    if (Vbs & 0x400) Cr25 |= VBS10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Vbs<<8 | 0x15));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr07<<8 | 0x07));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr09<<8 | 0x09));
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(Cr25<<8 | 0x25));

    // wait for vsync

    while (PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
    while (!(PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start

    data32 = PRAMDAC_REG_RD32(PRAMDAC_Base,NV_PRAMDAC_FP_DEBUG_0);           // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    PRAMDAC_REG_WR32(PRAMDAC_Base,NV_PRAMDAC_FP_DEBUG_0, data32);
}




//******************************************************************************
//
// Function:    Disable Interrupt
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_DisableNVInterrupts
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    ULONG CurrentValue;

    //**************************************************************************
    // Make sure that we're not currently in an interrupt routine first
    // If interrupts are disabled, then someone is currently handling
    // the interrupts.  Wait for Interrupts to get re-activated.
    //**************************************************************************

    CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);
    while (CurrentValue == 0)
        CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);

    //**************************************************************************
    // Save off current value of PMC_INTR_EN_0
    //**************************************************************************

    CurrentValue = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);

    HwDeviceExtension->SavedPMCState = CurrentValue;

    //**************************************************************************
    // Disable NV Interrupts
    //**************************************************************************

    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, 0x00000000);
}


//******************************************************************************
//
// Function:    Re-Enable Interrupt
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ReEnableNVInterrupts
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, HwDeviceExtension->SavedPMCState);

}


//******************************************************************************
//
// Function:    ManualTextModeSet
//
// Routine Description:
//
//              This code was ported from the BIOS
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ManualTextModeSet
(
    PHW_DEVICE_EXTENSION HwDeviceExtension
)
{
    U008 byteValue;
    U032 dwordValue;
    U008 savedCrtcIndex;
    U008 savedLockValue;
    U008 initialLockValue;
            
    //**************************************************************************
    // Unlock extended registers
    //**************************************************************************
                    
    savedCrtcIndex = REG_RD08(NV_PRMCIO_CRX__COLOR); // 3d4

    CRTC_RD(NV_CIO_SR_LOCK_INDEX , savedLockValue);  // 1f lock index
    initialLockValue = savedLockValue;
    savedLockValue &=1;

    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    byteValue &=0xfe;
    byteValue |=savedLockValue;
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    
    CRTC_WR(NV_CIO_SR_LOCK_INDEX , NV_CIO_SR_UNLOCK_RW_VALUE ); // 0x57 unlock value

    //**************************************************************************
    // OEMPreSetMode
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent)      // Flat panel is present
        {
        CRTC_WR(0x21, 0xba);
        }
    else if (HwDeviceExtension->TvIsPresent)        // TV is present
        {
        ;       // Do nothing
        }
    else
        {
        CRTC_WR(0x21, 0xfa);                        // CRT present
        }
                             
    //**************************************************************************
    // ATCOFF
    //**************************************************************************

// cli
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
    REG_WR08(NV_PRMCIO_ARX, 0);                     // 3c0
// sti

    //**************************************************************************
    // OEMPreSetRegs
    //**************************************************************************
    
    CRTC_RD(0x28, byteValue);                       // 3d4
    byteValue &=0xf8;
    CRTC_WR(0x28, byteValue);
    
    CRTC_RD(0x1a, byteValue);                       // 3d4
    byteValue |=2;
    CRTC_WR(0x1a, byteValue);

    //**************************************************************************
    // SetRegs
    //**************************************************************************
    
    REG_WR08(NV_PRMVIO_SRX, 0);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 1);                // 3c5
    
    REG_WR08(NV_PRMVIO_MISC__WRITE , 0x67);         // 3c2
                               

    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 0);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 2);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 3);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 3);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 0);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 4);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 2);                // 3c5

    REG_WR08(NV_PRMVIO_SRX, 0);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET, 3);                // 3c5

    //**************************************************************************
    // CRTC Regs
    //**************************************************************************

    CRTC_WR(0x11, 0x20);                            // 3d4
    CRTC_WR(0x00, 0x5f);
    CRTC_WR(0x01, 0x4f);
    CRTC_WR(0x02, 0x50);
    CRTC_WR(0x03, 0x82);
    CRTC_WR(0x04, 0x55);
    CRTC_WR(0x05, 0x81);
    CRTC_WR(0x06, 0xbf);
    CRTC_WR(0x07, 0x1f);
    CRTC_WR(0x08, 0x00);
    CRTC_WR(0x09, 0x4f);
    CRTC_WR(0x0a, 0x0d);
    CRTC_WR(0x0b, 0x0e);
    CRTC_WR(0x0c, 0x00);
    CRTC_WR(0x0d, 0x00);
    CRTC_WR(0x0e, 0x00);
    CRTC_WR(0x0f, 0x00);
    CRTC_WR(0x10, 0x9c);
    CRTC_WR(0x11, 0x8e);
    CRTC_WR(0x12, 0x8f);
    CRTC_WR(0x13, 0x28);
    CRTC_WR(0x14, 0x1f);
    CRTC_WR(0x15, 0x96);
    CRTC_WR(0x16, 0xb9);
    CRTC_WR(0x17, 0xa3);
    CRTC_WR(0x18, 0xff);

    //**************************************************************************
    // GDC Regs
    //**************************************************************************

    REG_WR08(NV_PRMVIO_GRX,   0x0);                 // 3ce
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x1);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x2);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x3);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x4);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x5);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x10);            

    REG_WR08(NV_PRMVIO_GRX,   0x6);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0e);            

    REG_WR08(NV_PRMVIO_GRX,   0x7);            
    REG_WR08(NV_PRMVIO_GX_SR, 0x0);            

    REG_WR08(NV_PRMVIO_GRX,   0x8);            
    REG_WR08(NV_PRMVIO_GX_SR, 0xff);            

    //**************************************************************************
    // Full Cpu ON
    //**************************************************************************
    
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
    byteValue |=0x20;
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET,byteValue  );       // 3c5

    //**************************************************************************
    // OEMSetRegs
    //**************************************************************************

    CRTC_WR(0x19, 0x0);

    CRTC_RD(0x1a,byteValue);
    byteValue &=0xc0;
    byteValue |=0x38;
    byteValue |=1;
    byteValue |=4;
    CRTC_WR(0x1a, byteValue);

    CRTC_WR(0x1b, 0x3);
    CRTC_WR(0x1c, 0x18);
    CRTC_WR(0x1d, 0x0);
    CRTC_WR(0x1e, 0x0);

    CRTC_WR(0x20, 0x20);
    CRTC_WR(0x25, 0x0);

    CRTC_RD(0x28,byteValue);
    byteValue &=0xf8;
    CRTC_WR(0x28, byteValue);


    CRTC_WR(0x2d, 0x0);
    CRTC_WR(0x29, 0x0);
    CRTC_WR(0x2a, 0x0);
    CRTC_WR(0x30, 0x0);
    CRTC_WR(0x31, 0x0);
    CRTC_WR(0x32, 0x0);

    CRTC_RD(0x33,byteValue);
    byteValue &= 0x7f;
    CRTC_WR(0x33, byteValue);

    CRTC_WR(0x39, 0xff);


    dwordValue = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
    dwordValue &=0xeffffdfe;
    if (HwDeviceExtension->FlatPanelIsPresent)      // Flat panel is present
        dwordValue |= 0x00000200;
    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT,dwordValue);

    dwordValue = REG_RD32(NV_PRAMDAC_GENERAL_CONTROL);
    dwordValue &= 0xffefeeef;
    dwordValue |= 0x00000100;
    dwordValue |= 0x00000010;
    REG_WR32(NV_PRAMDAC_GENERAL_CONTROL,dwordValue);

    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x18);                    

    //**************************************************************************
    // Skip Load Palette and LoadSysfont
    //**************************************************************************

    //**************************************************************************
    // Skip OemFixupSetMode/ FPEndSetMode for now    (Flat panel only)
    //**************************************************************************

//    FPEndSetMode();

    //**************************************************************************
    // SetDPMSOff
    // Turn off DPMS on CRT only
    //**************************************************************************

    if ((!(HwDeviceExtension->FlatPanelIsPresent)) &&   // Flat panel not present
        (!(HwDeviceExtension->TvIsPresent)) )           // TV not present
        {    
        CRTC_RD(0x1a, byteValue);
        byteValue&=0x3f;
        CRTC_WR(0x1a, byteValue);

        //**********************************************************************
        // Full CPU Off
        //**********************************************************************
    
        REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
        byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
        byteValue &=0xdf;
        REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
        REG_WR08(NV_PRMVIO_SR_RESET,byteValue);         // 3c5
    
        //**********************************************************************
        // ATCON
        //**********************************************************************
// cli    
        byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
        byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
        REG_WR08(NV_PRMCIO_ARX, 0x20);                  // 3c0
        byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
        byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
// sti
        }
            
    //**************************************************************************
    // Full CPU Off
    //**************************************************************************

    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    byteValue = REG_RD08(NV_PRMVIO_SR_RESET);       // 3c5
    byteValue &=0xdf;
    REG_WR08(NV_PRMVIO_SRX, 1);                     // 3c4
    REG_WR08(NV_PRMVIO_SR_RESET,byteValue);         // 3c5

    //**************************************************************************
    // ATCON
    //**************************************************************************

//cli
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
    REG_WR08(NV_PRMCIO_ARX, 0x20);                  // 3c0
    byteValue = REG_RD08(NV_PRMCIO_INP0__MONO);     // 3ba
    byteValue = REG_RD08(NV_PRMCIO_INP0__COLOR);    // 3da
//sti

    //**************************************************************************
    // Skip OEMPostSetMode  (TV only)
    //**************************************************************************

    //**************************************************************************
    // Restore / Lock extended registers if necessary
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c
    byteValue &=0xfe;                                // remove bit 0
    CRTC_WR(NV_CIO_CRE_SCRATCH1__INDEX , byteValue); // scratch index 2c

    if (initialLockValue == 0)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);
        }
    else if (initialLockValue == 1)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RO_VALUE);
        }
    else if (initialLockValue == 3)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);
        }

    //**************************************************************************
    // Restore the original CRTC index register
    //**************************************************************************

    REG_WR08(NV_PRMCIO_CRX__COLOR, savedCrtcIndex); // 3d4

    }



#if (_WIN32_WINNT >= 0x0500)

//******************************************************************************
//
// Function:    NV_VBE_DPMS_GetPowerState()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

BOOLEAN NV_VBE_DPMS_GetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG *CurrentPowerState)

    {
    UCHAR lock;
    UCHAR cr1a;
    UCHAR result;

    //**************************************************************************
    // Save off original lock value, then unlock extended registers
    //**************************************************************************

    CRTC_RD(NV_CIO_SR_LOCK_INDEX,lock);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);

    //**************************************************************************
    // Read CR1A
    //
    //   Bit 7 Hsync Toggle disable.  When set to a 1, this bit forces the Hsync to
    //            inactive state (high or low as programmed in the bit-6 of the
    //            Miscellaneous output register).
    //
    //   Bit 6 Vsync Toggle disable.  When set to a 1, this bit forces the Vsync to
    //            inactive state (high or low as programmed in the bit-7 of the
    //            Miscellaneous output register).
    //
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, cr1a);

    //**************************************************************************
    // Isolate DPMS bits (CR1A bits 7 & 6)
    //**************************************************************************

    cr1a >>=14;
    *CurrentPowerState = tblDPMSStates[cr1a];

    //**************************************************************************
    // Relock the extended registers, if necessary
    //**************************************************************************

    //**************************************************************************
    // Relock the extended registers, if necessary
    //**************************************************************************

    if (lock == 0)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_LOCK_VALUE);
        }
    else if (lock == 1)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RO_VALUE);
        }
    else if (lock == 3)
        {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX,NV_CIO_SR_UNLOCK_RW_VALUE);
        }


    return(TRUE);
    }


//******************************************************************************
//
// Function:    NV_VBE_DPMS_SetPowerState()
//
// Routine Description:
//
//       VBE Function 10h
//       VBE_DPMS - Display Power Management Signaling functions (DPMS).
//
//       Entry:  AX = 4F10h
//               BL = Subfunction
//               ES:DI = Null pointer
//               DS = Seg0
//
//               Other registers dependent on subfunction
//               Subfunction 0:
//                       None
//               Subfunction 1:
//                       BH = Requested power state
//                            0 = On
//                            1 = Stand by
//                            2 = Suspend
//                            4 = Off
//                            8 = Reduced on
//               Subfunction 2:
//                       None
//
//       Exit:   AX = VBE return status
//               Other registers dependent on subfunction:
//               Subfunction 0:
//                       BH = States supported:
//                            bit 0      Stand by
//                            bit 1      Suspend
//                            bit 2      Off
//                            bit 3      Reduced on
//                            bits 4-7   Reserved
//                       BL = VBE/PM Version number:
//                            bits 0-3   Minor version number (0)
//                            bits 4-7   Major version number (1)
//               Subfunction 1:
//                       None
//               Subfunction 2:
//                       BH = Power state currently requested by controller
//                            0 = On
//                            1 = Stand by
//                            2 = Suspend
//                            4 = Off
//                            8 = Reduced on
//
//       The VESA committee defined a method of signalling a monitor
//       to shutdown or to go into standby mode. The sync signals are
//       used in the following manner:
//
//       H Sync  V Sync  Result
//       ======  ======  ======
//       Pulses  Pulses  Monitor is active
//       None    Pulses  Monitor is in "stand-by" mode
//       Pulses  None    Monitor is in "suspend" mode
//       None    None    Monitor is in "shut down" mode
//
//       Note: ES, DS, SI have been pushed on the stack already
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
BOOLEAN NV_VBE_DPMS_SetPowerState(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PowerState)
{
    BOOLEAN bRet = 0;
    ULONG i;

    for(i = 0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
    {
        
        switch (PowerState)
        {

            case VideoPowerOn:
            case VideoPowerHibernate:
                bRet |= 
                    RmSetDisplayPowerState
                    (
                        HwDeviceExtension->DeviceReference,
                        HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i],
                        TRUE
                    );
                HwDeviceExtension->ulRmTurnedOffMonitor = FALSE;
                break;

            case VideoPowerStandBy:
                    //RmSetDisplayPowerState...
                    break;

            case VideoPowerSuspend:
                    //RmSetDisplayPowerState...
                    break;

            case VideoPowerOff:
                bRet |= 
                    RmSetDisplayPowerState
                    (
                        HwDeviceExtension->DeviceReference,
                        HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i],
                        FALSE
                    );
                HwDeviceExtension->ulRmTurnedOffMonitor = TRUE;
                break;
        }
    }    

    return(bRet);

}

//******************************************************************************
//
// Function:    GetCurrentDPMSState(HwDeviceExtension)
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

U032 GetCurrentDPMSState(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    U032 Value;
    
    
    Value = hwDeviceExtension->CurrentDPMSState;
    return(Value);
    }


//******************************************************************************
//
// Function:    NV_ATCOff()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ATCOff(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    NV_ResetATCFlipFlop(HwDeviceExtension);        // Reset ATC to index state

    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x0);

    }


//******************************************************************************
//
// Function:    NV_ATCOn()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ATCOn(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    NV_ResetATCFlipFlop(HwDeviceExtension);    // Reset ATC to index state

    PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_ARX, 0x20);

    NV_ResetATCFlipFlop(HwDeviceExtension);    // For compatibility with DOS EDIT

    }


//******************************************************************************
//
// Function:    NV_ResetATCFlipFlop()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV_ResetATCFlipFlop(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    volatile U008 value;

    value = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__COLOR);
    value = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_INP0__MONO);

    }


#endif // WINN32_WINNT >= 0x0500 NT5 only



//******************************************************************************
//
//  Function: NVGetTimingForDac()
//
//  Routine Description:
//
//      This routine get timing values for dac at giving mode.
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//
//  Return Value:
//      TRUE - successful; FALSE - failed
//
//******************************************************************************
BOOL NVGetTimingForDac(PHW_DEVICE_EXTENSION hwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo)
{
    GetTimingDacCommonModesetCode(hwDeviceExtension, pResolution, pTimingInfo);
    return (TRUE);
}

//
// Read in the monitor restriction mode list per head from the registry.
//
VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    U016 *ValidModePtr;
    U016 *RegDataPtr;
    ULONG NumRegistryModes;
    U016  *BaseOfValidModeTable;
    ULONG i;
    U016 RegWidth,RegHeight,RegDepth,RegRefresh;
    
    // init the Monitor restriction mode tables.
    MonitorRestrictionModeList0_registry_data[0]     = 0xFFFF ;
    MonitorRestrictionModeList1_registry_data[0]     = 0xFFFF ;
    HwDeviceExtension->NumRestrictionModes0 = 0;
    HwDeviceExtension->NumRestrictionModes1 = 0;
    // copy the monitor restriction modelists for both heads.
    NV_ReadAndCopyRegistryData(HwDeviceExtension, L"MonitorModeList0",      &(MonitorRestrictionModeList0_registry_data[0] ));
    NV_ReadAndCopyRegistryData(HwDeviceExtension, L"MonitorModeList1",      &(MonitorRestrictionModeList1_registry_data[0] ));

    for (i=0; i < NV_NO_DACS; i++)
    {
        RegDataPtr = (i ? (U016 *)&MonitorRestrictionModeList1_registry_data[0] : (U016 *)&MonitorRestrictionModeList0_registry_data[0]);
        ValidModePtr = (i ? (U016 *)&HwDeviceExtension->RestrictionModeTable1[0] : (U016 *)&HwDeviceExtension->RestrictionModeTable0[0]);
        BaseOfValidModeTable = ValidModePtr;
        NumRegistryModes = 0;
    
        //**************************************************************************
        // Parse each line from the registry.
        // For each refresh rate (of each mode), check if the refresh is present in the
        // vesa data table.  If so, then it's a valid mode. 
        // Registry data is terminated with 0xffff
        //**************************************************************************

        while (*RegDataPtr != 0xffff)
            {
            RegDepth   = *(RegDataPtr);             // Get Depth from registry
            RegWidth   = *(RegDataPtr+1);           // Get Width from registry
            RegHeight  = *(RegDataPtr+2);           // Get Height from registry

            //**********************************************************************
            // Advance to the registry refresh rates for this particular mode
            //**********************************************************************

            RegDataPtr+=3;

            //**********************************************************************
            // Each mode entry in the registry data is NULL terminated.
            // Parse all refresh rates for this mode
            //**********************************************************************

            while (*RegDataPtr !=0)
            {        
                RegRefresh  = *(RegDataPtr++);      // Get Refresh from registry data

                //**********************************************************
                // Generate 8bpp entry for this refresh rate
                //**********************************************************

                *ValidModePtr      = TRUE;              // Valid Flag
                *(ValidModePtr+1)  = RegWidth;          // Width
                *(ValidModePtr+2)  = RegHeight;         // Height
                *(ValidModePtr+3)  = RegDepth;          // Depth                                                                 
                *(ValidModePtr+4)  = RegRefresh;        // Refresh                                                               
                ValidModePtr +=5;                       // Next Valid Mode

                //**********************************************************
                // Keep track of how many modes have currently been specified
                //**********************************************************

                NumRegistryModes++;

                //**********************************************************
                // DEBUG safety check
                // Make sure we never go past the end of the
                // allocated valid mode table. (back off 30 words from end of table)
                //**********************************************************

                if (ValidModePtr > (U016 *)((PUCHAR)BaseOfValidModeTable + (MAX_VALID_MODE_TABLE_DATA_WORDS * 2) - (30*2) ))
                {
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: Went past end of ValidModeTable !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR   !!!\n"));
                    VideoDebugPrint((0, "!!! ERROR:                                 !!!\n"));
                }
            } // while (*RegDataPtr !=0)...

            //**********************************************************************
            // Skip past null terminator
            //**********************************************************************

            RegDataPtr++;
                
        } // while (*RegDataPtr != 0xffff)...

        //
        // Save the number of restriction modes for each head
        //
        if (i == 0) 
        {
            HwDeviceExtension->NumRestrictionModes0 = NumRegistryModes;
        }
        else
        {
            HwDeviceExtension->NumRestrictionModes1 = NumRegistryModes;
        }
    } // for each head
}

#if (_WIN32_WINNT >= 0x0500)
//
// Gets called while shutting down.
// Disables interrupts as they are left on by the ResMan to make full screen DOS VGA mode
// work correctly.
//
BOOLEAN
NVResetHW(
    PVOID hwDeviceExtension,
    ULONG Column,
    ULONG Rows
    )
{
    PHW_DEVICE_EXTENSION HwDeviceExtension;
    HwDeviceExtension = (PHW_DEVICE_EXTENSION)hwDeviceExtension;

    // Disable the interrupts.
    PMC_REG_WR32(PMC_Base, NV_PMC_INTR_EN_0, 0x00000000);

    // Since we are not setting the VGA mode, return FALSE so that the HAL can do the
    // equivalent of Int10, mode 3.
    return(FALSE);
}
#endif (_WIN32_WINNT >= 0x0500)


//
// DetectDevice is called from DetectNextDevice and checks whether in psnSlot is a nvidia device and if so it will claim
//              it's resources (if bClaimResources is TRUE). It also checks whether the device is a primary VGA device.
//  NOTE :      This is the place to add new board IDs (and it should remain the only place in the miniport)
//

VP_STATUS DetectDevice(PHW_DEVICE_EXTENSION   pHDE,                             // our devices 'global' data struct
                        PCI_SLOT_NUMBER       psnSlot,                          // the slot to check
                        ULONG                 ulNumAccessRanges,                // is needed the to claim the resources, for now it's always 2
                        PVIDEO_ACCESS_RANGE   pAccessRanges,                    // if bClaimResources == TRUE this exports the device's mapping
                        USHORT                *pusVendorID,
                        USHORT                *pusDeviceID,
                        BOOLEAN               *pbIsPrimaryDevice,
                        BOOLEAN               bClaimResources)
{
    VP_STATUS         status = ERROR_DEV_NOT_EXIST;
    PCI_COMMON_CONFIG pcc;
    ULONG             ulBytes;
    ULONG             ulVendorID;
    ULONG             ulDeviceID;
    PVOID             pvVendorID;
    PVOID             pvDeviceID;
    ULONG             ulSlot;
#if (_WIN32_WINNT >= 0x0500)
    ULONG             VgaStatus;
#endif

    ASSERT(pHDE);
    ASSERT(ulNumAccessRanges);
    ASSERT(pAccessRanges);
    ASSERT(pusVendorID);
    ASSERT(pusDeviceID);
    ASSERT(pbIsPrimaryDevice);

    VideoPortZeroMemory(&pcc, sizeof(PCI_COMMON_CONFIG));

    ulBytes = VideoPortGetBusData(pHDE, 
                                    PCIConfiguration,
                                    psnSlot.u.AsULONG,             // assuming that function = 0 , W2K ignores this 
                                    &pcc,
                                    0,
                                    PCI_COMMON_HDR_LENGTH);

    if (PCI_COMMON_HDR_LENGTH == ulBytes)
    {
        if (NV4_VENDOR_ID == pcc.VendorID) // most trivial check
        {
            //
            // list of boards supported now
            //
            switch (pcc.DeviceID)
            {
            case NV20_DEVICE_NV20_ID:
            case NV20_DEVICE_NV20_1_ID:
            case NV20_DEVICE_NV20_2_ID:
            case NV20_DEVICE_NV20_3_ID:
                ulNumAccessRanges++;            // NV20 needs one more access ranges
            case NV4_DEVICE_NV4_ID:
            case NV5_DEVICE_NV5_ID:
            case NV5ULTRA_DEVICE_NV5ULTRA_ID:
            case NV5VANTA_DEVICE_NV5VANTA_ID:
            case NV5MODEL64_DEVICE_NV5MODEL64_ID:
            case NV0A_DEVICE_NV0A_ID:
            case NV10_DEVICE_NV10_ID:
            case NV10DDR_DEVICE_NV10DDR_ID:
            case NV10GL_DEVICE_NV10GL_ID:
            case NV11_DEVICE_NV11_ID:
            case NV11DDR_DEVICE_NV11DDR_ID:
            case NV11M_DEVICE_NV11M_ID:
            case NV11GL_DEVICE_NV11GL_ID:
            case NV11_DEVICE_CRUSH11_ID:
            case NV15_DEVICE_NV15_ID:
            case NV15DDR_DEVICE_NV15DDR_ID:
            case NV15BR_DEVICE_NV15BR_ID:
            case NV15GL_DEVICE_NV15GL_ID:
                *pusVendorID = pcc.VendorID;
                *pusDeviceID = pcc.DeviceID;

#if (_WIN32_WINNT >= 0x0500)
                //
                // On IA64 it isn't save to rely on PCI_ENABLE_IO_SPACE to detect the
                // primary device. Since Win2K it is possible to query the VGA status:
                //
                if (NO_ERROR == VideoPortGetVgaStatus(pHDE, &VgaStatus))
                {
                    // VgaStatus (0) indicates that VGA is not enabled -> secondary device
                    // VgaStatus (1) indicates that VGA is enabled -> primary device
                    *pbIsPrimaryDevice = (1 == VgaStatus); 
                }
                else
#endif
                {
                    //
                    //  if the PCI io space is enabled we are on the primary VGA device
                    //
                    *pbIsPrimaryDevice = pcc.Command & PCI_ENABLE_IO_SPACE ? TRUE : FALSE;
                }

                //
                // if were not the primary device well have to enable MMIO and BUS MASTER
                //
                if (! *pbIsPrimaryDevice)
                {
                    //
                    // if NT4_MULTI_DEV is not defined, behave like original driver did -> don't recognize disabled board
                    //
#if (defined (NT4_MULTI_DEV) || (_WIN32_WINNT >= 0x0500))
                    // just prepare common config that VPGetAccessRanges can read the physical aperture
                    pcc.Command |=  PCI_ENABLE_MEMORY_SPACE | PCI_ENABLE_BUS_MASTER;

                    ulBytes = VideoPortSetBusData(pHDE, 
                                                PCIConfiguration,
                                                psnSlot.u.AsULONG,             
                                                &pcc.Command,
                                                offsetof(PCI_COMMON_CONFIG, Command),
                                                sizeof(ULONG));
                    if (sizeof(ULONG) != ulBytes)
#endif
                    {
                        status = ERROR_DEV_NOT_EXIST;
                        goto EXIT;
                    }
                }

#if (_WIN32_WINNT < 0x0500)
                ulSlot      = psnSlot.u.AsULONG;                // start looking at this slot
                ulVendorID  = (ULONG)(pcc.VendorID) & 0xffff;
                ulDeviceID  = (ULONG)(pcc.DeviceID) & 0xffff;
                pvVendorID  = (PVOID)&ulVendorID;
                pvDeviceID  = (PVOID)&ulDeviceID;
#else
                // W2K automatically uses the right slot, so all slot information is useless or invalid here
                ulSlot      = 0;                                // has to be 0 on W2K and above
                pvVendorID  = NULL;
                pvDeviceID  = NULL;
#endif
                //
                // VideoPortGetAccessRanges fills pAccessRanges (and pvVendor/DeviceID which obviously should match the ones we
                //                          found using VideoPortGetBusData 8-) )
                //
                if (bClaimResources)
                {
                    status = VideoPortGetAccessRanges(pHDE, 
                                                      0,
                                                      NULL,
                                                      ulNumAccessRanges,
                                                      pAccessRanges,
                                                      pvVendorID,
                                                      pvDeviceID, 
                                                      &ulSlot);
                    if (NO_ERROR == status)
                    {
                        //
                        // check data consistency for NT 4 only as in W2K ulSlot is alwas 0 
                        //
#if (_WIN32_WINNT < 0x0500) 
                        if (ulSlot != psnSlot.u.AsULONG ||
                          (USHORT)ulVendorID != *pusVendorID ||
                          (USHORT)ulDeviceID != *pusDeviceID)
                        {
                            //
                            // the last VideoPortGetAccessRanges has claimed resources but obviously
                            // for the wrong slot, so we unclaim everything with NumAccessRanges = 0
                            //
                            status = VideoPortGetAccessRanges(pHDE, 
                                                              0,
                                                              NULL,
                                                              0,
                                                              pAccessRanges,
                                                              pvVendorID,
                                                              pvDeviceID, 
                                                              &ulSlot);
                            ASSERT(NO_ERROR == status);
                            status = ERROR_DEV_NOT_EXIST;
                            goto EXIT;
                        }
#endif

                        //
                        // for some reason VideoPortGetAccessRanges enables PortIO in our command register
                        // so we have to reset this for non primary devices
                        //
                        if (! *pbIsPrimaryDevice)
                        {
                            ulBytes = VideoPortGetBusData(pHDE, 
                                                            PCIConfiguration,
                                                            psnSlot.u.AsULONG,             // assuming that function = 0
                                                            &pcc,
                                                            0,
                                                            PCI_COMMON_HDR_LENGTH);
                            if (ulBytes == PCI_COMMON_HDR_LENGTH)
                            {
                                // just prepare common config that VPGetAccessRanges can read the physical aperture
                                pcc.Command &=  ~PCI_ENABLE_IO_SPACE;

                                ulBytes = VideoPortSetBusData(pHDE, 
                                                            PCIConfiguration,
                                                            psnSlot.u.AsULONG,             // assuming that function = 0
                                                            &pcc,
                                                            0,
                                                            PCI_COMMON_HDR_LENGTH);
                                ASSERT(ulBytes == PCI_COMMON_HDR_LENGTH);
                            }
                        }
                    }
                }
                else
                {
                    status = NO_ERROR;
                }
                break;

                // no need for default branch
            }
        }
    }
EXIT:
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv4\ddc.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     DDC.C
//
// Abstract:
//
//     This is code specific to NV4
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"

// MP/RM merge
#include "nvos.h"
#include "rm.h"

extern VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

extern ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);


//******************************************************************************
// DDC support is only available for NT5 or later
//******************************************************************************


#if (_WIN32_WINNT >= 0x0500)


//******************************************************************************
// Forward Function Declarations
//******************************************************************************

VOID    WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
VOID    WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData);
BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID    WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension);
ULONG GetCurrentScanLine(PHW_DEVICE_EXTENSION);

BOOLEAN
GetDdcInformation (
    PHW_DEVICE_EXTENSION phwDeviceExtension,
    ULONG  ulDisplayIndex,
    PUCHAR QueryBuffer,
    ULONG  BufferSize
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetDdcInformation)
#endif

//******************************************************************************
//
//  Register Description:
//
//
//        6.24 CR3E DDC Status Register                 0x3X5 Index 3E (R-)
//      
//      #define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
//      
//         Bit 3    SDA pin.  This is the current value of the SDA pin.
//         Bit 2    SCL pin.  This is the current value of the SCL pin.
//      
//      
//        6.23 CR3F DDC Write Register                   0x3X5 Index 3F (RW)
//      #define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
//      
//         Bits 7-6 Reserved
//      
//         Bits 5   Write SCL pin. If 1, this will tri-state the SCL bus.  This will allow
//      	    the value of the SCL pin to reach a 1 since the SCL pin is connected
//      	    to a external pull-up.  A 0 will enable the SCL pin and force
//      	    a 0 onto the SCL signal.
//      
//         Bits 4   Write SDA pin. If 1, this will tri-state the SDA bus.  This will allow
//      	    the value of the SDA pin to reach a 1 since the SDA pin is connected
//      	    to a external pull-up.  A 0 will enable the SDA pin and force
//      	    a 0 onto the SDA signal.
//      
//         Bits 3-2   Reserved. 
//      
//         Bit  1   DDC Write release.  When a 0 is written, it will release the SCL pin
//      	    and allow it to float high.  When a 1 is written, it will latch the 
//      	    SDA value at the next falling edge of SCL and hold the SCL pin low
//      	    until a 0 is written.
//      
//         Bit  0   DDC enable pin.  Enables writes onto the DDC pins.  
//      	    1 indicates writes are enabled. 
//      
//         This register defaults to 0x30 after reset.
//         
//         The DDC is really a I2C interface.  This interface is designed to allow easy
//         software controllability.  
//      
//      None.
//
//******************************************************************************


//******************************************************************************
//
//  Function:   WriteClockLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************


VOID WriteClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)

    {
    UCHAR ucPortData;

    //**************************************************************************
    // Read current value then update
    //**************************************************************************
        
    CRTC_RD(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);

    if (ucData)
        ucPortData |= 0x20;
    else        
        ucPortData &= (~0x20);  

    //**************************************************************************
    // Set new value
    //**************************************************************************

    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);   

    }

//******************************************************************************
//
//  Function:   WriteDataLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID WriteDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension, UCHAR ucData)

    {
    UCHAR ucPortData;

    //**************************************************************************
    // Read current value then update
    //**************************************************************************
        
    CRTC_RD(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);

    if (ucData)
        ucPortData |= 0x10;
    else        
        ucPortData &= (~0x10);  

    //**************************************************************************
    // Set new value
    //**************************************************************************

    CRTC_WR(NV_CIO_CRE_DDC_WR__INDEX, ucPortData);   

    }

//******************************************************************************
//
//  Function:   ReadClockLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN ReadClockLine(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    UCHAR ucPortData;
    
    //**************************************************************************
    //  Bit 2    SCL pin (current value of the SCL pin)
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX , ucPortData);

    return((BOOLEAN)(ucPortData&4) >> 2);
    }


//******************************************************************************
//
//  Function:   ReadDataLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN ReadDataLine(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    UCHAR ucPortData;
    
    //**************************************************************************
    //  Bit 3    SDA pin (current value of the SCL pin)
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_DDC_STATUS__INDEX , ucPortData);

    return((BOOLEAN)(ucPortData&8) >> 3);
    }

//******************************************************************************
//
//  Function:   WaitForVsyncActive
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID WaitForVsyncActive(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    //**************************************************************************
    // Wait while in vblank
    //**************************************************************************

    while (GetCurrentScanLine(HwDeviceExtension) ==0);

    //**************************************************************************
    // Wait while display is active
    //**************************************************************************

    while (GetCurrentScanLine(HwDeviceExtension) !=0);

    //**************************************************************************
    // Now we're in vblank
    //**************************************************************************

    }


//******************************************************************************
//
//  Function: GetCurrentScanLine
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

ULONG GetCurrentScanLine(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    ULONG   LoByte, HiByte;
    ULONG   Value;
    
    //**************************************************************************
    // Get current scanline by reading both registers
    //**************************************************************************

    CRTC_RD(NV_CIO_CRE_RL1__INDEX , HiByte);
    HiByte <<=8;
    
    CRTC_RD(NV_CIO_CRE_RL0__INDEX , LoByte);
    LoByte &=0xff;
        
    Value = ( (HiByte << 8) | (LoByte&0xff) );
    Value &= 0x7FF;
        
    if (Value == 0)
        {
        //**********************************************************************
        // Double check to fix hw bug. (for NV3)
        //**********************************************************************

        CRTC_RD(NV_CIO_CRE_RL1__INDEX , HiByte);
        HiByte <<=8;
    
        CRTC_RD(NV_CIO_CRE_RL0__INDEX , LoByte);
        LoByte &=0xff;
        
        Value = ( (HiByte << 8) | (LoByte&0xff) );
        Value &= 0x7FF;
        }


    return(Value);
    }


//******************************************************************************
//
//  Function:   GetDdcInformation
//
//  Routine Description:
//
//      Reads the basic EDID structure from the monitor using DDC2.
//
//  Arguments:
//
//      HwDeviceExtension - Points to per-adapter device extension.
//  
//      ulDisplayIndex    - Logical Display index (GDI level)
//
//      QueryBuffer       - Buffer where information will be stored.
//  
//      BufferSize        - Size of the buffer to fill.
//
//  Return Value:
//
//      Whether the call succeeded or not.
//
//******************************************************************************


BOOLEAN
GetDdcInformation(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG  ulDisplayIndex,
    PUCHAR QueryBuffer,
    ULONG  BufferSize)

    {
    ULONG ulHead, i;
    ULONG ulPrimaryHead;
    NV_DESKTOP_INFO * pDeskTop;
    ULONG ulDeviceMask = 0;
    LPEDID_UNIT pEdidUnit;
    PUCHAR      pEDIDBuffer;

    pDeskTop = &HwDeviceExtension->DeskTopInfo;

    // BUGBUG
    // We take a different code path for Dualview. We want expose two monitors, no matter what.
    // The problem of single view is that it depends on HwDeviceExtension->DeskTopInfo to determine
    // which monitor to expose.  But at this moment, HwDeviceExtension->DeskTopInfo is not initialized yet.
    // And even worse, it's subject to change on switching to different heads.
    // In future, this code should be revisited.  We should always expose all monitors to GDI.
    // Non-Dualview code path shall be removed
    if (HwDeviceExtension->pDualViewAssociatedDE)
    {
        ULONG ulConnectedDeviceMask = pDeskTop->ulConnectedDeviceMask;
        // If on LCD/CRT/TV all exist, pick CLD and CRT
        if ((ulConnectedDeviceMask & BITMASK_ALL_CRT) &&
            (ulConnectedDeviceMask & BITMASK_ALL_TV) &&
            (ulConnectedDeviceMask & BITMASK_ALL_DFP))
            ulConnectedDeviceMask &= ~BITMASK_ALL_TV;

        for (i = 0; i <= ulDisplayIndex; i++)
        {
            ulDeviceMask = LOWESTBIT(ulConnectedDeviceMask);
            ulConnectedDeviceMask &= ~ulDeviceMask;
        }
    }
    else
    {
        // This function will be called only for the case of a board with a single head.
        // So we reference the EDID info of the Head 0.
        ulHead = 0;

        //
        // Enable this code once Terry finishes the control panel work of automoatically disabling the system EDID for
        // spanning modes.
        //
        // Extract the primary head. For standard/clone/span modes, we will let the OS manage the properties
        // (refresh rate, color depth, EDID flag) of the primary head.
        // Note: Dependency: The control panel needs to automatically disable the OS EDID if the user wants to switch
        // to spanning mode, otherwise the 'faked' doubled modes will be disallowed by the OS.

        // NOTE to keep in mind: This routine gets called before any mode set has happened. So encure that the right
        // device mask is being used.

        ulPrimaryHead = pDeskTop->ulDeviceDisplay[ulDisplayIndex];
        ulDeviceMask = pDeskTop->ulDeviceMask[ulPrimaryHead];
    }

    // We are overloading the term ulHead here, so clean up later by removing the variable ulHead
    // and use only the term ulEDIDIndex;
    ulHead = ConvertDeviceMaskToIndex(ulDeviceMask); 

    pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulHead];
    pEDIDBuffer = pEdidUnit->EDIDBuffer;

    //**************************************************************************
    // If a flat panel was connected, then just return the EDID buffer
    // (which was obtained in the RM). Do the same for a CRT also.
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
    {

        //**********************************************************************
        // Win2k (as of build 2195) does NOT seem to understand version 2.0 EDIDs.
        // Returning a version 2.0 EDID will cause Win2k to come up in VGA.
        // So for now, if we detect version 2.0, then just return FAILURE, and
        // don't bother returning the EDID.  (Fixes Gateway FPD1500 flat panel)
        //**********************************************************************

    	if (! ((pEDIDBuffer[0] == 0)    && 
               (pEDIDBuffer[1] == 0xFF) && 
               (pEDIDBuffer[7] == 0)) )
            return(FALSE);
    }

    //
    // Return failure if this is a non-DDC device. The whole EDID structure would have been zeroed out in this case.
    // Let us check a few random fields to verify.
    // (18)    EDID Version Number
    // (19)    Revision number
    //
    if (pEDIDBuffer[0] == 0    && 
        pEDIDBuffer[1] == 0    && 
        pEDIDBuffer[7] == 0    && 
        pEDIDBuffer[18] == 0   && 
        pEDIDBuffer[19] == 0)
    {
        VideoDebugPrint((0,"This is a non-DDC monitor. So not returning any EDID\n"));     
        return(FALSE);
    }

    if (!pEdidUnit->Valid)
    {
        VideoDebugPrint((0,"This is a non-DDC monitor. So not returning any EDID\n"));     
        return(FALSE);
    }
    

    //**********************************************************************
    // Go ahead and return the EDID
    //**********************************************************************

    VideoPortMoveMemory(QueryBuffer, pEDIDBuffer, BufferSize);

    //**********************************************************************
    // Return Success.
    //**********************************************************************

    return(TRUE);

    }



#endif // _WIN32_WINNT >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv4\nv10.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV10.C
//
// Abstract:
//
//     This is code specific to NV10
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nv4_ref.h"

#include "nv32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "cmdcnst.h"
#include <arb_fifo.h>
#include <nvntioctl.h>

#include "modes.h"
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"
#include "vesadata.h"

#include "nvos.h"
#include "rm.h"

#include "nvreg.h"
#include "nvcm.h"

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID NV10ChipFBPowerSave(PHW_DEVICE_EXTENSION);
VOID NV10ChipFBPowerRestore(PHW_DEVICE_EXTENSION);

//******************************************************************************
// External Declarations
//******************************************************************************

//******************************************************************************
// Hack -> Eventually, we want to include the official
//         NVREF.H file, located in \kernel\resman\inc.
//         However, since this miniport already has an nvref.h file,
//         we'll have to pick and choose.  This will all get
//         overhauled when the miniport is re-architected.
//******************************************************************************

#define NV_PGRAPH_TILE(i)                       (0x00400b00+(i)*16) /* RW-4A */
#define NV_PGRAPH_TLIMIT(i)                     (0x00400b04+(i)*16) /* RW-4A */
#define NV_PGRAPH_TSIZE(i)                      (0x00400b08+(i)*16) /* RW-4A */
#define NV_PBUS_DEBUG_1                                  0x00001084

#define NV_PRAMIN_DATA032(i)                     (0x00700000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                            524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                31:0 /* RWXVF */


#define NV_PFB_TIMING2                                   0x00100228 /* RW-4R */
#define NV_PFB_TIMING2_REFRESH                                 15:5 /* RW-VF */
#define NV_PFB_CFG                                       0x00100200 /* RW-4R */
#define NV_PFB_CSTATUS                                   0x0010020C /* R--4R */
#define NV_PFB_REFCTRL                                   0x00100210 /* RW-4R */
#define NV_PFB_MRS                                       0x001002C0 /* RW-4R */
#define NV_PFB_EMRS                                      0x001002C4 /* RW-4R */
#define NV_PFB_REF                                       0x001002D0 /* -W-4R */

//******************************************************************************
//
// Function:    NV10ChipFBPowerSave()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV10ChipFBPowerSave (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    // power down mode - max out memory refresh value
    HwDeviceExtension->Power_refresh = REG_RD32(NV_PFB_TIMING2);   // refresh
    FLD_WR_DRF_NUM(_PFB, _TIMING2, _REFRESH, 0xFFFFFFFF);       // max refresh
    // Chip has been init'd with the BIOS init tables, unless the BIOS
    // has an incompatible structure and the table was not found, in which case
    // we used a default table, which may not have the correct RAM config, so
    // we save away the current config for restoration above.
    HwDeviceExtension->Power_PfbBoot0     = REG_RD32(NV_PFB_CFG);           // RAM config
    HwDeviceExtension->Power_PfbConfig0   = REG_RD32(NV_PFB_CSTATUS);       // RAM config
    HwDeviceExtension->Power_PfbConfig1   = REG_RD32(NV_PFB_REFCTRL);       // RAM config
    HwDeviceExtension->Power_PfbMrs       = REG_RD32(NV_PFB_MRS);           // RAM config
    HwDeviceExtension->Power_PfbEmrs      = REG_RD32(NV_PFB_EMRS);          // RAM config
    HwDeviceExtension->Power_PfbRef       = REG_RD32(NV_PFB_REF);           // RAM config
    HwDeviceExtension->Power_PbusDebug1   = REG_RD32(NV_PBUS_DEBUG_1);      // RAM config
    HwDeviceExtension->Power_PextdevBoot0 = REG_RD32(NV_PEXTDEV_BOOT_0);    // READ STRAPS
    HwDeviceExtension->Power_PfifoRamHT   = REG_RD32(NV_PFIFO_RAMHT);
    HwDeviceExtension->Power_PfifoRamRO   = REG_RD32(NV_PFIFO_RAMRO);
    HwDeviceExtension->Power_PfifoRamFC   = REG_RD32(NV_PFIFO_RAMFC);

    }



//******************************************************************************
//
// Function:    NV10ChipFBPowerRestore()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV10ChipFBPowerRestore (PHW_DEVICE_EXTENSION HwDeviceExtension)
    {
    U032 D0_DELAY_RETRIES = 10; 
    U032 retry = 0;             
    U032 i;                     

    // power up mode - restore previous memory config
    REG_WR32(NV_PBUS_DEBUG_1, HwDeviceExtension->Power_PbusDebug1);   // must set FBI differential
    REG_WR32(NV_PFB_TIMING2, HwDeviceExtension->Power_refresh);       // refresh
    REG_WR32(NV_PFB_CFG, HwDeviceExtension->Power_PfbBoot0);          // RAM config
    REG_WR32(NV_PFB_CSTATUS, HwDeviceExtension->Power_PfbConfig0);    // RAM config
    REG_WR32(NV_PFB_REFCTRL, HwDeviceExtension->Power_PfbConfig1);    // RAM config
    REG_WR32(NV_PFB_MRS, HwDeviceExtension->Power_PfbMrs);    		 // RAM config
//  REG_WR32(NV_PFB_EMRS, HwDeviceExtension->Power_PfbEmrs);    		 // RAM config - reset
    REG_WR32(NV_PFB_REF, HwDeviceExtension->Power_PfbRef);    		 // RAM config

//  A delay seems to be necessary for i820 for win9x.
//  Couldn't demonstrate a problem with W2K, so its here for safety.
//  Reading NV_PMC_ENABLE is simply a convenient delay    
    while (REG_RD32(NV_PEXTDEV_BOOT_0) != HwDeviceExtension->Power_PextdevBoot0)
        {
        for (i=0; i<2000; i++)
            {
            REG_RD32(NV_PMC_ENABLE);
            }
        REG_WR32(NV_PEXTDEV_BOOT_0, HwDeviceExtension->Power_PextdevBoot0);    // WRITE STRAP REG
        retry++;
        if (retry == D0_DELAY_RETRIES)
            break;
        }
    REG_WR32(NV_PFIFO_RAMHT, HwDeviceExtension->Power_PfifoRamHT);      
    REG_WR32(NV_PFIFO_RAMRO, HwDeviceExtension->Power_PfifoRamRO);      
    REG_WR32(NV_PFIFO_RAMFC, HwDeviceExtension->Power_PfifoRamFC);      

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\cr11_ref.h ===
/* NVidia Corporation */ 
/* basis: crush11 manuals 
built on Thu Feb 22 04:10:06 PST 2001*/

#ifndef _CR_REF_H_
#define _CR_REF_H_

#define CR_DRF_DEF(d,r,f,c)  ((CR ## d ## r ## f ## c)<<DRF_SHIFT(CR ## d ## r ## f))
#define CR_DRF_NUM(d,r,f,n)  (((n)&DRF_MASK(CR ## d ## r ## f))<<DRF_SHIFT(CR ## d ## r ## f))
#define CR_DRF_VAL(d,r,f,v)  (((v)>>DRF_SHIFT(CR ## d ## r ## f))&DRF_MASK(CR ## d ## r ## f))

/* dev_cr.ref */

#define CR_CMC_CFG0                                      0x8000017c /* RW-4R */
#define CR_CMC_CFG0_TOP_OF_FB				       10:6 /* RWIVF */
#define CR_CMC_CFG0_TOP_OF_FB_1MB                        0x00000000 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_2MB                        0x00000001 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_3MB                        0x00000002 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_4MB                        0x00000003 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_5MB                        0x00000004 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_6MB                        0x00000005 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_7MB                        0x00000006 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_8MB                        0x00000007 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_9MB                        0x00000008 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_10MB                       0x00000009 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_11MB                       0x0000000A /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_12MB                       0x0000000B /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_13MB                       0x0000000C /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_14MB                       0x0000000D /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_15MB                       0x0000000E /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_16MB                       0x0000000F /* RWI-V */
#define CR_CMC_CFG0_TOP_OF_FB_17MB                       0x00000010 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_18MB                       0x00000011 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_19MB                       0x00000012 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_20MB                       0x00000013 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_21MB                       0x00000014 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_22MB                       0x00000015 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_23MB                       0x00000016 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_24MB                       0x00000017 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_25MB                       0x00000018 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_26MB                       0x00000019 /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_27MB                       0x0000001A /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_28MB                       0x0000001B /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_29MB                       0x0000001C /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_30MB                       0x0000001D /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_31MB                       0x0000001E /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB_32MB                       0x0000001F /* RW--V */
#define CR_CMC_CFG0_TOP_OF_FB__PROD                      0x0000001F /* RW--V */

#endif /* _CR_REF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\ddminint.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995,1997 NVidia Corporation. All Rights Reserved.
 *
 *  File:       ddmini.h
 *  Content:    header for Windows95 Direct Draw driver
 *
 *  Files:
 *           ddmini16.c
 *           ddddrv16.c
 *           ddmode.c
 *
 *           dddrv32.c
 *           blt832.c
 *           blt1632.c
 *           blt3232.c
 *
 ***************************************************************************/
#ifndef _DDMININT_H_
#define _DDMININT_H_

// Turn this off to disable the use of the VPP code for the winnt4
// display driver. @mjl@
#define MJL_USE_VPP


// Note:

// From NT4 DDK (Graphics System Overview)
//    The display driver is in the same privileged kernel-mode address space as the 
//    rest of the Windows NT Executive. Faults in the display driver will cause GDI 
//    and the rest of the system to fault.

#include "nvPusher.h"
#include "nvVPP.h"
#include "nvUtil.h"
#include "CompileControl.h"

#ifndef NVD3D
#include "nvFourCC.h"
#undef NV_MAX_FOURCC
#define NV_MAX_FOURCC 7
#endif

#define NV_MAX_EXTRA_FS_SURFACES 4
#define NV_MAX_EXTRA_SURFACES    6

//  Remove double-defintion warning
#ifdef  DIRECTDRAW_DLLNAME
#undef  DIRECTDRAW_DLLNAME
#endif
#define DIRECTDRAW_DLLNAME "NV3DD32.DLL"

#ifndef _WIN32
#define NOUSER
#define NOGDI
#define NOGDIOBJ
#define NOGDICAPMASKS
#include <windows.h>
#define NOPTRC
#define PTTYPE POINT
#include <nvgdi.inc>
#define NVFAR FAR
#include <nvdib.inc>
typedef struct tagPALETTEENTRY FAR* LPPALETTEENTRY;
typedef struct tagRGNDATA      FAR* LPRGNDATA;
#include <ddrawi.h>
#endif

#define FAST register

//  Remove double-definition warning
#ifdef  asmMergeCoords
#undef  asmMergeCoords
#endif
#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)

// Probably should move these up to a more general level -@mjl@

/* Other NV specific defines */
#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L

/* Surface Alignment */
#if (NVARCH >= 0x010)
#define NV_BYTE_ALIGNMENT_PAD           63L
#define NV_BYTE_ALIGNMENT               64L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#elif (NVARCH >= 0x04)
#define NV_BYTE_ALIGNMENT_PAD           31L
#define NV_BYTE_ALIGNMENT               32L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#else /* NVARCH < 0x04 */
#define NV_BYTE_ALIGNMENT_PAD           15L
#define NV_BYTE_ALIGNMENT               16L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      128
#define NV_BIT_ALIGNMENT                128
#endif  /* !(NV10 || NV4) */


//************************************************************************************
// Entry/exit macros used by the ddraw driver to acquire the rendering semaphore from the
// This notifies the OGL ICD that we need to touch the fifo
//************************************************************************************
#define START_DMA_PUSH_SYNC()           \
{ \
    ppdev->pfnAcquireOglMutex(ppdev); \
    ppdev->NVFreeCount = 0; \
    releaseOpenglSemaphore = TRUE; \
}

#define ENTER_DMA_PUSH_SYNC()           \
    if (OglIsEnabled(ppdev))       \
        {                               \
        START_DMA_PUSH_SYNC(); \
        }

#define END_DMA_PUSH_SYNC() \
    if (releaseOpenglSemaphore == TRUE) \
        {                               \
        ppdev->pfnReleaseOglMutex(ppdev); \
        }

#define EXIT_DMA_PUSH_SYNC(exitcode)    \
{ \
    END_DMA_PUSH_SYNC();            \
    return(exitcode); \
}


/***************************************************************************
 *
 * DriverData
 *
 * this structure contains all the globals of the driver, it is shared
 * between the 16 and 32bit side of the driver.
 *
 ***************************************************************************/

//  Remove double-definition warning
#ifdef  DDMINI_VERSION
#undef  DDMINI_VERSION
#endif
#define DDMINI_VERSION  0x0300



#ifndef NVD3D
typedef struct {
    short   x;
    short   y;
} NVXY;

typedef struct {
    short   y;
    short   x;
} NVYX;

typedef struct {
    unsigned short w;
    unsigned short h;
} NVWH;

typedef struct {
    unsigned short h;
    unsigned short w;
} NVHW;

typedef union {
    long xy;
    long yx;
    unsigned long wh;
    unsigned long hw;
    NVXY xy16;
    NVYX yx16;
    NVWH wh16;
    NVHW hw16;
} NVCOORD;

// Not sure this is the best approach to accessing this object methods. -@mjl@
#define BETA4_SET_BETA_FACTOR_OFFSET                            NV072_SET_BETA_FACTOR
#define SURFACES_2D_PITCH_OFFSET                                NV042_SET_PITCH
#define BLIT_POINT_IN_OFFSET                                    NV05F_CONTROL_POINT_IN
#define MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET                      NV039_OFFSET_IN
#define SET_ROP_OFFSET                                          NV043_SET_ROP5
#define SET_TRANSCOLOR_OFFSET                                   NV057_SET_COLOR
#define SURFACES_2D_SET_COLOR_FORMAT_OFFSET                     NV042_SET_COLOR_FORMAT
#define SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET                   NV077_SET_CONTEXT_DMA_IMAGE
#define SCALED_IMAGE_CONTEXT_SURFACE_OFFSET                     NV077_SET_CONTEXT_SURFACE
#define SCALED_IMAGE_SET_COLOR_FORMAT                           NV077_SET_COLOR_FORMAT
#define SCALED_IMAGE_CLIPPOINT_OFFSET                           NV077_CLIP_POINT
#define SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET                       NV077_IMAGE_IN_SIZE
#define SCALED_IMAGE_NOTIFY_OFFSET                              NV077_NOTIFY
#define IMAGE_BLACK_RECTANGLE_POINT_OFFSET                      NV019_SET_POINT
#define RECT_AND_TEXT_COLOR1A_OFFSET                            NV04A_COLOR1_A

//---------------------------------------------------------------------------
// blit data, including cached values and other control parameters
// 
// Used to allow sharing of several objects (ROP, 2D SURFACE, ...?)
//  by multiple users within the same context (may not need in NT4) -@mjl@

typedef struct BltData_s {
    NvU32               dwStatusReferenceCount;
    NvU32               dwSystemSurfaceContextDMAIndex;
    NvU32               dwMTMFIndex;     // alternating odd or even, does not need to be initialized
    NvU32               dwLastRop;
    NvU32               dwLastColourKey;
    NvU32               dwLastColourFormat;
    NvU32               dwLastCombinedPitch;
    NvU32               dwLastSrcOffset;
    NvU32               dwLastDstOffset;
    NvU32               dwSystemBltFallback;
    NvU32               dwLetItThrash;
    NvU32               dwQueuedPrimaryBlitCount;
} BltData_t;

typedef struct {
    DWORD               fpFlipFrom;
    DWORD               dwFlipDuration;
    DWORD               bFlipFlag;
    DWORD               bIsD3DSurface;
    DWORD               fpFlipTo;
    DWORD               fpPreviousFlipFrom;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    LONGLONG            llFlipTime;
    LONGLONG            llPreviousFlipTime;
} FLIPRECORD;


// I think these are mocomp... why are they used in VPP? -@mjl@
#define NVS2VF_SP_ODD           0x00000004
#define NVS2VF_SP_EVEN          0x00000008
typedef struct tagNVMCSURFACEFLAGS {
  DWORD dwMCSurfaceBase;
  DWORD dwMCSurface422Offset;
  DWORD dwMCMotionCompReferenceCount;
  DWORD dwMCFormatCnvReferenceCount;
  DWORD dwMCCompositeReferenceCount;
  DWORD dwMCTemporalFilterReferenceCount;
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
  BYTE  bMCFrameIsFiltered;
  BYTE  bMCFrameIsComposited;
  BYTE  bMCFrameAlreadyFormatConverted;
} NVMCSURFACEFLAGS, *LPNVMCSURFACEFLAGS;


typedef struct _PDEV PDEV;      // Handy forward declaration

typedef struct _GLOBALDATA
{
    // lpPDevice *must* be first (DIBLINK.ASM) uses it.
#ifdef _WIN32
    DWORD                       lpPDevice;
#else
    DIBENGINE FAR *             lpPDevice;
#endif


    DWORD                       dwVersion;
    DWORD                       fIsDisplay;

    // flags
    DWORD                       DDrawVideoSurfaceCount; // *MUST* start at 0xC offset from beginning of struct (cursor code and realizeObject checks it)
    WORD                        fDmaPusherActive;   // *MUST* start at 0x10 offset from beginning of struct (both display driver and direct draw check it)
    WORD                        fFullScreenDosOccurred; // *MUST* start at 0x12 offset from beginning of struct (both display driver and direct draw check it)
    WORD                        fVidMemLocked;
    WORD                        fActiveExternalUser; // NVLIB, NVDDX, etc
    WORD                        fNvActiveFloatingContexts;
    WORD                        OverlayBufferIndex;

    // info about the current mode
    DWORD                       ModeNumber;
    DWORD                       TotalVRAM;          // total VRAM on card
    DWORD                       ScreenSel;          // selector to screen
    DWORD                       maxOffScreenY;      // maximum screen pitch width Y at current resolution
    DWORD                       BaseAddress;        // base addess of accessable video memory.(set to zero on NT)
    long                        VideoHeapBase;      // start of video heap
    long                        VideoHeapEnd;       // end of video heap
    DWORD                       GARTLinearBase;     // linear base address of AGP GART memory
    DWORD                       GARTPhysicalBase;   // physical base address of AGP GART memory
    WORD                        OverlaySrcX;        // overlay source starting point
    WORD                        OverlaySrcY;

    // bitmapinfo for current mode
    BITMAPINFOHEADER            bi;
    DWORD                       color_table[256];

    PDEV *                      ppdev;  // A pointer back to the physical device
    // NV stuff
//    DWORD                       lpNvDev;
//    DWORD                       lpNvDmaBuffer;
//    DWORD                       NvDevFlat;
    DWORD                       NvDevFlatVPE; // Vpe channel (used in NV3 -- maybe)
//    DWORD                       NvDmaBufferFlat;
//    DWORD                       NvDummyNotifierFlat;
//    DWORD                       NvFlipPrimaryNotifierFlat;
//    DWORD                       NvFlipOverlayNotifierFlat;
//    DWORD                       NvFlipVportNotifierFlat;
//    DWORD                       NvDmaToMemNotifierFlat;
//    DWORD                       NvDmaFromMemNotifierFlat;
//    DWORD                       NvDmaFromMemBaseAddress;
//    DWORD                       NvDmaFromMemSurfaceMem;
//    DWORD                       NvPusherSyncNotifierFlat;
//    DWORD                       NvScanlineBufferFlat;
//    DWORD                       NvFloating0UYVYSurfaceMem;
//    DWORD                       NvFloating1UYVYSurfaceMem;
//    DWORD                       NvFloating0YUYVSurfaceMem;
//    DWORD                       NvFloating1YUYVSurfaceMem;
//    DWORD                       NvFloatingMem2MemFormatBaseAddress;
//    DWORD                       NvYUY2Surface0Mem;
//    DWORD                       NvYUY2Surface1Mem;
//    DWORD                       NvFloatingMem2MemFormatMemoryHandle;
//    DWORD                       NvWinDmaPusherNotifierFlat;
//    DWORD                       dwVideoPortsAvailable;
//    DWORD                       NvFloatingTexture;
//    DWORD                       CurrentVisibleSurfaceAddress;
//    DWORD                       lpLast3DSurfaceRendered;
    NvU32                       NvBaseFlat;                        // Base Address of NV IoSpace
//    DWORD                       dwOverlaySurfaces;
//    DWORD                       dwOverlayOwner;

//    DWORD                       dwOverlaySrcHeight;
//    DWORD                       dwOverlayDstHeight;
//    DWORD                       dwModeIndex;
//    DWORD                       dwUseRefreshRate;
//    DWORD                       NvFloatingMem2MemFormatNextAddress;
//    DWORD                       NvYUY2Surface2Mem;
    DWORD                       physicalColorMask; // (accessed in NV3 -- but used?)
    WORD                        flatSelector; // NV3 only -- used?
    WORD                        NvFreeCount;
    BYTE                        NvFirstCall;
    BYTE                        NvPrevDepth;
    BYTE                        ThreeDRenderingOccurred;// NV3 only -- used?
    BYTE                        unused_01;

//    DWORD                       fourCC[16];    // leave some empty locations so we can add more without rereleasing 16 bit portion of driver

    //*********************************************************************************
    // Stuff added for compatibility with NT5/Win9x Build
    //*********************************************************************************
    // TBD: make sure ALL of these are initialized properly -@mjl@
    LPPROCESSINFO               lpProcessInfoHead;
    PROCESSINFO                 procInfo;           // statically created for WinNT4/Win2k
    NvU16                       NvDeviceVersion;
    NvU8                        TwoDRenderingOccurred;       // Used trivially by VPP, but not otherwise
    NvU8                        unused_02;
    NvU32                       dwRootHandle;       
    NvU32                       dwDeviceHandle;
    NvU32                       dwSurfaceAlignPad;
    NvU32                       dwMostRecent3dUser;
    NvU32                      *pCurrentChannelID;
    NvU32                       regPBLocale;
    NvU32                       blitCalled;

    NvU32                       dDrawSpareSubchannelObject;  // This is referenced DIRECTLY by the VPP code.  Fix @mjl@
    NvU32                       ddClipUpdate;                // Used trivially by VPP, but not otherwise
    NvU32                       dwDXVAFlags;                 // Used trivially by VPP, but not otherwise
    NvU32                       dwSharedClipChangeCount;     // TBD: vpp makes global ref to these! -@mjl@
    NvU32                       dwDDMostRecentClipChangeCount;//Ditto

    CPushBuffer                 nvPusher;   // Used exclusively by the ported VPP code

    NV_SystemInfo_t             sysInfo;
    BltData_t                   bltData;
    FLIPRECORD                  flipPrimaryRecord;
    FLIPRECORD                  flipOverlayRecord;

    NvU32                       dwTVTunerFlipCount;
    NvU32                       dwOverlayFlipCount;
    NvU32                       dwHeads;            // number of heads (DACs) on this device
    NvU32                       dwDesktopState;
    NvV32                      *pCommonNotifierBuffer;
    NvNotification             *pPioFlipOverlayNotifierFlat; // To be changed! @mjl@

    //*********************************************************************************
    // Video & Overlay Stuff
    //*********************************************************************************
    Vpp_t                       vpp;

#if 0
    // D3D stuff
    DWORD                       dwCurrentContextHandle;
    DWORD                       dwCurrentContextPtr;
    DWORD                       dwCurrentTextureHandle;
    DWORD                       dwCurrentTexturePtr;
    DWORD                       dwD3DContextCount;
    DWORD                       dwZBufferContextAddr;
    DWORD                       dwTriangleContextHandle;
    DWORD                       dwTriangleContextAddr;
    DWORD                       dwD3DTextureCount;
    DWORD                       dwDMAPushContext;
    DWORD                       dwDmaPushBufferSize;
    DWORD                       hContexts_gbl;
    DWORD                       hTextures_gbl;
    DWORD                       hAGPList_gbl;
    DWORD                       hTextureHeap;
    DWORD                       hPipelines_gbl;
    DWORD                       hMaterials_gbl;
    DWORD                       dwDmaMaxPushCount;
    DWORD                       regD3DEnableBits1;
    DWORD                       regDmaPushBufferSizeMax;
    DWORD                       regMipMapLevels;
    DWORD                       regZOHMode;
    DWORD                       regTexHeap;
    DWORD                       regMinVideoTextureSize;
    DWORD                       regFilterControl;
    DWORD                       regDmaMinPushCount;
    DWORD                       regD3DContextMax;
    DWORD                       regD3DTextureMax;
    DWORD                       dwContextListHead;
    DWORD                       dwDmaFifoAddr;
    DWORD                       dwDmaFifoOffset;
    DWORD                       dwDmaFifoCurrentBuffer;
    DWORD                       dwDmaCount;

    // DirectDraw stuff
    DWORD                       fReset;
    DD_HALINFO                  HALInfo;    // This is unreferenced... check to see if we need it @mjl@
    DD_CALLBACKS                DDCallbacks;
    DD_SURFACECALLBACKS         DDSurfaceCallbacks;
    DD_PALETTECALLBACKS         DDPaletteCallbacks;
#endif
} GLOBALDATA;
#endif // #ifndef NVD3D

/***************************************************************************
 ***************************************************************************/
#ifdef _WIN32

/* Ternary raster operation indexes */

#define BLACKNESSINDEX      0x00000000L
#define NOTSRCERASEINDEX    0x00000011L
#define NOTSRCCOPYINDEX     0x00000033L
#define SRCERASEINDEX       0x00000044L
#define PATINVERTINDEX      0x0000005AL
#define SRCINVERTINDEX      0x00000066L
#define SRCANDINDEX         0x00000088L
#define MERGEPAINTINDEX     0x000000BBL
#define SRCCOPYINDEX        0x000000CCL
#define SRCPAINTINDEX       0x000000EEL
#define PATCOPYINDEX        0x000000F0L
#define WHITENESSINDEX      0x000000FFL


#else  // _WIN32

/* Ternary raster operations */
#define BLACKNESS           0x00000042L
#define SRCCOPY             0x00CC0020L
#define PATCOPY             0x00F00021L
#define WHITENESS           0x00FF0062L

/***************************************************************************
 *
 * global driver data
 *
 ***************************************************************************/

extern GLOBALDATA           DriverData;     // in ddmini16.c

/***************************************************************************
 *
 * functions in ddmini.c
 *
 ***************************************************************************/

void FAR PASCAL _loadds BeginAccess(DIBENGINE FAR *pde, int left, int top, int right, int bottom, UINT flags);
void FAR PASCAL _loadds EndAccess(DIBENGINE FAR *pde, UINT flags);

/***************************************************************************
 *
 * functions in setmode.c
 *
 ***************************************************************************/

BOOL HWSetMode();
BOOL HWTestMode(int ModeNumber);
void FAR PASCAL HWBeginAccess(DIBENGINE FAR *,short,short,DWORD,DWORD);
void HWEndAccess(void);
BOOL HWSetPalette(int start, int count, DWORD FAR *colors);


/***************************************************************************
 *
 * functions in DIBENG
 *
 ***************************************************************************/

extern DWORD FAR PASCAL CreateDIBPDevice    (LPBITMAPINFOHEADER lpbi, DIBENGINE FAR *lpDevice, LPVOID lpBits, WORD dwFlags);
extern UINT  FAR PASCAL DIB_Enable          (LPVOID, UINT, LPSTR, LPSTR, LPVOID);
extern UINT  FAR PASCAL DIB_Disable         (DIBENGINE FAR *);
extern LONG  FAR PASCAL DIB_Control         (DIBENGINE FAR *, UINT, LPVOID, LPVOID);
extern UINT  FAR PASCAL DIB_BeginAccess     (DIBENGINE FAR *, int left, int top, int right, int bottom, WORD flags);
extern UINT  FAR PASCAL DIB_EndAccess       (DIBENGINE FAR *, WORD flags);
extern UINT  FAR PASCAL DIB_SetPaletteExt   (UINT start, UINT count, DWORD FAR *lpPalette, DIBENGINE FAR * pde);
extern UINT  FAR PASCAL DIB_BitBlt          (DIBENGINE FAR *, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *);
extern UINT  FAR PASCAL DIB_StretchBlt      (DIBENGINE FAR *, int, int, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_StretchDIBits   (DIBENGINE FAR *, int, int, int, int, int, int, int, int, LPVOID, BITMAPINFO FAR *, LPVOID, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_DibToDevice     (DIBENGINE FAR *, int, int, int, int, RECT FAR *, DRAWMODE FAR *, LPVOID, BITMAPINFO FAR *, LPVOID);
extern UINT  FAR PASCAL DIB_Output          (DIBENGINE FAR *, int, int, POINT FAR *, DIB_Pen FAR *, DIB_Brush8 FAR *, DRAWMODE FAR *, RECT FAR *);
extern UINT  FAR PASCAL DIB_ExtTextOutExt   (DIBENGINE FAR *pde, int x, int y, RECT FAR *Clip, LPSTR sz, UINT cb, LPVOID lpFont, DRAWMODE FAR *pdm, LPVOID xform, int FAR *pdx, RECT FAR *lpORect, UINT f, LPVOID DrawBitmap, LPVOID DrawRect);
// extern UINT  FAR PASCAL DIB_SetCursorExt    (CURSORSHAPE FAR *lpCursor, DIBENGINE FAR *pde);
extern UINT  FAR PASCAL DIB_MoveCursorExt   (int x, int y, DIBENGINE FAR * pde);

#endif // _WIN32

/* Escape functions */
#define MOUSETRAILS         39
#define DCICOMMAND          3075
#define GETSURFINFO         0x6979
#define GETNVCHANNELPTR     0x6980
#define RECONFIGNVOFFSCREEN 0x6981
#define NVSETDDRAWMODE      0x6982


#ifndef DX7   // For DX7, this is defined in ddmini.h.
/* AGP stuff */
#define NV_MAX_AGP_MEMORY_LIMIT 0x1FFFFFF
#endif

/* Dma flags */
#define NV_WIN_DMA_PUSHER_IS_ACTIVE  1
#define NV_DD_DMA_PUSHER_IS_ACTIVE   2

/* Floating system memory context in use flags */
#define NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        1
#define NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        2
#define NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        4
#define NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        8
#define NV_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY       16

/* Other NV specific defines. NV3 and NV4 surface alignments have
   been changed since NV10 video scaler only supports 64 byte aligned
   surfaces. Note that changing these #defines causes ALL vidmem surfaces
   to be 64 byte aligned.
 */
#define NV3_BYTE_ALIGNMENT_PAD   15L
#define NV3_BIT_ALIGNMENT        128
#define NV4_BYTE_ALIGNMENT_PAD   31L
#define NV4_BIT_ALIGNMENT        256
#define NV10_BYTE_ALIGNMENT_PAD  63L
#define NV10_BIT_ALIGNMENT       512

#define NV10_INITIAL_PITCH    64
#define NV4_INITIAL_PITCH     32

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010

#ifndef NVD3D

#if _WIN32_WINNT < 0x0500
//*************************************************************************
// Misc stuff which changed between dx3 and dx5, Win95 and WinNT
//*************************************************************************
#define DDSCAPS_LOCALVIDMEM DDSCAPS_VIDEOMEMORY
#ifndef NV_AGP
// BUGBUG need to undefine this when AGP support arrives
#define DDSCAPS_NONLOCALVIDMEM DDSCAPS_SYSTEMMEMORY
#endif
#endif // #if _WIN32_WINNT < 0x0500
#endif  // #ifndef NVD3D

/***************************************************************************
 *
 * DEBUG stuff
 *
 ***************************************************************************/
#ifdef IS_32
#ifdef DEBUG
#if defined(_WIN32_WINNT)
//#define DPF(a) DISPDBG((0, (a))
#define BREAK() EngDebugBreak();
#else
    extern void __cdecl DPF(LPSTR szFormat, ...);
    #define BREAK() DebugBreak();
#endif
#else
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif
#else
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif

#define DDRAW_SET_PRIMARY(ppdev, Offset, Stride)        \
       if (Stride < 32)                                 \
           ppdev->DdCurrentDestPitch = 32;              \
       else                                             \
           {                                            \
           ppdev->DdCurrentDestPitch = ((Stride + ppdev->ulSurfaceAlign ) & ~ppdev->ulSurfaceAlign);          \
           }                                            \
                                                        \
       ppdev->DdCurrentDestOffset = Offset;             \
       while (freeCount < 3*4)                          \
           freeCount = NvGetFreeCount(npDev, NV_DD_PRIMARY);    \
       freeCount -= 3*4;                                \
                                                        \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = ((ppdev->DdCurrentDestPitch << 16) | (ppdev->DdCurrentSourcePitch));  \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource = ppdev->DdCurrentSourceOffset;  \
       npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = Offset

#define DDRAW_SET_SOURCE(ppdev, Offset, Stride)         \
    if (Stride < 32)                                    \
        ppdev->DdCurrentSourcePitch = 32;               \
    else                                                \
        {                                               \
        ppdev->DdCurrentSourcePitch = ((Stride + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);          \
        }                                               \
    ppdev->DdCurrentSourceOffset = Offset;              \
    while (freeCount < 3*4)                             \
        freeCount = NvGetFreeCount(npDev, NV_DD_PRIMARY);    \
    freeCount -= 3*4;                                   \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = ((ppdev->DdCurrentDestPitch <<16) | (ppdev->DdCurrentSourcePitch));    \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource = Offset;  \
    npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = ppdev->DdCurrentDestOffset

#if (_WIN32_WINNT >= 0x0500) && defined(NV3) && !defined(DISPDRV)
#ifdef RM_HEAPMGR
#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define MEM_TYPE_PRIMARY                     8
#define MEM_TYPE_IMAGE_TILED                 9

extern BOOL __fastcall bMoveAllDfbsFromOffscreenToDibs(PDEV *);

// TBD: create a better way of allocating and freeing memory - huge macro!  Baaaadddd. -@mjl@
#define NVHEAP_ALLOC(sts,pvm,sz,tp)             \
{                                           \
    NVOS11_PARAMETERS   HeapParams;         \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
                                            \
    if (!PDEV_PTR()->DDrawVideoSurfaceCount)     \
    {                                       \
        PDEV_PTR()->cbGdiHeap = PDEV_PTR()->VideoHeapTotal -   \
        PDEV_PTR()->VideoHeapFree;                      \
                                                                    \
    }                                       \
                                                    \
    HeapParams.hRoot = PDEV_PTR()->hClient;  \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                         \
        PDEV_PTR()->hDriver,            \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    (sts) = HeapParams.status; \ 
    if (!(pvm))                                                 \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(PDEV_PTR());    \
        HeapParams.hRoot = PDEV_PTR()->hClient;  \
        HeapParams.hObjectParent = PDEV_PTR()->hDevice;                  \
        HeapParams.function = HEAP_ALLOC_SIZE;                      \
        HeapParams.owner    = 'NVDD';                               \
        HeapParams.type     = (tp);                                 \
        HeapParams.size     = (sz);                                 \
        EngDeviceIoControl(                         \
            PDEV_PTR()->hDriver,            \
            (DWORD)IOCTL_NV01_ARCH_HEAP,            \
            (&pParms),                              \
            sizeof(PVOID),                          \
            pParms,                                 \
            sizeof(NVOS11_PARAMETERS),              \
            &cbReturned                             \
        );                                          \
        (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    }                                               \
    if (pvm)                                        \
        PDEV_PTR()->VideoHeapFree = HeapParams.free;    \
}

#define NVHEAP_FREE(pvm)                    \
{                                           \
    NVOS11_PARAMETERS HeapParams;           \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
    HeapParams.hRoot = PDEV_PTR()->hClient;      \
    HeapParams.hObjectParent = PDEV_PTR()->hDevice; \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.owner    = 'NVDD';         \
    HeapParams.offset   = (U032)(pvm);      \
    EngDeviceIoControl(                         \
        PDEV_PTR()->hDriver,                                \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    PDEV_PTR()->VideoHeapFree = HeapParams.free;              \
}
#else // !RM_HEAPMGR
#define NVHEAP_INIT(strt, end, heap)  \
    heap_init((strt), (end), heap)
#define NVHEAP_INFO()
#define NVHEAP_CLEAR(heap)  \
    heap_clear(heap)
#define NVHEAP_ALLOC(pvm,sz,tp)             \
    (pvm) = heap_alloc(sz, (memory_t *) (ppdev)->heap.heap_2d_ptr);
// TBD: where do we get sts in this case?
#define NVHEAP_FREE(pvm)             \
    heap_free((pvm), (memory_t *) (ppdev)->heap.heap_2d_ptr);
#endif // !RM_HEAPMGR
#endif // NV3

//**************************************************************************************
// Common ddraw fct prototypes.
//**************************************************************************************
EXTERN_C BOOL __stdcall nvDeterminePerformanceStrategy_NT4(GLOBALDATA *pDriverData, NV_SystemInfo_t *pSysInfo);
EXTERN_C DWORD __stdcall DdCanCreateSurface(PDD_CANCREATESURFACEDATA lpCanCreateSurface );
EXTERN_C DWORD __stdcall DdSetColorKey(PDD_SETCOLORKEYDATA lpSetColorKey);
EXTERN_C DWORD DdCreateSurface(PDD_CREATESURFACEDATA lpCreateSurface);
EXTERN_C DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
EXTERN_C DWORD DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory);
EXTERN_C DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank);
EXTERN_C DWORD GetScanLine32(PDD_GETSCANLINEDATA lpGetScanLine );
DWORD Nv3Blt(PDD_BLTDATA pbd);
DWORD Nv4Blt(PDD_BLTDATA pbd);
DWORD __stdcall Nv3DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface );
DWORD __stdcall Nv4DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface );
DWORD __stdcall Nv3Flip(PDD_FLIPDATA pfd);
DWORD __stdcall Nv4Flip(PDD_FLIPDATA pfd);
DWORD Nv3GetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD Nv4GetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD WINAPI DdGetDriverInfo(struct _DD_GETDRIVERINFODATA *lpData);
DWORD Nv3Lock(PDD_LOCKDATA lpLockData);
DWORD Nv4Lock(PDD_LOCKDATA lpLockData);
DWORD __stdcall DdSetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
DWORD __stdcall Nv3Unlock( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv4Unlock( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv3UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData );
DWORD __stdcall Nv4UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData );
#ifdef NVD3D
DWORD WINAPI GetAvailDriverMemory (PDD_GETAVAILDRIVERMEMORYDATA  pDmd);
#endif
HRESULT Nv3UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem );
unsigned long Nv4UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem );
DWORD __stdcall Nv3UnlockOverlay( PDD_UNLOCKDATA lpUnlockData );
DWORD __stdcall Nv4UnlockOverlay( PDD_UNLOCKDATA lpUnlockData );
BOOLEAN bCreateNV4DDPatchPio(PDEV *ppdev);
BOOLEAN bDestroyNV4DDPatchPio(PDEV *ppdev);
DWORD Nv3GetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD Nv4GetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD __stdcall Nv3SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
DWORD __stdcall Nv4SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData );
extern DWORD __stdcall Nv3Blt8( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv3Blt16( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv3Blt32( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt8( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt16( PDD_BLTDATA pbd );
extern DWORD __stdcall Nv4Blt32( PDD_BLTDATA pbd );

//------------------------------------------------------------------------------
// The minimum depth of the NV chip's FIFO -- never wait for the free count
// to reach a value greater than NV_GUARANTEED_FIFO_SIZE (124 bytes)!
//------------------------------------------------------------------------------

#define NV_GUARANTEED_FIFO_SIZE                 (0x007C)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\minii2c.c ===
/*----------------------------------------------------------------------------*/
/*
 * minii2c.c
 *
 *  I2C functionality for the miniport
 *
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#ifdef NVPE

//#define INITGUID     // Instantiate GUID_I2C_INTERFACE

#include <ntstatus.h>
#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

typedef unsigned long   DWORD;
typedef unsigned int    UINT;

#include "nv.h"
#include "nv32.h"
#include "nvos.h"

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif
#define PDEVICE_OBJECT  PVOID
#include "i2cgpio.h"

#define WDM_TO_VPE_COMMAND_MASK 0xdead0000

// backdoor VPE command functions
ULONG nvVPECommand(PHW_DEVICE_EXTENSION pHwDevExt, ULONG cmd, PVOID pData);
U032 vddWriteVPEPrescale(PHW_DEVICE_EXTENSION pHwDevExt, U032 ulX, U032 ulY, 
                         U032 ulCap, U032 ulVPUseOverlay, U032 ulFlag);

/*----------------------------------------------------------------------------*/
/*
 * misc defines and prototypes
 */

DECLSPEC_IMPORT
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

extern ULONG i2cAccess(PVOID, U032, NVRM_I2C_ACCESS_CONTROL *);

/*----------------------------------------------------------------------------*/
/*
 * globals
 *
 */

extern PHWINFO NvDBPtr_Table[];

/*
 * AcquireI2C() - Acquire I2C routine (Common)
 */
NTSTATUS AcquireI2C (
    PDEVICE_OBJECT          pDev,
    PHW_DEVICE_EXTENSION    pHwDevExt,
    PHWINFO                 pNvInfo,
    ULONG                   port,
    ULONG                   head )
{
    NTSTATUS                result;

    // Build command to acquire the I2C port

    pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_ACQUIRE;
    pHwDevExt->I2C_Ports[port].rmI2CCtrl.port = port;
    pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags = 0;

    // Try to acquire the desired I2C port

    if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
    {
        // I2C port acquired, update I2C structure (Including time)

        pHwDevExt->I2C_Ports[port].ulStatus = I2C_PORT_ACQUIRED;
        pHwDevExt->I2C_Ports[port].ulOwner = (ULONG) pDev;
        KeQuerySystemTime(&pHwDevExt->I2C_Ports[port].lTimeStamp);

        // Set the result status value

        result = STATUS_SUCCESS;
    }
    else    // Could not acquire the I2C port
    {
        // Set the result status value

        result = STATUS_OPEN_FAILED;
    }
    // Return result to the caller

    return(result);
}

/*
 * ReleaseI2C() - Release I2C routine (Common)
 */
NTSTATUS ReleaseI2C (
    PDEVICE_OBJECT          pDev,
    PHW_DEVICE_EXTENSION    pHwDevExt,
    PHWINFO                 pNvInfo,
    ULONG                   port,
    ULONG                   head )
{
    NTSTATUS                result;

    // Build command to release the I2C port

    pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_RELEASE;
    pHwDevExt->I2C_Ports[port].rmI2CCtrl.port = port;
    pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags = 0;

    // Try to free the I2C port

    if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
    {
        // I2C port is now release, update I2C structure

        pHwDevExt->I2C_Ports[port].ulStatus = I2C_PORT_FREE;
        pHwDevExt->I2C_Ports[port].ulOwner = 0;
        pHwDevExt->I2C_Ports[port].lTimeStamp.QuadPart = 0;

        // Set the result status value

        result = STATUS_SUCCESS;
    }
    else    // Error releasing the I2C port
    {
        // Set the result status value

        result = STATUS_OPEN_FAILED;
    }
    // Return result to the caller

    return(result);
}

/*
 * miniI2COpen() - Miniport I2C Open routine (Common)
 */

NTSTATUS miniI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT            acquire,
    PI2CControl     pI2CCtrl,
    ULONG           port,
    ULONG           head )
{
    PHW_DEVICE_EXTENSION    pHwDevExt;
    PHWINFO                 pNvInfo;
    NTSTATUS                result;
    LARGE_INTEGER           time, elapsed;

    // Get hardware device extension and information based on the device object

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));
    pNvInfo = NvDBPtr_Table[pHwDevExt->DeviceReference];

    // Check for WDM backdoor to VPE request  (This is allow WDM drivers to set
    // some VPE parameters that aren't or can't be set by WDM's overlay mixer.)

    if ((pI2CCtrl->Command & 0xffff0000) == WDM_TO_VPE_COMMAND_MASK)
    {
        // Call routine to process the VPE command

        pI2CCtrl->Status = nvVPECommand(pHwDevExt, (pI2CCtrl->Command & 0x0000ffff), (void*) pI2CCtrl);

        // Set result to status of VPE command

        result = pI2CCtrl->Status;
    }
    else    // This is a normal I2C open command
    {
        // Check to see if this is an acquire/release request

        if (acquire == TRUE)
        {
            // This is an acquire request, check for I2c port free

            if (pHwDevExt->I2C_Ports[port].ulStatus == I2C_PORT_FREE)
            {
                // I2C port is free, try to acquire the desired I2C port

                if (AcquireI2C(pDev, pHwDevExt, pNvInfo, port, head) == STATUS_SUCCESS)
                {
                    // I2C port acquired, set the I2C and result status values

                    pI2CCtrl->dwCookie = (ULONG) pDev;
                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Could not acquire the I2C port
                {
                    // Set the I2C and result status values

                    pI2CCtrl->dwCookie = 0;
                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_OPEN_FAILED;
                }
            }
            else    // This port is already acquired
            {
                // Compute the amount of time since last I2C access

                KeQuerySystemTime(&time);
                elapsed.QuadPart = time.QuadPart - pHwDevExt->I2C_Ports[port].lTimeStamp.QuadPart;

                // Check to see if port timeout has occurred

                if ((elapsed.HighPart != 0) || (elapsed.LowPart > I2C_PORT_TIMEOUT))
                {
                    // Port timeout has occurred, try to release current owner

                    if (ReleaseI2C((PDEVICE_OBJECT) pHwDevExt->I2C_Ports[port].ulOwner, pHwDevExt, pNvInfo, port, head) == STATUS_SUCCESS)
                    {
                        // Current owner released, try new owner acquire

                        if (AcquireI2C(pDev, pHwDevExt, pNvInfo, port, head) == STATUS_SUCCESS)
                        {
                            // I2C port acquired, set I2C and result status values

                            pI2CCtrl->dwCookie = (ULONG) pDev;
                            pI2CCtrl->Status = I2C_STATUS_NOERROR;
                            result = STATUS_SUCCESS;
                        }
                        else    // Unable to acquire for new owner
                        {
                            // Set the I2C and result status values

                            pI2CCtrl->dwCookie = 0;
                            pI2CCtrl->Status = I2C_STATUS_BUSY;
                            result = STATUS_OPEN_FAILED;
                        }
                    }
                    else    // Unable to release current owner
                    {
                        // Set the I2C and result status values

                        pI2CCtrl->dwCookie = 0;
                        pI2CCtrl->Status = I2C_STATUS_BUSY;
                        result = STATUS_OPEN_FAILED;
                    }
                }
                else    // Port access has not timed out
                {
                    // Set the I2C and result status values

                    pI2CCtrl->dwCookie = 0;
                    pI2CCtrl->Status = I2C_STATUS_BUSY;
                    result = STATUS_OPEN_FAILED;
                }
            }
        }
        else    // This is a release request
        {
            // Check to make sure port is acquired and the correct owner

            if ((pHwDevExt->I2C_Ports[port].ulStatus == I2C_PORT_ACQUIRED)  &&
                (pHwDevExt->I2C_Ports[port].ulOwner == (ULONG) pDev)        &&
                (pI2CCtrl->dwCookie == (ULONG) pDev))
            {
                // Valid release request, try to release the I2C port

                if (ReleaseI2C(pDev, pHwDevExt, pNvInfo, port, head) == STATUS_SUCCESS)
                {
                    // I2C port released, set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error releasing the I2C port
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_OPEN_FAILED;
                }
            }
            else    // Port not acquired or incorrect owner
            {
                // Set the I2C and result status values

                pI2CCtrl->Status = I2C_STATUS_ERROR;
                result = STATUS_INVALID_HANDLE;
            }
        }
    }
    // Return result to the caller

    return(result);
}

/*
 * miniI2CAccess - Miniport I2C Access routine (Common)
 */

NTSTATUS miniI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl,
    ULONG           port,
    ULONG           head )
{
    PHW_DEVICE_EXTENSION    pHwDevExt;
    PHWINFO                 pNvInfo;
    NTSTATUS                result;

    // Get hardware device extension and information based on the device object

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));
    pNvInfo = NvDBPtr_Table[pHwDevExt->DeviceReference];

    // Check to make sure port is acquired and the correct owner

    if ((pHwDevExt->I2C_Ports[port].ulStatus == I2C_PORT_ACQUIRED)  &&
        (pHwDevExt->I2C_Ports[port].ulOwner == (ULONG) pDev)        &&
        (pI2CCtrl->dwCookie == (ULONG) pDev))
    {
        // I2C port is owned, update the I2C port access time stamp

        KeQuerySystemTime(&pHwDevExt->I2C_Ports[port].lTimeStamp);

        // Start building the I2C command (Common flags and port)

        pHwDevExt->I2C_Ports[port].rmI2CCtrl.port = port;
        pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags = 0;

        if (pI2CCtrl->Flags & I2C_FLAGS_START)
            pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_START;
        if (pI2CCtrl->Flags & I2C_FLAGS_STOP)
            pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_STOP;
        if (pI2CCtrl->Flags & I2C_FLAGS_ACK)
            pHwDevExt->I2C_Ports[port].rmI2CCtrl.flags |= NVRM_I2C_ACCESS_FLAG_ACK;

        // Switch on the requested I2C command        

        switch(pI2CCtrl->Command)
        {
            case I2C_COMMAND_WRITE:     // I2c write byte command

                // Complete building the I2C command

                pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_WRITE_BYTE;
                pHwDevExt->I2C_Ports[port].rmI2CCtrl.data = pI2CCtrl->Data;

                // Try to perform the requested write command

                if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error performing write command
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_ADAPTER_HARDWARE_ERROR;
                }
                break;

            case I2C_COMMAND_READ:      // I2C read byte command

                // Complete building the I2C command

                pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_READ_BYTE;

                // Try to perform the requested read command

                if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
                {
                    // Save the I2C read data (Complete DWORD)

                    pI2CCtrl->Data        = (BYTE) (pHwDevExt->I2C_Ports[port].rmI2CCtrl.data & 0xFF);
                    pI2CCtrl->Reserved[0] = (BYTE)((pHwDevExt->I2C_Ports[port].rmI2CCtrl.data >>  8) & 0xFF);
                    pI2CCtrl->Reserved[1] = (BYTE)((pHwDevExt->I2C_Ports[port].rmI2CCtrl.data >> 16) & 0xFF);
                    pI2CCtrl->Reserved[2] = (BYTE)((pHwDevExt->I2C_Ports[port].rmI2CCtrl.data >> 24) & 0xFF);

                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error performing read command
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Data = 0;
                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_ADAPTER_HARDWARE_ERROR;
                }
                break;

            case I2C_COMMAND_NULL:      // I2C null command

                // Complete building the I2C command

                pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_NULL;

                // Try to perform the requested null command

                if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error performing null command
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_ADAPTER_HARDWARE_ERROR;
                }
                break;

            case I2C_COMMAND_STATUS:    // I2C status command

                // Set the I2C and result status values

                pI2CCtrl->Status = I2C_STATUS_NOERROR;
                result = STATUS_SUCCESS;

                break;

            case I2C_COMMAND_RESET:     // I2C reset command

                // Complete building the I2C command

                pHwDevExt->I2C_Ports[port].rmI2CCtrl.cmd = NVRM_I2C_ACCESS_CMD_NULL;

                // Try to perform the requested reset command

                if (i2cAccess(pNvInfo, head, &pHwDevExt->I2C_Ports[port].rmI2CCtrl) == 0)
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_NOERROR;
                    result = STATUS_SUCCESS;
                }
                else    // Error performing reset command
                {
                    // Set the I2C and result status values

                    pI2CCtrl->Status = I2C_STATUS_ERROR;
                    result = STATUS_ADAPTER_HARDWARE_ERROR;
                }
                break;

            default:                    // Unknown I2C command

                // Set the I2C and result status values

                pI2CCtrl->Status = I2C_STATUS_ERROR;
                result = STATUS_INVALID_PARAMETER;

                break;
        }
    }
    else    // Port not acquired or incorrect owner
    {
        // Check for an I2C port status command (Only valid non-owner command)

        if (pI2CCtrl->Command == I2C_COMMAND_STATUS)
        {
            // Get the status of the request I2C port (Free/Acquired)

            if (pHwDevExt->I2C_Ports[port].ulStatus == I2C_PORT_FREE)
                pI2CCtrl->Status = I2C_STATUS_NOERROR;
            else
                pI2CCtrl->Status = I2C_STATUS_BUSY;

            // Setup the result status value

            result = STATUS_SUCCESS;
        }
        else    // Invalid I2C access command
        {
            // Set the I2C and result status values

            pI2CCtrl->Status = I2C_STATUS_ERROR;
            result = STATUS_INVALID_HANDLE;
        }
    }
    // Return result to the caller

    return(result);
}

/*
 * NVGetI2CPort(HwID) - Get I2C port based on hardware ID
 */

ULONG
NVGetI2CPort(
    IN ULONG HwID)
{
    ULONG I2CPort;

    // Switch on the hardware ID value

    switch(HwID)
    {
        case 0:

            // Special value indicating dynamic I2C port (Based on real ID)

            I2CPort = I2C_ACCESS_DYNAMIC_PORT;
            break;

        case QUERY_MONITOR_ID:
        case QUERY_MONITOR_ID2:
        case QUERY_NONDDC_MONITOR_ID:
        case QUERY_NONDDC_MONITOR_ID2:
        case QUERY_ACPI_CRT_ID:
        case QUERY_ACPI_DFP_ID:

            // This is a monitor, setup for primary port

            I2CPort = I2C_ACCESS_PRIMARY_PORT;
            break;

        case NVCAP_I2C_DEVICE_ID:
        case NVXBAR_I2C_DEVICE_ID:
        case NVTUNER_I2C_DEVICE_ID:
        case NVTVSND_I2C_DEVICE_ID:

            // This is an external device, setup for secondary port

            I2CPort = I2C_ACCESS_SECONDARY_PORT;
            break;

        default:

            // Unknown hardware device ID, default to secondary port

            VideoDebugPrint((1, "NVGetI2CPort: Unknown hardware ID!\n"));
            I2CPort = I2C_ACCESS_SECONDARY_PORT;
            break;
    }
    return I2CPort;
}

/*
 * NVGetI2CHead(HwID) - Get I2C head based on hardware ID
 */

ULONG
NVGetI2CHead(
    IN ULONG HwID)
{
    ULONG I2CHead;

    // Switch on the hardware ID value

    switch(HwID)
    {
        case QUERY_MONITOR_ID:
        case QUERY_NONDDC_MONITOR_ID:
        case QUERY_ACPI_CRT_ID:
        case QUERY_ACPI_DFP_ID:

            // This is the primary monitor, use head number 0

            I2CHead = 0;
            break;

        case QUERY_MONITOR_ID2:
        case QUERY_NONDDC_MONITOR_ID2:

            // This is the secondary monitor, use head number 1

            I2CHead = 1;
            break;

        case NVCAP_I2C_DEVICE_ID:
        case NVXBAR_I2C_DEVICE_ID:
        case NVTUNER_I2C_DEVICE_ID:
        case NVTVSND_I2C_DEVICE_ID:

            // This is an external device, use head number 0

            I2CHead = 0;
            break;

        default:

            // Unknown hardware device ID, default to head number 0

            VideoDebugPrint((1, "NVGetI2CHead: Unknown hardware ID!\n"));
            I2CHead = 0;
            break;
    }
    // Return the I2C head number

    return I2CHead;
}

/*
 * dynI2COpen() - Dynamic I2C port version of I2COpen()
 */

NTSTATUS dynI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT            acquire,
    PI2CControl     pI2CCtrl )
{
    PHW_DEVICE_EXTENSION pHwDevExt;
    NTSTATUS result = STATUS_SUCCESS;
    ULONG Port;
    ULONG Head;
    ULONG HwID;

    // Get the hardware device extension for this device

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));

    // Check to make sure we can convert PDO to hardware ID

    if (pHwDevExt->pfnVideoPortGetAssociatedDeviceID)
    {
        // Convert the PDO value to a hardware ID

        HwID = (*pHwDevExt->pfnVideoPortGetAssociatedDeviceID)(pDev);

        // Get the requested I2C port and head values

        Port = NVGetI2CPort(HwID);
        Head = NVGetI2CHead(HwID);

        // Try to perform the requested I2C open operation

        result = miniI2COpen(pDev, acquire, pI2CCtrl, Port, Head);
    }
    else    // Unable to convert PDO, invalid dynamic I2C open
        result = STATUS_INVALID_PARAMETER;

    return(result);
}

/*
 * dynI2CAccess - Dynamic I2C port version of I2CAccess()
 */

NTSTATUS dynI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{
    PHW_DEVICE_EXTENSION pHwDevExt;
    NTSTATUS result = STATUS_SUCCESS;
    ULONG Port;
    ULONG Head;
    ULONG HwID;

    // Get the hardware device extension for this device

    pHwDevExt = (PHW_DEVICE_EXTENSION)(VideoPortGetAssociatedDeviceExtension(pDev));

    // Check to make sure we can convert PDO to hardware ID

    if (pHwDevExt->pfnVideoPortGetAssociatedDeviceID)
    {
        // Convert the PDO value to a hardware ID

        HwID = (*pHwDevExt->pfnVideoPortGetAssociatedDeviceID)(pDev);

        // Get the requested I2C port and head values

        Port = NVGetI2CPort(HwID);
        Head = NVGetI2CHead(HwID);

        // Try to perform the requested I2C access operation

        result = miniI2CAccess(pDev, pI2CCtrl, Port, Head);
    }
    else    // Unable to convert PDO, invalid dynamic I2C access
        result = STATUS_INVALID_PARAMETER;

    return(result);
}

/*
 * priI2COpen() - Primary I2C port version of I2COpen()
 */

NTSTATUS priI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT            acquire,
    PI2CControl     pI2CCtrl )
{
    ULONG Port = NVRM_I2C_ACCESS_PORT_PRIMARY;
    ULONG Head = 0;

    // Try to perform the requested I2C open operation

    return miniI2COpen(pDev, acquire, pI2CCtrl, Port, Head);
}

/*
 * priI2CAccess - Primary I2C port version of I2CAccess()
 */

NTSTATUS priI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{
    ULONG Port = NVRM_I2C_ACCESS_PORT_PRIMARY;
    ULONG Head = 0;
    ULONG HwID;

    // Try to perform the requested I2C access operation

    return miniI2CAccess(pDev, pI2CCtrl, Port, Head);
}

/*
 * secI2COpen() - Secondary I2C port version of I2COpen()
 */

NTSTATUS secI2COpen (
    PDEVICE_OBJECT  pDev,
    UINT            acquire,
    PI2CControl     pI2CCtrl )
{
    ULONG Port = NVRM_I2C_ACCESS_PORT_SECONDARY;
    ULONG Head = 0;

    // Try to perform the requested I2C open operation

    return miniI2COpen(pDev, acquire, pI2CCtrl, Port, Head);
}

/*
 * secI2CAccess - Secondary I2C port version of I2CAccess()
 */

NTSTATUS secI2CAccess (
    PDEVICE_OBJECT  pDev,
    PI2CControl     pI2CCtrl )
{
    ULONG Port = NVRM_I2C_ACCESS_PORT_SECONDARY;
    ULONG Head = 0;

    // Try to perform the requested I2C access operation

    return miniI2CAccess(pDev, pI2CCtrl, Port, Head);
}

/*
 * nvVPECommand() is a backdoor function to allow other Ring0 programs (like WDM)
 * to change or request various VPE functions.
 */

#define NV_VPE_CMD_SET_PRESCALE_MODE    1
#define NV_VPE_CMD_SET_CROP_MODE        2

ULONG nvVPECommand (
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG cmd,
    PVOID pData )
{

    switch ( cmd ) {

    case NV_VPE_CMD_SET_PRESCALE_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to prescale
         * as oppose to cropping.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * set prescale flag and size
             */
            //Data(lower nibble)    =   0   not capturing
            //                          1   capturing
            //Data(upper nibble)    =   2   X scale
            //                          4   Y scale
            //Status    =   prescale/height * 1000
            if((pI2CCtrl->Data)& 0x40){
                vddWriteVPEPrescale(pHwDevExt,
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Status,//set Y-prescale 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    6);                             //prog. y-pre & cap. flag
            }else if((pI2CCtrl->Data)& 0x20){
                vddWriteVPEPrescale(pHwDevExt,
                                    ((PI2CControl)pI2CCtrl)->Status,//set X-prescale
                                    0, 
                                    ((PI2CControl)pI2CCtrl)->Data,  //capture flag
                                    0, 
                                    0xa);                           //prog. x-pre & cap.flag
            }else if(!((pI2CCtrl->Data)& 0x1)){
                vddWriteVPEPrescale(pHwDevExt,
                                    0,
                                    0, 
                                    0,  //capture flag=0 (not capturing)
                                    0, 
                                    0x2);   
            }
        }
        break;

    case NV_VPE_CMD_SET_CROP_MODE:

        /*
         * This command is to allow WDM drivers to tell VPE to crop
         * as oppose to prescaling.  This is because the overlay mixer does
         * not seem to pass on this information to us.
         */

        {
            PI2CControl pI2CCtrl = pData;

            /*
             * turn off prescale flag
             */

        }
        break;

    default:
        return 1;   
    }

    return 0;
}

void nvpeVDDInit(PHW_DEVICE_EXTENSION pHwDevExt)
{
    //Initialize VPE capture hack for WDM
    vddWriteVPEPrescale(pHwDevExt,
                        1000,   //setting ME X-prescale factor. 1000=no scale
                        1000,   //setting ME Y-prescale factor. 1000=no scale
                        0,      //set to not vpe capture mode 
                        0,      //set default VP surf type = overlay 
                        0xf);   //use all values

}

// A mechanism to populate the WDM prescale values
// This is a back door mechanism and should not really be in this module.
U032 vddWriteVPEPrescale(PHW_DEVICE_EXTENSION pHwDevExt, U032 ulX, U032 ulY, 
                         U032 ulCap, U032 ulVPNotUseOverlay, U032 ulFlag)
{
    PNVP_CONTEXT pVPEContext;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "nvpekmvt: vddWriteVPEPrescale()\n");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    
    if(ulFlag & 0x8){
        pVPEContext->ulVPECapturePrescaleXFactor=ulX;
    }

    if(ulFlag & 0x4){
        pVPEContext->ulVPECapturePrescaleYFactor=ulY;
    }

    if(ulFlag & 0x2){
        pVPEContext->ulVPECaptureFlag=ulCap;
    }

    if(ulFlag & 0x1){
        pVPEContext->ulVPNotUseOverSurf=ulVPNotUseOverlay;
    }


    return 0;
}

#endif // #ifdef NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\memstruc.h ===
//****************************Module*Header***********************************
//
// Module Name: memstruc.h
//
//****************************************************************************

/*****************************************************************************
 *                                                                           *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.             *
 *                                                                           *
 ****************************************************************************/

//----------------------------------------------------------------------------
// WARNING:  For now, make sure this structure agrees with the one defined in MCD.H
//           We'll eventually move over to exclusively using THIS file,
//           so that the display driver can also use the memory_t structure.
//----------------------------------------------------------------------------

typedef struct _memory_t
{
    struct _memory_t    *prev;
    struct _memory_t    *next;
    struct _memory_t    *nextEmpty;
    ULONG               blkSize;
    ULONG               memBase;
} memory_t;

#define EMPTY               0x1
#define ALIGN_SIZE          64

#define IS_EMPTY(pBlk)      (((ULONG_PTR)(pBlk)->prev) & EMPTY )
#define SET_EMPTY(pBlk)     (pBlk)->prev = (memory_t *)(((BYTE *)(pBlk)->prev) + EMPTY)
#define SET_BUSY(pBlk)      (pBlk)->prev = (memory_t *)(((BYTE *)(pBlk)->prev) - EMPTY)
#define EMPTY_VALUE(pBlk)   ((memory_t *) (((BYTE *)(pBlk)) + EMPTY))
#define BUSY_VALUE(pBlk)    ((memory_t *) (((BYTE *)(pBlk)) - EMPTY))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modedata.c ===
//
// modedata.c - Data tables used for setting extended VESA modes.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    "modes.h"
#endif // DOS_COMPILE
#include "tv.h"

#include "monitor.h"
#include "modedefs.h"

#define POLAR_NEG_NEG        0x0c0
#define POLAR_POS_NEG        0x040
#define POLAR_NEG_POS        0x080
#define POLAR_POS_POS        0x000




VGATBL   vga_tbl[] =
{
    // Basic CRTC Table for Packed Pixel Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
     0x05, 0x0F, 0xFF}
    },

    // Basic CRTC Table for Planar Graphics Modes.
    {0x50, 0x1D, 0x10,
     0xA000,
    {0x01, 0x0F, 0x00, 0x06},
     0xE3,
    {0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80,
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x8C,
     0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
     0xFF},
     0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
     0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B,
     0x3C, 0x3D, 0x3E, 0x3F, 0x01, 0x00,
     0x0F, 0x00,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x05, 0x0F, 0xFF}
    }
};

EXTREGS eregs[] =    // Extended Register Tables
{
    {0x49, 0x00, 0x20, 0x30, 0xFF, 0xFF, 0x0000, CLKID_25_175}, // 00: VGA Modes      00:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 08: Mode 5F/101    01:
    {0x48, 0x00, 0x20, 0x30, 0x32, 0xFF, 0xFA00, CLKID_40},     // 09: Mode 58/6A/102 02:
    {0x4C, 0x00, 0x20, 0x39, 0x64, 0xFF, 0xFFFF, CLKID_40},     // 0A: Mode 5C/103    03:
    {0x48, 0x00, 0x20, 0x30, 0x40, 0xFF, 0xFFFF, CLKID_65},     // 0B: Mode 5D/104    04:
    {0x4C, 0x00, 0x20, 0x39, 0x80, 0xFF, 0xFFFF, CLKID_65},     // 0C: Mode 5E/105    05:
    {0x08, 0x00, 0x15, 0x30, 0x50, 0xFF, 0xFFFF, CLKID_108_5},  // 0F: Mode 5A/106    06:
    {0x0C, 0x00, 0x15, 0x39, 0xA0, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    07:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 08:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 09:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0A:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0B:
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0000, 0x00},         // Text - unused mode 0C:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 22: Mode 78        0D:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 23: Mode 6E        0E:
    {0x44, 0x80, 0x20, 0x3A, 0xC8, 0xFF, 0xFFFF, CLKID_40},     // 24: Mode 6F        0F:
    {0x54, 0x81, 0x20, 0x3A, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72        10:
    {0x4C, 0x00, 0x20, 0x39, 0x50, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        11:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        12:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        13:
    {0x44, 0x00, 0x20, 0x3B, 0xA0, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        14:
    {0x44, 0x00, 0x20, 0x3B, 0xC8, 0xFF, 0xFFFF, CLKID_20},     // 27: Mode 20        15:
    {0x44, 0x00, 0x20, 0x3B, 0xF0, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72        16:
    {0x54, 0x01, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72        17:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        18:
    {0x54, 0x01, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_25_175}, // 28: Mode 21        19:
    {0x54, 0x01, 0x20, 0x3B, 0x90, 0xFF, 0xFFFF, CLKID_40},     // 29: Mode 22        1A:
    {0x54, 0x01, 0x20, 0x3B, 0xE0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72        1B:
    {0x64, 0x02, 0x20, 0x3B, 0x00, 0xFF, 0xFFFF, CLKID_65},     // 25: Mode 72        1C:
    {0x24, 0x02, 0x20, 0x3B, 0x40, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        1D:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x4000, CLKID_12_588}, // 27: Mode 20        1E:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x8000, CLKID_12_588}, // 27: Mode 20        1F:
    {0x4C, 0x00, 0x20, 0x39, 0x28, 0xFF, 0x5000, CLKID_12_588}, // 27: Mode 20        20:
    {0x4C, 0x00, 0x20, 0x39, 0x32, 0xFF, 0x8000, CLKID_20},     // 27: Mode 20        21:
    {0x4C, 0x00, 0x20, 0x39, 0x3C, 0xFF, 0xB000, CLKID_27_93},  // 25: Mode 72        22:
    {0x4C, 0x00, 0x20, 0x39, 0x40, 0xFF, 0xD000, CLKID_32_5},   // 25: Mode 72        23:
    {0x4C, 0x00, 0x20, 0x39, 0x78, 0xFF, 0xFFFF, CLKID_55_86},  // 0C: Mode 5E/105    24:
    {0x0C, 0x00, 0x20, 0x39, 0x90, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        25:
    {0x0C, 0x00, 0x0F, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        26:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xFFFF, CLKID_12_588}, // 27: Mode 20        27:
    {0x44, 0x80, 0x20, 0x3A, 0x50, 0xFF, 0xA000, CLKID_12_588}, // 27: Mode 20        28:
    {0x44, 0x80, 0x20, 0x3A, 0x64, 0xFF, 0xF000, CLKID_20},     // 27: Mode 20        29:
    {0x44, 0x80, 0x20, 0x3A, 0x78, 0xFF, 0xFFFF, CLKID_27_93},  // 25: Mode 72        2A:
    {0x44, 0x80, 0x20, 0x3A, 0x80, 0xFF, 0xFFFF, CLKID_32_5},   // 25: Mode 72        2B:
    {0x44, 0x80, 0x20, 0x3A, 0xA0, 0xFF, 0xFFFF, CLKID_25_175}, // 26: Mode 5B        2C:
    {0x44, 0x80, 0x20, 0x3A, 0xF0, 0xFF, 0xFFFF, CLKID_55_86},  // 25: Mode 72        2D:
    {0x14, 0x81, 0x20, 0x3A, 0x20, 0xFF, 0xFFFF, CLKID_81_62},  // 25: Mode 72        2E:
    {0x14, 0x81, 0x15, 0x3A, 0x40, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    2F:
    {0x14, 0x81, 0x0F, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        30:
    {0x24, 0x02, 0x15, 0x3B, 0x80, 0xFF, 0xFFFF, CLKID_108_5},  // 10: Mode 6B/107    31:
    {0x24, 0x03, 0x0F, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_158},    // 25: Mode 72        32:

    // JJV - New Modes (I think this starts at 0x33 ??)
    {0x0C, 0x40, 0x0F, 0x79, 0xE1, 0xFF, 0xFFFF, CLKID_219_566}, // 33: 1800X1440X8
    {0x0C, 0x41, 0x0F, 0x7A, 0xC2, 0xFF, 0xFFFF, CLKID_219_566}, // 34: 1800X1440X16
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_172_798}, // 35: 1920X1080X8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_172_798}, // 36: 1920X1080X16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_172_798}, // 37: 1920X1080X32
    {0x0C, 0x40, 0x9F, 0x79, 0xF0, 0xFF, 0xFFFF, CLKID_193_156}, // 38: 1920X1200X8
    {0x0C, 0x41, 0x9F, 0x7A, 0xE0, 0xFF, 0xFFFF, CLKID_193_156}, // 39: 1920X1200X16
    {0x0C, 0x43, 0x9F, 0x7B, 0xC0, 0xFF, 0xFFFF, CLKID_193_156},  // 3A: 1920X1200X32
    // JJV - New Modes

    // VEL - New Dell Modes
    {0x0C, 0x40, 0x05, 0x79, 0xC8, 0xFF, 0xFFFF, CLKID_136_36},  // 3B: 1600x1024x8      
    {0x0C, 0x41, 0x05, 0x7A, 0x90, 0xFF, 0xFFFF, CLKID_136_36},  // 3C: 1600x1024x16     
    {0x0C, 0x43, 0x05, 0x7B, 0x20, 0xFF, 0xFFFF, CLKID_136_36}   // 3D: 1600x1024x32     
    // VEL - New Dell Modes

};

TVREGS tvregs[] =    // TV Timing Tables
{
    {0x60, 0x00, 0x67, 0x5B, 0x31, 0x2E, 0xDE, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 0 - VGA Mode 3
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xA9, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 1 - VGA Mode 11/12
    {0x60, 0x00, 0x68, 0x5B, 0x23, 0x3E, 0xDE, 0x4F, 0x4F, 0x8B, 0x85, 0x38, 0x8F, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0xA1, 0xBA, 0x30, 0x4F, 0x50, 0x00, 0x85, 0x05, 0x7F, 0xE0, 0x0D },   // TV Mode 2 - VGA Mode 13
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xD0, 0xFF, 0x0D,
     0x06, 0x82, 0x70, 0x81, 0xF8, 0x30, 0x63, 0x63, 0x8B, 0x85, 0x05, 0x00, 0xE0, 0x0D },   // TV Mode 3 - VGA Modes > 640x480
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0x90, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D },   // TV Mode 4 - 640x400 Extended Modes
    {0x60, 0x08, 0x67, 0x5A, 0x12, 0x2E, 0xDF, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xFF, 0x0D,
     0x00, 0x62, 0x55, 0x91, 0xBA, 0x30, 0x4F, 0x4F, 0x8B, 0x85, 0x05, 0xE0, 0xE0, 0x0D }   // TV Mode 5 - 640x480 Extended Modes
};

//
// Mode clock frequencies
//
U016 tblClockFreq[] =
{
    5035,       // 00: 50.350
    5664,       // 01: 56.644
    3325,       // 02: 33.250
    5200,       // 03: 52.000
    8000,       // 04: 80.000
    6300,       // 05: 63.000
    0000,       // 06: Ext
    7500,       // 07: 75.000 (1024x768@70)
    2518,       // 08: 25.175 (VGA)
    2832,       // 09: 28.322 (VGA)
    3150,       // 0A: 31.500 (640x480@72)
    3600,       // 0B: 36.000 (800x600@56)
    4000,       // 0C: 40.000 (800x600@60)
    4490,       // 0D: 44.900 (1024x768@87i)
    5000,       // 0E: 50.000 (800x600@72)
    6500,       // 0F: 65.000 (1024x768@60)
    10800,      // 10: 108.000/2 (1280x1024@60) use clock doubler
    13500,      // 11: 135.000/2 (1280x1024@75) use clock doubler
    4950,       // 12: 49.500
    5625,       // 13: 56.250
    7875,       // 14: 78.750
    9450,       // 15: 94.500
    10850,      // 16: 108.500/2 use clock doubler
    3550,       // 17: 35.500
    15800,      // 18: 158.000/2 use clock doubler
    5586,       // 19: 55.860
    2000,       // 1A: 20.000
    2793,       // 1B: 27.930
    3250,       // 1C: 32.500
    1259,       // 1D: 12.588 (VGA/2)
    8162,       // 1E: 81.624
    21957,      // 1F: 219.566
    17280,      // 20: 172.798
    19316,      // 21: 193.156
    22950,      // 22: 229.50 (for max dot clock)
    13636       // 23: 136.36
};

U016 DMTOverrideTable[NUMBER_OF_MODES*NUMBER_OF_RATES][13] =
{
    //0:
    // Settings for 1600x1200:
    16200, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    18900, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    20250, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    22950, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    //1:
    // Settings for 1280x1024:
    10800, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a7, 0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    13500, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a3,   0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    15750, POLAR_POS_POS, 0x0d3, 0x09f, 0x097, 0x0a9,   0x01d, 0x02e, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x02f,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    //2:
    // Settings for 1152x864:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    10800, POLAR_POS_POS, 0x0c3, 0x08f, 0x087, 0x099, 0x009, 0x082, 0x0ff, (0x061-1), (0x024-1) | 0x080, 0x05f, 0x083,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //3:
    // Settings for 1024x768:
    6500 , POLAR_NEG_NEG, 0x0a3, 0x07f, 0x087, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7500 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
// 72Hz does not appear in DMT, so this is a fudge of the GTF's
    7843 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x085, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7875 , POLAR_POS_POS, 0x09f, 0x07f, 0x083, 0x083, 0x08f, 0x01e, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x01f,
    9450 , POLAR_POS_POS, 0x0a7, 0x07f, 0x08b, 0x087, 0x093, 0x026, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x027,
// 100Hz does not appear in DMT, so this is a fudge of the GTF's
    11370, POLAR_POS_POS, 0x0a9, 0x07f, 0x08D, 0x086, 0x098, 0x02C, 0x0f5, (0x002-1), (0x024-1) | 0x080, 0x0ff, 0x027,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //4:
    // Settings for 960x720:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //5:
    // Settings for 800x600:
    4000 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x06a, 0x01a, 0x072, 0x0f0, (0x059-1), (0x02d-1) | 0x080, 0x057, 0x073,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    5000 , POLAR_POS_POS, 0x07d, 0x063, 0x081, 0x06c, 0x01b, 0x098, 0x0f0, (0x07d-1), (0x023-1) | 0x080, 0x057, 0x099,
    4950 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x067, 0x011, 0x06f, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x070,
    5625 , POLAR_POS_POS, 0x07e, 0x063, 0x082, 0x069, 0x011, 0x075, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x076,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //6:
    // Settings for 640x480:
    2517 , POLAR_NEG_NEG, 0x05f, 0x04f, 0x083, 0x053, 0x09f, 0x00b, 0x03e, (0x0ea-1), (0x02c-1) | 0x080, 0x0df, 0x00c,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    3150 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x054, 0x099, 0x006, 0x03e, (0x0e9-1), (0x02c-1) | 0x080, 0x0df, 0x007,
    3150 , POLAR_NEG_NEG, 0x064, 0x04f, 0x088, 0x053, 0x09b, 0x0f2, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0f3,
    3600 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x058, 0x09f, 0x0fb, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0fc,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //7:
    // Settings for 640x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //8:
    // Settings for 512x384:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //9:
    // Settings for 480x360:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //10:
    // Settings for 400x300:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //11:
    // Settings for 320x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //12:
    // Settings for 320x240:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //13:
    // Settings for 320x200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //14:
    // Settings for 1920x1200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //15:
    // Settings for 1920x1080:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //16:
    // Settings for 1800x1440:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //17:
    // Settings for 1600x1024:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

};

//  this table translates resolutions into their VESA BIOS mode equivalents
U016 ModeSetTable[NUMBER_OF_MODES*NUMBER_OF_DEPTHS] =
{
    // depths: 4 (planar modes), 8, 16, 24/32
    //0:
    // 1600 x 1200
    0xff, 0x145, 0x146, 0x14E,
    //1:
    // 1280 x 1024
    0x106, 0x107, 0x11a, 0x14D,
    //2:
    // 1152 x 864
    0xff, 0x141, 0x142, 0x143,
    //3:
    // 1024 x 768
    0x104, 0x105, 0x117, 0x118,
    //4:
    // 960 x 720
    0xff, 0x14a, 0x14b, 0x14c,
    //5:
    // 800 x 600
    0x102, 0x103, 0x114, 0x115,
    //6:
    // 640 x 480
    0xff, 0x101, 0x111, 0x112,
    //7:
    // 640 x 400
    0xff, 0x100, 0x13d, 0x13e,
    //8:
    // 512 x 384
    0xff, 0x13a, 0x13b, 0x13c,
    //9:
    // 480 x 360
    0xff, 0x147, 0x148, 0x149,
    //10:
    // 400 x 300
    0xff, 0x137, 0x138, 0x139,
    //11:
    // 320 x 400
    0xff, 0x131, 0x132, 0x133,
    //12:
    // 320 x 240
    0xff, 0x134, 0x135, 0x136,
    //13:
    // 320 x 200
    0xff, 0x130, 0x10e, 0x10f,

    //14:
    // 1920 x 1200
    0xff, 0x154, 0x155, 0x156,
    //15:
    // 1920 x 1080
    0xff, 0x151, 0x152, 0x153,
    //16:
    // 1800 x 1440
    0xff, 0x14f, 0x150, 0xff,

    //17:
    // 1600 x 1024
    0xff, 0x157, 0x158, 0x159


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modedefs.h ===
//******************************************************************************
//
// Copyright (c) 1998  NVidia Corporation
//
// Module Name:
//
//     modedefs.h
//
// Abstract:
//
// Environment:
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1998 NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#define NUMBER_OF_MODES 18
#define NUMBER_OF_DEPTHS 4
#define NUMBER_OF_RATES  7
#define MODE_TABLE_LENGTH (NUMBER_OF_MODES * NUMBER_OF_DEPTHS * sizeof(U016))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\dspioctl.h ===
#ifndef _DSPIOCTL_H
#define _DSPIOCTL_H
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     dspioctl.h
//
// Abstract:
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "nvMultiMon.h"
//******************************************************************************
// Number of dacs
//******************************************************************************
#define NV_NO_DACS                  2

//******************************************************************************
// Private IOCTL info - Used by all components of the display driver
//******************************************************************************

#define IOCTL_VIDEO_GET_VIDEO_CARD_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_RESTORE_DISPLAY_PATCH    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2050, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2051, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_IO_PORT_FOR_ALI    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2052, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2053, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_VBLANK_FLAG    \
        CTL_CODE (FILE_DEVICE_VIDEO, 2054, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_NV_PFIFO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2055, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_WRITE_COMBINING \
        CTL_CODE (FILE_DEVICE_VIDEO, 2056, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2057, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT \
        CTL_CODE (FILE_DEVICE_VIDEO, 2058, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SYSMEM_SHARE_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2059, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SYSMEM_UNSHARE_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2060, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_LOCK_DOWN_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2061, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNLOCK_MEMORY \
        CTL_CODE (FILE_DEVICE_VIDEO, 2062, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_TO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2063, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_UNMAP_FROM_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 2064, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_COMMON_DEVICE_INFO \
        CTL_CODE (FILE_DEVICE_VIDEO, 2065, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ALLOC_AGP_MEM \
        CTL_CODE (FILE_DEVICE_VIDEO, 2066, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_FREE_AGP_MEM  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2067, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_PIXMIX_INDEX \
        CTL_CODE (FILE_DEVICE_VIDEO, 2068, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_VPE_COMMAND \
        CTL_CODE (FILE_DEVICE_VIDEO, 2069, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_REGISTRY_PATH  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2070, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_REGISTRY_VAL  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2071, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_REGISTRY_VALUE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2072, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2073, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_DISPLAY_DEVICE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2075, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_DISPLAY_DEVICE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2076, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VALIDATE_DEVICE_MODE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2077, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2078, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_GAMMA_CLUT  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2079, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_MAP_PHYS_ADDR  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2080, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_PHYS_ADDR  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2081, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2083, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_STOP_TIMER_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2084, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR \
        CTL_CODE (FILE_DEVICE_VIDEO, 2085, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_DESKTOP_INFO_MODE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2086, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TIMING_DAC \
        CTL_CODE (FILE_DEVICE_VIDEO, 2087, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_PREMODE_SET \
        CTL_CODE (FILE_DEVICE_VIDEO, 2088, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_POSTMODE_SET \
        CTL_CODE (FILE_DEVICE_VIDEO, 2089, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TWINVIEW_STATE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2090, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_TWINVIEW_STATE \
        CTL_CODE (FILE_DEVICE_VIDEO, 2091, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_NUMBER_DACS \
        CTL_CODE (FILE_DEVICE_VIDEO, 2092, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING \
        CTL_CODE (FILE_DEVICE_VIDEO, 2093, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SAVE_GAMMA_VALUES \
        CTL_CODE (FILE_DEVICE_VIDEO, 2094, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESTORE_GAMMA_VALUES \
        CTL_CODE (FILE_DEVICE_VIDEO, 2095, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_PCI_SLOT  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2096, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2097, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_CLEAR_FRAMEBUFFER  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2098, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_TV_ENCODER_TYPE  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2099, METHOD_BUFFERED, FILE_ANY_ACCESS)
// handle calls for stereo glasses
#define IOCTL_VIDEO_STEREO_GLASSES_SWITCH \
        CTL_CODE (FILE_DEVICE_VIDEO, 2100, METHOD_BUFFERED, FILE_ANY_ACCESS)
// handle calls for multi device support for NT 4
#define IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_DEVICE_OBJECTS  \
        CTL_CODE (FILE_DEVICE_VIDEO, 2102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_NV_PFIFO_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 3001, METHOD_BUFFERED, FILE_ANY_ACCESS)


#define IOCTL_VIDEO_ZW_CREATE_FILE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3002, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_ZW_READ_FILE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3003, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_ZW_WRITE_FILE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3004, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_ZW_CLOSE_HANDLE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3005, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS \
        CTL_CODE (FILE_DEVICE_VIDEO, 3006, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_CONTROL_DEVICE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3007, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_UNIQUENESS_VGA \
        CTL_CODE (FILE_DEVICE_VIDEO, 3008, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SIGNAL_NVSVC_MODESET_EVENT \
        CTL_CODE (FILE_DEVICE_VIDEO, 3010, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_NVSVC_STATUS \
        CTL_CODE (FILE_DEVICE_VIDEO, 3011, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK \
        CTL_CODE (FILE_DEVICE_VIDEO, 3012, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SIGNAL_NVCPL_HOTKEY_EVENT \
        CTL_CODE (FILE_DEVICE_VIDEO, 3013, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CONVERT_RING3_HANDLE \
        CTL_CODE (FILE_DEVICE_VIDEO, 3014, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_NV_PBUS_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 3015, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_NV_PBUS_USER \
        CTL_CODE (FILE_DEVICE_VIDEO, 3016, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED \
        CTL_CODE (FILE_DEVICE_VIDEO, 3017, METHOD_BUFFERED, FILE_ANY_ACCESS)


typedef struct _GET_NUMBER_DACS
{
    ULONG ulNumberDacsOnBoard;          // Number of heads on the board.
    ULONG ulNumberDacsConnected;        // Number of heads connected to any device.
    ULONG ulAllDeviceMask;              // Bitmask for all connectors in the board.
    ULONG ulConnectedDeviceMask;        // Bitmask for all connected devices in the system.
    ULONG ulDeviceDisplay[NV_NO_DACS];  // 0,1 or 1,0 depending on the primary head being used in std/span modes.
    ULONG ulDeviceMask[NV_NO_DACS];     // The bitmask of device connected to the head.
                                        // defined in nvcm.h
    ULONG ulDeviceType[NV_NO_DACS];     // The type of device connected to the head viz., CRT, TV, FlatPanel
                                        // defined in nvcm.h
    ULONG ulTVFormat[NV_NO_DACS];       // The TV type: defined in nvcm.h
    ULONG ulHeadDeviceOptions[NV_NO_DACS]; // A matrix of possible device options for each head.
    //
    // Following are the registry keys that get sent back upto the display driver
    //
    ULONG Mobile;                       // 0: desktop system; 1: Dell laptop; 2: Toshiba laptop
    ULONG UseHWSelectedDevice;          // BIOS devices take precedence over windows devices.
    ULONG UseHotKeySameMode;            // On hot key switches, keeps the same desktop mode (resolution,depth).
                                        // This needs PAN_SCAN_SELECTION_ENABLE_ALL to have been turned on.
                                        // This field is obsolete now since no OEM is using this feature curently.
    ULONG PanScanSelection;             // absent or 0: pan-scan in only secondary monitor of clone mode: PAN_SCAN_SELECTION_CLONE_SECONDARY_ONLY
                                        // 1: Enable pan-scan in all modes: PAN_SCAN_SELECTION_ENABLE_ALL
                                        // 2: Disable pan-scan in all modes:PAN_SCAN_SELECTION_DISABLE_ALL 
    ULONG GDIModePruning;
    ULONG ulDFPSupports1400x1050;       // If the builtin DFP of the laptop supports 1400x1050 or not.
                                        // Toshiba wants us to export this mode only if natively supported by DFP.
    ULONG ulHotKeyPending;              // 1 if miniport has a hotkey pending to be done by the display driver.
                                        // Then the display will ignore the BOOT_HEADS.
    ULONG ulUniquenessVGA;              // The unique integer ID for the ppdev
                                        // for which the last IOCTL_RESET_DEVICE 
                                        // was performed.
    ULONG ACPISystem;                   // TRUE if we are on a ACPI system (such as laptops).

    

} GET_NUMBER_DACS;

typedef struct _HEAD_MODE_LIST_INFO
{
    ULONG ulHead;
    ULONG ulEnableDDC;
    ULONG ulDeviceMask;
    ULONG ulDeviceType;
    ULONG ulTVType;
    ULONG ulNumVirtualModes;
    MODE_ENTRY *pVirtualModeList;
    MODE_ENTRY *pPhysicalModeList;    // Caller should have allocated this memory. It is assumed that this
                                      // PhysicalModeList is atleast as big as the VirtualModeList.
} HEAD_MODE_LIST_INFO;

typedef struct _NV_DESKTOP_INFO
{
    ULONG ulDesktopMode;                // 0x0000 -> Single Monitor
    ULONG ulDesktopModeIndex;           // Display driver set the requested mode index  
    ULONG ulDesktopWidth;               // Miniport driver return the width based on the mode index
    ULONG ulDesktopHeight;              // Miniport driver return the height based on the mode index
    ULONG ulDisplayWidth[NV_NO_DACS];   // Display driver set these values; 
    ULONG ulDisplayHeight[NV_NO_DACS];  // control panel should give it to display driver
    ULONG ulDisplayRefresh[NV_NO_DACS]; // refresh rate 
    ULONG ulDisplayPixelDepth[NV_NO_DACS]; // Color Depth
    ULONG ulNumberDacsOnBoard;          // Number of DACs on the board
    ULONG ulNumberDacsConnected;        // Number of DACs which have a device (CRT/DFP/TV) connected to them
    ULONG ulNumberDacsActive;           // Number of DACs which are currently active. For example, in the Normal
                                        // mode, this value will be 1.
    ULONG ulAllDeviceMask;              // Bitmask of all output connectors in the board.
    ULONG ulConnectedDeviceMask;        // Bitmask for all connected devices in the system.
    ULONG ulDeviceMask[NV_NO_DACS];     // The bitmask of device connected to the head.
                                        // defined in nvcm.h
    ULONG ulDeviceType[NV_NO_DACS];     // The type of device connected to the head viz., CRT, TV, FlatPanel
                                        // defined in nvcm.h
    ULONG ulTVFormat[NV_NO_DACS];       // The TV type: defined in nvcm.h
    ULONG ulDeviceDisplay[NV_NO_DACS];  // Dynamically switch device; ulDeviceDisplay[0] will be primary; head 0 or head 1
    ULONG ulHeadDeviceOptions[NV_NO_DACS];    // A matrix of possible device options for each head. Defined in nvMultiMon.h.
                                                // This info is used mainly by the NV control panel and gets scanned in after each
                                                // modeset since this matrix can be changed by the RM after a modeset.
                                                // This is a static entity as opposed to ulDeviceType[NV_NO_DACS] which specifies
                                                // the currently selected device type for this head.
    ULONG ulTwinView_State;             // standard, clone or span.

} NV_DESKTOP_INFO;

typedef struct _NV_CURSOR_INFO
{
    LONG    lCursorX;
    LONG    lCursorY;
    LONG    lCursorWidth;
    LONG    lCursorHeight;
    LONG    lScreenStride;
    LONG    lScreenPixelDepth;
    ULONG   ulHwCursorWidth;
    ULONG   ulOriginalImageMemOffset;
    ULONG   ulCursorMemOffset;
} NV_CURSOR_INFO;

typedef struct _NV_SYSMEM_SHARE_MEMORY
    {
    PVOID pSystemMdl;           // MDL for locked down memory
    PVOID userVirtualAddress;   // user virtual address
    PVOID ddVirtualAddress;     // display driver virtual address
    ULONG physicalAddress;      // physical address of memory
    ULONG byteLength;           // byte length of data to lock down
    ULONG bDontModifyMDL;       // if TRUE, MDL will not be allocated nor freed
    } NV_SYSMEM_SHARE_MEMORY;


typedef struct _NV_LOCK_DOWN_MEMORY
    {
    PVOID virtualAddress; // display driver virtual address
    ULONG byteLength;     // byte length of data to lock down
    PVOID pMdl;           // MDL for locked down memory
    } NV_LOCK_DOWN_MEMORY;

typedef struct _NV_UNLOCK_MEMORY
    {
    PVOID pMdl;           // MDL for memory to unlock
    } NV_UNLOCK_MEMORY;

//
// AGP memory block node structure.
//
typedef struct _AGP_MEM
    {
    ULONG   hContext;       // Addr context of process
    ULONG   cb;             // Size of memory region in bytes
    PVOID   VirtualAddress; // Based address of Virtual AGP buffer
    } *PAGP_MEM, AGP_MEM;

//
// Registry set structure
//
typedef struct _NV_REGISTRY_STRUCT
    {
    PWSTR keyName;          // Name of key in unicode string format
    PVOID keyVal;           // pointer to key value
    ULONG keyValSize;       // Size of Key Value;
    } *PNV_REGISTRY_STRUCT, NV_REGISTRY_STRUCT;


//
// Zw File I/O support
// We don't want to export the use of Zw functions for release builds
// define NV_ZW_FILE_IO_ENABLED to get the Zw functions enabled.
// 

//#define NV_ZW_FILE_IO_ENABLED

typedef struct _NV_ZW_IO_FILE_OUT
    {
    PVOID pvFileHandle;
    PVOID pvIoStatusBlock;
    PVOID pvBuffer;
    } *PNV_ZW_IO_FILE_OUT, NV_ZW_IO_FILE_OUT;

typedef struct _ZW_UNICODE_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
    } ZW_UNICODE_STRING, *PZW_UNICODE_STRING;

typedef struct _ZW_OBJECT_ATTRIBUTES
    {
    ULONG              Length;
    PVOID              RootDirectory;             // Handle
    PZW_UNICODE_STRING ObjectName;
    ULONG              Attributes;
    PVOID              SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID              SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
    } ZW_OBJECT_ATTRIBUTES, *PZW_OBJECT_ATTRIBUTES;

typedef struct _NV_ZW_CREATE_FILE_IN
    {
    ULONG                ulDesiredAccess;
    ZW_OBJECT_ATTRIBUTES ObjectAttributes;
    LARGE_INTEGER        liAllocationSize;
    ULONG                ulFileAttributes;
    ULONG                ulShareAccess;
    ULONG                ulCreateDisposition;
    ULONG                ulCreateOptions;
    PVOID                pvEaBuffer;
    ULONG                ulEaLength;

    ZW_UNICODE_STRING uiObjectName;
    WCHAR pwcObjectBuffer[257];
    } *PNV_ZW_CREATE_FILE_IN, NV_ZW_CREATE_FILE_IN;

typedef struct _NV_ZW_RW_FILE_IN
    {
    PVOID         pvFileHandle;
    PVOID         pvEvent;
    PVOID         pvApcRoutine;
    PVOID         pvApcContext;
    PVOID         pvBuffer;
    ULONG         ulLength;
    LARGE_INTEGER liByteOffset;
    PVOID         pvKey;
    } *PNV_ZW_RW_FILE_IN, NV_ZW_RW_FILE_IN;

typedef struct _NV_ZW_DEVICE_IO_CONTROL_FILE
    {
    PVOID hDevice;
    ULONG ulIoControlCode;
    PVOID pvInputBuffer;
    ULONG ulInputBufferSize;
    } *PNV_ZW_DEVICE_IO_CONTROL_FILE, NV_ZW_DEVICE_IO_CONTROL_FILE;

typedef ULONG (*LPNVZWCREATEFILEFUNCTION) ( PVOID FileHandle,
                                            ULONG DesiredAccess,
                                            PVOID ObjectAttributes,
                                            PVOID IoStatusBlock,
                                            PVOID AllocationSize,
                                            ULONG FileAttributes,
                                            ULONG ShareAccess,
                                            ULONG CreateDisposition,
                                            ULONG CreateOptions,
                                            PVOID EaBuffer,
                                            ULONG EaLength );


typedef ULONG (*LPNVZWWRITEFILEFUNCTION) ( PVOID  FileHandle,
                                           PVOID  Event,
                                           PVOID  ApcRoutine,
                                           PVOID  ApcContext,
                                           PVOID  IoStatusBlock,
                                           PVOID  Buffer,
                                           ULONG  Length,
                                           PVOID  ByteOffset,
                                           PVOID  Key );

typedef ULONG (*LPNVZWREADFILEFUNCTION)  ( PVOID  FileHandle,
                                           PVOID  Event,
                                           PVOID  ApcRoutine,
                                           PVOID  ApcContext,
                                           PVOID  IoStatusBlock,
                                           PVOID  Buffer,
                                           ULONG  Length,
                                           PVOID  ByteOffset,
                                           PVOID  Key );

typedef ULONG (*LPNVZWCLOSEFUNCTION) ( PVOID Handle );

typedef ULONG (*LPNVZWDEVICEIOCONTROLFILEFUNCTION) ( PVOID  FileHandle,
                                                     PVOID  Event,
                                                     PVOID  ApcRoutine,
                                                     PVOID  ApcContext,
                                                     PVOID  IoStatusBlock,
                                                     ULONG  IoControlCode,
                                                     PVOID  InputBuffer,
                                                     ULONG  InputBufferLength,
                                                     PVOID  OutputBuffer,
                                                     ULONG  OutputBufferLength );

typedef struct _NV_ZW_FILE_IO_FUNCS
    {
    LPNVZWCREATEFILEFUNCTION pvZwCreateFile;
    LPNVZWWRITEFILEFUNCTION pvZwWriteFile;
    LPNVZWREADFILEFUNCTION pvZwReadFile;
    LPNVZWCLOSEFUNCTION pvZwClose;
    LPNVZWDEVICEIOCONTROLFILEFUNCTION pvZwDeviceIoControlFile;
    } *PNV_ZW_FILE_IO_FUNCS, NV_ZW_FILE_IO_FUNCS;

//
// OS Version Information Support
// (Some header information stolen from NTDDK.H)
//

typedef struct _NV_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} NV_UNICODE_STRING;
typedef NV_UNICODE_STRING *PNV_UNICODE_STRING;

typedef struct _NV_OS_VERSION_INFO
    {
    ULONG  dwMajorVersion;
    ULONG  dwMinorVersion;
    ULONG  dwBuildNumber;
    ULONG  dwBuildType;
    } *PNV_OS_VERSION_INFO, NV_OS_VERSION_INFO;

#if (_WIN32_WINNT >= 0x0500)
//
// System Memory Information structure
//
typedef struct _NV_SYSMEM_INFO
    {
    ULONGLONG SystemMemorySize;      // Physical memory size in bytes
    ULONGLONG AgpAllocationLimit;    // Max recommended size in bytes for committed AGP meme
    } *PNV_SYSMEM_INFO, NV_SYSMEM_INFO;
#endif // #if (_WIN32_WINNT >= 0x0500)


typedef struct _NV_COMMON_DEVICE_INFO
    {
    ULONG  ulDeviceReference;
    ULONG  ulEnableDualView;
    ULONG  ulDualViewSecondary;

    NV_OS_VERSION_INFO OsVersionInfo;
#if (_WIN32_WINNT >= 0x0500)
    NV_SYSMEM_INFO     SysMemInfo;
#endif
    } *PNV_COMMON_DEVICE_INFO, NV_COMMON_DEVICE_INFO;

typedef struct _RESOLUTION_INFO
{
    ULONG ulDisplayWidth;           // width  
    ULONG ulDisplayHeight;          // Height
    ULONG ulDisplayRefresh;         // refresh rate 
    ULONG ulDisplayPixelDepth;      // Color Depth
} RESOLUTION_INFO;

//
// Possible values for ulOption in the HEAD_RESOLUTION_INFO structure
// Currently only one flag is being used.
//
#define HEAD_RESOLUTION_OPTION_DONT_BACKOFF 1

typedef struct _HEAD_RESOLUTION_INFO
{
    ULONG ulDisplayWidth;           // width  
    ULONG ulDisplayHeight;          // Height
    ULONG ulDisplayRefresh;         // refresh rate 
    ULONG ulDisplayPixelDepth;      // Color Depth
    ULONG ulHead;                     // Whether 0 or 1. This is the physical head number
    ULONG ulDeviceMask;             // Bitmask of Device.
    ULONG ulDeviceType;             // Device type of the head.
    ULONG ulTVFormat;
    ULONG ulOption;                 // if DONT_BACKOFF is set, then if the requested mode is not supported in
                                    // the EDID, ignores the EDID and returns the timing without backing off.
} HEAD_RESOLUTION_INFO;


typedef struct _dac_timing_values
{  
    unsigned int HorizontalVisible; 
    unsigned int VerticalVisible;
    unsigned int Refresh;
    unsigned int HorizontalTotal; 
    unsigned int HorizontalBlankStart; 
    unsigned int HorizontalRetraceStart; 
    unsigned int HorizontalRetraceEnd; 
    unsigned int HorizontalBlankEnd;
    unsigned int VerticalTotal; 
    unsigned int VerticalBlankStart; 
    unsigned int VerticalRetraceStart; 
    unsigned int VerticalRetraceEnd; 
    unsigned int VerticalBlankEnd;
    unsigned int PixelClock;
    unsigned int HSyncpolarity; 
    unsigned int VSyncpolarity; 
} DAC_TIMING_VALUES;

//
// Possible values for the registry entry "GDIModePruning".
//
// Absent or 0: Driver always provides EDID mode pruning protection.
// 1:   For desktop or laptop systems, for CRT, for the
//      standard mode device and the primary device in clone mode and
//      both devices in XP DualView mode, lets the GDI handle EDID 
//      mode pruning via "Hide Modes" monitor checkbox.
// 2:   For desktop systems only, for CRT or DFP, for the
//      standard mode device and the primary device in clone mode and
//      both devices in XP DualView mode, lets the GDI handle EDID 
//      mode pruning via "Hide Modes" monitor checkbox.
//
#define GDI_MODE_PRUNING_NONE                       0
#define GDI_MODE_PRUNING_DESKTOP_LAPTOP_CRT         1
#define GDI_MODE_PRUNING_DESKTOP_CRT_DFP            2



//
// structures used forr NT4 multi device layer
//
typedef struct _QUERY_NUM_OF_DEVICE_OBJECTS
{
    union
    {
        IN  HANDLE hDriver;
        IN  PVOID  pvDevObj;
        OUT ULONG  ulNumDevObj;
    };
} QUERY_NUM_OF_DEVICE_OBJECTS;

typedef struct _GET_DEVICE_OBJECTS
{
    union
    {
        IN  HANDLE hDriver;
        IN  PVOID  pvDevObj;
    };
    IN  ULONG  ulNumDevObj;
    union
    {
        OUT  HANDLE ahDriver[1];
        OUT  PVOID  apvDevObj[1];
    };
    
} GET_DEVICE_OBJECTS;

#endif // _DSPIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modehw.c ===
//
// modehw.c -  OS specific NV register access routines for mode set code.
//
// These Win NT specific routines access the NV3 through a series of NV
// engine pointers contained in the global HwDeviceExtension and frame
// buffer pointer, fbAddr.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"
#include "nv3a_ref.h"

#include "modes.h"

PHW_DEVICE_EXTENSION HwDeviceExtension;
PHWREG fbAddr;

//******************************************************************************
// External function declarations
//******************************************************************************

// write a dword value to a fb address
VOID WriteFb32(U032 datum, U032 addr)
{
    MEM_WR32(addr, datum);
}


// read a dword value from a fb address
U032 ReadFb32(U032 addr)
{
    return MEM_RD32(addr);
}


// write a dword value to an NV register
// assume extended CRTC registers are unlocked
#pragma warning(disable: 4296)

VOID WritePriv32(U032 datum, U032 addr)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR32(PRMVIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR32(PRMCIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRAMDAC) && addr < DEVICE_BASE(NV_PRAMDAC) + DEVICE_EXTENT(NV_PRAMDAC))
    {
        PRAMDAC_REG_WR32(PRAMDAC_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PFB) && addr < DEVICE_BASE(NV_PFB) + DEVICE_EXTENT(NV_PFB))
    {
        PFB_REG_WR32(PFB_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PMC) && addr < DEVICE_BASE(NV_PMC) + DEVICE_EXTENT(NV_PMC))
    {
        PMC_REG_WR32(PMC_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PEXTDEV) && addr < DEVICE_BASE(NV_PEXTDEV) + DEVICE_EXTENT(NV_PEXTDEV))
    {
        PEXTDEV_REG_WR32(PEXTDEV_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PBUS) && addr < DEVICE_BASE(NV_PBUS) + DEVICE_EXTENT(NV_PBUS))
    {
        PBUS_REG_WR32(PBUS_Base, addr, datum);
        return;
    }

    // catch bad ranges
    //DebugBreakPoint();
}


// read a dword value from an NV register
U032 ReadPriv32(U032 addr)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        return PRMVIO_REG_RD32(PRMVIO_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        return PRMCIO_REG_RD32(PRMCIO_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PRAMDAC) && addr < DEVICE_BASE(NV_PRAMDAC) + DEVICE_EXTENT(NV_PRAMDAC))
    {
        return PRAMDAC_REG_RD32(PRAMDAC_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PFB) && addr < DEVICE_BASE(NV_PFB) + DEVICE_EXTENT(NV_PFB))
    {
        return PFB_REG_RD32(PFB_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PMC) && addr < DEVICE_BASE(NV_PMC) + DEVICE_EXTENT(NV_PMC))
    {
        return PMC_REG_RD32(PMC_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PEXTDEV) && addr < DEVICE_BASE(NV_PEXTDEV) + DEVICE_EXTENT(NV_PEXTDEV))
    {
        return PEXTDEV_REG_RD32(PEXTDEV_Base, addr);
    }
    if (addr >= DEVICE_BASE(NV_PBUS) && addr < DEVICE_BASE(NV_PBUS) + DEVICE_EXTENT(NV_PBUS))
    {
        return PBUS_REG_RD32(PBUS_Base, addr);
    }

    // catch bad ranges
    //DbgBreakPoint();

	return(0);
}

#pragma warning(default: 4296)

// write a data word to Priveledged IO
VOID WriteIndexed(U032 addr, U016 datum)
{
    //
    // Keep it 8bit to be safe; index in lower byte, data in upper
    //
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, datum & 0xFF);
        PRMVIO_REG_WR08(PRMVIO_Base, addr+1, (datum >> 8) & 0xFF);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, datum & 0xFF);
        PRMCIO_REG_WR08(PRMCIO_Base, addr+1, (datum >> 8) & 0xFF);
        return;
    }

    // catch bad ranges
    //DbgBreakPoint();

}


// write a data byte to Priveledged IO
VOID WritePriv08(U032 addr, U008 datum)
{
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, datum);
        return;
    }
    if (addr >= DEVICE_BASE(NV_USER_DAC) && addr < DEVICE_BASE(NV_USER_DAC) + DEVICE_EXTENT(NV_USER_DAC))
    {
        USERDAC_REG_WR08(USERDAC_Base, addr, datum);
        return;
    }

    // catch bad ranges
    //DbgBreakPoint();

}

// read a data word from Priveledged IO
U016 ReadIndexed(U032 addr, U008 reg)
{
    U016   datum;

    //
    // Return the data in the upper byte, index in the lower
    //
    if (addr >= DEVICE_BASE(NV_PRMVIO) && addr < DEVICE_BASE(NV_PRMVIO) + DEVICE_EXTENT(NV_PRMVIO))
    {
        PRMVIO_REG_WR08(PRMVIO_Base, addr, reg);
        datum = (PRMVIO_REG_RD08(PRMVIO_Base, addr+1) << 8) & 0xFF00;
        datum |= reg;
        return datum;
    }
    if (addr >= DEVICE_BASE(NV_PRMCIO) && addr < DEVICE_BASE(NV_PRMCIO) + DEVICE_EXTENT(NV_PRMCIO))
    {
        PRMCIO_REG_WR08(PRMCIO_Base, addr, reg);
        datum = (PRMCIO_REG_RD08(PRMCIO_Base, addr+1) << 8) & 0xFF00;
        datum |= reg;
        return datum;
    }

    // catch bad ranges
    //DbgBreakPoint();

	return(0);
}


// end of modehw.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modes.h ===
//
// MODES.H - Header file for mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines and structures for use with the 'C' based modeset code.
//
//

#ifdef DOS_COMPILE
typedef unsigned long U032;
typedef unsigned short U016;
typedef unsigned char U008;
#define VOID void
#endif


#define PACKED  0
#define PLANAR  1

#define NVRM_ACCESS         0x38
#define NVRM_ACCESS_MASK    0x01
#define NVRM_IDENT          0x00
#define NVRM_ADDRESS        0x02
#define NVRM_DATA           0x04
#define NVRM_DATA32         0x06
#define NVRM_SELECT_MASK    0x06    // Mask for decode bits
#define NVRM_SELECT         0x01    // Least signifcant bit is 1

#ifdef DOS_COMPILE
//
// These defines are the standard NV defines... the appropriate include
// file should be utilized, rather than these values.
//
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB       0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB       0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB       0x00000002 /* RW--V */
#define NV_PRMVIO_MISC__WRITE              0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                      0x000C03c4 /* RW-1R */
#define NV_PRMVIO_GRX                      0x000C03ce /* RW-1R */
#define NV_PFB_BOOT_0                      0x00100000 /* RW-4R */
#define NV_PFB_CONFIG_0                    0x00100200 /* RW-4R */
#define NV_PRMCIO_ARX                      0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ         0x006013c1 /* R--1R */
#define NV_PRMCIO_CRX__COLOR               0x006013d4 /* RW-1R */
#define NV_PRMCIO_INP0__COLOR              0x006013da /* R--1R */
#define NV_PRAMDAC_VPLL_COEFF              0x00680508 /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT        0x0068050C /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL         0x00680600 /* RW-4R */
#define NV_USER_DAC_PIXEL_MASK             0x006813C6 /* RWI1R */
#define NV_USER_DAC_READ_MODE_ADDRESS      0x006813C7 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS     0x006813C8 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA           0x006813C9 /* RW-1R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO  28    /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE 16    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE     12    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE      4    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE     8    /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC          20    /* RWIVF */
#define NV_PFB_CONFIG_0_TILING                  12    /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DISABLED    0x00000001 /* RWI-V */
#endif // DOS_COMPILE


#define CRYSTAL_FREQ143         14318180           // 14.318,180 MHz
#define CRYSTAL_FREQ135         13500000           // 13.500,180 MHz
#define CRYSTAL_FREQ143KHZ      14318              // 14318 kHz
#define CRYSTAL_FREQ135KHZ      13500              // 13500 kHz

//
// VBE3.0-based CRTC Timings Table
//
typedef struct gtf_timings_structure
{
    U016    horiz_total;
    U016    horiz_start;
    U016    horiz_end;
    U016    vertical_total;
    U016    vertical_start;
    U016    vertical_end;
    U008    flags;
    U032    dot_clock;
    U016    refresh;
} GTF_TIMINGS, *PGTF_TIMINGS;

//
// DMT Override Table
//
typedef struct DMT_Overrides_structure
{
    U016    DotClock;
    U016    Polarity;
    U016    CR0;
    U016    CR2;
    U016    CR3;
    U016    CR4;
    U016    CR5;
    U016    CR6;
    U016    CR7;
    U016    CR10;
    U016    CR11;
    U016    CR15;
    U016    CR16;

} DMT_OVERRIDES, *PDMT_OVERRIDES;

//
// State flags for GTF structure
//
#define GTF_FLAGS_SINGLE_SCANNED    0x00
#define GTF_FLAGS_DOUBLE_SCANNED    0x01
#define GTF_FLAGS_NON_INTERLACED    0x00
#define GTF_FLAGS_INTERLACED        0x02
#define GTF_FLAGS_HSYNC_POSITIVE    0x00
#define GTF_FLAGS_HSYNC_NEGATIVE    0x04
#define GTF_FLAGS_VSYNC_POSITIVE    0x00
#define GTF_FLAGS_VSYNC_NEGATIVE    0x08


// Standard VGA Mode Table Structure
typedef struct _seq_
{
    U008 ClockMode;
    U008 MapMask;
    U008 FontAddr;
    U008 MemMode;
} SEQ;

typedef struct  _crtc_
{
    U008   HTotal;
    U008   HDispEnd;
    U008   HBlankS;
    U008   HBlankE;
    U008   HSyncS;
    U008   HSyncE;
    U008   VTotal;
    U008   Overflow;
    U008   PresetRowScan;
    U008   CellHeight;
    U008   CursorS;
    U008   CursorE;
    U008   RegenSHigh;
    U008   RegenSLow;
    U008   CursorPosHigh;
    U008   CursorPosLow;
    U008   VSyncS;
    U008   VSyncE;
    U008   VDispE;
    U008   RowOffset;
    U008   ULineRow;
    U008   VBlankS;
    U008   VBlandE;
    U008   Mode;
    U008   LineCompare;
} CRTC;

typedef struct  _gr_
{
    U008   SetReset;
    U008   EnableSetReset;
    U008   ColorCmp;
    U008   ROP;
    U008   ReadMap;
    U008   Mode;
    U008   Misc;
    U008   CDC;
    U008   BitMask;
} GR;

// Standard VGA Mode Table format.
typedef struct _vga_mode_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U016  RegenLenght;
    SEQ     seq_regs;              // SR1-4
    U008   PT_Misc;               // Misc Register
    CRTC    crtc_regs;             // CR0-18
    U008   PT_ATC[20];            // Attribute Controller
    GR      gr_regs;               // GR0-8
} VGATBL;

// Indexes into the clock table
#define MAX_DCLK    0x1F            // 229.50 Mhz
#define MAX_ATC     0x16            // 108 Mhz

#define    CLKID_50_35     0x00
#define    CLKID_56_64     0x01
#define    CLKID_33_25     0x02
#define    CLKID_52        0x03
#define    CLKID_80        0x04
#define    CLKID_63        0x05
#define    CLKID_EXT       0x06
#define    CLKID_75        0x07
#define    CLKID_25_175    0x08
#define    CLKID_28_322    0x09
#define    CLKID_31_5      0x0A
#define    CLKID_36        0x0B
#define    CLKID_40        0x0C
#define    CLKID_44_9      0x0D
#define    CLKID_50        0x0E
#define    CLKID_65        0x0F
#define    CLKID_108       0x10        // Requires clock doubler
#define    CLKID_135       0x11        // Requires clock doubler
#define    CLKID_49_5      0x12
#define    CLKID_56_25     0x13
#define    CLKID_78_75     0x14
#define    CLKID_94_5      0x15
#define    CLKID_108_5     0x16        // Requires clock doubler
#define    CLKID_35_5      0x17
#define    CLKID_158       0x18        // Requires clock doubler
#define    CLKID_55_86     0x19
#define    CLKID_20        0x1A
#define    CLKID_27_93     0x1B
#define    CLKID_32_5      0x1C
#define    CLKID_12_588    0x1D
#define    CLKID_81_62     0x1E
#define    CLKID_219_566   0x1F
#define    CLKID_172_798   0x20
#define    CLKID_193_156   0x21
#define    CLKID_229_5     0x22
#define    CLKID_136_36    0x23

// Video Mode Control Structure
typedef struct _vmode_
{
    U016  mdVMode;                // Mode Number of this mode
    U008   mdMode;                 // Internal Mode Number
    U008   mdIMode;                // Standard Mode Table Index
    U008   mdEMode;                // Extended Mode Table Index
    U008   mdTVMode;               // TV Mode Table Index
    U008   mdCMode;                // Extended CRTC Override Index
    U008   mdBPP;                  // Bits per Pixel
    U016  mdXRes;                 // X resolutio
    U016  mdYRes;                 // Y resolutionn
    U016  mdRowOff;               // Scanline Row Offset
    U016  mdMaxDotClock;          // Maximum DCLK

} MODEDESC;


typedef struct _ext_regs_
{
                            // ++++------- Reserved
                            // |||| +----- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| |+---- CR1C[2] - Sequential Chain 4
                            // |||| ||+--- CR1C[1] - Page Select Control
                            // |||| |||+-- CR1A[0] - Address Wrap
    U008   xrFlags;         // VVVV VVVV
                            // 7654 3210

                            // +---------- NV_PRAMDAC_GENERAL_CONTROL[12] - 565_MODE
                            // |+++------- NV_PRAMDAC_GENERAL_CONTROL[20] - DAC Width
                            // |||| +----- CR25[5] - Bit 11 of offset
                            // |||| |+++-- CR19[7:5] - Bits 8->10 of Offset
    U008   xrOffset;        // VVVV VVVV
                            // 7654 3210

                            // ++--------- CR2D[3:2] - Bit 8 of HRetrace & HBlank Starts
                            // ||+-------- CR1A[2] - Large Screen bit
                            // |||+------- CR25[4] - Bit 6 of HBlank End
                            // |||| ++---- Bit 10 of VBlank & VRetrace Start
                            // |||| ||++-- VDisp End, VTotal
    U008   xrVOver;         // VVVV VVVV
                            // 7654 3210

                            // ++--------- CR2D[1:0] - Bit 8 of DHisp End and HTotoal
                            // ||++------- CR1C[4:3] - Optimized chain-4 write/read access
                            // |||| +----- CR28[3] - NV_PRAMDAC_PLL_COEFF_SELECT[28]
                            // |||| |                VCLK Divide by 1 or 2
                            // |||| |+---- CR28[2] - Linear/Tile mode
                            // |||| ||++-- CR28[1:0] - Pixel Format
    U008   xrPixFmt;        // VVVV VVVV
                            // 7654 3210

    U008   xrVOffset;      // CR13 - VGA Offset register
    U008   xrIntlace;      // CR39 - Interlace Half Field Start
    U016  xrRegenLength;   // Override of PT_RegenLength (res+color depth specific)
    U008   xrClkSel;       // Pixel Clock Select

} EXTREGS;

typedef struct _tv_regs_
{
    U008   tvIntlace;              // CRTC[39] (Interlace Half Field Start)
    U008   tvDecimate_NTSC;        // CRTC[29] (Decimate for TV)
    U008   tvHT_NTSC;              // CRTC[00] (Horiztonal total for NTSC)
    U008   tvHRS_NTSC;             // CRTC[04] (Horizontal retrace start for NTSC)
    U008   tvVT_NTSC;              // CRTC[06] (Vertical total for NTSC)
    U008   tvVO_NTSC;              // CRTC[07] (Vertical overflow for NTSC)
    U008   tvVRS_NTSC;             // CRTC[10] (Vertical retrace start for NTSC)
    U008   tvHDE_NTSC;             // CRTC[01] (Horizontal Display End)
    U008   tvHBS_NTSC;             // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_NTSC;             // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_NTSC;             // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_NTSC;             // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_NTSC;             // CRTC[12] (Vertical Display End)
    U008   tvVBS_NTSC;             // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_NTSC;             // CRTC[16] (Vertical Blank End)
    U008   tvDecimate_PAL;         // CRTC[29] (Decimate for TV)
    U008   tvHT_PAL;               // CRTC[00] (Horiztonal total for PAL)
    U008   tvHRS_PAL;              // CRTC[04] (Horizontal retrace start for PAL)
    U008   tvVT_PAL;               // CRTC[06] (Vertical total for PAL)
    U008   tvVO_PAL;               // CRTC[07] (Vertical overflow for PAL)
    U008   tvVRS_PAL;              // CRTC[10] (Vertical retrace start for PAL)
    U008   tvHDE_PAL;              // CRTC[01] (Horizontal Display End)
    U008   tvHBS_PAL;              // CRTC[02] (Horizontal Blank Start)
    U008   tvHBE_PAL;              // CRTC[03] (Horizontal Blank End)
    U008   tvHRE_PAL;              // CRTC[05] (Horizontal Retrace End)
    U008   tvVRE_PAL;              // CRTC[11] (Vertical Retrace End)
    U008   tvVDE_PAL;              // CRTC[12] (Vertical Display End)
    U008   tvVBS_PAL;              // CRTC[15] (Vertical Blank Start)
    U008   tvVBE_PAL;              // CRTC[16] (Vertical Blank End)

} TVREGS;

// CRTC Override Structure. This structure overrides the settings selected
// from the standard modeset mode table.
//
typedef struct _crtc_ovr_
{
    U008   columns;
    U008   rows;
    U008   char_height;
    U008   CO_Misc;                // Misc Register
    U008   CO_ClockMode;           // SR1
    U008   HTotal;                 // CR00
    U008   HDispEnd;               // CR01
    U008   HBlankS;                // CR02
    U008   HBlankE;                // CR03
    U008   HSyncS;                 // CR04
    U008   HSyncE;                 // CR05
    U008   VTotal;                 // CR06
    U008   Overflow;               // CR07
    U008   CO_CellHeight;          // CR09
    U008   CO_VSyncStart;          // CR10
    U008   VSyncE;                 // CR11
    U008   VDispE;                 // CR12
    U008   CO_VBlankStart;         // CR15
    U008   VBlandE;                // CR16

}CRTC_OVERRIDE;

//
// Fifo settings
//
typedef struct _modeset_fifo_
{
    U016  Freq;                   // Maximum frequency for these water marks
    U008   LowWaterMark64;         // Low water mark for 64 bit bus
    U008   BurstSize64;            // Burst size for 64 bit bus
    U008   LowWaterMark128;        // Low water mark for 128 bit bus
    U008   BurstSize128;           // Burst size for 128 bit bus

} MODESET_FIFO;

//
// CRTC access state (for dos compile)
//
typedef struct _save_astate_
{
    U016   crtc_addr;          // CRTC Address
    U032   nv_address;         // 32-bit NV address
    U008   access_bits;        // Access Control Bits
    U008   access_reg;         // Access Register (NVRM_ACCESS)
    U016   data_low;           // Low 32-bits of data register
} ACCESS_STATE;


//
// Modeset function prototypes
//
VOID NvPost(VOID);
U016 VBESetMode(U016, PGTF_TIMINGS,PDMT_OVERRIDES,U016);         // VESA SetMode
U016 VBESetRefresh(PGTF_TIMINGS);
MODEDESC *ValidateMode(U016 );    // Validate VESA Mode
U008 isTV(VOID);
U008 OEMValidateMode(MODEDESC *);
U016 OEMGetMemSize(VOID);
VOID SaveNVAccessState(ACCESS_STATE *);
VOID RestoreNVAccessState(ACCESS_STATE *);
U032 ReadPriv32(U032 );
U016 ReadIndexed(U032 , U008 );
VOID WriteIndexed(U032, U016);
VOID OEMPreSetRegs(VOID);
VOID SetRegs(MODEDESC *);
VOID LoadIndexRange(U032, U008, U008, U008 *);
VOID ATCOff(VOID);
VOID ATCOn(VOID);
VOID OEMSetRegs(MODEDESC *);
VOID FullCpuOn(VOID);
VOID FullCpuOff(VOID);
U032 CalcMNP(U016 *);
VOID OEMSetClock(U016 );
VOID WritePriv32(U032 , U032 );
VOID LoadDefaultATCAndSavePtr(U008 *);
VOID LoadDefaultRAMDAC(MODEDESC *);
VOID LoadPalette(MODEDESC *);
VOID LoadColorDACTable(VOID);
VOID LoadColor256DAC(VOID);
VOID LoadIdentityDAC(VOID);
VOID WriteColor(U008 );
VOID WriteColor2(U016 , U016 , U016 , U016 );
VOID FixLowWaterMark(U016 );
VOID SetDACClock(U032 );
VOID WritePriv08(U032 , U008 );
U016 h2i(U008 *);                // Hex 2 Integer
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modehw.h ===
//
// MODEHW.H - Header file for OS specific portions of mode sets in 'C'.
//
// Copyright (c) 1997 - NVidia Corp.
// All Rights Reserved.
//
// Defines for accessing NV registers in the 'C' based modeset code.
//
//
VOID WriteFb32(U032 datum, U032 addr);
U032 ReadFb32(U032 addr);
VOID WritePriv32(U032 datum, U032 addr);
U032 ReadPriv32(U032 addr);
VOID WriteIndexed(U032 addr, U016 datum);
VOID WritePriv08(U032 addr, U008 datum);
U016 ReadIndexed(U032 addr, U008 reg);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\monitor.h ===
//******************************************************************************
// 
// Copyright (c) 1998  NVidia Corporation
// 
// Module Name:
// 
//     monitor.h
// 
// Environment:
// 
// Revision History:
// 
//******************************************************************************

//******************************************************************************
// 
// Copyright (c) 1998  NVidia Corporation. All Rights Reserved
// 
//******************************************************************************

#define NV_MONITOR_VGA  0
#define NV_MONITOR_NTSC 2
#define NV_MONITOR_PAL  3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\multidev.h ===
#ifndef _INCLUDE_MULTIDEV
#define _INCLUDE_MULTIDEV


ULONG	ulQueryNumDevices(PVOID pvDeviceObject);
BOOLEAN bGetDevices(PVOID pvDeviceObject, PVOID *ppvDevObjs);

#endif // _INCLUDE_MULTIDEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\modesetNT.c ===
//
// modeset.c -  Program to set a VESA mode. Assumes the controller is
//              already initialized.
//
// Copyright (c) 1997 - NVidia Corporation. All Rights Reserved.
//

#ifndef NTMINIPORT

#ifdef DOS_COMPILE
#include    <stdio.h>
#include    <stdlib.h>
#else
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <os.h>
#include <vga.h>
#endif // DOS_COMPILE

#include    "modes.h"
#include    "modedata.c"
#include    "modehw.h"
#include "nvhw.h"

#else

//*****************************************************************************
//
// NV1/NV3/NV4 conventions...
//
//       This modeset code was originally designed to be compiled for each
//       version of the chip (NV1/NV3/NV4).  However, this miniport was designed
//       to work with ALL versions of the chip.  That is, the original modeset
//       code had to be compiled for each chip.  But since this miniport
//       determines which chip it's running on at RUN time (i.e. we don't
//       compile several versions of the miniport) we need to use the following
//       convention:
//
//          THIS MODULE SHOULD ONLY CONTAIN NV3 SPECIFIC CODE
//          (OR CODE THAT HAS NOT CHANGED ACROSS CHIPS) !!
//
//       Mainly because NV_REF.H already includes NV3_REF.H.
//       For code which is different from NV3, that code
//       should exist separately in NV4.C/NV5.C/...etc...
//
//       We'll follow the convention that the Miniport decides at runtime
//       which chip it's running on (i.e. only ONE miniport instead of
//       compiling several versions for each type of chip).
//
//*****************************************************************************

//*****************************************************************************
//
// ModeSet Code differences between chips:
//
//       NV3:   - CRTC registers are locked using NV_PRMVIO_SR_LOCK
//                (See OEMEnableExtension/OEMDisableExtension)
//
//              - 565 mode is set with PRAMDAC_GENERAL_CONTROL_565_MODE
//                (See OEMSetRegs)
//
//              - PRAMDAC_PLL_COEFF_SELECT and PRAMDAC_PLL_SETUP_CONTROL
//                bit definitions are different than NV4
//
//              - FixLowWaterMark is different than NV4 version
//
//              - OEMGetMemSize
//
//       NV4:   - CRTC registers are locked using NV_CIO_SR_LOCK_INDEX.
//                (See NV4_OEMEnableExtenions/NV4_OEMDisableExtension)
//
//              - 565 mode is set with NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE
//                (See NV4_OEMSetRegs)
//
//              - PRAMDAC_PLL_COEFF_SELECT and PRAMDAC_PLL_SETUP_CONTROL
//                bit definitions are different than NV3
//
//              - TV functionality has changed
//
//              - FixLowWaterMark is different than NV3 version
//
//              - NV4_OEMGetMemSize
//
//*****************************************************************************


#include <miniport.h>
#include <nv_ref.h>
#include <ntddvdeo.h>
#include <video.h>
#include "nv.h"
#include "modes.h"
#include "modedata.c"
#include "modehw.h"

// Debug level values and output macro
#define DEBUGLEVEL_TRACEINFO    0     // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO    1     // For informational debug setup info
#define DEBUGLEVEL_USERERRORS   2     // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS     3     // For debug warning info
#define DEBUGLEVEL_ERRORS       4     // For debug error info
#define DBG_PRINT_STRING_VALUE(l, s, v) VideoDebugPrint(((l), s ## " 0x%x\n", (v)))

#endif // NTMINIPORT

//******************************************************************************
// Forward declarations
//******************************************************************************

VOID ProgramTV( U008 tvmode );
VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides);

//******************************************************************************
// External variables
//******************************************************************************

// global device extension pointer - We need it to distinguish between NV3/NV4..
extern PHW_DEVICE_EXTENSION HwDeviceExtension;
extern CRTC_OVERRIDE crt_override[];
extern MODEDESC mib[];            // Our Mode List

//******************************************************************************
// External functions
//******************************************************************************

extern VOID NV_OEMSetRegs(MODEDESC *);
extern VOID NV_FixLowWaterMark(U016);
extern U016 NV_OEMGetMemSize(VOID);
extern VOID NV_OEMEnableExtensions(PHW_DEVICE_EXTENSION);
extern VOID NV_OEMDisableExtensions(PHW_DEVICE_EXTENSION);

U016 VBESetModeEx(PHW_DEVICE_EXTENSION pHwDevExt, U016 vbeMode, PGTF_TIMINGS pVbeTimings, PDMT_OVERRIDES pDMTOverrides, U016 UseDMTFlag)
{
    HwDeviceExtension = pHwDevExt;
    return VBESetMode(vbeMode, pVbeTimings, pDMTOverrides, UseDMTFlag);
}

VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION pHwDevExt)
{
    HwDeviceExtension = pHwDevExt;
}



//******************************************************************************
//
// Function: WakeUpCard
//
// Description:
//
//           NV4 or better:
//
//           When RmInitNvDevice() is called during NVInitialize(),
//           it tries to detect if a monitor, flat panel, or TV is connected.
//           It does this when InitDac() calls dacMonitorConnectStatus(). 
//
//           However, dacMonitorConnectStatus() seems to fail on some cards
//           if the card is secondary and the monitor is not 'alive'
//           The end result is that dacMonitorConnectStatus() incorrectly identifies
//           the secondary card. This results in the secondary monitor coming up blank.
//
//           This does NOT happen on Win9x, since by that time, the secondary monitor
//           is already 'alive' and in text mode.  But under WinNT, the secondary
//           monitor has not yet been initialized.
//          
//           Aos, this does NOT happen on all cards (ie...my TNT2 works without this workaround)
//           but DOES happen on my NV4.    
//
//           So, under NT, to make sure that dacMonitorConnectStatus correctly identifies 
//           the monitor and that the 'monitor' is awake, we'll touch just enough registers
//           on the card to make sure it's alive.
//                   
//*****************************************************************************


VOID WakeUpCard(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    MODEDESC    *minfo;             

    //*************************************************************************
    // Mib[1] is the entry for 640x480
    //*************************************************************************

    minfo = &mib[1];

    //*************************************************************************
    // NV3 still uses the OLD style modeset code, and does NOT go thru
    // the RM to set the mode.  Only do this for NV4 or better.
    //*************************************************************************

    if  (HwDeviceExtension->ulChipID != NV3_DEVICE_NV3_ID)
        {
        //**********************************************************************
        // Make sure card is 'active'.  This code doesn't completely set a mode,
        // but it touches enough registers to make sure that dacMonitorConnectStatus()
        // in the RM will succeed, and correctly detect the monitor.
        //**********************************************************************

        SetGlobalHwDev(HwDeviceExtension);
        NV_OEMEnableExtensions(HwDeviceExtension);        
        SetRegs(minfo);             
        }
        
    }



//
// VBE Function 02h - Vesa SetMode routine.
//
// Used to set a VESA mode. This routine will not accept standard
// VGA Mode numbers, nor will it load/support fonts. This means that
// TTY output is DISABLED.
//
// Entry:   U016 mode             // VESA mode to be set
//
//          +------------------ Don't clear screen (1=Save Screen)
//          |+----------------- Linear Frame Buffer (1=Enable)
//          ||++--------------- Reserved for VBE/AF
//          ||||+-------------- User Refresh (1=User Specified)
//          |||||++------------ Reserved
//          |||||||+-++++++++-- Mode Number
//          VVVVVVVV VVVVVVVV
//          00000000 00000000
//
//          111111
//          54321098 76543210
//
//          CRTCInfoBlk *cib        // Pointer to CRTCInfoBlock Structure
//
// Exit:    U016 rc               // VESA Error Status
//


U016 VBESetMode(U016 mode, PGTF_TIMINGS timings, PDMT_OVERRIDES pDMTOverrides, U016 UseDmtFlag)
{
    MODEDESC    *minfo;             // Mode Information
    U016        wv;
    U016        rc = 0x014F;        // Default to FAIL
    U032        data32;
    U016        data,shadow;    


    NV_OEMEnableExtensions(HwDeviceExtension);          // Unlock the registers

    //**************************************************************************
    // Do this for flat panel only
    //**************************************************************************

    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {

#define NV_PRAMDAC_FP_DEBUG_0                            0x00680880 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX                0x00000002 /* RWI-V */

        // de-couple vertical sync from flat panel while setting mode
        data32 = ReadPriv32(NV_PRAMDAC_FP_DEBUG_0); 
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
        WritePriv32(data32, NV_PRAMDAC_FP_DEBUG_0 );
        }



    if (HwDeviceExtension->FlatPanelIsPresent == TRUE)
        {
    
        shadow = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x21);        // read shadow lock (is there really no define for this reg?)

        data = shadow | 0xC800;         // Enable loading of CRTC's: bit 7 Horiz shadow, bit 3 Vert shadow
                                    // bit 6 = scanline doubling shadow
        WriteIndexed(NV_PRMCIO_CRX__COLOR, data);


        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        data = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09);         // read scanline double
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (data &= ~0x8000));   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        while (PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08);     // wait for active display
        while (!(PRMCIO_REG_RD08(PRMCIO_Base, NV_PRMCIO_INP0__COLOR) & 0x08));  // wait for retrace start
    
        // shadow = CR21
        shadow &= ~0x4000;  // shadow the scanline double bit
        WriteIndexed(NV_PRMCIO_CRX__COLOR, (shadow |= 0x8800)); // allow horiz & vert write-thru
        }    


    if ((minfo = ValidateMode((U016) (mode & 0x1FF))) != (MODEDESC *) NULL)
    {
        // Mode is maintained here, for the linear/regen flags
        // minfo now points to everything we need to program the mode.

        // Set the mode
        // SetBIOSVariables(minfo); // Set low memory variables from parms.
        ATCOff();                   // Screen off
        OEMPreSetRegs();            // Set up DAC for programming palette.

        SetRegs(minfo);             // Set the VGA Registers
        FullCpuOn();

        NV_OEMSetRegs(minfo);          // Set the OEM Registers
        LoadPalette(minfo);

        // Not in VESA modes...
        /*
        LoadSysFont(minfo);      // Not in these VESA modes...

        if (!(mode & 0x8000))     // Save the screen?
          OEMClearScreen();       // Clear the buffer

        if (mode & 0x4000)
          VBESetLinearFB();
        */

        // Use DMT override values instead of GTF timings
        if (UseDmtFlag)
            {
            // Mode now successfully set .. Set DMT override values
            SetDMTOverrideValues(pDMTOverrides);
            }

        else
            {

            // Mode now successfully set .. Set GTF timings
            if ((mode & 0x0800) && timings)  // See if bit 11 is set for VBE Refresh
              VBESetRefresh(timings);        // Set the VBE 3.0 Refresh
            }


        FullCpuOff();
        ATCOn();

        // Clear the DPMS State
        wv = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
        wv &= 0x3FFF;                   // Strip to standard DAC settings
        WriteIndexed(NV_PRMCIO_CRX__COLOR, wv);

        // if (isTV())
        //    fixup_tv();          // Only required on Mode 13h

        rc &= 0x00FF;               // Clear error status
    }
    NV_OEMDisableExtensions(HwDeviceExtension);         // Unlock the registers

    return(rc);                     // Mode Not Supported
}

//
// Program the CRTC timing values given by the GTF parameters
//
// WARNING: This is not going to be pretty!!
// TODO: Clean the code to be more straightforward.
//
U016 VBESetRefresh(PGTF_TIMINGS timings)
{

    U032 val32;
    U016 val16, val16b, val16c;
    U008 val08;
    U016 pixperclk;
    U016 border;
    U008 ov07, ov25, ov2D;
    U016 horiz_total;
    U016 hbe;


    //
    // Program the new clocks
    //
    OEMSetClock((U016)(timings->dot_clock / 10000));

    /*
        ; Program new horizontal sync polarity
        mov     bl, [edi].CRTCInfoBlock.HorizontalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 040h
@@:
        ; Program new vertical sync polarity
        mov     bl, [edi].CRTCInfoBlock.VerticalSyncPolarity
        cmp     bl, '-'
        jne     @f
        or      al, 080h
@@:
        mov     dx, MISC_OUTPUT
        LOG_GO  dx, al
    */
    //
    // Program the sync polarities
    //
    val32 = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    if (timings->flags & GTF_FLAGS_HSYNC_NEGATIVE)
        val32 |= 0x40;
    if (timings->flags & GTF_FLAGS_VSYNC_NEGATIVE)
        val32 |= 0x80;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: PRMVIO_MISC=",(U008)val32);

    /*
        ;---------------------------------------------------------
        ; Compute CRTC settings
        call    PixPerCharClk
        mov     si, ax
    */
    //
    // Get the pixels per char settings
    //
    if (ReadIndexed(NV_PRMVIO_SRX, NV_PRMVIO_SR_CLOCK_INDEX) & 0x0100)
        pixperclk = 8;
    else
        pixperclk = 9;

    /*
        ; Another way to compute vertical border would be to
        ; subtract current CR12 (VDE[0:7]) from CR15 (VBS[0:7])
        call    GetCRTCAddr
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bh, ah
        mov     al, 015h
        call    GetIndexRegister        ; VBS[7:0]
        sub     ah, bh
        ;add    ah, 1-1                 ; VGA adjustments cancel
        xor     al, al
        or      ah, ah
        jz      @f
        inc     al                      ; 1 character horizontal
@@:
        mov     bx, [edi].CRTCInfoBlock.RefreshRate
        cmp     bx, 7200
        jle     @f
        xor     ax,ax                   ; No boarder for refresh above 72Hz
@@:
        mov     bp, ax                  ; Save boarders in bp
    */
    //
    // Get the border setting
    //
    border = (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x15) & 0xFF00;
    border -= (U016)ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) & 0xFF00;
    border &= 0xFF00;
    if (border & 0xFF00)
        border++;
    if (timings->refresh > 7200)
        border = 0;

    /*
        ;---------------------------------------------------------
        ; Store CRTC settings
        ; Get overflow values to accumulate
        mov     al, 007h
        call    GetIndexRegister
        mov     ch, ah                  ; Save off overflow register
        and     ch, 01010010b           ; Mask bits to save
        mov     al, 025h
        call    GetIndexRegister
        mov     cl, ah                  ; Save off extra bits screen register
        and     cl, 11100010b           ; Mask bits to save
IFDEF NVIDIA_SPECIFIC
        ; Load original 02Dh
        mov     al,02Dh
        call    GetIndexRegister
        and     ah,0E2h         ; Save unused bits and HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Get the overflow bits
    //
    ov07 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x07) >> 8;
    ov07 &= 0x52;
    ov25 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x25) >> 8;
    ov25 &= 0xE2;
    ov2D = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x2D) >> 8;
    ov2D &= 0xE2;

    /*
        ; cl = CRTC[25] overflow
        ; ch = CRTC[07] overflow
        ; upper cl = CRTC[2D] overflow
        ; dx = CRTC I/O address
        ; si = pixels per character
        ; es:di = pointer to CRTCInfoBlock
        ; ds = seg0
        ; bp = boarder
        mov     ax, [edi].CRTCInfoBlock.HorizontalTotal
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax                  ; Save original
        sub     ax, 5                   ; VGA HT adjustment
IFDEF NVIDIA_SPECIFIC
        ; Do bit 8 of HT
        and     ah,1            ; mask out bit 8
        ;shl     ah,0-0          ; already in position 0
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        ; CRTC[00]
        mov     ah, al
        mov     al, 000h
        LOG_GO  dx, ax
    */
    //
    // Calculate and program horizontal total (CR00)
    //
    horiz_total = timings->horiz_total / pixperclk;
    val16 = horiz_total - 5;
    val16 &= 0x01FF;
    ov2D |= (U008)(val16 >> 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((val16 << 8) & 0xFF00));

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR00=",(U008)val16);

    /*
IFDEF NVIDIA_SPECIFIC
        ; CRTC[39]
        ; Note, we are assuming that the 9th bit of interlace half field start is always 0
        mov     ax, bx
        shr     ax, 1           ; Compute horizontal total divided by 2
        mov     ah, [edi].CRTCInfoBlock.Flags
        and     ah,00000010b    ; ?Interlaced mode
        jnz     @f              ; Y: Leave ah at 1/2 HT
        mov     al, 0FFh        ; N: Disable interlace
@@:
        mov     ah, al
        mov     al, 039h
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program interlace half-field value (CR39)
    //
    if (timings->flags & GTF_FLAGS_INTERLACED)
        val16 = (((horiz_total >> 1) << 8) & 0xFF00) | 0x39;
    else
        val16 = 0xFF39;   // disabled
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR39=",(U008)(val16>>8));

    /*
        mov     ax, bp
        xor     ah, ah                  ; Make into word
        sub     bx, ax                  ; Subtract boarder from HT
        ; CRTC[03]
        mov     al, 003h
        call    GetIndexRegister
        and     ah, 11100000b
        dec     bl                      ; VGA HBE Adjustment
        mov     bh, bl                  ; save HBE
        and     bl, 00011111b           ; HBE[4:0]
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking end (CR03)
    //
    val16 = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x03);
    val16 &= 0xE0FF;
    hbe = horiz_total - (border & 0xFF) - 1;
    val16 |= ((hbe & 0x1F) << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR03=",(U008)(val16>>8));

    /*
        ; CRTC[05]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncEnd
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bl, al
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bl              ; VGA HSE adjustment is +2
        .endif
        inc     bl                      ; Native HSE adjustment is +1
        mov     al, 005h
        call    GetIndexRegister
        and     ah, 01100000b
        and     bl, 00011111b           ; HSE[4:0]
        or      ah, bl
        mov     bl, bh                  ; restore HBE
        and     bl, 00100000b           ; HBE[5]
        shl     bl, 7-5                 ; Move from bit 5 to bit 7
        or      ah, bl
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace end (CR05)
    //
    val16 = timings->horiz_end / pixperclk;
    val16++;    // always native mode
    val16 &= 0x1F;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x05);
    val16b &= 0x60FF;
    val16b |= (val16 << 8);
    val16 = (hbe & 0x20) << 2;
    val16b |= (val16 << 8);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR05=",(U008)(val16b>>8));

    /*
IFDEF NVIDIA_SPECIFIC
        and     bh, 01000000b
        shr     bh, 6-4
        ; MSK - Assume HBE[6] can always be set, but only takes effect if LC ignore flag is set
        or      cl, bh                  ; HBE[6]
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Modify overflow25
    //
    ov25 |= ((hbe & 0x40) >> 2);

    /*
        ; CRTC[02]
        mov     al, 001h
        call    GetIndexRegister        ; HDE[0:7]
        mov     al, ah
IFDEF NVIDIA_SPECIFIC
        ; Get bit 8 of HDE
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah, cl
        ror     ecx,16          ; switch back to lower part of ECX
        and     ah, 2           ; mask out bit 1
        shr     ah, 1-0         ; shift into position 0
ELSE ; NVIDIA_SPECIFIC
        xor     ah, ah
ENDIF ; NVIDIA_SPECIFIC
        ;
        inc     ax                      ; VGA HDE adjustment
        mov     bx, bp
        xor     bh, bh
        add     ax, bx
        dec     ax                      ; VGA HBS Adjustment
IFDEF NVIDIA_SPECIFIC
        ; Store bit 8 of HBS
        and     ah,1            ; mask out bit 8
        shl     ah,2-0          ; shift into position 2
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,ah
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, al
        mov     al, 002h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal blanking start (CR02)
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x01) >> 8) & 0x00FF;
    val16 |= ((U016)(ov2D & 2) << 7) & 0xFF00;
    val16++;
    val16 += (border & 0xFF);
    val16--;
    val08 = ((val16 >> 8) & 1) << 2;
    ov2D |= (U016)val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR02=",(U008)(val16>>8));

    /*
        ; CRTC[04]
        mov     ax, [edi].CRTCInfoBlock.HorizontalSyncStart
        push    dx
        xor     dx, dx
        div     si
        pop     dx
        mov     bx, ax
        mov     al, 028h                ; See if we are in native mode or vga mode
IFDEF NVIDIA_SPECIFIC
        call    GetIndexRegister
        and     ah, 003h
ENDIF ; NVIDIA_SPECIFIC
        .if (zero?)
                inc     bx              ; VGA HSS adjustment is +2
        .endif
        inc     bx                      ; Native HSS adjustment is +1
IFDEF NVIDIA_SPECIFIC
        ; do bit 8 of HRS
        and     bh,1            ; mask out bit 8
        shl     bh,3-0          ; shift into position 3
        rol     ecx,16          ; switch to upper part of ECX
        or      cl,bh
        ror     ecx,16          ; switch back to lower part of ECX
ENDIF ; NVIDIA_SPECIFIC
        ;
        mov     ah, bl
        mov     al, 004h
        LOG_GO  dx, ax
    */
    //
    // Program horizontal retrace start (CR04)
    //
    val16 = timings->horiz_start / pixperclk;
    val16++;    // always native mode
    val08 = ((val16 >> 8) & 1) << 3;
    ov2D |= val08;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR04=",(U008)(val16>>8));

    /*
IFDEF NVIDIA_SPECIFIC
        ; CRTC[2D]
        rol     ecx,16          ; switch to upper part of ECX
        mov     ah,cl
        ror     ecx,16          ; switch back to lower part of ECX
        mov     al,02Dh
        SIM_NO  dx,ax
ENDIF ; NVIDIA_SPECIFIC
    */
    //
    // Program CR2D
    //
    val16 = ((((U016)ov2D) << 8) & 0xFF00) | 0x2D;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR2D=",(U008)(val16>>8));

    /*
        ; CRTC[16]
        mov     bx, [edi].CRTCInfoBlock.VerticalTotal
        mov     ax, bp
        mov     al, ah
        xor     ah, ah
        sub     ax, bx
        neg     ax
        mov     ah, al
        mov     al, 016h
        dec     ah                      ; VGA VBE Adjustment
        LOG_GO  dx, ax                  ; VBE[0:7]
    */
    //
    // Program vertical blanking end (CR16)
    //
    val16 = (border >> 8) - timings->vertical_total;
    val16 = -val16;
    val16--;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR16=",(U008)(val16>>8));

    /*
        ; CRTC[06]
        mov     al, 006h
        sub     bx, 2                   ; VGA VT Adjustement
        mov     ah, bl
        LOG_GO  dx, ax                  ; VT[0:7]
    */
    //
    // Program the vertical total (CR06)
    //
    val16 = timings->vertical_total - 2;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR06=",(U008)(val16>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        ;shl    0-(8-8)
        or      ch, bl                  ; VT[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ch, bl                  ; VT[9]
        and     bh, 00000100b
        shr     bh, (10-8)-0
        or      cl, bh                  ; VT[10]
        ; CRTC[15]
        mov     ah, cl                  ; CRTC[25]
        and     ah, 00000010b
        shl     ah, (10-8)-1
        mov     bh, ah                  ; VDE[10]
        mov     al, ch                  ; CRTC[7]
        and     al, 01000000b
        shr     al, 6-(9-8)
        or      bh, al                  ; VDE[9]
        mov     ah, ch                  ; CRTC[7]
        and     ah, 00000010b
        shr     ah, 1-(8-8)
        or      bh, ah                  ; VDE[8]
        mov     al, 012h
        call    GetIndexRegister        ; VDE[7:0]
        mov     bl, ah
        inc     bx                      ; VGA VDE adjustment
        mov     ax, bp                  ; Adjust boarder
        mov     al, ah
        xor     ah, ah
        add     bx, ax
        mov     al, 015h
        dec     bx                      ; VGA VBS adjustment
        mov     ah, bl
        LOG_GO  dx, ax                  ; VBS[0:7]
    */
    //
    // Program vertical blanking start (CR15)
    //
    val16 = timings->vertical_total - 2;
    val08 = (val16 >> 8) & 0x01;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x02;
    val08 <<= 4;
    ov07 |= (U016)val08;
    val08 = (val16 >> 8) & 0x04;
    val08 >>= 2;
    ov25 |= (U016)val08;

    val08 = (ov25 & 0x02) << 1;
    val16 = (U016)val08 << 8;
    val08 = (ov07 & 0x40) >> 5;
    val16 |= (U016)val08 << 8;
    val08 = (ov07 & 0x02) >> 1;
    val16 |= (U016)val08 << 8;

    val16 &= 0xFF00;
    val16 |= (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
    val16++;
    val16 += (border >> 8);
    val16--;
    val16c = val16;                     // save for later
    val16b = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR15=",(U008)(val16b>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 3-(8-8)
        or      ch, bl                  ; VBS[8]
    */
    val08 = ((val16 >> 8) & 1) << 3;
    ov07 |= val08;

    /*
        ; CRTC[09]
        ; MSK - 5/15/97
        ; To allow a double scan mode to be non double scanned, we need to preserve the
        ; double scan bit so we can check it later
        ; We need to adjust VDE based on the old and new double scan bits
        ; We also need the original VDE
        ; NOTE: alternate way would be to get the value from the mode tables

        mov     al, 009h
        call    GetIndexRegister
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     ah,10000000b    ; Old double scan mode
        shr     ah,7-0
        and     bl,00000001b    ; ?Double scan mode
        cmp     bl, ah
        .if     (!zero?)        ; Mismatch
    */
    //
    // Is the current doublescan status different from the requested flag?
    //
    val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16 >>= 7;
    // this takes advantage that the flag is 0x01
    if ((timings->flags & GTF_FLAGS_DOUBLE_SCANNED) != (U008)val16)
    {

        /*
                ; New mode had different double scan setting from old mode
                ; We have to multiply or divide VDE by 2

                mov     bl, ch          ; CR[7].1
                and     bl, 00000010b
                shr     bl, 1-0         ; move to bit 0

                mov     ah, ch          ; CR[7].6
                and     ah, 01000000b
                shr     ah, 6-1         ; move to bit 1
                or      bl, ah

                mov     ah, cl          ; CR[25].1
                and     ah, 00000010b
                shl     ah, 2-1         ; Move to bit 2
                or      bl, ah
        */
        //
        // Adjust VDE
        //
        val08 = (ov07 & 0x02) >> 1;
        val08 |= (ov07 & 0x40) >> 5;
        val08 |= (ov25 & 0x02) << 1;

        /*
                mov     al, 012h
                call    GetIndexRegister
                mov     al, [edi].CRTCInfoBlock.Flags
                and     al, 00000001b   ; Is new mode a double scan mode?
                .if (zero?)
                        ; was double scan, now is not, so divide by 2
                        shr     bl, 1           ; Divide by 2
                        rcr     ah, 1
                .else
                        ; was not double scan, now is, so multiply by 2
                        shl     ah, 1           ; Multiply by 2
        BUG? =>         rcr     bl, 1
                        inc     ah              ; Make lsb set

                .endif
                mov     al, 012h

                LOG_GO  dx, ax          ; VDE[0:7]
        */

        val16 = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x12) >> 8) & 0x00FF;
        val16 |= (U016)val08 << 8;
        if (!(timings->flags & GTF_FLAGS_DOUBLE_SCANNED))
        {
            val16 >>= 1;
        }
        else
        {
            val16 <<= 1;
            val16++;
        }
        val16b = ((val16 << 8) & 0xFF00) | 0x12;
        WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR12=",(U008)(val16b>>8));

        /*
                and     ch, NOT 01000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000001b
                shl     al, 1-0         ; move to bit 1
                or      ch, al          ; CR[7].1
                mov     al, bl
                and     al, 00000010b
                shl     al, 6-1         ; move to bit 6
                or      ch, al          ; CR[7].1

                and     cl, NOT 00000010b       ; Strip old VDE
                mov     al, bl
                and     al, 00000100b
                shr     al, 2-1         ; move to bit 1
                or      cl, al          ; CR[25].1

        .endif
        ; End MSK - 5/15/97
        */
        //
        // Adjust the overflows based on the new VDE
        //
        ov07 &= 0xBD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x01) << 1;
        ov07 |= val08;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x02) << 5;
        ov07 |= val08;
        ov25 &= 0xFD;
        val08 = (U008)(val16 >> 8);
        val08 = (val08 & 0x04) >> 1;
        ov25 |= val08;
    }

    /*
        mov     al, 009h
        call    GetIndexRegister
        and     ah, NOT 10100000b
        mov     bl, [edi].CRTCInfoBlock.Flags
        and     bl,00000001b    ; ?Double scan mode
        jz      @f              ; N: Leave clear
        or      ah, 10000000b   ; Y: Set double scan
@@:
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 5-(9-8)
        or      ah, bl                  ; VBS[9]
        LOG_GO  dx, ax
    */
    //
    //
    val16b = (ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x09) >> 8) & 0x00FF;
    val16b &= 0x5F;
    if (timings->flags & GTF_FLAGS_DOUBLE_SCANNED)
        val16b |= 0x80;
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x02) << 4;
    val16b |= (U016)val08;
    val16 = ((val16b << 8) & 0xFF00) | 0x09;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR09=",(U008)(val16>>8));

    /*
        and     bh, 00000100b
        shl     bh, 3-(10-8)
        or      cl, bh                  ; VBS[10]
        ; CRTC[10]
        mov     al, 010h
        mov     bx, [edi].CRTCInfoBlock.VerticalSyncStart
        mov     ah, bl
        LOG_GO  dx, ax                  ; VSS[0:7]
    */
    //
    //
    val08 = (U008)(val16c >> 8);
    val08 = (val08 & 0x04) << 1;
    ov25 |= val08;
    val16 = timings->vertical_start;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR10=",(U008)(val16>>8));

    /*
        mov     bl, bh
        and     bl, 00000001b
        shl     bl, 2-(8-8)
        or      ch, bl                  ; VSS[8]
        mov     bl, bh
        and     bl, 00000010b
        shl     bl, 7-(9-8)
        or      ch, bl                  ; VSS[9]
        and     bh, 00000100b
        ;shl     bh, 2-(10-8)
        or      cl, bh                  ; VSS[10]
        ; CRTC[11]
        mov     al, 011h
        call    GetIndexRegister
        and     ah, 11110000b
        mov     bl, byte ptr [edi].CRTCInfoBlock.VerticalSyncEnd
        and     bl, 00001111b
        or      ah, bl
        LOG_GO  dx, ax                  ; VSE[0:3]
    */
    //
    //
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x01) << 2;
    ov07 |= val08;
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = (val08 & 0x02) << 6;
    ov07 |= val08;
    val08 = (U008)(timings->vertical_start >> 8);
    val08 = val08 & 0x04;
    ov25 |= val08;
    val16b = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x11);
    val16b &= 0xF0FF;
    val16b |= (timings->vertical_end & 0x000F) << 8;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16b);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR11=",(U008)(val16b>>8));

    /*
        ; Store overflow registers
        ; CRTC[7]
        mov     al, 007h
        mov     ah, ch
        LOG_GO  dx, ax
    */
    val16 = ((((U016)ov07) << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR07=",(U008)(val16>>8));

    /*
        ; CRTC[25]
IFDEF NVIDIA_SPECIFIC
        mov     al, 025h
        mov     ah, cl
        SIM_NO  dx, ax
ENDIF ; NVIDIA_SPECIFIC
    */
    val16 = ((((U016)ov25) << 8) & 0xFF00) | 0x25;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, "SetMode: CR25=",(U008)(val16>>8));

    return(0);
}


//*****************************************************************************
//
// Function: SetDMTOverrideValues()
//
// Description:
//
//      Do VESA 1.0 rev 0.7 DMT timings for the following modes:
//
//      DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7
//      Monitor Timing Specifications and D.Reed's NV3 CRTC spreadsheet.
//
//           1600 x 1200 @ 60,70,75,85
//           1280 x 1024 @ 60,75,85
//           1152 x  864 @ 75
//           1024 x  768 @ 60,70,75,85
//            800 x  600 @ 60,72,75,85
//            640 x  480 @ 60,72,75,85
//
//      DMT_Overrides_structure
//
//          U016    DotClock;
//          U016    Polarity;
//          U016    CR0;
//          U016    CR2;
//          U016    CR3;
//          U016    CR4;
//          U016    CR5;
//          U016    CR6;
//          U016    CR7;
//          U016    CR10;
//          U016    CR11;
//          U016    CR15;
//          U016    CR16;
//
//*****************************************************************************


VOID SetDMTOverrideValues(PDMT_OVERRIDES pDMTOverrides)

{

    U032 val32;
    U016 val16;
    U016  wv;

    //
    // Program the new clocks
    //

    OEMSetClock((U016)(pDMTOverrides->DotClock));

    //
    // Program the sync polarity
    //

    val32   = ReadPriv32(NV_PRMVIO_MISC__READ) & 0x3F;
    val32  &= 0xf3;
    val32  |= 0x8;
    val32  |= pDMTOverrides->Polarity;
    WritePriv08(NV_PRMVIO_MISC__WRITE, (U008)val32);

    //
    // Clear the crtc protection bit.
    //

    val16 = 0x0011;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR0
    //

    val16 = pDMTOverrides->CR0;
    val16 = ((val16 << 8) & 0xFF00) | 0x00;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);


    //
    // Update CR2
    //

    val16 = pDMTOverrides->CR2;
    val16 = ((val16 << 8) & 0xFF00) | 0x02;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR3
    //

    val16 = pDMTOverrides->CR3;
    val16 = ((val16 << 8) & 0xFF00) | 0x03;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR4
    //

    val16 = pDMTOverrides->CR4;
    val16 = ((val16 << 8) & 0xFF00) | 0x04;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR5
    //

    val16 = pDMTOverrides->CR5;
    val16 = ((val16 << 8) & 0xFF00) | 0x05;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR6
    //

    val16 = pDMTOverrides->CR6;
    val16 = ((val16 << 8) & 0xFF00) | 0x06;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR7
    //

    val16 = pDMTOverrides->CR7;
    val16 = ((val16 << 8) & 0xFF00) | 0x07;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR10
    //

    val16 = pDMTOverrides->CR10;
    val16 = ((val16 << 8) & 0xFF00) | 0x10;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);
    //
    // Update CR11
    //

    val16 = pDMTOverrides->CR11;
    val16 = ((val16 << 8) & 0xFF00) | 0x11;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR15
    //

    val16 = pDMTOverrides->CR15;
    val16 = ((val16 << 8) & 0xFF00) | 0x15;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    //
    // Update CR16
    //

    val16 = pDMTOverrides->CR16;
    val16 = ((val16 << 8) & 0xFF00) | 0x16;
    WriteIndexed(NV_PRMCIO_CRX__COLOR, val16);

    }

#define COMBINE_INDEX_DATA(i, d) ((U016)((((U016)(d)) << 8 & 0xff00) + (i)))
#define EXTRACT_DATA(x) (x) >> 8 & 0x00ff
VOID ProgramTV
(
    U008    tvmode
)
{
    U016    data;

    // 11-07-97 wk. Note that either the commented out tvreg table for CRTC[12] is
    //              wrong or the BIOS CRTC[12] programming code is wrong. The BIOS doesn't
    //              have tvreg tables for TV modes 4 and 5. The C code will use the tvreg
    //              table, so if the bug is in the table then make the correction there.

    WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_ILACE__INDEX, tvregs[tvmode].tvIntlace));        // CRTC[39]

    // Un-write protect CR0-7 registers.
    data = ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_VRE_INDEX);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(data & 0x7fff));

    // Check for NTSC or PAL.
    data = EXTRACT_DATA(ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CRE_PIXEL_INDEX));
    if(( data & 0xc0 ) == 0x80 )
    {
        // NTSC
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_DEC__INDEX, tvregs[ tvmode ].tvDecimate_NTSC ));      // CR[29]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDT_INDEX,   tvregs[ tvmode ].tvHT_NTSC       ));      // CR[00]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRS_INDEX,   tvregs[ tvmode ].tvHRS_NTSC      ));      // CR[04]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDT_INDEX,   tvregs[ tvmode ].tvVT_NTSC       ));      // CR[06]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_OVL_INDEX,   tvregs[ tvmode ].tvVO_NTSC       ));      // CR[07]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRS_INDEX,   tvregs[ tvmode ].tvVRS_NTSC      ));      // CR[10]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDE_INDEX,   tvregs[ tvmode ].tvHDE_NTSC      ));      // CR[01]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBS_INDEX,   tvregs[ tvmode ].tvHBS_NTSC      ));      // CR[02]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBE_INDEX,   tvregs[ tvmode ].tvHBE_NTSC      ));      // CR[03]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRE_INDEX,   tvregs[ tvmode ].tvHRE_NTSC      ));      // CR[05]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRE_INDEX,   tvregs[ tvmode ].tvVRE_NTSC      ));      // CR[11]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDE_INDEX,   tvregs[ tvmode ].tvVDE_NTSC      ));      // CR[12]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBS_INDEX,   tvregs[ tvmode ].tvVBS_NTSC      ));      // CR[15]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBE_INDEX,   tvregs[ tvmode ].tvVBE_NTSC      ));      // CR[16]
    }
    else
    {
        // PAL
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CRE_DEC__INDEX, tvregs[ tvmode ].tvDecimate_PAL ));      // CR[29]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDT_INDEX,   tvregs[ tvmode ].tvHT_PAL       ));      // CR[00]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRS_INDEX,   tvregs[ tvmode ].tvHRS_PAL      ));      // CR[04]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDT_INDEX,   tvregs[ tvmode ].tvVT_PAL       ));      // CR[06]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_OVL_INDEX,   tvregs[ tvmode ].tvVO_PAL       ));      // CR[07]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRS_INDEX,   tvregs[ tvmode ].tvVRS_PAL      ));      // CR[10]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HDE_INDEX,   tvregs[ tvmode ].tvHDE_PAL      ));      // CR[01]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBS_INDEX,   tvregs[ tvmode ].tvHBS_PAL      ));      // CR[02]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HBE_INDEX,   tvregs[ tvmode ].tvHBE_PAL      ));      // CR[03]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_HRE_INDEX,   tvregs[ tvmode ].tvHRE_PAL      ));      // CR[05]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VRE_INDEX,   tvregs[ tvmode ].tvVRE_PAL      ));      // CR[11]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VDE_INDEX,   tvregs[ tvmode ].tvVDE_PAL      ));      // CR[12]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBS_INDEX,   tvregs[ tvmode ].tvVBS_PAL      ));      // CR[15]
        WriteIndexed(NV_PRMCIO_CRX__COLOR, COMBINE_INDEX_DATA(NV_CIO_CR_VBE_INDEX,   tvregs[ tvmode ].tvVBE_PAL      ));      // CR[16]

        // PAL Fix up.

        // 11-07-97 wk. mighty suspect bios code (or documentation)!
        //
        // mov     al,1                    ; Look at value in CR01
        // SIM_GET_INDEX_REGISTER_NV       ; Read CR01
        // cmp     ah,4Fh                  ; Is it > 4Fh? (800 s/b 63h)
        //
        // jbe     @low_pal                ; it's a 640x480 or less mode... jump!

        //CRTC_RD( NV_CIO_CR_HDE_INDEX, data );      // CRTC[01]
        data = EXTRACT_DATA(ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_HDE_INDEX));
        if( data > 0x4f )
        {
            // PAL timings for modes 800x600 or more.

            // set VPLL to SOURCE
            WritePriv32(0x00010100, NV_PRAMDAC_PLL_COEFF_SELECT );
            WritePriv32(0x00035A09, NV_PRAMDAC_VPLL_COEFF       );

            // tblPALTimingsHi
            WritePriv32(0x0000004F, NV_PRAMDAC_HSYNC_WIDTH      );
            WritePriv32(0x0000005F, NV_PRAMDAC_HBURST_START     );
            WritePriv32(0x000003FF, NV_PRAMDAC_HBLANK_START     );
            WritePriv32(0x00000438, NV_PRAMDAC_HTOTAL           );
            WritePriv32(0x00000027, NV_PRAMDAC_HEQU_WIDTH       );
            WritePriv32(0x000001CA, NV_PRAMDAC_HSERR_WIDTH      );
        }
        else
        {
            // PAL timings for modes less then 800x600.

            // set VPLL to SOURCE
            WritePriv32(0x02010100, NV_PRAMDAC_PLL_COEFF_SELECT );
            WritePriv32(0x00034709, NV_PRAMDAC_VPLL_COEFF       );

            // tblPALTimingsLo
            WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH      );
            WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START     );
            WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START     );
            WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL           );
            WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH       );
            WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH      );
        }
    }

    // write protect CR0-7 registers.
    data = ReadIndexed(NV_PRMCIO_CRX__COLOR, NV_CIO_CR_VRE_INDEX);
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016)(data & 0x7fff));
}



//
//       LoadPalette - Load the system palette and the user defined palette if there is one
//
//       Entry:  DS = Seg0
//               ES:DI = Pointer to parameter entry
//       Exit:   None
VOID LoadPalette(MODEDESC *mi)
{
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    //
    // Load default internal palette
    //
    LoadDefaultATCAndSavePtr((vga_tbl[mi->mdIMode].PT_ATC));

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop

    WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!

    //
    // Load default external palette
    //
    LoadDefaultRAMDAC(mi);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif

}

//
//       LoadDefaultATCAndSavePtr - Load a the default ATC registers and store them in the saveptr area if necessary
//
//       Entry:  ES:SI = Pointer to palette data
//               DX = I/O Address of Input Status Register
//               DS = Seg0
//       Exit:   None
//
//       AX, CX, SI are trashed
//       DX is preserved
//
VOID LoadDefaultATCAndSavePtr(U008 *pal)
{
    U008  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop

    for (i = 0; i < 20; i++)
    {
        WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//
//       LoadDefaultRAMDAC - Load the default palette
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed
//

// #define DAC_MASK 0x3C6

VOID LoadDefaultRAMDAC(MODEDESC *mi)
{
    WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask
    // outp(DAC_MASK, 0xFFh);

    switch(mi->mdBPP)
    {
    case    4:          // 4bpp - Planar
        LoadColorDACTable();
        break;

    case    8:          // 8bpp - Packed
        LoadColor256DAC();
        break;

    case    16:         // 16bpp - Packed
    case    32:         // 16bpp - Packed
    default:
        LoadIdentityDAC();
        break;
    }
}

//
//       LoadColorDACTable - Load the DAC for the 16-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       WARNING! This routine must follow "LoadColorTextDACTable"!
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadColorDACTable(VOID)
{
    U008  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        WriteColor(i);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//
//       LoadColor256DAC - Load the DAC for the 256-color modes
//
//       Entry:  DS = Seg0
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
// These tables are defined in Resman code in DACMODE.C
//
extern U008 CompatColors[];

//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
extern U008 GrayColors[];

//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
extern U008 FixupColors[];

//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
extern U008 IntenseTable[];

VOID LoadColor256DAC(VOID)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        WriteColor(CompatColors[i]);

    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }

    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //

    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {

        // I know these could probably be a function, but for now...
        // (this is getting tedious).

        // Traverse(blue, red);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            red++;
        } while (red < blue);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            blue--;
        } while (blue);

        // Traverse(red, green);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            green++;
        } while (green < red);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            red--;
        } while (red);


        // Traverse(green, blue);
        do
        {
            // To loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            blue++;
        } while (blue < green);

        do
        {
            // From loop
            WriteColor2(red, green, blue, (U016) (i * 5));
            green--;
        } while (green);
    }

    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif

}

//
//       WriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               BL = 6 bit color (R'G'B'RGB)
//       Exit:   None
//
//       AX is trashed
//
VOID WriteColor(U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write

    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component

        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;

        WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}

//
//       WriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
//       Entry:  DAC address already written
//               DX = DAC data address
//               CS:BX points to intensity table
//               SI = Red index (0 to 4)
//               DI = Green index (0 to 4)
//               CX = Blue index (0 to 4)
//
//       Exit:   None
//
//       AL is trashed
//
VOID WriteColor2(U016 red, U016 green, U016 blue, U016 tblidx)
{
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       LoadIdentityDAC - Load the DAC with a gamma ramp
//
//       Entry:  DS = Seg0
//               ES = _TEXT
//       Exit:   None
//
//       AX, BX, CX, DX, SI are trashed.
//
VOID LoadIdentityDAC(VOID)
{
    U016  i;
    U016  flags;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax
    _asm    cli;                    // No interrupts during this!
#endif

    // Select the DAC address
    WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);

    for (i = 0; i < 256; i++)
    {
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
        WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)i);
    }

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf;                   // Restore interrupt status
#endif
}

//       OEMSetClock - Set the clock chip to the requested frequency
//
//       Entry:  AL = Clock select index
//       Exit:   None
//
//       All registers are preserved.
VOID OEMSetClock(U016 clock)
{
    U032   mnp;

    //clock = tblClockFreq[csel];         // Get selected clock value
    NV_FixLowWaterMark(clock);             // Set low water mark.
    mnp = CalcMNP(&clock);              // Get the MNP of frequency

    // mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM

//  AL = M parameter
//  AH = N parameter
//  DL = P parameter

    SetDACClock(mnp);
}

//       SetDACClock - Set the VPLL parameters in the NVidia DAC
//
//  Entry:  mnp = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
//       Entry:  AL = M parameter
//               AH = N parameter
//               DL = P parameter
//       Exit:   None
//
VOID SetDACClock(U032 mnp)
{
    // NOTE: if we need to support divide by two, use msb of p parameter
    // Set the MNP VPLL parameters in the DAC
    WritePriv32(mnp, NV_PRAMDAC_VPLL_COEFF);
}



//       CalcMNP - Set the clock chip to the requested frequency
//
//       Entry:  AX = Clock frequency in 100 kHz
//       Exit:   AL = M parameter
//               AH = N parameter
//               DL = P parameter
//               BX = Closest clock frequency in 100 kHz
//
//      Returns: long lwv = xxxxxxxx PPPPPPPP NNNNNNNN MMMMMMMM
//
U032 CalcMNP(U016 *clock)
{
    U016  crystalFreq;
    U032   vclk;
    U016  vclkClosest;
    U016  deltaOld;
    U016  bestM;
    U016  bestP;
    U016  bestN;
    U016  lowM;
    U016  highM;

    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032   lwv;

    U032   edx;
    U016  dx, cx, bx;
    U016  lwvs, vclks;
    U016  t;

    vclk = (U032)(*clock * 10);     // Make KHz

    deltaOld = 0xFFFF;

    lwv = ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040;

    if (lwv)
    {
        // 14.3Khz
        dx = CRYSTAL_FREQ143KHZ;
        cx = 8;
        bx = 14;
    }
    else
    {
        // 13.5Khz
        dx = CRYSTAL_FREQ135KHZ;
        cx = 7;
        bx = 13;
    }

    lowM = cx;
    highM = bx;
    crystalFreq = dx;

    // Register usage below
    // eax = scratch
    // ebx = scratch
    // edx = scratch
    // si = m
    // di = n

    // P Loop
    for (powerP = 0; powerP <= 4; powerP++) // Init Power of P
    {
        // M Loop
        for (m = lowM; m <= highM; m++)
        {
            lwv = vclk << powerP;   // vclk * P

            // Compare with internal range of DAC
            if ((lwv >= 128000) && (lwv <= 256000))
            {
                lwv *= (U032)m;    // vclk * P * M

                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);

                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);

                lwv *= crystalFreq; // N * crystal

                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2

                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P

                i = m;
                j = m;

                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M


//                   ; upper part of ebx should still be 0
//                   mov     bx, m
//                   ; Note: edx should be zero from multiply above
//                   mov     dx, bx
//                   shr     dx, 1           ; m / 2
//                   add     eax, edx        ; This will round better
//                   xor     dx, dx
//                   div     ebx             ; Freq=N*crystal/P/M
//
//                   mov     edx, eax        ; Save a copy

                edx = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta

                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);

                if (lwvs < vclks)
                {
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }

                lwvs -= vclks;      // ABS(Freq-Vclk);

                // lwvs is ax
                // vclks is bx

                if (lwvs < deltaOld)
                {
                    // Closer match
                    deltaOld = lwvs;

                    bestP = powerP;
                    bestM = m;
                    bestN = n;

                    //         mov     deltaOld, ax
                    //         mov     bestP, powerP
                    //         mov     ax, m
                    //         mov     bestM, al
                    //         mov     ax, n
                    //         mov     bestN, al

                    edx /= 10;

                    //         mov     eax,edx
                    //         xor     edx,edx
                    //         mov     ebx,10
                    //         div     ebx             ; Convert
                    //         mov     vclkClosest,ax
                    vclkClosest = (U016)(edx & 0xFFFF);
                }
            }
        }
    }

  //  lwv = ((bestP << 16) | (bestN << 8) | (bestM));
    lwv = bestP;
    lwv <<= 16;
    lwv |= ((bestN << 8) | (bestM));


    // mov     bx, vclkClosest
    *clock = vclkClosest;

    return(lwv);
}

//       FullCpuOn - Give the CPU full bandwidth to video memory
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOn(VOID)
{
    U016  datum;

    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum |= 0x2000;                            // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
}

//       FullCpuOff - Share the CPU bandwidth with the CRTC
//
//       Entry:  None
//       Exit:   None
//
VOID FullCpuOff(VOID)
{
    U016  datum;

    datum = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    datum &= 0xDFFF;                            // Full Bandwidth bit OFF
    WriteIndexed(NV_PRMVIO_SRX, datum);          // Set bit
}

//
//       SetRegs - Set VGA registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID SetRegs(MODEDESC *mi)
{
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset

    WritePriv08(NV_PRMVIO_MISC__WRITE, vga_tbl[mi->mdIMode].PT_Misc);

    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    LoadIndexRange(NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(vga_tbl[mi->mdIMode].seq_regs));

    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset

    // Load CRTC's
    WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x2011);  // Unlock CR0-7

    // Load CRTC, beginning at CR0, for all CR's (CR0-18), from the mode table
    LoadIndexRange(NV_PRMCIO_CRX__COLOR, 0, sizeof(CRTC), (U008 *)&(vga_tbl[mi->mdIMode].crtc_regs));

    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    LoadIndexRange(NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(vga_tbl[mi->mdIMode].gr_regs));
}

VOID LoadIndexRange(U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;

    // Program SR1-4
    for (i = 0; i < count; i++)
    {
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }
}

//       OEMPreSetRegs - Make special preparations to load registers
//
//       Entry:  ES:DI = Pointer to standard parameter table entry
//               DS = Seg0
//       Exit:   None
VOID OEMPreSetRegs(VOID)
{
    U016  rc;

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    rc &= 0xF8FF;                   // Strip to standard DAC settings
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A);
    rc |= 0x0200;                   // Use 6-bit DAC
    WriteIndexed(NV_PRMCIO_CRX__COLOR, rc);
}

//
//       ATCOff - Turn off Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOff(VOID)
{
    U016  flags = 0;

#ifdef DOS_COMPILE
    _asm    pushf;                  // Save Interrupt state
    _asm    pop ax;
    _asm    mov flags,ax            // Save flags
    _asm    cli;                    // No interrupts during this!
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x00);   // Turn off screen at AR

#ifdef DOS_COMPILE
    _asm    mov ax,flags
    _asm    push ax
    _asm    popf
#endif
}

//
//       ATCOn - Turn on Attribute Controller
//
//       Entry:  None
//       Exit:   None
VOID ATCOn(VOID)
{
    U016  flags;

#ifdef DOS_COMPILE
    _asm
    {
        pushf
        pop ax
        mov flags,ax
        cli
    }
#endif

    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    WritePriv08(NV_PRMCIO_ARX, 0x20);   // Turn off screen at AR
    ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
                                    // So DOS Edit doesn't barf
#ifdef DOS_COMPILE
    _asm
    {
        mov ax,flags
        push ax
        popf
    }
#endif
}

//
// ValidateMode - Validate the passed mode is valid, and if it is,
//                return the pointer to the mode information block.
//
//  Entry:  U016  mode            // VESA Mode Number to validate
//
//  Exit:   MODEDESC *mi            // Mode Information Block Pointer
//                                  // NULL if error (invalid mode)
//  NOTES:  This function must also verify the operational mode,
//          and return failure status if not valid on TV
//

MODEDESC *ValidateMode(U016 mode)
{
    MODEDESC    *mi;

    for (mi = &mib[0]; mi->mdVMode != 0xFFFF; mi++)
    {
        if (mi->mdVMode == mode)
        {
            if (OEMValidateMode(mi))
                return(mi);
            break;      // Out of the for - report error
        }
    }
    return(NULL);
}

// From OEMIsModeAvailable - validate the mode from the OEM perspective.
//
U008 OEMValidateMode(MODEDESC *m)
{
    U032   memory;

    // Are we running tv mode? If so, we need an additional filter

    // For now, NV5 or better only supports Flat Panel
    // We don't support TV yet 

    if  ( (HwDeviceExtension->ulChipID == NV3_DEVICE_NV3_ID) &&
          (isTV()) )       

    {
        if (m->mdTVMode == 0xFF)
            return((U008)0);
    }

    // Validate we have enough memory
    // (XRes * YRes * Bpp)/8
    //           +--- XRes / 8
    //           V
    memory = (((m->mdXRes >> 3) * m->mdBPP) * m->mdYRes);
    memory += 0xFFFF;               // Take to next 64K bank size
    memory >>= 16;                  // Divide by 64K for number of banks

    // memory now has the 64K blocks necessary for this mode.

    if (((U016)memory) > NV_OEMGetMemSize())
        return((U008)0);
    return((U008)1);
}

// Returns 1 if the TV is active
//
U008 isTV(VOID)
{
    U016   rc;

    // WARNING: This code was ONLY valid on NV3.
    //          It's no longer adequate for NV5 or better !!

    rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28);
    return((U008)((rc >> 8) & 0x80));
}





/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/

// And the following routines will become "throwaway" code, as they
// deal with the saving and restoring of the IO state during the
// accesses to the PRIV_IO.

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
//       SaveNVAccessState - Save the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//       Exit:   cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//               Real mode access registers set to address
VOID SaveNVAccessState(ACCESS_STATE *as)
{
    U008   rc;

    U016  wval;
    U032   dval;

/*
    as->crtc_addr = 0x3D4;           // Set 3D4 by default
    as->access_reg = 0x38;           // Set CR38

    // rc = ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x38);
    dval = NV_PRMCIO_CRX__COLOR;

    // Output the MSW of the address
    outpw(0x3D2, (U016)((dval >> 16) & 0xFFFF));

    // and the LSW of the address
    outpw(0x3D0, (U016)(dval & 0xFFFF));

    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));

    outp(0x3D0, 0x38);              // Select the register
    wval = inpw(0x3D0);             // This data is Byte/Word accessable

    as->access_reg = (U008)(wval & 0xFF);
    as->access_bits = (U008)((wval >> 8) & 0xFF);

    // Select the data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA) << 8) | (as->access_reg)));

    as->data_low = inpw(0x3D0);      // Save lsw of 32-bit data

    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));

    as->nv_address = inpw(0x3D2);    // Read MSW of address
    as->nv_address <<= 16;           // Put in high word.
    as->nv_address |= inpw(0x3D0);   // Read LSW of address
*/

}


//       RestoreNVAccessState - Restore the state of the NV real mode access registers
//
//       Entry:  ds = seg0
//               Extended CRTC registers unlocked
//               cx  = CRTC address
//               eax = 32-bit NV address
//               bh  = real mode access control bits
//               bl  = real mode access register (NVRM_ACCESS)
//               dx  = LSW of 32-bit data register
//       Exit:   none
VOID RestoreNVAccessState(ACCESS_STATE *as)
{
/*
    // Get the address next
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_ADDRESS) << 8) | (as->access_reg)));
    outpw(0x3D2, (U016)(as->nv_address >> 16));       // MSW of address
    outpw(0x3D0, (U016)(as->nv_address & 0xFFFF));    // LSW of address

    // Select the buffered data port
    outpw(as->crtc_addr, (((NVRM_ACCESS_MASK | NVRM_DATA32) << 8) | (as->access_reg)));

    outpw(0x3D0, as->data_low);     // LSW of address

    outpw(as->crtc_addr, (((as->access_bits) << 8) | (as->access_reg)));
*/
}

/**********************************************************************/
/**********************************************************************/

//
// POST the chip, just like the BIOS normally does
//
VOID NvPost()
{
    U032 memconfig;
    U032 val32;

    //////////////////////////////////////////////
    //
    // Taken from BIOS POST sequence
    //

    //
    // Enable requisite engines
    //
    WritePriv32(0x11111111, NV_PMC_ENABLE);

    //
    // Program 100MHz MPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
    else
        WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    //
    // Program PFB Config to defaults
    //
    WritePriv32( DRF_DEF(_PFB,_CONFIG_0,_RESOLUTION,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_PIXEL_DEPTH,_DEFAULT)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING,_DISABLED)
               | DRF_DEF(_PFB,_CONFIG_0,_TILING_DEBUG,_DISABLED), NV_PFB_CONFIG_0);

    //
    // Program VPLL clocking
    //
    if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
        WritePriv32(0x00028D0E, NV_PRAMDAC_MPLL_COEFF);
    else
        WritePriv32(0x0001400C, NV_PRAMDAC_MPLL_COEFF);

    //
    // Program PFB Power control
    //
    WritePriv32(DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED), NV_PFB_GREEN_0);

    //
    // Program memory timings based on framebuffer size
    //
    //

    //
    // Determine how wide/deep is the framebuffer
    //
    /*
     Memory layout:

           4mb 128-bit     33221100 77665544 bbaa9988 ffeeddcc
           2mb 128-bit     33221100 77665544 xxxxxxxx xxxxxxxx

           128-bit covers address 0-3fffff in both 2mb and 4mb configs,
           but the second 2 dwords are garbage on 2mb boards.

           4mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc
           2mb 64-bit      33221100 77665544 bbaa9988 ffeeddcc

           64-bit covers address 0-3fffff in 4mb configs, while
           64-bit covers address 0-1fffff in 2mb configs. All bytes are
           addressed.
    */

    memconfig = ReadPriv32(NV_PFB_BOOT_0);
    memconfig &= 0xFFFFFFFC;
    memconfig |= DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _DEFAULT); // mask to 4meg, keep bus width

    //
    // Poke the framebuffer based on bus width
    //
    if (memconfig & DRF_DEF(_PFB, _BOOT_0, _RAM_WIDTH_128, _ON))
    {
        //
        // 128bit test
        //
        WriteFb32('NV3A', 0x00200008);  // 2meg+8

        //
        // 4meg?
        //
        if (ReadFb32(0x00200008) != 'NV3A')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);

    } else {

        //
        // 64bit test
        //
        WriteFb32('NV3A', 0x00100000);  // 1meg
        WriteFb32('NV3B', 0x00300000);  // 3meg

        //
        // 4meg?
        //
        if (ReadFb32(0x00300000) != 'NV3B')
            //
            // Assume 2meg
            //
            memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB);

            //
            // 2meg?
            //
            if (ReadFb32(0x00100000) != 'NV3A')
                //
                // Assume 1meg
                //
                ;//memconfig = (memconfig & 0xFFFFFFFC) | DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _1MB);

    }

    //
    // Write the memory config
    //
    WritePriv32(memconfig, NV_PFB_BOOT_0);

    //
    // Now program the appropriate memory timings
    //
    if ((memconfig & 3) == DRF_DEF(_PFB, _BOOT_0, _RAM_AMOUNT, _2MB))
    {
        //
        // 2meg timings
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);

        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);

        WritePriv32((ULONG) (DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON)), NV_PFB_CONFIG_1);

        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);

        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    } else {
        //
        // 4meg
        //
        WritePriv32(DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_WRITE_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_RISE,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_CAS_ENABLE_FALL,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_OUTPUT_DATA,_0)
                  | DRF_DEF(_PFB,_DELAY_1,_RAS_ENABLE,_0), NV_PFB_DELAY_1);

        WritePriv32(DRF_DEF(_PFB,_DEBUG_0,_CKE_ALWAYSON,_ON)
                  | DRF_DEF(_PFB,_DEBUG_0,_CKE_INVERT,_OFF)
                  | DRF_DEF(_PFB,_DEBUG_0,_CASOE,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH_COUNTX64,_DEFAULT)
                  | DRF_DEF(_PFB,_DEBUG_0,_REFRESH,_ENABLED)
                  | DRF_DEF(_PFB,_DEBUG_0,_PAGE_MODE,_ENABLED), NV_PFB_DEBUG_0);

        WritePriv32((ULONG) (DRF_DEF(_PFB,_CONFIG_1,_CAS_LATENCY,_3)
                  | DRF_DEF(_PFB,_CONFIG_1,_SGRAM100,_ENABLED)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_PCHG,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_LOW,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_MRS_TO_RAS,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_WRITE_TO_READ,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_RAS_TO_CAS_M1,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_WRITE,_DEFAULT)
                  | DRF_DEF(_PFB,_CONFIG_1,_READ_TO_PCHG,_ON)), NV_PFB_CONFIG_1);

        WritePriv32(DRF_DEF(_PFB,_RTL,_S,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_V,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_M,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_H,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_A,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_G,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_GR_HI_PRIOR,_DEFAULT)
                  | DRF_DEF(_PFB,_RTL,_ARB_MEDIA_HI_PRIOR,_DEFAULT), NV_PFB_RTL);

        //
        // Program 100MHz MPLL clocking
        //
        if (ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000040)
            WritePriv32(0x0001C40E, NV_PRAMDAC_MPLL_COEFF);
        else
            WritePriv32(0x0001A30B, NV_PRAMDAC_MPLL_COEFF);

    }

    //
    // Enable clocking
    //
    WritePriv32(DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_DLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_SOURCE,_PROG)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_MPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_SOURCE,_DEFAULT)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VPLL_BYPASS,_FALSE)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_PCLK_SOURCE,_VPLL)
              | DRF_DEF(_PRAMDAC,_PLL_COEFF_SELECT,_VCLK_RATIO,_DB1), NV_PRAMDAC_PLL_COEFF_SELECT);

    //
    // Setup optimal PCI interface
    //
    WritePriv32(DRF_DEF(_PBUS,_DEBUG_1,_PCIM_THROTTLE,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_CMD,_SIZE_BASED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIM_AGP,_IS_AGP)
              | DRF_DEF(_PBUS,_DEBUG_1,_AGPM_CMD,_LP_ONLY)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WRITE,_0_CYCLE)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_2_1,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RETRY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RD_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_WR_BURST,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_EARLY_RTY,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_RMAIO,_DISABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_PCIS_CPUQ,_ENABLED)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE1,_ZERO)
              | DRF_DEF(_PBUS,_DEBUG_1,_SPARE2,_ZERO), NV_PBUS_DEBUG_1);


    //
    // Make sure hsync and vsync are on (we only set them in DPMS calls)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x1A) & 0x3FFF) | 0x0000));

    //
    // Boot with TV off, and set for NTSC if it was on.
    // Also set horizontal pixel adjustment
    // Sets pixel format to VGA
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x28) & 0x00FF) | 0x0000));

    //
    // Float DDC pins high (not touched during a mode set or save/restore state)
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3300));

    //
    // Disable DDC
    //
    WriteIndexed(NV_PRMCIO_CRX__COLOR, (U016) ((ReadIndexed(NV_PRMCIO_CRX__COLOR, 0x3F) & 0x00FF) | 0x3200));

    //
    // Program NTSC TV settings
    //
    WritePriv32(0x00000006, NV_PRAMDAC_VSERR_WIDTH);
    WritePriv32(0x0000000C, NV_PRAMDAC_VEQU_END);
    WritePriv32(0x0000000C, NV_PRAMDAC_VBBLANK_END);
    WritePriv32(0x00000024, NV_PRAMDAC_VBLANK_END);
    WritePriv32(0x0000020C, NV_PRAMDAC_VBLANK_START);
    WritePriv32(0x00000206, NV_PRAMDAC_VBBLANK_START);
    WritePriv32(0x00000207, NV_PRAMDAC_VEQU_START);
    WritePriv32(0x0000020D, NV_PRAMDAC_VTOTAL);
    WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
    WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
    WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
    WritePriv32(0x0000034A, NV_PRAMDAC_HBLANK_START);
    WritePriv32(0x00000088, NV_PRAMDAC_HBLANK_END);
    WritePriv32(0x0000035A, NV_PRAMDAC_HTOTAL);
    WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
    WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);

    //
    // If strapped to PAL, program PAL TV settings
    //
    if ((ReadPriv32(NV_PEXTDEV_BOOT_0) & 0x00000180) == 0x00000100)
    {

        WritePriv32(0x00000005, NV_PRAMDAC_VSERR_WIDTH);
        WritePriv32(0x0000000A, NV_PRAMDAC_VEQU_END);
        WritePriv32(0x0000000A, NV_PRAMDAC_VBBLANK_END);
        WritePriv32(0x0000002C, NV_PRAMDAC_VBLANK_END);
        WritePriv32(0x0000026C, NV_PRAMDAC_VBLANK_START);
        WritePriv32(0x00000269, NV_PRAMDAC_VBBLANK_START);
        WritePriv32(0x0000026C, NV_PRAMDAC_VEQU_START);
        WritePriv32(0x00000271, NV_PRAMDAC_VTOTAL);
        WritePriv32(0x0000003F, NV_PRAMDAC_HSYNC_WIDTH);
        WritePriv32(0x00000048, NV_PRAMDAC_HBURST_START);
        WritePriv32(0x0000006A, NV_PRAMDAC_HBURST_END);
        WritePriv32(0x00000350, NV_PRAMDAC_HBLANK_START);
        WritePriv32(0x00000092, NV_PRAMDAC_HBLANK_END);
        WritePriv32(0x00000360, NV_PRAMDAC_HTOTAL);
        WritePriv32(0x0000001F, NV_PRAMDAC_HEQU_WIDTH);
        WritePriv32(0x0000016E, NV_PRAMDAC_HSERR_WIDTH);
    }

}

/**********************************************************************/
/**********************************************************************/


//
// The following MAIN() routine is only used for standalone DOS compiles
//
#ifdef DOS_COMPILE
VOID main(U016 ac, U008 **av)
{
    U016  mode;                   // Mode to be set
    U016  rc;                     // Return code

    printf("NVIDIA MODESET V1.00\n\n");

    if (ac < 2)
    {
        printf("Usage: modeset vmode\n");
        printf("       vmode - Vesa Mode Number\n");
        exit(1);
    }

    if ((mode = h2i(*(++av))) == 0xFFFF)
    {
        printf("Error! Bad Vesa Mode Number\n");
        exit(2);
    }

    printf("Setting Mode 0x%02X\n", mode);
    getchar();

    rc = VBESetMode(mode);

    if (((rc & 0xFF) != 0x4F) || ((rc & 0xFF00) >> 8))
    {
        printf("Error! Could Not Set Mode 0x%02X [rc=%04X]\n", mode, rc);
        exit(3);
    }

    exit(0);
}

//
// h2i - convert Hex string to an Unsigned Integer
U016 h2i(U008 *str)
{
    U016  sus = 0;                // Starting unsigned short
    U016  i;
    U016  val;                    // Conversion value

    // Since we only do U016's, we have a max of 0xFFFF-1
    if ((i = strlen(str)) > 4)
        return(0xFFFF);

    while (i--)
    {
        val = toupper(*str) - 0x30;  // Convert Hex 0-9
        if (val > 9)
        {
            val -= 7;               // Take 7 more to convert A-F
            if (val < 0x0A || val > 0x0F)
                return(0xFFFF);     // Error!
        }
        sus *= 16;                  // Shift by 4
        sus += val;
        str++;
    }
    return(sus);
}
#endif // DOS_COMPILE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\ntnvreg.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/



//******************************************************************************
// Common typedefs
//******************************************************************************

typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

//******************************************************************************
// Type of REGISTRY entry
//******************************************************************************

#define IS_BINARY       0
#define IS_STRING       1
#define IS_DWORD        2

//******************************************************************************
// REGISTRY data length max values
//******************************************************************************

#define REG_STRING_DATA_MAX 30

//******************************************************************************
// Maximum number of NV registry switches
//******************************************************************************

#define MAX_NV_REGISTRY_SWITCHES   100

//******************************************************************************
// Dword value used to IGNORE the presence of the registry switch
//******************************************************************************

#define IGNORE_REGISTRY_SWITCH     0x99999999

//******************************************************************************
// NT Registry Switches:
// ====================
//
// The implementation of NT registry keys are different than Win9x,
// since NT is more restricted when it comes to setting values in its registry.
// Essentially, for NT, we only use a 'flat' registry structure, as opposed to 
// several different keys (directory structure) in Win9x.
//  
// For Win9x, the registy keys and values are stored under 
//          \HKEY_LOCAL_MACHINE\SOFTWARE\NVIDIA Corporation\Riva TNT\
// 
// For WinNT, the registry values are all stored under 
//          \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\nv\DeviceXX
//
// Even though the implementation is different on NT, we'll attempt to keep the
// registry functionality as close to Win9x as possible.
//
//
// NOTE: Since OPENGL is NOT part of the NT display driver (it'a separate DLL),
//       it can read the registry by itself, and does NOT have its registry
//       switches in the same location as all the switches.
//       It's switches are still located in .\Software\NVIDIA Corporation\Riva TNT\
//
//
//      Please Refer to NVREG.H in the \drivers\common\inc directory to
//              see how this structure was obtained
//
//******************************************************************************

typedef struct _NT_NV_REGISTRY_SWITCH_OFFSET
    {
    U032    RegType;
    U008    RegName[REG_STRING_DATA_MAX];
    U032    Offset;
    } NT_NV_REGISTRY_SWITCH_OFFSET;


typedef struct _NT_NV_REGISTRY_DISPLAY
    {
    U008    LastDisplayDevice[REG_STRING_DATA_MAX];     // String
    U008    LastCRTMode[REG_STRING_DATA_MAX];           // String
    U008    LastDFPMode[REG_STRING_DATA_MAX];           // String
    U008    LastNTSCMode[REG_STRING_DATA_MAX];          // String
    U008    LastPALMode[REG_STRING_DATA_MAX];           // String
    U008    CRTMode[REG_STRING_DATA_MAX];               // String
    U008    DFPMode[REG_STRING_DATA_MAX];               // String
    U008    NTSCMode[REG_STRING_DATA_MAX];              // String
    U008    PALMode[REG_STRING_DATA_MAX];               // String
    U008    DefaultCRTRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    DefaultDFPRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    OptimalCRTRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    OptimalDFPRefreshRate[REG_STRING_DATA_MAX]; // String
    U008    DisplayDeviceType[REG_STRING_DATA_MAX];     // String
    U008    MonitorTiming[REG_STRING_DATA_MAX];         // String
    U032    DisplayType;                                // Dword
    U032    TVType;                                     // Dword
    U032    CursorAlpha;                                // Dword
    } NT_NV_REGISTRY_DISPLAY;

typedef struct _NT_NV_REGISTRY_DIRECTDRAW
    {
    U032    VPENABLE;                                   // Dword
    U032    OverlayMode;                                // Dword
    U032    OverlayColorControlEnable;                  // Dword
    U032    OverlayBrightness;                          // Dword
    U032    OverlayContrast;                            // Dword
    U032    OverlayHue;                                 // Dword
    U032    OverlaySaturation;                          // Dword
    U032    OverlayGamma;                               // Dword
    U032    OverlaySharpness;                           // Dword
    } NT_NV_REGISTRY_DIRECTDRAW;


typedef struct _NT_NV_REGISTRY_DIRECT3D
    {
    U032    ANTIALIASENABLE;                            // Dword
    U032    COLORKEYCOMPATABILITYENABLE;                // Dword
    U032    CONTROLTRAFFIC;                             // Dword
    U032    DIRECTMAPENABLE;                            // Dword
    U032    FOGTABLENABLE;                              // Dword
    U032    LOGOENABLE;                                 // Dword
    U032    SCENESYNCENABLE;                            // Dword
    U032    TILINGENABLE;                               // Dword
    U032    USERMIPMAPENABLE;                           // Dword
    U032    VIDEOTEXTUREENABLEENABLE;                   // Dword
    U032    VSYNCENABLE;                                // Dword
    U032    WENABLE;                                    // Dword
    U032    Z24ENABLE;                                  // Dword        
    U032    AAMETHOD;                                   // Dword
    U032    AUTOMIPMAPMETHOD;                           // Dword
    U032    CKREF;                                      // Dword
    U032    DX6ENABLE;                                  // Dword
    U032    ANISOTOPIC4TAP;                             // Dword
    U032    PAL8TEXTURECONVERT;                         // Dword
    U032    PMTRIGGER;                                  // Dword
    U032    TEXELALIGNMENT;                             // Dword
    U032    VALIDATEZMETHOD;                            // Dword
    U032    W16FORMAT;                                  // Dword
    U032    W32FORMAT;                                  // Dword
    U032    AGPTEXCUTOFF;                               // Dword       
    U032    D3DCONTEXTMAX;                              // Dword
    U032    D3DTEXTUREMAX;                              // Dword
    U032    DMAMINPUSHCOUNT;                            // Dword
    U032    LODBIASADJUST;                              // Dword     
    U032    MINVIDEOTEXSIZE;                            // Dword
    U032    MIPMAPLEVELS;                               // Dword       
    U032    PERFSTRATEGY;                               // Dword
    U032    NOVSYNCPREREDNERLIMIT;                      // Dword
    U032    DMAPUSHBUFFERSIZEMAX;                       // Dword
    U032    TEXHEAP;                                    // Dword
    U032    WSCALE16;                                   // Dword
    U032    WSCALE24;                                   // Dword
    
    
    } NT_NV_REGISTRY_DIRECT3D;


typedef struct _NT_NV_REGISTRY_SYSTEM
    {
    U032    Super7Compat;                               // Dword  
    U032    FlipOnHSync;                                // Dword                     
    U032    FilterOverride;                             // Dword                  
    U032    NoNT4AGP;                                   // Dword
    U032    George;                                     // Dword
    U032    Gracie;                                     // Dword
    U032    TVOutOnPrimary;                             // Dword
    U032    Enable256Burst;                             // Dword
    U032    DisableMPCDetect;                           // Dword
    U032    MemoryOverride;                             // Dword
    U032    RTLOverride;                                // Dword
    } NT_NV_REGISTRY_SYSTEM;


typedef struct _NT_NV_REGISTRY_NVTWEAK
    {
    U032    test;                                       // Dword
    } NT_NV_REGISTRY_NVTWEAK;
                     



    //**************************************************************************
    // Complete Registry Structure
    //**************************************************************************


typedef struct _NT_NV_REGISTRY
    {
    //**************************************************************************
    // DISPLAY Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DISPLAY Display;
            
    //**************************************************************************
    // DIRECTDRAW Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DIRECTDRAW DirectDraw;

    //**************************************************************************
    // DIRECT3D Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_DIRECT3D Direct3D;

    //**************************************************************************
    // RESMAN Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_SYSTEM System;

    //**************************************************************************
    // NVTWEAK Control Panel Registry switches
    //**************************************************************************

    NT_NV_REGISTRY_NVTWEAK NVTweak;


    } NT_NV_REGISTRY;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\multidev.c ===
// this module is compiled in DDK environment cause we need to deal with ddk.h only structs to walk 
// thru the list of devices!!!
// for this all routines have standard windows parameters like pvoid, ulong etc.

#include <ntddk.h>
#include <windef.h>
#undef WIN32
#include <nvos.h>
#include <nvntioctl.h>


// 
// ulQueryNumDevices walks thru the linked list of device objects and counts all devices which belong to one driver
// NOTE : a DeviceObject is the same than a hDriver in the Display driver
//
ULONG ulQueryNumDevices(PVOID pvDeviceObject)
{
	ULONG			ulNumDevices = 1;  // default is one device
	DEVICE_OBJECT   *pDevObj;
	DEVICE_OBJECT   *pRootDevObj;
	DRIVER_OBJECT   *pDrvObj;

	pDevObj =(DEVICE_OBJECT *)pvDeviceObject;
	if (pDevObj)
	{
		pDrvObj = pDevObj->DriverObject;
		if (pDrvObj)
		{
			pRootDevObj = pDrvObj->DeviceObject;
			pDevObj = pRootDevObj;
			while (pDevObj && pDevObj->NextDevice)
			{
				pDevObj = pDevObj->NextDevice;
				ulNumDevices++;
			}
		}
	}
	return ulNumDevices;
}

//
// bGetDevices walks thru the list of device objects and exports them thru ppvDevObjs
//
BOOLEAN bGetDevices(PVOID pvDeviceObject, PVOID *ppvDevObjs)
{
	BOOLEAN			bRet = FALSE;
	int				i = 0;
	DEVICE_OBJECT *pDevObj;
	DEVICE_OBJECT *pRootDevObj;
	DRIVER_OBJECT *pDrvObj;

	pDevObj =(DEVICE_OBJECT *)pvDeviceObject;
	if (pDevObj)
	{
		pDrvObj = pDevObj->DriverObject;
		if (pDrvObj)
		{
			bRet = TRUE;

			pRootDevObj = pDrvObj->DeviceObject;
			pDevObj = pRootDevObj;

			ppvDevObjs[i++] = (PVOID)pDevObj;

			while (pDevObj && pDevObj->NextDevice)
			{
				pDevObj = pDevObj->NextDevice;
				ppvDevObjs[i++] = (PVOID)pDevObj;
			}
		}
	}
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nv.h
//
// Abstract:
//
//     This module contains the definitions for the code that implements the
//     NVidia NV device driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

//******************************************************************************
// Include IOCTL codes to be shared among all components of driver
//******************************************************************************

#include <dspioctl.h>
#include "ntnvreg.h"

#ifdef NVPE
#include "nvpecntx.h"
#endif // NVPE

#include "nvMultiMon.h"

////////////////////////
// BUGBUG: The following section is extracted from nvmisc.h.
//         The miniport has no access to the nvidia\sdk directory !!!
//
//#include "nvmisc.h"
// 
// control struct and defines for NvRmI2CAccess()
//
typedef struct
{
    unsigned long	token;
    unsigned long	cmd;
    unsigned long	port;
    unsigned long	flags;
    unsigned long	data;
    unsigned long	status;
} NVRM_I2C_ACCESS_CONTROL;

// commands
#define	NVRM_I2C_ACCESS_CMD_ACQUIRE     1
#define	NVRM_I2C_ACCESS_CMD_RELEASE     2
#define	NVRM_I2C_ACCESS_CMD_WRITE_BYTE  3
#define	NVRM_I2C_ACCESS_CMD_READ_BYTE   4
#define	NVRM_I2C_ACCESS_CMD_NULL        5
#define	NVRM_I2C_ACCESS_CMD_RESET       6
#define NVRM_I2C_ACCESS_CMD_READ_SDA    7
#define NVRM_I2C_ACCESS_CMD_READ_SCL    8
#define NVRM_I2C_ACCESS_CMD_WRITE_SDA   9
#define NVRM_I2C_ACCESS_CMD_WRITE_SCL   10

// flags
#define NVRM_I2C_ACCESS_FLAG_START	    0x1
#define	NVRM_I2C_ACCESS_FLAG_STOP	    0x2
#define	NVRM_I2C_ACCESS_FLAG_ACK	    0x4

// port
#define	NVRM_I2C_ACCESS_PORT_PRIMARY    1
#define	NVRM_I2C_ACCESS_PORT_SECONDARY  2

// status
#define	NVRM_I2C_ACCESS_STATUS_SUCCESS         0
#define	NVRM_I2C_ACCESS_STATUS_ERROR           1
#define	NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR  2
#define	NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY     3

//
// misc string definitions for registry manipulation
//
#define STR_NVIDIA                  "NVidia"
#define STR_DEV_NODE_RM             "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\System"
#define STR_DEV_NODE_DISPLAY        "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display";
#define STR_DEV_NODE_DISPLAY_NUMBER "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display\\DeviceX";
#define STR_RM_CORE_NAME            "RmCoreName"

// End of extracted section
//////////////////////////////////////////////


//
// Undefine this line to disable interrupts via Mutex for Win2K and cli/sti for NT4.0
// This works OK on desktop Win2K but crashes on Toshiba laptop. So disable for now
//
// #define ENABLE_FP_MUTEX



//
// Win2K currently supports 8 different power states as defined in ntddvdeo.h
// We use 16 slots just as a cushion for future additional power states in succeeding
// versions of Win2K.
//
#define MAX_WIN2K_POWER_STATES 16
//
// The only power states of relevance in Win2K currently are on, standby, suspend, off, hibernate
//
#define NV_VideoPowerUnspecified 0
#define NV_VideoPowerOn 1
#define NV_VideoPowerStandBy 2
#define NV_VideoPowerSuspend 3
#define NV_VideoPowerOff 4
#define NV_VideoPowerHibernate 5
#define NV_VideoPowerShutdown 6


//******************************************************************************
// Common typedefs
//******************************************************************************

typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;

typedef unsigned char   V008;
typedef unsigned short  V016;
typedef unsigned long   V032;

typedef unsigned long   BOOL;
typedef long            S032;

#define LOWESTBIT(x)    ((x) & (((x)-1) ^ (x)))

#define PHYSICAL_ADDRESS_VALUE(p) ((p).LowPart)

//******************************************************************************
// Polymorphic type stubs for NT4
//******************************************************************************

#if (_WIN32_WINNT < 0x0500)
#define SIZE_T ULONG
#define ULONG_PTR ULONG
#endif // _WIN32_WINNT < 0x0500

//******************************************************************************
// Monitor types  -> Values MUST agree with those from RM !!!
//******************************************************************************

#define NV_MONITOR_VGA                  0
#define NV_MONITOR_NTSC                 2
#define NV_MONITOR_PAL                  3

// Use the following for monitor types. The ones above are obsolete names.
#define MONITOR_TYPE_VGA                0
#define MONITOR_TYPE_NTSC               2
#define MONITOR_TYPE_PAL                3
#define MONITOR_TYPE_FLAT_PANEL         4

// Use the following for display types. The ones above are obsolete names.
#define DISPLAY_TYPE_MONITOR            0
#define DISPLAY_TYPE_TV                 1
#define DISPLAY_TYPE_DUALSURFACE        2
#define DISPLAY_TYPE_FLAT_PANEL         3

//******************************************************************************
// Our hardcoded defines
//******************************************************************************

#define MAX_CLIP_REGIONS      16
#define MAX_GRPATCH_FANOUT    56
#define MAX_GRPATCH_INPUT     56
#define NUM_PATCHES           10
#define NUM_SUBCHANNELS       8
#define NUM_GRAPHICS_DEVICES  0x1e
#define INVALID               0xffffffff;
#define BIOS_STR_MAX 50

//******************************************************************************
// Size of saved BIOS image (used for manual posting)
//******************************************************************************

#define SAVED_BIOS_IMAGE_SIZE   0x10000

//******************************************************************************
// Bios memory sizing adjust value (for RM Post Device memory sizing)
//******************************************************************************

#define BIOS_MEM_SIZE_ADJUST_FACTOR 0x00010000;

//******************************************************************************
// EDID buffer size (in bytes)
//******************************************************************************

#define EDID_V2_SIZE   256

//******************************************************************************
// Max Size in bytes of saved instance memory (used when powering down)
//******************************************************************************

#define MAX_INSTANCE_MEM_SIZE   0x30000

//******************************************************************************
// Enough memory to store registry data
//
// Set MAX of 30 numbers per mode entry (each line) in INF
// Set MAX of 90  mode entries ( MAX 30 width_height * 3 (for depths))
// Data table will consist of type U016
//
//          Registry Data Format (word values)
//              MAX word values per line = 30 word values
//              MAX of 90 lines (90 mode entries)
//
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           BITDEPTH, WIDTH, HEIGHT, Refresh1, Refresh2, etc...., 0 ,
//           etc...
//******************************************************************************

#define MAX_STRING_REGISTRY_VALUES  30
#define MAX_STRING_REGISTRY_LINES   90
#define MAX_STRING_REGISTRY_DATA_WORDS (MAX_STRING_REGISTRY_VALUES * MAX_STRING_REGISTRY_LINES)

//******************************************************************************
// Enough memory to store valid mode table data
// Set MAX of 1800 mode entries ( MAX 30 width/height * 3 (for depths) * MAX 20 refresh rates)
// Each struct entry  has 5 entries (valid flag, width,height, bpp, refresh)
// Data table will consist of type U016
//******************************************************************************

#define MAX_VALID_MODE_REFRESH_RATES 20
#define MAX_VALID_MODE_TABLE_DATA_WORDS (MAX_STRING_REGISTRY_LINES * MAX_VALID_MODE_REFRESH_RATES * 5)


#define MAX_BIOS_SCAN 1024

//******************************************************************************
// VSync/HSync defines
//******************************************************************************

#define BUFFER_HSYNC_NEGATIVE  0
#define BUFFER_HSYNC_POSITIVE  1

//******************************************************************************
// Memory types
//******************************************************************************

#define NV_BUFFER_SDRAM            0
#define NV_BUFFER_SGRAM            1

//******************************************************************************
// Resolution defines
//******************************************************************************
#define RESOLUTION_640X480      0
#define RESOLUTION_320X240      3
#define RESOLUTION_320X400      6
#define RESOLUTION_400X300      9
#define RESOLUTION_480X360      12
#define RESOLUTION_512X384      15
#define RESOLUTION_640X400      18
#define RESOLUTION_320X200      21
#define RESOLUTION_800X600      24
#define RESOLUTION_960X720      27
#define RESOLUTION_1024X768     30
#define RESOLUTION_1152X864     33
#define RESOLUTION_1280X1024    36
#define RESOLUTION_1600X1200    39
#define RESOLUTION_1800X1440    42
#define RESOLUTION_1920X1080    45
#define RESOLUTION_1920X1200    48

//******************************************************************************
// Various NV Chip ID's
//******************************************************************************

#define NV1_REV_B_02             2
#define NV1_REV_B_03             3
#define NV1_REV_C_01             4
#define NV1_REV_C_02             5
#define NV3_REV_A_00             0
#define NV3_REV_B_00             1
#define NV3_REV_C_00             2


//******************************************************************************
// NV1 Color Format values to be used to generate CONTEXT values
// for STATIC image objects. (Assumes only Destination Buffer 0 enabled)
//******************************************************************************

#define COLOR_FORMAT_X17R5G5B5        0x00000000
#define COLOR_FORMAT_X16A1R5G5B5      0x00002000
#define COLOR_FORMAT_X8R8G8B8         0x00000200
#define COLOR_FORMAT_A8R8G8B8         0x00002200
#define COLOR_FORMAT_X2R10G10B10      0x00000400
#define COLOR_FORMAT_A2R10G10B10      0x00002400
#define COLOR_FORMAT_X24Y8            0x00000600
#define COLOR_FORMAT_X16A8Y8          0x00002600

//******************************************************************************
// NV3 Color Format values to be used to generate CONTEXT values
// for STATIC image objects. (Assumes only Destination Buffer 0 enabled)
// See PGRAPH_CTX_SWITCH register definition for more information.
//******************************************************************************

#define NV3_COLOR_FORMAT_X17R5G5B5        (0x00000000)
#define NV3_COLOR_FORMAT_X16A1R5G5B5      (0x00000008 | 0x00000000)
#define NV3_COLOR_FORMAT_X8R8G8B8         (0x00000001)
#define NV3_COLOR_FORMAT_A8R8G8B8         (0x00000008 | 0x00000001)
#define NV3_COLOR_FORMAT_X2R10G10B10      (0x00000002)
#define NV3_COLOR_FORMAT_A2R10G10B10      (0x00000008 | 0x00000002)
#define NV3_COLOR_FORMAT_X24Y8            (0x00000003)
#define NV3_COLOR_FORMAT_X16A8Y8          (0x00000008 | 0x00000003)
#define NV3_COLOR_FORMAT_Y16                           (0x00000004)


//******************************************************************************
// Monochrome Format values to be used to generate CONTEXT values
// See the CTX_SWITCH register definition for more information (Bit 14)
//******************************************************************************

#define MONO_FORMAT_LE        0x00000000
#define MONO_FORMAT_CGA6      0x00004000

#define NV3_MONO_FORMAT_LE    0x00000000
#define NV3_MONO_FORMAT_CGA6  0x00000100

//******************************************************************************
// NV1 Cursor defines
//******************************************************************************

#define NV1_DAC_CURSOR_TWO_COLOR_XOR    2
#define NV1_DAC_CURSOR_TWO_COLOR        3

//******************************************************************************
// ID values for STATIC image objects
// (Index into the CommonObject array - Currently allow up to 10)
//******************************************************************************

#define IMAGE_SOLID_ID                 0
#define IMAGE_BLACK_RECTANGLE_ID       1
#define IMAGE_PATTERN_ID               2
#define IMAGE_ROP_ID                   3

//******************************************************************************
// ID values for the patches, each is associated with a Rendering object
// (Index into the Render Object array - Currently allow up to 15)
//******************************************************************************

#define RECTANGLE_PATCH                0
#define TRIANGLE_PATCH                 1
#define BLIT_PATCH                     2
#define IMAGE_FROM_CPU_PATCH           3
#define IMAGE_MONO_FROM_CPU_PATCH      4
#define D3DTRIANGLE_PATCH              5
#define CLEARZ_PATCH                   6
#define SRCIMAGE_IN_MEMORY_PATCH       7
#define DSTIMAGE_IN_MEMORY_PATCH       8
#define MEMORY_TO_MEMORY_PATCH         9
#define D3DTRIANGLE_SYSMEM_PATCH       10
#define RENDER_SOLID_LIN_PATCH         11

//******************************************************************************
// Special cased ROP3 operations
//******************************************************************************

#define BLACKNESS 0x0000
#define DSTINVERT 0x0055
#define PATINVERT 0x005A
#define SRCAND    0x0088
#define DSTCOPY   0x00AA
#define SRCCOPY   0x00CC
#define SRCPAINT  0x00EE
#define PATCOPY   0x00F0
#define WHITENESS 0x00FF
//******************************************************************************
// Number of dacs
//******************************************************************************
#define NV_NO_DACS                  2

//******************************************************************************
// maximum Number of output device connectors on a board.
//******************************************************************************
#define NV_NO_CONNECTORS                  24

//******************************************************************************
// Type of video ram
//******************************************************************************

#define BUFFER_DRAM 0
#define BUFFER_VRAM 1

//******************************************************************************
// Page size definitions.
//******************************************************************************
#if defined(_M_IA64)

#define PAGE_SIZE 0x2000

#elif defined(_M_IX86)

#define PAGE_SIZE 0x1000

#endif

//******************************************************************************
// This cursor structure MUST also match the one defined in driver.h
// (in the display driver directory)
//******************************************************************************

typedef struct _TV_CURSOR_ADJUST_INFO
    {
    ULONG   MonitorType;
    ULONG   Underscan_x;
    ULONG   Underscan_y;
    ULONG   Scale_x;
    ULONG   Scale_y;
    ULONG   FilterEnable;
    ULONG   TVCursorMin;
    ULONG   TVCursorMax;
    } TV_CURSOR_ADJUST_INFO;


//******************************************************************************
// Current PRAMIN map: (Currently only 64k is allocated for total PRAMIN size)
//                      in NV3_IsPresent()
//
// Offset   Type of Instance Data
// ======   =====================
//
//          ------------------------------   <--- Start of PRAMIN area
// 0        Hash Table                       ^
//          Run Out                          |
//          Fifo Context                     |
//          Free Instances                   |
//                                           |
//                                           |
//                                           |
//          ------------------------------   |
// 16k                                       |
//                                           |
//                                           |
//                                           |
//                                           |
//                                           |
//                                           |
//          ------------------------------   |----> 64k allocated for PRAMIN
// 32k      VRAM Texture Page Table Entries  |
//          (Used by D3DTriangle Object for  |
//           textures in VRAM)               |
//                                           |
// 42k      SYSMEM Texture Page Table Entreis|
//          (Used by the D3dTriangle Object  |
//           for textures in System Memory)  |
//                                           |
//          ------------------------------   |
// 48k      Cursor data (8 cached images)    |
//          Each bitmap takes up 2k          |
//                                           |
//                                           |
//                                           |
//                                           v
// 64k      ------------------------------
//
//******************************************************************************

//******************************************************************************
// Types of Engine known to FIFO (NV3)
//******************************************************************************

#define ENGINE_SW       0
#define ENGINE_GRAPHICS 1

//******************************************************************************
// Dedicated privileged device ram size in bytes. (NV1)
//******************************************************************************

#define NV_PRAM_DEVICE_SIZE_12_KBYTES   0x3000  // 12KB
#define NV_PRAM_DEVICE_SIZE_20_KBYTES  0x5000   // 20KB
#define NV_PRAM_DEVICE_SIZE_36_KBYTES  0x9000   // 36KB
#define NV_PRAM_DEVICE_SIZE_68_KBYTES  0x11000  // 68KB

//******************************************************************************
// NV3's privileged size, minus audio (NV3)
//******************************************************************************

#define NV_PRAM_DEVICE_SIZE_5_5_KBYTES   0x1600 // 5.5KB
#define NV_PRAM_DEVICE_SIZE_9_5_KBYTES   0x2600 // 9.5KB
#define NV_PRAM_DEVICE_SIZE_17_5_KBYTES  0x4600 // 17.5KB
#define NV_PRAM_DEVICE_SIZE_33_5_KBYTES  0x8600 // 33.5KB

//******************************************************************************
// Offscreen Instance Memory size.
//******************************************************************************

#define NV_PRAM_MIN_SIZE_INSTANCE_MEM  0x1000   // 4KB

#define BUFFER_HSYNC_NEGATIVE           0
#define BUFFER_HSYNC_POSITIVE           1
#define BUFFER_VSYNC_NEGATIVE           0
#define BUFFER_VSYNC_POSITIVE           1
#define BUFFER_CSYNC_DISABLED           0
#define BUFFER_CSYNC_ENABLED            1

//******************************************************************************
// Forward declaration of all structures
//******************************************************************************

typedef struct _def_object                  OBJECT,*POBJECT;
typedef struct _def_common_object           COMMONOBJECT, *PCOMMONOBJECT;
typedef struct _def_render_common           RENDERCOMMON, *PRENDERCOMMON;
typedef struct _def_render_common_object    RENDERCOMMONOBJECT, *PRENDERCOMMONOBJECT;
typedef struct _def_image_blt_object        IMAGEBLITOBJECT, *PIMAGEBLITOBJECT;
typedef struct _def_image_mem_object        IMAGEMEMOBJECT, *PIMAGEMEMOBJECT;
typedef struct _def_render_object           RENDEROBJECT, *PRENDEROBJECT;
typedef struct _def_render_beta_object      RENDERBETAOBJECT, *PRENDERBETAOBJECT;
typedef struct _def_video_object            VIDEOOBJECT, *PVIDEOOBJECT;
typedef struct _def_video_patchcord         VIDEOPATCHCORD, *PVIDEOPATCHCORD;
typedef struct _def_video_switch_object     VIDEOSWITCHOBJECT, *PVIDEOSWITCHOBJECT;
typedef struct _def_ordinal_object          ORDINALOBJECT, *PORDINALOBJECT;
typedef struct _def_video_sink              VIDEOSINKOBJECT, *PVIDEOSINKOBJECT;
typedef struct _def_video_colormap_object   VIDEOCOLORMAPOBJECT, *PVIDEOCOLORMAPOBJECT;
typedef struct _def_image_object            IMAGEOBJECT, *PIMAGEOBJECT;
typedef struct _def_image_patchcord         IMAGEPATCHCORD, *PIMAGEPATCHCORD;
typedef struct _def_image_video_object      IMAGEVIDEOOBJECT, *PIMAGEVIDEOOBJECT;
typedef struct _def_rop_patchcord           ROPPATCHCORD, *PROPPATCHCORD;
typedef struct _def_solid_object            SOLIDOBJECT, *PSOLIDOBJECT;
typedef struct _def_black_rect_object       CLIPOBJECT, *PCLIPOBJECT;
typedef struct _def_pattern_object          PATTERNOBJECT, *PPATTERNOBJECT;
typedef struct _def_rop_object              ROPOBJECT, *PROPOBJECT;
typedef struct _def_beta_object             BETAOBJECT, *PBETAOBJECT;
typedef struct _def_beta_max_object         BETAMAXOBJECT, *PBETAMAXOBJECT;
typedef struct _def_bool_object             BOOLOBJECT, *PBOOLOBJECT;
typedef struct _def_blend_object            BLENDOBJECT, *PBLENDOBJECT;
typedef struct _def_beta_patchcord          BETAPATCHCORD, *PBETAPATCHCORD;
typedef struct _def_stencil_object          STENCILOBJECT, *PSTENCILOBJECT;
typedef struct _def_colorkey_object         COLORKEYOBJECT, *PCOLORKEYOBJECT;
typedef struct _def_plane_mask_object       PLANEMASKOBJECT, *PPLANEMASKOBJECT;
typedef struct _def_fifo                    FIFO, *PFIFO;
typedef struct _def_patch_context           PATCHCONTEXT, *PPATCHCONTEXT;
typedef struct _def_graphics_patch          GRAPHICSPATCH, *PGRAPHICSPATCH;
typedef struct _def_graphics_channel        GRAPHICSCHANNEL, *PGRAPHICSCHANNEL;
typedef struct _def_canvas                  CANVAS, *PCANVAS;
typedef struct _def_node                    NODE, *PNODE;

//******************************************************************************
// Regular Object
//******************************************************************************


struct _def_object
{
    U032       Name;
    U032       ChID;
    U032       ClassType;
};

//******************************************************************************
// Common Object
//******************************************************************************

struct _def_common_object
{
    OBJECT      Base;
    U032        Valid;
    U032        NotifyPending;
    U032        Context;
    U032        Device;
    U032        Instance;           // Useful for NV3 (Uses Instance Addresses)
    PCOMMONOBJECT Next;
    U032        ColorFormat;
    U032        MonoFormat;
};

//******************************************************************************
// Macros to get to the common fields
//******************************************************************************

#define CBase            Common.Base
#define CValid           Common.Valid
#define CNotifyPending   Common.NotifyPending
#define CContext         Common.Context
#define CDevice          Common.Device
#define CInstance        Common.Instance
#define CNext            Common.Next
#define CColorFormat     Common.ColorFormat
#define CMonoFormat      Common.MonoFormat


//******************************************************************************
// BTREE structure.
//******************************************************************************

struct _def_node
{
    U032              Value;
    VOID             *Data;
    U032              LeftCount;
    U032              RightCount;
    struct _def_node *LeftBranch;
    struct _def_node *RightBranch;
} ;

//******************************************************************************
// Canvas
//******************************************************************************

struct _def_canvas
{
    NODE Node;
    U032 CanvasID;
    U032 UsageCount;
    U032 BufferToggle;
    U032 xyMin;
    U032 xyMax;
    U032 ClipCount;
    U032 ClipMisc;
    U032 xyClipMin[MAX_CLIP_REGIONS];
    U032 xyClipMax[MAX_CLIP_REGIONS];
    U032 InOutClip[MAX_CLIP_REGIONS];
    U032 CplxClipCount;
    U032 xyCplxClipMin[2];
    U032 xyCplxClipMax[2];
} ;


//******************************************************************************
// Video Object
//******************************************************************************

struct _def_video_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput[MAX_GRPATCH_INPUT];
} ;

//******************************************************************************
// Video Patchcord
//******************************************************************************

struct _def_video_patchcord
{
    OBJECT       Base;
    PVIDEOOBJECT Source;
    PVIDEOOBJECT Destination;
} ;

//******************************************************************************
// Video Switch Object
//******************************************************************************

struct _def_video_switch_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput[2];
//    VBLANKNOTIFY    VBlankNotify[2];
    PORDINALOBJECT  Ordinal;
    PCANVAS         Canvas;
} ;

//******************************************************************************
// Ordinal Object
//******************************************************************************

struct _def_ordinal_object
{
    OBJECT             Base;
    U032               Value;
    PVIDEOSWITCHOBJECT Switch[MAX_GRPATCH_FANOUT];
    U032               FanOut;
} ;

//******************************************************************************
// Video Sink Object
//******************************************************************************

struct _def_video_sink
{
    OBJECT          Base;
//    PDMAOBJECT      NameXlate;
    PVIDEOPATCHCORD VideoInput[MAX_GRPATCH_INPUT];
} ;

//******************************************************************************
// Video ColorMap Object
//******************************************************************************

struct _def_video_colormap_object
{
    OBJECT          Base;
    PVIDEOPATCHCORD VideoOutput;
    PVIDEOPATCHCORD VideoInput;
    U032            ColorFormat;
//    PDMAOBJECT      Xlate;
    U032            Start;
    U032            Length;
    U032            DirtyStart;
    U032            DirtyLength;
    U032            ColorMap[256];
} ;

//******************************************************************************
// Image Object
//******************************************************************************

struct _def_image_object
{
    OBJECT          Base;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[MAX_GRPATCH_INPUT];
} ;

//******************************************************************************
// Image Patchcord
//******************************************************************************

struct _def_image_patchcord
{
    OBJECT       Base;
    U032         FanOut;
    PIMAGEOBJECT Source;
    PIMAGEOBJECT Destination[MAX_GRPATCH_FANOUT];
} ;

//******************************************************************************
// Image Video Object
//******************************************************************************

struct _def_image_video_object
{
    OBJECT          Base;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[MAX_GRPATCH_INPUT];
    PVIDEOPATCHCORD VideoOutput;
//    PDMAOBJECT      NameXlate;
    PCANVAS         Canvas;
    U032            Buffer;
} ;

//******************************************************************************
// ROP Patchcord
//******************************************************************************

struct _def_rop_patchcord
{
    OBJECT      Base;
    U032        FanOut;
    PROPOBJECT  Source;
    PBOOLOBJECT Destination[MAX_GRPATCH_FANOUT];
} ;

//******************************************************************************
// Solid Object
//******************************************************************************

struct _def_solid_object
{
        COMMONOBJECT    Common;
    PIMAGEPATCHCORD ImageOutput;
    U032            Color;
} ;

//******************************************************************************
// Clip Object
//******************************************************************************

struct _def_black_rect_object
{
    COMMONOBJECT    Common;
    PIMAGEPATCHCORD ImageOutput;
    U032            xClipMin;
    U032            xClipMax;
    U032            yClipMin;
    U032            yClipMax;
} ;

//******************************************************************************
// Pattern Object
//******************************************************************************

struct _def_pattern_object
{
    COMMONOBJECT    Common;
    PIMAGEPATCHCORD ImageOutput;
    U032            PattColor0;
    U032            PattColor0Alpha;
    U032            PattColor1;
    U032            PattColor1Alpha;
    U032            Pattern0;
    U032            Pattern1;
    U032            PatternShape;
} ;

//******************************************************************************
// Rop Object
//******************************************************************************

struct _def_rop_object
{
    COMMONOBJECT  Common;
    PROPPATCHCORD RopOutput;
    U032          Rop3;
} ;


//******************************************************************************
// Beta Object
//******************************************************************************

struct _def_beta_object
{
    COMMONOBJECT   Common;
    PBETAPATCHCORD BetaOutput;
    U032           Beta;
} ;

//******************************************************************************
// Beta Max Object
//******************************************************************************

struct _def_beta_max_object
{
    OBJECT         Base;
    PBETAPATCHCORD BetaOutput;
    PBETAPATCHCORD BetaInput[2];
} ;

//******************************************************************************
// Bool object
//******************************************************************************

struct _def_bool_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[3];
    PROPPATCHCORD     RopInput;
    PROPOBJECT        RopObject;
    PPATTERNOBJECT    PatObject;
    PIMAGEVIDEOOBJECT DstObject;
    U032              Config;
} ;

//******************************************************************************
// Blend Object
//******************************************************************************

struct _def_blend_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[2];
    PBETAPATCHCORD    BetaInput;
    PPATTERNOBJECT    PatObject;
    PCOMMONOBJECT     SrcObject;
    PBETAOBJECT       BetaObject;
    PIMAGEVIDEOOBJECT DstObject;
    U032              Config;
} ;


//******************************************************************************
// Beta Patchcord Object
//******************************************************************************

struct _def_beta_patchcord
{
    OBJECT  Base;
    U032    FanOut;
    POBJECT Source;
    POBJECT Destination[MAX_GRPATCH_FANOUT];
} ;

//******************************************************************************
// Stencil Object
//******************************************************************************

struct _def_stencil_object
{
    OBJECT          Base;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput[2];
    PCLIPOBJECT     ClipObject;
} ;

//******************************************************************************
// Color Key Object
//******************************************************************************

struct _def_colorkey_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[2];
    PSOLIDOBJECT      ColorObject;
    PIMAGEVIDEOOBJECT DstObject;
} ;

//******************************************************************************
// Plane Mask Object
//******************************************************************************

struct _def_plane_mask_object
{
    OBJECT            Base;
    PIMAGEPATCHCORD   ImageOutput;
    PIMAGEPATCHCORD   ImageInput[3];
    PSOLIDOBJECT      ColorObject;
    PIMAGEVIDEOOBJECT DstObject;
} ;

//******************************************************************************
// Graphics patch context representation,
//
// NOTE: In the RESOURCE MANAGER, this structure mainly consists of POINTERS.
//       But here, we store the actual structures, so we don't have to
//       allocate the memory dynamically.  That is, instead of PROPOBJECT,
//       we use ROPOBJECT instead.  This will take up memory in the
//       HwDeviceExtension structure (which holds all the 'global' values.
//
//******************************************************************************

struct _def_patch_context
{
    U032                 ImageConfig;
    U032                 VideoConfig;
//    PIMAGEVIDEOOBJECT    ImageVideo;
//    PCANVAS              Canvas;
//    PROPOBJECT           Rop;
//    PPATTERNOBJECT       RopPat;
//    PIMAGEVIDEOOBJECT    RopDst;
//    PBETAOBJECT          Beta;
//    PCOMMONOBJECT        BetaSrc;
//    PPATTERNOBJECT       BetaPat;
//    PIMAGEVIDEOOBJECT    BetaDst;
//    PSOLIDOBJECT         ColorKey;
//    PSOLIDOBJECT         PlaneMask;
//    PIMAGEVIDEOOBJECT    PlaneMaskDst;
//    PCLIPOBJECT          Clip;
//    PPATTERNOBJECT       Pattern;
//    PVIDEOCOLORMAPOBJECT ColorMap0;
//    PVIDEOCOLORMAPOBJECT ColorMap1;
//    PVIDEOSWITCHOBJECT   VideoSwitch;

      IMAGEVIDEOOBJECT    ImageVideo;
      CANVAS              Canvas;
      ROPOBJECT           Rop;
      PATTERNOBJECT       RopPat;
      IMAGEVIDEOOBJECT    RopDst;
      BETAOBJECT          Beta;
      COMMONOBJECT        BetaSrc;
      PATTERNOBJECT       BetaPat;
      IMAGEVIDEOOBJECT    BetaDst;
      SOLIDOBJECT         ColorKey;
      SOLIDOBJECT         PlaneMask;
      IMAGEVIDEOOBJECT    PlaneMaskDst;
      CLIPOBJECT          Clip;
      PATTERNOBJECT       Pattern;
      VIDEOCOLORMAPOBJECT ColorMap0;
      VIDEOCOLORMAPOBJECT ColorMap1;
      VIDEOSWITCHOBJECT   VideoSwitch;


} ;

//******************************************************************************
// Render Common Object
//******************************************************************************

struct _def_render_common
{
    PGRAPHICSPATCH  Patch;
    PATCHCONTEXT    PatchContext;
//    PDMAOBJECT      Xlate;
} ;

//******************************************************************************
// Macros to get to the common fields
//******************************************************************************

#define RCPatch            RenderCommon.Patch
#define RCPatchContext     RenderCommon.PatchContext
#define RCXlate            RenderCommon.Xlate


//******************************************************************************
// RenderCommon Object
//******************************************************************************

struct _def_render_common_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
} ;

//******************************************************************************
// Image Blit Object
//******************************************************************************

struct _def_image_blt_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
    PIMAGEPATCHCORD ImageInput;
} ;

//******************************************************************************
// ImageMem Object
//******************************************************************************

struct _def_image_mem_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageInputOutput;
} ;

//******************************************************************************
// Render Object
//******************************************************************************

struct _def_render_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
} ;

//******************************************************************************
// Render Beta Object
//******************************************************************************

struct _def_render_beta_object
{
    COMMONOBJECT    Common;
    RENDERCOMMON    RenderCommon;
    PIMAGEPATCHCORD ImageOutput;
    PBETAPATCHCORD  BetaOutput;
} ;

//******************************************************************************
// FIFO structure
//******************************************************************************

struct _def_fifo
{
    BOOL    InUse;
    U032    ChID;
//    POBJECT ObjectStack[NUM_SUBCHANNELS];
    ULONG   ObjectStack[NUM_SUBCHANNELS];
    ULONG   SavedChDevInstance[NUM_SUBCHANNELS];
    ULONG   SavedContext[NUM_SUBCHANNELS];
    U032    ObjectCount;
} ;

//******************************************************************************
// Graphics Channel Patch Table
//******************************************************************************

struct _def_graphics_patch
{
    U032                 UsageCount;        // # of objects using this patch c
    U032                 RopUsage;          // # of objects using ROP.
    U032                 BetaUsage;         // # of objects using Beta.
    U032                 ColorKeyUsage;     // # of objects using Color Key.
    U032                 PlaneMaskUsage;    // # of objects using Plane Mask.
    U032                 ClipUsage;         // # of objects using Clip.
    U032                 PatternUsage;      // # of objects using Pattern.
    PGRAPHICSPATCH       Next;
    PRENDERCOMMONOBJECT  XferObject;        // DMA information for graphics.
    PCANVAS              Canvas;            // Associated canvas to this patch
    U032                 xyMinPrev;         // Previous xyMin of canvas.
    U032                 xyMaxPrev;         // Previous xyMax of canvas.
    PVIDEOCOLORMAPOBJECT ColorMap0;         // Associated colormap to buffer 0
    PVIDEOCOLORMAPOBJECT ColorMap1;         // Associated colormap to buffer 1
    PVIDEOSWITCHOBJECT   VideoSwitch;       // Associated video switch.
    PCOMMONOBJECT        UserObjects[NUM_GRAPHICS_DEVICES];
    U032                 AbsX[18];          // Internal state that isn't
    U032                 AbsY[18];          // object specific.  It is
    U032                 XYLogicMisc0;      // restored for whatever
    U032                 XYLogicMisc1;      // object that was last
    U032                 XMisc;             // rendering.
    U032                 YMisc;             // ...
    U032                 CanvasMisc;        // ...
    U032                 MonoColor0;        // ...
    U032                 MonoColor1;        // ...
    U032                 SourceColor;       // ...
    U032                 SubDivide;         // ...
    U032                 EdgeFill;          // ...
    U032                 BetaRam[14];       // ...
    U032                 XAbsIClipMax;      // ...
    U032                 YAbsIClipMax;      // ...
    U032                 Bit33;             // ...
} ;


//******************************************************************************
// Graphics Channel Patch Table
//******************************************************************************

struct _def_graphics_channel
{
    PCOMMONOBJECT  NotifyObject;
    U032           Notify;
    PROPOBJECT     CurrentRop;
    PBETAOBJECT    CurrentBeta;
    PSOLIDOBJECT   CurrentColorKey;
    PSOLIDOBJECT   CurrentPlaneMask;
    PCLIPOBJECT    CurrentClip;
    PPATTERNOBJECT CurrentPattern;
    PGRAPHICSPATCH CurrentPatch;
    PGRAPHICSPATCH PatchList;
    U032           PatchCount;
    U032           Exceptions;
} ;

//******************************************************************************
// Register base macros
//******************************************************************************

#define PMC_Base            HwDeviceExtension->NV1_Lin_PMC_Registers
#define PFB_Base            HwDeviceExtension->NV1_Lin_PFB_Registers
#define PRM_Base            HwDeviceExtension->NV1_Lin_PRM_Registers
#define PDAC_Base           HwDeviceExtension->NV1_Lin_PDAC_Registers
#define PRAM_Base           HwDeviceExtension->NV1_Lin_PRAM_Registers
#define PRAMFC_Base         HwDeviceExtension->NV1_Lin_PRAMFC_Registers
#define PRAMHT_Base         HwDeviceExtension->NV1_Lin_PRAMHT_Registers
#define USER_Base           HwDeviceExtension->NV1_Lin_USER_Registers
#define PFIFO_Base          HwDeviceExtension->NV1_Lin_PFIFO_Registers
#define PBUS_Base           HwDeviceExtension->NV1_Lin_PBUS_Registers
#define PGRAPH_Base         HwDeviceExtension->NV1_Lin_PGRAPH_Registers
#define CONFIG_Base         HwDeviceExtension->NV1_Lin_CONFIG_Registers
#define MEM_Base            HwDeviceExtension->NV1_Lin_MEM_Registers
#define IO_Base             HwDeviceExtension->NV1_Lin_IO_Registers
#define PDMA_Base           HwDeviceExtension->NV1_Lin_PDMA_Registers
#define PTIMER_Base         HwDeviceExtension->NV1_Lin_PTIMER_Registers
#define PAUDIO_Base         HwDeviceExtension->NV1_Lin_PAUDIO_Registers
#define PAUTH_Base          HwDeviceExtension->NV1_Lin_PAUTH_Registers
#define PEXTDEV_Base        HwDeviceExtension->NV1_Lin_PEXTDEV_Registers
#define PEEPROM_Base        HwDeviceExtension->NV1_Lin_PEEPROM_Registers
#define PROM_Base           HwDeviceExtension->NV1_Lin_PROM_Registers
#define PALT_Base           HwDeviceExtension->NV1_Lin_PALT_Registers
#define PRMIO_Base          HwDeviceExtension->NV1_Lin_PRMIO_Registers
#define URECT_Base          HwDeviceExtension->NV1_Lin_URECT_Registers
#define UTRI_Base           HwDeviceExtension->NV1_Lin_UTRI_Registers
#define UBLIT_Base          HwDeviceExtension->NV1_Lin_UBLIT_Registers
#define UIMAGE_Base         HwDeviceExtension->NV1_Lin_UIMAGE_Registers
#define UBITMAP_Base        HwDeviceExtension->NV1_Lin_UBITMAP_Registers
#define PRAMIN_Base         HwDeviceExtension->NV3_Lin_PRAMIN_Registers
#define PRMVIO_Base         HwDeviceExtension->NV3_Lin_PRMVIO_Registers
#define PRMCIO_Base         HwDeviceExtension->NV3_Lin_PRMCIO_Registers
#define PRAMDAC_Base        HwDeviceExtension->NV3_Lin_PRAMDAC_Registers
#define USERDAC_Base        HwDeviceExtension->NV3_Lin_USERDAC_Registers
#define PVIDEO_Base         HwDeviceExtension->NV3_Lin_PVIDEO_Registers

//******************************************************************************
// Device macros
//******************************************************************************


#define GR_DEVICE_INDEX(d)      ((((d)>>16)&0x7F)-0x41)


//******************************************************************************
//
// Save/Restore state macros for graphics engine
//
//******************************************************************************

#define GR_SAVE_STATE(misc)                                                             \
{                                                                                   \
        misc = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_MISC);    \
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC, DRF_DEF(_PGRAPH, _MISC, _FIFO_WRITE, _ENABLED)     \
                        | DRF_DEF(_PGRAPH, _MISC, _FIFO,       _DISABLED));  \
}

#define GR_RESTORE_STATE(misc)                                                          \
{                                                                                   \
        PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_MISC, DRF_DEF(_PGRAPH, _MISC, _FIFO_WRITE, _ENABLED)     \
                              | (DRF_DEF(_PGRAPH, _MISC, _FIFO, _ENABLED) & misc)); \
}

//*************************************************************************
// Graphics Engine DONE and IDLE macros
//*************************************************************************

#define GR_IDLE     while ((volatile)PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_STATUS))  \
                        {                                                            \
                        V032 pmc;                                                    \
                        pmc = PMC_REG_RD32(PMC_Base,NV_PMC_INTR_0);                  \
                        if (pmc & DRF_DEF(_PMC,_INTR_0,_PGRAPH,_PENDING))            \
                            VideoDebugPrint((0, "Interrupt pending in GR_IDLE"));    \
                        }

#define GR_DONE     while ((volatile)PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_STATUS));

#define GR_IDLE_NV3 while ((volatile)PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_STATUS))  \
                        {                                                            \
                        V032 pmc;                                                    \
                        pmc = PMC_REG_RD32(PMC_Base,NV_PMC_INTR_0);                  \
                        if (pmc & DRF_DEF(_PMC,_INTR_0,_PGRAPH0,_PENDING))            \
                            VideoDebugPrint((0, "Interrupt pending in GR_IDLE_NV3"));  \
                        }



//******************************************************************************
//
// Hash table function.
//
//******************************************************************************

#define FIFO_HASH(h,c)  ((((h)^((h)>>8)^((h)>>16)^((h)>>24))&0xFF)^((c)&0x7F))
#define HASH_DEPTH      4
#define HASH_ENTRY(h,d) ((h)*HASH_DEPTH+(d))


//******************************************************************************
//
// NV Reference Manual register access definitions.
//
//******************************************************************************


typedef union _def_HwReg
{
    volatile V008 Reg008[1];
    volatile V016 Reg016[1];
    volatile V032 Reg032[1];
} HWREG, * PHWREG;

// Start using flat register range (instead of using multiple ranges)

#define REG_WR32(a,d)   (HwDeviceExtension->NvRegisterBase)->Reg032[(a)/4]=(U032)(d)
#define REG_RD32(a)     (HwDeviceExtension->NvRegisterBase)->Reg032[(a)/4]
#define REG_WR08(a,d)   (HwDeviceExtension->NvRegisterBase)->Reg008[(a)]  =(U008)(d)
#define REG_RD08(a)     (HwDeviceExtension->NvRegisterBase)->Reg008[(a)]


//#ifdef PC98
#define MEM_WR32(a,d)   fbAddr->Reg032[(a)/4]=(U032)(d)
#define MEM_RD32(a)     fbAddr->Reg032[(a)/4]
//#endif // PC98


#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d) - DEVICE_BASE(d) + 1
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAMIN registers (NV3)
//******************************************************************************

#define PRAMIN_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMIN))/4]=(U032)(d)
#define PRAMIN_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMIN))/4]
#define PRAMIN_REG_WR_DRF_NUM(b,d,r,f,n) PRAMIN_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMIN_REG_WR_DRF_DEF(b,d,r,f,c) PRAMIN_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMIN_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMIN_REG_WR32(b,NV##d##r,(PRAMIN_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMIN_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMIN_REG_WR32(b,NV##d##r,(PRAMIN_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMIN_REG_RD_DRF(b,d,r,f)       (((PRAMIN_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
//
// NV Reference Manual INSTANCE MEMORY structure access definitions.
//
//******************************************************************************

#define INST_WR32(b,i,o,d)      PRAMIN_REG_WR32(b,DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o),(d))
#define INST_RD32(b,i,o)        PRAMIN_REG_RD32(b,DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o))
#define SF_OFFSET(sf)           (((0?sf)/32)<<2)
#define SF_SHIFT(sf)            ((0?sf)&31)
#define SF_MASK(sf)             (0xFFFFFFFF>>(31-(1?sf)+(0?sf)))
#define SF_DEF(s,f,c)           ((NV ## s ## f ## c)<<SF_SHIFT(NV ## s ## f))
#define SF_NUM(s,f,n)           (((n)&SF_MASK(NV ## s ## f))<<SF_SHIFT(NV ## s ## f))
#define SF_VAL(s,f,v)           (((v)>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))
#define RAM_WR_ISF_NUM(b,i,s,f,n) INST_WR32(b,i,SF_OFFSET(NV ## s ## f),SF_NUM(s,f,n))
#define RAM_WR_ISF_DEF(b,i,s,f,c) INST_WR32(b,i,SF_OFFSET(NV ## s ## f),SF_DEF(s,f,c))
#define FLD_WR_ISF_NUM(b,i,s,f,n) INST_WR32(b,i,SF_OFFSET(NV##s##f),(INST_RD32(b,i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_NUM(s,f,n))
#define FLD_WR_ISF_DEF(b,i,s,f,c) INST_WR32(b,i,SF_OFFSET(NV##s##f),(INST_RD32(b,i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_DEF(s,f,c))
#define RAM_RD_ISF(b,i,s,f)       (((INST_RD32(b,i,SF_OFFSET(NV ## s ## f)))>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))

//******************************************************************************
// Unlike Win95, we don't allocate one pointer to reference the entire
// address space mapped by the NV memory map (32Mb). NT doesn't like us
// taking all this memory.  So what we'll do instead is allocate separate
// chunks of memory for the various classes of registers.  The downside
// is that we can't use the REG_RD and REG_WR macros as is.  We'll need
// to use specific macros for each type of register class.
// The goal is that we want to use all those DEFINES that have already
// been done for us (Instead of having to Re-define the REGISTER BASES)
//
// Format is as follows:
//    b = Base address mapped for this type of register class
//    o = Register Offset address from the base of the NV device (address=0)
//        The correct address will be fixed up as follows:
//        OFFSET_FROM_REGISTER_BASE = OFFSET_FROM_0 - REGISTER_BASE_OFFSET
//
//        For example, OFFSET of NV_PFIFO_INTR_0 = 2100.
//        NEW OFFSET (from register base ) = 2100 - NV_PFIFO = 100
//
// ???? What about performance ?????
// ???? Redefine macros to improve performance ??????
// ???? Does compiler optimize well ?????
//******************************************************************************

//******************************************************************************
// Temporary register range
//******************************************************************************

#define TEMP_REG_WR32(b,d)   (b)->Reg032[0]=(U032)(d)
#define TEMP_REG_RD32(b)     (b)->Reg032[0]

//******************************************************************************
// Macros for NV_CONFIG registers
//******************************************************************************

#define CONFIG_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_CONFIG))/4]=(U032)(d)
#define CONFIG_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_CONFIG))/4]
#define CONFIG_REG_WR_DRF_NUM(b,d,r,f,n) CONFIG_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define CONFIG_REG_WR_DRF_DEF(b,d,r,f,c) CONFIG_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define CONFIG_FLD_WR_DRF_NUM(b,d,r,f,n) CONFIG_REG_WR32(b,NV##d##r,(CONFIG_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define CONFIG_FLD_WR_DRF_DEF(b,d,r,f,c) CONFIG_REG_WR32(b,NV##d##r,(CONFIG_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define CONFIG_REG_RD_DRF(b,d,r,f)       (((CONFIG_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_MEMORY registers
//******************************************************************************

#define MEMORY_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_MEMORY))/4]=(U032)(d)
#define MEMORY_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_MEMORY))/4]
#define MEMORY_REG_WR_DRF_NUM(b,d,r,f,n) MEMORY_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define MEMORY_REG_WR_DRF_DEF(b,d,r,f,c) MEMORY_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define MEMORY_FLD_WR_DRF_NUM(b,d,r,f,n) MEMORY_REG_WR32(b,NV##d##r,(MEMORY_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define MEMORY_FLD_WR_DRF_DEF(b,d,r,f,c) MEMORY_REG_WR32(b,NV##d##r,(MEMORY_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define MEMORY_REG_RD_DRF(b,d,r,f)       (((MEMORY_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_IO registers
//******************************************************************************

#define IO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_IO))/4]=(U032)(d)
#define IO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_IO))/4]
#define IO_REG_WR_DRF_NUM(b,d,r,f,n) IO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define IO_REG_WR_DRF_DEF(b,d,r,f,c) IO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define IO_FLD_WR_DRF_NUM(b,d,r,f,n) IO_REG_WR32(b,NV##d##r,(IO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define IO_FLD_WR_DRF_DEF(b,d,r,f,c) IO_REG_WR32(b,NV##d##r,(IO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define IO_REG_RD_DRF(b,d,r,f)       (((IO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PMC registers
//******************************************************************************

#define PMC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PMC))/4]=(U032)(d)
#define PMC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PMC))/4]
#define PMC_REG_WR_DRF_NUM(b,d,r,f,n) PMC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PMC_REG_WR_DRF_DEF(b,d,r,f,c) PMC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PMC_FLD_WR_DRF_NUM(b,d,r,f,n) PMC_REG_WR32(b,NV##d##r,(PMC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PMC_FLD_WR_DRF_DEF(b,d,r,f,c) PMC_REG_WR32(b,NV##d##r,(PMC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PMC_REG_RD_DRF(b,d,r,f)       (((PMC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PBUS registers
//******************************************************************************

#define PBUS_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PBUS))/4]=(U032)(d)
#define PBUS_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PBUS))/4]
#define PBUS_REG_WR_DRF_NUM(b,d,r,f,n) PBUS_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PBUS_REG_WR_DRF_DEF(b,d,r,f,c) PBUS_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PBUS_FLD_WR_DRF_NUM(b,d,r,f,n) PBUS_REG_WR32(b,NV##d##r,(PBUS_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PBUS_FLD_WR_DRF_DEF(b,d,r,f,c) PBUS_REG_WR32(b,NV##d##r,(PBUS_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PBUS_REG_RD_DRF(b,d,r,f)       (((PBUS_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PFIFO registers
//******************************************************************************

#define PFIFO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PFIFO))/4]=(U032)(d)
#define PFIFO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PFIFO))/4]
#define PFIFO_REG_WR_DRF_NUM(b,d,r,f,n) PFIFO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PFIFO_REG_WR_DRF_DEF(b,d,r,f,c) PFIFO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PFIFO_FLD_WR_DRF_NUM(b,d,r,f,n) PFIFO_REG_WR32(b,NV##d##r,(PFIFO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PFIFO_FLD_WR_DRF_DEF(b,d,r,f,c) PFIFO_REG_WR32(b,NV##d##r,(PFIFO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PFIFO_REG_RD_DRF(b,d,r,f)       (((PFIFO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PDMA registers
//******************************************************************************

#define PDMA_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PDMA))/4]=(U032)(d)
#define PDMA_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PDMA))/4]
#define PDMA_REG_WR_DRF_NUM(b,d,r,f,n) PDMA_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PDMA_REG_WR_DRF_DEF(b,d,r,f,c) PDMA_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PDMA_FLD_WR_DRF_NUM(b,d,r,f,n) PDMA_REG_WR32(b,NV##d##r,(PDMA_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PDMA_FLD_WR_DRF_DEF(b,d,r,f,c) PDMA_REG_WR32(b,NV##d##r,(PDMA_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PDMA_REG_RD_DRF(b,d,r,f)       (((PDMA_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PTIMER registers
//******************************************************************************

#define PTIMER_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PTIMER))/4]=(U032)(d)
#define PTIMER_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PTIMER))/4]
#define PTIMER_REG_WR_DRF_NUM(b,d,r,f,n) PTIMER_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PTIMER_REG_WR_DRF_DEF(b,d,r,f,c) PTIMER_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PTIMER_FLD_WR_DRF_NUM(b,d,r,f,n) PTIMER_REG_WR32(b,NV##d##r,(PTIMER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PTIMER_FLD_WR_DRF_DEF(b,d,r,f,c) PTIMER_REG_WR32(b,NV##d##r,(PTIMER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PTIMER_REG_RD_DRF(b,d,r,f)       (((PTIMER_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PAUDIO registers
//******************************************************************************

#define PAUDIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PAUDIO))/4]=(U032)(d)
#define PAUDIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PAUDIO))/4]
#define PAUDIO_REG_WR_DRF_NUM(b,d,r,f,n) PAUDIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PAUDIO_REG_WR_DRF_DEF(b,d,r,f,c) PAUDIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PAUDIO_FLD_WR_DRF_NUM(b,d,r,f,n) PAUDIO_REG_WR32(b,NV##d##r,(PAUDIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PAUDIO_FLD_WR_DRF_DEF(b,d,r,f,c) PAUDIO_REG_WR32(b,NV##d##r,(PAUDIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PAUDIO_REG_RD_DRF(b,d,r,f)       (((PAUDIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PGRAPH registers
//******************************************************************************

#define PGRAPH_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PGRAPH))/4]=(U032)(d)
#define PGRAPH_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PGRAPH))/4]
#define PGRAPH_REG_WR_DRF_NUM(b,d,r,f,n) PGRAPH_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PGRAPH_REG_WR_DRF_DEF(b,d,r,f,c) PGRAPH_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PGRAPH_FLD_WR_DRF_NUM(b,d,r,f,n) PGRAPH_REG_WR32(b,NV##d##r,(PGRAPH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PGRAPH_FLD_WR_DRF_DEF(b,d,r,f,c) PGRAPH_REG_WR32(b,NV##d##r,(PGRAPH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PGRAPH_REG_RD_DRF(b,d,r,f)       (((PGRAPH_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRMVIO registers (NV3)
//******************************************************************************

#define PRMVIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRMVIO))/4]=(U032)(d)
#define PRMVIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRMVIO))/4]
#define PRMVIO_REG_WR_DRF_NUM(b,d,r,f,n) PRMVIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRMVIO_REG_WR_DRF_DEF(b,d,r,f,c) PRMVIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRMVIO_FLD_WR_DRF_NUM(b,d,r,f,n) PRMVIO_REG_WR32(b,NV##d##r,(PRMVIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRMVIO_FLD_WR_DRF_DEF(b,d,r,f,c) PRMVIO_REG_WR32(b,NV##d##r,(PRMVIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRMVIO_REG_RD_DRF(b,d,r,f)       (((PRMVIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

#define PRMVIO_REG_WR08(b,a,d)   (b)->Reg008[(a)-DEVICE_BASE(NV_PRMVIO)]=(U008)(d)
#define PRMVIO_REG_RD08(b,a)     (b)->Reg008[(a)-DEVICE_BASE(NV_PRMVIO)]

#define NV_SR_UNLOCK_VALUE                               0x00000057
#define NV_SR_LOCK_VALUE                                 0x00000099

//******************************************************************************
// Macros for NV_PRMCIO registers (NV3)
//******************************************************************************

#define PRMCIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRMCIO))/4]=(U032)(d)
#define PRMCIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRMCIO))/4]
#define PRMCIO_REG_WR_DRF_NUM(b,d,r,f,n) PRMCIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRMCIO_REG_WR_DRF_DEF(b,d,r,f,c) PRMCIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRMCIO_FLD_WR_DRF_NUM(b,d,r,f,n) PRMCIO_REG_WR32(b,NV##d##r,(PRMCIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRMCIO_FLD_WR_DRF_DEF(b,d,r,f,c) PRMCIO_REG_WR32(b,NV##d##r,(PRMCIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRMCIO_REG_RD_DRF(b,d,r,f)       (((PRMCIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

#define PRMCIO_REG_WR08(b,o,d)   (b)->Reg008[(o)-DEVICE_BASE(NV_PRMCIO)]=(U008)(d)
#define PRMCIO_REG_RD08(b,o)     (b)->Reg008[(o)-DEVICE_BASE(NV_PRMCIO)]

//******************************************************************************
// Macros for NV_PRAMDAC registers (NV3)
//******************************************************************************

#define PRAMDAC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMDAC))/4]=(U032)(d)
#define PRAMDAC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMDAC))/4]
#define PRAMDAC_REG_WR_DRF_NUM(b,d,r,f,n) PRAMDAC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMDAC_REG_WR_DRF_DEF(b,d,r,f,c) PRAMDAC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMDAC_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMDAC_REG_WR32(b,NV##d##r,(PRAMDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMDAC_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMDAC_REG_WR32(b,NV##d##r,(PRAMDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMDAC_REG_RD_DRF(b,d,r,f)       (((PRAMDAC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_USERDAC registers (NV3)
//******************************************************************************

#define USERDAC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_USER_DAC))/4]=(U032)(d)
#define USERDAC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_USER_DAC))/4]
#define USERDAC_REG_WR_DRF_NUM(b,d,r,f,n) USERDAC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define USERDAC_REG_WR_DRF_DEF(b,d,r,f,c) USERDAC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define USERDAC_FLD_WR_DRF_NUM(b,d,r,f,n) USERDAC_REG_WR32(b,NV##d##r,(USERDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define USERDAC_FLD_WR_DRF_DEF(b,d,r,f,c) USERDAC_REG_WR32(b,NV##d##r,(USERDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define USERDAC_REG_RD_DRF(b,d,r,f)       (((USERDAC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//#ifdef PC98
#define USERDAC_REG_WR08(b,o,d)   (b)->Reg008[(o)-DEVICE_BASE(NV_USER_DAC)]=(U008)(d)
#define USERDAC_REG_RD08(b,o)     (b)->Reg008[(o)-DEVICE_BASE(NV_USER_DAC)]
//#endif // PC98

//******************************************************************************
// Macros for NV_PVIDEO registers (NV3)
//******************************************************************************

#define PVIDEO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PVIDEO))/4]=(U032)(d)
#define PVIDEO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PVIDEO))/4]
#define PVIDEO_REG_WR_DRF_NUM(b,d,r,f,n) PVIDEO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PVIDEO_REG_WR_DRF_DEF(b,d,r,f,c) PVIDEO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PVIDEO_FLD_WR_DRF_NUM(b,d,r,f,n) PVIDEO_REG_WR32(b,NV##d##r,(PVIDEO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PVIDEO_FLD_WR_DRF_DEF(b,d,r,f,c) PVIDEO_REG_WR32(b,NV##d##r,(PVIDEO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PVIDEO_REG_RD_DRF(b,d,r,f)       (((PVIDEO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))




//******************************************************************************
// CRTC Access Macros
//
// For now use the priviliged space, but we may have to switch to standard VGA i/o
//******************************************************************************

#define CRTC_WR(i,d)    {PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
                        PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_CR__COLOR, (d));}
#define CRTC_RD(i,d)    {PRMCIO_REG_WR08(PRMCIO_Base,NV_PRMCIO_CRX__COLOR, (i) & 0x3F);\
                        (d) = PRMCIO_REG_RD08(PRMCIO_Base,NV_PRMCIO_CR__COLOR);}

//******************************************************************************
// Macros for NV_UBETA registers
//******************************************************************************

#define UBETA_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBETA))/4]=(U032)(d)
#define UBETA_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBETA))/4]

//******************************************************************************
// Macros for NV_UROP registers
//******************************************************************************

#define UROP_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UROP))/4]=(U032)(d)
#define UROP_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UROP))/4]

//******************************************************************************
// Macros for NV_UCHROMA registers
//******************************************************************************

#define UCHROMA_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UCHROMA))/4]=(U032)(d)
#define UCHROMA_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UCHROMA))/4]

//******************************************************************************
// Macros for NV_UPLANE registers
//******************************************************************************

#define UPLANE_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UPLANE))/4]=(U032)(d)
#define UPLANE_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UPLANE))/4]

//******************************************************************************
// Macros for NV_UCLIP registers
//******************************************************************************

#define UCLIP_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UCLIP))/4]=(U032)(d)
#define UCLIP_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UCLIP))/4]

//******************************************************************************
// Macros for NV_UPATT registers
//******************************************************************************

#define UPATT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UPATT))/4]=(U032)(d)
#define UPATT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UPATT))/4]

//******************************************************************************
// Macros for NV_UPOINT registers
//******************************************************************************

#define UPOINT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UPOINT))/4]=(U032)(d)
#define UPOINT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UPOINT))/4]

//******************************************************************************
// Macros for NV_ULINE registers
//******************************************************************************

#define ULINE_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_ULINE))/4]=(U032)(d)
#define ULINE_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_ULINE))/4]

//******************************************************************************
// Macros for NV_ULIN registers
//******************************************************************************

#define ULIN_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_ULIN))/4]=(U032)(d)
#define ULIN_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_ULIN))/4]

//******************************************************************************
// Macros for NV_UTRI registers
//******************************************************************************

#define UTRI_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UTRI))/4]=(U032)(d)
#define UTRI_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UTRI))/4]

//******************************************************************************
// Macros for NV_URECT registers
//******************************************************************************

#define URECT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_URECT))/4]=(U032)(d)
#define URECT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_URECT))/4]

//******************************************************************************
// Macros for NV_UBTM registers
//******************************************************************************

#define UBTM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBTM))/4]=(U032)(d)
#define UBTM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBTM))/4]

//******************************************************************************
// Macros for NV_UQTM registers
//******************************************************************************

#define UQTM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UQTM))/4]=(U032)(d)
#define UQTM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UQTM))/4]

//******************************************************************************
// Macros for NV_UBLIT registers
//******************************************************************************

#define UBLIT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBLIT))/4]=(U032)(d)
#define UBLIT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBLIT))/4]

//******************************************************************************
// Macros for NV_UIMAGE registers
//******************************************************************************

#define UIMAGE_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UIMAGE))/4]=(U032)(d)
#define UIMAGE_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UIMAGE))/4]

//******************************************************************************
// Macros for NV_UBITMAP registers
//******************************************************************************

#define UBITMAP_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBITMAP))/4]=(U032)(d)
#define UBITMAP_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBITMAP))/4]

//******************************************************************************
// Macros for NV_UFROMEM registers
//******************************************************************************

#define UFROMEM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UFROMEM))/4]=(U032)(d)
#define UFROMEM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UFROMEM))/4]

//******************************************************************************
// Macros for NV_UTOMEM registers
//******************************************************************************

#define UTOMEM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UTOMEM))/4]=(U032)(d)
#define UTOMEM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UTOMEM))/4]

//******************************************************************************
// Macros for NV_UBTMB registers
//******************************************************************************

#define UBTMB_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UBTMB))/4]=(U032)(d)
#define UBTMB_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UBTMB))/4]

//******************************************************************************
// Macros for NV_UQTMB registers
//******************************************************************************

#define UQTMB_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_UQTMB))/4]=(U032)(d)
#define UQTMB_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_UQTMB))/4]

//******************************************************************************
// Macros for NV_PFB registers
//******************************************************************************

#define PFB_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PFB))/4]=(U032)(d)
#define PFB_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PFB))/4]
#define PFB_REG_WR_DRF_NUM(b,d,r,f,n) PFB_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PFB_REG_WR_DRF_DEF(b,d,r,f,c) PFB_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PFB_FLD_WR_DRF_NUM(b,d,r,f,n) PFB_REG_WR32(b,NV##d##r,(PFB_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PFB_FLD_WR_DRF_DEF(b,d,r,f,c) PFB_REG_WR32(b,NV##d##r,(PFB_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PFB_REG_RD_DRF(b,d,r,f)       (((PFB_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAM registers
//******************************************************************************

#define PRAM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAM))/4]=(U032)(d)
#define PRAM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAM))/4]
#define PRAM_REG_WR_DRF_NUM(b,d,r,f,n) PRAM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAM_REG_WR_DRF_DEF(b,d,r,f,c) PRAM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAM_FLD_WR_DRF_NUM(b,d,r,f,n) PRAM_REG_WR32(b,NV##d##r,(PRAM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAM_FLD_WR_DRF_DEF(b,d,r,f,c) PRAM_REG_WR32(b,NV##d##r,(PRAM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAM_REG_RD_DRF(b,d,r,f)       (((PRAM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAMFC registers
//******************************************************************************

#define PRAMFC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMFC))/4]=(U032)(d)
#define PRAMFC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMFC))/4]
#define PRAMFC_REG_WR_DRF_NUM(b,d,r,f,n) PRAMFC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMFC_REG_WR_DRF_DEF(b,d,r,f,c) PRAMFC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMFC_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMFC_REG_WR32(b,NV##d##r,(PRAMFC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMFC_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMFC_REG_WR32(b,NV##d##r,(PRAMFC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMFC_REG_RD_DRF(b,d,r,f)       (((PRAMFC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRAMHT registers
//******************************************************************************

#define PRAMHT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMHT))/4]=(U032)(d)
#define PRAMHT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRAMHT))/4]
#define PRAMHT_REG_WR_DRF_NUM(b,d,r,f,n) PRAMHT_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRAMHT_REG_WR_DRF_DEF(b,d,r,f,c) PRAMHT_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRAMHT_FLD_WR_DRF_NUM(b,d,r,f,n) PRAMHT_REG_WR32(b,NV##d##r,(PRAMHT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRAMHT_FLD_WR_DRF_DEF(b,d,r,f,c) PRAMHT_REG_WR32(b,NV##d##r,(PRAMHT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRAMHT_REG_RD_DRF(b,d,r,f)       (((PRAMHT_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PAUTH registers
//******************************************************************************

#define PAUTH_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PAUTH))/4]=(U032)(d)
#define PAUTH_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PAUTH))/4]
#define PAUTH_REG_WR_DRF_NUM(b,d,r,f,n) PAUTH_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PAUTH_REG_WR_DRF_DEF(b,d,r,f,c) PAUTH_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PAUTH_FLD_WR_DRF_NUM(b,d,r,f,n) PAUTH_REG_WR32(b,NV##d##r,(PAUTH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PAUTH_FLD_WR_DRF_DEF(b,d,r,f,c) PAUTH_REG_WR32(b,NV##d##r,(PAUTH_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PAUTH_REG_RD_DRF(b,d,r,f)       (((PAUTH_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_EXTDEV registers
//******************************************************************************

#define PEXTDEV_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PEXTDEV))/4]=(U032)(d)
#define PEXTDEV_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PEXTDEV))/4]
#define PEXTDEV_REG_WR_DRF_NUM(b,d,r,f,n) PEXTDEV_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PEXTDEV_REG_WR_DRF_DEF(b,d,r,f,c) PEXTDEV_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PEXTDEV_FLD_WR_DRF_NUM(b,d,r,f,n) PEXTDEV_REG_WR32(b,NV##d##r,(PEXTDEV_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PEXTDEV_FLD_WR_DRF_DEF(b,d,r,f,c) PEXTDEV_REG_WR32(b,NV##d##r,(PEXTDEV_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PEXTDEV_REG_RD_DRF(b,d,r,f)       (((PEXTDEV_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PDAC registers
//******************************************************************************

#define PDAC_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PDAC))/4]=(U032)(d)
#define PDAC_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PDAC))/4]
#define PDAC_REG_WR_DRF_NUM(b,d,r,f,n) PDAC_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PDAC_REG_WR_DRF_DEF(b,d,r,f,c) PDAC_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PDAC_FLD_WR_DRF_NUM(b,d,r,f,n) PDAC_REG_WR32(b,NV##d##r,(PDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PDAC_FLD_WR_DRF_DEF(b,d,r,f,c) PDAC_REG_WR32(b,NV##d##r,(PDAC_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PDAC_REG_RD_DRF(b,d,r,f)       (((PDAC_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PEEPROM registers
//******************************************************************************

#define PEEPROM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PEEPROM))/4]=(U032)(d)
#define PEEPROM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PEEPROM))/4]
#define PEEPROM_REG_WR_DRF_NUM(b,d,r,f,n) PEEPROM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PEEPROM_REG_WR_DRF_DEF(b,d,r,f,c) PEEPROM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PEEPROM_FLD_WR_DRF_NUM(b,d,r,f,n) PEEPROM_REG_WR32(b,NV##d##r,(PEEPROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PEEPROM_FLD_WR_DRF_DEF(b,d,r,f,c) PEEPROM_REG_WR32(b,NV##d##r,(PEEPROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PEEPROM_REG_RD_DRF(b,d,r,f)       (((PEEPROM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PROM registers
//******************************************************************************

#define PROM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PROM))/4]=(U032)(d)
#define PROM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PROM))/4]
#define PROM_REG_WR_DRF_NUM(b,d,r,f,n) PROM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PROM_REG_WR_DRF_DEF(b,d,r,f,c) PROM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PROM_FLD_WR_DRF_NUM(b,d,r,f,n) PROM_REG_WR32(b,NV##d##r,(PROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PROM_FLD_WR_DRF_DEF(b,d,r,f,c) PROM_REG_WR32(b,NV##d##r,(PROM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PROM_REG_RD_DRF(b,d,r,f)       (((PROM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PALT registers
//******************************************************************************

#define PALT_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PALT))/4]=(U032)(d)
#define PALT_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PALT))/4]
#define PALT_REG_WR_DRF_NUM(b,d,r,f,n) PALT_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PALT_REG_WR_DRF_DEF(b,d,r,f,c) PALT_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PALT_FLD_WR_DRF_NUM(b,d,r,f,n) PALT_REG_WR32(b,NV##d##r,(PALT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PALT_FLD_WR_DRF_DEF(b,d,r,f,c) PALT_REG_WR32(b,NV##d##r,(PALT_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PALT_REG_RD_DRF(b,d,r,f)       (((PALT_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRM registers
//******************************************************************************

#define PRM_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRM))/4]=(U032)(d)
#define PRM_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRM))/4]
#define PRM_REG_WR_DRF_NUM(b,d,r,f,n) PRM_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRM_REG_WR_DRF_DEF(b,d,r,f,c) PRM_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRM_FLD_WR_DRF_NUM(b,d,r,f,n) PRM_REG_WR32(b,NV##d##r,(PRM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRM_FLD_WR_DRF_DEF(b,d,r,f,c) PRM_REG_WR32(b,NV##d##r,(PRM_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRM_REG_RD_DRF(b,d,r,f)       (((PRM_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_PRMIO registers
//******************************************************************************

#define PRMIO_REG_WR32(b,o,d)   (b)->Reg032[((o)-DEVICE_BASE(NV_PRMIO))/4]=(U032)(d)
#define PRMIO_REG_RD32(b,o)     (b)->Reg032[((o)-DEVICE_BASE(NV_PRMIO))/4]
#define PRMIO_REG_WR_DRF_NUM(b,d,r,f,n) PRMIO_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define PRMIO_REG_WR_DRF_DEF(b,d,r,f,c) PRMIO_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define PRMIO_FLD_WR_DRF_NUM(b,d,r,f,n) PRMIO_REG_WR32(b,NV##d##r,(PRMIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define PRMIO_FLD_WR_DRF_DEF(b,d,r,f,c) PRMIO_REG_WR32(b,NV##d##r,(PRMIO_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define PRMIO_REG_RD_DRF(b,d,r,f)       (((PRMIO_REG_RD32(b,NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

//******************************************************************************
// Macros for NV_USER registers
//******************************************************************************

#define USER_REG_WR32(b,o,d)           (b)->Reg032[(o)/4]=(U032)(d)
#define USER_REG_WR_DRF_NUM(b,d,r,f,n) USER_REG_WR32(b,NV ## d ## r, DRF_NUM(d,r,f,n))
#define USER_REG_WR_DRF_DEF(b,d,r,f,c) USER_REG_WR32(b,NV ## d ## r, DRF_DEF(d,r,f,c))
#define USER_FLD_WR_DRF_NUM(b,d,r,f,n) USER_REG_WR32(b,NV##d##r,(USER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define USER_FLD_WR_DRF_DEF(b,d,r,f,c) USER_REG_WR32(b,NV##d##r,(USER_REG_RD32(b,NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))

//******************************************************************************
// Mode Entry Structure (Taken from Resource Manager code and modified)
//******************************************************************************

#define NUM_RESOLUTIONS 18
#define NUM_REFRESHES 7
#define NUM_DEPTHS 5
#define NUM_ELEMENTS 5

extern U016 fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS][NUM_REFRESHES][NUM_ELEMENTS];


//******************************************************************************
// Master NVInfo Structure
//
// CAREFUL:  There are now 2 HWINFO structures, the original one (this one)
//           and the one that also exists in the RM (in nvrm.h).  Modeset.c
//           includes nvrm.h but does NOT include NV.H, so for now, this is ok.
//           (This confuses Soft-Ice though when loading symbols).
// TODO:     These structures should be renamed or consolidated to minimize confusion!
//******************************************************************************

typedef struct _def_hw_info
{
    struct _def_chip_info
    {
        U032 Size;
        char ID[32];
        U032 SavePmc;
        U032 SaveIntrEn0;
        U032 IntrEn0;
        U032 Implementation;
        U032 Revision;
        U032 Architecture;
        U032 Manufacturer;
        U032 Bus;
        U032 ChipToken[2];
        U032 ServiceCount;
        U032 ServiceTimeLo;
        U032 ServiceTimeHi;
        U032 ExceptionTimeLo;
        U032 ExceptionTimeHi;
    } Chip;
    struct _def_mapping_info
    {
        U032 Size;
        char ID[32];
        U032 PhysAddr;
        U032 IntLine;
        U032 IntPin;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Mapping;
    struct _def_pram_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 HashDepth;
        U032 RunOutMask;
        U032 FreeInstSize;
        U032 FreeInstBase;
        U032 FreeInstMax;
        U032 CurrentSize;
        U032 AvailableSize[4];
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 HashTableAddr;
        U032 FifoRunoutAddr;
        U032 FifoContextAddr;
        U032 AudioScratchAddr;
        U032 AuthScratchAddr;
        U032 DMATextureInstances;
    } Pram;
    struct _def_fifo_info
    {
        U032 Size;
        char ID[32];
        U032 ServiceCount;
        U032 AllocateCount;
        U032 CacheDepth;
        U032 LieDepth;
        U032 RetryCount;
        U032 Count;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 DmaFetchAmount;       // Burst amount the DMA pusher should use
                                   // when reading into the FIFO
        U032 DmaWaterMark;         // Fifo level which will kick of the next
                                   // DMA burst
    } Fifo;
    struct _def_master_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Master;
    struct _def_framebuffer_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 ConfigPageHeight;
        U032 RamSizeMb;
        U032 RamSize;
        U032 RamType;
        U032 RamTech;
        U032 DpmLevel;
        U032 Depth;
        U032 Resolution;
        U032 RefreshRate;
        U032 HorizFrontPorch;
        U032 HorizSyncWidth;
        U032 HorizBackPorch;
        U032 HorizDisplayWidth;
        U032 VertFrontPorch;
        U032 VertSyncWidth;
        U032 VertBackPorch;
        U032 VertDisplayWidth;
        U032 HSyncPolarity;
        U032 VSyncPolarity;
        U032 CSync;
        U032 Count;
        U032 ServiceCount;
        U032 ActiveCount;
        U032 ActiveMask;
        U032 Start[3];
        U032 Limit[3];
        U032 Current;
        U032 FlipUsageCount;
        U032 FlipTo;
        U032 FlipFrom;
        U032 VBlankToggle;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 MonitorType;
        U032 FilterEnable;
        U032 SaveToEEPROMEnable;
        U032 Underscan_x;
        U032 Underscan_y;
        U032 Scale_x;
        U032 Scale_y;
        U032 Instance;
        U032 DmaInstance;
    } Framebuffer;
    struct _def_graphics_info
    {
        U032 Size;
        char ID[32];
        U032 Debug0;
        U032 Debug1;
        U032 Debug2;
        U032 Debug3;
        U032 CurrentChID;
        U032 Count;
        U032 CanvasCount;
        U032 Enabled;
        U032 ServiceCount;
        U032 ComplexClipCount;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Graphics;
    struct _def_video_info
    {
        U032 CurrentChID;
        U032 ColorKeyEnabled;
        U032 ScaleFactor;   // 12.20
        U032 Enabled;
        U032 VideoStart;
        U032 VideoSize;
        U032 VideoScale;
        U032 VideoColorKey;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Video;
    struct _def_mediaport_info
    {
        U032 CurrentChID;
        U032 Enabled;
    } MediaPort;
    struct _def_audio_info
    {
        U032 Size;
        char ID[32];
        U032 OutLogVolumeLeft;
        U032 OutLogVolumeRight;
        U032 NoteLogVolumeLeft;
        U032 NoteLogVolumeRight;
        U032 OutLinVolumeLeft;
        U032 OutLinVolumeRight;
        U032 NoteLinVolumeLeft;
        U032 NoteLinVolumeRight;
        U032 VolumeThreshold;
        U032 MaxNotes;
        U032 MaxIOs;
        U032 NoteCount;
        U032 InCount;
        U032 OutCount;
        U032 NearMark;
        U032 BlockLength;
        U032 RateConversion;
        U032 ServiceCount;
        U032 Enabled;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Audio;
    struct _def_dac_info
    {
        U032 Size;
        char ID[32];
        U032 InputWidth;
        U032 PClkVClkRatio;
        U032 VClk;
        U032 MClk;
        U032 VPllM;
        U032 VPllN;
        U032 VPllO;
        U032 VPllP;
        U032 MPllM;
        U032 MPllN;
        U032 MPllO;
        U032 MPllP;
        U032 DpmLevel;
        S032 CursorPosX;
        S032 CursorPosY;
        U032 CursorWidth;
        U032 CursorHeight;
        U008 CursorImagePlane[2][32 * sizeof(U032)];
        U032 CursorType;
        U032 CursorColor1;
        U032 CursorColor2;
        U032 CursorColor3;
        U008 CursorColorImage[32][32 * sizeof(U032)];
        S032 CursorSaveUnderPosX;
        S032 CursorSaveUnderPosY;
        U032 CursorSaveUnderWidth;
        U032 CursorSaveUnderHeight;
        U032 CursorSaveUnder[32][32];
        U032 CursorExclude;
        U032 CursorEmulation;
        U032 Palette[272];
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 CursorImageInstance;
        U032 TVCursorMin;
        U032 TVCursorMax;
    } Dac;
    struct _def_codec_info
    {
        U032 Size;
        char ID[32];
        U032 Chip;
        U032 DpmLevel;
        U032 Frequency;
        U032 OutputAttenuation;
        U032 InputSource;
        U032 InputLineLogGainLeft;
        U032 InputLineLogGainRight;
        U032 InputAuxLogGainLeft;
        U032 InputAuxLogGainRight;
        U032 InputMicLogGainLeft;
        U032 InputMicLogGainRight;
        U032 InputMixLogGainLeft;
        U032 InputMixLogGainRight;
        U032 PassThruAux1LogLeft;
        U032 PassThruAux1LogRight;
        U032 PassThruAux2LogLeft;
        U032 PassThruAux2LogRight;
        U032 InputLineLinGainLeft;
        U032 InputLineLinGainRight;
        U032 InputAuxLinGainLeft;
        U032 InputAuxLinGainRight;
        U032 InputMicLinGainLeft;
        U032 InputMicLinGainRight;
        U032 InputMixLinGainLeft;
        U032 InputMixLinGainRight;
        U032 PassThruAux1LinLeft;
        U032 PassThruAux1LinRight;
        U032 PassThruAux2LinLeft;
        U032 PassThruAux2LinRight;
        U032 Monitor;
        U032 ControlPins;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Codec;
    struct _def_dgp_chip_info
    {
        U032 Size;
        char ID[32];
        U032 Chip;
        U032 Enable3D;
        U032 Scale;
        U032 HorizDelay;
        U032 HorizOffset;
        U032 HorizScale;
        U032 VertOffset;
        U032 VertScale;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Dgp;
    struct _def_gameport_info
    {
        U032 Size;
        char ID[32];
        U032 DevicePort;
        V032 InputTypes;
        V032 DigitalInputs;
        S032 AnalogInputs[8];
        U032 XferRateDelay;
        U032 HorizRange;
        S032 HorizCenter;
        U032 VertRange;
        S032 VertCenter;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Gameport[13];
    struct _def_timer_info
    {
        U032 Size;
        char ID[32];
        U032 Denominator;
        U032 Numerator;
        U032 ServiceCount;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Timer;
    struct _def_vga_info
    {
        U032 Size;
        char ID[32];
        U032 Enabled;
        U032 GlobalEnable;
        U032 RomVersion;
        U032 RomFixupCode;
        U032 UpdateFlags;
        U032 FinishFlags;
    } Vga;
    struct _def_classes_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Classes;
    struct _def_stat_info
    {
        U032 Size;
        char ID[32];
        U032 AudioExceptionCount;
        U032 FifoExceptionCount;
        U032 FramebufferExceptionCount;
        U032 GraphicsExceptionCount;
        U032 TimerExceptionCount;
        U032 TotalExceptionCount;
        U032 IntTimeLo;
        U032 IntTimeHi;
        U032 ExecTimeLo;
        U032 ExecTimeHi;
        U032 MemAlloced;
        U032 MemLocked;
        U032 UpdateLo;
        U032 UpdateHi;
    } Statistics;
    struct _def_null_info
    {
        U032 Size;
        char ID[32];
    } Null;
} HWINFO, * PHWINFO;


typedef struct _VIDEO_COPROCESSOR_INFORMATION {
    ULONG ulChipID;         // ET3000, ET4000, W32, W32I, W32P, or ET6000
    ULONG ulRevLevel;       // REV_A, REV_B, REV_C, REV_D, REV_UNDEF
    ULONG ulVideoMemory;    // in bytes
} VIDEO_COPROCESSOR_INFORMATION, *PVIDEO_COPROCESSOR_INFORMATION;

typedef enum _CHIP_TYPE {
    NV3 = 1,
    NV4,
} CHIP_TYPE;

typedef enum _REV_TYPE {
    REV_UNDEF = 1,
    REV_A,
    REV_B,
    REV_C,
    REV_D,
} REV_TYPE;

//
//  NV1 PCI defines - These values should match those in NV1_REF.H
//
#define NV1_VENDOR_ID       0x10DE
#define ST1_VENDOR_ID       0x104A
#define NV1_DEVICE_VGA_ID   0x0008
#define NV1_DEVICE_NV1_ID   0x0009


//
//  NV3 PCI defines - These values should match those in NV3_REF.H
//
#define NV3_VENDOR_ID       0x12D2
#define ST3_VENDOR_ID       0x12D2
#define NV3_DEVICE_VGA_ID   0x0008
#define NV3_DEVICE_NV3_ID   0x0018
#define NV3_DEVICE_NV3_ID_2 0x0019


//
//  NV4 PCI defines - These values should match those in NV4_REF.H
//
#define NV4_VENDOR_ID                   0x10DE
#define ST4_VENDOR_ID                   0x10DE
#define NV4_DEVICE_VGA_ID               0x0008
#define NV4_DEVICE_NV4_ID               0x0020
#define NV5_DEVICE_NV5_ID               0x0028
#define NV5ULTRA_DEVICE_NV5ULTRA_ID     0x0029
#define NV5VANTA_DEVICE_NV5VANTA_ID     0x002C
#define NV5MODEL64_DEVICE_NV5MODEL64_ID 0x002D
#define NV0A_DEVICE_NV0A_ID             0x00A0
#define NV10_DEVICE_NV10_ID             0x0100
#define NV10DDR_DEVICE_NV10DDR_ID       0x0101
#define NV10GL_DEVICE_NV10GL_ID         0x0103
#define NV11_DEVICE_NV11_ID             0x0110
#define NV11DDR_DEVICE_NV11DDR_ID       0x0111
#define NV11M_DEVICE_NV11M_ID           0x0112
#define NV11GL_DEVICE_NV11GL_ID         0x0113
#define NV11_DEVICE_CRUSH11_ID          0x01A0
#define NV15_DEVICE_NV15_ID             0x0150
#define NV15DDR_DEVICE_NV15DDR_ID       0x0151
#define NV15BR_DEVICE_NV15BR_ID         0x0152
#define NV15GL_DEVICE_NV15GL_ID         0x0153
#define NV20_DEVICE_NV20_ID             0x0200
#define NV20_DEVICE_NV20_1_ID           0x0201
#define NV20_DEVICE_NV20_2_ID           0x0202
#define NV20_DEVICE_NV20_3_ID           0x0203


//////////////////////////////////////////////////////////////////////////////

//
// Do full save and restore.
//

#define EXTENDED_REGISTER_SAVE_RESTORE 1

//
// BIOS Variables
//

#define BIOS_INFO_1 0x488
#define PRODESIGNER_BIOS_INFO 0x4E8

//
// Define type of ET4000 boards
//

typedef enum _BOARD_TYPE {
    SPEEDSTARPLUS = 1,
    SPEEDSTAR24,
    SPEEDSTAR,
    PRODESIGNERIISEISA,
    PRODESIGNERIIS,
    PRODESIGNER2,
    TSENG3000,
    TSENG4000,
    TSENG4000W32,
    STEALTH32,
    TSENG6000,
    OTHER
} BOARD_TYPE;



//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

//******************************************************************************
// Indices corresponding to the NV Memory ranges
//******************************************************************************

#define NV_PHYSICAL_ADDRESS_QTY         3
#define NV_PHYSICAL_BASE_ADDRESS        0
#define NV_PHYSICAL_DFB_ADDRESS         1
#define NV_PHYSICAL_REMAPPER_ADDRESS    2

#define NV_PMC_INDEX          0
#define NV_PFB_INDEX          1
#define NV_PRM_INDEX          2
#define NV_PDAC_INDEX         3
#define NV_PRAM_INDEX         4
#define NV_PRAMFC_INDEX       5
#define NV_PRAMHT_INDEX       6
#define NV_PFIFO_INDEX        7
#define NV_PBUS_INDEX         8
#define NV_PGRAPH_INDEX       9
#define NV_URECT_INDEX        10
#define NV_UTRI_INDEX         11
#define NV_UBLIT_INDEX        12
#define NV_UIMAGE_INDEX       13
#define NV_UBITMAP_INDEX      14
#define NV_CONFIG_INDEX       15
#define NV_PDMA_INDEX         16
#define NV_PTIMER_INDEX       17
#define NV_PAUDIO_INDEX       18
#define NV_PAUTH_INDEX        19
#define NV_PEXTDEV_INDEX      20
#define NV_PEEPROM_INDEX      21
#define NV_PROM_INDEX         22
#define NV_PALT_INDEX         23

#define NV_USER_INDEX          24
#define NV_PGRAPH_STATUS_INDEX 25
#define NV_PDFB_INDEX          26

#define NV_PRAMIN_INDEX        27
#define NV_PRMVIO_INDEX        28
#define NV_PRMCIO_INDEX        29

#define NV_PFB_CONFIG_0_INDEX  30
#define NV_PFB_START_ADDRESS_INDEX  31

#define NV_PRAMDAC_INDEX       32
#define NV_USERDAC_INDEX       33

#define NV_SGS_DAC_INDEX       34
#define NV_PVIDEO_INDEX        35

#define NV_NUM_RANGES          36


#define BANKED_FRAME_BUFFER 3
#define LINEAR_FRAME_BUFFER 4

//
// W32 MMU stuff
//

#define PORT_IO_ADDR                0
#define PORT_IO_LEN                 0x10000

// When we are banked

#define BANKED_MMU_BUFFER_MEMORY_ADDR          0xB8000
#define BANKED_MMU_BUFFER_MEMORY_LEN           (0xBE000 - 0xB8000)
#define BANKED_MMU_MEMORY_MAPPED_REGS_ADDR     0xBFF00
#define BANKED_MMU_MEMORY_MAPPED_REGS_LEN      (0xC0000 - 0xBFF00)
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_ADDR   0xBE000
#define BANKED_MMU_EXTERNAL_MAPPED_REGS_LEN    (0xBF000 - 0xBE000)

#define BANKED_APERTURE_0_OFFSET   0x0000
#define BANKED_APERTURE_1_OFFSET   0x2000
#define BANKED_APERTURE_2_OFFSET   0x4000

// When we are linear

#define MMU_BUFFER_MEMORY_ADDR          0x200000
#define MMU_BUFFER_MEMORY_LEN           0x180000
#define MMU_MEMORY_MAPPED_REGS_ADDR     0x3FFF00
#define MMU_MEMORY_MAPPED_REGS_LEN      0x000100
#define MMU_EXTERNAL_MAPPED_REGS_ADDR   0x3FE000
#define MMU_EXTERNAL_MAPPED_REGS_LEN    0x001000

typedef struct {
    ULONG  ulOffset;
    ULONG  ulLength;
} RANGE_OFFSETS;

#define APERTURE_0_OFFSET   0x000000
#define APERTURE_1_OFFSET   0x080000
#define APERTURE_2_OFFSET   0x100000

#define MMU_APERTURE_2_ACL_BIT  0x04

typedef struct {
    ULONG   ulPhysicalAddress;
    ULONG   ulLength;
    ULONG   ulInIoSpace;
    PVOID   pvVirtualAddress;
} W32_ADDRESS_MAPPING_INFORMATION, *PW32_ADDRESS_MAPPING_INFORMATION;


//
// Port definitions for filling the ACCESS_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// W32 CRTCB port addresses (used for ID)
//

#define CRTCB_IO_PORT_BASE    0x0000217A
#define CRTCB_IO_PORT_LEN     0x00000002

#define CRTCB_IO_PORT_INDEX   CRTCB_IO_PORT_BASE
#define CRTCB_IO_PORT_DATA    (CRTCB_IO_PORT_INDEX+1)
#define IND_CRTCB_CHIP_ID     0xEC




//
// VGA register definitions
//
#define NUM_VGA_ACCESS_RANGES  3
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x03B4  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x03B5  // Data registers in mono mode
#define MODE_CONTROL_PORT_MONO      0x03B8  // Tseng Mode Control port, used
                                            //  here only for unlocking the
                                            //  key so we can get at extended
                                            //  registers
#define FEAT_CTRL_WRITE_PORT_MONO   0x03BA  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x03BA  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in mono mode
#define HERCULES_COMPATIBILITY_PORT 0x03BF  // used to unlock Tseng key to
                                            //  get at extended ports

#define ATT_ADDRESS_PORT            0x03C0  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x03C0  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x010
#define ATT_DATA_READ_PORT          0x03C1  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x03C2  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x03C2  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x03C3  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x03C4  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x03C5  // Data registers
#define DAC_PIXEL_MASK_PORT         0x03C6  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x03C7  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x03C7  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x03C8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x03C9  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x03CA  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x03CC  // Miscellaneous Output reg read
                                            // port
#define SEGMENT_SELECT_PORT         0x03CD  // Tseng banking control register
#define SEGMENT_SELECT_HIGH         0x03CB  // Tseng W32 SegSel extension
#define GRAPH_ADDRESS_PORT          0x03CE  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x03CF  // and Data registers

                                            // ports in color mode
#define CRTC_ADDRESS_PORT_COLOR     0x03D4  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x03D5  // Data registers in color mode
#define MODE_CONTROL_PORT_COLOR     0x03D8  // Tseng Mode Control port, used
                                            //  here only for unlocking the
                                            //  key so we can get at extended
                                            //  registers
#define FEAT_CTRL_WRITE_PORT_COLOR  0x03DA  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x03DA  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode
//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_STATE_CONTROL       0x06    // index of TS State Control reg in Seq
#define IND_TS_AUX_MODE         0x07    // index of TS Aux Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC
#define IND_RAS_CAS_CONFIG      0x32    // index of RAS/CAS Config reg in CRTC
#define IND_EXT_START_ADDR      0x33    // index of Extended Start Address reg
                                        //  in CRTC
#define IND_CRTC_COMPAT         0x34    // index of CRTC Compatibility reg
                                        //  in CRTC
#define IND_OFLOW_HIGH          0x35    // index of Overflow High reg in CRTC
#define IND_VID_SYS_CONFIG_1    0x36    // index of Video System Configuration
#define IND_VID_SYS_CONFIG_2    0x37    //  1 & 2 registers in CRTC
#define IND_ATC_MISC            0x16    // index of Miscellaneous reg in ATC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

#define UNLOCK_KEY_1            0x03    // value to output to Herc Compat
                                        //  register as first step in unlocking
                                        //  key so Tseng registers can be set
#define UNLOCK_KEY_2            0xA0    // value to output to Mode Control Port
                                        //  register as 2nd step in unlocking
                                        //  key so Tseng registers can be set
#define LOCK_KEY_1              0x00    // value to output to Herc Compat
                                        //  register as first step in locking
                                        //  key so Tseng registers can't be set
#define LOCK_KEY_2              0x00    // value to output to Mode Control Port
                                        //  register as 2nd step in locking
                                        //  key so Tseng registers can't be set
#define HERCULES_COMPATIBILITY_DEFAULT 0x00
                                        // value to output to Herc Compat
                                        //  register to put back to MDA
                                        //  compatibility

#define MODE_CONTROL_PORT_COLOR_DEFAULT 0x00
#define MODE_CONTROL_PORT_MONO_DEFAULT 0x00
                                        // values to output to CGA and MDA mode
                                        //  registers to put to default state
                                        //  (video disabled).

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F



//
// Indices for type of memory mapping; used in ModesVGA[], must match
// MemoryMap[].
//

typedef enum _VIDEO_MEMORY_MAP {
    MemMap_Mono,
    MemMap_CGA,
    MemMap_VGA
} VIDEO_MEMORY_MAP, *PVIDEO_MEMORY_MAP;

//
// Memory map table definition
//

typedef struct {
    ULONG   MaxSize;        // Maximum addressable size of memory
    ULONG   Start;          // Start address of display memory
} MEMORYMAPS;

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    MemMgrBanking,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;


//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
    USHORT  fbType;             // color or monochrome, text or graphics, via
                                //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
    USHORT  numPlanes;          // # of video memory planes
    USHORT  bitsPerPlane;       // # of bits of color in each plane
    SHORT   col;                // # of text columns across screen with default font

    SHORT   row;                // # of text rows down screen with default font
    USHORT  hres;               // # of pixels across screen
    USHORT  vres;               // # of scan lines down screen
    USHORT  wbytes;             // # of bytes from start of one scan line to start of next
    ULONG   sbytes;             // total size of addressable display memory in bytes
    ULONG   Frequency;          // Vertical Frequency
    ULONG   Interlaced;         // Determines if the mode is interlaced or not
    BANK_TYPE banktype;         // NoBanking, NormalBanking, PlanarHCBanking
    VIDEO_MEMORY_MAP MemMap;    // index from VIDEO_MEMORY_MAP of memory
                                //  mapping used by this mode
    BOOLEAN ValidMode;          // Determines which modes are valid.
    ULONG   Int10ModeNumber;    // Mode number via Int 10
    PUSHORT CmdStrings;         // pointer to array of register-setting commands
} VIDEOMODE, *PVIDEOMODE;


//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0



// 
// Added structs for control panel support
//

// For setting the current device type 
typedef struct  tagSETGETDEVTYPE
{
    unsigned long   dwSuccessFlag;
    unsigned long   dwDeviceType;
    unsigned long   dwTvFormat;
} SETGETDEVTYPE, *PSETGETDEVTYPE;

// For validating a particular mode on a particular device type 
typedef struct  tagVALMODEEXTR
{
    unsigned long   dwHRes;
    unsigned long   dwVRes;
    unsigned long   dwBpp;
    unsigned long   dwRefresh;
    unsigned long   dwDeviceType;
} VALMODEXTR;

// Size of the color lookup table cache in the device extension
#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))


//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//


//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

#ifdef EXTENDED_REGISTER_SAVE_RESTORE

//
// Indices to start save/restore in extension registers:
// For both chip types

#define ET4000_SEQUENCER_EXT_START     0x06
#define ET4000_SEQUENCER_EXT_END       0x07

#define ET4000_CRTC_EXT_START          0x31
#define ET4000_CRTC_EXT_END            0x37
#define ET4000_CRTC_1_EXT_START        0x3F
#define ET4000_CRTC_1_EXT_END          0x3F

#define ET4000_ATTRIB_EXT_START        0x16
#define ET4000_ATTRIB_EXT_END          0x16

//
// Number of extended regs for both chip types.
//

#define ET4000_NUM_SEQUENCER_EXT_PORTS (ET4000_SEQUENCER_EXT_END - ET4000_SEQUENCER_EXT_START + 1)
#define ET4000_NUM_CRTC_EXT_PORTS      (ET4000_CRTC_EXT_END - ET4000_CRTC_EXT_START + 1) + \
                                       (ET4000_CRTC_1_EXT_END - ET4000_CRTC_1_EXT_START + 1)
#define ET4000_NUM_ATTRIB_EXT_PORTS    (ET4000_ATTRIB_EXT_END - ET4000_ATTRIB_EXT_START + 1)

//
// set values for save/restore area based on largest value for a chipset.
//

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     ET4000_NUM_SEQUENCER_EXT_PORTS
#define EXT_NUM_CRTC_PORTS          ET4000_NUM_CRTC_EXT_PORTS
#define EXT_NUM_ATTRIB_CONT_PORTS   ET4000_NUM_ATTRIB_EXT_PORTS
#define EXT_NUM_DAC_ENTRIES         0

#else

#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          0
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

#endif


#define VGA_MAX_VALIDATOR_DATA       100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;

//
// Number of bytes to save in each plane.
//

#define VGA_PLANE_SIZE 0x10000

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET (VGA_BASIC_SEQUENCER_OFFSET + \
         VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET + \
         VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
         VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET (VGA_BASIC_ATTRIB_CONT_OFFSET + \
         VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET (VGA_BASIC_DAC_OFFSET + \
         (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET (VGA_EXT_SEQUENCER_OFFSET + \
         EXT_NUM_SEQUENCER_PORTS)
#define VGA_EXT_GRAPH_CONT_OFFSET (VGA_EXT_CRTC_OFFSET + \
         EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET (VGA_EXT_GRAPH_CONT_OFFSET +\
         EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET (VGA_EXT_ATTRIB_CONT_OFFSET + \
         EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET VGA_MISC_DATA_AREA_OFFSET + VGA_MISC_DATA_AREA_SIZE

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//

#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE

//
// Dualview related status
//
#define DUALVIEW_STATUS_GRAPHICS_MODE   0x00000001
#define DUALVIEW_STATUS_ENABLE_DUALVIEW 0x80000000
#define DUALVIEW_STATUS_SECONDARY       0x40000000
#define DUALVIEW_STATUS_VIEW_ON         0x20000000
#define DUALVIEW_STATUS_MOBILE          0x10000000

// If video memory size < 12M, disable Dualview for performance concern 
#define VIDEOMEMSIZELIMIT_FOR_DUALVIEW  0xC00000

#if 0
//////////////////////
// H.AZAR: (02/15/99)
//

#define NVP_MAX_VPORTS              1
#define NVP_MAX_SURFACES            5
#define NVP_MAX_TRANSFER_BUFFERS    10

//
// Surface definition (Video or VBI) and related data
//
typedef struct _NVP_SURFACE_INFO
{
    //HANDLE              hSurface;           // DirectDraw surface handle
    ULONG               dwCaps;             // capabilites of this DD surface
    ULONG               pVidMem;            // Flat pointer to the surface
    ULONG               dwOffset;           // Offset from the base of the frame buffer
    ULONG               dwPitch;
    ULONG               dwLength;
    ULONG               dwHeight;
    ULONG               dwWidth;            // Ignored for VBI
    ULONG               dwStartLine;        // Programs Y-crop for image, and startline for vbi
    ULONG               dwPreScaleSizeX;    // Ignored for VBI.. prescale size width
    ULONG               dwPreScaleSizeY;    // Ignored for VBI.. prescale size height
    ULONG               dwFieldType;        // what field was this surface setup to capture?
    //ULONG               bAutoFlip;          // do we turn around and auto program this surface?
    ULONG               bIsFirstFieldCaptured;
    LONG                nNextSurfaceIdx;     // the next surface idx in the chain
} NVP_SURFACE_INFO, *PNVP_SURFACE_INFO;

#define NVP_MAX_EXTRA422 10
// Overlay info
typedef struct _NVP_OVERLAY {
    ULONG   dwOverlayFormat;
    ULONG   dwOverlaySrcX;
    ULONG   dwOverlaySrcY;
    ULONG   dwOverlaySrcPitch;
    ULONG   dwOverlaySrcSize;
    ULONG   dwOverlaySrcWidth;
    ULONG   dwOverlaySrcHeight;
    ULONG   dwOverlayDstWidth;
    ULONG   dwOverlayDstHeight;
    ULONG   dwOverlayDstX;
    ULONG   dwOverlayDstY;
    ULONG   dwOverlayDeltaX;
    ULONG   dwOverlayDeltaY;
    ULONG   dwOverlayColorKey;
    ULONG   dwOverlayMode;
    ULONG   aExtra422OverlayOffset[NVP_MAX_EXTRA422];   // extra memory space used for prescaling
    ULONG   dwExtra422Index;            // index of current extra surface
    ULONG   dwExtra422NumSurfaces;      // number of extra allocated surfaces
    ULONG   dwExtra422Pitch;            // extra surface pitch
    ULONG   pNvPioFlipOverlayNotifierFlat;
    ULONG   dwOverlayMaxDownScale;
    ULONG   dwOverlayBufferIndex;
    ULONG   dwReserved1;
    ULONG   dwReserved2;
} NVP_OVERLAY, *PNVP_OVERLAY;

// Transfer
typedef struct _NVP_TRANSFER_BUFFER
{
    ULONG   dwTransferId;
    ULONG   dwTransferStatus;
    ULONG   pSurfaceData;
    //LONG  nSurfaceIdx;    // Idx of surface we're transfering from
    LONG    lStartLine;
    LONG    lEndLine;
    ULONG   dwTransferFlags;
    ULONG   pDestMDL;
    LONG    nNextTransferIdx;
    LONG    nPrevTransferIdx;
} NVP_TRANSFER_BUFFER, *PNVP_TRANSFER_BUFFER;

// transfer status
#define NVP_TRANSFER_QUEUED         0x01
#define NVP_TRANSFER_IN_PROGRESS    0x02
#define NVP_TRANSFER_DONE           0x03
#define NVP_TRANSFER_FAILURE        0x04
#define NVP_TRANSFER_FREE           0xFFFFFFFF

//
// NVidia Video Port context
//
typedef struct _NVP_CONTEXT
{
    NVP_SURFACE_INFO    aVideoSurfaceInfo[NVP_MAX_SURFACES];
    NVP_SURFACE_INFO    aVBISurfaceInfo[NVP_MAX_SURFACES];
    int                 nNumVidSurf;            // number of allocated video surfaces
    int                 nNumVBISurf;            // number of allocated vbi surfaces
    int                 nVidSurfIdx;            // current video surface index
    int                 nVBISurfIdx;            // current vbi surface index
    int                 nNextVideoSurfId;
    int                 nNextVBISurfId;

    int                 nLastFieldId;           // Id of last field captured
    ULONG               bLastFieldType;         // type of last field captured (TRUE if VBI, FALSE if VIDEO)

    ULONG               dwVPState;              // NVP_STATE_STOPPED, NVP_STATE_STARTED
    ULONG               dwVPFlags;
    ULONG               dwVPConFlags;           // connection flags

    ULONG               dwChipId;               // chip version Id
    ULONG               hClient;
    ULONG               dwDeviceId;             // NV_WIN_DEVICE
    ULONG               dwOverlayObjectID;      // overlay object Id (shared object!)
    ULONG               dwScalerObjectID;       // scaler object Id
    ULONG               dwDVDSubPicObjectID;    // used for prescaling on nv4 and nv5
    ULONG               dwDVDObjectCtxDma;      // context dma used for synchronization.
    int                 nFreeCount;     // fifo free count

    // BUGBUG: hacking declerations to avoid including hardware dependent header files
    //         in "nv.h"
    ULONG               pNVPChannel;            // NvChannel *pNVPChannel; // VPE pio channel
    UCHAR               avpNotifiers[16*9];     // (Media port notifiers) NvNotification avpNotifiers[NVP_CLASS04D_MAX_NOTIFIERS];
    UCHAR               aovNotifiers[16*3];     // (Overlay notifiers) NvNotification aovNotifiers[NVP_CLASS07A_MAX_NOTIFIERS];

    // overlay
    NVP_OVERLAY         nvpOverlay;             // information retrieved from UpdateOverlay32() in Ring3
    ULONG               pOverlayChannel;        // NvChannel *pOverlayChannel; // Overlay channel
    ULONG               dwOvrSubChannel;


    // vidmem to sysmem transfer (vbi and video capture !)
    NVP_TRANSFER_BUFFER aTransferBuffers[NVP_MAX_TRANSFER_BUFFERS];
    UCHAR               axfNotifiers[16*6]; //
    int                 nCurTransferIdx;    // current transfer buffer index
    int                 nLastTransferIdx;
    int                 nRecentTransferIdx; // index of most recently transfered buffer
    int                 nNumTransfer;       // current number of transfer buffer in queue
    ULONG               bxfContextCreated;  // TRUE if context already created
    ULONG               bxfContextFlushed;  // TRUE if context flushed
    ULONG               dwTransferCtxStart; // old transfer context start
    ULONG               dwTransferCtxSize;  // transfer size

    ULONG               hVPSyncEvent;       // media port Vsync event handle // PKEVENT hVSyncEvent;

    // DMA push buffer
    PVOID               pDmaChannel;
    ULONG               *nvDmaFifo;
    ULONG               nvDmaCount;
    ULONG               DmaPushBufTotalSize;    // 32 DWORDs
    UCHAR               DmaPushBufErrNotifier[16*1];

} NVP_CONTEXT, *PNVP_CONTEXT;

//////////////////////
#endif

//
// EDID cache structure
//
typedef struct _EDID_UNIT
{
    UCHAR EDIDBuffer[EDID_V2_SIZE];
    ULONG Valid;
    ULONG Size;
} EDID_UNIT, *PEDID_UNIT, *LPEDID_UNIT;

typedef struct _EDID_COLLECTION
{
    LPEDID_UNIT HeadMaps[NV_NO_CONNECTORS];
    EDID_UNIT   EdidUnits[0];
} EDID_COLLECTION, *PEDID_COLLECTION, *LPEDID_COLLECTION;

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344
#define QUERY_MONITOR_ID2           QUERY_MONITOR_ID+1
#define QUERY_NONDDC_MONITOR_ID2    QUERY_NONDDC_MONITOR_ID+1
#define QUERY_ACPI_CRT_ID           0x0100
#define QUERY_ACPI_DFP_ID           0x0110
#define QUERY_ACPI_TV_ID            0x0200

#define NVCAP_I2C_DEVICE_ID         0xCA000002
#define NVXBAR_I2C_DEVICE_ID        0xCA000003
#define NVTUNER_I2C_DEVICE_ID       0xCA000004
#define NVTVSND_I2C_DEVICE_ID       0xCA000005

#define DISPLAY_ADAPTER_HW_ID       0xFFFFFFFF

#define I2C_ACCESS_DYNAMIC_PORT     0
#define I2C_ACCESS_PRIMARY_PORT     1
#define I2C_ACCESS_SECONDARY_PORT   2

#define I2C_PORT_FREE               0
#define I2C_PORT_ACQUIRED           1

#define I2C_PORT_TIMEOUT            0xB2D05E00  // 5 minutes in NT system timer

//
// I2C port structure
//
typedef struct _I2C_PORT
{
    ULONG                   ulStatus;   /* Status of I2C port (Acquired/Free) */
    ULONG                   ulOwner;    /* Current owner of I2C port (PDO) */
    LARGE_INTEGER           lTimeStamp; /* Time stamp of last port access */
    NVRM_I2C_ACCESS_CONTROL rmI2CCtrl;  /* RM I2C control structure */
} I2C_PORT, *PI2C_PORT, *LPI2C_PORT;

//
// Child device structure
//
typedef struct _CHILD_DEVICE
{
    ULONG           ulPDO;          /* PDO of the child device */
    ULONG           ulHwID;         /* Hardware ID of the child device */
} CHILD_DEVICE, *PCHILD_DEVICE, *LPCHILD_DEVICE;

#if _WIN32_WINNT <= 0x0501

VIDEOPORT_API
ULONG
VideoPortGetAssociatedDeviceID(
    IN PVOID DeviceObject
    );

#endif

//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PUCHAR  IOAddress;            // base I/O address of VGA ports
    PUCHAR  VgaPortRange[NUM_VGA_ACCESS_RANGES];
                                  // Non-palette related VGA regs
    PVOID   VideoMemoryAddress;   // base virtual memory address of VGA memory
    ULONG   AdapterMemorySize;    // size, in bytes, of the memory on the
                                  // board.
    ULONG   ModeIndex;            // index of current mode in ModesVGA[]
    ULONG   NumRegistryModes;     // number of modes specified from registry/vesadata
    ULONG   NumAvailableModes;    // number of valid modes on this device for first head
    ULONG   NumAvailableModes1;    // number of valid modes on this device for second head.
    ULONG   NonPrimaryDevice;     // Denotes if system was booted on this device

//    PVIDEOMODE  CurrentMode;    // pointer to VIDEOMODE structure for
//                                // current mode.

    PMODE_ENTRY  CurrentMode;     // pointer to MODE_ENTRY structure for
                                  // current mode.

    ULONG   ulChipID;
    REV_TYPE    ulRevLevel;
    WCHAR LegacyPnPId[8];         // legacy PnP ID

    USHORT  FontPelColumns;       // Width of the font in pels
    USHORT  FontPelRows;          // height of the font in pels

    NV_CURSOR_INFO NvCursorInfo;  // Cursor position and other info

    UCHAR CursorEnable;           // whether cursor is enabled or not
    UCHAR CursorTopScanLine;      // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;   // Cursor End register setting (bottom scan)

    USHORT BoardID;               // Used to Identify Diamond boards
    UCHAR  DriverRegPath[128];    // The name of registry path ofthis device
    
    //**************************************************************************
    // OLD Style modeset code
    // ModeTiming table  (represents modes that are valid for this adapter)
    // This needs to be put here in the hw device extension for multi adapter
    // configurations. (still used by NV3)
    //**************************************************************************

    MODE_ENTRY fbTimingTable[NUM_RESOLUTIONS*NUM_DEPTHS*NUM_REFRESHES];

    //**************************************************************************
    // NEW Style modeset code
    // Allocate a table which will contain all valid modes
    //**************************************************************************
    USHORT ValidModeTable[MAX_VALID_MODE_TABLE_DATA_WORDS];

    //***************************************************************************
    // The OEM-specific and monitor-specific restriction mode lists.
    //***************************************************************************
    USHORT RestrictionModeTable0[MAX_VALID_MODE_TABLE_DATA_WORDS]; // For the first head
    USHORT RestrictionModeTable1[MAX_VALID_MODE_TABLE_DATA_WORDS]; // For the second head
    ULONG  NumRestrictionModes0; // Number of monitor restriction modes for head0
    ULONG  NumRestrictionModes1; // Number of monitor restriction modes for head1

    //**************************************************************************
    // Used to keep track of where to story parsed registry data
    //**************************************************************************

    ULONG RegistryDataOffset;

    //**************************************************************************
    // Structure containing registry switch data
    //**************************************************************************

    NT_NV_REGISTRY NV_Registry_Table;

    //**************************************************************************
    // Saved BIOS image (64k)
    //**************************************************************************

    UCHAR SavedBiosImageArray[SAVED_BIOS_IMAGE_SIZE];

    //**************************************************************************
    // Saved instance memory (128k)
    //**************************************************************************

    UCHAR SavedInstanceMemory[MAX_INSTANCE_MEM_SIZE];
    ULONG TotalInstanceMemory;

    //**************************************************************************
    // NV1 Specific registers
    //**************************************************************************

    PHYSICAL_ADDRESS NV1Registers;     // NV1 initialization registers
    ULONG  NV1RegistersLength;         // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PMC_Registers;    // NV1 Master Control Registers
    PHWREG NV1_Lin_PMC_Registers;      // Linear address to Master Control Registers
    ULONG  NV1_PMC_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PFB_Registers;    // NV1 Frame Buffer Control Registers
    PHWREG  NV1_Lin_PFB_Registers;     // Linear address to Frame Buffer Control Registers
    ULONG  NV1_PFB_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRM_Registers;    // NV1 Real Mode Control Registers
    PHWREG  NV1_Lin_PRM_Registers;     // Linear address to Real Mode Control Registers
    ULONG  NV1_PRM_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PDAC_Registers;   // NV1 DAC Registers
    PHWREG  NV1_Lin_PDAC_Registers;    // Linear address to DAC Registers
    ULONG  NV1_PDAC_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRAM_Registers;   // NV1 RAM Registers
    PHWREG  NV1_Lin_PRAM_Registers;    // Linear address to RAM Registers
    ULONG  NV1_PRAM_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRAMFC_Registers; // NV1 RAMFC Registers
    PHWREG  NV1_Lin_PRAMFC_Registers;  // Linear address to RAMFC Registers
    ULONG  NV1_PRAMFC_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRAMHT_Registers;   // NV1 RAMHT Registers
    PHWREG  NV1_Lin_PRAMHT_Registers;    // Linear address to RAMHT Registers
    ULONG  NV1_PRAMHT_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_USER_Registers;   // NV1 USER Registers
    PHWREG  NV1_Lin_USER_Registers;    // Linear address to USER Registers
    ULONG  NV1_USER_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PFIFO_Registers;  // NV1 FIFO Registers
    PHWREG  NV1_Lin_PFIFO_Registers;   // Linear address to FIFO Registers
    ULONG  NV1_PFIFO_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PBUS_Registers;   // NV1 PBUS Registers
    PHWREG  NV1_Lin_PBUS_Registers;    // Linear address to PBUS Registers
    ULONG  NV1_PBUS_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PGRAPH_Registers; // NV1 PGRAPH Registers
    PHWREG  NV1_Lin_PGRAPH_Registers;  // Linear address to PGRAPH Registers
    ULONG  NV1_PGRAPH_Length;          // NV1 register window



    PHYSICAL_ADDRESS NV1_Phys_CONFIG_Registers; // NV1 Config Registers
    PHWREG NV1_Lin_CONFIG_Registers;   // Linear address to Config Registers
    ULONG  NV1_CONFIG_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_MEM_Registers;    // NV1 Mermory Registers
    PHWREG NV1_Lin_MEM_Registers;      // Linear address to Memory Registers
    ULONG  NV1_MEM_Length;             // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_IO_Registers;     // NV1 IO Registers
    PHWREG NV1_Lin_IO_Registers;       // Linear address to IO Registers
    ULONG  NV1_IO_Length;              // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PDMA_Registers;   // NV1 DMA Registers
    PHWREG NV1_Lin_PDMA_Registers;     // Linear address to DMA Registers
    ULONG  NV1_PDMA_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PTIMER_Registers; // NV1 Timer Registers
    PHWREG NV1_Lin_PTIMER_Registers;   // Linear address to Timer Registers
    ULONG  NV1_PTIMER_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PAUDIO_Registers; // NV1 Audio Registers
    PHWREG NV1_Lin_PAUDIO_Registers;   // Linear address to Audio Registers
    ULONG  NV1_PAUDIO_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PAUTH_Registers;  // NV1 Authority Registers
    PHWREG NV1_Lin_PAUTH_Registers;    // Linear address to Authority Registers
    ULONG  NV1_PAUTH_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PEXTDEV_Registers; // NV1 Extdev Registers
    PHWREG NV1_Lin_PEXTDEV_Registers;   // Linear address to Extdev Registers
    ULONG  NV1_PEXTDEV_Length;          // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PEEPROM_Registers;// NV1 Eeprom Registers
    PHWREG NV1_Lin_PEEPROM_Registers;  // Linear address to Eeprom Registers
    ULONG  NV1_PEEPROM_Length;         // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PROM_Registers;   // NV1 ROM Registers
    PHWREG NV1_Lin_PROM_Registers;     // Linear address to ROM Registers
    ULONG  NV1_PROM_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PALT_Registers;   // NV1 Alt Registers
    PHWREG NV1_Lin_PALT_Registers;     // Linear address to Alt Registers
    ULONG  NV1_PALT_Length;            // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_PRMIO_Registers;  // NV1 Real Mode IO Registers
    PHWREG NV1_Lin_PRMIO_Registers;    // Linear address to Real Mode IO Registers
    ULONG  NV1_PRMIO_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_URECT_Registers;  // NV1 User Rectangle Registers
    PHWREG NV1_Lin_URECT_Registers;    // Linear address to User Rectangle Registers
    ULONG  NV1_URECT_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UTRI_Registers;  // NV1 User Triangle Registers
    PHWREG NV1_Lin_UTRI_Registers;    // Linear address to User Triangle Registers
    ULONG  NV1_UTRI_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UBLIT_Registers;  // NV1 User BLIT Registers
    PHWREG NV1_Lin_UBLIT_Registers;    // Linear address to User BLIT Registers
    ULONG  NV1_UBLIT_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UIMAGE_Registers;  // NV1 User IMAGE Registers
    PHWREG NV1_Lin_UIMAGE_Registers;    // Linear address to User IMAGE Registers
    ULONG  NV1_UIMAGE_Length;           // NV1 register window

    PHYSICAL_ADDRESS NV1_Phys_UBITMAP_Registers;  // NV1 User IMAGE MONO Registers
    PHWREG NV1_Lin_UBITMAP_Registers;   // Linear address to User IMAGE MONO Registers
    ULONG  NV1_UBITMAP_Length;          // NV1 register window

    //**************************************************************************
    // NV3 Specific registers
    //**************************************************************************

    PHYSICAL_ADDRESS NV3_Phys_PRAMIN_Registers;   // NV3 RAMIN Registers
    PHWREG  NV3_Lin_PRAMIN_Registers;   // Linear address to RAMIN Registers
    ULONG  NV3_PRAMIN_Length;           // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PRMVIO_Registers;   // NV3 PRMVIO Registers
    PHWREG  NV3_Lin_PRMVIO_Registers;    // Linear address to PRMVIO Registers
    ULONG  NV3_PRMVIO_Length;            // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PRMCIO_Registers;   // NV3 PRMCIO Registers
    PHWREG  NV3_Lin_PRMCIO_Registers;    // Linear address to PRMCIO Registers
    ULONG  NV3_PRMCIO_Length;            // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PRAMDAC_Registers;   // NV3 PRAMDAC Registers
    PHWREG  NV3_Lin_PRAMDAC_Registers;  // Linear address to PRAMDAC Registers
    ULONG  NV3_PRAMDAC_Length;          // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_USERDAC_Registers;   // NV3 USERDAC Registers
    PHWREG  NV3_Lin_USERDAC_Registers;  // Linear address to USERDAC Registers
    ULONG  NV3_USERDAC_Length;          // NV3 register window

    PHYSICAL_ADDRESS NV3_Phys_PVIDEO_Registers;   // NV3 USERDAC Registers
    PHWREG  NV3_Lin_PVIDEO_Registers;   // Linear address to USERDAC Registers
    ULONG  NV3_PVIDEO_Length;           // NV3 register window

    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    ULONG PhysicalVideoMemoryLength;          // length of display memory
    PHYSICAL_ADDRESS PhysicalFrameBase; // physical memory address and
    ULONG PhysicalFrameLength;          // length of display memory for the

    ULONG TextureDataLength;            //  Length of allocated texture data in Sys Mem

    ULONG DMABufferLength;              //  Length of allocated texture data in Sys Mem

    ULONG DMAPushLength;                // Size of DMA Push Buffer
    PVOID FrameBufferPtr;               // Get access to frame buffer

    //**************************************************************************
    // NV Software structures
    //**************************************************************************

    ULONG HashTable[HASH_DEPTH*256*2];   // Our local hash table
    ULONG ColorFormatTable[5];         // Color format conversion table
    GRAPHICSCHANNEL GrTable;           // Currently using 1 channel only
    FIFO FifoTable;                    // Currently using 1 channel only
    RENDEROBJECT RenderObject[15];     // Allocate up to 15 objects for now
    COMMONOBJECT CommonObject[10];     // Allocate up to 10 NON Render objects
    HWINFO NvInfo;                     // NVInfo structure information
    UCHAR CRTC[64];                    // Holds CRTC values
    UCHAR FreeInstanceUsage[NV_PRAM_MIN_SIZE_INSTANCE_MEM / 16];
                                       // Array denoting usage of FreeInstance mem
                                       // Each byte represents 1 paragraph of instance mem

    ULONG LastInstanceIndex;      //
    ULONG DisableVBlankFlag;      // Check for VBlank in OpenGL?
    PUSHORT BiosArea;             // address of the BIOS area
    USHORT OriginalBiosData;      // Orignal value in the Bios data area.

    BOOLEAN bLinearModeSupported; // Do we support linear modes?
    BOOLEAN bInLinearMode;        // Are we currently in a linear mode?
    ULONG ulSlot;                 // the slot that the card is in

    //**************************************************************************
    // Denotes if Flat panel is active or not
    //**************************************************************************

    BOOLEAN FlatPanelIsPresent;
    BOOLEAN TvIsPresent;
    BOOLEAN FlatPanelIsOff[NV_NO_DACS];

    //**************************************************************************
    // Max width and height of display (detected by RM)
    //**************************************************************************

    ULONG   MaxFlatPanelWidth;
    ULONG   MaxFlatPanelHeight;

    //**************************************************************************
    // Flag to denote if driver is being installed during unattended install
    //**************************************************************************

    BOOL    DeviceMappingFailed;
    
    //**************************************************************************
    // Save last DPMS state
    //**************************************************************************

    ULONG   CurrentDPMSState;
    
    //**************************************************************************
    // Used to save/restore power managment related registers for Win2k
    //**************************************************************************

    ULONG   Power_refresh;
    ULONG   Power_PfbBoot0;
    ULONG   Power_PfbConfig0;
    ULONG   Power_PfbConfig1;
    ULONG   Power_PfbMrs;
    ULONG   Power_PfbEmrs;
    ULONG   Power_PfbRef;
    ULONG   Power_PbusDebug1;
    ULONG   Power_PextdevBoot0;
    ULONG   Power_PfifoRamHT;
    ULONG   Power_PfifoRamRO;
    ULONG   Power_PfifoRamFC;    
    ULONG   Power_coeff_select;
    ULONG   Power_nvpll;
    ULONG   Power_vpll;
    ULONG   Power_mpll;

    ULONG   Master_Enable;
    ULONG   Fifo_Mode    ;
    ULONG   Numerator    ;
    ULONG   Denominator  ;
    ULONG   PCINV19      ;

    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;   // number of entries in the Trapped
                                   // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                   // Data trapped by the validator routines
                                   // but not yet played back into the VGA
                                   // register.

    ULONG SequencerAddressValue;   // Determines if the Sequencer Address Port
                                   // is currently selecting the SyncReset data
                                   // register.

    ULONG CurrentNumVdmAccessRanges;           // Number of access ranges in
                                               // the access range array pointed
                                               // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                               // associated to the VDM
    FLONG   flMapMemory;            // Flags passed to VideoPortMapMemory for mapping fb
    BOOLEAN bHwVidOvl;              // Is hw video overlay supported in the current mode?
    ULONG   bEnableIF09;             // Should we support IF09 format video data?
    ULONG   bUseDMT;                // Did a registry flag indicate we should use DMT
                                    // monitor timings?
    ULONG   ulTimingOverrideTwinViewInfo[NV_NO_DACS]; // DMT/GTF/Auto override specifed in the
                                    // TwinViewInfo registry structure. This makes the 
                                    // bUseDMT field obsolete. Delete the bUseDMT field later.

    // MP/RM integration...
    PHWREG      NvRegisterBase;
    PHWREG      FrameBufferBase;
    ULONG       DeviceReference;

    ULONG       curAdapterPowerState;      // Last known power state of the adapter
    ULONG       curMonitorPowerState;      // Last known power state of the monitor

    ULONG       ulRmTurnedOffMonitor;     // Last known value power state of monitor
                                    // This field is obsolete and will be deleted later.

#if _WIN32_WINNT < 0x0500
    ULONG       bExtRefreshDisable;     // DWORD is defined in INF file
#endif // #if _WIN32_WINNT < 0x0500
    ULONG       bMax16x12;
    ULONG       bDisable19x12x32at60;
    ULONG       bDisable19x10x32ge70;
    ULONG       bDisable16x12x32ge70;
    ULONG       ulDisableDfpModesGreaterThan;
    ULONG       bDellSwitch1;
    ULONG       OglStencilSwitch;
    ULONG       ulForceSwCursor;

    ULONG       Via694ChipsetFound;
    ULONG       AMD751ChipsetFound;
    USHORT      AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT;
    ULONG       AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG;
    PHWREG      AMD751_BAR1_Mapped_Address;
    ULONG       AliChipset_Problem_Found;
    PVOID       AliFixupIOBase;
    ULONG       LastWidth;
    ULONG       LastHeight;
    ULONG       LastDepth;
    ULONG       LastRefreshRate;

    ULONG       SavedPMCState;


    ULONG       BiosRevision;
    PUCHAR      pBios;
#if _WIN32_WINNT >= 0x0500
    BOOLEAN     bAgp;
    BOOLEAN     bDisableAgp;
    VIDEO_PORT_AGP_SERVICES AgpServices;
    PHYSICAL_ADDRESS AgpAddressRange;
    ULONG       AgpPagesTotal;
    PVOID       *AgpPhysContext;
    PVOID       dummyVirtualContext;
    PVOID       AgpHeapBase;
    PVOID       AgpVirtualBaseAddress;
    ULONGLONG   SystemMemorySize;
    struct _HW_DEVICE_EXTENSION *pDualViewAssociatedDE;
    ULONG       ulDualViewStatus;
#endif // #if _WIN32_WINNT >= 0x0500

    // per-device PCI addresses
    VIDEO_ACCESS_RANGE NVAccessRanges[NV_PHYSICAL_ADDRESS_QTY];


// Added to support gamma clut support
   VIDEO_CLUT       GammaCache;
   VIDEO_CLUTDATA   GammaCacheData[NV_NO_DACS*256];    // Make it 256 just to be safe...

// Added to support GTF or DMT method selection
    ULONG   bUseGTF; // Did a registry flag indicate we should use GTF?
    // On the fly valid device mode work area
    USHORT ValidDeviceModeTable[MAX_VALID_MODE_TABLE_DATA_WORDS];

    // VPE integration
    ULONG       BusInterruptLevel;
    ULONG       BusInterruptVector;
    PVOID       IRQCallback;
    PVOID       pIRQData;
    ULONG       dwIRQSources;

#ifdef NVPE
    /////////// 
    // H.AZAR: (02/15/99)
    NVP_CONTEXT avpContexts[NVP_MAX_VPORTS];
    ULONG       dwVPEEnabled;       // TRUE Enabled/default, FALSE disabled (registry key)
    ///////////
#endif // NVPE

    // Added for new I2C interface support (DDC-CI) [Not using child structures]
    I2C_PORT        I2C_Ports[2];           // I2C port structures
    ULONG           I2C_Reference_Count;    // I2C version 2 reference count
    ULONG           (*pfnVideoPortGetAssociatedDeviceID) (PVOID);
    CHILD_DEVICE    Child_Devices[8];       // Child device structures

    // TwinView related fields with info about the dacs.
    //**************************************************************************
    // Saved EDID Buffer
    //**************************************************************************
    LPEDID_COLLECTION EdidCollection;
    BOOLEAN bNeedRetrieveEDID;

    BOOLEAN bRmInitialized;
    // TRUE if we are on a ACPI system (such as laptops).
    ULONG   ACPISystem;

    // 1 if any high res modeset has occurred. 0 if any modeset has not yet occurred, i.e. we are in the 
    // early parts of the system bootup.
    ULONG SystemModeSetHasOccurred;

    //
    // The max pixelclock frequencies of each head as returned by ResMan.
    // Note: if CRT is connected for second head, only then should we
    // use the pixel clock for the second head. Otherwise, we use the pixel clock of
    // DAC 0 for both heads.
    //
    ULONG maxPixelClockFrequency_8bpp[NV_NO_DACS];
    ULONG maxPixelClockFrequency_16bpp[NV_NO_DACS];
    ULONG maxPixelClockFrequency_32bpp[NV_NO_DACS];

    //
    // We create a mapping array from Win2K's power state to NVidia's supported power states
    //
    ULONG NVMonitorPowerState[NV_NO_DACS][MAX_WIN2K_POWER_STATES];
    ULONG NVAdapterPowerState[MAX_WIN2K_POWER_STATES];

    //
    // 0: Desktop
    // 1,2: Laptops (DELL, Toshiba).
    // NOTE: The miniport should not refer to this registry key. This will be deleted eventually.
    //
    ULONG Mobile;

    ULONG   UseHWSelectedDevice;        // BIOS devices take precedence over windows devices.
    ULONG   UseHotKeySameMode;          // On hot key switches, keeps the same desktop mode (resolution,depth).
                                        // This needs PAN_SCAN_SELECTION_ENABLE_ALL to have been turned on.
                                        // This field is obsolete now since no OEM is using this feature curently.
    ULONG   PanScanSelection;           // absent or 0: pan-scan in only secondary monitor of clone mode: PAN_SCAN_SELECTION_CLONE_SECONDARY_ONLY
                                        // 1: Enable pan-scan in all modes: PAN_SCAN_SELECTION_ENABLE_ALL
                                        // 2: Disable pan-scan in all modes:PAN_SCAN_SELECTION_DISABLE_ALL 
    ULONG   EnableModesetStopImage;     // Sony specific feature to STOP_IMAGE during modesets and 
                                        // DPMS power on.
    ULONG   DFPAsDefaultMonitor;        // If the registry entry is1, does not export the EDID of the DFP to 
                                        // Win2K causing the DFP to show up as default monitor. 
                                        // This is done for Dell laptop.
    ULONG   EnumerateTVAsACPIDevice;    // On systems such as Dell laptop, miniport should enumerate TV as
                                        // an ACPI device since SBIOS is not enumerating TV.
    ULONG   GDIModePruning;             // Absent or 0: Driver always provides EDID mode pruning protection.
                                        // 1:   For desktop or laptop systems, for CRT, for the
                                        //      standard mode device and the primary device in clone mode and
                                        //      both devices in XP DualView mode, lets the GDI handle EDID 
                                        //      mode pruning via "Hide Modes" monitor checkbox.
                                        // 2:   For desktop systems only, for CRT or DFP, for the
                                        //      standard mode device and the primary device in clone mode and
                                        //      both devices in XP DualView mode, lets the GDI handle EDID 
                                        //      mode pruning via "Hide Modes" monitor checkbox.
                                        //
    ULONG   ulDFPSupports1400x1050;     // If the builtin DFP of the laptop supports 1400x1050 or not.
    ULONG   ulHotKeyPending;            // 1 if miniport has a hotkey pending to be done by the display driver.
                                        // Then the display will ignore the BOOT_HEADS.
    ULONG   ulUniquenessVGA;            // The unique integer ID for the ppdev
                                        // of the last IOCTL_RESET_DEVICE.
    ULONG   ulNVSVCStatus;               // Started, Stoped or Paused status of the NVSVC service.
    ULONG   ulInduceModeChangeDeviceMask; // The device mask/masks used by the NVSVC to induce mode change.


    VOID    *pFPStateSave;              // To do Floating point state save/restore for common modeset.mhd code.
                                        // Should be typecast as KFLOATING_SAVE
    VOID    *pFPMutex;                  // To disable interrupts during floating point opearations for common modeset.mhd code.
                                        // Should be typecast as FAST_MUTEX.
    
    NV_DESKTOP_INFO DeskTopInfo;         // Information about the virtual desktop
    ULONG ulMaxTVOutResolution;          // Max TV resolution for common mode set code.
    ULONG ulTVEncoderType;               // TV encoder info
    ULONG ulTVEncoderID;                 // TV encoder info
    NVTWINVIEWDATA SaveSettings[NUM_ENTRIES_SAVE_SETTINGS]; // Saved settings for each device combo.
    // End TwinView related fields

#if (_WIN32_WINNT >= 0x0500)
    // macrovision
    ULONG ulCurrentMacrovisionKey;
    ULONG ulNextMacrovisionKey;
    ULONG ulMacrovisionMode;
#endif

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;



//
// Function prototypes.
//

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

//
// Bank switch code start and end labels, define in HARDWARE.ASM
//

extern UCHAR BankSwitchStart;
extern UCHAR PlanarHCBankSwitchStart;
extern UCHAR EnablePlanarHCStart;
extern UCHAR DisablePlanarHCStart;
extern UCHAR BankSwitchEnd;

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];

extern MEMORYMAPS MemoryMaps[];

extern VIDEOMODE ModesVGA[];
extern ULONG NumVideoModes;

extern RANGE_OFFSETS RangeOffsets[NV_NUM_RANGES];

extern VIDEO_ACCESS_RANGE VgaAccessRange[];
extern VIDEO_ACCESS_RANGE VgaPaletteAccessRange;

#define VGA_NUM_EMULATOR_ACCESS_ENTRIES     6
extern EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[];

#define NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE 4
extern VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[];

#define NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE 2
extern VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[];



//
// These are macros used to call the VideoPort AGP functions. Their
// purpose is to make the code more readable. VideoPortGetAGPServices
// MUST be called prior to invoking these macros.
//
#define VideoPortAgpReservePhysical(_HwDeviceExt, _Pages, _Caching, _PhysContext) \
(_HwDeviceExt)->AgpServices.AgpReservePhysical((_HwDeviceExt), (_Pages), \
                (_Caching), (_PhysContext))

#define VideoPortAgpReleasePhysical(_HwDeviceExt, _PhysContext) \
(_HwDeviceExt)->AgpServices.AgpReleasePhysical((_HwDeviceExt), (_PhysContext))

#define VideoPortAgpCommitPhysical(_HwDeviceExt, _PhysContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpCommitPhysical((_HwDeviceExt), (_PhysContext), \
                _Pages, _Offset)

#define VideoPortAgpFreePhysical(_HwDeviceExt, _PhysContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpFreePhysical((_HwDeviceExt), \
                (_PhysContext), (_Pages), (_Offset))

#define VideoPortAgpReserveVirtual(_HwDeviceExt, _Pid, _PhysContext, _VirtContext) \
(_HwDeviceExt)->AgpServices.AgpReserveVirtual((_HwDeviceExt), (_Pid), \
                (_PhysContext), (_VirtContext))

#define VideoPortAgpReleaseVirtual(_HwDeviceExt, _VirtContext) \
(_HwDeviceExt)->AgpServices.AgpReleaseVirtual((_HwDeviceExt), (_VirtContext))

#define VideoPortAgpCommitVirtual(_HwDeviceExt, _VirtContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpCommitVirtual((_HwDeviceExt), (_VirtContext), \
                (_Pages), (_Offset))

#define VideoPortAgpFreeVirtual(_HwDeviceExt, _VirtContext, _Pages, _Offset) \
(_HwDeviceExt)->AgpServices.AgpFreeVirtual((_HwDeviceExt), (_VirtContext), \
                (_Pages), (_Offset))

//******************************************************************************
// Capabilities flags
//
// These are private flags passed to the NV display driver.  They
// come from the 'DriverSpecificAttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the display drivers 'driver.h'!
//******************************************************************************

typedef enum {
  CAPS_NV1_IS_PRESENT       = 0x00000010,   // NV1 Chip is present
  CAPS_NV3_IS_PRESENT       = 0x00000020,   // NV3 Chip is present
  CAPS_NV4_IS_PRESENT       = 0x00000040,   // NV4 Chip is present
  CAPS_NV5_IS_PRESENT       = 0x00000080,   // NV5 Chip is present
  CAPS_NV5VANTA_IS_PRESENT  = 0x00000100,   // NV5 VANTA Chip is present
  CAPS_NV5ULTRA_IS_PRESENT  = 0x00000200,   // NV5 ULTRA Chip is present
  CAPS_NV0A_IS_PRESENT      = 0x00000400,   // NV0A Chip is present
  CAPS_NV10_IS_PRESENT      = 0x00000800,   // NV10 Chip is present
  CAPS_NV5MODEL64_IS_PRESENT= 0x00001000,   // NV5 MODEL64 Chip is present
  CAPS_NV10DDR_IS_PRESENT   = 0x00002000,   // NV10 DDR Chip is present
  CAPS_NV10GL_IS_PRESENT    = 0x00004000,   // NV10 GL Chip is present
  CAPS_NV11_IS_PRESENT      = 0x00008000,   // NV11 Chip is present
  CAPS_NV11DDR_IS_PRESENT   = 0x00010000,   // NV11 DDR Chip is present
  CAPS_NV11GL_IS_PRESENT    = 0x00020000,   // NV11 GL Chip is present
  CAPS_NV15_IS_PRESENT      = 0x00040000,   // NV15 Chip is present
  CAPS_NV15DDR_IS_PRESENT   = 0x00080000,   // NV15 DDR Chip is present
  CAPS_NV15GL_IS_PRESENT    = 0x00100000,   // NV15 GL Chip is present
  CAPS_NV15BR_IS_PRESENT    = 0x00200000,   // NV15 BR Chip is present
  CAPS_NV20_IS_PRESENT      = 0x00400000,   // NV20 Chip is present
  CAPS_NV11M_IS_PRESENT     = 0x00800000,   // NV11M Chip is present
  CAPS_CRUSH11_IS_PRESENT   = 0x01000000,   // CRUSH11 Chip is present
  CAPS_SW_POINTER           = 0x40000000,   // No hardware pointer; use software simulation


} CAPS;

//**********************************************************************************
// Defines for VESA power management function.
//**********************************************************************************
#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001
#define VESA_STATUS_SUCCESS 0x004f

#if DBG
VOID DbgBreakPoint(VOID);
#define NvDbgBreak() DbgBreakPoint();
#else
#define NvDbgBreak()
#endif

//******************************************************************************
// External declarations.
//******************************************************************************
BOOLEAN NVGetNVInfo(PHW_DEVICE_EXTENSION);
VOID NVUpdateRegNVInfo(PHW_DEVICE_EXTENSION);
//BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PVIDEO_ACCESS_RANGE,PULONG);
BOOLEAN NVIsPresent(PHW_DEVICE_EXTENSION,PULONG);
ULONG NVMapMemoryRanges(PVOID);
ULONG NVMapFrameBuffer(PVOID HwDeviceExtension);
ULONG NVMapVgaPaletteRegisters(PHW_DEVICE_EXTENSION);
VOID NVGetMonitorType(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID NV_SetColorLookup(PHW_DEVICE_EXTENSION,PVIDEO_CLUT,ULONG);
VOID NVSetBiosInfo(PHW_DEVICE_EXTENSION);
VOID wtoa(USHORT, PUCHAR, UCHAR, UCHAR);

#if _WIN32_WINNT < 0x0500
ULONG wcslen(PWCHAR pString);
#endif // #if _WIN32_WINNT < 0x0500

#if _WIN32_WINNT >= 0x0500
VOID NV_SetPixMixBits(PHW_DEVICE_EXTENSION);
#endif

//
//
//
VP_STATUS DetectDevice(PHW_DEVICE_EXTENSION   pHDE,                             // our devices 'global' data struct
                        PCI_SLOT_NUMBER       psnSlot,                          // the slot to check
                        ULONG                 ulNumAccessRanges,                // is needed the to claim the resources, for now it's always 2
                        PVIDEO_ACCESS_RANGE   pAccessRanges,                    // if bClaimResources == TRUE this exports the device's mapping
                        USHORT                *pusVendorID,
                        USHORT                *pusDeviceID,
                        BOOLEAN               *pbIsPrimaryDevice,
                        BOOLEAN               bClaimResources);


VP_STATUS DetectNextDevice( IN      PHW_DEVICE_EXTENSION  pHDE, 
                            IN OUT  ULONG                 *pulPrevDevice,           // can be 0xffffffff : start looking at dev 0 and must be lower than 32 (5bit)
                            IN      ULONG                 ulNumAccessRanges,
                               OUT  PVIDEO_ACCESS_RANGE   pAccessRanges, 
                               OUT  USHORT                *pusVendorID,
                               OUT  USHORT                *pusDeviceID,
                               OUT  BOOLEAN               *pbIsPrimaryDevice,
                            IN      BOOLEAN                 bClaimResources);


//******************************************************************************
// Normally we would include #ntddk.h, but that would include a bunch
// of other structures that would cause redefinitions / errors.
//******************************************************************************

extern ULONG HalGetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

extern ULONG HalGetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern ULONG HalSetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType

    // end_wdm
    ,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    // begin_wdm

    } POOL_TYPE;


extern PVOID ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

extern PVOID ExAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

extern PVOID ExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

extern VOID ExFreePool(
    IN PVOID P
    );

#if _WIN32_WINNT >= 0x0500

#ifndef VIDEO_CHILD_DETACHED
#define VIDEO_CHILD_DETACHED    0x2
#endif //#ifndef VIDEO_CHILD_DETACHED

#ifndef IOCTL_VIDEO_SWITCH_DUALVIEW
#define IOCTL_VIDEO_SWITCH_DUALVIEW \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x123, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif //#ifndef IOCTL_VIDEO_SWITCH_DUALVIEW

#ifndef VIDEO_DUALVIEW_REMOVABLE
#define VIDEO_DUALVIEW_REMOVABLE    1
#endif //#ifndef VIDEO_DUALVIEW_REMOVABLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV.C
//
// Abstract:
//
//     This is the miniport driver for NV Adapters.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//     This driver was adapted from the ET4000 Miniport driver
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvapi.h"

#include "modedefs.h"

#include "nvMultiMon.h"

#ifdef PC98
#include "modes.h"
#endif // PC98

#include "rm.h"
#include "nvcm.h"

// To get the twinview definitions
#include "nvMultiMon.h"

// to get the multi device helper routines
#include "multidev.h"


#include <nvRmStereo.h>


// modeset DLL definitions                    
#include "modeext.h"

extern int FindModeEntry (LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew);

#if (_WIN32_WINNT >= 0x0500)

// Normally we would include #ntddk.h, but that would include a bunch
// of other structures that would cause redefinitions / errors.

typedef struct _IO_STATUS_BLOCK
    {
    union
        {
        ULONG Status;
        PVOID Pointer;
        };

    ULONG *Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

extern ULONG ZwCreateFile(
  PVOID FileHandle,
  ULONG DesiredAccess,
  PVOID ObjectAttributes,
  PVOID IoStatusBlock,
  PVOID AllocationSize,
  ULONG FileAttributes,
  ULONG ShareAccess,
  ULONG CreateDisposition,
  ULONG CreateOptions,
  PVOID EaBuffer,
  ULONG EaLength );

extern ULONG ZwWriteFile(
  PVOID  FileHandle,
  PVOID  Event,
  PVOID  ApcRoutine,
  PVOID  ApcContext,
  PVOID  IoStatusBlock,
  PVOID  Buffer,
  ULONG  Length,
  PVOID  ByteOffset,
  PVOID  Key );

extern ULONG ZwReadFile(
  PVOID  FileHandle,
  PVOID  Event,
  PVOID  ApcRoutine,
  PVOID  ApcContext,
  PVOID  IoStatusBlock,
  PVOID  Buffer,
  ULONG  Length,
  PVOID  ByteOffset,
  PVOID  Key );

extern ULONG ZwDeviceIoControlFile(
  PVOID  FileHandle,
  PVOID  Event,
  PVOID  ApcRoutine,
  PVOID  ApcContext,
  PVOID  IoStatusBlock,
  ULONG  IoControlCode,
  PVOID  InputBuffer,
  ULONG  InputBufferLength,
  PVOID  OutputBuffer,
  ULONG  OutputBufferLength
);

extern ULONG ZwClose( PVOID Handle );

extern BOOLEAN
PsGetVersion(
    PULONG MajorVersion OPTIONAL,
    PULONG MinorVersion OPTIONAL,
    PULONG BuildNumber OPTIONAL,
    PNV_UNICODE_STRING CSDVersion OPTIONAL
    );

#endif

extern InitializeCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension);
extern VOID ReadMonitorRestrictionModeList(PHW_DEVICE_EXTENSION HwDeviceExtension);
VOID ChoosePrimaryDevice(PHW_DEVICE_EXTENSION HwDeviceExtension, NVTWINVIEWDATA *pData);

VP_STATUS
NVGetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
NVReadMonitorTimingModeCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
VP_STATUS
NVReadRegistrySaveSettingsCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );
VP_STATUS
NVReadRegistryBinaryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

BOOLEAN  GetHeadPhysicalModeList(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    HEAD_MODE_LIST_INFO * pInput,
    ULONG * pRetSize);

ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);

ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask);

VOID InitializeACPIStates(
    PHW_DEVICE_EXTENSION hwDeviceExtension);

VOID vInitializeSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension);
VOID vWriteSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension);
VOID vReadSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension);
VOID vPrintSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension);

static VOID SetSafeDeviceMasks_SingleHeadBoard(PHW_DEVICE_EXTENSION hwDeviceExtension);
static VOID SetSafeDeviceMasks_DualHeadBoard(PHW_DEVICE_EXTENSION hwDeviceExtension);
ULONG MaskToDeviceType( ULONG ulDeviceMask);
ULONG MaskToFindModeEntryDeviceType( ULONG ulDeviceMask);
ULONG MaskToTVFormat( ULONG ulDeviceMask);
ULONG ACPIHwIdToMask( ULONG ACPIHwId);
VOID HandleBIOSHeads(PHW_DEVICE_EXTENSION hwDeviceExtension);
VOID HandleBestResolution(PHW_DEVICE_EXTENSION hwDeviceExtension);
BOOLEAN   TwinViewDataOK(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData);
VOID   InvalidateTwinViewData(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData);
VOID InitFromTwinViewInfo(PHW_DEVICE_EXTENSION HwDeviceExtension);

VOID Verify1400x1050DFP(PHW_DEVICE_EXTENSION hwDeviceExtension);
ULONG WriteFPModeToRegistry (PHW_DEVICE_EXTENSION hwDeviceExtension);
extern VOID EnterFPCode(VOID *pSave, VOID *pMutex);
extern VOID ExitFPCode(VOID *pSave, VOID *pMutex);


extern VOID SetTimingOverRide(PHW_DEVICE_EXTENSION HwDeviceExtension);
extern ULONG GetBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulEDIDIndex, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *pBestMode);
// 
//extern VOID SetBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulWidth, ULONG ulHeight, ULONG ulDepth, ULONG ulRefreshRate);
// 
//  Use CheckForcedResolution with the last parameter TRUE if you want to SetTheBestResolution
//
//extern   
//
// Function is now in nv.c since I could not get it to compile including nv.h in nvfloat.c

void CheckForcedResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, USHORT ulWidth, USHORT ulHeight, USHORT ulDepth, USHORT ulRefreshRate, BOOLEAN SetBestResolution );

extern VOID SignalModeSwitchEvent();
extern VOID SignalNVCplHotKeyEvent();
extern VOID InitNVSVCEvents();


//******************************************************************************
// The following declarations are needed to use the memory manager functions
//******************************************************************************
#define NV_PWR_MGMT
#define SYSMEM_FUDGE    (0x1000)

#define NTKERNELAPI DECLSPEC_IMPORT


extern VOID NVEnableBusMastering(PHW_DEVICE_EXTENSION);
extern VOID NVEnableVGASubsystem(PHW_DEVICE_EXTENSION);
extern VOID NVExtractBiosImage(PHW_DEVICE_EXTENSION);
extern VOID NVClearMutexPmeAudBuff0(PHW_DEVICE_EXTENSION);
extern U016 ModeTimingTable[NUMBER_OF_MODES*NUMBER_OF_RATES][10];
extern VOID NV_DisableNVInterrupts(PHW_DEVICE_EXTENSION);
extern VOID NV_ReEnableNVInterrupts(PHW_DEVICE_EXTENSION);
extern VOID SetGlobalHwDev(PHW_DEVICE_EXTENSION);
extern VOID BuildAvailableModesTable(PHW_DEVICE_EXTENSION);
extern VOID LoadRegistrySettings(PHW_DEVICE_EXTENSION);
extern VOID WakeUpCard(PHW_DEVICE_EXTENSION);
extern VOID NV_SetPixMixBits(PHW_DEVICE_EXTENSION);
extern VOID NVRestoreSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
extern VOID NVSaveSpecificRegistersForPwrMgmt(PHW_DEVICE_EXTENSION);
extern VOID NV_ManualTextModeSet(PHW_DEVICE_EXTENSION);
extern ULONG NVObReferenceObjectByHandle(HANDLE, HANDLE*);


extern void NVMapPhysIntoUserSpace(
        PHYSICAL_ADDRESS pa,
        LONG byteLength,
        PVOID *userVirtualAddress);

extern void NvUnmapPhysFromUserSpace(
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
        );

extern void NvMapIntoUserSpace(
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
        );

extern void NvUnmapFromUserSpace(
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
        );

extern void
NvLockdownMemory(
    NV_LOCK_DOWN_MEMORY *pLockdownMemory
    );

extern void
NvUnlockMemory(
    NV_UNLOCK_MEMORY *pUnlockMemory
    );

extern void
NvSystemMemoryShare(
    NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
    );

extern void
NvSystemMemoryUnShare(
    NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory
    );

NTKERNELAPI PHYSICAL_ADDRESS
MmGetPhysicalAddress (
    IN PVOID BaseAddress
    );

typedef enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
    MmNonCached = FALSE,
    MmCached = TRUE,
    MmWriteCombined = MmFrameBufferCached,
    MmHardwareCoherentCached,
    MmCachingTypeDoNotUse1,
    MmCachingTypeDoNotUse2,
    MmMaximumCacheType
} MEMORY_CACHING_TYPE;

NTKERNELAPI
PVOID
MmMapIoSpace (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN size_t NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

NTKERNELAPI
VOID
MmUnmapIoSpace (
    IN PVOID BaseAddress,
    IN size_t NumberOfBytes
    );


//******************************************************************************
//
// Function declarations
//
//******************************************************************************
BOOLEAN bScanHeadDeviceOptions(PHW_DEVICE_EXTENSION HwDeviceExtension);

SHORT GetNextWordFromRegistry(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR *SrcStrPtr
    );

SHORT my_wtoi(
    PUCHAR *SrcStrPtr
    );

VP_STATUS
NVFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
NVInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
NVInitialize_DacsAndEDID(
    PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bBootTime
    );

BOOLEAN
NVOneTimeInit_TwinView(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

BOOLEAN
NVInterrupt(
    PVOID HwDeviceExtension
    );

VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );


#if (_WIN32_WINNT >= 0x0500)
#ifdef NT_BUILD_NV4
extern BOOLEAN
NVResetHW(
    PVOID hwDeviceExtension,
    ULONG Column,
    ULONG Rows
    );
#endif
#endif

#if (_WIN32_WINNT >= 0x0500)

ULONG
NVGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );

VP_STATUS
NVGetChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VP_STATUS
NVValidateChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VP_STATUS
NVSetChildState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VP_STATUS
NVSwitchDualView(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG                dwViewEnable
    );

#ifdef NV_PWR_MGMT
VP_STATUS
NVGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );

VP_STATUS
NVSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    );
#endif // #ifdef NV_PWR_MGMT

#endif // if (_WIN32_WINNT >= 0x0500)

// Support to validate a mode on a particular display device for control panel
BOOL NVValidateDeviceMode(PHW_DEVICE_EXTENSION HwDeviceExtension, VALMODEXTR *vmx);

//******************************************************************************
// Global variable used to detect if the ALI 1541 chipset is found.
// It needs to be global since the hwDeviceExtension is not preserved.
//******************************************************************************

ULONG Ali_1541_Chipset_Found = FALSE;

//******************************************************************************
// Value of VIA GA Translation Table Base register (offset 88)
//******************************************************************************

ULONG   ViaAgpRegister;


//******************************************************************************
// Global variable used to detect if several adapters are present
//******************************************************************************

ULONG MultiAdaptersPresent = FALSE;

//******************************************************************************
// Global variable used to track the slots where devices are located on the bus
// initialized with -1 (so DetectNextDevice starts looking for slot 0
//******************************************************************************

ULONG ulFindSlot = 0xffffffff;  

//******************************************************************************
// Static area buffer used to read information from the registry
//******************************************************************************

U016 registry_data[MAX_STRING_REGISTRY_DATA_WORDS];

//
//  Global flag to ensure RmInitRm() to be called only once.
//

BOOLEAN g_bIsRmInitRmCalled = FALSE;

//******************************************************************************
//
// Private function prototypes.
//
//******************************************************************************

VP_STATUS
NVQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

BOOLEAN
NVIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    //PVIDEO_ACCESS_RANGE pAccessRange,
    PULONG NV1Slot
    );

VP_STATUS
NVSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VOID
NVValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
NVSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize
    );

VOID NV10CursorTimer(
    PVOID HwDeviceExtension
);

BOOL NVGetTimingForDac(PHW_DEVICE_EXTENSION hwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);

//////// H.AZAR
#ifdef NVPE
VP_STATUS NVQueryInterface( PVOID HwDeviceExtension, PQUERY_INTERFACE QueryInterface);
VP_STATUS NVPEProcessCommand(PVOID pHwDeviceExtension, PVIDEO_REQUEST_PACKET pRequestPacket);
VP_STATUS NVRegistryCallbackPnpId(PVOID HwDeviceExtension, PVOID Context, PWSTR ValueName, PVOID ValueData, ULONG ValueLength);
#endif

#ifdef PC98

// global device extension pointer and frame buffer pointer
// used for local POST and mode sets
extern PHW_DEVICE_EXTENSION HwDeviceExtension;
extern PHWREG fbAddr;
VOID NvPostEx(PHW_DEVICE_EXTENSION pHwDevExt)
{
    PHYSICAL_ADDRESS physFbAddr;
    ULONG length, inIoSpace;

    // init global device extension for local POST
    HwDeviceExtension = pHwDevExt;

    // map the frame buffer
    physFbAddr.HighPart = 0x00000000;
    physFbAddr.LowPart = NVAccessRange[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
    physFbAddr.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;
    length = 0x400000;
    inIoSpace = FALSE;
    fbAddr = 0;
    VideoPortMapMemory(
        pHwDevExt,
        physFbAddr,
        &length,
        &inIoSpace,
        &fbAddr
    );

    // perform the POST based on global fbAddr and addresses in the device extension
    NvPost();

    // unmap the frame buffer
    VideoPortUnmapMemory(
        pHwDevExt,
        fbAddr,
        0
    );
}

#endif // PC98

//******************************************************************************
// The functions listed below are pageable
//******************************************************************************

#if defined(ALLOC_PRAGMA)

#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,NVFindAdapter)
#pragma alloc_text(PAGE,NVInitialize)
#pragma alloc_text(PAGE,NVStartIO)
#pragma alloc_text(PAGE,NVIsPresent)
#pragma alloc_text(PAGE,NVSetColorLookup)

#if (_WIN32_WINNT >= 0x500)
#pragma alloc_text(PAGE, NVGetPowerState)
#pragma alloc_text(PAGE, NVSetPowerState)
#endif  // #if (_WIN32_WINNT >= 0x500)

#endif  // #if defined(ALLOC_PRAGMA)

//******************************************************************************
//
// Function: DriverEntry()
//
// Routine Description:
//
//     Installable driver initialization entry point.
//     This entry point is called directly by the I/O system.
//
// Arguments:
//
//     Context1 - First context value passed by the operating system. This is
//         the value with which the miniport driver calls VideoPortInitialize().
//
//     Context2 - Second context value passed by the operating system. This is
//         the value with which the miniport driver calls VideoPortInitialize().
//
// Return Value:
//
//     Status from VideoPortInitialize()
//
//******************************************************************************


ULONG DriverEntry(
    PVOID Context1,
    PVOID Context2
    )


    {

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus;



    //**************************************************************************
    // Zero out structure.
    //**************************************************************************

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //**************************************************************************
    // Specify sizes of structure and extension.
    //**************************************************************************

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //**************************************************************************
    // Set entry points.
    //**************************************************************************

    hwInitData.HwFindAdapter = NVFindAdapter;
    hwInitData.HwInitialize = NVInitialize;
    hwInitData.HwStartIO = NVStartIO;
    hwInitData.HwInterrupt = NVInterrupt;
    // This timer is only enabled on NV10 and alpha cursor blending.
//    hwInitData.HwTimer = NV10CursorTimer;

    //**************************************************************************
    // New NT 5.0 EntryPoint
    //**************************************************************************

#if (_WIN32_WINNT >= 0x0500)

    hwInitData.HwGetVideoChildDescriptor = NVGetChildDescriptor;

#ifdef NT_BUILD_NV4
    // To fix a hang on soft reboot issue for Toshiba and Dell.
    hwInitData.HwResetHw = NVResetHW;
#endif

#ifdef NV_PWR_MGMT
    hwInitData.HwGetPowerState = NVGetPowerState;
    hwInitData.HwSetPowerState = NVSetPowerState;
#endif // #ifdef NV_PWR_MGMT

#ifdef NVPE
    hwInitData.HwQueryInterface = NVQueryInterface;

#endif

#endif

    //**************************************************************************
    // Determine the size we require for the device extension.
    //**************************************************************************

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //**************************************************************************
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //**************************************************************************

//    hwInitData.StartingDeviceNumber = 0;

    //**************************************************************************
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and MCA.
    // We will return the minimum of all return values.
    //
    //
    // NOTE: For NV, we must be running on a PCI Bus
    //
    //**************************************************************************

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
       {
       return initializationStatus;
       }

    //**************************************************************************
    // We didn't find the card on any bus type, so lets
    // return the last error.
    //**************************************************************************

    return initializationStatus;

    } // end DriverEntry()


//**************************************************************************
// NT 5.0 specific entry points.
//**************************************************************************


#if (_WIN32_WINNT >= 0x0500)

#ifdef NV_PWR_MGMT

#ifndef _WIN64
VOID
NVAMD751ChipsetSaveHibernationRegisters(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PCI_COMMON_CONFIG AGPConfigInfo;
    PHYSICAL_ADDRESS physaddr;
    ULONG GetBusDataStatus;
    #define RM_PAGE_MASK 0x0FFF
    #define RM_PAGE_SIZE 4096

    GetBusDataStatus = HalGetBusData(
                PCIConfiguration,           // bus data type
                0,                          // bus number
                0,                          // slot number
                &AGPConfigInfo,
                sizeof(PCI_COMMON_CONFIG));

    // Sanity check. Check the vendor ID and device ID.
    if ((GetBusDataStatus <= 2) || (AGPConfigInfo.VendorID != 0x1022) ||  (AGPConfigInfo.DeviceID != 0x7006)) {
        VideoDebugPrint((0, "*** NVAMD751ChipsetSaveHibernationRegisters(). Something wrong. The chipset is not AMD 751 even though it should be.\n"));
        return;
    }

    // AMD 751 has its AGP related regs memory-mapped via BAR1 (setup this mapping).
    physaddr.HighPart = 0;
    physaddr.LowPart  = AGPConfigInfo.u.type0.BaseAddresses[1] & ~RM_PAGE_MASK;
    HwDeviceExtension->AMD751_BAR1_Mapped_Address = (PHWREG)MmMapIoSpace(physaddr, RM_PAGE_SIZE, FALSE);
    VideoDebugPrint((3, "hwDeviceExtension->AMD751_BAR1_Mapped_Address: 0x%p\n",HwDeviceExtension->AMD751_BAR1_Mapped_Address));
    if (HwDeviceExtension->AMD751_BAR1_Mapped_Address == (PHWREG)NULL) {
        VideoDebugPrint((0,"*** Failed to map AMD 751's AGP chipset registers\n"));
    } else {
        // Save the registers values. We restore them later while coming back up from hibernation.
        HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT =   HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg016[1];
        HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG  =   HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg032[1];
        VideoDebugPrint((3, "Saved AMD751 Status register: 0x%x\n",HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT));
        VideoDebugPrint((3, "Saved AMD751 GART Base register: 0x%x\n",HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG));
    }
}

VOID
NVAMD751ChipsetRestoreHibernationRegisters(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    // Sanity check. Ensure the chipset is AMD751.
    if (HwDeviceExtension->AMD751ChipsetFound != TRUE) {
        VideoDebugPrint((0, "*** NVAMD751ChipsetRestoreHibernationRegisters(). Something wrong. The chipset is not AMD 751 even though it should be.\n"));
        return;
    }
    //***********************************************************************
    // Two of the AMD 751 chipset's BAR1 registers are not set correctly when
    // the machines wakes up from hibernation. So we restore these
    // Enable and Status register and GART base register to the values at the
    // normal bootup time. 
    //***********************************************************************
    if ((VOID *)HwDeviceExtension->AMD751_BAR1_Mapped_Address != NULL) {
        HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg016[1] = HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT;
        HwDeviceExtension->AMD751_BAR1_Mapped_Address->Reg032[1] = HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG;
        VideoDebugPrint((3, "Restored AMD751 Status register: 0x%x\n",HwDeviceExtension->AMD751_AGP_Enable_And_Status_Register_Saved_Value_USHORT));
        VideoDebugPrint((3, "Restored AMD751 GART Base register: 0x%x\n",HwDeviceExtension->AMD751_AGP_GART_Base_Address_Register_Saved_Value_ULONG));
    }
}
#endif // #ifndef _WIN64

VP_STATUS
NVGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    This function is called to see if a given device can go into a given
    power state.

Arguments:

    HwDeviceExtension    - Pointer to our hardware device extension structure.


    HwDeviceId           - Private unique 32 bit ID identifing the device.
                           0xFFFFFFFF indicates the NV card itself.

    VideoPowerManagement - Pointer to the power management structure which
                           indicates the power state in question.

Return Value:

    NO_ERROR if the device can go into the requested power state,
    otherwise an appropriate error code is returned.

--*/
{
ULONG CurrentPowerState;

    //*************************************************************************
    // Unattended install with Intel 810 present:
    // Make sure to SKIP this call, if the device has NOT been mapped!!!
    // (Skip this function if currently running unattended install with
    // an Intel 810)
    //*************************************************************************

    if (HwDeviceExtension->DeviceMappingFailed == TRUE)
        return NO_ERROR;

    //
    // on ACPI systems, Win2K actually calls us for "device ID 0 - Other".
    // Not sure how we should handle this device id. 
    // we simply return  true for now.
    //
    if (HwDeviceId == 0)
    {
        return(NO_ERROR);
    }

    //
    // For getPowerState, we treat the ACPI(100,110,200) and non-ACPI(QUERY_NONDDC_MONITOR_ID, QUERY_MONITOR_ID) device Ids
    // the same way. (Since all monitors essentially have only on/off support in the resMan. If the resMan were to support
    // a finer granularity of power management for monitors, this code should change.)
    // For SetPowerState, we treat yhe ACPI and non-ACPI device IDs differently since ACPI device IDs are mask based
    // and non-ACPI devices are head based.
    //
    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID)  ||
        (HwDeviceId == QUERY_NONDDC_MONITOR_ID2) ||
        (HwDeviceId == QUERY_MONITOR_ID)         ||
        (HwDeviceId == QUERY_MONITOR_ID2)        ||
        (HwDeviceId == QUERY_ACPI_CRT_ID)        ||
        (HwDeviceId == QUERY_ACPI_DFP_ID)        ||
        (HwDeviceId == QUERY_ACPI_TV_ID))
    {
        //
        // We deal with only the head0 since the Win2K OS is aware of only head0.
        //
        ULONG ulPrimaryHead;
        BOOL bRet;
        ulPrimaryHead = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[0];
        switch (VideoPowerManagement->PowerState)
        {
        case VideoPowerOn:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerOn])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerOff:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerOff])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerHibernate:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerHibernate])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerSuspend:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerSuspend])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerStandBy:
            if (HwDeviceExtension->NVMonitorPowerState[ulPrimaryHead][NV_VideoPowerStandBy])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerShutdown:
            return(NO_ERROR);
            break;

        default:
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // The requested monitor power state is not supported by ResMan.
        //
        VideoDebugPrint((0,"Oops! NVGetPowerState for Monitor, QueriedState: 0x%x not supported\n",
                        VideoPowerManagement->PowerState));
        return(ERROR_INVALID_PARAMETER);

    } 
    else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) 

    {
        BOOL bRet;
        
        //
        // We are querying power support for the graphics card.
        //


        switch (VideoPowerManagement->PowerState)
        {
        
        case VideoPowerOn:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn])
            {
                return(NO_ERROR);
            }
            break;
            
        case VideoPowerHibernate:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerStandBy:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerSuspend:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend])
            {
                return(NO_ERROR);
            }
            break;
        case VideoPowerOff:
            if (HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff])
            {
                return(NO_ERROR);
            }
            break;

        case VideoPowerShutdown:
            return(NO_ERROR);
            break;

        default:
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            break;
        }
        // The requested monitor power state is not supported by ResMan.
        VideoDebugPrint((0,"Oops! NVGetPowerState for Adapter, QueriedState: 0x%x not supported\n",
                        VideoPowerManagement->PowerState));
        return(ERROR_INVALID_PARAMETER);

    } else {

        VideoDebugPrint((0, "Unknown HwDeviceId\n"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}



VP_STATUS
NVSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerManagement - Power state information.

Return Value:

    TRUE if power state can be set,
    FALSE otherwise.

--*/

{

    ULONG ulStopImage, ModesetStopImage;

    //
    // Print the request for debugging purposes.
    //
    VideoDebugPrint((1, "nvSetPowerState(): HwDeviceId: 0x%x, Power State: ", HwDeviceId));
    switch (VideoPowerManagement->PowerState)
    {
    
    case VideoPowerOn:
        VideoDebugPrint((1, "VideoPowerOn\n"));
        break;
    case VideoPowerHibernate:
        VideoDebugPrint((1, "VideoPowerHibernate\n"));
        break;

    case VideoPowerStandBy:         
        VideoDebugPrint((1, "VideoPowerStandBy\n"));
        break;
    case VideoPowerSuspend:
        VideoDebugPrint((1, "VideoPowerSuspend\n"));
        break;
    case VideoPowerOff:
        VideoDebugPrint((1, "VideoPowerOff\n"));
        break;
    case VideoPowerShutdown:
        VideoDebugPrint((1, "VideoPowerShutdown\n"));
        break;
    default:
        VideoDebugPrint((1, "Unknown power state: 0x%x\n", VideoPowerManagement->PowerState));
        break;
    }

    //
    // We should not turn on the monitor power state if we have defered a modeset via NVSVC.
    //
    //
    ulStopImage = 0;
    ModesetStopImage = 0;
    if (HwDeviceExtension->ulInduceModeChangeDeviceMask)
    {
        ulStopImage = 1;
    }

    //
    // We should also not turn on the monitor power state if Sony's ModesetStopImage feature is turned on.
    //
    if (HwDeviceExtension->EnableModesetStopImage)
    {
        //
        // Read the registry entry.
        //
        VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"ModesetStopImage",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(ModesetStopImage));
        if (ModesetStopImage == 1)
        {
            ulStopImage = 1;
        }
    }

    //*************************************************************************
    // Unattended install with Intel 810 present:
    // Make sure to SKIP this call, if the device has NOT been mapped!!!
    // (Skip this function if currently running unattended install with
    // an Intel 810)
    //*************************************************************************
    if (HwDeviceExtension->DeviceMappingFailed == TRUE)
        return NO_ERROR;

    //
    // Make sure we recognize the device.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID)  ||
        (HwDeviceId == QUERY_MONITOR_ID)         ||
        (HwDeviceId == QUERY_NONDDC_MONITOR_ID2) ||
        (HwDeviceId == QUERY_MONITOR_ID2))
    {

        ULONG i, ulHead, State;
        BOOL bRet;

        HwDeviceExtension->curMonitorPowerState = VideoPowerManagement->PowerState;

        for (i = 0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
        {
            ulHead = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];

            switch (VideoPowerManagement->PowerState)
            {
            
            case VideoPowerOn:
                //
                // If the image has been stopped, we should not turn the monitor on
                //
                if (ulStopImage)
                {
                    VideoDebugPrint((1, "Image has been stopped, so ignoring monitor poweron\n"));
                    return(NO_ERROR);
                }
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOn];
                break;
            case VideoPowerHibernate:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerHibernate];
                break;

            case VideoPowerStandBy:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerStandBy];
                break;
            case VideoPowerSuspend:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerSuspend];
                break;
            case VideoPowerOff:
                State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOff];
                break;
            case VideoPowerShutdown:
                return(NO_ERROR);
                break;

            default:
                VideoDebugPrint((0, "Unknown power state.\n"));
                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
            }

            bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, ulHead, State);
            if (bRet == FALSE)
            {
                VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for monitor %d, for State: 0x%x\n",
                                 ulHead, State));
            }

        }
        return(NO_ERROR);
    }

    //
    // The ACPI table has a "device ID 0 - for Other". Not sure what this device ID refers to.
    //
    if (HwDeviceId == 0)
    {
        VideoDebugPrint((0,"nvSetPowerState: HwID: 0x0, not sure what to do ,returning NO_ERROR\n"));
        return(NO_ERROR);
    }

    //
    // Handle the ACPI devices - CRT, TV, DFP on a laptop
    //
    if ((HwDeviceId == QUERY_ACPI_CRT_ID) ||
        (HwDeviceId == QUERY_ACPI_DFP_ID) ||
        (HwDeviceId == QUERY_ACPI_TV_ID))
    {

        ULONG i, ulHead, State, ulDeviceMask;
        BOOL bRet;

        HwDeviceExtension->curMonitorPowerState = VideoPowerManagement->PowerState;

        ulDeviceMask = ACPIHwIdToMask(HwDeviceId);
        if (ulDeviceMask == 0)
        {
            // Invalid device. simply return NO_ERROR.
            VideoDebugPrint((0,"Invalid deviceId, returning NO_ERROR\n"));
            return(NO_ERROR);
        }

        // Now we need to convert the device mask to a head. Since our ResMan power management interface is
        // specified in terms of head and not device mask. This leaves us with a hole. What if the device 
        // that we watnto set the power state is not currently one of the active heads? Hopefully win2K does not
        // call us in this fashion. Otherwise we will have to make more changes in resman's internal power management code
        // and its interface to the miniport.


        for (i = 0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
        {
            ulHead = HwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
            if (HwDeviceExtension->DeskTopInfo.ulDeviceMask[ulHead] == ulDeviceMask)
            {
                // We found the head for which this requested device is attached.
                switch (VideoPowerManagement->PowerState)
                {
                
                case VideoPowerOn:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOn];
                    //
                    // If the image has been stopped, we should not turn the monitor on
                    //
                    if (ulStopImage)
                    {
                        VideoDebugPrint((1, "Image has been stopped, so ignoring monitor poweron\n"));
                        return(NO_ERROR);
                    }
                    break;
                case VideoPowerHibernate:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerHibernate];
                    break;

                case VideoPowerStandBy:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerStandBy];
                    break;
                case VideoPowerSuspend:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerSuspend];
                    break;
                case VideoPowerOff:
                    State = HwDeviceExtension->NVMonitorPowerState[ulHead][NV_VideoPowerOff];
                    break;
                case VideoPowerShutdown:
                    return(NO_ERROR);
                    break;
                default:
                    VideoDebugPrint((0, "Unknown power state.\n"));
                    ASSERT(FALSE);
                    return ERROR_INVALID_PARAMETER;
                }

                bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, ulHead, State);
                if (bRet == FALSE)
                {
                    VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for monitor %d, for State: 0x%x\n",
                                     ulHead, State));
                }
                return(NO_ERROR);
            }
        }

        // Oops! We did not find any active head which was attached to this device!
        VideoDebugPrint((1,"Did not find the head for the requested deviceMask: 0x%x was attached\n", HwDeviceId));
        return(NO_ERROR);
    }

    if (HwDeviceId == DISPLAY_ADAPTER_HW_ID)
    {


        switch (VideoPowerManagement->PowerState)
        {
        case VideoPowerOn:
            {
                ULONG State;
                BOOL bRet;


                //
                // If the device was previously turned off, we need to reinitialize it.
                //


                if ( (HwDeviceExtension->curAdapterPowerState == VideoPowerHibernate)  ||
                     (HwDeviceExtension->curAdapterPowerState == VideoPowerStandBy)    ||
                     (HwDeviceExtension->curAdapterPowerState == VideoPowerSuspend)    ||
                     (HwDeviceExtension->curAdapterPowerState == VideoPowerOff))
                {
                    VIDEO_REQUEST_PACKET requestPacket;
                    STATUS_BLOCK statusblock;

                    // 
                    // The display driver needs to know whether we are resuming from hibernation/stdby/suspend so write the
                    // power down state to the registry.
                    //
                    VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"ResumingFromAdapterPowerDownState",
                                      &HwDeviceExtension->curAdapterPowerState,
                                      sizeof(ULONG));


                    if (HwDeviceExtension->CurrentMode==NULL)
                    {
                        //
                        //  If CurrentMode is not initialized, we know that our chip is
                        //  never initialized at all therefore, we must exit immediately.
                        //  And we should return no error. (configuration: ATI on motherboard
                        //  primary, NV3 as secondary, not posted)

                        //  NOTE:  Keep this fix here for now, until we can verify that
                        //  we can write to hardware registers in RmLoadState().
                        //  i.e....If this device was NOT posted, I'm not convinced that
                        //  we'll be able to touch the hardware registers (device is NOT on).
                        //  We should be able to delete this check once BIOS post code is added here.
                        //
                        return(NO_ERROR);
                    }


#ifndef IA64
                    //**********************************************************
                    // If the Via chipset is found, then we need to
                    // fixup one of the THEIR registers in order for AGP to work.
                    // Somewhat dangerous, but hibernation won't resume in
                    // AGP mode unless this register is programmed correctly.
                    //**********************************************************

                    if (HwDeviceExtension->Via694ChipsetFound == TRUE)
                    {

                        //******************************************************
                        // Save the value of this VIA AGP register
                        //******************************************************

                        /*
                        _asm {
                             mov    eax,0x80000088
                             mov    dx,0xcf8
                             out    dx,eax
    
                             mov    dx,0xcfc
                             mov    eax,ViaAgpRegister
                             out    dx,eax
                             }
                        */

                        HalSetBusDataByOffset(PCIConfiguration,
                                              0,    //  Bus 0
                                              0,    //  Slot 0
                                              &ViaAgpRegister,
                                              (0x88 >> 2),  //  Offset in byte
                                              sizeof(ULONG));   //  Size in byte
                    }

                    //**********************************************************
                    // If the AMD 751 chipset is found, then we need to 
                    // fixup two of THEIR registers in order for the AGP to work.
                    //**********************************************************
                    if (HwDeviceExtension->AMD751ChipsetFound == TRUE)
                    {
                        NVAMD751ChipsetRestoreHibernationRegisters(HwDeviceExtension);
                    }
#endif // IA64
                }

                // Call the resman to set to PowerOn state
                State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn];
                bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, 0, State);
                if (bRet == FALSE)
                {
                    VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for adapter for State: 0x%x\n",
                                     State));
                }

                if (HwDeviceExtension->SavedPMCState != 0)
                {
                    NV_ReEnableNVInterrupts(HwDeviceExtension);
                }

                HwDeviceExtension->curAdapterPowerState = VideoPowerManagement->PowerState;

                return(NO_ERROR);
            }


            break;


        case VideoPowerHibernate:

        case VideoPowerStandBy:

        case VideoPowerSuspend:


        case VideoPowerOff:


            {
                VIDEO_REQUEST_PACKET requestPacket;
                STATUS_BLOCK statusblock;
                ULONG State;
                BOOL bRet;
                ULONG PrevDevMask;
                VP_STATUS RegStatus;

                //
                // if the PrevDevMask registry key exists, set it to zero.
                // This is to ensure that we do the begin/end modeset bracket in
                // the display driver.
                //
                PrevDevMask = 0;
                RegStatus = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"PrevDevMask",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(PrevDevMask));
                if (RegStatus == NO_ERROR)
                {
                    PrevDevMask = 0;
                    RegStatus = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"PrevDevMask",
                                                &(PrevDevMask),
                                                sizeof(ULONG));
                }


                HwDeviceExtension->curAdapterPowerState = VideoPowerManagement->PowerState;

#ifndef IA64
                //**************************************************************
                // If the Via chipset is found, then we need to
                // fixup one of the THEIR registers in order for AGP to work.
                // Somewhat dangerous, but hibernation won't resume in
                // AGP mode unless this register is programmed correctly.
                //**************************************************************

                if (HwDeviceExtension->Via694ChipsetFound == TRUE)
                {

                    //**********************************************************
                    // Save the value of this VIA AGP register
                    //**********************************************************

                    /*
                    _asm {
                         mov    eax,0x80000088
                         mov    dx,0xcf8
                         out    dx,eax

                         mov    dx,0xcfc
                         in     eax,dx
                         mov    ViaAgpRegister,eax
                         }
                    */

                    HalGetBusDataByOffset(PCIConfiguration,
                                          0,    //  Bus 0
                                          0,    //  Slot 0
                                          &ViaAgpRegister,
                                          (0x88 >> 2),  //  Offset in bytes
                                          sizeof(ULONG));   //  Size in bytes
                }

                //**********************************************************
                // If the AMD 751 chipset is found, then we need to 
                // fixup two of THEIR registers in order for the AGP to work.
                //**********************************************************
                if (HwDeviceExtension->AMD751ChipsetFound == TRUE)
                {
                    NVAMD751ChipsetSaveHibernationRegisters(HwDeviceExtension);
                }
#endif // IA64


                switch (  VideoPowerManagement->PowerState)
                {
                
                case VideoPowerHibernate:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate];
                    break;
                case VideoPowerStandBy:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy];
                    break;
                case VideoPowerSuspend:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend];
                    break;
                case VideoPowerOff:
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff];
                    break;
                default:
                    VideoDebugPrint((0,"Oops! NvSetPowerState(): some invalid PowerState: 0x%x, line: %d\n",
                                     VideoPowerManagement->PowerState, __LINE__));
                    // use some safe off value.
                    State = HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff];
                    break;
                }

                // We are going out of high res mode. So indicate it.
                HwDeviceExtension->SystemModeSetHasOccurred = 0;
                VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"SystemModeSetHasOccurred",
                                      &HwDeviceExtension->SystemModeSetHasOccurred,
                                      sizeof(ULONG));

                NV_DisableNVInterrupts(HwDeviceExtension);

                // Call the ResMan to set the adapter power down to the required state
                // The 'head' arguement is irrelevant since we are setting the adapter power state.
                bRet = RmSetPowerState(HwDeviceExtension->DeviceReference, 0, State);
                if (bRet == FALSE)
                {
                    VideoDebugPrint((0,"Oops! RmSetPowerState returned FALSE for adapter for State: 0x%x\n",
                                 State));
                }

                return(NO_ERROR);
            }

            break;

        case VideoPowerShutdown:
            // Disable interrupts

            NV_DisableNVInterrupts(HwDeviceExtension);
            return(NO_ERROR);

        default:
            //
            // Unrecognized power state.
            //
            VideoDebugPrint((0,"Oops! NvSetPowerState(): some invalid PowerState: 0x%x, line: %d\n",
                                     VideoPowerManagement->PowerState, __LINE__));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
            break;
        }
        return(NO_ERROR);
    }

    VideoDebugPrint((0, "Unknown HwDeviceId: 0x%x\n", HwDeviceId));
    ASSERT(FALSE);
    return ERROR_INVALID_PARAMETER;

}

#endif // #ifdef NV_PWR_MGMT

#endif // #ifdef (_WIN32_WINNT >= 0x0500)


#if _WIN32_WINNT >= 0x0500
ULONG NVGetNumBootDevices(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG ulConnectedDeviceMask, ulNumberDacsOnBoard;

    ulConnectedDeviceMask = BITMASK_INVALID_DEVICE;
    if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_GET_ALL_DEVICES, &ulConnectedDeviceMask))
    {
        return 1;
    }

    if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                            NV_CFGEX_CHECK_CONNECTED_DEVICES, &ulConnectedDeviceMask, 
                            sizeof(ulConnectedDeviceMask)))
    {
        return 1;
    }
    if (ulConnectedDeviceMask == 0)
    {
        return 1;
    }
    if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_NUMBER_OF_HEADS, &ulNumberDacsOnBoard))
    {
        return 1;
    }

    if (ulNumberDacsOnBoard < 2)
    {
        return 1;
    }

    if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE)
    {
        if (ulConnectedDeviceMask & BITMASK_ALL_DFP)
            return 2;
        else
        {
            // A mobile without Panel????
            ASSERT(FALSE);
            return 1;
        }
    }
    else if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) > 1)
    {
        return 2;
    }
    return 1;
}
#endif

VP_STATUS NVGetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    )
{
    VP_STATUS status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                                      L"TwinviewInfo",
                                                      FALSE,
                                                      NVReadRegistryTwinViewInfoCallback,
                                                      pTwinviewInfo);

    if (status == NO_ERROR)
    {
        VideoDebugPrint((2, "NVGetRegistryTwinviewInfo : HwExtension=0x%08x\n", hwDeviceExtension));
        VideoDebugPrint((2, "State: 0x%x, Orientation: 0x%x, DeskTopRectl: (%d, %d), (%d, %d), AllDeviceMask: 0x%x, ConnectedDevMask: 0x%x, Head Mapping: %d, %d\n",
            pTwinviewInfo->dwState, pTwinviewInfo->dwOrientation, pTwinviewInfo->DeskTopRectl.left,pTwinviewInfo->DeskTopRectl.top,pTwinviewInfo->DeskTopRectl.right,
            pTwinviewInfo->DeskTopRectl.bottom, pTwinviewInfo->dwAllDeviceMask, pTwinviewInfo->dwConnectedDeviceMask, pTwinviewInfo->dwDeviceDisplay[0],pTwinviewInfo->dwDeviceDisplay[1]));
        VideoDebugPrint((2, "dwDeviceMask[2] = {%x,%x}   dwDeviceType[2] = {%x,%x}\n", 
                        pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask, pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask,
                        pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType, pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceType));
        VideoDebugPrint((2,"........................\n"));
    }
    else
    {
        VideoDebugPrint((1, "NVGetRegistryTwinviewInfo : HwExtension=0x%08x\n", hwDeviceExtension));
        VideoDebugPrint((1, "NVGetRegistryTwinviewInfo Failed\n"));
    }

    return status;
}

VP_STATUS NVSetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    )
{
    VideoDebugPrint((2,"NVSetRegistryTwinviewInfo : HwExtension=0x%08x\n", hwDeviceExtension));
    VideoDebugPrint((2,"State: 0x%x, Orientation: 0x%x, DeskTopRectl: (%d, %d), (%d, %d), AllDeviceMask: 0x%x, ConnectedDevMask: 0x%x, Head Mapping: %d, %d\n",
        pTwinviewInfo->dwState, pTwinviewInfo->dwOrientation, pTwinviewInfo->DeskTopRectl.left,pTwinviewInfo->DeskTopRectl.top,pTwinviewInfo->DeskTopRectl.right,
        pTwinviewInfo->DeskTopRectl.bottom, pTwinviewInfo->dwAllDeviceMask, pTwinviewInfo->dwConnectedDeviceMask, pTwinviewInfo->dwDeviceDisplay[0],pTwinviewInfo->dwDeviceDisplay[1]));
    VideoDebugPrint((2, "dwDeviceMask[2] = {%x,%x}   dwDeviceType[2] = {%x,%x}\n", 
                     pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask, pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask,
                     pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType, pTwinviewInfo->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceType));
    VideoDebugPrint((2,"........................\n"));

    return VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"TwinviewInfo",
                                   pTwinviewInfo,
                                   sizeof(NVTWINVIEWDATA));
}

VP_STATUS NVInitRm (
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
{
    if (hwDeviceExtension->bRmInitialized)
    {
        NV_ReEnableNVInterrupts(hwDeviceExtension);
        return NO_ERROR;
    }
    
    hwDeviceExtension->bRmInitialized = TRUE;
    
    if (hwDeviceExtension->DeviceMappingFailed == FALSE)
    {
        //**************************************************************************
        // Map the frame buffer here, so the Resource Manager can also get access to it,
        // instead of enablehardware in the display driver.
        //**************************************************************************

        if (NVMapFrameBuffer(hwDeviceExtension) != NO_ERROR)
        {
            return ERROR_INVALID_PARAMETER;
        }

        //**************************************************************************
        // For NV3, instead of passing the Frame buffer pointer back to the RM,
        // we will ONLY map instance memory beginning at address = framebuffer + 12Mb
        // This is because , for NV3, the RM accesses instance memory using the 'frame buffer'
        // ptr, and it must NOT be write combined.  Essentially, for NV3, we map
        // the frame buffer (write combined) and give this to the display driver.
        // But we also map 4Mb of instance memory (NON write combined) and
        // give it to the resource manager.
        //
        //  FrameBufferPtr = WRITE COMBINED mapping of frame buffer
        //  FrameBufferBase = NON write combined mapping of framebuffer+12Mb
        //                    used to access instance memory
        //
        // This is DIFFERENT from NV4 !!
        //**************************************************************************

        SetGlobalHwDev(hwDeviceExtension);

        //**************************************************************************
        // Make sure Non_primary monitor is alive, so that
        // dacConnectMonitorStatus in the RM will correctly detect the monitor!!
        // Only do this for NON primary devices.  Otherwise, the screen
        // will get garbled on the primary monitor.
        //**************************************************************************

        if (MultiAdaptersPresent == TRUE)
           if (hwDeviceExtension->NonPrimaryDevice == TRUE)
                WakeUpCard(hwDeviceExtension);

        // initialize the device
        if (!RmInitNvDevice(hwDeviceExtension->DeviceReference,
                            hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart,
                            hwDeviceExtension->FrameBufferBase))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    return NO_ERROR;
}

//******************************************************************************
//
// Function:    NVFindAdapter()
//
// Routine Description:
//
//     This routine is called to determine if the adapter for this driver
//     is present in the system.
//     If it is present, the function fills out some information describing
//     the adapter.
//
// Arguments:
//
//     HwDeviceExtension - Supplies the miniport driver's adapter storage. This
//         storage is initialized to zero before this call.
//
//     HwContext - Supplies the context value which was passed to
//         VideoPortInitialize().
//
//     ArgumentString - Supplies a NULL terminated ASCII string. This string
//         originates from the user.
//
//     ConfigInfo - Returns the configuration information structure which is
//         filled by the miniport driver. This structure is initialized with
//         any known configuration information (such as SystemIoBusNumber) by
//         the port driver. Where possible, drivers should have one set of
//         defaults which do not require any supplied configuration information.
//
//     Again - Indicates if the miniport driver wants the port driver to call
//         its VIDEO_HW_FIND_ADAPTER function again with a new device extension
//         and the same config info. This is used by the miniport drivers which
//         can search for several adapters on a bus.
//
// Return Value:
//
//     This routine must return:
//
//     NO_ERROR - Indicates a host adapter was found and the
//         configuration information was successfully determined.
//
//     ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
//         error obtaining the configuration information. If possible an error
//         should be logged.
//
//     ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
//         supplied configuration information.
//
//******************************************************************************

VP_STATUS NVFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG NV1Slot;
    ULONG OutData;
    ULONG Status;
    PVOID NonCachedSystemMemoryPtr;
    ULONG TestSize;
    ULONG SysMemTextureFlag2;
    ULONG SysMemTextureFlag4;
    ULONG SysMemTextureFlag6;
    ULONG DMADisableFlag;
    ULONG DMAEnableFlag;
    ULONG DisableVBlankFlag;
    VP_STATUS   status;
    int i;
    PCI_COMMON_CONFIG pciData;
    PCI_COMMON_CONFIG ALIPciData;
    PCI_COMMON_CONFIG IntelPciData;
    ULONG SlotSearchNum;
    ULONG BusSearchNum;
    ULONG GetBusDataStatus;
    ULONG AliFoundStatus = FALSE;
    ULONG Intel810FoundStatus = FALSE;
    USHORT usVendorID, usDeviceID;
    BOOLEAN bIsPrimaryDevice;


    //**************************************************************************
    // Initialize this local variable before using it.
    //**************************************************************************
    //numAccessRanges = 0;

    //**************************************************************************
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //**************************************************************************

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }
#if (_WIN32_WINNT >= 0x0500)
    //**************************************************************************
    // Try to get VideoPortGetAssociatedDeviceID routine address
    //**************************************************************************
    hwDeviceExtension->pfnVideoPortGetAssociatedDeviceID = 
        ConfigInfo->VideoPortGetProcAddress(hwDeviceExtension, "VideoPortGetAssociatedDeviceID");
#endif
    //  Make sure that we only called this once
    //  The reason why RmInitRm() is moved to FindAdapter is that
    //  W2k/Whistler will unload miniport right after DriverEntry
    //  during setup.  Since there is no way to clean up any buffer
    //  allocation which we allocate in RmInitRm(), we end up holding
    //  a chunk of memory.
    //  Also, RmInitRm allocates global clientInfo and dmaListElementPool.
    //  In W2k/Whistler, DriverEntry is called multiple time depending on
    //  the number of devices.  If RmInitRm() is called more than one time,
    //  the new allocation will overwritten the previous one without freeing
    //  them first.  This leads to memory leads.

    if(!g_bIsRmInitRmCalled)
    {
        if(!RmInitRm())
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        g_bIsRmInitRmCalled = TRUE;
    }

    //**************************************************************************
    // Look for ALI 15411 chipset
    // Need to implement a workaround for chipset cache issues
    //**************************************************************************

    SlotSearchNum = 0;
    GetBusDataStatus = FALSE;
    AliFoundStatus   = FALSE;
    hwDeviceExtension->Via694ChipsetFound = FALSE;
    hwDeviceExtension->AMD751ChipsetFound = FALSE;


#if (_WIN32_WINNT >= 0x0500)
#if !defined(_WIN64)

    // Try to find ALI1541 chipset under Win2k
    //
    GetBusDataStatus = HalGetBusData(
                PCIConfiguration,           // bus data type
                0,                          // bus number
                0,                          // slot number
                &ALIPciData,
                sizeof(PCI_COMMON_HDR_LENGTH));

    //**************************************************************************
    // If status is Non-zero, and greater than 2, check the vendor id, device id
    //**************************************************************************
   
    if (GetBusDataStatus > 2)
        {
        if ((ALIPciData.DeviceID == 0x1541) &&
            (ALIPciData.VendorID == 0x10B9))
            {
            AliFoundStatus = TRUE;
            }


        //**********************************************************************
        // Use the same structure, see if a VIA 694 chipset was found
        //**********************************************************************
        if ((ALIPciData.DeviceID == 0x691) &&
            (ALIPciData.VendorID == 0x1106))
            {
            hwDeviceExtension->Via694ChipsetFound = TRUE;
            }
    

        //**********************************************************************
        // Use the same structure, see if an AMD 751 chipset was found
        //**********************************************************************
        if ((ALIPciData.DeviceID == 0x7006) &&
            (ALIPciData.VendorID == 0x1022))
            {
                hwDeviceExtension->AMD751ChipsetFound = TRUE;
                // Note: Do not try to get the BAR1 address of the chipset.
                // It has not been set correctly at this point in time.
                // We will do that when we are going down in hibernation.
            }

        }
    //**************************************************************************
    // Try to find an Intel 810 chip
    //**************************************************************************

    GetBusDataStatus = HalGetBusData(
                PCIConfiguration,           // bus data type
                0,                          // bus number
                1,                          // slot number
                &IntelPciData,
                sizeof(PCI_COMMON_HDR_LENGTH));

    //**************************************************************************
    // If status is Non-zero, and greater than 2, check the vendor id, device id
    //**************************************************************************

    if (GetBusDataStatus > 2)
        {
        if ( ((IntelPciData.DeviceID == 0x7121) || (IntelPciData.DeviceID == 0x7123) || (IntelPciData.DeviceID == 0x7125)) &&
            (IntelPciData.VendorID == 0x8086))
            {
            Intel810FoundStatus = TRUE;
            }

        }
#endif // !defined(_WIN64)


    //*************************************************************************
    // Save the size of physical system memory in the device extension.
    //*************************************************************************
    hwDeviceExtension->SystemMemorySize = ConfigInfo->SystemMemorySize;

#else // (_WIN32_WINNT >= 0x0500)

    // Try to find ALI1541 chipset under NT4

    while ( (SlotSearchNum<8) && (AliFoundStatus == FALSE) )
        {

        GetBusDataStatus = VideoPortGetBusData(
                           hwDeviceExtension,
                           PCIConfiguration,
                           SlotSearchNum,
                           &ALIPciData,
                           0,
                           PCI_COMMON_HDR_LENGTH
                           );

        //**************************************************************************
        // If status is Non-zero, and greater than 2, check the vendor id, device id
        //**************************************************************************

        if (GetBusDataStatus > 2)
            {
            if ((ALIPciData.DeviceID == 0x1541) &&
                (ALIPciData.VendorID == 0x10B9))
                {
                AliFoundStatus = TRUE;
                }

            }


        SlotSearchNum++;

        }

#endif

    //**************************************************************************
    // Tell the display driver to implement an IO workaround for the ALI 1541 chipset
    // Since FindAdapter gets called for the PCI and AGP buses, and
    // the HwDeviceExtension is NOT preserved, we unfortunately have to resort
    // to using a global variable.
    //**************************************************************************

    if (AliFoundStatus)
        Ali_1541_Chipset_Found = TRUE;

    //**************************************************************************
    // Check and see if NV adapter is present.  If NV is present, the
    // the BASE PHYSICAL address of NV is stored in the NVAccessRange
    // member of the device extension.
    //**************************************************************************

    // search for nvidia boards 
    Status = DetectNextDevice(hwDeviceExtension, 
                              &ulFindSlot,                            // global variable !!!
                              2,
                              hwDeviceExtension->NVAccessRanges, 
                              &usVendorID,
                              &usDeviceID,
                              &bIsPrimaryDevice, 
                              TRUE);                                   // claim resources
    if (NO_ERROR != Status)
    {
        return(ERROR_DEV_NOT_EXIST);
    }

    //
    //  update some board related data in the device extension
    //
    hwDeviceExtension->ulSlot       = ulFindSlot;
    hwDeviceExtension->ulChipID     = (ULONG)(usDeviceID) & 0xffff;
    hwDeviceExtension->ulRevLevel   = REV_UNDEF;
    hwDeviceExtension->BoardID      = usVendorID;

    //
    // call our old NVIsPresent routine, this now only updates some RangeOffsets...
    //
    if (!NVIsPresent(hwDeviceExtension, &ulFindSlot))
        return(ERROR_DEV_NOT_EXIST);

    NV1Slot = ulFindSlot;


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // Code change request for Win2k per Microsoft
    // Fail if there is a resource conflict
    //**************************************************************************

    if ( (ConfigInfo->BusInterruptLevel == 0 ) && (ConfigInfo->BusInterruptVector == 0))
        return(ERROR_DEV_NOT_EXIST);

#endif

    //**************************************************************************
    // Initialize the Ali_1541 flag in the hwDeviceExtension according
    // to the global flag (Since VideoPortGetBusData doesn't work
    // across buses)
    //**************************************************************************

    if (Ali_1541_Chipset_Found == TRUE)
        hwDeviceExtension->AliChipset_Problem_Found = TRUE;


    //**************************************************************************
    // Assume that the device mapping will always succeed
    //**************************************************************************

    hwDeviceExtension->DeviceMappingFailed = FALSE;

    //**************************************************************************
    // Now map the NV registers so we can get to them
    //**************************************************************************
    Status = NVMapMemoryRanges(hwDeviceExtension);
    if (Status != NO_ERROR)
        {
        //**********************************************************************
        // Our device mapping requires 16Mb.  This call has ALWAYS succeeded, even on 32Mb
        // systems.  However, during Win2k unattended install with an Intel 810 present,
        // this call may fail. In order to workaround this, We set a flag acknowledging
        // this low memory situation.  Subsequent functions will have to be forced
        // to succeed (and do nothing), at least enough to get through the unattended install.
        //**********************************************************************

        if (Intel810FoundStatus == TRUE)

            {
            hwDeviceExtension->DeviceMappingFailed = TRUE;

            ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
            ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
            ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;

            ConfigInfo->NumEmulatorAccessEntries     = 0;
            ConfigInfo->EmulatorAccessEntries        = NULL;
            ConfigInfo->EmulatorAccessEntriesContext = 0;

            ConfigInfo->HardwareStateSize = 0;

            *Again = 0;

            //******************************************************************
            // The only thing this function needed to do anyway
            // was to detect the presence of our chip
            //******************************************************************

            return NO_ERROR;
            }

        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Show all relevant Linear memory ranges to help debug
    //**************************************************************************

    VideoDebugPrint((0,"PMC = 0x%p \n", hwDeviceExtension->NV1_Lin_PMC_Registers));
    VideoDebugPrint((0,"PFB = 0x%p \n",hwDeviceExtension->NV1_Lin_PFB_Registers));
    VideoDebugPrint((0,"PRAMIN = 0x%p \n",hwDeviceExtension->NV3_Lin_PRAMIN_Registers));
    VideoDebugPrint((0,"PRAMFC = 0x%p \n",hwDeviceExtension->NV1_Lin_PRAMFC_Registers));
    VideoDebugPrint((0,"PRAMHT = 0x%p \n",hwDeviceExtension->NV1_Lin_PRAMHT_Registers));
    VideoDebugPrint((0,"PFIFO = 0x%p \n",hwDeviceExtension->NV1_Lin_PFIFO_Registers));
    VideoDebugPrint((0,"PBUS = 0x%p \n",hwDeviceExtension->NV1_Lin_PBUS_Registers));
    VideoDebugPrint((0,"PGRAPH = 0x%p \n",hwDeviceExtension->NV1_Lin_PGRAPH_Registers));
    VideoDebugPrint((0,"CONFIG = 0x%p \n",hwDeviceExtension->NV1_Lin_CONFIG_Registers));
    VideoDebugPrint((0,"PRAMDAC = 0x%p \n",hwDeviceExtension->NV3_Lin_PRAMDAC_Registers));
    VideoDebugPrint((0,"USERDAC = 0x%p \n",hwDeviceExtension->NV3_Lin_USERDAC_Registers));
    VideoDebugPrint((0,"PRMVIO = 0x%p \n",hwDeviceExtension->NV3_Lin_PRMVIO_Registers));
    VideoDebugPrint((0,"PRMCIO = 0x%p \n",hwDeviceExtension->NV3_Lin_PRMCIO_Registers));


#ifdef PC98

    //
    // POST the chip if we're running on a system with no VGA BIOS
    //
    NvPostEx(hwDeviceExtension);

#endif // PC98

    // initialize the RM device register mapping
    if (
        !RmInitNvMapping(
            (VOID*)hwDeviceExtension,
            hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart,
            hwDeviceExtension->NvRegisterBase,
            &hwDeviceExtension->DeviceReference
        )
    )
    {
        return ERROR_DEV_NOT_EXIST;
    }

    // We need to update the IRQ info as the RM has not done this
    {
       U032 oldValue;

       // Get the hals view of the IRQ line from the adapter
       VideoPortGetBusData(
            hwDeviceExtension,
            PCIConfiguration,
            NV1Slot,
            &pciData,
            0,
            PCI_COMMON_HDR_LENGTH
            );

       // Go ahead and set the mapping
       RmConfigSetKernel(hwDeviceExtension->DeviceReference, NV_CFG_IRQ,
                                   (ULONG)pciData.u.type0.InterruptLine, &oldValue);

    }

    //**************************************************************************
    // Flag to denote if adapter is NON primary (ie..device was not booted)
    //**************************************************************************

    hwDeviceExtension->NonPrimaryDevice = FALSE;



    if (!bIsPrimaryDevice)
    {
        VP_STATUS ntStatus = NO_ERROR;
        PHYSICAL_ADDRESS fbPhysAddr;
        ULONG qtyBytesSet, inIoSpace, fbLength;
        PVOID fbAddr;
        // hook up the HAL state now that the chip is accessible
        if (!RmInitNvHal(hwDeviceExtension->DeviceReference))
        {
            return ERROR_DEV_NOT_EXIST;
        }

        // create a large enuff temporary FB mapping to POST the device
        fbPhysAddr.HighPart = 0x00000000;
        fbPhysAddr.LowPart  = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
        fbPhysAddr.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;
        fbLength = 0x04000000 + BIOS_MEM_SIZE_ADJUST_FACTOR;
        inIoSpace = VIDEO_MEMORY_SPACE_P6CACHE;
        fbAddr = NULL;
        ntStatus = VideoPortMapMemory
        (
            hwDeviceExtension,
            fbPhysAddr,
            &fbLength,
            &inIoSpace,
            &fbAddr
        );
        if (ntStatus != NO_ERROR)
        {
            return ntStatus;
        }


        //**********************************************************************
        // Extract the BIOS image (64k) from either PROM or PRAMIN
        // (This function call behaves differently depending on whether
        // MEMORY_SPACE is set by VideoPortSetBusData)
        //**********************************************************************

        NVExtractBiosImage(hwDeviceExtension);


        // POST the device
        if (!RmPostNvDevice(hwDeviceExtension->DeviceReference, (PHWREG)(&(hwDeviceExtension->SavedBiosImageArray[0])), (PHWREG)fbAddr))
        {
            return ERROR_INVALID_PARAMETER;
        }

        // free up the temporary FB mapping
        VideoPortUnmapMemory(
            hwDeviceExtension,
            fbAddr,
            0
        );

        //**************************************************************************
        // If multiple adapters are present, do NOT invoke reset device
        //**************************************************************************

        MultiAdaptersPresent = TRUE;

        //**************************************************************************
        // Flag to denote if adapter is NON primary (ie..device was not booted)
        //**************************************************************************

        hwDeviceExtension->NonPrimaryDevice = TRUE;
    }
    else
    {
        // hook up the HAL state for the primary device
        if (!RmInitNvHal(hwDeviceExtension->DeviceReference))
        {
            return ERROR_DEV_NOT_EXIST;
        }
    }

    //**************************************************************************
    // If this is the PRIMARY adapter, we still need to save off the BIOS image
    // (ExtractBiosImage behaves differently, the BIOS image will be in PROM or PRAMIN)
    //**************************************************************************

    if (hwDeviceExtension->NonPrimaryDevice == FALSE)
        NVExtractBiosImage(hwDeviceExtension);



    //**************************************************************************
    // Fill in NVInfo information structure
    //**************************************************************************

    if (NVGetNVInfo(hwDeviceExtension) == FALSE)
        return(ERROR_DEV_NOT_EXIST);        // Default to VGA if error getting info


    //
    // Store Memory Size
    //

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &(hwDeviceExtension->NvInfo.Framebuffer.RamSize),
                                   sizeof(ULONG));

    //
    // We have this so that the int10 will also work on the VGA also if we
    // use it in this driver.
    //

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries     = 0;
    ConfigInfo->EmulatorAccessEntries        = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //

    ConfigInfo->HardwareStateSize = 0;

    //**************************************************************************
    // Check the DisableVBLANK registry setting
    //**************************************************************************

    DisableVBlankFlag = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DisableVBlank",
                                       FALSE,
                                       NVRegistryCallback,
                                       NULL);

    if (DisableVBlankFlag == NO_ERROR)
        hwDeviceExtension->DisableVBlankFlag = TRUE;
    else
        hwDeviceExtension->DisableVBlankFlag = FALSE;

    //**************************************************************************
    // Check to see if we should handle IF09 format video data.
    //**************************************************************************
    hwDeviceExtension->bEnableIF09 = TRUE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"IF09",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bEnableIF09));
#if _WIN32_WINNT < 0x0500
    //**************************************************************************
    // Check the EnableExtRefresh registry setting. If this is false or
    // not present we limit refresh rates to 85Hz.
    //**************************************************************************
    hwDeviceExtension->bExtRefreshDisable = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DisableExtRefresh",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bExtRefreshDisable));
#endif // #if _WIN32_WINNT < 0x0500

    //**************************************************************************
    // Check the Disable19x12Mode registry setting.
    //**************************************************************************
    hwDeviceExtension->bMax16x12 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Max16x12",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bMax16x12));

    hwDeviceExtension->bDisable19x12x32at60 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Disable19x12x32at60",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisable19x12x32at60));

    hwDeviceExtension->bDisable16x12x32ge70 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Disable16x12x32ge70",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisable16x12x32ge70));

    hwDeviceExtension->bDisable19x10x32ge70 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Disable19x10x32ge70",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisable19x10x32ge70));

    hwDeviceExtension->ulDisableDfpModesGreaterThan = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DisableDfpModesGreaterThan",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->ulDisableDfpModesGreaterThan));

    //**************************************************************************
    // DellSwitch1 registry switch 1:
    //
    // 1) Add 1600x1024 modes 76hz for specific customers
    // 2) Also change 1920x1200 75Hz to 1920x1200 76Hz
    //**************************************************************************

    hwDeviceExtension->bDellSwitch1 = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DellSwitch1",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDellSwitch1));


    //**************************************************************************
    // OGL Stencil registry switch
    //**************************************************************************

    hwDeviceExtension->OglStencilSwitch = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"OglStencil",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->OglStencilSwitch));

    //**************************************************************************
    // Force SW cursor registry switch
    //**************************************************************************

    hwDeviceExtension->ulForceSwCursor = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"ForceSwCursor",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->ulForceSwCursor));


    //**************************************************************************
    // This function is only meaningful for NV4 or better (uses newer RM modeset code)
    // It creates the list of available modes, depending on
    // what modes are available in vesadata.c, and what modes
    // are specified in the registry
    //**************************************************************************

    BuildAvailableModesTable(HwDeviceExtension);

    //**************************************************************************
    // This function is only meaningful for NV4 or better
    // If the NV registry switches are NOT present, then write them to the registry.
    // (Otherwise read the registry values).
    // Then load the registry values into the NT_NV_REGISTRY structure
    // so the miniport/display driver can get to them.
    //**************************************************************************

    LoadRegistrySettings(HwDeviceExtension);


    //**************************************************************************
    // ** MODE DATA FIXUP HACK **
    // The ModeTimingTable is normally a fixed STATIC data table.
    // We can't just ADD another refresh rate without some major changes.
    // So for now, just manually change the 1920x1200 75Hz timing to 1920x1200 76Hz
    // (Note: ValidateModes in nvmode.c also needs to be changed!)
    //
    // OEM Customer wants a SPECIFIC 76hz timing which is NOT GTF or DMT compliant.
    // So we'll accommodate them an use their specific timing....
    //**************************************************************************

    if (hwDeviceExtension->bDellSwitch1)
        {

// Standard GTF timing

//        ModeTimingTable[14*NUMBER_OF_RATES+3][0] = 2624;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][1] = 2064;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][2] = 2272;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][3] = 1253;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][4] = 1201;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][5] = 1204;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][6] = 24988;
//        ModeTimingTable[14*NUMBER_OF_RATES+3][7] = 7600;

// OEM specific requested timing (for Wide Sony monitor)

        ModeTimingTable[14*NUMBER_OF_RATES+3][0] = 2584;
        ModeTimingTable[14*NUMBER_OF_RATES+3][1] = 1984;
        ModeTimingTable[14*NUMBER_OF_RATES+3][2] = 2240;
        ModeTimingTable[14*NUMBER_OF_RATES+3][3] = 1250;
        ModeTimingTable[14*NUMBER_OF_RATES+3][4] = 1203;
        ModeTimingTable[14*NUMBER_OF_RATES+3][5] = 1206;
        ModeTimingTable[14*NUMBER_OF_RATES+3][6] = 24548;
        ModeTimingTable[14*NUMBER_OF_RATES+3][7] = 7600;
        ModeTimingTable[14*NUMBER_OF_RATES+3][8] = BUFFER_HSYNC_NEGATIVE;
        ModeTimingTable[14*NUMBER_OF_RATES+3][9] = BUFFER_VSYNC_NEGATIVE;


        }


#if _WIN32_WINNT >= 0x0500
    //**************************************************************************
    // Determine if we should DISABLE AGP support (Default=ENABLE AGP support)
    //**************************************************************************
    status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                       L"DisableAgp",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bDisableAgp));


#endif // #if _WIN32_WINNT >= 0x0500


#ifdef NVPE
    //**************************************************************************
    // Determine if we should DISABLE VPE (Video Port Extension that controls
    // the Media Port). Default is VPE Enabled !
    //**************************************************************************
    status = VideoPortGetRegistryParameters(
                hwDeviceExtension,
                L"VPEENABLE",
                FALSE,
                NVRegistryCallbackPnpId,
                (PVOID)(&(hwDeviceExtension->dwVPEEnabled)));
    if (status != NO_ERROR)
    {
       // most probably, we didn't find the VPEEnable key, so enable VPE by default !!!
       hwDeviceExtension->dwVPEEnabled = TRUE;
    }
#endif


    *Again = 0;

#if _WIN32_WINNT < 0x0500

    //
    // on NT4 *Again == TRUE indicates the OS to call us back for a further device with FindAdapter and a new hwDeviceExtension
    // so we check here if this is necessary 
    // different here is that we don't want to claim the resources
    //
    {
        ULONG ulNextSlot;
        BOOLEAN bPrimDev;
        USHORT usVendorID, usDeviceID;
        ulNextSlot = ulFindSlot;
        if (NO_ERROR == DetectNextDevice( hwDeviceExtension, 
                                        &ulNextSlot,
                                        2,
                                        NULL, 
                                        &usVendorID,
                                        &usDeviceID,
                                        &bPrimDev,
                                        FALSE))
        {
            *Again = TRUE;
        }
        else
        {
            // reset global slot counter to be ready for the next bus...
            ulFindSlot = 0xFFFFFFFF;
        }
    }
#endif
    
    NVUpdateRegNVInfo(hwDeviceExtension);

#if _WIN32_WINNT >= 0x0500
    //**************************************************************************
    // Copy driver registry path over
    //**************************************************************************
    for (i = 0; i < sizeof(hwDeviceExtension->DriverRegPath) && ConfigInfo->DriverRegistryPath[i] != 0; i++)
        hwDeviceExtension->DriverRegPath[i] = (UCHAR)ConfigInfo->DriverRegistryPath[i];
    if (i < sizeof(hwDeviceExtension->DriverRegPath))
        hwDeviceExtension->DriverRegPath[i] = 0;

    //
    // Read in the registry entry to see if we shoud export the EDID for the DFP or not.
    // This is only to fix a Win2k PnP bug of failing to install PnP monitor.  It only affects Win2k
    //
    hwDeviceExtension->DFPAsDefaultMonitor = 0;
    if (!(ConfigInfo->VideoPortGetProcAddress)(hwDeviceExtension, "VideoPortCreateSecondaryDisplay"))
    {
        VideoPortGetRegistryParameters(hwDeviceExtension,
                                       L"DFPAsDefaultMonitor",
                                       FALSE,
                                       NVRegistryCallback,
                                       (PVOID)&hwDeviceExtension->DFPAsDefaultMonitor);
    }

    //**************************************************************************
    // Enable DualView based several rules
    // 1. Check if setup allows it
    // 2. Check if OS supports it 
    // 3. Check if the chipn has the capability
    //**************************************************************************
    status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                       L"EnableDualView",
                                       FALSE,
                                       NVRegistryCallback,
                                       &OutData);
    if (status == NO_ERROR && OutData)
    {
        typedef
        VP_STATUS
        (*PVIDEO_PORT_CREATE_SECONDARY_DISPLAY)(
            IN PVOID     HwDeviceExtension,
            IN OUT PVOID *SecondaryDeviceExtension,
            IN ULONG     ulFlag
        );
        PVIDEO_PORT_CREATE_SECONDARY_DISPLAY VideoPortCreateSecondaryDisplay = NULL;

        if (ConfigInfo->VideoPortGetProcAddress)
        {
            VideoPortCreateSecondaryDisplay = (PVIDEO_PORT_CREATE_SECONDARY_DISPLAY)
                                              ((ConfigInfo->VideoPortGetProcAddress)(hwDeviceExtension, "VideoPortCreateSecondaryDisplay"));
            if (VideoPortCreateSecondaryDisplay)
            {
                //
                // For Dualview, we moved NVInitRm from HwInitialize to FindAdapter for the reason of detecting DACs beforehand.
                // One side effect of this change is that NVInitRm enables interrupt by itself, thus cause VideoPortFindAdapter
                // having trouble at IOConnectInterrupt (An Interrupt storm happens on toshiba when Reboot).  The fix is to 
                // Disable Interrupt explicitly here and enable it explicitly at NVInitialize.
                //
                if (NVInitRm(hwDeviceExtension) != NO_ERROR)
                    return ERROR_INVALID_PARAMETER;
                NV_DisableNVInterrupts(hwDeviceExtension);

                // Check if it's Laptop
                status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                                   L"DualviewMobile",
                                                   FALSE,
                                                   NVRegistryCallback,
                                                   &OutData);
                if (status == NO_ERROR && OutData)
                {
                   hwDeviceExtension->ulDualViewStatus |= DUALVIEW_STATUS_MOBILE;
                }

                //
                // Only we have two DACs (and physically connected two devices for Desktop),
                // have enough video memory, we enable DualView
                //
                if (NVGetNumBootDevices(hwDeviceExtension) > 1 &&
                    hwDeviceExtension->NvInfo.Framebuffer.RamSize >= VIDEOMEMSIZELIMIT_FOR_DUALVIEW)
                {
                    PHW_DEVICE_EXTENSION hwDE2;
                    status = VideoPortCreateSecondaryDisplay(HwDeviceExtension,
                                                             (PVOID*)&hwDE2,
                                                             (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE) ? VIDEO_DUALVIEW_REMOVABLE : 0);
                    if (status == NO_ERROR)
                    {
                        hwDeviceExtension->ulDualViewStatus |= DUALVIEW_STATUS_ENABLE_DUALVIEW;

                        VideoPortMoveMemory(hwDE2, hwDeviceExtension, sizeof(HW_DEVICE_EXTENSION));
                        hwDE2->ulDualViewStatus |= DUALVIEW_STATUS_SECONDARY;
                        hwDE2->pDualViewAssociatedDE = hwDeviceExtension;
                        hwDeviceExtension->pDualViewAssociatedDE = hwDE2;

                        // BUGBUG  We assume secondary display always be primary device index plus 1.
                        // But the assumption is broken on combination of Multimon and Dualview
                        // The regkey path should only be used for debug purposes
                        for (i = 0; i < sizeof(hwDE2->DriverRegPath) && ConfigInfo->DriverRegistryPath[i] != 0; i++)
                            hwDE2->DriverRegPath[i] = (UCHAR)ConfigInfo->DriverRegistryPath[i];
                        if (i < sizeof(hwDE2->DriverRegPath))
                            hwDE2->DriverRegPath[i] = 0;
                        if (i != 0)
                            hwDE2->DriverRegPath[i]++;

                        NVUpdateRegNVInfo(hwDE2);
                    }
                }
            }
        }
    }

#endif // #if _WIN32_WINNT >= 0x0500

    //**************************************************************************
    // Indicate a successful completion status.
    //**************************************************************************

    return NO_ERROR;

    } // NVFindAdapter()


#if (_WIN32_WINNT >= 0x0500)
//*******************************************************************************
//
//  Function: NVUpdateDualViewDevice
//
//  For DualView.
//
//  Update the secondary display Hardware_Device_Extension and copy relevant
//  information after HwInitialize() be called.
//
//*******************************************************************************

VOID NVUpdateDualViewDevice (PHW_DEVICE_EXTENSION pHwDE)
    {
    PHW_DEVICE_EXTENSION    pHwDE2;
    ULONG                   status;
    ULONG                   SecondviewMemSize, dwMinSize = 640*480;

    //
    // We can not copy ALL HwDeviceExtension data
    //
    if ((pHwDE2 = pHwDE->pDualViewAssociatedDE) == NULL)
        return;

    pHwDE2->CursorTopScanLine    = pHwDE->CursorTopScanLine;
    pHwDE2->CursorBottomScanLine = pHwDE->CursorBottomScanLine;
    pHwDE2->CursorEnable         = pHwDE->CursorEnable;
    pHwDE2->curAdapterPowerState = pHwDE->curAdapterPowerState;
    pHwDE2->curMonitorPowerState = pHwDE->curMonitorPowerState;
    pHwDE2->BiosArea             = pHwDE->BiosArea;
    pHwDE2->flMapMemory          = pHwDE->flMapMemory;

    pHwDE2->NvInfo          = pHwDE->NvInfo;
    pHwDE2->FrameBufferPtr  = pHwDE->FrameBufferPtr;
    pHwDE2->FrameBufferBase = pHwDE->FrameBufferBase;

    pHwDE2->TotalInstanceMemory = pHwDE->TotalInstanceMemory;

    pHwDE2->AgpPagesTotal   = pHwDE->AgpPagesTotal;
    pHwDE2->bAgp            = pHwDE->bAgp;
    pHwDE2->AgpServices     = pHwDE->AgpServices;

    pHwDE2->GammaCache      = pHwDE->GammaCache;
    VideoPortMoveMemory(pHwDE2->GammaCacheData, pHwDE->GammaCacheData, sizeof(pHwDE->GammaCacheData));

    pHwDE2->ulCurrentMacrovisionKey = pHwDE->ulCurrentMacrovisionKey;
    pHwDE2->ulNextMacrovisionKey    = pHwDE->ulNextMacrovisionKey;
    pHwDE2->ulMacrovisionMode       = pHwDE->ulMacrovisionMode;

    pHwDE2->MaxFlatPanelWidth  = pHwDE->MaxFlatPanelWidth;
    pHwDE2->MaxFlatPanelHeight = pHwDE->MaxFlatPanelHeight;

    //
    // Corresponding to NVInitialize_DacsAndEDID(pHwDE2, TRUE);
    // The heads need to be reversed
    //
    pHwDE2->EdidCollection  = pHwDE->EdidCollection;
    pHwDE2->DeskTopInfo     = pHwDE->DeskTopInfo;
    {
        NVTWINVIEWDATA TwinviewInfo;

        if (NVGetRegistryTwinviewInfo(pHwDE, &TwinviewInfo) == NO_ERROR)
        {
            NVSetRegistryTwinviewInfo(pHwDE2, &TwinviewInfo);
        }
    }
    
    SetTimingOverRide(pHwDE2);

    //
    // Corresponding to InitializeCommonModesetCode()
    //
    pHwDE2->pFPStateSave         = pHwDE->pFPStateSave;
    pHwDE2->pFPMutex             = pHwDE->pFPMutex;
    VideoPortMoveMemory(pHwDE2->maxPixelClockFrequency_8bpp, pHwDE->maxPixelClockFrequency_8bpp, sizeof(pHwDE->maxPixelClockFrequency_8bpp));
    VideoPortMoveMemory(pHwDE2->maxPixelClockFrequency_16bpp, pHwDE->maxPixelClockFrequency_16bpp, sizeof(pHwDE->maxPixelClockFrequency_16bpp));
    VideoPortMoveMemory(pHwDE2->maxPixelClockFrequency_32bpp, pHwDE->maxPixelClockFrequency_32bpp, sizeof(pHwDE->maxPixelClockFrequency_32bpp));

    NVSetBiosInfo(pHwDE2);
    NVValidateModes(pHwDE2);
    }
#endif


//******************************************************************************
//
// Function: NVInitialize()
//
// Routine Description:
//
//     This routine does one time initialization of the device.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's adapter information.
//
// Return Value:
//
//     None.
//
//******************************************************************************

BOOLEAN NVInitialize(
    PVOID HwDeviceExtension
    )
    {

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG Status;


    //**************************************************************************
    // Check for unattended install with Intel 810.
    // If so, then just return true.
    //**************************************************************************

    if (hwDeviceExtension->DeviceMappingFailed == TRUE)
        return TRUE;

    //**************************************************************************
    // Set up the default cursor position and type.
    //**************************************************************************


    hwDeviceExtension->CursorTopScanLine = 0;
    hwDeviceExtension->CursorBottomScanLine = 31;
    hwDeviceExtension->CursorEnable = TRUE;

    hwDeviceExtension->BiosArea = (PUSHORT)NULL;

    //***************************************************************************
    // Default to disabling write combining when mapping fb.
    //***************************************************************************
    hwDeviceExtension->flMapMemory = 0;

    //***************************************************************************
    // Initialize current power state.
    //***************************************************************************
    hwDeviceExtension->curAdapterPowerState = VideoPowerOn;
    hwDeviceExtension->curMonitorPowerState = VideoPowerOn;

    if (NVInitRm(hwDeviceExtension) != NO_ERROR)
        return FALSE;

    // One time initialization of the twinview structures.
    NVOneTimeInit_TwinView(hwDeviceExtension);

    // One time initialization of the saveSettings table.
    vInitializeSaveSettings(hwDeviceExtension);

    // Debug print
    vPrintSaveSettings(hwDeviceExtension);

    // Detect the Head info and read in the EDIDs
    // The TRUE indicates it is a boottime operation.
    if (!NVInitialize_DacsAndEDID(hwDeviceExtension, TRUE))
    {
        return FALSE;
    }

    // Initialize our CRT timing standard overrides.
    SetTimingOverRide(HwDeviceExtension);

    // One time initialization of the common mode set code fields.
    InitializeCommonModesetCode(hwDeviceExtension);

    // One time initialization of the mapping of power states from Win2K's states to nVidia's states.
    InitializeACPIStates(hwDeviceExtension);


    //**************************************************************************
    // Store BIOS revision string in the registry. This must be
    // done now since we need to call the RM to get the BIOS rev,
    // and the RM is not fully initialized at FindAdapter time.
    //**************************************************************************
    NVSetBiosInfo(hwDeviceExtension);

    //**************************************************************************
    // Get monitor info (TV out) into NVInfo struct
    //**************************************************************************
    NVGetMonitorType(hwDeviceExtension);

    //**************************************************************************
    // Get total amount of instance memory.
    // We need to save/restore all of instance memory across a Win2k standby
    //**************************************************************************

    RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_INSTANCE_TOTAL, &(hwDeviceExtension->TotalInstanceMemory));

    if (hwDeviceExtension->TotalInstanceMemory > MAX_INSTANCE_MEM_SIZE)
        {
        VideoDebugPrint((2, "ERROR:  ----------------------------- !!!!\n"));
        VideoDebugPrint((2, "ERROR:  Need to increase size of      !!!!\n"));
        VideoDebugPrint((2, "ERROR:  SavedInstanceMemory buffer    !!!!\n"));
        VideoDebugPrint((2, "ERROR:  in HwDeviceExtension          !!!!\n"));
        VideoDebugPrint((2, "ERROR:  ----------------------------- !!!!\n"));
        }

    //**************************************************************************
    // Validate the modes.
    // This function call was originally in NVFindAdapter.
    // However, since it depends on the result of GetMonitorType,
    // (whether we're running on a TV or not), it needs to occur
    // AFTER GetMonitorType.
    //**************************************************************************

    NVValidateModes(hwDeviceExtension);

    // Check to see if the DFP supports 1400x1050 natively on a laptop.
    Verify1400x1050DFP(hwDeviceExtension);

#if (_WIN32_WINNT >= 0x0500) && (!defined(DISABLE_AGP))
    {
    //**************************************************************************
    // Check registry switch to see if we disabled AGP support
    //**************************************************************************

    if (hwDeviceExtension->bDisableAgp)
        goto Agp_Done;

    //**************************************************************************
    // Disable AGP if running on an ALI 1541 chipset
    //**************************************************************************

    if (hwDeviceExtension->AliChipset_Problem_Found)
        goto Agp_Done;

    hwDeviceExtension->AgpPagesTotal = ((MAX_AGP_HEAP + (PAGE_SIZE - 1)) &
                                            ~(PAGE_SIZE - 1)) / PAGE_SIZE;

    //***********************************************************
    // Determine if AGP memory is available.
    //***********************************************************
    hwDeviceExtension->bAgp =
        VideoPortGetAgpServices(hwDeviceExtension,
            &(hwDeviceExtension->AgpServices));
    }
Agp_Done:

    //**************************************************************************
    // If successful, let the RM know where the AGP services are
    //**************************************************************************
    if (hwDeviceExtension->bAgp)
    {
        RmSetAgpServices(hwDeviceExtension->DeviceReference,
                         &hwDeviceExtension->AgpServices);
    }

#endif // #if _WIN32_WINNT >= 0x0500

    {
      PVIDEO_CLUTDATA   pvcdItem;
      int i, iHead;

      VideoDebugPrint((1, "NVInitialize - Initializing the Gamma cache values to defaults\n"));

      // - Init the clut params
      hwDeviceExtension->GammaCache.NumEntries = 256;
          hwDeviceExtension->GammaCache.FirstEntry = 0;

                pvcdItem = &hwDeviceExtension->GammaCache.LookupTable->RgbArray;

      // - Init the CLUT data to a default gamma ramp
      for(iHead = 0; iHead < NV_NO_DACS; iHead++)
      {
        for(i = 0; i < 256; i++) 
        {
            pvcdItem[i+iHead*256].Blue   = (UCHAR)i; /* blue value */
            pvcdItem[i+iHead*256].Green  = (UCHAR)i; /* green value */
            pvcdItem[i+iHead*256].Red    = (UCHAR)i; /* red value */
            pvcdItem[i+iHead*256].Unused = (UCHAR)0; /* unused value */
        }
      }

    }

   
    // To rid oursleves of some nasty visual effects when opening the panel when on a TV,
    // we need to stash the encoder status and type in the registry for later reference
    {
        NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS TVInfo;
        ULONG TVEncoderType;
        ULONG TVEncoderID;

        // Assume that this adapter lacks a TV encoder 
        TVEncoderType = TV_ENCODER_NONE;
        TVEncoderID = 0;

        // Use head 0 for this case
        TVInfo.Head = 0;
        TVInfo.EncoderType = TV_ENCODER_NONE;
        TVInfo.EncoderID = 0;

        // Attemp the resman call for the encoder info...
        if (RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                NV_CFGEX_GET_TV_ENCODER_INFO_MULTI, &TVInfo, 
                                sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS)))

        {

            // We have a valid blob from the resman, so extract the encoder info
            TVEncoderType = TVInfo.EncoderType;
            TVEncoderID = TVInfo.EncoderID;

        }
        else
        {

            // The resman had issues with our request, so spew a warning
            VideoDebugPrint((0, "NVInitialize -  RmConfigGetExKernel() returned error for NV_CFGEX_GET_TV_ENCODER_INFO_MULTI\n"));
        }

        //
        // Save the encoder info in the HwDevExtension as it gets referenced frequently
        //
        hwDeviceExtension->ulTVEncoderType = TVEncoderType;
        hwDeviceExtension->ulTVEncoderID =   TVEncoderID;

        //
        // Set up the max TV resolution. We need to pass it to the common modeset code while calling
        // FindModeEntry().
        //
        if (TVInfo.EncoderType == NV_ENCODER_BROOKTREE_871)
        {
            hwDeviceExtension->ulMaxTVOutResolution = (1024 << 16) | 768;
        }
        else
        {
            hwDeviceExtension->ulMaxTVOutResolution = (800 << 16) | 600;
        }


        // No matter what the outcome above, flush the derived encoder values to the registry

        VideoPortSetRegistryParameters( HwDeviceExtension,
                                        L"TVEncoderType",
                                        &TVEncoderType,
                                        sizeof(ULONG));

        VideoPortSetRegistryParameters( HwDeviceExtension,
                                        L"TVEncoderID",
                                        &TVEncoderID,
                                        sizeof(ULONG));

    }

    // After initialing the EDIDs, parse the EDIDs for the best supported resolution the first time boot
    // after driver installation.
    HandleBestResolution(HwDeviceExtension);
    

#if (_WIN32_WINNT >= 0x0500)
    // Initializing the macrovision
    hwDeviceExtension->ulCurrentMacrovisionKey = -1;
    hwDeviceExtension->ulNextMacrovisionKey = 0x99999999;
    hwDeviceExtension->ulMacrovisionMode = 3;

    NVUpdateDualViewDevice(hwDeviceExtension);
#endif
    return TRUE;

    } // NVInitialize()


//******************************************************************************
//
// Function: NVStartIO()
//
// Routine Description:
//
//    This routine is the main execution routine for the miniport driver. It
//    acceptss a Video Request Packet, performs the request, and then returns
//    with the appropriate status.
//
// Arguments:
//
//    HwDeviceExtension - Pointer to the miniport driver's adapter information.
//
//    RequestPacket - Pointer to the video request packet. This structure
//        contains all the parameters passed to the VideoIoControl function.
//
// Return Value:
//
//    This routine will return error codes from the various support routines
//    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
//    buffers and ERROR_INVALID_FUNCTION for unsupported functions.
//
//******************************************************************************


BOOLEAN
NVStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;

    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    PHYSICAL_ADDRESS shareAddress;
    PVOID virtualAddress;
    ULONG byteLength;
    ULONG sharedViewSize;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    ULONG Address;
    PHYSICAL_ADDRESS NVFrameBuffer;
    PHYSICAL_ADDRESS AliFixupBaseAddress;
    ULONG IOLength;
    PVOID AliVirtualAddress;
    PHWINFO NVInfo;

    //**************************************************************************
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //**************************************************************************

    VideoDebugPrint((2, "W32StartIO Entry - %08.8x\n", RequestPacket->IoControlCode));

    switch (RequestPacket->IoControlCode) {
    
#ifdef ENABLE_WIN2K_HOTKEY_CODE
#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // GET_CHILD_STATE
    //**************************************************************************
    case IOCTL_VIDEO_GET_CHILD_STATE:
        
        VideoDebugPrint((1, "\nW32StartIO - SetChildState\n"));
        status = NVGetChildState(HwDeviceExtension, RequestPacket);
        break;

    //**************************************************************************
    // VALIDATE_CHILD_STATE_CONFIGURATION
    //**************************************************************************
    case IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION:

        VideoDebugPrint((1, "\nW32StartIO - ValidateChildStateConfiguration\n"));
        status = NVValidateChildState(HwDeviceExtension, RequestPacket);
        break;

    //**************************************************************************
    // SET_CHILD_STATE_CONFIGURATION
    //**************************************************************************
    case IOCTL_VIDEO_SET_CHILD_STATE_CONFIGURATION:

        VideoDebugPrint((1, "\nW32StartIO - SetChildStateConfiguration\n"));
        status = NVSetChildState(HwDeviceExtension, RequestPacket);
        break;

#endif _WIN32_WINNT >= 0x0500
#endif ENABLE_WIN2K_HOTKEY_CODE

#if (_WIN32_WINNT >= 0x0500)
    //**************************************************************************
    // SWITCH_DUALVIEW
    //**************************************************************************
    case IOCTL_VIDEO_SWITCH_DUALVIEW:

        VideoDebugPrint((1, "\nW32StartIO - Switch Dualview\n"));
        status = NVSwitchDualView(HwDeviceExtension, *((PULONG)RequestPacket->InputBuffer));
        break;
#endif _WIN32_WINNT >= 0x0500

    //**************************************************************************
    // SHARE_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:


        VideoDebugPrint((2, "W32StartIO - ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
            }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //**********************************************************************
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //**********************************************************************

        //**********************************************************************
        //
        // NOTE: AdapterMemorySize was adjusted in NVValidateModes
        //       to compensate for INSTANCE memory in offscreen memory.
        //       That is, Hash Table, Fifo Context, and Run Out information
        //       is stored in PRAMIN memory, which also exists in offscreen memory.
        //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
        //
        //       When sharing memory (for Direct X), we must make sure that
        //       we don't give anyone else access to the last 196k or so of offscreen VRAM.
        //       Otherwise, someone else may corrupt our instance memory.
        //**********************************************************************

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = 0;

        //**********************************************************************
        // NOTE: we are ignoring ViewOffset
        //**********************************************************************

        shareAddress.HighPart = 0x00000000;
        shareAddress.LowPart = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_DFB_ADDRESS].RangeStart.LowPart;
        shareAddress.LowPart += RangeOffsets[NV_PDFB_INDEX].ulOffset;

        //**********************************************************************
        // Specifying virtualAddress = 0 will cause this address to be
        // mapped into the address space of the current process
        //**********************************************************************
        inIoSpace |= hwDeviceExtension->flMapMemory;
        status = VideoPortMapMemory(hwDeviceExtension,
                                    shareAddress,
                                    &sharedViewSize,
                                    &inIoSpace,
                                    &virtualAddress);

        pShareMemoryInformation = RequestPacket->OutputBuffer;

        //**********************************************************************
        // Returned shared virtual address to specific process
        //**********************************************************************

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        break;

    //**************************************************************************
    // UNSHARE_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "W32StartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;

    //**************************************************************************
    // QUERY_PUBLIC_ACCESS_RANGES
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:


        VideoDebugPrint((1, "NVStartIO - Map W32 MMU or ACL\n"));

        //**********************************************************************
        // Currently, we'll be giving the display driver
        // public access to 5 ranges (in addition to the frame buffer)
        //
        //     1) User Channel
        //     2) Graphics Status register (to check for Engine Busy)
        //     3) Vertical Blank (PFB_CONFIG_0 register)
        //     4) Frame Buffer Start Address
        //     5) DAC Registers
        //
        // The Frame buffer is mapped separately in VIDEO_MAP_VIDEO_MEMORY
        //
        //
        // NV3: We also need access to the following memory ranges for NV3
        //      to access the cursor, vertical,miscellaneous registers
        //      which are different from NV1.
        //
        //     6) PRMCIO
        //     7) PRMVIO
        //     8) PRAMDAC
        //     9) PRAMIN (So we can get to the cursor image data)
        //     10) TEXTURE DATA (in System Memory)
        //     11) PGRAPH Registers
        //     12) DMA Buffer Area (Fixed/Locked contiguous memory)
        //     13) PFIFO Registers
        //
        //**********************************************************************

        if (RequestPacket->OutputBufferLength <
            13 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        else

            {
            PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
            PVOID                       base;
            ULONG                       ulIndex;

            //******************************************************************
            // Currently, we'll be giving the display driver
            // public access to 5 ranges (in addition to the frame buffer)
            //
            //     1) User Channel
            //     2) Graphics Status register (to check for Engine Busy)
            //     3) Vertical Blank (PFB_CONFIG_0 register)
            //     4) Frame Buffer Start Address
            //     5) DAC Registers
            //
            // The Frame buffer is mapped separately in VIDEO_MAP_VIDEO_MEMORY
            //
            //
            // NV3: We also need access to the following memory ranges for NV3
            //      to access the cursor,vertical,miscellaneous registers
            //      which are different from NV1.
            //
            //     6) PRMCIO
            //     7) PRMVIO
            //     8) PRAMDAC
            //     9) PRAMIN (So we can get to the cursor image data)
            //     10) TEXTURE DATA (in System Memory)
            //     11) PGRAPH Registers
            //
            //******************************************************************

            RequestPacket->StatusBlock->Information =
                12 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

            portAccess = RequestPacket->OutputBuffer;

            //******************************************************************
            // Map the NV user channel area (Treat it like Memory Mapped IO)
            //******************************************************************

            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

            //******************************************************************
            // We now use just 1 mapping to access ALL registers, and
            // just 1 mapping to access the framebuffer.  Display Driver,
            // miniport, and Resource Manager now use the same mappings!
            // See NVMapMemoryRanges() and NVMapFrameBuffer() for more info.
            //******************************************************************

            status = NO_ERROR;

            portAccess->VirtualAddress  = (PVOID)(hwDeviceExtension->NvRegisterBase);
            base                         = (PVOID)(hwDeviceExtension->NvRegisterBase);



//Map_PGRAPH_Status:

            //******************************************************************
            // Map the second range for the PGRAPH Status register
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulOffset;

//Map_PFG_CONFIG_0:

            //******************************************************************
            // Map the third range for the PFB_CONFIG_0 register
            // (so we can check for vertical blanking)
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulOffset;

//Map_PFB_Start_Address:

            //******************************************************************
            // Map the fourth range for the PFB_START_ADDRESS register
            // (so we can flip the current buffer)
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

//Map_DAC_Regs:

            //******************************************************************
            // Map the fifth range for the DACRegs memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;



//Map_PRMCIO_Regs:

            //******************************************************************
            // Map the sixth range for the NV3 PRMCIO memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;

            //******************************************************************
            // PRMCIO only exists for NV3.
            // Don't map it for NV1.
            // TO DO:  Might want to put this in NV3.C
            //         We want to separate out all NV1/NV3 specific code!!!
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PRMCIO_INDEX].ulOffset;


//Map_PRMVIO_Regs:

            //******************************************************************
            // Map the seventh range for the NV3 PRMVIO memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // PRMVIO only exists for NV3.
            // Don't map it for NV1.
            // TO DO:  Might want to put this in NV3.C
            //         We want to separate out all NV1/NV3 specific code!!!
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PRMVIO_INDEX].ulOffset;


//Map_PRAMDAC_Regs:

            //******************************************************************
            // Map the eighth range for the NV3 PRAMDAC memory range
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // PRAMDAC only exists for NV3.
            // Don't map it for NV1.
            // TO DO:  Might want to put this in NV3.C
            //         We want to separate out all NV1/NV3 specific code!!!
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PRAMDAC_INDEX].ulOffset;


//Map_PRAMIN_Memory:

            //******************************************************************
            // Map the ninth range for the NV3 PRAMIN Instance Memory
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;

//Map_Texture_Buffer:

            //******************************************************************
            // Map the Tenth range to contain information about
            // the texture buffer in system memory.
            // We'll use Virtual Address  -> Virtual Address
            //           InIoSpace        -> Physical Address
            //           MappedInIoSpace  -> Length of buffer
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = FALSE;



//Map_PGRAPH_Regs:
            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // Map the Eleventh range for the NV3 PGRAPH registers
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PGRAPH_INDEX].ulOffset;

//Map_PFIFO_Regs:
            portAccess++;
            portAccess->VirtualAddress = (PVOID) NULL;

            //******************************************************************
            // Map the Twelfth range for the NV3 PFIFO registers
            //******************************************************************

            portAccess->VirtualAddress = (PUCHAR)(base) +
                RangeOffsets[NV_PFIFO_INDEX].ulOffset;


//Map_NV3_DMA_Buffer_Area:

            //******************************************************************
            // Map the 13th range to contain information about
            // the DMA buffer in system memory.
            // We'll use Virtual Address  -> Virtual Address
            //           InIoSpace        -> Physical Address
            //           MappedInIoSpace  -> Length of buffer
            //******************************************************************

            portAccess++;
            portAccess->VirtualAddress  = (PVOID) NULL;
            portAccess->InIoSpace       = FALSE;
            portAccess->MappedInIoSpace = FALSE;

            }

        break;

    //**************************************************************************
    // FREE_PUBLIC_ACCESS_RANGES
    //**************************************************************************

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:


        VideoDebugPrint((2, "NVStartIO - FreePublicAccessRanges\n"));

        {
        PVIDEO_MEMORY mappedMemory;
        ULONG i;

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        status = NO_ERROR;


        //******************************************************************
        // We now use just 1 mapping to access ALL registers, and
        // just 1 mapping to access the framebuffer.  Display Driver,
        // miniport, and Resource Manager now use the same mappings!
        // See NVMapMemoryRanges() and NVMapFrameBuffer() for more info.
        //
        // It never gets unmapped, and is always available
        //******************************************************************

        }

        break;

    //**************************************************************************
    // MAP_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "NVStartIO - MapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        //*********************************************************************
        // Make sure to set the VideoRamLength!
        //
        // NOTE: AdapterMemorySize was adjusted in NVValidateModes
        //       to compensate for INSTANCE memory in offscreen memory.
        //       That is, Hash Table, Fifo Context, and Run Out information
        //       is stored in PRAMIN memory, which also exists in offscreen memory.
        //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
        //
        //*********************************************************************

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                (RequestPacket->InputBuffer))->RequestedVirtualAddress;

        //*********************************************************************
        // Get the ptr to the NVInfo structure and initialize the video ram
        // length to be mapped.  DO NOT use hwDeviceExtension->AdapterMemorySize
        // because that value is NOT aligned on a MB boundary (it's adjusted to
        // exclude a portion of video memory).  Using that value would cause
        // the VideoPortMapMemory call to NOT correctly set write combining.
        // Use Framebuffer.RamSize instead !!!
        //*********************************************************************

        NVInfo = &(hwDeviceExtension->NvInfo);

        //**********************************************************************
        // Frame buffer is now mapped earlier, in NVMapFrameBuffer
        // So just return that mapping...Mapping is done in ONE place
        // ONLY, so the miniport, RM, and display driver can access it.
        // (No more multiple mappings of the frame buffer!)
        //**********************************************************************

        memoryInformation->FrameBufferBase = hwDeviceExtension->FrameBufferPtr;
        memoryInformation->FrameBufferLength = NVInfo->Framebuffer.RamSize;

        status = NO_ERROR;


        break;

    //**************************************************************************
    // UNMAP_VIDEO_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "NVStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        //**********************************************************************
        // Frame buffer is now mapped earlier, in NVMapFrameBuffer
        // It's mapped one time, and doesn't get unmapped
        //**********************************************************************

        status = NO_ERROR;

        break;

    //**************************************************************************
    // QUERY_AVAIL_MODES
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "NVStartIO - QueryAvailableModes\n"));

        status = NVQueryAvailableModes(hwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        &RequestPacket->StatusBlock->Information);

        break;

    //**************************************************************************
    // QUERY_NUM_AVAIL_MODES
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "NVStartIO - QueryNumAvailableModes\n"));

        status = NVQueryNumberOfAvailableModes(hwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                &RequestPacket->StatusBlock->Information);

        break;

    //**************************************************************************
    // QUERY_CURRENT_MODE
    //**************************************************************************

    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "NVStartIO - QueryCurrentMode\n"));

        status = NVQueryCurrentMode(hwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     &RequestPacket->StatusBlock->Information);

        break;

    //**************************************************************************
    // GET TIMING OF DAC at giving resolution
    //
    //**************************************************************************
    case IOCTL_VIDEO_GET_TIMING_DAC:
    {
        HEAD_RESOLUTION_INFO * pResolution;
        DAC_TIMING_VALUES * pTimingInfo;

        status = ERROR_INSUFFICIENT_BUFFER;
        if(RequestPacket->InputBufferLength == sizeof(HEAD_RESOLUTION_INFO))
        {
            pResolution = (HEAD_RESOLUTION_INFO *) RequestPacket->InputBuffer;
            if(RequestPacket->OutputBufferLength == sizeof(DAC_TIMING_VALUES))
            {
                pTimingInfo = (DAC_TIMING_VALUES *) RequestPacket->OutputBuffer;
                if(NVGetTimingForDac(hwDeviceExtension, pResolution, pTimingInfo))
                {
                    // Patch for Timing values.  Our engine only accepts values aligned to 8
                    pTimingInfo->HorizontalTotal &= 0xFFFFFFFC;
                    pTimingInfo->HorizontalBlankStart &= 0xFFFFFFFC;
                    pTimingInfo->HorizontalRetraceStart &= 0xFFFFFFFC;
                    pTimingInfo->HorizontalRetraceEnd &= 0xFFFFFFFC;
                    pTimingInfo->HorizontalBlankEnd &= 0xFFFFFFFC;

                    RequestPacket->StatusBlock->Information = sizeof(DAC_TIMING_VALUES);
                    status = NO_ERROR;
                }
            }
        }
    }

    break;

    //**************************************************************************
    // Call RM before set mdoe
    //
    //**************************************************************************
    case IOCTL_VIDEO_PREMODE_SET:
    {
        ULONG * pulHead;

        status = ERROR_INSUFFICIENT_BUFFER;
        if(RequestPacket->InputBufferLength == sizeof(ULONG))
        {
            pulHead = (ULONG *) RequestPacket->InputBuffer;
            if(RmPreModeSet(hwDeviceExtension->DeviceReference, *pulHead))
            {
                    status = NO_ERROR;
            }
        }


    }
    break;

    //**************************************************************************
    // Call RM after set mdoe
    //
    //**************************************************************************
    case IOCTL_VIDEO_POSTMODE_SET:
    {
        ULONG * pulHead;

        status = ERROR_INSUFFICIENT_BUFFER;
        if(RequestPacket->InputBufferLength == sizeof(ULONG))
        {
            pulHead = (ULONG *) RequestPacket->InputBuffer;
            if(RmPostModeSet(hwDeviceExtension->DeviceReference, *pulHead))
            {
                    status = NO_ERROR;

            }

        }


    }
    break;

    //**************************************************************************
    // Setup Virtual Desktop information
    //**************************************************************************
    case IOCTL_VIDEO_SET_DESKTOP_INFO_MODE:
        {
            NV_DESKTOP_INFO * pDeskTop;
            ULONG i;

            if(RequestPacket->InputBufferLength == sizeof(NV_DESKTOP_INFO))
            {
                pDeskTop = (NV_DESKTOP_INFO *) RequestPacket->InputBuffer;
                hwDeviceExtension->DeskTopInfo.ulDesktopModeIndex = pDeskTop->ulDesktopModeIndex;

                hwDeviceExtension->DeskTopInfo.ulDesktopMode = pDeskTop->ulDesktopMode;
                hwDeviceExtension->DeskTopInfo.ulTwinView_State = pDeskTop->ulTwinView_State;
                hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard = pDeskTop->ulNumberDacsOnBoard;
                hwDeviceExtension->DeskTopInfo.ulNumberDacsConnected = pDeskTop->ulNumberDacsConnected;
                hwDeviceExtension->DeskTopInfo.ulNumberDacsActive = pDeskTop->ulNumberDacsActive;

                hwDeviceExtension->DeskTopInfo.ulDesktopWidth = pDeskTop->ulDesktopWidth;
                hwDeviceExtension->DeskTopInfo.ulDesktopHeight = pDeskTop->ulDesktopHeight;

                hwDeviceExtension->DeskTopInfo.ulAllDeviceMask = pDeskTop->ulAllDeviceMask;
                hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask = pDeskTop->ulConnectedDeviceMask;

                for(i = 0; i < NV_NO_DACS; i++)
                {
                    hwDeviceExtension->DeskTopInfo.ulDisplayWidth[i] = pDeskTop->ulDisplayWidth[i];
                    hwDeviceExtension->DeskTopInfo.ulDisplayHeight[i] = pDeskTop->ulDisplayHeight[i];
                    hwDeviceExtension->DeskTopInfo.ulDisplayRefresh[i] = pDeskTop->ulDisplayRefresh[i];
                    hwDeviceExtension->DeskTopInfo.ulDisplayPixelDepth[i] = pDeskTop->ulDisplayPixelDepth[i];
                    hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i] = pDeskTop->ulDeviceDisplay[i];
                    hwDeviceExtension->DeskTopInfo.ulDeviceMask[i] = pDeskTop->ulDeviceMask[i];
                    hwDeviceExtension->DeskTopInfo.ulDeviceType[i] = pDeskTop->ulDeviceType[i];
                    hwDeviceExtension->DeskTopInfo.ulTVFormat[i] = pDeskTop->ulTVFormat[i];
                }

                // TODO ...  
                // Display driver already checks this; Miniport driver should double check ??
                // Should call RM to check dual head support
                if(1)
                    *((BOOLEAN *) RequestPacket->OutputBuffer) =  TRUE ;
                else
                    *((BOOLEAN *) RequestPacket->OutputBuffer) =  FALSE ;

                RequestPacket->StatusBlock->Information = sizeof(BOOLEAN);
                status = NO_ERROR;
                break;
            }
            else
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_SET_DESKTOP_DISPLAY_MODE - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        }

        break;

    
    case IOCTL_VIDEO_CLEAR_FRAMEBUFFER:
        {
        ULONG i;
        if (hwDeviceExtension->FrameBufferPtr !=NULL)
            {
            //**********************************************************************
            // Clear the framebuffer prior to setting the video mode.
            // This is for aesthetics only.
            // Back up 1Mb to make absolutely sure we don't walk over any instance memory
            //**********************************************************************
            for (i = 0; i < ( (hwDeviceExtension->AdapterMemorySize-0x100000) >> 2); i++)
                {
                ((PULONG) hwDeviceExtension->FrameBufferPtr)[i] = 0;
                }
            }
        }
        status = NO_ERROR;
        break;

    //**************************************************************************
    // SET_CURRENT_MODE
    //**************************************************************************

    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "NVStartIO - SetCurrentModes\n"));

        // Call the RM to enable hot key functionality
        RmSetDriverHotkeyHandling(hwDeviceExtension->DeviceReference, TRUE);

        // Also clear the hotkeyPending flag since a modeset will be done.
        hwDeviceExtension->ulHotKeyPending = 0;

#if 1
   {   //check for last saved flat panel mode and set it if necessary
        ULONG  regmode  = -1;
        BOOL   fpstatus = 0;
        BOOL   Status;
        ULONG  head;
        ULONG  i;
        NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS fpGetParams; 
        NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS fpSetParams;
         
        Status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                           L"FlatPanelMode",
                                           FALSE,
                                           NVRegistryCallback,
                                           &regmode);
                                          
        if (Status == NO_ERROR && regmode <= 2)
        {
            for (i=0;i<hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
            {
                head = hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
                if(MaskToDeviceType(hwDeviceExtension->DeskTopInfo.ulDeviceMask[head]) ==
                                    MONITOR_TYPE_FLAT_PANEL)
                {
                    fpGetParams.Head = head;
                    fpstatus = RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                        NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI,
                                        &(fpGetParams), 
                                        sizeof(NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS));
    
                    if( fpstatus == TRUE && 
                        regmode  != fpGetParams.FlatPanelMode && 
                        fpGetParams.FlatPanelMode  <= 2 )
                    {
                        fpSetParams.CommitChanges = 0; //already committed
                        fpSetParams.FlatPanelMode = regmode;
                        fpSetParams.Head = head;
                        RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                            NV_CFGEX_SET_FLAT_PANEL_SCALING,
                                            &fpSetParams, 
                                            sizeof(NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS));
                    } //if modes arent the same
                }//if flat panel
            }//for each active dac
        }//if registry returns no error
        else
        {
            //else the registry didn't tell us what to do, so default to adapter scaling. NEC hi-priority request.
            for (i=0;i<hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
            {
                head = hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
                if(MaskToDeviceType(hwDeviceExtension->DeskTopInfo.ulDeviceMask[head]) ==
                                    MONITOR_TYPE_FLAT_PANEL)
                {
                    {
                        fpSetParams.CommitChanges = 1; //not committed yet
                        regmode = NV_CFGEX_GET_FLATPANEL_INFO_SCALED;
                        fpSetParams.FlatPanelMode = regmode;
                        fpSetParams.Head = head;
                        RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                            NV_CFGEX_SET_FLAT_PANEL_SCALING,
                                            &fpSetParams, 
                                            sizeof(NV_CFGEX_SET_FLATPANEL_INFO_MULTI_PARAMS));
                    } //if modes arent the same
                }//if flat panel
            }//for each active dac     
        }
    } //end of checking for last saved flat panel mode and setting.
#endif    

        status = NVSetMode(hwDeviceExtension,
                              (PVIDEO_MODE) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);

        //******************************************************************************
        // Did caller ask if we supported hw video overlay?
        //******************************************************************************
        if (RequestPacket->OutputBufferLength  == sizeof(BOOLEAN))
            {
            //******************************************************************************
            // return whether or hw video overlay is supported in the current mode.
            //******************************************************************************
            *((BOOLEAN *) RequestPacket->OutputBuffer) = hwDeviceExtension->bHwVidOvl;
            RequestPacket->StatusBlock->Information = sizeof(BOOLEAN);
            }


// removed hard coded status....

        //
        // Refresh gamma clut after modeset
        //
        // Update the gamma concept if we are not on an NV3
        if( !(hwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_CLASS_SET_MODE))
        {

            VideoDebugPrint((2, "IOCTL_VIDEO_SET_CURRENT_MODE - Updating gamma registers\n"));

                // We need to make sure that we wait for the vblank interrupt handler to run at least once before
                // we update the gamma values, as the handler will also write out the values in the dac.gamma table
                // and clobber anything that we have written.  This is very backdoor, and should be handled in a more
                // proper way, say by letting the vblank code update these for us by letting it know what we want.


            if(hwDeviceExtension->ulChipID != NV3_DEVICE_NV3_ID)
            {
               U032   StartVBlank,CurrentVBlank;

               // Do this: Get some vblank count and wait for it to change

               // Get the first relative start value
               if(RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_VBLANK_COUNTER, &CurrentVBlank)) {

                  StartVBlank = CurrentVBlank;
                  while(CurrentVBlank == StartVBlank) {    // Wait till they are different
                        if(!RmConfigGetKernel(hwDeviceExtension->DeviceReference, NV_CFG_VBLANK_COUNTER, &CurrentVBlank)) {
                           CurrentVBlank = StartVBlank + 1;   // This is how we break out of here if the RM fails
                        }
                  }
               }

                NV_SetPixMixBits(hwDeviceExtension);

                NVSetColorLookup(hwDeviceExtension,
                            (PVIDEO_CLUT) &hwDeviceExtension->GammaCache,
                            MAX_CLUT_SIZE);
            }
        }

        //**************************************************************************
        //
        // We need to let the control panel know that the modeset has occurred.
        // For example, in TwinView configuration, NT4.0/Win2K sometimes ignores a 
        // modeset request for the same mode even though we could be changing the mode
        // from normal to clone, but with the same resolution.
        // nVidia control sets this registry entry to 0, calls Win2K to do a modeset
        // and then tests this registry entry to see if the display driver actually
        // was called or not.
        //
        //**************************************************************************

        {
          ULONG NvCplModeSetHasOccurred;      // Used only by the control panel.
          
          NvCplModeSetHasOccurred = 1;
          hwDeviceExtension->SystemModeSetHasOccurred = 1;

          VideoPortSetRegistryParameters(hwDeviceExtension,
                                      L"NvCplModeSetHasOccurred",
                                      &NvCplModeSetHasOccurred,
                                      sizeof(ULONG));
          VideoPortSetRegistryParameters(hwDeviceExtension,
                                      L"SystemModeSetHasOccurred",
                                      &hwDeviceExtension->SystemModeSetHasOccurred,
                                      sizeof(ULONG));
        }
        break;

    //**************************************************************************
    // Store the unique integer ID for the ppdev for the ensuing IOCTL_RESET_DEVICE.
    //**************************************************************************
    case IOCTL_VIDEO_SET_UNIQUENESS_VGA:
        {
            ULONG ulUniqueness;
            status = NO_ERROR;

            if(RequestPacket->InputBufferLength < sizeof(ULONG))
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_SET_UNIQUENESS_VGA - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
            ulUniqueness = *(ULONG *)RequestPacket->InputBuffer;
            hwDeviceExtension->ulUniquenessVGA = ulUniqueness;
            VideoDebugPrint((1, "UniquenessVGA stored: 0x%x\n",ulUniqueness));
        }
        break;

    //**************************************************************************
    // Store Status of the NVSVC service.
    //**************************************************************************
    case IOCTL_VIDEO_SET_NVSVC_STATUS:
        {
            ULONG ulNVSVCStatus;
            status = NO_ERROR;

            if(RequestPacket->InputBufferLength < sizeof(ULONG))
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_SET_NVSVC_STATUS - ERROR_INSUFFICIENT_BUFFER\n"));
                //
                // Set the status to stopped to be safe.
                //
                hwDeviceExtension->ulNVSVCStatus = NVSVC_STATUS_STOPPED;
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
            ulNVSVCStatus = *(ULONG *)RequestPacket->InputBuffer;
            hwDeviceExtension->ulNVSVCStatus = ulNVSVCStatus;
            VideoDebugPrint((1, "ulNVSVCStatus stored: 0x%x\n",ulNVSVCStatus));
        }
        break;

    //**************************************************************************
    // Store Status of the NVSVC service.
    //**************************************************************************
    case IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK:
        {
            ULONG ulInduceModeChangeDeviceMask;
            status = NO_ERROR;

            if(RequestPacket->InputBufferLength < sizeof(ULONG))
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_SET_NVSVC_MODESET_DEVMASK - ERROR_INSUFFICIENT_BUFFER\n"));
                hwDeviceExtension->ulInduceModeChangeDeviceMask = 0;
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
            ulInduceModeChangeDeviceMask = *(ULONG *)RequestPacket->InputBuffer;
            hwDeviceExtension->ulInduceModeChangeDeviceMask = ulInduceModeChangeDeviceMask;
            VideoDebugPrint((1, "ulInduceModeChangeDeviceMask stored: 0x%x\n",ulInduceModeChangeDeviceMask));
        }
        break;

    //**************************************************************************
    // Signal the NVModesetEvent to invoke the NVSVC
    //**************************************************************************
    case IOCTL_VIDEO_SIGNAL_NVSVC_MODESET_EVENT:
        {
            VideoDebugPrint((1, "NVStartIO - SignalNVSVCModeSetEvent\n"));
            status = NO_ERROR;
            SignalModeSwitchEvent();
        }
        break;

    //*****************************************************************************
    // Signal the control panel thread to indicate a hotkey switch has taken place.
    //*****************************************************************************
    case IOCTL_VIDEO_SIGNAL_NVCPL_HOTKEY_EVENT:
        {
            VideoDebugPrint((1, "NVStartIO - SignalNVCplHotKeyEvent\n"));
            status = NO_ERROR;
            SignalNVCplHotKeyEvent();
        }
        break;


    //**************************************************************************
    // RESET_DEVICE
    //**************************************************************************

    case IOCTL_VIDEO_RESET_DEVICE:

        // Clean up virtual desktop flag.
        hwDeviceExtension->DeskTopInfo.ulDesktopMode = 0;

        VideoDebugPrint((2, "NVStartIO - Reset Device\n"));

        status = NO_ERROR;
        
#if (_WIN32_WINNT >= 0x0500)
        hwDeviceExtension->ulDualViewStatus &= ~DUALVIEW_STATUS_GRAPHICS_MODE;

        //
        // For DualView(MHS), we need to check whether the other view is in graphics mode.
        //
        if (hwDeviceExtension->pDualViewAssociatedDE)
        {
            //
            // If another display still in graphics mode, do nothing.
            //
            if (hwDeviceExtension->pDualViewAssociatedDE->ulDualViewStatus & DUALVIEW_STATUS_GRAPHICS_MODE)
            {
                break;
            }
        }
#endif

        // Call the RM to disable hot key functionality
        RmSetDriverHotkeyHandling(hwDeviceExtension->DeviceReference, FALSE);

        if(hwDeviceExtension->ulRmTurnedOffMonitor)
        {
            // PowerManagement turn off the monitor 
            // It is not necessary to call BIOS to reset the chip
            break;
        }

        //**********************************************************************
        // Because we're going to do a reset, we need to write current value
        // to registry.  Temporary fix, used to keep mobile scaling hotkey in
        // some sort of sync with registry.
        //**********************************************************************

        WriteFPModeToRegistry (hwDeviceExtension);
        
        //**********************************************************************
        // Must *NOT* call Int10 in a multiple adapter configuration
        //**********************************************************************

        if (MultiAdaptersPresent == FALSE)
            {
            //******************************************************************
            // Make sure that NV interrupts are disabled before we call Int10!!!
            // Otherwise, there may be conflicts writing to the hardware registers
            // (especially in an SMP system)
            //******************************************************************

            NV_DisableNVInterrupts(hwDeviceExtension);


#if _WIN32_WINNT < 0x0500

            //******************************************************************
            // For NT4, always use the bios to do the modeset.
            // SMP issue that used to reqire setting the text mode by hand
            // seems to be gone now.
            //******************************************************************

                status = RMVideoResetDevice(hwDeviceExtension->DeviceReference);
                if (status != NO_ERROR)
                    VideoDebugPrint((0, "NV: IOCTL_VIDEO_RESET_DEVICE FAILED\n"));

#else
            //******************************************************************
            // For Win2k, always use Int10
            //******************************************************************

            if(hwDeviceExtension->curAdapterPowerState == VideoPowerOn ||
                hwDeviceExtension->curAdapterPowerState == VideoPowerHibernate)
            {
                //FPMode needs to be saved/restored because of bios bug in nv11
                status = RMVideoResetDevice(hwDeviceExtension->DeviceReference);
                if (status != NO_ERROR)
                    VideoDebugPrint((0, "NV: IOCTL_VIDEO_RESET_DEVICE FAILED\n"));
            }
#endif

            //******************************************************************
            // Turn NV interrupts back on
            //******************************************************************

            NV_ReEnableNVInterrupts(hwDeviceExtension);
            }


        break;

    //**************************************************************************
    // SET_COLOR_REGISTERS
    //**************************************************************************

    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "NVStartIO - SetColorRegs\n"));

        status = NVSetColorLookup(hwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);


// Initialize this adapters CLUT to the requested gamma ramp
   {

      PVIDEO_CLUTDATA   pvcdItemSrc,pvcdItemDst;
      PVIDEO_CLUT       srcclut;
      ULONG index,item,NumEntries,FirstEntry;

      VideoDebugPrint((1, "IOCTL_VIDEO_SET_COLOR_REGISTERS - Saving gamma mods in gammacache\n"));

      // - Make things nice to look at
          pvcdItemSrc = &(((PVIDEO_CLUT)RequestPacket->InputBuffer)->LookupTable->RgbArray);
          pvcdItemDst = &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
      srcclut = (PVIDEO_CLUT)RequestPacket->InputBuffer;

      // - Set the limits on the item count
      NumEntries = srcclut->NumEntries;
      FirstEntry = srcclut->FirstEntry;

      // - Copy over the gamma data
      for(item = FirstEntry; item < NumEntries; item++) {
           index = item + FirstEntry;
           pvcdItemDst[index].Blue   = pvcdItemSrc[index].Blue;
           pvcdItemDst[index].Green  = pvcdItemSrc[index].Green;
           pvcdItemDst[index].Red    = pvcdItemSrc[index].Red;
           pvcdItemDst[index].Unused = pvcdItemSrc[index].Unused;
      }

    }

        break;

    //**************************************************************************
    // Enable the PIXMIX bits in NV_PRAMDAC_GENERAL_CONTROL
    //**************************************************************************
    case IOCTL_VIDEO_ENABLE_PIXMIX_INDEX:
            //
            //      Set PIXMIX bits to 11b
            //
            NV_SetPixMixBits(hwDeviceExtension);

            status = NO_ERROR;
            break;

    //**************************************************************************
    // ENABLE_VDM
    // Do we need to implement this call ??
    // We'll need to implement ResetDevice because we'll be using VgaCompatible=0
    //**************************************************************************

    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "NVStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalVgaValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;

    //**************************************************************************
    // Private IOCTLs established with the driver
    //**************************************************************************


    //**************************************************************************
    // GET_VIDEO_CARD_INFO
    // This call is unnecessary , we don't do banking
    //**************************************************************************

    case IOCTL_VIDEO_GET_VIDEO_CARD_INFO:

        VideoDebugPrint((2, "NVStartIO - Get video card info\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(VIDEO_COPROCESSOR_INFORMATION)) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        // return the Coproc Base Address.

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulChipID =
            hwDeviceExtension->ulChipID;

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulRevLevel =
            hwDeviceExtension->ulRevLevel;

        ((PVIDEO_COPROCESSOR_INFORMATION) RequestPacket->OutputBuffer)->ulVideoMemory =
            hwDeviceExtension->AdapterMemorySize;

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_MAP_IO_PORT_FOR_ALI:

        VideoDebugPrint((2, "NVStartIO - Map IO port for ALI\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }
        RequestPacket->StatusBlock->Information = sizeof(VIDEO_MEMORY_INFORMATION);


        memoryInformation = RequestPacket->OutputBuffer;
        memoryInformation->FrameBufferBase   = 0;
        memoryInformation->FrameBufferLength = FALSE;
        hwDeviceExtension->AliFixupIOBase    = NULL;

        //**********************************************************************
        // This code is ONLY necessary for the ALI 1541 chipset
        //**********************************************************************

        if (hwDeviceExtension->AliChipset_Problem_Found == TRUE)
            {
            //******************************************************************
            // Setup to map an IO register
            //******************************************************************

            AliFixupBaseAddress.HighPart = 0x00000000;
            AliFixupBaseAddress.LowPart  = 0x000003d0;
            IOLength            = 4;
            inIoSpace           = TRUE;
            AliVirtualAddress   = NULL;

            //******************************************************************
            // Map the IO port, and pass it back to the display driver
            //******************************************************************

            status = VideoPortMapMemory(hwDeviceExtension,
                                     AliFixupBaseAddress,
                                     &(IOLength),
                                     &(inIoSpace),
                                     &AliVirtualAddress);

            memoryInformation->FrameBufferBase   = AliVirtualAddress;
            memoryInformation->FrameBufferLength = TRUE;
            hwDeviceExtension->AliFixupIOBase    = AliVirtualAddress;
            }



        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_UNMAP_IO_PORT_FOR_ALI:

        VideoDebugPrint((2, "NVStartIO - Free mapping for IO port \n"));

        //**********************************************************************
        // This code is ONLY necessary for the ALI 1541 chipset
        //**********************************************************************

        if (hwDeviceExtension->AliChipset_Problem_Found == TRUE)
            {

            //******************************************************************
            // Free up the mapping for the IO port
            //******************************************************************

            if (hwDeviceExtension->AliFixupIOBase !=NULL)
                {
                status = VideoPortUnmapMemory(hwDeviceExtension,
                                         hwDeviceExtension->AliFixupIOBase,
                                         0);
                }

            hwDeviceExtension->AliFixupIOBase = NULL;
            }


        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_MAP_NV_PFIFO_USER:
        {
        PHYSICAL_ADDRESS            base, pa;
        ULONG                       length;

        VideoDebugPrint((2, "NVStartIO - Map PFIFO User\n"));

        if (RequestPacket->OutputBufferLength < sizeof(ULONG) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        //**********************************************************************
        // Return mapping to PFIFO registers in user address space
        //**********************************************************************

        virtualAddress = (PVOID)0L;

        //******************************************************************
        // Get physical base address again (since we modified it up above
        // for the PFIFO registers
        //******************************************************************

        base = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart;

        //**************************************************************
        // Call VideoPort to map the range for us
        //**************************************************************

        pa          = base;
        pa.HighPart = 0x00000000;
        pa.LowPart  += RangeOffsets[NV_PFIFO_INDEX].ulOffset;
        sharedViewSize = RangeOffsets[NV_PFIFO_INDEX].ulLength;

        NVMapPhysIntoUserSpace(pa, sharedViewSize, &virtualAddress);
        *(PVOID *)RequestPacket->OutputBuffer = virtualAddress;
        RequestPacket->StatusBlock->Information = sizeof(PVOID);

        status = NO_ERROR;

        }
        break;

    case IOCTL_VIDEO_UNMAP_NV_PFIFO_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        VideoDebugPrint((2, "NVStartIO - UnMap PFIFO User\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_UNMAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->pSystemMdl points to previously allocated MDL
        NvUnmapPhysFromUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        status = NO_ERROR;
        }
        break;

    case IOCTL_VIDEO_MAP_NV_PBUS_USER:
        {
        PHYSICAL_ADDRESS            base, pa;
        ULONG                       length;

        VideoDebugPrint((2, "NVStartIO - Map PBUS User\n"));

        if (RequestPacket->OutputBufferLength < sizeof(ULONG) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        //**********************************************************************
        // Return mapping to PBUS registers in user address space
        //**********************************************************************

        virtualAddress = (PVOID)0L;

        //******************************************************************
        // Get physical base address again (since we modified it up above
        // for the PBUS registers
        //******************************************************************

        base = hwDeviceExtension->NVAccessRanges[NV_PHYSICAL_BASE_ADDRESS].RangeStart;

        //**************************************************************
        // Call VideoPort to map the range for us
        //**************************************************************

        pa          = base;
        pa.HighPart = 0x00000000;
        pa.LowPart  += RangeOffsets[NV_PBUS_INDEX].ulOffset;
        sharedViewSize = RangeOffsets[NV_PBUS_INDEX].ulLength;

        NVMapPhysIntoUserSpace(pa, sharedViewSize, &virtualAddress);
        *(PVOID *)RequestPacket->OutputBuffer = virtualAddress;
        RequestPacket->StatusBlock->Information = sizeof(PVOID);

        status = NO_ERROR;

        }
        break;

    case IOCTL_VIDEO_UNMAP_NV_PBUS_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        VideoDebugPrint((2, "NVStartIO - UnMap PBUS User\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_UNMAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->pSystemMdl points to previously allocated MDL
        NvUnmapPhysFromUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        status = NO_ERROR;
        }
        break;

    case IOCTL_VIDEO_ENABLE_WRITE_COMBINING:

        VideoDebugPrint((2, "NVStartIO - VIDEO_ENABLE_WRITE_COMBINING\n"));

        //**********************************************************************
        // Set flags to enable fb write combining.
        //**********************************************************************
        hwDeviceExtension->flMapMemory |= VIDEO_MEMORY_SPACE_P6CACHE;
        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_GET_TV_CURSOR_ADJUST_INFO:

        VideoDebugPrint((2, "NVStartIO - Return TV cursor adjustment values\n"));

        if (RequestPacket->OutputBufferLength < sizeof(TV_CURSOR_ADJUST_INFO) )
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        //**********************************************************************
        // Return information about our DMA buffer
        //**********************************************************************

        RequestPacket->StatusBlock->Information = sizeof(TV_CURSOR_ADJUST_INFO);

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->MonitorType =
                                  hwDeviceExtension->NvInfo.Framebuffer.MonitorType;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Underscan_x =
                                  hwDeviceExtension->NvInfo.Framebuffer.Underscan_x;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Underscan_y =
                                  hwDeviceExtension->NvInfo.Framebuffer.Underscan_y;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Scale_x =
                                  hwDeviceExtension->NvInfo.Framebuffer.Scale_x;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->Scale_y =
                                  hwDeviceExtension->NvInfo.Framebuffer.Scale_y;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->FilterEnable =
                                  hwDeviceExtension->NvInfo.Framebuffer.FilterEnable;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->TVCursorMin =
                                  hwDeviceExtension->NvInfo.Dac.TVCursorMin;

        ((TV_CURSOR_ADJUST_INFO *)(RequestPacket->OutputBuffer))->TVCursorMax =
                                  hwDeviceExtension->NvInfo.Dac.TVCursorMax;

        status = NO_ERROR;

        break;

    //**************************************************************************
    // GET_IF09_VIDEO_SUPPORT
    //**************************************************************************

    case IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT:

        VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_IF09_VIDEO_SUPPORT\n"));

        //******************************************************************************
        // Should we support IF09 format video data?
        //******************************************************************************
        if (RequestPacket->OutputBufferLength  == sizeof(ULONG))
            {
            //******************************************************************************
            // return whether or IF09 format video data should be supported.
            //******************************************************************************
            *((ULONG *) RequestPacket->OutputBuffer) = hwDeviceExtension->bEnableIF09;
            RequestPacket->StatusBlock->Information = sizeof(ULONG);
            status = NO_ERROR;
            }
        else
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            }

        break;

    //**************************************************************************
    // GET_COMMON_DEVICE_INFO
    //**************************************************************************

    case IOCTL_VIDEO_GET_COMMON_DEVICE_INFO:

        VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_COMMON_DEVICE_INFO\n"));

        if (RequestPacket->OutputBufferLength  == sizeof(NV_COMMON_DEVICE_INFO))
        {
            NV_COMMON_DEVICE_INFO *pCommonDeviceInfo = (NV_COMMON_DEVICE_INFO *)RequestPacket->OutputBuffer;
            NV_OS_VERSION_INFO    *pOsVersionInfo    = &(pCommonDeviceInfo->OsVersionInfo);

            pCommonDeviceInfo->ulDeviceReference   = hwDeviceExtension->DeviceReference;
            pCommonDeviceInfo->ulEnableDualView    = 0;
            pCommonDeviceInfo->ulDualViewSecondary = 0;

            pOsVersionInfo->dwBuildType    = 0xffffffff;
            pOsVersionInfo->dwMajorVersion = 0xffffffff;
            pOsVersionInfo->dwMinorVersion = 0xffffffff;
            pOsVersionInfo->dwBuildNumber  = 0xffffffff;

#if _WIN32_WINNT >= 0x0500
            pCommonDeviceInfo->ulEnableDualView = (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_ENABLE_DUALVIEW) ? 1 : 0;
            pCommonDeviceInfo->ulDualViewSecondary = (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) ? 1 : 0;
            pOsVersionInfo->dwBuildType = PsGetVersion(&pOsVersionInfo->dwMajorVersion,
                                                       &pOsVersionInfo->dwMinorVersion,
                                                       &pOsVersionInfo->dwBuildNumber, NULL);
            pCommonDeviceInfo->SysMemInfo.SystemMemorySize   = hwDeviceExtension->SystemMemorySize;
            pCommonDeviceInfo->SysMemInfo.AgpAllocationLimit = hwDeviceExtension->AgpServices.AllocationLimit;
#endif

            RequestPacket->StatusBlock->Information = sizeof(NV_COMMON_DEVICE_INFO);
            status = NO_ERROR;
        }
        else
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        break;

    //**************************************************************************
    // GET_OGL_STENCIL_SWITCH
    //**************************************************************************

    case IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH:

        VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_OGL_STENCIL_SWITCH\n"));

        if (RequestPacket->OutputBufferLength  == sizeof(ULONG))
        {
            *((ULONG *) RequestPacket->OutputBuffer) = hwDeviceExtension->OglStencilSwitch;
            RequestPacket->StatusBlock->Information = sizeof(ULONG);
            status = NO_ERROR;
        }
        else
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }

        break;


    //**********************************************************************************
    // The following IOCTLs allow communication between the display driver and the RM
    //**********************************************************************************

    //****CHECK FOR ERROR_INSUFFICIENT_BUFFER here

    // MP/RM merge...

    // TO DO: remove open and close
    // open and close are here for compatibility
    case NVAPI_IOCTL_OPEN:
        status = NO_ERROR;
        break;

    case NVAPI_IOCTL_CLOSE:
        status = NO_ERROR;
        break;

    case IOCTL_NV01_ALLOC_ROOT:
        Nv01AllocRoot((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_DEVICE:
        Nv01AllocDevice((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_CONTEXT_DMA:
        Nv01AllocContextDma((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_CHANNEL_PIO:
        Nv01AllocChannelPio((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV03_ALLOC_CHANNEL_DMA:
        Nv03AllocChannelDma((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_MEMORY:
        Nv01AllocMemory((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_OBJECT:
        Nv01AllocObject((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ALLOC_EVENT:
        Nv01AllocEvent((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_ALLOC:
        Nv04Alloc((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_FREE:
        Nv01Free((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV03_DMA_FLOW_CONTROL:
        Nv03DmaFlowControl((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_ARCH_HEAP:
        Nv03ArchHeap((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_VERSION:
        Nv01ConfigVersion((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_GET:
        Nv01ConfigGet((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_SET:
        Nv01ConfigSet((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_CONFIG_GET_EX:
        Nv04ConfigGetEx((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_CONFIG_SET_EX:
        Nv04ConfigSetEx((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_CONFIG_UPDATE:
        Nv01ConfigUpdate((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV01_DEBUG_CONTROL:
        Nv01DebugControl((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

    case IOCTL_NV04_DIRECT_METHOD_CALL:
        Nv04DirectMethodCall((PVOID)(*(ULONG_PTR *)(RequestPacket->InputBuffer)));
        status = RequestPacket->StatusBlock->Status;
        break;

        //...jsw

    case IOCTL_NV04_I2C_ACCESS:
         {
            NVOS_I2C_ACCESS_PARAMS *i2cparams;

            i2cparams = (NVOS_I2C_ACCESS_PARAMS *)RequestPacket->InputBuffer;

            // Make sure that the data handed us is within limits
            if( (RequestPacket->InputBufferLength  < sizeof(NVOS_I2C_ACCESS_PARAMS)) ||
                (RequestPacket->OutputBufferLength < sizeof(NVOS_I2C_ACCESS_PARAMS)) ){

               status = ERROR_INSUFFICIENT_BUFFER;
               RequestPacket->StatusBlock->Information = 0;
            }
            else {

               // Have the RM help us with this one...
               Nv04I2CAccess((NVOS_I2C_ACCESS_PARAMS *)i2cparams);

               // Make sure that we only give back the right amount
               RequestPacket->StatusBlock->Information = sizeof(NVOS_I2C_ACCESS_PARAMS);
               status = NO_ERROR;
            }
         }
        break;


    //**************************************************************************
    // SYSMEM_SHARE_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_SYSMEM_SHARE_MEMORY:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_SYSMEM_SHARE_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        NvSystemMemoryShare(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;

        pSysmemShareMemoryOut->pSystemMdl       = pSysmemShareMemoryIn->pSystemMdl;
        pSysmemShareMemoryOut->physicalAddress  = pSysmemShareMemoryIn->physicalAddress;
        pSysmemShareMemoryOut->ddVirtualAddress = pSysmemShareMemoryIn->ddVirtualAddress;
        pSysmemShareMemoryOut->byteLength       = pSysmemShareMemoryIn->byteLength;
        pSysmemShareMemoryOut->bDontModifyMDL   = pSysmemShareMemoryIn->bDontModifyMDL;

        VideoDebugPrint((0, "SHARE: pSystemMdl = 0x%p\n",
                        pSysmemShareMemoryOut->pSystemMdl));
        VideoDebugPrint((0, "SHARE: physicalAddress = 0x%p\n",
                        pSysmemShareMemoryOut->physicalAddress));
        VideoDebugPrint((0, "SHARE: ddVirtualAddress = 0x%p\n",
                        pSysmemShareMemoryOut->ddVirtualAddress));
        VideoDebugPrint((0, "SHARE: bDontModifyMDL = 0x%p\n",
                        pSysmemShareMemoryOut->bDontModifyMDL));

        status = NO_ERROR;

        }
        break;

    //**************************************************************************
    // SYSMEM_UNSHARE_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_SYSMEM_UNSHARE_MEMORY:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn;

        if (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY))
            {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        VideoDebugPrint((0, "UNSHARE: pSystemMdl = 0x%p\n",
                        pSysmemShareMemoryIn->pSystemMdl));
        VideoDebugPrint((0, "UNSHARE: ddVirtualAddress = 0x%p\n",
                        pSysmemShareMemoryIn->ddVirtualAddress));
        VideoDebugPrint((0, "UNSHARE: bDontModifyMDL = 0x%p\n",
                        pSysmemShareMemoryIn->bDontModifyMDL));
        NvSystemMemoryUnShare(pSysmemShareMemoryIn);
        status = NO_ERROR;
        }
        break;

    //**************************************************************************
    // LOCK_DOWN_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_LOCK_DOWN_MEMORY:
        {
        NV_LOCK_DOWN_MEMORY *pLockdownMemoryIn = NULL;
        NV_LOCK_DOWN_MEMORY *pLockdownMemoryOut = NULL;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_LOCK_DOWN_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_LOCK_DOWN_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_LOCK_DOWN_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pLockdownMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_LOCK_DOWN_MEMORY);
        NvLockdownMemory(pLockdownMemoryIn);
        if (pLockdownMemoryIn->pMdl == NULL)
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_LOCK_DOWN_MEMORY - Fails lock - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pLockdownMemoryOut = RequestPacket->OutputBuffer;
        pLockdownMemoryOut->pMdl           = pLockdownMemoryIn->pMdl;
        pLockdownMemoryOut->virtualAddress = pLockdownMemoryIn->virtualAddress;
        pLockdownMemoryOut->byteLength     = pLockdownMemoryIn->byteLength;

        VideoDebugPrint((0, "LOCKDOWN: virtualAddress = 0x%p\n",
                        pLockdownMemoryOut->virtualAddress));
        VideoDebugPrint((0, "LOCKDOWN: pMdl = 0x%p\n",
                        pLockdownMemoryOut->pMdl));
        status = NO_ERROR;

        VideoDebugPrint((2, "W32StartIO - LockDownMemory Exit\n"));
        }
        break;

    //**************************************************************************
    // UNLOCK_MEMORY
    //**************************************************************************

    case IOCTL_VIDEO_UNLOCK_MEMORY:
        {
        NV_UNLOCK_MEMORY *pUnlockMemoryIn = NULL;
        NV_UNLOCK_MEMORY *pUnlockMemoryOut = NULL;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_UNLOCK_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_UNLOCK_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_UNLOCK_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }
        pUnlockMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_UNLOCK_MEMORY);
        NvUnlockMemory(pUnlockMemoryIn);
        pUnlockMemoryOut = RequestPacket->OutputBuffer;
        pUnlockMemoryOut->pMdl = pUnlockMemoryIn->pMdl;
        VideoDebugPrint((0, "UNLOCK: pMdl = 0x%p\n", pUnlockMemoryOut->pMdl));
        status = NO_ERROR;
        }
        break;

    //**************************************************************************
    // MAP_TO_USER
    //**************************************************************************

    case IOCTL_VIDEO_MAP_TO_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_MAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->ddVirtualAddress points to kernel address which may be locked down
        // pSysmemShareMemoryIn->byteLength points to length of kernel address memory
        NvMapIntoUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        pSysmemShareMemoryOut->userVirtualAddress = pSysmemShareMemoryIn->userVirtualAddress;
        pSysmemShareMemoryOut->physicalAddress    = pSysmemShareMemoryIn->physicalAddress;
        status = NO_ERROR;
        }
        break;

    //**************************************************************************
    // UNMAP_FROM_USER
    //**************************************************************************

    case IOCTL_VIDEO_UNMAP_FROM_USER:
        {
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryIn = NULL;
        NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemoryOut = NULL;
        PHYSICAL_ADDRESS        physAddr;

        if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ||
             (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) )
            {
            VideoDebugPrint((0, "IOCTL_VIDEO_MAP_TO_USER - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
            }

        pSysmemShareMemoryIn = RequestPacket->InputBuffer;
        RequestPacket->StatusBlock->Information = sizeof(NV_SYSMEM_SHARE_MEMORY);
        // pSysmemShareMemoryIn->pSystemMdl points to previously allocated MDL
        NvUnmapFromUserSpace(pSysmemShareMemoryIn);
        pSysmemShareMemoryOut = RequestPacket->OutputBuffer;
        status = NO_ERROR;
        }
        break;


#if (_WIN32_WINNT >= 0x0500)

    //**************************************************************************
    // NT5 only !
    // IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS
    //**************************************************************************

    case IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS:

        VideoDebugPrint((2, "NVStartIO - IOCTL Handle Video Parameters\n"));

        status = ERROR_INVALID_FUNCTION;
        
        if( (RequestPacket->InputBufferLength  == sizeof(VIDEOPARAMETERS) ) &&
            (RequestPacket->OutputBufferLength == sizeof(VIDEOPARAMETERS) ) )
        {
            VIDEOPARAMETERS * pInVideoParameters  = (VIDEOPARAMETERS *) RequestPacket->InputBuffer;
            VIDEOPARAMETERS * pOutVideoParameters = (VIDEOPARAMETERS *) RequestPacket->OutputBuffer;
            ULONG i, dwTemp;
            NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS nvEncoder;

            switch(pInVideoParameters->dwCommand)
            {
                case VP_COMMAND_GET:
                {
                    pOutVideoParameters->dwMode = VP_MODE_WIN_GRAPHICS;
                    pOutVideoParameters->dwFlags = 0;
                    pOutVideoParameters->dwTVStandard = 0;
            
                    for(i = 0; i < hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
                    {
                        if( (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_NTSC) ||
                            (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_PAL) )
                        {
                            pOutVideoParameters->dwFlags  = VP_FLAGS_TV_MODE;
                            pOutVideoParameters->dwFlags |= VP_FLAGS_TV_STANDARD;
                            if(hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_NTSC)
                            {
                                pOutVideoParameters->dwTVStandard = pOutVideoParameters->dwAvailableTVStandard 
                                    = VP_TV_STANDARD_NTSC_M;
                            }
                            else
                            {
                                pOutVideoParameters->dwTVStandard = pOutVideoParameters->dwAvailableTVStandard
                                    = VP_TV_STANDARD_PAL_B;
                            }

                            pOutVideoParameters->dwAvailableModes = VP_MODE_WIN_GRAPHICS;
            
                            pOutVideoParameters->dwFlags |= VP_FLAGS_MAX_UNSCALED;
                            pOutVideoParameters->dwMaxUnscaledX = hwDeviceExtension->DeskTopInfo.ulDisplayWidth[i];
                            pOutVideoParameters->dwMaxUnscaledY = hwDeviceExtension->DeskTopInfo.ulDisplayHeight[i];
            
                            pOutVideoParameters->dwFlags |= VP_FLAGS_POSITION;
                            pOutVideoParameters->dwPositionX = 0;
                            pOutVideoParameters->dwPositionY = 0;
            
                            pOutVideoParameters->dwCPType = 0;
                            pOutVideoParameters->dwCPStandard = 0;
            
                            nvEncoder.Head = i;
                            RmConfigGetExKernel(hwDeviceExtension->DeviceReference, NV_CFGEX_VIDEO_ENCODER_TYPE, &nvEncoder, sizeof(NV_CFGEX_VIDEO_ENCODER_TYPE));
                            switch(nvEncoder.EncoderType)
                            {
                                case NV_ENCODER_BROOKTREE_868:
                                case NV_ENCODER_CHRONTEL_7003:
                                case NV_ENCODER_CHRONTEL_7006:
                                case NV_ENCODER_CHRONTEL_7008:
                                    // Not macrovision support
                                    break;
                                default:
                                    // macrovision support
                                    pOutVideoParameters->dwFlags |= VP_FLAGS_COPYPROTECT;
                                    pOutVideoParameters->dwCPType = VP_CP_TYPE_APS_TRIGGER;
                                    pOutVideoParameters->bCP_APSTriggerBits = hwDeviceExtension->ulMacrovisionMode; 
                                    switch(hwDeviceExtension->DeskTopInfo.ulTVFormat[i])
                                    {
                                        case NTSC_M:
                                            dwTemp = VP_TV_STANDARD_NTSC_M;
                                        break;
                                        case NTSC_J:
                                            dwTemp = VP_TV_STANDARD_NTSC_M_J;
                                        break;
                                        case PAL_M:
                                            dwTemp = VP_TV_STANDARD_PAL_M;
                                        break;
                                        case PAL_A:
                                            dwTemp = VP_TV_STANDARD_PAL_B | VP_TV_STANDARD_PAL_D | VP_TV_STANDARD_PAL_G |
                                                 VP_TV_STANDARD_PAL_H | VP_TV_STANDARD_PAL_I;
                                        break;
                                        case PAL_N:
                                            dwTemp = VP_TV_STANDARD_PAL_N;
                                        break;
                                        case PAL_NC:
                                        default:
                                            dwTemp = VP_TV_STANDARD_WIN_VGA;
                                        break;
                                    }
                                    pOutVideoParameters->dwCPStandard = dwTemp;
                                    break;
                                break;
                            }
                            break;
                        } // if
                    } // for
                    RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
                    VideoDebugPrint((0, "NVStartIO - IOCTL Handle Video Parameters Get dwCommand \n"));
                    status = NO_ERROR;
                    break;
                }
                case VP_COMMAND_SET:
                {
                    if((pInVideoParameters->dwFlags  &  VP_FLAGS_COPYPROTECT) &&
                       (pInVideoParameters->dwCPType == VP_CP_TYPE_APS_TRIGGER) )
                    {
                        NV_CFGEX_SET_MACROVISION_MODE_PARAMS nvMacrovision;

                        memcpy((PUCHAR) pOutVideoParameters, (PUCHAR) pInVideoParameters, sizeof(VIDEOPARAMETERS));
                        for(i = 0; i < hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
                        {
                            if( (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_NTSC) ||
                                (hwDeviceExtension->DeskTopInfo.ulDeviceType[i] == MONITOR_TYPE_PAL) )
                            {
                                nvEncoder.Head = i;
                                RmConfigGetExKernel(hwDeviceExtension->DeviceReference, NV_CFGEX_VIDEO_ENCODER_TYPE, 
                                        &nvEncoder, sizeof(NV_CFGEX_VIDEO_ENCODER_TYPE));
                                switch(nvEncoder.EncoderType)
                                {
                                    case NV_ENCODER_BROOKTREE_868:
                                    case NV_ENCODER_CHRONTEL_7003:
                                    case NV_ENCODER_CHRONTEL_7006:
                                    case NV_ENCODER_CHRONTEL_7008:
                                    // Not macrovision support
                                        break;
                                    default:
                                        // macrovision support
                                        nvMacrovision.head = i;
                                        nvMacrovision.mode = pInVideoParameters->bCP_APSTriggerBits;
                                        nvMacrovision.resx = hwDeviceExtension->DeskTopInfo.ulDisplayWidth[i];
                                        nvMacrovision.resy = hwDeviceExtension->DeskTopInfo.ulDisplayHeight[i];
                                        switch(pInVideoParameters->dwCPCommand)
                                        {
                                            case VP_CP_CMD_ACTIVATE:
                                                if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                                     NV_CFGEX_SET_MACROVISION_MODE,
                                                     &nvMacrovision,
                                                     sizeof(NV_CFGEX_SET_MACROVISION_MODE_PARAMS))) 
                                                {
                                                    pOutVideoParameters->dwCPKey = hwDeviceExtension->ulCurrentMacrovisionKey 
                                                                                 = hwDeviceExtension->ulNextMacrovisionKey++;
                                                }
                                            break;
                                            case VP_CP_CMD_DEACTIVATE:
                                                if(pInVideoParameters->dwCPKey == hwDeviceExtension->ulCurrentMacrovisionKey)
                                                {
                                                    nvMacrovision.mode = 0;
                                                    if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                                         NV_CFGEX_SET_MACROVISION_MODE,
                                                         &nvMacrovision,
                                                         sizeof(NV_CFGEX_SET_MACROVISION_MODE_PARAMS))) 
                                                    {
                                                        // Disabled successfully
                                                    }
                                                    else
                                                    {
                                                        // Failed to disable it.
                                                    }
                                                }
                                            break;
                                            case VP_CP_CMD_CHANGE:
                                                if(pInVideoParameters->dwCPKey == hwDeviceExtension->ulCurrentMacrovisionKey)
                                                {
                                                    nvMacrovision.mode  = pInVideoParameters->bCP_APSTriggerBits & 0x03;
                                                    if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                                         NV_CFGEX_SET_MACROVISION_MODE,
                                                         &nvMacrovision,
                                                         sizeof(NV_CFGEX_SET_MACROVISION_MODE_PARAMS))) 
                                                    {
                                                        // changed successfully
                                                    }
                                                    else
                                                    {
                                                        // Failed to change it.
                                                    }
                                                }
                                            break;
                                        }
                                        RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
                                        hwDeviceExtension->ulMacrovisionMode = nvMacrovision.mode;
                                } // switch
                            } // if
                        } // for
                   } // if
                   status = NO_ERROR;
                    break; //  
                } // 
                default:
                    break;
             } // switch
        }
        break;

        case IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED:
            {
                if (hwDeviceExtension->bAgp)
                    status = NO_ERROR;
                else
                    status = ERROR_INVALID_FUNCTION;
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_ALLOC_AGP_MEM
        //**************************************************************************

        case IOCTL_VIDEO_ALLOC_AGP_MEM:
            {
            ULONG       cPages;
            PAGP_MEM    pBlock, pOutputBuffer;
            PVOID       VirtualAddress;
            VideoDebugPrint((2, "NVStartIO - IOCTL Alloc AGP Mem\n"));

            if ((RequestPacket->OutputBufferLength < sizeof(AGP_MEM)) ||
                 (RequestPacket->InputBufferLength < sizeof(AGP_MEM)))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_ALLOC_AGP_MEM - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }
            else if (!hwDeviceExtension->bAgp)
                {
                status = ERROR_INVALID_FUNCTION;
                break;
                }
            pBlock = (PAGP_MEM) (RequestPacket->InputBuffer);
            pOutputBuffer = (PAGP_MEM) (RequestPacket->OutputBuffer);
            cPages = ((pBlock->cb / PAGE_SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
            //
            // WARNING: The (ULONG_PTR) cast makes the warning go away, 
            //          but it is possible this is broken since hContext
            //          may not be big enough on 64 bit systems.
            //
            if (!(hwDeviceExtension->AgpVirtualBaseAddress =
                    VideoPortAgpReserveVirtual(
                        hwDeviceExtension,
                        (HANDLE)((ULONG_PTR)pBlock->hContext),
                        hwDeviceExtension->AgpPhysContext,
                        (PVOID *)(&(hwDeviceExtension->dummyVirtualContext)))))
                {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
                }
            *pOutputBuffer = *pBlock;
            if (!(pOutputBuffer->VirtualAddress =
                    VideoPortAgpCommitVirtual(
                        hwDeviceExtension,
                        hwDeviceExtension->dummyVirtualContext,
                        cPages, 0)))
                {
                VideoPortAgpReleaseVirtual(
                    hwDeviceExtension,
                    hwDeviceExtension->dummyVirtualContext);
                hwDeviceExtension->dummyVirtualContext = NULL;
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
                }
                RequestPacket->StatusBlock->Information = sizeof(AGP_MEM);
                status = NO_ERROR;
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_FREE_AGP_MEM
        //**************************************************************************

        case IOCTL_VIDEO_FREE_AGP_MEM:
            {
            PVOID       VirtualAddress;
            PAGP_MEM    pBlock;
            ULONG       cPages;

            VideoDebugPrint((2, "NVStartIO - IOCTL Free AGP Mem\n"));
            if (RequestPacket->InputBufferLength < sizeof(AGP_MEM))
                {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }
            else if (!hwDeviceExtension->bAgp)
                {
                status = ERROR_INVALID_FUNCTION;
                break;
                }
            pBlock = (PAGP_MEM) RequestPacket->InputBuffer;
            cPages = ((pBlock->cb / PAGE_SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
            VideoPortAgpFreeVirtual(
                hwDeviceExtension,
                hwDeviceExtension->dummyVirtualContext,
                cPages,
                (ULONG)((PUCHAR)pBlock->VirtualAddress - (PUCHAR)hwDeviceExtension->dummyVirtualContext)
            );
            VideoPortAgpReleaseVirtual(hwDeviceExtension,
                hwDeviceExtension->dummyVirtualContext);
            hwDeviceExtension->dummyVirtualContext = NULL;
            status = NO_ERROR;
            }
            break;

        ////// all VPE commands go thru here !
#ifdef NVPE
        case IOCTL_VIDEO_VPE_COMMAND:
            VideoDebugPrint((2, "NVStartIO - IOCTL Video Port Extension Command\n"));
            status = NVPEProcessCommand(hwDeviceExtension, RequestPacket);
            break;
#endif  // #ifdef NVPE
#endif  // _WIN32_WINNT >= 0x0500




        //****************************************************************************************************
        // IOCTL_VIDEO_SET_TWINVIEW_STATE
        // Sets the user selected state of Clone/Normal/Multimon.
        // Also sets the other pieces of info like DeviceType, Physical and virtual rectl for each head etc..
        //****************************************************************************************************

        case IOCTL_VIDEO_SET_TWINVIEW_STATE:
            {
                NVTWINVIEWDATA *pInfo;

                VideoDebugPrint((6, "IOCTL_VIDEO_SET_TWINVIEW_STATE():\n"));
                if(RequestPacket->InputBufferLength < sizeof(NVTWINVIEWDATA)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_SET_TWINVIEW_STATE(): Error: pInfo is wrong Size.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInfo = (NVTWINVIEWDATA *)(RequestPacket->InputBuffer);
                if (pInfo == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_SET_TWINVIEW_STATE(): Error: pInfo is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                status = NVSetRegistryTwinviewInfo(hwDeviceExtension, pInfo);
            }
            break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_TWINVIEW_STATE
        // Gets the user selected state of Clone/Normal/Multimon.
        // Also gets the other pieces of info like DeviceType, Physical and virtual rectl for each head etc..
        //****************************************************************************************************

        case IOCTL_VIDEO_GET_TWINVIEW_STATE:
            {
                NVTWINVIEWDATA *pInfo;

                VideoDebugPrint((6, "IOCTL_VIDEO_GET_TWINVIEW_STATE():\n"));
                if(RequestPacket->OutputBufferLength < sizeof(NVTWINVIEWDATA)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_TWINVIEW_STATE(): Error: pInfo is wrong Size.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInfo = (NVTWINVIEWDATA *)(RequestPacket->OutputBuffer);
                if (pInfo == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_TWINVIEW_STATE(): Error: pInfo is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                status = NVGetRegistryTwinviewInfo(hwDeviceExtension, pInfo);
                if (status != NO_ERROR)
                {
                    VideoPortZeroMemory(pInfo, sizeof(NVTWINVIEWDATA));
                    pInfo->dwState = hwDeviceExtension->DeskTopInfo.ulTwinView_State;
                }
                RequestPacket->StatusBlock->Information = sizeof(NVTWINVIEWDATA);
                status = NO_ERROR;
            }
            break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_PCI_NUMBER
        //****************************************************************************************************
        case IOCTL_VIDEO_QUERY_PCI_SLOT:
        {
            ULONG * pulTemp;

            status = NO_ERROR;
            if(RequestPacket->OutputBufferLength < sizeof(ULONG)) 
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_QUERY_PCI_SLOT(): Error: pInfo is wrong Size.\n"));
                status = ERROR_INVALID_PARAMETER;
                break;
            }
            pulTemp = (ULONG *)(RequestPacket->OutputBuffer);

            *pulTemp = hwDeviceExtension->ulSlot; 

            if (status == NO_ERROR)
                RequestPacket->StatusBlock->Information = sizeof(ULONG);
            else
                RequestPacket->StatusBlock->Information = 0;

        }
        break;

        //****************************************************************************************************
        // IOCTL_VIDEO_GET_NUMBER_DACS_ON_BOARD
        // Gets the number of DACS on the board
        //****************************************************************************************************

        case IOCTL_VIDEO_GET_NUMBER_DACS:
            {
                GET_NUMBER_DACS *pInfo;
                NV_DESKTOP_INFO *pDeskTopInfo;
                ULONG i, Count = 0;

                VideoDebugPrint((6, "IOCTL_VIDEO_GET_NUMBER_DACS():\n"));

                status = NO_ERROR;
                if(RequestPacket->OutputBufferLength < sizeof(GET_NUMBER_DACS)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_NUMBER_DACS(): Error: pInfo is wrong Size.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInfo = (GET_NUMBER_DACS *)(RequestPacket->OutputBuffer);
                if (pInfo == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_NUMBER_DACS(): Error: pInfo is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                // Extract the info from the hwDeviceExtension.
                pDeskTopInfo = (NV_DESKTOP_INFO *)&hwDeviceExtension->DeskTopInfo;

                // Stuff the info to send back to the display driver.
                pInfo->ulNumberDacsOnBoard = pDeskTopInfo->ulNumberDacsOnBoard;
                pInfo->ulNumberDacsConnected = pDeskTopInfo->ulNumberDacsConnected;
                pInfo->ulAllDeviceMask = pDeskTopInfo->ulAllDeviceMask;
                pInfo->ulConnectedDeviceMask = pDeskTopInfo->ulConnectedDeviceMask;
                pInfo->Mobile = hwDeviceExtension->Mobile;
                pInfo->UseHWSelectedDevice = hwDeviceExtension->UseHWSelectedDevice;
                pInfo->GDIModePruning = hwDeviceExtension->GDIModePruning;
                pInfo->UseHotKeySameMode = hwDeviceExtension->UseHotKeySameMode;
                pInfo->PanScanSelection = hwDeviceExtension->PanScanSelection;
                pInfo->ulDFPSupports1400x1050 = hwDeviceExtension->ulDFPSupports1400x1050;
                pInfo->ulHotKeyPending = hwDeviceExtension->ulHotKeyPending;
                pInfo->ulUniquenessVGA = hwDeviceExtension->ulUniquenessVGA;
                pInfo->ACPISystem = hwDeviceExtension->ACPISystem;

                for (i=0; i < pDeskTopInfo->ulNumberDacsOnBoard; i++)
                {
                    pInfo->ulDeviceMask[i] = pDeskTopInfo->ulDeviceMask[i];
                    pInfo->ulDeviceDisplay[i] = pDeskTopInfo->ulDeviceDisplay[i];
                    pInfo->ulDeviceType[i] = pDeskTopInfo->ulDeviceType[i];
                    pInfo->ulTVFormat[i] = pDeskTopInfo->ulTVFormat[i];
                    pInfo->ulHeadDeviceOptions[i] = pDeskTopInfo->ulHeadDeviceOptions[i];
                }


                VideoDebugPrint((3,"IOCTL_GET_NUMBER_DACS: Number of heads on board returning to display driver: 0x%x, number connected: 0x%x\n",
                    pInfo->ulNumberDacsOnBoard,pInfo->ulNumberDacsConnected));

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(GET_NUMBER_DACS);
                else
                    RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING:
            {
                VideoDebugPrint((1, "IOCTL_VIDEO_INDUCE_HEAD_DEVICE_SCANNING():\n"));
                status = NO_ERROR;
#if _WIN32_WINNT >= 0x0500
                if (hwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_SECONDARY) {
                    hwDeviceExtension = hwDeviceExtension->pDualViewAssociatedDE;
                }
#endif
                bScanHeadDeviceOptions(hwDeviceExtension);
                RequestPacket->StatusBlock->Information = 0;
#if _WIN32_WINNT >= 0x0500
                //******************************************************************
                // bScanHeadDeviceOptions has updated ulConnectedDeviceMask, so now's a good time to
                // have our NVGetChildDescriptor callback run (triggerd by VideoPortEnumerateChildren).
                // This allows new ACPI HwIds to be passed to VALIDATE/SET_CHILD_STATE_CONFIGURATION
                //******************************************************************
                VideoPortEnumerateChildren(hwDeviceExtension, NULL);
#endif // _WIN32_WINNT >= 0x0500
            }
            break;

    case IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE:
            {
                VideoDebugPrint((1, "IOCTL_VIDEO_INDUCE_TIMING_OVERRIDE():\n"));
                status = NO_ERROR;
                SetTimingOverRide(hwDeviceExtension);
                RequestPacket->StatusBlock->Information = 0;
            }
            break;


        //****************************************************************************************************
        // IOCTL_VIDEO_GET_PHYSICAL_MODE_LIST
        // Returns the number and list of physical modes for the specified head.
        // Input is the list of virtual modes for that head (no doubled resolutions but single screen resolutions)
        //****************************************************************************************************

        case IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST:
            {
                HEAD_MODE_LIST_INFO *pInput, *pOutput;
                ULONG ulRet, ulRetSize;
                

                VideoDebugPrint((6, "IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST():\n"));
                status = NO_ERROR;
                
                if(RequestPacket->InputBufferLength < sizeof(HEAD_MODE_LIST_INFO)) 
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST(): Error: InputBufferLength is wrong Size: 0x%x\n",
                        RequestPacket->InputBufferLength));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                pInput = (HEAD_MODE_LIST_INFO *)(RequestPacket->InputBuffer);
                
                if (pInput == NULL)
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST(): Error: pInput is NULL.\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }
                


                ulRetSize = 0;
                ulRet = GetHeadPhysicalModeList(hwDeviceExtension, 
                            pInput, &ulRetSize);

                if (ulRet == FALSE)
                {
                    status = ERROR_INVALID_PARAMETER;
                }


                VideoDebugPrint((3,"IOCTL_VIDEO_GET_HEAD_PHYSICAL_MODE_LIST: Number of PhysicalModes for head: %d returned is: %d\n",
                    pInput->ulHead, (ulRetSize/sizeof(MODE_ENTRY))));

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = ulRetSize;
                else
                    RequestPacket->StatusBlock->Information = 0;
            }
            break;



        //**************************************************************************
        // IOCTL_VIDEO_SET_REGISTRY_VALUE
        // Sets a registry value.
        // Supports only DWORD entries right now.
        //**************************************************************************

        case IOCTL_VIDEO_SET_REGISTRY_VALUE:
            {
                PNV_REGISTRY_STRUCT pRegStruct;

                pRegStruct = (PNV_REGISTRY_STRUCT)(RequestPacket->InputBuffer);

                status = VideoPortSetRegistryParameters(hwDeviceExtension,
                                       pRegStruct->keyName,
                                       pRegStruct->keyVal,
                                       pRegStruct->keyValSize);
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_GET_REGISTRY_PATH
        // Queries a registry path.
        //**************************************************************************
        case IOCTL_VIDEO_GET_REGISTRY_PATH:
            {
                if (strlen(hwDeviceExtension->DriverRegPath) > RequestPacket->OutputBufferLength)
                    status = ERROR_INVALID_PARAMETER;
                else
                {
                    strcpy((PUCHAR)(RequestPacket->OutputBuffer), hwDeviceExtension->DriverRegPath);
                    RequestPacket->StatusBlock->Information = strlen(hwDeviceExtension->DriverRegPath);
                    status = NO_ERROR;
                }
            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_QUERY_REGISTRY_VAL
        // Queries a registry value.
        // We support only DWORD entries right now.
        //**************************************************************************

        case IOCTL_VIDEO_QUERY_REGISTRY_VAL:
            {
                PWSTR     regKeyName;
                PVOID     regValData;

                regKeyName = (PWSTR)(RequestPacket->InputBuffer);
                regValData = (PVOID)(RequestPacket->OutputBuffer);

                status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                       regKeyName,
                                       FALSE,
                                       NVRegistryCallback,
                                       regValData);
                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(ULONG);
                else
                    RequestPacket->StatusBlock->Information = 0;

            }
            break;

        //**************************************************************************
        // IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL
        // Queries a Binary registry value.
        //**************************************************************************

        case IOCTL_VIDEO_QUERY_REGISTRY_BINARY_VAL:
            {
                PWSTR     regKeyName;
                PNV_REGISTRY_STRUCT pRegStructInput;
                NV_REGISTRY_STRUCT  RegStruct;
                PVOID pOutput;
                ULONG OutputLength;
                
                pRegStructInput = (PNV_REGISTRY_STRUCT)(RequestPacket->InputBuffer);
                regKeyName = (PWSTR)(pRegStructInput->keyName);
                pOutput = (PVOID)(RequestPacket->OutputBuffer);
                OutputLength = (ULONG)(RequestPacket->OutputBufferLength);
                
                // Copy the required values into the input structure
                // Note that the OS preserves/restores the content of the  the 
                RegStruct.keyVal = pOutput;
                RegStruct.keyValSize = OutputLength;
                RegStruct.keyName = regKeyName;

                status = VideoPortGetRegistryParameters(hwDeviceExtension,
                                       regKeyName,
                                       FALSE,
                                       NVReadRegistryBinaryCallback,
                                       (PVOID)&RegStruct);
                if (status == NO_ERROR)
                {
                    RequestPacket->StatusBlock->Information = RegStruct.keyValSize;
                }
                else
                {
                    RequestPacket->StatusBlock->Information = 0;
                }
            }
            break;

#if (_WIN32_WINNT >= 0x0500)

#ifdef NV_ZW_FILE_IO_ENABLED
        //**************************************************************************
        // IOCTL_VIDEO_ZW_XXX
        // Wrappers for the Zw file IO functions.
        //**************************************************************************

        case IOCTL_VIDEO_ZW_CREATE_FILE:
            {
                PNV_ZW_CREATE_FILE_IN pZwCreateFileIn = (PNV_ZW_CREATE_FILE_IN)RequestPacket->InputBuffer;
                IO_STATUS_BLOCK IoBlock;
                PVOID hFile;
                PVOID *phFileOutput = RequestPacket->OutputBuffer;

                status = ZwCreateFile( &hFile,
                                       pZwCreateFileIn->ulDesiredAccess,
                                       &pZwCreateFileIn->ObjectAttributes,
                                       &IoBlock,
                                       &pZwCreateFileIn->liAllocationSize,
                                       pZwCreateFileIn->ulFileAttributes,
                                       pZwCreateFileIn->ulShareAccess,
                                       pZwCreateFileIn->ulCreateDisposition,
                                       pZwCreateFileIn->ulCreateOptions,
                                       pZwCreateFileIn->pvEaBuffer,
                                       pZwCreateFileIn->ulEaLength );

    

                if (status == NO_ERROR)
                {
                    *phFileOutput = hFile;
                    RequestPacket->StatusBlock->Information = sizeof(hFile);
                }
                else
                {
                    *phFileOutput = NULL;
                    RequestPacket->StatusBlock->Information = 0;
                }

            }
            break;

        case IOCTL_VIDEO_ZW_WRITE_FILE:
            {
                PNV_ZW_RW_FILE_IN pZwWriteFileIn = (PNV_ZW_RW_FILE_IN)RequestPacket->OutputBuffer;
                IO_STATUS_BLOCK IoBlock;

                status = ZwWriteFile( pZwWriteFileIn->pvFileHandle,
                                      pZwWriteFileIn->pvEvent,
                                      pZwWriteFileIn->pvApcRoutine,
                                      pZwWriteFileIn->pvApcContext,
                                      &IoBlock,
                                      pZwWriteFileIn->pvBuffer,
                                      pZwWriteFileIn->ulLength,
                                      &pZwWriteFileIn->liByteOffset,
                                      pZwWriteFileIn->pvKey );

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(ULONG);
                else
                    RequestPacket->StatusBlock->Information = 0;

            }
            break;

        case IOCTL_VIDEO_ZW_READ_FILE:
            {
                PNV_ZW_RW_FILE_IN pZwReadFileIn = (PNV_ZW_RW_FILE_IN)RequestPacket->OutputBuffer;
                IO_STATUS_BLOCK IoBlock;

                status = ZwReadFile( pZwReadFileIn->pvFileHandle,
                                     pZwReadFileIn->pvEvent,
                                     pZwReadFileIn->pvApcRoutine,
                                     pZwReadFileIn->pvApcContext,
                                     &IoBlock,
                                     pZwReadFileIn->pvBuffer,
                                     pZwReadFileIn->ulLength,
                                     &pZwReadFileIn->liByteOffset,
                                     pZwReadFileIn->pvKey );

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = pZwReadFileIn->ulLength;
                else
                    RequestPacket->StatusBlock->Information = 0;

            }
            break;

        case IOCTL_VIDEO_ZW_CLOSE_HANDLE:
            {
                PVOID *phFile = RequestPacket->InputBuffer;
                status = ZwClose( *phFile );

                if (status == NO_ERROR)
                    RequestPacket->StatusBlock->Information = sizeof(ULONG);
                else
                    RequestPacket->StatusBlock->Information = 0;

            }
            break;

        case IOCTL_VIDEO_CONTROL_DEVICE:
            {
                PNV_ZW_DEVICE_IO_CONTROL_FILE pControlDevice = (PNV_ZW_DEVICE_IO_CONTROL_FILE)RequestPacket->InputBuffer;
                IO_STATUS_BLOCK IoBlock;

                status = ZwDeviceIoControlFile( pControlDevice->hDevice,
                                                NULL,
                                                NULL,
                                                NULL,
                                                &IoBlock,
                                                pControlDevice->ulIoControlCode,
                                                pControlDevice->pvInputBuffer,
                                                pControlDevice->ulInputBufferSize,
                                                RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength );

                if( status == NO_ERROR )
                    RequestPacket->StatusBlock->Information = RequestPacket->OutputBufferLength;
                else
                    RequestPacket->StatusBlock->Information = 0ul;
            }
            break;

        case IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS:
            {
                PNV_ZW_FILE_IO_FUNCS pFuncs = (PNV_ZW_FILE_IO_FUNCS)RequestPacket->OutputBuffer;

                pFuncs->pvZwCreateFile = (LPNVZWCREATEFILEFUNCTION)ZwCreateFile;
                pFuncs->pvZwWriteFile = (LPNVZWWRITEFILEFUNCTION)ZwWriteFile;
                pFuncs->pvZwReadFile = (LPNVZWREADFILEFUNCTION)ZwReadFile;
                pFuncs->pvZwClose = (LPNVZWCLOSEFUNCTION)ZwClose;
                pFuncs->pvZwDeviceIoControlFile = (LPNVZWDEVICEIOCONTROLFILEFUNCTION)ZwDeviceIoControlFile;

                status = NO_ERROR;
                RequestPacket->StatusBlock->Information = sizeof(NV_ZW_FILE_IO_FUNCS);
            }
            break;

#else

        case IOCTL_VIDEO_ZW_CREATE_FILE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_CREATE_FILE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_ZW_WRITE_FILE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_WRITE_FILE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_ZW_READ_FILE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_READ_FILE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_ZW_CLOSE_HANDLE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_CLOSE_HANDLE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_CONTROL_DEVICE:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_CONTROL_DEVICE not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;

        case IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS:
            {
                VideoDebugPrint((0, "IOCTL_VIDEO_ZW_GET_FILE_IO_FUNCS not enabled.\n"));
                VideoDebugPrint((0, "  miniport must be built with NV_ZW_FILE_IO_ENABLED defined \n"));
                status = ERROR_INVALID_FUNCTION;
                RequestPacket->StatusBlock->Information = 0;
            }
            break;
#endif

#endif // (_WIN32_WINNT >= 0x0500)


      // Sets a Display value ( vga, fp or tv, and tv type: ntsc or pal) in the registry
      case IOCTL_VIDEO_SET_DISPLAY_DEVICE:
         {
            NV_CFGEX_SET_DISPLAY_TYPE_PARAMS sdtp;
            PSETGETDEVTYPE sgdt;
            BOOL  ValidParams;

            if(RequestPacket->InputBufferLength < sizeof(SETGETDEVTYPE)) {
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               sgdt = (PSETGETDEVTYPE)RequestPacket->InputBuffer;
               VideoDebugPrint((2, "NVStartIO - SetDisplayDevice\n"));

               switch(sgdt->dwDeviceType) {
                  case 0:     // NV_DISPLAY_TYPE_VGA
                     sdtp.Type = DISPLAY_TYPE_MONITOR;
                     sdtp.TVType = 0;  // Play it safe
                     ValidParams = TRUE;
                     break;
                  case 2:     // NV_DISPLAY_TYPE_TV_NTSC
                     sdtp.Type = DISPLAY_TYPE_TV;
                     sdtp.TVType = sgdt->dwTvFormat;
                     ValidParams = TRUE;
                     break;
                  case 3:     // NV_DISPLAY_TYPE_TV_PAL
                     sdtp.Type = DISPLAY_TYPE_TV;
                     sdtp.TVType = sgdt->dwTvFormat;
                     ValidParams = TRUE;
                     break;
                  case 4:     // NV_DISPLAY_TYPE_FLAT_PANEL
                     sdtp.Type = DISPLAY_TYPE_FLAT_PANEL;
                     sdtp.TVType = 0;  // Play it safe
                     ValidParams = TRUE;
                     break;
                  default: // ?
                     ValidParams = FALSE;
                     break;
               }

               // - If all of the params are cool, attempt the settings
               if(ValidParams) {

                  VideoDebugPrint((1, "IOCTL_VIDEO_SET_DISPLAY_DEVICE: Type: %d, TVType: %d\n",sdtp.Type,sdtp.TVType));

                  // - Go set the values in the registry
                  if(RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                         NV_CFGEX_SET_DISPLAY_TYPE,
                                         &sdtp,
                                         sizeof(NV_CFGEX_SET_DISPLAY_TYPE_PARAMS))) {

                     // The Rm call seems to have succeded
                     status = NO_ERROR;
                  }
                  else {

                     VideoDebugPrint((1, "IOCTL_VIDEO_SET_DISPLAY_DEVICE: RmConfigSetExKernel failed\n"));
                     status = ERROR_INVALID_PARAMETER;   // This is not correct, but the other error codes are
                                                         // just as incorrect!
                  }

                  // - Nothing to return to the caller
                  RequestPacket->StatusBlock->Information = 0;

               }
               else {

                  VideoDebugPrint((1, "IOCTL_VIDEO_SET_DISPLAY_DEVICE: The parameters were in error.\n"));
                  // - Wrap up IOCTL control info for failure
                  status = ERROR_INVALID_PARAMETER;
               }
            }
         }
         break;


      // Gets a Display value ( vga, fp or tv, and tv type: ntsc or pal) from the registry
      case IOCTL_VIDEO_GET_DISPLAY_DEVICE:
         {

            NV_CFGEX_GET_DISPLAY_TYPE_PARAMS sdtp;
            PSETGETDEVTYPE sgdt;
            BOOL  ValidRegData;

            if(RequestPacket->OutputBufferLength < sizeof(SETGETDEVTYPE)) {
               status = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

               VideoDebugPrint((2, "NVStartIO - GetDisplayDevice\n"));
               sgdt = (PSETGETDEVTYPE)RequestPacket->OutputBuffer;
               status = NO_ERROR;

               // - Go get the values in the registry
               ValidRegData = FALSE;
               if(RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                      NV_CFGEX_GET_DISPLAY_TYPE,
                                      &sdtp,
                                      sizeof(NV_CFGEX_GET_DISPLAY_TYPE_PARAMS))) {
                  ValidRegData = TRUE;
               }

               if(ValidRegData) {

                  // - Update the values in the passed in buffer
                  switch(sdtp.Type) {

                     case DISPLAY_TYPE_MONITOR:
                        sgdt->dwDeviceType = 0; // NV_DISPLAY_TYPE_VGA
                        sgdt->dwTvFormat = 0;
                        sgdt->dwSuccessFlag = TRUE;
                        break;

                     case DISPLAY_TYPE_TV:
                        switch(sdtp.TVType) {
                           case 0: // NV_REG_TVFORMAT_NTSCM
                           case 1: // NV_REG_TVFORMAT_NTSCJ
                              sgdt->dwDeviceType = 2; // NV_DISPLAY_TYPE_TV_NTSC
                              sgdt->dwTvFormat = sdtp.TVType;
                              sgdt->dwSuccessFlag = TRUE;
                              break;
                           case 2: // NV_REG_TVFORMAT_PALM
                           case 3: // NV_REG_TVFORMAT_PALB
                           case 4: // NV_REG_TVFORMAT_PALN
                           case 5: // NV_REG_TVFORMAT_PALNC
                              sgdt->dwDeviceType = 3; // NV_DISPLAY_TYPE_TV_PAL
                              sgdt->dwTvFormat = sdtp.TVType;
                              sgdt->dwSuccessFlag = TRUE;
                              break;
                           default:
                              sgdt->dwDeviceType = 2; // Make this NTSC just in case someone does not pay attention
                              sgdt->dwTvFormat = 0;
                              sgdt->dwSuccessFlag = FALSE;
                              break;
                        }
                        break;

                     case DISPLAY_TYPE_FLAT_PANEL: // NV_DISPLAY_TYPE_FLAT_PANEL
                        sgdt->dwDeviceType = 4;
                        sgdt->dwTvFormat = 0;
                        sgdt->dwSuccessFlag = TRUE;
                        break;


                     default:
                        sgdt->dwDeviceType = 0; // NV_DISPLAY_TYPE_VGA
                        sgdt->dwTvFormat = 0;
                        sgdt->dwSuccessFlag = TRUE;
                        break;
                  }
               }
               else {   // Data in reg not avail, so return faliure
                     sgdt->dwDeviceType = 0;
                     sgdt->dwTvFormat = 0;
                     sgdt->dwSuccessFlag = FALSE;
               }

               // - Wrap up IOCTL control info
               RequestPacket->StatusBlock->Information = sizeof(SETGETDEVTYPE);
               status = NO_ERROR;

            }
         }
         break;

     case IOCTL_VIDEO_GET_TV_ENCODER_TYPE:
         {
            NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS TVInfo;
            VideoDebugPrint((2, "NVStartIO -  IOCTL_VIDEO_GET_TV_ENCODER_TYPE\n"));
            if ( RequestPacket->OutputBufferLength < sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS) )
            {
                status = ERROR_INVALID_PARAMETER;
            }
            else
            {
                TVInfo.Head        = 0;
                TVInfo.EncoderID   = hwDeviceExtension->ulTVEncoderID;
                TVInfo.EncoderType = hwDeviceExtension->ulTVEncoderType;

                // We have a valid blob from the resman, so extract the encoder info
                VideoDebugPrint((2,"From RM: TVEncoderType = 0x%x, TVEncoderID = 0x%x\n",TVInfo.EncoderType,TVInfo.EncoderID));
                *((NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS*)RequestPacket->OutputBuffer) = TVInfo;
                RequestPacket->StatusBlock->Information = sizeof(NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS);
                status = NO_ERROR;
            }
         }
         break;

      // - NV_ESC_VALIDATE_DEVICE_MODE path into the miniport
      case IOCTL_VALIDATE_DEVICE_MODE:
         {

            BOOL  ValidParams;
            VALMODEXTR *vmx;

            if( (RequestPacket->InputBufferLength < sizeof(VALMODEXTR)) ||
                (RequestPacket->OutputBufferLength < sizeof(ULONG)) ){
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               vmx = (VALMODEXTR *)RequestPacket->InputBuffer;
               VideoDebugPrint((1, "NVStartIO - ValidateDeviceMode\n"));
               VideoDebugPrint((1, "NVStartIO -   dwHRes = %ld\n",vmx->dwHRes));
               VideoDebugPrint((1, "NVStartIO -   dwVRes = %ld\n",vmx->dwVRes));
               VideoDebugPrint((1, "NVStartIO -   dwBpp = %ld\n",vmx->dwBpp));
               VideoDebugPrint((1, "NVStartIO -   dwRefresh = %ld\n",vmx->dwRefresh));
               VideoDebugPrint((1, "NVStartIO -   dwDeviceType = %ld\n",vmx->dwDeviceType));

               ValidParams = TRUE;

               // - If all of the params are cool, attempt the validate mode function
               if(ValidParams) {

                  // - Go set the values in the device context, no error checking for now...
                  if(NVValidateDeviceMode(hwDeviceExtension, vmx)) {

                     // - That mode is VALID for this device
                     *(ULONG *)RequestPacket->OutputBuffer = TRUE;
                  }
                  else {

                     // - That mode is NOT VALID for this device
                     *(ULONG *)RequestPacket->OutputBuffer = FALSE;
                  }

                  RequestPacket->StatusBlock->Information = sizeof(ULONG);
                  status = NO_ERROR;

               }
               else {
                  RequestPacket->StatusBlock->Information = 0;
                  status = ERROR_INVALID_PARAMETER;
               }
            }
         }
         break;


      // - This next one seems like a lot of work for nothing, but is keeps it comp with 9x for now
      case IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER:
         {

            if(RequestPacket->OutputBufferLength < sizeof(ULONG)) {
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_IS_NVIDIA_BOARD_AND_DRIVER\n"));

               // - We use the device reference + 1
               *(ULONG *)RequestPacket->OutputBuffer = hwDeviceExtension->DeviceReference + 1;
               RequestPacket->StatusBlock->Information = sizeof(ULONG);
               status = NO_ERROR;

            }
         }
         break;

      // - This IOCTL return the current gamma cache clut stored in the device extension
      case IOCTL_VIDEO_GET_GAMMA_CLUT:
         {

            if(RequestPacket->OutputBufferLength != MAX_CLUT_SIZE) {
               status = ERROR_INVALID_PARAMETER;
            }
            else {

               VideoDebugPrint((2, "NVStartIO - IOCTL_VIDEO_GET_GAMMA_CLUT\n"));

               status = NVGetColorLookup(hwDeviceExtension,
                                         (PVIDEO_CLUT)RequestPacket->OutputBuffer,
                                         RequestPacket->OutputBufferLength );

               RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE;

            }
         }
         break;
         
        
        //**************************************************************************
        // Save/Restore the Gamma values for the mode switching.
        //**************************************************************************
        case IOCTL_VIDEO_SAVE_GAMMA_VALUES:
            if(RequestPacket->InputBufferLength != sizeof(hwDeviceExtension->GammaCacheData)) 
            {
                status = ERROR_INVALID_PARAMETER;
            }
            else 
            {
                ULONG i;
                ULONG * pGammaCache;
                ULONG * pCallerBuffer;
                
                pGammaCache = (ULONG *) &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
                pCallerBuffer = (ULONG *) RequestPacket->InputBuffer;
                
                for(i = 0; i < sizeof(hwDeviceExtension->GammaCacheData) / sizeof(ULONG); i++)
                {
                    *pGammaCache++ = *pCallerBuffer++;
                }
                status = NO_ERROR;
            }
            break;
            
        case IOCTL_VIDEO_RESTORE_GAMMA_VALUES:
            if(RequestPacket->OutputBufferLength != sizeof(hwDeviceExtension->GammaCacheData)) 
            {
                status = ERROR_INVALID_PARAMETER;
            }
            else 
            {
                ULONG i;
                ULONG * pGammaCache;
                ULONG * pCallerBuffer;
                
                pGammaCache = (ULONG *) &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
                pCallerBuffer = (ULONG *) RequestPacket->OutputBuffer;
                
                for(i = 0; i < sizeof(hwDeviceExtension->GammaCacheData) / sizeof(ULONG); i++)
                {
                    *pCallerBuffer++ = *pGammaCache++;
                }
                status = NO_ERROR;
                RequestPacket->StatusBlock->Information =sizeof(hwDeviceExtension->GammaCacheData);
            }
            break;
        //**************************************************************************
        // CONVERT_RING3_HANDLE
        // Converts a ring3 handle to a ring0 handle
        //**************************************************************************

        case IOCTL_CONVERT_RING3_HANDLE:
            {
            HANDLE** input = (HANDLE**) RequestPacket->InputBuffer;

            status = NVObReferenceObjectByHandle(*(input[0]), input[1]);
            }
            break;

        //**************************************************************************
        // MAP_PHYS_ADDR
        //**************************************************************************

        case IOCTL_VIDEO_MAP_PHYS_ADDR:
            {
            NV_SYSMEM_SHARE_MEMORY  *pShareMemory, *pShareMemoryInformation;
            NV_CFGEX_AGP_LINEAR_BASE_PARAMS params;
            U032 physicalAGPBase;

            VideoDebugPrint((2, "W32StartIO - MapPhysAddr\n"));

            if ( (RequestPacket->OutputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY) ||
                 (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY)) ))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_MAP_PHYS_ADDR - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            pShareMemory = (NV_SYSMEM_SHARE_MEMORY *) RequestPacket->InputBuffer;
            RequestPacket->StatusBlock->Information =
                                        sizeof(NV_SYSMEM_SHARE_MEMORY);

            sharedViewSize = pShareMemory->byteLength;

            //**********************************************************************
            // NOTE: we are ignoring ViewOffset
            //**********************************************************************

            shareAddress.HighPart = 0x00000000;
            PHYSICAL_ADDRESS_VALUE(shareAddress) = pShareMemory->physicalAddress;
            pShareMemoryInformation = (NV_SYSMEM_SHARE_MEMORY *) RequestPacket->OutputBuffer;

            //**********************************************************************
            // Map the physical address into a non-cached kernel mode address.
            //**********************************************************************
            pShareMemoryInformation->ddVirtualAddress =
                MmMapIoSpace(shareAddress,
                            (size_t) sharedViewSize,
                            (MmNonCached | MmWriteCombined));

            if (pShareMemoryInformation->ddVirtualAddress == NULL)
                {
                status = ERROR_INVALID_PARAMETER;
                break;
                }

            //**********************************************************************
            // Set the RM's AGP linear base if a mapping doesn't exist already. We
            // don't expect this to ever been needed, since the RM should've been
            // able to create their own mapping to the AGP phys base. Just in case,
            // set it up if it's not already.
            //**********************************************************************
            RmConfigGetKernel(hwDeviceExtension->DeviceReference,
                              NV_CFG_AGP_PHYS_BASE, &physicalAGPBase);

            RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                NV_CFGEX_AGP_LINEAR_BASE,
                                &params,
                                sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS));
            if ((params.linaddr == NULL) &&
                (physicalAGPBase == pShareMemory->physicalAddress)) {
                
                // update the RM's linear base
                params.linaddr = pShareMemoryInformation->ddVirtualAddress;
                RmConfigSetExKernel(hwDeviceExtension->DeviceReference,
                                    NV_CFGEX_AGP_LINEAR_BASE,
                                    &params,
                                    sizeof(NV_CFGEX_AGP_LINEAR_BASE_PARAMS));
            }

            //**********************************************************************
            // Returned amount of mapped memory to specific process
            //**********************************************************************

            pShareMemoryInformation->byteLength = sharedViewSize;

            status = NO_ERROR;
            }
            break;

        //**************************************************************************
        // UNMAP_PHYS_ADDR
        //**************************************************************************

        case IOCTL_VIDEO_UNMAP_PHYS_ADDR:
            {
            NV_SYSMEM_SHARE_MEMORY  *pShareMemory;

            VideoDebugPrint((2, "W32StartIO - UnmapPhysAddr\n"));

            if (RequestPacket->InputBufferLength < sizeof(NV_SYSMEM_SHARE_MEMORY))
                {
                VideoDebugPrint((0, "IOCTL_VIDEO_MAP_PHYS_ADDR - ERROR_INSUFFICIENT_BUFFER\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
                }

            pShareMemory = (NV_SYSMEM_SHARE_MEMORY *) RequestPacket->InputBuffer;
            RequestPacket->StatusBlock->Information =
                                        sizeof(NV_SYSMEM_SHARE_MEMORY);

            sharedViewSize = pShareMemory->byteLength;

            //**********************************************************************
            // Unmap the virtual address.
            //**********************************************************************
            MmUnmapIoSpace(pShareMemory->ddVirtualAddress,
                        (size_t) sharedViewSize);

            pShareMemory->ddVirtualAddress = NULL;
            status = NO_ERROR;
            }
            break;

        case IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR:
            {
                ULONG * pulXY;

                if(RequestPacket->InputBufferLength != sizeof(ULONG))
                {

                    VideoDebugPrint((0, "IOCTL_VIDEO_TIMER_UPDATE_XY_FOR_NV10_CURSOR - ERROR_INSUFFICIENT_BUFFER\n"));
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }
                else
                {
                    pulXY = (ULONG *)RequestPacket->InputBuffer;
                    hwDeviceExtension->NvCursorInfo.lCursorX= (LONG)( (SHORT)(*pulXY & 0xFFFF));
                    hwDeviceExtension->NvCursorInfo.lCursorY= (LONG)( (SHORT)(*pulXY >> 16));
                    status = NO_ERROR;
                    break;
                }
            }
            break;

        case IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR:
            {
                NV_CURSOR_INFO * pNvCursorInfo;

                if(RequestPacket->InputBufferLength != sizeof(NV_CURSOR_INFO))
                {

                    VideoDebugPrint((0, "IOCTL_VIDEO_START_TIMER_FOR_NV10_CURSOR - ERROR_INSUFFICIENT_BUFFER\n"));
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }
                else
                {
                    pNvCursorInfo = (NV_CURSOR_INFO * )RequestPacket->InputBuffer;

                    hwDeviceExtension->NvCursorInfo.lCursorX = pNvCursorInfo->lCursorX;
                    hwDeviceExtension->NvCursorInfo.lCursorY = pNvCursorInfo->lCursorY;
                    hwDeviceExtension->NvCursorInfo.lCursorWidth = pNvCursorInfo->lCursorWidth;
                    hwDeviceExtension->NvCursorInfo.lCursorHeight = pNvCursorInfo->lCursorHeight;
                    hwDeviceExtension->NvCursorInfo.lScreenStride = pNvCursorInfo->lScreenStride;
                    hwDeviceExtension->NvCursorInfo.lScreenPixelDepth = pNvCursorInfo->lScreenPixelDepth;
                    hwDeviceExtension->NvCursorInfo.ulHwCursorWidth = pNvCursorInfo->ulHwCursorWidth;
                    hwDeviceExtension->NvCursorInfo.ulOriginalImageMemOffset = pNvCursorInfo->ulOriginalImageMemOffset;
                    hwDeviceExtension->NvCursorInfo.ulCursorMemOffset = pNvCursorInfo->ulCursorMemOffset;

                    VideoPortStartTimer(hwDeviceExtension);
                    status = NO_ERROR;
                }
            }
            break;

        case IOCTL_VIDEO_STOP_TIMER_FOR_NV10_CURSOR:
            {
                VideoPortStopTimer(hwDeviceExtension);
                status = NO_ERROR;
            }
            break;


#if !defined(_WIN64)
        case IOCTL_VIDEO_STEREO_GLASSES_SWITCH:
            {
                if (   (NULL!=RequestPacket->InputBuffer)
                    && (RequestPacket->InputBufferLength==sizeof(NV_CFG_STEREO_PARAMS)) )
                {
                    NV_CFG_STEREO_PARAMS  StereoParamsOld;

                    // this interface is used for workstation opengl api stewreo so far !
                    ASSERT( ((NV_CFG_STEREO_PARAMS*)RequestPacket->InputBuffer)->Flags & STEREOCFG_WS_OGL_API_STEREO);

                    // NOT IA64 SAVE !! because we cast a pointer to U032 !!
                    if( RmConfigSetKernel( hwDeviceExtension->DeviceReference,
                                           NV_CFG_STEREO_CONFIG,
                                           (U032)RequestPacket->InputBuffer,
                                           (U032*)&StereoParamsOld)
                      )
                    {
                        status = NO_ERROR;
                    }
                }
                else
                {
                    VideoDebugPrint((0, "IOCTL_VIDEO_STEREO_GLASSES_SWITCH failed because of invalid RequestPacket->InputBuffer data!"));
                }

            }
            break;
#endif

        case IOCTL_VIDEO_QUERY_NUM_OF_DEVICE_OBJECTS:  // should be called only from the multi dev layer of the NT4 display driver!
            {
                PVOID pvDevObj;
                ULONG ulNumDevObj;

                if (RequestPacket->OutputBufferLength < sizeof(QUERY_NUM_OF_DEVICE_OBJECTS) ||
                    RequestPacket->InputBufferLength < sizeof(QUERY_NUM_OF_DEVICE_OBJECTS))
                {
                  status = ERROR_INSUFFICIENT_BUFFER;
                  break;
                }
                pvDevObj = ((QUERY_NUM_OF_DEVICE_OBJECTS *)(RequestPacket->InputBuffer))->pvDevObj;  // need hDriver in InputBuffer
                ASSERT(pvDevObj);
                if (pvDevObj)
                {
                    ((QUERY_NUM_OF_DEVICE_OBJECTS *)(RequestPacket->OutputBuffer))->ulNumDevObj = ulQueryNumDevices(pvDevObj);

                    status = NO_ERROR;
                    RequestPacket->StatusBlock->Information = sizeof(QUERY_NUM_OF_DEVICE_OBJECTS);
                }
            }  
            break;

        case IOCTL_VIDEO_GET_DEVICE_OBJECTS:  // should be called only from the multi dev layer of the NT4 display driver!
            {
                ULONG ulNumDevObj;
                PVOID pvDevObj;
                PVOID *ppvOutDevObj;

                if (RequestPacket->InputBufferLength < (sizeof (GET_DEVICE_OBJECTS)))
                {
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }
                pvDevObj    = ((GET_DEVICE_OBJECTS *)(RequestPacket->InputBuffer))->pvDevObj;     // need hDriver in InputBuffer
                ulNumDevObj = ((GET_DEVICE_OBJECTS *)(RequestPacket->InputBuffer))->ulNumDevObj;  


                if (RequestPacket->OutputBufferLength < (sizeof (GET_DEVICE_OBJECTS) + (ulNumDevObj -1) * sizeof(PVOID) )) 
                {
                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                ppvOutDevObj = &((GET_DEVICE_OBJECTS *)(RequestPacket->OutputBuffer))->apvDevObj[0];

                if (!bGetDevices(pvDevObj, ppvOutDevObj))
                {
                    status = ERROR_INSUFFICIENT_BUFFER;
                }
                else
                {
                    RequestPacket->StatusBlock->Information = (sizeof (GET_DEVICE_OBJECTS) + (ulNumDevObj -1) * sizeof(PVOID) );
                    status = NO_ERROR;
                }
            }
            break;

    default:

        //**************************************************************************
        // if we get here, an invalid IoControlCode was specified.
        //**************************************************************************

        VideoDebugPrint((1, "Fell through vga startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;
        }

        //  Zero out the Information in StatusBlock when Error occurs.
        
        if(status != NO_ERROR)
        {
            RequestPacket->StatusBlock->Information = 0;
        }

    RequestPacket->StatusBlock->Status = status;
#if DBG
    VideoDebugPrint((2, "W32StartIO Exit  - %08.8x\n", RequestPacket->IoControlCode));
#endif
    return TRUE;

    } // NVStartIO()

//******************************************************************************
//
// Function: NVInterrupt()
//
// Routine Description:
//   This function services interrupts generated by the device.
//
// Arguments:
//
//    HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//   TRUE -- if this device caused the interrupt and when the interrupt is
//           serviced and the interrupt reset
//
//   FALSE -- if this device was not responsible for the interrupt
//
//******************************************************************************


BOOLEAN NVInterrupt(
    PVOID HwDeviceExtension
)
{
        PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
        BOOLEAN serviced;

        // Only service the interrupt when the power of adapter is on
        if(hwDeviceExtension->curAdapterPowerState != VideoPowerOn)
            return(FALSE);

        serviced = (BOOLEAN) RmIsr(hwDeviceExtension->DeviceReference);

        return serviced;
}

//******************************************************************************
//
// private routines
//
//******************************************************************************


//******************************************************************************
//
// Function: NVSetColorLookup()
//
// Routine Description:
//
//     This routine sets a specified portion of the DAC color lookup table
//     settings.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//     ClutBufferSize - Length of the input buffer supplied by the user.
//
//     ClutBuffer - Pointer to the structure containing the color lookup table.
//
// Return Value:
//
//     NO_ERROR - information returned successfully
//
//     ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.
//
//     ERROR_INVALID_PARAMETER - invalid clut size.
//
//******************************************************************************


VP_STATUS
NVSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )


    {
    USHORT i;
    ULONG OutData;

    //**************************************************************************
    // Check if the size of the data in the input buffer is large enough.
    //**************************************************************************

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //**************************************************************************
    // Check to see if the parameters are valid.
    //**************************************************************************

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
             VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //**************************************************************************
    // Set palette for either.
    //**************************************************************************
    NV_SetColorLookup(HwDeviceExtension,ClutBuffer,ClutBufferSize);

    return NO_ERROR;

    } // end NVSetColorLookup()



//******************************************************************************
//
// Function: NVGetColorLookup()
//
// Routine Description:
//
//     This routine gets a specified portion of the DAC color lookup table
//     settings.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//     ClutBufferSize - Length of the output buffer supplied by the user.
//
//     ClutBuffer - Pointer to the buffer to store the color lookup table.
//
// Return Value:
//
//     NO_ERROR - information returned successfully
//
//     ERROR_INSUFFICIENT_BUFFER - output buffer not large enough for clut data.
//
//     ERROR_INVALID_PARAMETER - invalid clut size.
//
//******************************************************************************

VP_STATUS
NVGetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

    {
      PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
      PVIDEO_CLUTDATA   pvcdItemSrc,pvcdItemDst;
      PVIDEO_CLUT       srcclut,dstclut;
      ULONG index,item,NumEntries,FirstEntry;

      //**************************************************************************
      // Get data from gamma cache.
      //**************************************************************************

      // - Make things nice to look at
                pvcdItemSrc = &hwDeviceExtension->GammaCache.LookupTable->RgbArray;
                pvcdItemDst = &ClutBuffer->LookupTable->RgbArray;
      srcclut = &hwDeviceExtension->GammaCache;
      dstclut = ClutBuffer;

      // - Copy over the clut specs
      dstclut->NumEntries = srcclut->NumEntries;
      dstclut->FirstEntry = srcclut->FirstEntry;

      // - Set the limits on the item copy
      NumEntries = srcclut->NumEntries;
      FirstEntry = srcclut->FirstEntry;

      // - Copy over the gamma data
      for(item = FirstEntry; item < NumEntries; item++) {
           index = item + FirstEntry;
           pvcdItemDst[index].Blue   = pvcdItemSrc[index].Blue;
           pvcdItemDst[index].Green  = pvcdItemSrc[index].Green;
           pvcdItemDst[index].Red    = pvcdItemSrc[index].Red;
           pvcdItemDst[index].Unused = pvcdItemSrc[index].Unused;
      }

    return NO_ERROR;

    } // end NVGetColorLookup()



//******************************************************************************
//
// Function: NVRegistryCallback()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }

    //**********************************************************************
    // Deals with data if size > 4 bytes
    // If > 4 bytes, we'll treat it as Unicode string data  (MODE ENTRIES)
    // and not dword registry switches
    //**********************************************************************

    if (ValueLength > sizeof(ULONG))
        {
        //*******************************************************************
        // Copy string data into our temporary buffer registry_data[]
        // Since this callback can be called MANY times per each
        // VideoPortGetRegistry call, we need to manually keep track of where
        // to store the incoming data, since the Context ptr is NOT
        // automatically incremented.  It's always equal to the
        // base address of registry_data.  That is, the RegistryDataOffset value
        // is incremented each time we read a short value from the registry,
        // so that the next time this callback gets called, we'll know where
        // we left off.
        //*******************************************************************

        DestPtr = (SHORT*)((PUCHAR)Context + hwDeviceExtension->RegistryDataOffset);
        SrcStrPtr = (PUCHAR)(ValueData);

        //**********************************************************************
        // Reading mode data numbers from the current mode entry line.
        // This registry callback will continue getting called for each line
        // until the last line is encountered.
        //**********************************************************************

        while (SrcStrPtr < (PUCHAR)ValueData + ValueLength - 2)
            {

            shortvalue = GetNextWordFromRegistry(hwDeviceExtension,&SrcStrPtr);
            *DestPtr = shortvalue;

            //******************************************************************
            // Need to manually keep track of where we need to store the numbers
            // (short values) the next time the registry call back gets called.
            //******************************************************************

            (hwDeviceExtension->RegistryDataOffset)+=2;
            DestPtr++;

            //******************************************************************
            // Debug Safety Check:
            // Make sure we don't go past the end of the registry_data table
            // Backup 30 words from end of table
            //******************************************************************

            if (hwDeviceExtension->RegistryDataOffset > ( (MAX_STRING_REGISTRY_DATA_WORDS*2) - (30*2))  )
                {
                VideoDebugPrint((0, "!!!                                             !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR ERROR  !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: Went past end of registry_data table !!!\n"));
                VideoDebugPrint((0, "!!! ERROR: ERROR ERROR ERROR ERROR ERROR ERROR  !!!\n"));
                VideoDebugPrint((0, "!!!                                             !!!\n"));
                }

            }



        return(NO_ERROR);


        }

    //*************************************************************************
    // Read dword entries
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, (size_t) ValueLength);
    return(NO_ERROR);
    } // end NVRegistryCallback()



//******************************************************************************
//
// Function: NVReadLocalRegistryCallback()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistrySwitchesCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }


    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, ValueLength);
    return(NO_ERROR);
    } // end NVReadLocalRegistryCallback()

//******************************************************************************
//
// Function: NVReadRegistryTwinViewInfoCallback()
//
// Routine Description:     Used to read the "TwinViewInfo" registry entry.
//                          Do not use it for any other purpose.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistryTwinViewInfoCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }

    // In rare pathlogical condidtions, it is possible for the disk copy of the "TwinViewInfo" structure to be different
    // than the incore structure. This happens when for example the structure gets modified in the source tree but
    // there is a leftover disk entry from a previous version of driver.
    if (ValueLength != sizeof(NVTWINVIEWDATA))
    {
        VideoDebugPrint((1, "Oops!TwinViewCallback(): size mismatch Diskcopy size: %d, struct size: %d\n",
                         ValueLength, sizeof(NVTWINVIEWDATA)));
        return(ERROR_INVALID_PARAMETER);
    }


    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, ValueLength);
    return(NO_ERROR);
    } // end NVReadLocalRegistryCallback()

//******************************************************************************
//
// Function: NVReadRegistrySaveSettingsCallback()
//
// Routine Description:     Used to read the "SaveSettings" registry entry.
//                          Do not use it for any other purpose.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistrySaveSettingsCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;
    ULONG ulCurrentTwinViewInfoSize;
    ULONG ulExpectedDataSize;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        {
            return(NO_ERROR);
        }

    ulCurrentTwinViewInfoSize = sizeof(NVTWINVIEWDATA);
    ulExpectedDataSize = ulCurrentTwinViewInfoSize * NUM_ENTRIES_SAVE_SETTINGS;

    // In rare pathlogical condidtions, it is possible for a data mismatch. For example, the user could have manually
    // copied the driver binaries without doing a full driver installation. A full driver kit installation will blow
    // away any existing "SaveSettings" registry entry.
    if (ValueLength != ulExpectedDataSize)
    {
        VideoDebugPrint((1, "Oops!SaveSettingsCallback(): size mismatch Diskcopy size: %d, expected size: %d\n",
                         ValueLength, ulExpectedDataSize));
        return(ERROR_INVALID_PARAMETER);
    }

    // Sanity check. Make sure sufficient array was set aside to read in the SaveSettings.
    if (ValueLength > sizeof(hwDeviceExtension->SaveSettings))
    {
        VideoDebugPrint((1, "Oops!SaveSettingsCallback(): not enough array size in hwdevextension: size: %d, expected size: %d\n",
                         ValueLength, sizeof(hwDeviceExtension->SaveSettings)));
        return(ERROR_INVALID_PARAMETER);
    }

    // Sanity check. Should never happen
    if (ValueData == NULL)
    {
        VideoDebugPrint((1, "Oops!SaveSettingsCallback(): ValueData pointer is NULL\n"));
        return(ERROR_INVALID_PARAMETER);
    }


    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) Context, (PUCHAR) ValueData, ValueLength);
    return(NO_ERROR);
    } // end NVReadSaveSettingsCallback()

//******************************************************************************
//
// Function: NVReadRegistryCallbackBinaryValue()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS
NVReadRegistryBinaryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PNV_REGISTRY_STRUCT pRegStruct;




    //**********************************************************************
    // If the destination ptr is null, we return error.
    // The user sent us a null output pointer.
    //**********************************************************************
    if (Context == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    pRegStruct = (PNV_REGISTRY_STRUCT)Context;

    // Check to see if the user passed us a non-NULL buffer
    if (pRegStruct->keyVal == NULL)
    {
        // Tell him what is the expected buffer size.
        pRegStruct->keyValSize = ValueLength;
        return(NO_ERROR);
    }

    // Check to see if the user passed us enough of a buffer
    if (pRegStruct->keyValSize < ValueLength || pRegStruct->keyValSize == 0)
    {
        // The user did not send us enough buffer. Tell him what is the 
        // expected buffer size.
        pRegStruct->keyValSize = ValueLength;
        return(NO_ERROR);
    }

    //*************************************************************************
    // Copy ValueLength bytes
    //*************************************************************************

    memcpy((PUCHAR) pRegStruct->keyVal, (PUCHAR) ValueData, ValueLength);
    pRegStruct->keyValSize = ValueLength;
    return(NO_ERROR);
    } // end NVReadLocalRegistryCallback()



//******************************************************************************
//
// Function: NVReadMonitorTimingModeCallback()
//
// Routine Description: If there is a reg entry and it fits, copy it
//                      If it is to big, copy the string L"DMT" instead
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VP_STATUS
NVReadMonitorTimingModeCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )


{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if(Context == NULL) {
      return(NO_ERROR);
    }


    //*************************************************************************
    // Compare the value to the GTF and DMT strings
    //*************************************************************************

    if(!memcmp( (PUCHAR)L"GTF", (PUCHAR) ValueData, sizeof(L"GTF"))) {
        VideoDebugPrint((1, "GTF overide detected\n"));
        *(ULONG *)Context = TRUE;
        }
    else {
        *(ULONG *)Context = FALSE;
        }

    return(NO_ERROR);
}


//******************************************************************************
//
// Function:    NVSetBiosInfo(HwDeviceExtension)
//
// Routine Description:
//  Attempts to locate BIOS version string. First it searches for
//  a standard NV Bios Info block. If that is not present, it
//  assumes this is a Viper board and scans for a version
//  string.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
VOID NVSetBiosInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    PUCHAR VersionStr = "Version ";
    PUCHAR pBios = HwDeviceExtension->pBios;
    USHORT  i, j, c;
    BOOLEAN Found = FALSE;
    WCHAR   wcNameStr[BIOS_STR_MAX] = L"<unavailable>";
    CHAR    NameStr[BIOS_STR_MAX];

    //********************************************************
    // Ask RM for NVidia BIOS revision.
    //********************************************************
    if (RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_BIOS_REVISION, &(HwDeviceExtension->BiosRevision))
        && HwDeviceExtension->BiosRevision)
        {

        //********************************************************
        // See if it's an Elsa BIOS: Elsa uses a similar data structure
        // as the NVIDIA BIOS, but the version string is 24-bits instead of 32.
        //********************************************************
        if (pBios != NULL)
        {
            strcpy(NameStr, "ELSA");
            for (i = 0; i < MAX_BIOS_SCAN; i++)
                if (Found = (VideoPortCompareMemory(NameStr, &pBios[i], strlen(NameStr)) == strlen(NameStr)))
                    break;
        }

        strcpy(NameStr, "Version ");

        // If Found, it's an ELSA BIOS

        if (Found)
        {
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x00ff0000) >> 16), &(NameStr[strlen(NameStr)]), 16, 0);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x0000ff00) >> 8), &(NameStr[strlen(NameStr)]), 16, 2);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x000000ff)), &(NameStr[strlen(NameStr)]), 16, 2);
        }
        else
        {
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0xff000000) >> 24), &(NameStr[strlen(NameStr)]), 16, 0);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x00ff0000) >> 16), &(NameStr[strlen(NameStr)]), 16, 2);
            strcat(NameStr, ".");
            wtoa((USHORT) ((HwDeviceExtension->BiosRevision & 0x0000ffff)), &(NameStr[strlen(NameStr)]), 16, 4);
        }

        //*******************************************************
        // Convert BIOS version string to unicode.
        //*******************************************************
        for (c = i = 0; c < strlen(NameStr); c++)
            {
            wcNameStr[c] = (WCHAR)(NameStr[i + c]) & (WCHAR) 0xff;
            }
        wcNameStr[c] = (WCHAR) 0;
        goto WriteRegistryVersionStr;
        }

    //********************************************************
    // Search for Diamond Viper BIOS: it doesn't use the same
    // version strings as the standard NV BIOS.
    //********************************************************
    if (pBios == NULL)
        return;

    strcpy(NameStr, "Viper ");
    for (i = 0; i < MAX_BIOS_SCAN; i++)
        if (Found = (VideoPortCompareMemory(NameStr, &pBios[i], strlen(NameStr)) == strlen(NameStr)))
            break;

    if (!Found)
        //********************************************************
        // Didn't find a Viper BIOS: write the default version
        // string to the registry.
        //********************************************************
        goto WriteRegistryVersionStr;

    Found = FALSE;
    for ( i += (strlen(NameStr) + 1); i < MAX_BIOS_SCAN; i++)
        if (Found = (VideoPortCompareMemory(VersionStr, &pBios[i], strlen(VersionStr)) == strlen(VersionStr)))
            break;

    if (!Found)
        //********************************************************
        // Didn't find a Version String in the Viper BIOS: write
        // the default version string to the registry.
        //********************************************************
        goto WriteRegistryVersionStr;

    //*******************************************************
    // Determine length of BIOS version string.
    //*******************************************************
    Found = FALSE;
    for (j = i; j < MAX_BIOS_SCAN; j++)
        if (Found = (pBios[j] == '\r'))
            break;

    if (!Found || (j == i))
        return;

    //*******************************************************
    // Convert BIOS version string to unicode.
    //*******************************************************
    for (c = 0; (c < j - i) && (c < BIOS_STR_MAX - 1); c++)
        {
        wcNameStr[c] = (WCHAR)(pBios[i + c] & 0xffffL);
        }

    wcNameStr[c] = (WCHAR) 0;

WriteRegistryVersionStr:
    //*******************************************************
    // Write version string to registry so display applet
    // can access it.
    //*******************************************************
    VideoPortSetRegistryParameters(HwDeviceExtension,
                L"HardwareInformation.BiosString",
                wcNameStr,
                (wcslen(wcNameStr) + 1) * sizeof(WCHAR));
    return;
}

//******************************************************************************
//
// Function: wtoa(Number, pString, radix, width
//
// Routine Description:
//  Converts an unsigned 16 number to an ASCII string.
//
// Arguments:
//      Number      Number to be converted
//      pString     ptr to buffer for converted string. Must be
//                  a min of 6 bytes long.
//      radix       base for conversion
//      width       If 0, do not store leading 0s in pString, otherwise == number of nibbles in input number
//
// Return Value:
//
//******************************************************************************
VOID wtoa(USHORT Number, PUCHAR pString, UCHAR radix, UCHAR width)
{
    ULONG   divisor;
    USHORT  digit;
    USHORT  i;


    if (width)
        divisor = 1 << (4 * (width - 1));
    else
    {
        divisor = radix;
        while (divisor <= Number)
            divisor *= radix;
    }

    for (i = 0; divisor; (divisor /= radix))
        {
        digit = (USHORT)(Number / divisor);
        if (!(!i && !digit && !width))
            if (digit < 10)
                pString[i++] = (UCHAR) ((digit) + '0');
            else
                pString[i++] = (UCHAR) ((digit - 10) + 'A');
        Number = (USHORT) (Number % divisor);
        }
    pString[i]='\0';
}

#if _WIN32_WINNT < 0x0500
//******************************************************************************
//
// Function: wcslen(pString)
//
// Routine Description:
//  Our implementation of a wide char string length routine. We
//  can't call the c lib version of wcslen from this kernel mode
//  driver.
//
// Arguments:
//      pString     wide char string
//
// Return Value:
//      Length of string in wide chars, less the null terminator.
//******************************************************************************
ULONG wcslen(PWCHAR pString)
{
    ULONG i;

    for (i = 0; pString[i]; i++);
    return(i);
}
#endif // #if _WIN32_WINNT < 0x0500



//******************************************************************************
//
// Function: GetNextWordFromRegistry
//
// Routine Description:
//
//          Read the next value in the mode entry line.
//          This function 1) skips unicode white space, and then
//          Converts the unicode string to an integer (short) value.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


SHORT GetNextWordFromRegistry(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUCHAR *SrcStrPtr
    )


    {
    SHORT value;
    UCHAR ch;

    ch = **SrcStrPtr;

    //******************************************************************************
    // Skip over empty space in unicode string
    //******************************************************************************

    while ((ch == 0) || (ch == ' '))
        {
        (*SrcStrPtr)++;                 // Advance the unicode string ptr
        ch = **SrcStrPtr;
        }

    //******************************************************************************
    // We're now at the beginning of the next 'unicode' number
    //******************************************************************************

    value = my_wtoi(SrcStrPtr);

    return(value);
    }


//******************************************************************************
//
// Function: my_wtoi
//
// Routine Description:
//
//      Converts unicode string to an integer (short value)
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


SHORT my_wtoi(
    PUCHAR *SrcStrPtr
    )

    {
    short i,n;

    n=0;
    for (i=0  ; ((**SrcStrPtr) >= '0') && ((**SrcStrPtr) <='9')  ; (*SrcStrPtr)+=2 )
        n=10 * n + ((**SrcStrPtr) - '0');

    return(n);
    }

//******************************************************************************
//
// Function: my_strupr
//
// Routine Description:
//
//      Converts string to all upper case
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID my_strupr(
    PUCHAR s
    )

    {
    short i;

    for (i=0; s[i] != '\0'; i++)
        if ( (s[i] >= 'a') && ( s[i] <='z')  )
            s[i] = (s[i] - 'a') + 'A';

    }

//******************************************************************************
//
// Function: my_strcmp
//
// Routine Description:
//
//      String compare routine.
//      Returns Zero if strings are equal.
//      Returns NonZero if string are not equal
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


ULONG my_strcmp(
    PUCHAR s,
    PUCHAR t
    )

    {
    short i;


    for (i=0; s[i] == t[i] ; i++)
        if (s[i] == '\0')
            return(0);

    return(s[i] - t[i]);
    }


//******************************************************************************
//
// Function: my_strcpy
//
// Routine Description:
//
//      Converts string to all upper case
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID my_strcpy(
    PUCHAR s,
    PUCHAR t
    )

    {
    short i;

    i=0;

    while (  ( s[i] = t[i]  ) != '\0')
        i++;
    }


//******************************************************************************
//
// Function: NV10CursorTimer
//
// Routine Description:
//
//      This function is to workaround the NV10 HW cursor alpha blending problem.
//      Please also see NV10SetPointerShape and NV10MovePointer in NV10ptr.c in
//      displays driver.
//
// Arguments:
//
// Return Value:
//
//******************************************************************************
VOID NV10CursorTimer(
    PVOID HwDeviceExtension
)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    LONG i, j, x, y;
    LONG lScreenStride;
    LONG lScreenPixelDepth;

    ULONG ulAlpha;
    ULONG ulBgdColor;
    ULONG ulBgdRed;
    ULONG ulBgdGreen;
    ULONG ulBgdBlue;
    ULONG ulSrcRed;
    ULONG ulSrcGreen;
    ULONG ulSrcBlue;
    ULONG ulSrcColor;
    ULONG ulDstColor;
    ULONG ulHwCursorWidth;      // HW : 32 or 64

    NV_CURSOR_INFO * pNvCursorInfo;

    UCHAR * pjScreenLoc;
    ULONG * pulDstCursor;
    ULONG * pulSrcCursor;


    pNvCursorInfo = &hwDeviceExtension->NvCursorInfo;

    lScreenStride = pNvCursorInfo->lScreenStride;
    ulHwCursorWidth = pNvCursorInfo->ulHwCursorWidth;
    lScreenPixelDepth = pNvCursorInfo->lScreenPixelDepth;

    pulDstCursor = (ULONG *)( (UCHAR *)hwDeviceExtension->FrameBufferPtr + pNvCursorInfo->ulCursorMemOffset);
    pulSrcCursor = (ULONG *)( (UCHAR *)hwDeviceExtension->FrameBufferPtr + pNvCursorInfo->ulOriginalImageMemOffset);

    x = pNvCursorInfo->lCursorX;
    y = pNvCursorInfo->lCursorY;

    pjScreenLoc = (PUCHAR)hwDeviceExtension->FrameBufferPtr + y * lScreenStride + x * lScreenPixelDepth;

    for(i = 0; i < pNvCursorInfo->lCursorHeight; i++)
    {
        if( (y+i) < 0 ) continue;

        for(j = 0; j < pNvCursorInfo->lCursorWidth; j++)
        {
            if( (x+j) < 0) continue;
            ulSrcColor = *(i * ulHwCursorWidth + j + pulSrcCursor);
            ulAlpha = (ulSrcColor >> 24);
            if( (!ulAlpha) || (ulAlpha == 0xFF))
            {
                // HW will take care it
                continue;
            }
            else
            {

                // HW is broken;  SW Alpha blending
                ulBgdColor = *(ULONG *)(i * lScreenStride + j * lScreenPixelDepth + pjScreenLoc);

                if(lScreenPixelDepth == 2)
                {
                    // Screen is on 16 BPP mode.
                    ulBgdRed   = (ulBgdColor >> 11) & 0x1F;
                    ulBgdGreen = (ulBgdColor >> 05) & 0x3F;
                    ulBgdBlue  = (ulBgdColor & 0x1F);

                    ulBgdRed   = ulBgdRed  * 0xFF / 0x1F;         // convert to 8 bits format
                    ulBgdGreen = ulBgdGreen  * 0xFF / 0x3F;       // convert to 8 bits format
                    ulBgdBlue  = ulBgdBlue * 0xFF / 0x1F;

                }
                else
                {
                    // Screen is on 32 BPP mode
                    ulBgdRed   = (ulBgdColor >> 16) & 0xFF;
                    ulBgdGreen = (ulBgdColor >> 8) & 0xFF;
                    ulBgdBlue  = (ulBgdColor & 0xFF);
                }

                ulSrcRed   = (ulSrcColor >> 16) & 0xFF;
                ulSrcGreen = (ulSrcColor >> 8) & 0xFF;
                ulSrcBlue  = (ulSrcColor & 0xFF);

                ulSrcRed    = ulSrcRed   + (((255 - ulAlpha) * ulBgdRed + 128) >> 8) ;
                ulSrcRed   &= 0xFF;

                ulSrcGreen  = ulSrcGreen + (((255 - ulAlpha) * ulBgdGreen + 128) >> 8);
                ulSrcGreen &= 0xFF;

                ulSrcBlue   = ulSrcBlue  + (((255 - ulAlpha) * ulBgdBlue + 128) >> 8);
                ulSrcBlue  &= 0xFF;

                ulDstColor =  (0xFF000000) | (ulSrcRed << 16) | (ulSrcGreen << 8) | ulSrcBlue;

                *(i * ulHwCursorWidth + j + pulDstCursor) = ulDstColor;
            }
        }
    }

}




#ifdef NVPE
//******************************************************************************
//
// Function: NVRegistryCallbackPnpId()
//
// Routine Description: callback function used to read 'pnpid' strings from
//                      registry
// Arguments:
//
// Return Value:
//
//******************************************************************************


VP_STATUS NVRegistryCallbackPnpId(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    SHORT shortvalue;
    PUCHAR SrcStrPtr;
    SHORT *DestPtr;

    //**********************************************************************
    // If the destination ptr is null, we don't care about the actual value, just
    // the fact that the Value name was found in the registry.
    //**********************************************************************
    if (Context == NULL)
        return (NO_ERROR);

    VideoPortMoveMemory(Context, ValueData, ValueLength);

    return(NO_ERROR);

} // end NVRegistryCallbackPnpId()

#endif


//
// Detects the number of heads present and reads in the EDID for each head.
// bBootTime: If TRUE, sets safe default masks.
//

BOOLEAN NVInitialize_DacsAndEDID(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bBootTime)
{
    ULONG Count = 0;
    BOOLEAN bRet = TRUE;
    NV_DESKTOP_INFO * pInfo;
    LONG i, numChildren;
    ULONG ulConnectedDeviceMask;
    NVTWINVIEWDATA TwinViewData;
    VP_STATUS Status;
    PVOID ptr;

    VideoDebugPrint((2, "INVInitialize_DacsAndEDID():\n"));

    if (bBootTime)
        HwDeviceExtension->bNeedRetrieveEDID = FALSE;
    
    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    pInfo->ulNumberDacsOnBoard = 1;
    pInfo->ulNumberDacsConnected = 1;

    // Get the bitmask for all the connectors in the system.
    pInfo->ulAllDeviceMask = BITMASK_INVALID_DEVICE;
    RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_GET_ALL_DEVICES, &pInfo->ulAllDeviceMask);
    VideoDebugPrint((1,"ulAllDeviceMask: 0x%x\n",pInfo->ulAllDeviceMask));

    // Get the connect status for all the connectors.
    pInfo->ulConnectedDeviceMask = pInfo->ulAllDeviceMask;
    ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;

    if (RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                            NV_CFGEX_CHECK_CONNECTED_DEVICES, &pInfo->ulConnectedDeviceMask, 
                            sizeof(pInfo->ulConnectedDeviceMask)))
    {
        // success.
        VideoDebugPrint((1,"ulConnectedDeviceMask: 0x%x\n",pInfo->ulConnectedDeviceMask));
        if (pInfo->ulConnectedDeviceMask == 0)
        {
            VideoDebugPrint((0,"Oops! ConnectedDevicemask is 0. Assume a CRT\n"));
            pInfo->ulConnectedDeviceMask = 0x1;

        }
        ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;
    }
    else
    {
        // The resman had issues with our request, so spew a warning
        VideoDebugPrint((0, "NVInitialize -  RmConfigGetExKernel() returned error for NV_CFGEX_CHECK_CONNECTED_DEVICESI\n"));
    }


    if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_NUMBER_OF_HEADS, &pInfo->ulNumberDacsOnBoard))
    {
        VideoDebugPrint((0,"Ooops! RmConfigGetKernel() failed for NV_CFG_NUMBER_OF_HEADS\n"));
        bRet = FALSE;
    }
    else
    {
        if (pInfo->ulNumberDacsOnBoard == 1)
        {
            pInfo->ulNumberDacsConnected = 1;
            if (bBootTime) 
            {
                SetSafeDeviceMasks_SingleHeadBoard(HwDeviceExtension);
            }
        }
        if (pInfo->ulNumberDacsOnBoard == 2)
        {
            if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) == 1)
            {
                pInfo->ulNumberDacsConnected = 1;
            }
            if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) > 1)
            {
                pInfo->ulNumberDacsConnected = 2;
            }
            if (bBootTime)
            {
                SetSafeDeviceMasks_DualHeadBoard(HwDeviceExtension);
                InitFromTwinViewInfo(HwDeviceExtension);
            }
        }
        HandleBIOSHeads(HwDeviceExtension);

        // Print the info collected
        VideoDebugPrint((1,"DacsOnBoard: %d, DacsConnected: %d, AllDeviceMask: 0x%x, ConnectedDeviceMask: 0x%x,\n",
                 pInfo->ulNumberDacsOnBoard, pInfo->ulNumberDacsConnected,pInfo->ulAllDeviceMask,  pInfo->ulConnectedDeviceMask));
    } 


    VideoDebugPrint((2,"Number of heads on board returning to display driver: 0x%x, number connected: 0x%x\n",
        pInfo->ulNumberDacsOnBoard,pInfo->ulNumberDacsConnected));

    numChildren = ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask);
    ptr = ExAllocatePool(PagedPool, sizeof(EDID_COLLECTION)+sizeof(EDID_UNIT)*(numChildren+1));
    if (ptr == NULL)
    {
        return FALSE;
    }
    if (HwDeviceExtension->EdidCollection)
    {
        ExFreePool(HwDeviceExtension->EdidCollection);
        HwDeviceExtension->EdidCollection = NULL;
    }
    HwDeviceExtension->EdidCollection = (LPEDID_COLLECTION)ptr;
    VideoPortZeroMemory(HwDeviceExtension->EdidCollection, sizeof(EDID_COLLECTION)+sizeof(EDID_UNIT)*(numChildren+1));
    //
    // By default, all HeadMaps points to a dummy EdidUnit, which is the last one EdidUnits array
    // It's also why we allocate one more EdidUnit
    //
    for (i = 0; i < NV_NO_CONNECTORS; i++)
    {
        HwDeviceExtension->EdidCollection->HeadMaps[i] = &(HwDeviceExtension->EdidCollection->EdidUnits[numChildren]);
    }

    //
    // Now read the EDID for all the connected devices.
    // Get the EDID buffer from the RM always.
    //
    numChildren = 0;
    for (i = 0; i < NV_NO_CONNECTORS; i++)
    {
        ULONG ulDeviceMask;
        ulDeviceMask = (1 << i);

        // See if this device is connected
        if (ulConnectedDeviceMask & ulDeviceMask)
        {
            NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS EdidParams;
            LPEDID_UNIT pEdidUnit = &HwDeviceExtension->EdidCollection->EdidUnits[numChildren];
            ULONG EdidBufferSize          = EDID_V2_SIZE;

            EdidParams.displayMap   = ulDeviceMask;
            EdidParams.edidBuffer   = (UCHAR *) &(pEdidUnit->EDIDBuffer[0]);
            EdidParams.bufferLength = &EdidBufferSize;

            if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_GET_LOGICAL_DEV_EDID, &EdidParams, sizeof(NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS) ))
            {
                VideoDebugPrint((1, "RmConfigGetExKernel() returned error for NV_CFGEX_GET_LOGICAL_DEV_EDID for DeviceMask: 0x%x\n",ulDeviceMask));
                // Reset all the data fields.
                VideoPortZeroMemory(pEdidUnit, sizeof(EDID_UNIT));
            }
            else
            {
                pEdidUnit->Valid = 1;
                pEdidUnit->Size  = EdidBufferSize;
            }
            HwDeviceExtension->EdidCollection->HeadMaps[i] = &(HwDeviceExtension->EdidCollection->EdidUnits[numChildren]);
            numChildren++;
        }
    }

    // Now read the TwinViewInfo registry structure. If it is invalid with the current configuration,
    // Invalidate it. For example, the user might have done a output device switch to TV, shut down the system,
    // reboot without the TV.
    Status = NVGetRegistryTwinviewInfo(HwDeviceExtension, &TwinViewData);
    if (Status == NO_ERROR)
    {
        // Check to see if the data is valid.
        if (!TwinViewDataOK(HwDeviceExtension, &TwinViewData))
        {
            // Invalidate the registry data.
            InvalidateTwinViewData(HwDeviceExtension, &TwinViewData);
        }
    }

#if (_WIN32_WINNT >= 0x0500)
    if (HwDeviceExtension->pDualViewAssociatedDE)
        HwDeviceExtension->pDualViewAssociatedDE->EdidCollection  = HwDeviceExtension->EdidCollection;
#endif

    return(TRUE);
}




//
// Returns TRUE if the device list is successfully scanned
//
BOOLEAN bScanHeadDeviceOptions(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    // The FALSE indicates it is not a boottime operation.
    NVInitialize_DacsAndEDID(HwDeviceExtension, FALSE);
    return(TRUE);
} // End function bScanHeadDeviceOptions()



//
// This function should be called once at boot time.
// It initializes the DeskTopInfo structure to safe values.
//
BOOLEAN NVOneTimeInit_TwinView(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG i, Count = 0;
    BOOLEAN bRet = TRUE;
    NV_DESKTOP_INFO * pInfo;
    VP_STATUS status;
    ULONG ulValue;
    
    VideoDebugPrint((2, "NVOneTimeInit_TwinView():\n"));

    //
    // If we don't create the events, NVSVC can not open the events and will keep spitting out debug messages.
    // Just creating the events is harmless even if the NVSVC is never installed or started.
    //
    InitNVSVCEvents();
    HwDeviceExtension->ulNVSVCStatus = NVSVC_STATUS_STOPPED;

    //
    // We are booting up the system. So no modeset has happended yet.
    // The display driver needs to know this because on Mobile systems, we need to
    // honor the BIOS's output device selections at boot time.
    //
    HwDeviceExtension->SystemModeSetHasOccurred = 0;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"SystemModeSetHasOccurred",
                                      &HwDeviceExtension->SystemModeSetHasOccurred,
                                      sizeof(ULONG));

    //
    // Per Terry, blindly create "NvCplSetAtStartup" with a value of 0xFFFFFFFF at boot time. This will be
    // used and managed by the control panel.
    //
    ulValue = 0xFFFFFFFF;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                      L"NvCplSetAtStartup",
                                      &ulValue,
                                      sizeof(ULONG));
    
    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    pInfo->ulDesktopModeIndex = 0;

    pInfo->ulDesktopMode = 0;
    //
    // Initialize the state to Standard mode. This will be changed to clone mode only in the case of 
    // 'UseHwSelectedDevice' (i.e. laptops) being on and the BIOSDeviceMask indicating two devices.
    //
    pInfo->ulTwinView_State = NVTWINVIEW_STATE_NORMAL;
    pInfo->ulNumberDacsOnBoard = 1;
    pInfo->ulNumberDacsConnected = 1;
    pInfo->ulNumberDacsActive = 1;
    pInfo->ulAllDeviceMask = BITMASK_CRT0;
    pInfo->ulConnectedDeviceMask = BITMASK_CRT0;

    pInfo->ulDesktopWidth = 640;
    pInfo->ulDesktopHeight = 480;

    for(i = 0; i < NV_NO_DACS; i++)
    {
        pInfo->ulDisplayWidth[i] = 640;
        pInfo->ulDisplayHeight[i] = 480;
        pInfo->ulDisplayRefresh[i] = 60;
        pInfo->ulDisplayPixelDepth[i] = 8;
        pInfo->ulDeviceDisplay[i] = i;
        pInfo->ulDeviceMask[i] = BITMASK_CRT0;
        pInfo->ulDeviceType[i] = MONITOR_TYPE_VGA;
        pInfo->ulTVFormat[i] = 0;
    }

    HwDeviceExtension->ulUniquenessVGA = 0;
    HwDeviceExtension->ulNVSVCStatus = NVSVC_STATUS_STOPPED;
    HwDeviceExtension->ulInduceModeChangeDeviceMask = 0;

    return(bRet);
}


//
// Returns the number and list of physical modes for the specified head.
// The following filters are applied
// 1. PixelClockFrequency of the specified head. Note if ulHead is 1 and ulDeviceType is CRT, then the 
//  pixelFreq of Head1 (150MHZ) is used. For other device types (DFP,TV) the head0's (350MHZ) pixel freq is used.
// 2. If a MonitorModeList is found, use this list (after filtering against the pixelFreq) and Return.
// 3. If ulEnableDDC is enabled, then parse the EDID for this to get the modes.
//
BOOLEAN  GetHeadPhysicalModeList(
    PHW_DEVICE_EXTENSION HwDeviceExtension, 
    HEAD_MODE_LIST_INFO * pInput,
    ULONG * pRetSize)
{
    ULONG ulHead;
    ULONG ulEnableDDC;
    MODE_ENTRY *MonitorModeList, *VirtualModeList;
    ULONG NumMonitorModes, NumVirtualModes, NumValidModes;
    MODE_ENTRY *DestPtr;
    LPDISPDATA lpDispData;
    LPMODEINFO lpModeDesc;
    LPMODEOUT  lpModeOut;
    LPMODEINFO lpModeNew;
    ULONG ulFrequencyHead;
    DISPDATA DispData;
    MODEINFO ModeDesc;
    MODEOUT  ModeOut;
    MODEINFO ModeNew;
    ULONG ulRet, i, j;
    BOOLEAN bFoundMatchInVirtualList;
    ULONG ulHeadEDID;
    LPEDID_UNIT pEdidUnit;
    ULONG ulDeviceType;
    ULONG ulWidth, ulHeight;

    VideoDebugPrint((3,"Enter GetHeadPhysicalModeList()\n"));

    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;
    

    ulHead = pInput->ulHead;
    ulEnableDDC = pInput->ulEnableDDC;
    
    ulHeadEDID =  ConvertDeviceMaskToIndex(pInput->ulDeviceMask);
    pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulHeadEDID];

    // If the device type is TV, w simply return the virtual mode list with only
    // 640x480 and 800x600 for all color depths at only 60HZ
    // For brooktree871 encoder, add the 1024x768 resolution

    pInput->ulDeviceType = MaskToDeviceType(pInput->ulDeviceMask);

    
    if (pInput->ulDeviceType == MONITOR_TYPE_NTSC || pInput->ulDeviceType == MONITOR_TYPE_PAL)
    {
        DestPtr = pInput->pPhysicalModeList;
        VirtualModeList = pInput->pVirtualModeList;

        NumVirtualModes = pInput->ulNumVirtualModes;
        NumValidModes = NumVirtualModes;

        for (i=0; i < NumVirtualModes; i++)
        {

            if (HwDeviceExtension->ulTVEncoderType == NV_ENCODER_BROOKTREE_871)
            {
                if (VirtualModeList->Width > 1024 || VirtualModeList->Height > 768 || VirtualModeList->RefreshRate != 60)
                { 
                    // Not a valid mode.
                    NumValidModes--;
                    VirtualModeList++;
                    continue;
                }
            }
            else if (VirtualModeList->Width > 800 || VirtualModeList->Height > 600 || VirtualModeList->RefreshRate != 60)
            {
                // Not a valid mode.
                NumValidModes--;
                VirtualModeList++;
                continue;
            }

            // The mode passes all filters.
            // Copy this valid mode and process the next mode from the monitor modelist.
            if (DestPtr)
            {
                *DestPtr++ = *VirtualModeList++;
            }
            else
            {
                VirtualModeList++;
            }
            
        }
        *pRetSize = NumValidModes * sizeof(MODE_ENTRY);
        return(TRUE);
    }

    // Set up the generic fields required for the FindModeEntry() call.
    //
    // Check if CRT is connected for second head. Only then should we
    // use the pixel clock for the second head. Otherwise, we should use the pixel clock of
    // DAC 0 for both heads.
    //
    ulFrequencyHead = ulHead;
    if (ulHead == 1 && pInput->ulDeviceType != MONITOR_TYPE_VGA) {
         ulFrequencyHead = 0;
    }
    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwCRTCIndex = ulHead;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    
    // Read in the monitor restriction mode lists for each head.
    ReadMonitorRestrictionModeList(HwDeviceExtension);

    
    // use the right monitor mode list entry for this head.
    switch (ulHead)
    {
        case 0:
            MonitorModeList = (MODE_ENTRY *)&HwDeviceExtension->RestrictionModeTable0[0];
            NumMonitorModes = HwDeviceExtension->NumRestrictionModes0;
            break;
        case 1:
            MonitorModeList = (MODE_ENTRY *)&HwDeviceExtension->RestrictionModeTable1[0];
            NumMonitorModes = HwDeviceExtension->NumRestrictionModes1;
            break;
        default:
            VideoDebugPrint((1,"Oops! Invalid Head: 0x%x\n",ulHead));
            MonitorModeList = (MODE_ENTRY *)&HwDeviceExtension->RestrictionModeTable0[0];
            NumMonitorModes = HwDeviceExtension->NumRestrictionModes0;
            break;
    }

    
 
    // If the monitor mode list is present, then we simply return this mode list for this head.
    // We do not bother about EDID for this case.
    if (NumMonitorModes != 0)
    {
        DestPtr = pInput->pPhysicalModeList;
        
        NumVirtualModes = pInput->ulNumVirtualModes;
        NumValidModes = NumMonitorModes;

        lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(pInput->ulDeviceMask);
        lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(pInput->ulDeviceMask);
        lpModeDesc->MIDevData.cFormat   = (CHAR)pInput->ulTVType;
        lpModeDesc->MIDevData.cReserved = 0x0;

        EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
        for (i=0; i < NumMonitorModes; i++)
        {
            VirtualModeList = pInput->pVirtualModeList;
            bFoundMatchInVirtualList = FALSE;
            // First validate against the virtual mode list.

            for (j=0; j < NumVirtualModes; j++)
            {
                if (VirtualModeList->Width == MonitorModeList->Width &&
                    VirtualModeList->Height == MonitorModeList->Height &&
                    VirtualModeList->Depth == MonitorModeList->Depth &&
                    VirtualModeList->RefreshRate == MonitorModeList->RefreshRate &&
                    MonitorModeList->ValidMode)
                {
                    bFoundMatchInVirtualList = TRUE;
                    break;
                }
                VirtualModeList++;

            }
            // If we did not find a match for this specified mode in the virtual mode list, this mode is not valid.
            if (bFoundMatchInVirtualList == FALSE)
            {
                // Not a valid mode.
                NumValidModes--;
                MonitorModeList++;
                continue;
            }

            // Now validate against the pixel frequency of the head.
            lpModeDesc->dwXRes = MonitorModeList->Width;
            lpModeDesc->dwYRes = MonitorModeList->Height;
            lpModeDesc->dwBpp = MonitorModeList->Depth;
            lpModeDesc->dwRefreshRate = MonitorModeList->RefreshRate;
            lpModeDesc->dwOriginalRefreshRate = MonitorModeList->RefreshRate;
            lpModeDesc->dwDevType = MaskToFindModeEntryDeviceType(pInput->ulDeviceMask);
            lpModeDesc->dwTVFormat = pInput->ulTVType;


            // We want to ignore the EDID since we are using the explicit monitor mode list.
            lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
            // Call the modeset DLL to see if this mode is valid.
            // We are not interested in the mode timings but just to see if this is a valid mode.
            VideoDebugPrint((3,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));

            ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                                  lpModeDesc, lpModeOut, lpModeNew);
            VideoDebugPrint((3,"ulRet: 0x%x\n",ulRet));
            VideoDebugPrint((3,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
            VideoDebugPrint((3,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

            if (ulRet != 0)
            {
                // Not a valid mode.
                NumValidModes--;
                MonitorModeList++;
                continue;
            }
            
            if((pInput->ulDeviceType == MONITOR_TYPE_FLAT_PANEL) && (HwDeviceExtension->ulDisableDfpModesGreaterThan))
            {
                ulWidth = HwDeviceExtension->ulDisableDfpModesGreaterThan >> 16;
                ulHeight = HwDeviceExtension->ulDisableDfpModesGreaterThan & 0xFFFF;
                if ((VirtualModeList->Width > ulWidth) && (VirtualModeList->Height > ulHeight))
                { 
                    // Not a valid mode.
                    NumValidModes--;
                    VirtualModeList++;
                    continue;
                }
            }

            // The mode passes all filters.
            // Copy this valid mode and process the next mode from the monitor modelist.
            if (DestPtr)
            {
                *DestPtr++ = *MonitorModeList++;
            }
            else
            {
                MonitorModeList++;
            }
        }
        *pRetSize = NumValidModes * sizeof(MODE_ENTRY);
        ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
        return(TRUE);
    }

    //
    // There is no specified monitor mode list for this head.
    // Now see if we need to parse the EDID.
    //
    if (pInput->ulEnableDDC)
    {
        // There is no monitor mode list for this head and DDC is enabled by the user for this head.
        // So we need to filter against pixel clock freq and EDID.
        if (pEdidUnit->Valid)
        {
            lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
        }
        else
        {
            lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
        }
    }
    else
    {
        // There is no monitor mode list for this head and DDC is disabled by the user for this head.
        // So we need to filter against pixel clock freq only.
        lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
        // BUGBUG: I am assuming that just setting the UNKNOWN_DEVICE is sufficient while still passing
        // in the EDID and EDIDSize into FindModeEntry().
    }
    // The user does not want EDID detection for this head.
    // We need to only do the filtering of all virtual list modes against the pixel clock.

    DestPtr = pInput->pPhysicalModeList;
    VirtualModeList = pInput->pVirtualModeList;

    NumVirtualModes = pInput->ulNumVirtualModes;
    NumValidModes = NumVirtualModes;
    EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

    lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(pInput->ulDeviceMask);
    lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(pInput->ulDeviceMask);
    lpModeDesc->MIDevData.cFormat   = (CHAR)pInput->ulTVType; 
    lpModeDesc->MIDevData.cReserved = 0x0;

    for (i=0; i < NumVirtualModes; i++)
    {

        // Now validate against the pixel frequency of the head.
        lpModeDesc->dwXRes = VirtualModeList->Width;
        lpModeDesc->dwYRes = VirtualModeList->Height;
        lpModeDesc->dwBpp  = VirtualModeList->Depth;
        lpModeDesc->dwRefreshRate   = VirtualModeList->RefreshRate;
        lpModeDesc->dwOriginalRefreshRate = VirtualModeList->RefreshRate;
        lpModeDesc->dwDevType       = MaskToFindModeEntryDeviceType(pInput->ulDeviceMask);
        lpModeDesc->dwTVFormat      = pInput->ulTVType;


        // Call the modeset DLL to see if this mode is valid.
        // We are not interested in the mode timings but just to see if this is a valid mode.
        VideoDebugPrint((3,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                         lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                         lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));

        ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                              lpModeDesc, lpModeOut, lpModeNew);
        VideoDebugPrint((3,"ulRet: 0x%x\n",ulRet));
        VideoDebugPrint((3,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
            lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
            lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
        VideoDebugPrint((3,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
            lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
            lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

        if (ulRet != 0)
        {
            // Not a valid mode.
            NumValidModes--;
            VirtualModeList++;
            continue;
        }

        if((pInput->ulDeviceType == MONITOR_TYPE_FLAT_PANEL) && (HwDeviceExtension->ulDisableDfpModesGreaterThan))
        {
            ulWidth = HwDeviceExtension->ulDisableDfpModesGreaterThan >> 16;
            ulHeight = HwDeviceExtension->ulDisableDfpModesGreaterThan & 0xFFFF;
            if ((VirtualModeList->Width > ulWidth) && (VirtualModeList->Height > ulHeight))
            { 
                // Not a valid mode.
                NumValidModes--;
                VirtualModeList++;
                continue;
            }
        }

        // The mode passes all filters.
        // Copy this valid mode and process the next mode from the monitor modelist.
        if (DestPtr)
        {
            *DestPtr++ = *VirtualModeList++;
        }
        else
        {
            VirtualModeList++;
        }
    }
    *pRetSize = NumValidModes * sizeof(MODE_ENTRY);
    ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    return(TRUE);
 
}



//
// This function initializes the mapping layer between Win2K's power states and nVidia's power states
//
VOID InitializeACPIStates(
    PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    BOOL bRet;
    ULONG Caps, ulHead;
    ULONG HighestNVAdapterState, i;
    TOSHIBA_HOTKEY_MODE ToshibaHotKeyMode;
    VP_STATUS status;
    ULONG ModeSetInitiated;
    ULONG InduceModeChange;
    ULONG ResumingFromAdapterPowerDownState;
    ULONG PrevDevMask;

    ulHead = 0;

    
    //
    // Note, at this point in time, it does not matter if we have actually done a modeset to the head or
    // not. Anyways, we support only two states for monitors. Its the capabilities of the adapter we
    // need to get.
    //
    bRet = RmGetPowerCaps(HwDeviceExtension->DeviceReference, ulHead, &Caps);

    //
    // Initialize the monitor power states
    //
    for (i=0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard; i++ )
    {
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerOn] = NV_POWER_MONITOR_STATE_0;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerStandBy] = NV_POWER_MONITOR_STATE_1;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerSuspend] = NV_POWER_MONITOR_STATE_1;            
        HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerOff] = NV_POWER_MONITOR_STATE_1;            
        //
        // If the RM exports an explicit monitor HIBERNATE state, we use that explicit state.
        // This explicit state would leave the monitor in an On state.
        // Otherwise, we map Hibernate to the Off state. Note that Win2K dictates that we use On state for
        // hibernate.
        //
        if (Caps & NV_POWER_MONITOR_STATE_HIBERNATE)
        {
            HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerHibernate] = NV_POWER_MONITOR_STATE_HIBERNATE;
        }
        else
        {
            HwDeviceExtension->NVMonitorPowerState[i][NV_VideoPowerHibernate] = NV_POWER_MONITOR_STATE_1;            
        }
    }

    //
    // Search for the highest supported adapter power state
    //
    if ((Caps & NV_POWER_ADAPTER_STATE_3) &&
        (Caps & NV_POWER_ADAPTER_STATE_1) &&
        (Caps & NV_POWER_ADAPTER_STATE_0))
    {
        //
        // This is the case for the desktop.
        //
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn] = NV_POWER_ADAPTER_STATE_0;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy] = NV_POWER_ADAPTER_STATE_1;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend] = NV_POWER_ADAPTER_STATE_3;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff] = NV_POWER_ADAPTER_STATE_3;            
        //
        // We support the hibernate state only if the "context save" feature is turned on.
        // If this feature is turned on, we assume that the highest numbered state (3 in this case)
        // will support this context save feature. If the RM exports an explicit HIBERNATE state,
        // then we use that explicit state.
        // This explicit state would leave the adaptor in an On state but does the save/restore.
        // Note that Win2K dictates that we use On state for hibernate.
        //
        if (Caps & NV_POWER_ADAPTER_FEATURE_CTXSAVED)
        {
            if (Caps & NV_POWER_ADAPTER_STATE_HIBERNATE)
            {
                HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_HIBERNATE;
            }
            else
            {
                HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_3;            
            }
        }
        else
        {
            HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = 0; // not supported
        }
     }

    if ((Caps & NV_POWER_ADAPTER_STATE_3) &&
        (Caps & NV_POWER_ADAPTER_STATE_2) &&
        (Caps & NV_POWER_ADAPTER_STATE_0))
    {
        //
        // This is the case for the laptop.
        //
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOn] = NV_POWER_ADAPTER_STATE_0;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerStandBy] = NV_POWER_ADAPTER_STATE_2;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerSuspend] = NV_POWER_ADAPTER_STATE_2;            
        HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerOff] = NV_POWER_ADAPTER_STATE_2;            
        //
        // We support the hibernate state only if the "context save" feature is turned on.
        // If this feature is turned on, we assume that the highest numbered state (3 in this case)
        // will support this context save feature. If the RM exports an explicit HIBERNATE state,
        // then we use that explicit state.
        // This explicit state would leave the adaptor in an On state but does the save/restore.
        // Note that Win2K dictates that we use On state for hibernate.
        //
        if (Caps & NV_POWER_ADAPTER_FEATURE_CTXSAVED)
        {
            if (Caps & NV_POWER_ADAPTER_STATE_HIBERNATE)
            {
                HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_HIBERNATE;
            }
            else
            {
                HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = NV_POWER_ADAPTER_STATE_3;            
            }
        }
        else
        {
            HwDeviceExtension->NVAdapterPowerState[NV_VideoPowerHibernate] = 0; // not supported
        }
     }

    // Hotkey Initialization.
    HwDeviceExtension->ulHotKeyPending = 0;
    ToshibaHotKeyMode.ValidMode = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"ForceGDIMode",
                                            FALSE,
                                            NVReadRegistryBinaryCallback,
                                            (PVOID)&ToshibaHotKeyMode);
    if (status == NO_ERROR)
    {
        if (ToshibaHotKeyMode.ValidMode == 1)
        {
            // Invalidate it. This may happen as a rare pathological condition.
            // For example, the user has hit the hotkey function, miniport has written the 'ToshibaHotKeyMode'
            // registry entry, but before the DrvEnablePdev or DrvAssertMode(TRUE) is called, system is rebooted.
            ToshibaHotKeyMode.ValidMode = 0;
            status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                    L"ForceGDIMode",
                                                    &ToshibaHotKeyMode,
                                                    sizeof(TOSHIBA_HOTKEY_MODE));
        }

    }

    // if the ModeSetInitiated registry key exists, set it to zero.
    ModeSetInitiated = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"NVCplInduceModeSetInitiated",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(ModeSetInitiated));
    if (status == NO_ERROR)
    {
        ModeSetInitiated = 0;
        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"NVCplInduceModeSetInitiated",
                                                &ModeSetInitiated,
                                                sizeof(ULONG));
    }

    // if the InduceModeChange registry key exists, set it to zero.
    InduceModeChange = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"InduceModeChange",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(InduceModeChange));
    if (status == NO_ERROR)
    {
        InduceModeChange = 0;
        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"InduceModeChange",
                                                &InduceModeChange,
                                                sizeof(ULONG));
    }

    // if the ResumingFromAdapterPowerDownState registry key exists, set it to zero.
    ResumingFromAdapterPowerDownState = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"ResumingFromAdapterPowerDownState",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(ResumingFromAdapterPowerDownState));
    if (status == NO_ERROR)
    {
        ResumingFromAdapterPowerDownState = 0;
        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"ResumingFromAdapterPowerDownState",
                                                &(ResumingFromAdapterPowerDownState),
                                                sizeof(ULONG));
    }

    // if the PrevDevMask registry key exists, set it to zero.
    PrevDevMask = 0;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            L"PrevDevMask",
                                            FALSE,
                                            NVRegistryCallback,
                                            &(PrevDevMask));
    if (status == NO_ERROR)
    {
        PrevDevMask = 0;
        status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                L"PrevDevMask",
                                                &(PrevDevMask),
                                                sizeof(ULONG));
    }

}

//
// Returns the index from the device mask.
// Input: A 32bit bitmask with only one of the 32bits set specifying a unique device
// Return Value: Index of this bitmask
//      For example: 
//      input: 0x4, Return: 2
//      input: 0x20, Return: 5
//      input: 0x1, Return: 0
//      input: 0x0, Return: 0
//
ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask)
{
    ULONG i;
    ULONG ulTmp;
    ulTmp = ulDeviceMask;

  
    i=0;
    for (;;)
    {
        if (ulTmp == 0)
        {
            VideoDebugPrint((1,"Oops! ConvertDeviceMaskToIndex(): Invalid ulDeviceMask: 0x%x\n",ulDeviceMask));
            return(0);
        }
        if (ulTmp & 0x1)
        {
            return(i);
        }
        // shift right by one and increment the index
        ulTmp >>= 1;
        i++;
    }
    
}

//
// Returns the number of bits that are set in the mask.
// 
ULONG ConvertConnectedMaskToNumDevices(
    ULONG ulConnectedDeviceMask)
{
    ULONG i, NumDevices, ulDeviceMask;
    NumDevices = 0;
    for(i=0; i < NV_NO_CONNECTORS; i++)
    {
        ulDeviceMask = (1 << i);
        if(ulConnectedDeviceMask & ulDeviceMask)
        {
            NumDevices++;
        }
    }
    return(NumDevices);

}

//
// Sets some safe default device masks in the hwdeviceExtension based on the current config returned by the miniport.
// Later we will read the TwinViewInfo registry data to see if should use the device masks specified in the registry
//
static VOID SetSafeDeviceMasks_SingleHeadBoard( PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG i;
    NV_DESKTOP_INFO * pInfo;
    
    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    
    pInfo->ulDeviceMask[0] = LOWESTBIT(pInfo->ulConnectedDeviceMask);
    if (pInfo->ulDeviceMask[0])
    {
        return;
    }

    // Something wrong. No devices are connected. So use a default CRT0.
    VideoDebugPrint((0,"Oops!  SetSafeDeviceMasks(): No devices connected. So assume CRT0"));
    pInfo->ulDeviceMask[0] = BITMASK_CRT0;
    return;
}

//
// We need to set up a safe standard mode device mask and deviceDisplay mapping array. This is needed for the special 
// case of the first time boot after driver install since there will no TwinViewInfo structure present after a 
// driver install.
// Later we will read the TwinViewInfo registry data to see if should use the device masks specified in the registry.
//
static VOID SetSafeDeviceMasks_DualHeadBoard( PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG i;
    ULONG DeviceMask;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;
    ULONG status;
    NV_DESKTOP_INFO * pInfo;

    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;

    for (i = 0; i < NV_NO_DACS; i++)
    {
        pInfo->ulDeviceMask[i] = BITMASK_INVALID_DEVICE;
    }


    if (pInfo->ulNumberDacsConnected == 0)
    {
        VideoDebugPrint((0,"Oops!  SetSafeDeviceMasks(): No devices connected. So assume CRT0\n"));
        pInfo->ulDeviceMask[0] = BITMASK_CRT0;
        pInfo->ulConnectedDeviceMask = BITMASK_CRT0;
        pInfo->ulNumberDacsConnected = 1;
        return;
    }

    if (pInfo->ulNumberDacsConnected == 1 || pInfo->ulNumberDacsConnected == 2)
    {
        for (i = 0; i < NV_NO_CONNECTORS; i++)
        {
            if (pInfo->ulConnectedDeviceMask & (1 << i))
            {
                DeviceMask = (1 << i);
                // Ask ResMan what head to use.
                nvConfig.DevicesConfig = DeviceMask;
                nvConfig.OldDevicesConfig = 0;
                nvConfig.OldDevicesAllocationMap = 0;
                nvConfig.DevicesAllocationMap = 0;

                
                if (!RmConfigGetExKernel (HwDeviceExtension->DeviceReference, 
                              NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
                {

                    VideoDebugPrint((0, "SetSafeDeviceMasks_DualHeadBoard - Cannot get DEVICES_CONFIG value from RM\n"));
                }
                else
                {
                    if (nvConfig.DevicesAllocationMap > 1)
                    {
                        VideoDebugPrint((0,"Oops! Invalid DevAllocationMap from RM: 0x%x\n",nvConfig.DevicesAllocationMap));
                    }
                    if (nvConfig.DevicesAllocationMap == 0)
                    {
                        pInfo->ulDeviceMask[0] = DeviceMask;
                        pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                        pInfo->ulDeviceDisplay[0] = 0;
                        pInfo->ulDeviceDisplay[1] = 1;
                    }
                    if (nvConfig.DevicesAllocationMap == 1)
                    {
                        pInfo->ulDeviceMask[1] = DeviceMask;
                        pInfo->ulDeviceMask[0] = BITMASK_INVALID_DEVICE;
                        pInfo->ulDeviceDisplay[0] = 1;
                        pInfo->ulDeviceDisplay[1] = 0;
                    }

                }
                return;
            }
        }
        return;
    }

}// end of SetSafeDeviceMasks_DualHeadBoard()

//
// Input: bitmask for a single device
// Return: device type of this device as expected by the display driver and the control panel.
//
ULONG MaskToDeviceType( ULONG ulDeviceMask)
{
    ULONG ulRet;

    if (ulDeviceMask & BITMASK_ALL_CRT) ulRet = MONITOR_TYPE_VGA; 
    else if (ulDeviceMask & BITMASK_ALL_DFP) ulRet = MONITOR_TYPE_FLAT_PANEL;
    else if (ulDeviceMask & BITMASK_ALL_TV) ulRet = MONITOR_TYPE_NTSC; 
    else ulRet = INVALID_DEVICE_TYPE;

    return(ulRet);
}

//
// Input: bitmask for a single device
// Return: device type of this device as expected by the common modeset code and FindModeEntry().
//
ULONG MaskToFindModeEntryDeviceType( ULONG ulDeviceMask)
{
    ULONG ulRet;

    if (ulDeviceMask & BITMASK_ALL_CRT) ulRet = DEVTYPE_CRT; 
    else if (ulDeviceMask & BITMASK_ALL_DFP) ulRet = DEVTYPE_DFP;
    else if (ulDeviceMask & BITMASK_ALL_TV) ulRet = DEVTYPE_TV; 
    else ulRet = INVALID_DEVICE_TYPE;

    return(ulRet);
}

//
// Input: bitmask for a single device
// Return: TV Format of this device. Currently returns only NTSC_M format
//
ULONG MaskToTVFormat( ULONG ulDeviceMask)
{
    return(NTSC_M);
}

//
// If the system is a desktop, this routine does nothing.
// If the system is a laptop, we should use the output deive posted by the BIOS for the desktop.
// We honor the BIOS output only at boot time.
// BUGBUG: Currently this function only handles a single output device posted by the BIOS.
// The code does not yet support when the BIOS posts to two devices (sort of BIOS clone mode).
// We follow the following Kevin K's specs for laptops:
//      If a single bit is enabled, that should be the primary boot device.  
//      If more than one bit is enabled, and Windows was previously in standard or clone mode,
//          the driver should enter clone mode with the associated devices.  I would give priority
//          (what gets chosen as the primary) to the LCD, CRT, then TV (in that order if bit enabled).
//      If more than one bit is enabled, and Windows was previously in extended mode,
//          the driver should remain in extended mode with the associated devices.  I would give
//          priority (what gets chosen as the primary) to the LCD, CRT, then TV (in that order if bit enabled).
//
//
VOID HandleBIOSHeads(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG ulHead;
    ULONG Status, RetSize;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;

    NV_DESKTOP_INFO * pInfo;
    NV_DESKTOP_INFO sOri;
    ULONG DeviceMask[NV_NO_DACS] = {0, 0};
    ULONG i, status;
    NVTWINVIEWDATA sData;
    NVTWINVIEW_DEVICE_TYPE_DATA  * pHeadData;
    NVTWINVIEW_DEVICE_TYPE_DATA  * pHead0, * pHead1;
    ULONG TwinViewDataPresent;
    ULONG Width, Height, Depth, Refresh;
    ULONG ulPrimaryHead;
    ULONG SwapHeadMapping;
    ULONG ulTmp;
    

    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
    
    // Save this structure off for later use.
    sOri = *pInfo;
    
    //
    // Initialize the registry keys to zero.
    //
    HwDeviceExtension->Mobile = 0;
    HwDeviceExtension->UseHWSelectedDevice = 0;
    HwDeviceExtension->GDIModePruning = 0;
    HwDeviceExtension->UseHotKeySameMode = 0;
    HwDeviceExtension->PanScanSelection = 0;
    HwDeviceExtension->EnableModesetStopImage = 0;
    HwDeviceExtension->EnumerateTVAsACPIDevice = 0;

    // Read the registry entry "Mobile" to see if we are on a desktop or laptop.
    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"Mobile",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->Mobile));
    VideoDebugPrint((3,"HwDeviceExtension->Mobile registry value: 0x%x\n",HwDeviceExtension->Mobile));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"UseHWSelectedDevice",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->UseHWSelectedDevice));
    VideoDebugPrint((3,"HwDeviceExtension->UseHWSelectedDevice registry value: 0x%x\n",HwDeviceExtension->UseHWSelectedDevice));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"GDIModePruning",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->GDIModePruning));
    VideoDebugPrint((3,"HwDeviceExtension->GDIModePruning registry value: 0x%x\n",HwDeviceExtension->GDIModePruning));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"UseHotKeySameMode",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->UseHotKeySameMode));
    VideoDebugPrint((3,"HwDeviceExtension->UseHotKeySameMode registry value: 0x%x\n",HwDeviceExtension->UseHotKeySameMode));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"PanScanSelection",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->PanScanSelection));
    VideoDebugPrint((3,"HwDeviceExtension->PanScanSelection registry value: 0x%x\n",HwDeviceExtension->PanScanSelection));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"EnableModesetStopImage",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->EnableModesetStopImage));
    VideoDebugPrint((3,"HwDeviceExtension->EnableModesetStopImage registry value: 0x%x\n",HwDeviceExtension->EnableModesetStopImage));

    Status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"EnumerateTVAsACPIDevice",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(HwDeviceExtension->EnumerateTVAsACPIDevice));
    VideoDebugPrint((3,"HwDeviceExtension->EnumerateTVAsACPIDevice registry value: 0x%x\n",HwDeviceExtension->EnumerateTVAsACPIDevice));


    if (HwDeviceExtension->UseHWSelectedDevice)
    {
        ULONG BIOSDeviceMask;
        // We are on a laptop (either dell or toshiba).
        // So we should use the same devices that the BIOS used for the desktop.
        // We honor the BIOS's selections only at boot time.
        if (HwDeviceExtension->SystemModeSetHasOccurred)
        {
            // A high res modeset has already occurred. So don't bother about the BIOS
            return;
           
        }
        
        // Read the twinviewinfo data from the registry if it is present.
        TwinViewDataPresent = 0;
        status = NVGetRegistryTwinviewInfo(HwDeviceExtension, &sData);
        if (status == NO_ERROR)
        {
            if (TwinViewDataOK(HwDeviceExtension, &sData))
            {
                TwinViewDataPresent = 1;
            }
        }
                


        if (!RmConfigGetKernel(HwDeviceExtension->DeviceReference,
                                  NV_CFG_GET_BOOT_DEVICES, &BIOSDeviceMask))
        {
            VideoDebugPrint((0,"Oops!    NV_CFG_GET_BOOT_DEVICES failed\n"));
        }

        VideoDebugPrint((1,"BIOSDeviceMask returned by ResMan: 0x%x\n",BIOSDeviceMask));

        // see if the BIOS had posted on a single device or two devices.
        if (ConvertConnectedMaskToNumDevices(BIOSDeviceMask) == 1)
        {
            // BIOS posted on a single device.
            if (TwinViewDataPresent == 0)
            {
                ulHead = pInfo->ulDeviceDisplay[0];
                if (pInfo->ulDeviceMask[ulHead] == BIOSDeviceMask)
                {
                    // Nothing to do.
                    return;
                }

            }

            // Ask ResMan for which head to use.
            // Ask ResMan what head to use.
            nvConfig.DevicesConfig = BIOSDeviceMask;
            nvConfig.OldDevicesConfig = 0;
            nvConfig.OldDevicesAllocationMap = 0;
            nvConfig.DevicesAllocationMap = 0;
            if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference,
                                     NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS)))
            {

                VideoDebugPrint((0, "SetSafeDeviceMasks_DualHeadBoard - Cannot get DEVICES_CONFIG value from RM\n"));
            }
            else
            {
                if (nvConfig.DevicesAllocationMap > 1)
                {
                    VideoDebugPrint((0,"Oops! Invalid DevAllocationMap from RM: 0x%x\n",nvConfig.DevicesAllocationMap));
                }
                if (nvConfig.DevicesAllocationMap == 0)
                {
                    pInfo->ulDeviceMask[0] = BIOSDeviceMask;
                    pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                    pInfo->ulDeviceDisplay[0] = 0;
                    pInfo->ulDeviceDisplay[1] = 1;
                }
                if (nvConfig.DevicesAllocationMap == 1)
                {
                    pInfo->ulDeviceMask[1] = BIOSDeviceMask;
                    pInfo->ulDeviceMask[0] = BITMASK_INVALID_DEVICE;
                    pInfo->ulDeviceDisplay[0] = 1;
                    pInfo->ulDeviceDisplay[1] = 0;
                }
            }

            if (TwinViewDataPresent)
            {
                ulHead = sData.dwDeviceDisplay[0];
                if ((sData.dwState == NVTWINVIEW_STATE_NORMAL || sData.dwState == NVTWINVIEW_STATE_DUALVIEW) && 
                    sData.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask == BIOSDeviceMask)
                {
                    // Nothing to do
                    return;
                }
                //
                // If the TwinViewInfo registry exists, we need to patch it to reflect the BIOS.
                // For the single BIOS device, we simply invalidate the registry.
                //
                // This functions also writes the invalidated TwinViewInfo structure to the registry.
                InvalidateTwinViewData(HwDeviceExtension, &sData);
            }
            
        }


        if (ConvertConnectedMaskToNumDevices(BIOSDeviceMask) >= 2)
        {
            // We need to do this only if the connfig has been changed underneath us such as by the
            // user hot-keying around in BIOS mode.
            if (pInfo->ulNumberDacsActive == 2)
            {
                // So we were in clone or multimon mode. Were we using the same BIOS devices?
                if ((pInfo->ulDeviceMask[0] | pInfo->ulDeviceMask[1]) == BIOSDeviceMask)
                {
                    // Nothing to do.
                    return;
                }

            }
            if (TwinViewDataPresent && (sData.dwState == NVTWINVIEW_STATE_CLONE || sData.dwState == NVTWINVIEW_STATE_SPAN))
            {
                // So we were in clone or multimon mode. Were we using the same BIOS devices?
                if ((sData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask | sData.NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask) 
                    == BIOSDeviceMask)
                {
                    // Nothing to do.
                    return;
                }

            }


            pInfo->ulDeviceDisplay[0] = 0;
            pInfo->ulDeviceDisplay[1] = 1;

            // Grab the first output device.
            DeviceMask[0] = LOWESTBIT(BIOSDeviceMask);
            DeviceMask[1] = LOWESTBIT(BIOSDeviceMask & ~DeviceMask[0]);

            // Ask ResMan what head to use for the devices.
            nvConfig.DevicesConfig = DeviceMask[0] | DeviceMask[1];
            nvConfig.OldDevicesConfig = 0;
            nvConfig.OldDevicesAllocationMap = 0;
            nvConfig.DevicesAllocationMap = 0;
            status = RmConfigGetExKernel (HwDeviceExtension->DeviceReference,
                                          NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS));
            if (status == 0)
            {

                VideoDebugPrint((0, "Oops! SetSafeDeviceMasks_DualHeadBoard - Cannot get DEVICES_CONFIG value from RM\n"));
                // Set to a safe single head mode.
                pInfo->ulNumberDacsConnected = 1;
                pInfo->ulConnectedDeviceMask = DeviceMask[0];
                pInfo->ulAllDeviceMask = DeviceMask[0];
                pInfo->ulDeviceMask[0] = DeviceMask[0];
                pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
            }
            else
            {
                // We got a successful head assignment for both the devices.
                switch (nvConfig.DevicesAllocationMap)
                {
                case 0x10:
                    // Head assignment 1, 0
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = DeviceMask[1];

                    break;
                case 0x01:
                    // Head assignment 0, 1
                    pInfo->ulDeviceMask[0] = DeviceMask[1];
                    pInfo->ulDeviceMask[1] = DeviceMask[0];
                    break;
                default:
                    VideoDebugPrint((0,"Oops! Unexpected head allocationMap: 0x%x\n",  nvConfig.DevicesAllocationMap));
                    // Set to a safe single head mode.
                    pInfo->ulNumberDacsConnected = 1;
                    pInfo->ulConnectedDeviceMask = DeviceMask[0];
                    pInfo->ulAllDeviceMask = DeviceMask[0];
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                    break;
                }

                for (i=0; i < pInfo->ulNumberDacsConnected; i++)
                {
                    pInfo->ulDeviceType[i] = MaskToDeviceType(pInfo->ulDeviceMask[i]);
                    pInfo->ulTVFormat[i] = MaskToTVFormat(pInfo->ulDeviceMask[i]);
                }
            }

            //
            // If the TwinViewInfo registry exists, we need to patch it to reflect the BIOS.
            // We patch the following fields.
            // - dwState
            // - dwDeviceDisplay
            // - DeviceMask
            // - DeviceType.
            // Note: We don't need to worry about the desktop resolution here since the DELL or Toshiba logic kicks in
            // DrvGetModes(). For example, on DELL where there is no pan-scan in standard mode, Windows may be in 16x12
            // on CRT Standard mode, the user may hotkey to DFP in BIOS, then Win2K will fall back to 8x6 or 6x4 since DrvGetModes() 
            // will filter out 16x12. TODO: It could be handled more elegantly by figuring out the best-fit mode for this
            // BIOS device and writing it into the ToshibaHotKeyMode registry entry. Later.
            //
            if (TwinViewDataPresent)
            {
                Width = sData.DeskTopRectl.right - sData.DeskTopRectl.left;
                Height = sData.DeskTopRectl.bottom - sData.DeskTopRectl.top;
                ulPrimaryHead = sData.dwDeviceDisplay[0];
                Depth = sData.NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwBpp;
                Refresh = sData.NVTWINVIEWUNION.nvtwdevdata[ulPrimaryHead].dwRefresh;
            }
            else
            {

                Width = sOri.ulDesktopWidth;
                Height = sOri.ulDesktopHeight;
                ulPrimaryHead = sOri.ulDeviceDisplay[0];
                Depth = sOri.ulDisplayPixelDepth[ulPrimaryHead];
                Refresh = sOri.ulDisplayRefresh[ulPrimaryHead];
            }


            // Set the desktop resolution.
            sData.DeskTopRectl.left = 0;
            sData.DeskTopRectl.top = 0;
            sData.DeskTopRectl.right = Width;
            sData.DeskTopRectl.bottom = Height;

            
            // If it does not exist or is standard/clone mode, create a full registry entry for clone mode.
            // Lets handle all cases the same for now. Later, we will need to remember the modes per device.
            if (TwinViewDataPresent == 0 || 
               (TwinViewDataPresent == 1 && (sData.dwState == NVTWINVIEW_STATE_NORMAL ||
                                             sData.dwState == NVTWINVIEW_STATE_DUALVIEW ||
                                             sData.dwState == NVTWINVIEW_STATE_CLONE)))
            {
                sData.dwState = NVTWINVIEW_STATE_CLONE;
                sData.dwAllDeviceMask = pInfo->ulAllDeviceMask;
                sData.dwConnectedDeviceMask = pInfo->ulConnectedDeviceMask;

                for (i=0; i < NV_NO_DACS; i++)
                {
                    sData.dwDeviceDisplay[i] = pInfo->ulDeviceDisplay[i];

                    pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);
                    pHeadData->dwDeviceMask = pInfo->ulDeviceMask[i];
                    pHeadData->dwDeviceType = pInfo->ulDeviceType[i];
                    pHeadData->dwTVFormat = pInfo->ulTVFormat[i];
                    //
                    // BUGBUG we should really remember the last mode info for each device and use that. Later.
                    //
                    pHeadData->dwBpp = Depth;
                    pHeadData->dwRefresh = Refresh;
                    pHeadData->VirtualRectl.left = 0;
                    pHeadData->VirtualRectl.top = 0;
                    pHeadData->VirtualRectl.right = Width;
                    pHeadData->VirtualRectl.bottom = Height;
                    pHeadData->PhysicalRectl.left = 0;
                    pHeadData->PhysicalRectl.top = 0;
                    pHeadData->PhysicalRectl.right = Width;
                    pHeadData->PhysicalRectl.bottom = Height;
                }
            }

            // Handle the special case of when windows is in spanning mode and BIOS is in clone mode.
            // Per Kevin's specs we need to put windows into spanning mode with the BIOS heads.
            if (TwinViewDataPresent == 1 && sData.dwState == NVTWINVIEW_STATE_SPAN)
            {
                sData.dwAllDeviceMask = pInfo->ulAllDeviceMask;
                sData.dwConnectedDeviceMask = pInfo->ulConnectedDeviceMask;

                for (i=0; i < NV_NO_DACS; i++)
                {
                    sData.dwDeviceDisplay[i] = pInfo->ulDeviceDisplay[i];
                    pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);
                    pHeadData->dwDeviceMask = pInfo->ulDeviceMask[i];
                    pHeadData->dwDeviceType = pInfo->ulDeviceType[i];
                    pHeadData->dwTVFormat = pInfo->ulTVFormat[i];
                }
            }

            // Now we have chosen wither clone or span mode.
            // Always make LCD/CRT the primary in that order.
            // We change the dvice mapping array to reflect that.
            ChoosePrimaryDevice(HwDeviceExtension, &sData);

            // Now write the TwinViewInfo to registry.
            NVSetRegistryTwinviewInfo(HwDeviceExtension, &sData);
        }
    }

    return;
}


VOID HandleDualviewHeads(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOLEAN bEnableDualView)
{
#if (_WIN32_WINNT >= 0x0500)
    ULONG ulHead;
    ULONG i, Status, TwinViewDataPresent = 0;
    NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS nvConfig;

    NV_DESKTOP_INFO *pInfo, *pInfo2;
    ULONG DeviceMask[NV_NO_DACS] = {0, 0}, SecondHeadMask;
    NVTWINVIEWDATA sData;
    NVTWINVIEW_DEVICE_TYPE_DATA  *pHeadData;
    ULONG ulConnectedDeviceMask;

    //
    // If Dualview, use ResMan default head setting
    //
    if (HwDeviceExtension->pDualViewAssociatedDE)
    {
        pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;
        pInfo2 = (NV_DESKTOP_INFO *) &HwDeviceExtension->pDualViewAssociatedDE->DeskTopInfo;
    
        // Read the twinviewinfo data from the registry if it is present.
        VideoPortZeroMemory(&sData, sizeof(sData));
        if (NVGetRegistryTwinviewInfo(HwDeviceExtension, &sData) == NO_ERROR)
        {
            if (TwinViewDataOK(HwDeviceExtension, &sData))
            {
                TwinViewDataPresent = 1;
            }
            else
            {
                VideoPortZeroMemory(&sData, sizeof(sData));
            }
        }

        if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE)
        {
            DeviceMask[0] = (pInfo->ulConnectedDeviceMask & BITMASK_ALL_DFP);
            if (DeviceMask[0] == 0)
            {
                // A laptop wothout LCD ??????
                ASSERT(FALSE);
                DeviceMask[0] = pInfo->ulAllDeviceMask & BITMASK_ALL_DFP;
                if (DeviceMask[0] == 0)
                    DeviceMask[0] = BITMASK_ALL_DFP;
            }
            DeviceMask[0] = LOWESTBIT(DeviceMask[0]);

            // Continue further and grab the next device.
            DeviceMask[1] = (pInfo->ulConnectedDeviceMask & ~DeviceMask[0]);
            if (DeviceMask[1] == 0)
            {
                // If on laptop, there is no devices other than LCD, force the secondary to be CRT0
                DeviceMask[1] = pInfo->ulAllDeviceMask & (~BITMASK_ALL_DFP);
                if (DeviceMask[1] == 0)
                {
                    ASSERT(FALSE);
                    DeviceMask[1] = BITMASK_CRT0;
                }
            }
            DeviceMask[1] = LOWESTBIT(DeviceMask[1]);

            ulConnectedDeviceMask = DeviceMask[0] | DeviceMask[1];
        }
        else
        {
            ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;
            // If on LCD/CRT/TV all exist, pick CLD and CRT
            if ((ulConnectedDeviceMask & BITMASK_ALL_CRT) &&
                (ulConnectedDeviceMask & BITMASK_ALL_TV) &&
                (ulConnectedDeviceMask & BITMASK_ALL_DFP))
                ulConnectedDeviceMask &= ~BITMASK_ALL_TV;
        }

        // Config the heads
        if (ConvertConnectedMaskToNumDevices(ulConnectedDeviceMask) > 1)
        {
            // Grab the first output device.
            DeviceMask[0] = LOWESTBIT(ulConnectedDeviceMask);
            DeviceMask[1] = LOWESTBIT(ulConnectedDeviceMask & ~DeviceMask[0]);

            // Ask ResMan what head to use for the devices.
            nvConfig.DevicesConfig = DeviceMask[0] | DeviceMask[1];
            nvConfig.OldDevicesConfig = 0;
            nvConfig.OldDevicesAllocationMap = 0;
            nvConfig.DevicesAllocationMap = 0;
            Status = RmConfigGetExKernel (HwDeviceExtension->DeviceReference,
                                          NV_CFGEX_GET_DEVICES_CONFIGURATION, &nvConfig, sizeof(NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS));
            if (Status == 0)
            {
                VideoDebugPrint((0, "Oops! HandleDualViewHeads - Cannot get DEVICES_CONFIG value from RM\n"));
                ASSERT(FALSE);
                if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE)
                {
                    pInfo->ulDeviceMask[0] = DeviceMask[1];
                    pInfo->ulDeviceMask[1] = DeviceMask[0];
                }
                else
                {
                    // Set to a safe single head mode.
                    pInfo->ulNumberDacsConnected = 1;
                    pInfo->ulConnectedDeviceMask = DeviceMask[0];
                    pInfo->ulAllDeviceMask = DeviceMask[0];
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                }
            }
            else
            {
                // We got a successful head assignment for both the devices.
                switch (nvConfig.DevicesAllocationMap)
                {
                case 0x10:
                    // Head assignment 1, 0
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = DeviceMask[1];
                    break;
                case 0x01:
                    // Head assignment 0, 1
                    pInfo->ulDeviceMask[0] = DeviceMask[1];
                    pInfo->ulDeviceMask[1] = DeviceMask[0];
                    break;
                default:
                    VideoDebugPrint((0,"Oops! Unexpected head allocationMap: 0x%x\n",  nvConfig.DevicesAllocationMap));
                    ASSERT(FALSE);
                    // Set to a safe single head mode.
                    pInfo->ulNumberDacsConnected = 1;
                    pInfo->ulConnectedDeviceMask = DeviceMask[0];
                    pInfo->ulAllDeviceMask = DeviceMask[0];
                    pInfo->ulDeviceMask[0] = DeviceMask[0];
                    pInfo->ulDeviceMask[1] = BITMASK_INVALID_DEVICE;
                    break;
                }

                for (i = 0; i < pInfo->ulNumberDacsConnected; i++)
                {
                    pInfo->ulDeviceType[i] = MaskToDeviceType(pInfo->ulDeviceMask[i]);
                    pInfo->ulTVFormat[i] = MaskToTVFormat(pInfo->ulDeviceMask[i]);
                }

                pInfo->ulDeviceDisplay[0] = 0;
                pInfo->ulDeviceDisplay[1] = 1;
                if ((HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_MOBILE) &&
                    (pInfo->ulDeviceMask[1] & BITMASK_ALL_DFP))
                {
                    pInfo->ulDeviceDisplay[0] = 1;
                    pInfo->ulDeviceDisplay[1] = 0;
                }

                VideoDebugPrint((2, "HandleDualviewHeads: ulDeviceMask[]={0x%x,0x%x}\n",
                                 pInfo->ulDeviceMask[0], pInfo->ulDeviceMask[1]));
                VideoDebugPrint((2, "                     ulDeviceDisplay[]={%d,%d}\n",
                                 pInfo->ulDeviceDisplay[0], pInfo->ulDeviceDisplay[1]));
            }

            // Second view reversed the head mapping
            for (i = 0; i < NV_NO_DACS; i++)
            {
                pInfo2->ulDeviceMask[i] = pInfo->ulDeviceMask[i];
                pInfo2->ulDeviceType[i] = pInfo->ulDeviceType[i];
                pInfo2->ulTVFormat[i] = pInfo->ulTVFormat[i];
            }
            sData.dwDeviceDisplay[0] = pInfo2->ulDeviceDisplay[1] = pInfo->ulDeviceDisplay[0];
            sData.dwDeviceDisplay[1] = pInfo2->ulDeviceDisplay[0] = pInfo->ulDeviceDisplay[1];
            sData.dwAllDeviceMask = pInfo2->ulAllDeviceMask = pInfo->ulAllDeviceMask;
            sData.dwConnectedDeviceMask = pInfo2->ulConnectedDeviceMask = pInfo->ulConnectedDeviceMask;

            if (bEnableDualView)
            {
                pInfo->ulTwinView_State = NVTWINVIEW_STATE_DUALVIEW;
            }
            else
            {
                if (sData.dwState == NVTWINVIEW_STATE_DUALVIEW || sData.dwState == NVTWINVIEW_STATE_NORMAL)
                {
                    pInfo->ulTwinView_State = NVTWINVIEW_STATE_NORMAL;
                    // Put secondary head to invalid device for primary view
                    ulHead = pInfo->ulDeviceDisplay[1];
                    pInfo->ulDeviceMask[ulHead] = BITMASK_INVALID_DEVICE;
                }
                else
                    pInfo->ulTwinView_State = sData.dwState;
            }
            sData.dwState = pInfo->ulTwinView_State;

            for (i = 0; i < NV_NO_DACS; i++)
            {
                sData.dwDeviceDisplay[i] = pInfo->ulDeviceDisplay[i];

                pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);
                pHeadData->dwDeviceMask = pInfo->ulDeviceMask[i];
                pHeadData->dwDeviceType = pInfo->ulDeviceType[i];
                pHeadData->dwTVFormat = pInfo->ulTVFormat[i];
            }

            // Now write the TwinViewInfo to registry.
            // Primary view needs to be updated only when Dualview is enabled or TwinViewData state
            // is not Spanning or Clone
            // A scenario would be from Dualview to Spanning mode.
            if (bEnableDualView || !TwinViewDataPresent ||
                sData.dwState == NVTWINVIEW_STATE_DUALVIEW || sData.dwState == NVTWINVIEW_STATE_NORMAL)
            {
                VideoPortZeroMemory(&sData.DeskTopRectl, sizeof(sData.DeskTopRectl));
                NVSetRegistryTwinviewInfo(HwDeviceExtension, &sData);
            }

            // Second view should always be updated.  It's only reversed head setting from primary view.
            // The state is always DUALVIEW
            pInfo2->ulTwinView_State = sData.dwState = NVTWINVIEW_STATE_DUALVIEW;
            for (i = 0; i < NV_NO_DACS; i++)
            {
                sData.dwDeviceDisplay[i] = pInfo2->ulDeviceDisplay[i];
                pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[i]);
                pHeadData->dwDeviceMask = pInfo2->ulDeviceMask[i];
            }
            VideoPortZeroMemory(&sData.DeskTopRectl, sizeof(sData.DeskTopRectl));
            NVSetRegistryTwinviewInfo(HwDeviceExtension->pDualViewAssociatedDE, &sData);
        }
        else
        {
            // At this point, we know CRT and LCD have to exist
            ASSERT(FALSE);
        }
    }
#endif
}

//
// Returns true if the tinviewData is safe. Otherwise returns FALSE>
//
BOOLEAN TwinViewDataOK(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData)
{
    BOOLEAN bRet = TRUE;
    ULONG i, ulHead, ulDeviceMask;

    if (pData->DeskTopRectl.left == 0 && pData->DeskTopRectl.top == 0 && 
        pData->DeskTopRectl.right == 0 && pData->DeskTopRectl.bottom == 0)
    {
        
        return(FALSE);
    }

    if (pData->dwState != NVTWINVIEW_STATE_SPAN && pData->dwState != NVTWINVIEW_STATE_CLONE &&
        pData->dwState != NVTWINVIEW_STATE_DUALVIEW && pData->dwState != NVTWINVIEW_STATE_NORMAL) 
    {
       
        return(FALSE);
    }

    if ((pData->dwState == NVTWINVIEW_STATE_NORMAL || pData->dwState == NVTWINVIEW_STATE_DUALVIEW) && pData->dwDeviceDisplay[0] > 1)
    {
       
       return(FALSE);
    }

    if (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE)
    {
        if (pData->dwDeviceDisplay[0] > 1 || 
            pData->dwDeviceDisplay[1] > 1 ||
            (pData->dwDeviceDisplay[0] == 0 && pData->dwDeviceDisplay[1] == 0) ||
            (pData->dwDeviceDisplay[0] == 1 && pData->dwDeviceDisplay[1] == 1))
        {
       
            return(FALSE);
        }
    }

    if (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE) 
    {
        if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp != pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp)
        {
       
            return(FALSE);
        }
    }


    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwBpp == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].dwBpp == 0)
    {
       
        return(FALSE);
    }

    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].dwRefresh == 0)
    {
       
        return(FALSE);
    }
    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].VirtualRectl.bottom == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].VirtualRectl.bottom == 0)
    {
       
        return(FALSE);
    }

    if (pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[0].PhysicalRectl.bottom == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.left == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.top == 0 
        && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.right == 0 && pData->NVTWINVIEWUNION.nvtwdevdata[1].PhysicalRectl.bottom == 0)
    {
       
        return(FALSE);
    }

    // If there is just one head on the board and the registry says any mode other than normal, mark it as invalid.
    if (hwDeviceExtension)
    {

        if (hwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard == 1 &&
            (pData->dwState == NVTWINVIEW_STATE_SPAN || pData->dwState == NVTWINVIEW_STATE_CLONE))
        {
       
            return(FALSE);
        }
    }

    // Check to see if the user has swapped the board
    if (pData->dwAllDeviceMask != hwDeviceExtension->DeskTopInfo.ulAllDeviceMask)
    {
        return(FALSE);
    }

    // Now check to see if the output device specified in the registry are actually present in this
    // current configuration.
    if (pData->dwState == NVTWINVIEW_STATE_NORMAL || pData->dwState == NVTWINVIEW_STATE_DUALVIEW)
    {
        ulHead = pData->dwDeviceDisplay[0];
        ulDeviceMask = pData->NVTWINVIEWUNION.nvtwdevdata[ulHead].dwDeviceMask;
        if (!(ulDeviceMask & hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask))
        {
            // The specified device is no longer connected
            return(FALSE);
        }
    }
    
    // Check the connected devices for clone/span modes.
    if (pData->dwState == NVTWINVIEW_STATE_CLONE || pData->dwState == NVTWINVIEW_STATE_SPAN)
    {
        ulDeviceMask = pData->NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceMask;
        if (!(ulDeviceMask & hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask))
        {
            // The specified device is no longer connected
            return(FALSE);
        }
        ulDeviceMask = pData->NVTWINVIEWUNION.nvtwdevdata[1].dwDeviceMask;
        if (!(ulDeviceMask & hwDeviceExtension->DeskTopInfo.ulConnectedDeviceMask))
        {
            // The specified device is no longer connected
            return(FALSE);
        }
    }
    return(TRUE);
}

//
// Invalidates the twinview data and writes back to the registry. Ideally we would have just wanted to delete
// the TwinViewInfo structure registry entry but we can not delete registry entries from the miniport.
//
VOID InvalidateTwinViewData(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData)
{
    VideoPortZeroMemory(&pData->DeskTopRectl, sizeof(pData->DeskTopRectl));
    
    NVSetRegistryTwinviewInfo(hwDeviceExtension, pData);
    return;
}

//
// Select the primary device correctly.
// For laptops, we want LCD/CRT/TV in that order.
// For desktops, this function does nothing.
// This function updates both the pData and the hwDevExt->DeskTopInfo structures.
//
VOID ChoosePrimaryDevice(PHW_DEVICE_EXTENSION HwDeviceExtension, NVTWINVIEWDATA *pData)
{
    NV_DESKTOP_INFO * pInfo;
    NVTWINVIEW_DEVICE_TYPE_DATA  * pHead0, * pHead1;
    ULONG SwapHeadMapping;
    ULONG ulTmp;

    pInfo = &HwDeviceExtension->DeskTopInfo;
    pHead0 = &(pData->NVTWINVIEWUNION.nvtwdevdata[0]);
    pHead1 = &(pData->NVTWINVIEWUNION.nvtwdevdata[1]);

    // Initialize the flag to zero.
    SwapHeadMapping = 0;
    if (pData->dwDeviceDisplay[0] == 0)
    {
        // Head0 is the primary. 
        // Now check the physical head types to make DFP the primary device.
        if ((pHead0->dwDeviceType == MONITOR_TYPE_VGA && pHead1->dwDeviceType == MONITOR_TYPE_FLAT_PANEL) ||
            ((pHead0->dwDeviceType == MONITOR_TYPE_NTSC || pHead0->dwDeviceType == MONITOR_TYPE_PAL) && 
             pHead1->dwDeviceType == MONITOR_TYPE_FLAT_PANEL))
        {
            // We need to swap the primary device.
            SwapHeadMapping = 1;
        }

        // Now check the physical head types to make CRT the primary device.
        if ((pHead0->dwDeviceType == MONITOR_TYPE_NTSC || pHead0->dwDeviceType == MONITOR_TYPE_PAL) && 
            pHead1->dwDeviceType == MONITOR_TYPE_VGA)
        {
            // We need to swap the primary device.
            SwapHeadMapping = 1;
        }
    }

    if (pData->dwDeviceDisplay[0] == 1)
    {
        // Head1 is the primary. 
        // Now check the physical head types to make DFP the primary device.
        if ((pHead1->dwDeviceType == MONITOR_TYPE_VGA && pHead0->dwDeviceType == MONITOR_TYPE_FLAT_PANEL) ||
            ((pHead1->dwDeviceType == MONITOR_TYPE_NTSC || pHead1->dwDeviceType == MONITOR_TYPE_PAL) && 
             pHead0->dwDeviceType == MONITOR_TYPE_FLAT_PANEL))
        {
            // We need to swap the primary device.
            SwapHeadMapping = 1;
        }

        // Now check the physical head types to make CRT the primary device.
        if ((pHead1->dwDeviceType == MONITOR_TYPE_NTSC || pHead1->dwDeviceType == MONITOR_TYPE_PAL) && 
            pHead0->dwDeviceType == MONITOR_TYPE_VGA)
        {
            // We need to swap the primary device.
            SwapHeadMapping = 1;
        }
    }

    // Swap the head mapping if we need to
    if (SwapHeadMapping)
    {
        // Swap the registry data
        ulTmp = pData->dwDeviceDisplay[0];
        pData->dwDeviceDisplay[0] = pData->dwDeviceDisplay[1];
        pData->dwDeviceDisplay[1] = ulTmp;

        // Swap the incore data in HwDevExt.
        ulTmp = pInfo->ulDeviceDisplay[0];
        pInfo->ulDeviceDisplay[0] = pInfo->ulDeviceDisplay[1];
        pInfo->ulDeviceDisplay[1] = ulTmp;
    }
}

//
// Verifies if the DFP supports 1400x1050. This is done if the EnablePanScanAl lregistry entry is set.
// This routine should be called after nvInitialize_dacsAndEdid(),InitializeCommonModeSetCode() 
// have been called.
//
VOID Verify1400x1050DFP(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    LPDISPDATA lpDispData;
    LPMODEINFO lpModeDesc;
    LPMODEOUT  lpModeOut;
    LPMODEINFO lpModeNew;
    ULONG ulFrequencyHead;
    DISPDATA DispData;
    MODEINFO ModeDesc;
    MODEOUT  ModeOut;
    MODEINFO ModeNew;

    NV_DESKTOP_INFO *pInfo;
    ULONG ulDeviceMask;
    ULONG ulHead, ulIndex, ulRet;
    LPEDID_UNIT pEdidUnit;

    VideoDebugPrint((1,"Verify1400x1050DFP()\n"));

    pInfo = &HwDeviceExtension->DeskTopInfo;
    HwDeviceExtension->ulDFPSupports1400x1050 = 0;

    // Test the conditions to enable this check.
    if ((pInfo->ulConnectedDeviceMask & 0xFF0000) == 0)
    {
        // No DFP in this system, so return.
        return;
    }

    if (HwDeviceExtension->PanScanSelection != PAN_SCAN_SELECTION_ENABLE_ALL)
    {
        // We are not asked to pan scan always. So return.
        return;
    }

    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;

    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    lpModeDesc->dwXRes = 1400;
    lpModeDesc->dwYRes = 1050;
    lpModeDesc->dwBpp = 8;
    lpModeDesc->dwRefreshRate = 60;
    lpModeDesc->dwOriginalRefreshRate = 60;

    // DFP goes to physical head 0.
    ulHead = 1;
    ulDeviceMask = 0x10000;
    ulIndex = ConvertDeviceMaskToIndex(ulDeviceMask);
    pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulIndex];
    ulFrequencyHead = 0;

    if (pEdidUnit->Valid)
    {
        lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
    }
    else
    {
        lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
    }
    lpDispData->dwCRTCIndex = ulHead;
    lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];

    // Now validate against the pixel frequency of the head.

    lpModeDesc->dwDevType  = MaskToFindModeEntryDeviceType(ulDeviceMask);
    lpModeDesc->dwTVFormat = 0;

    lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(ulDeviceMask);
    lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(ulDeviceMask);
    lpModeDesc->MIDevData.cFormat   = (CHAR)0;
    lpModeDesc->MIDevData.cReserved = 0x0;

    // Call the modeset DLL to see if this mode is valid.
    // We are not interested in the mode timings but just to see if this is a valid mode.
    VideoDebugPrint((1,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                     lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((1,"ulDeviceMask: 0x%x, ulIndex: %d, MonitorInfType: 0x%x, EDIDBufferValid: 0x%x\n",
                     ulDeviceMask, ulIndex, lpDispData->dwMonitorInfType, pEdidUnit->Valid));

    EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                          lpModeDesc, lpModeOut, lpModeNew);
    ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    VideoDebugPrint((1,"ulRet: 0x%x\n",ulRet));
    VideoDebugPrint((1,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                     lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((1,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                     lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                     lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));

    if (ulRet != 0)
    {
        // This mode is not physically supported.
        HwDeviceExtension->ulDFPSupports1400x1050 = 0;
        return;
    }

    // BUGBUG: FindModeEntry returns 0 even if the DFP does not support this mode. Not sure why.
    // So check the lpModeNew also as a backup test.
    if (lpModeNew->dwXRes != lpModeDesc->dwXRes ||
        lpModeNew->dwYRes != lpModeDesc->dwYRes ||
        lpModeNew->dwBpp != lpModeDesc->dwBpp ||
        lpModeNew->dwRefreshRate != lpModeDesc->dwRefreshRate
        )
    {
        // This mode is not physically supported.
        HwDeviceExtension->ulDFPSupports1400x1050 = 0;
        return;
    }


    // This mode is natively supported.
    HwDeviceExtension->ulDFPSupports1400x1050 = 1;
    
    return;
}


//   DetectNextDevice   walks thru the bus (specified indirectly thru pHDE) starting at (*pulPrevDevice + 1) and checks for 
//                      presense of nvidia boards. It returns the Vendos/Device ID of the found board and the slot where it 
//                      is located on the bus (*pulPrevDevice). If bClaimResources is TRUE it also claims the boards memory
//                      access ranges in the registry (using VideoPortGetAccessRanges). As a result it also indicates whether
//                      the board is our primary device (VGA is enabled) or a secondary device in *pbIsPrimaryDevice.
//
VP_STATUS DetectNextDevice( IN      PHW_DEVICE_EXTENSION  pHDE,                     // our devices 'global' data struct
                            IN OUT  ULONG                 *pulPrevDevice,           // in : slot where the last nvidia device was detected (or where the search begins)
                                                                                    // out: slot where the next nvidia device is located                                                                                    
                                                                                    // NOTE: can be 0xffffffff : start looking at dev 0 and must be lower than 32 (5bit)
                            IN      ULONG                 ulNumAccessRanges,        // is needed the to claim the resources, for now it's always 2
                               OUT  PVIDEO_ACCESS_RANGE   pAccessRanges,            // if bClaimResources == TRUE this exports the device's mapping
                               OUT  USHORT                *pusVendorID,             // 
                               OUT  USHORT                *pusDeviceID,             //
                               OUT  BOOLEAN               *pbIsPrimaryDevice,       // 
                            IN      BOOLEAN               bClaimResources)          //
{
    VP_STATUS         status = ERROR_DEV_NOT_EXIST;
    ULONG             ulDevice;
    PCI_SLOT_NUMBER   psnSlot;

    ASSERT(pHDE);
    ASSERT(pulPrevDevice);
    ASSERT((*pulPrevDevice == 0xffffffff) || (*pulPrevDevice < PCI_MAX_DEVICES));
    ASSERT(2 == ulNumAccessRanges);
    ASSERT(pAccessRanges);
    ASSERT(pusVendorID);
    ASSERT(pusDeviceID);
    ASSERT(pbIsPrimaryDevice);

    if ((*pulPrevDevice == 0xffffffff) || (*pulPrevDevice < (PCI_MAX_DEVICES - 1)))  // no need to look behind slot 31
    {
        //
        // walk thru our bus and try to detect nvidia boards
        //
        for (ulDevice = *pulPrevDevice + 1; ulDevice < PCI_MAX_DEVICES; ulDevice++)
        {
            psnSlot.u.bits.DeviceNumber  = ulDevice;
            psnSlot.u.bits.FunctionNumber= 0;
            psnSlot.u.bits.Reserved      = 0;

            status = DetectDevice(pHDE, 
                                psnSlot, 
                                ulNumAccessRanges, 
                                pAccessRanges,
                                pusVendorID,
                                pusDeviceID,
                                pbIsPrimaryDevice, 
                                bClaimResources);

            if (NO_ERROR == status)
            {
                // 
                // return slot # 
                //
                *pulPrevDevice = psnSlot.u.AsULONG;
                break;
            }
        }
    }
    return status;
}


//
// Sets the display resolution to the highest supported resolution at 16BPP. The refresh rate chosen will be the
// highest supported at this resolution.
// Note: Currently this logic is supported only if we are booting into Standard mode.
//
VOID HandleBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    ULONG ulHead, ulDeviceMask, ulEDIDIndex, ulDeviceType, ulMaxTVOutResolution;
    ULONG UseBestResolution;
    NV_DESKTOP_INFO *pInfo;
    MODE_ENTRY BestMode;
    ULONG ulRet;
    ULONG RegStatus;

    UseBestResolution = 0;
    pInfo = &HwDeviceExtension->DeskTopInfo;


    RegStatus = VideoPortGetRegistryParameters(HwDeviceExtension,
                    L"UseBestResolution",
                    FALSE,
                    NVRegistryCallback,
                    &(UseBestResolution));

    // Get the best resolution for this chosen device.
    // Handle only the case when we are going to boot into single device standard mode.
    if (pInfo->ulNumberDacsActive == 1)
    {
        if (RegStatus == NO_ERROR && UseBestResolution == 1)
        {
            LPEDID_UNIT pEdidUnit;

            ulHead = pInfo->ulDeviceDisplay[0];
            ulDeviceMask = pInfo->ulDeviceMask[ulHead];
            ulDeviceType = MaskToDeviceType(ulDeviceMask);
            ulEDIDIndex = ConvertDeviceMaskToIndex(ulDeviceMask);
            pEdidUnit = HwDeviceExtension->EdidCollection->HeadMaps[ulEDIDIndex];

            // If there is a valid EDID for CRT or DFP, process it. Otherwise, do nothing.
            if (ulDeviceType == MONITOR_TYPE_VGA || ulDeviceType == MONITOR_TYPE_FLAT_PANEL)
            {
                if (pEdidUnit->Valid)
                {
                    // parse the EDID
                    ulRet = GetBestResolution(HwDeviceExtension, ulEDIDIndex, ulHead, ulDeviceMask, &BestMode);
                    if (ulRet)
                    {
                        BestMode.ValidMode = 1;
                        CheckForcedResolution(HwDeviceExtension, BestMode.Width, BestMode.Height, 
                            BestMode.Depth, BestMode.RefreshRate, TRUE);
                    }
                }
            }

            // If the device is TV, we pick the best resolution.
            if (ulDeviceType == MONITOR_TYPE_NTSC || ulDeviceType == MONITOR_TYPE_PAL)
            {
                ulMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;
                BestMode.ValidMode = 1;
                BestMode.Width = (USHORT)((ulMaxTVOutResolution & 0xffff0000) >> 16);
                BestMode.Height = (USHORT)(ulMaxTVOutResolution & 0xffff);
                BestMode.Depth = 32;
                BestMode.RefreshRate = 60;
                CheckForcedResolution(HwDeviceExtension, BestMode.Width, BestMode.Height, 
                    BestMode.Depth, BestMode.RefreshRate, TRUE);
                
            }
        } // if UseBestResolution == 1

        else
        {
            // Else, even if UseBestResolution flag was cleared, we could be in 
            // the middle of a one-time-after-reboot-forced-mode sequence so
            // we NEED to check the status of this sequence so DrvEnablePdev
            // will be able to force the mode since we are now passing again
            // in hwinit() (rebooted)
            // (see CheckForcedResolution() (in this file) for details)

            // Even if a one-time-forced-mode sequence is active, only pursue it
            // if we are in standard mode...            
            
            // Note that when setbestresolution (last param) is FALSE, the modeinfo
            // is not used anyways -> see checkforced...
            //
            CheckForcedResolution(HwDeviceExtension, 640, 480, 4, 1, FALSE);

        }


    } // if standard mode
        

    // If the regkey exists, set it to 0.
    if (RegStatus == NO_ERROR && UseBestResolution == 1)
    {
        UseBestResolution = 0;
        VideoPortSetRegistryParameters(HwDeviceExtension,
                    L"UseBestResolution",
                    &UseBestResolution,
                    sizeof(ULONG));
    }

        
    // done
    return;
}

//
// If the twinViewInfo registry structure is present and is valid, use twinVieInfo to initiliaze the 
// fields in HwDeviceExtension strutcure.
// This handles the case when UseHwSelectedDevice has been disabled such as on compal. We still need to initialize
// device masks correctly so that at boot time, GET_CHILD_STATE returns the correct device state for
// ACPI systems. This ensures Win2K uses the correct resolution to bootup.
//
// Note: 
// - This function should be called just once, at boot time.
//
VOID InitFromTwinViewInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    NVTWINVIEWDATA sData;
    NVTWINVIEW_DEVICE_TYPE_DATA * pHeadData;
    ULONG ulCombinedMask;
    NV_DESKTOP_INFO * pInfo;
    ULONG i,j, ulHead;
    VP_STATUS Status;

    VideoDebugPrint((1, "InitFromTwinViewInfo():\n"));
    pInfo = (NV_DESKTOP_INFO *) &HwDeviceExtension->DeskTopInfo;

    //
    // Read in the twinview info structure
    //
    if (NVGetRegistryTwinviewInfo(HwDeviceExtension, &sData) != NO_ERROR) 
    {
        return;
    }

    //
    // See if the twinviewInfo is valid before using it.
    //
    if (TwinViewDataOK(HwDeviceExtension, &sData))
    {
        pInfo->ulDesktopWidth = sData.DeskTopRectl.right - sData.DeskTopRectl.left;
        pInfo->ulDesktopHeight = sData.DeskTopRectl.bottom - sData.DeskTopRectl.top;
        pInfo->ulTwinView_State = sData.dwState;

        //
        // Set the number of active dacs based on the mode.
        //
        if (sData.dwState == NVTWINVIEW_STATE_NORMAL || sData.dwState == NVTWINVIEW_STATE_DUALVIEW)
        {
            pInfo->ulNumberDacsActive = 1;
        }
        if (sData.dwState == NVTWINVIEW_STATE_CLONE)
        {
            pInfo->ulNumberDacsActive = 2;
        }
        if (sData.dwState == NVTWINVIEW_STATE_SPAN)
        {
            if (MULTIMON_MODE(pInfo->ulDesktopWidth, pInfo->ulDesktopHeight))
            {
                pInfo->ulNumberDacsActive = 2;
            }
            else
            {
                pInfo->ulNumberDacsActive = 1;
            }
        }
        
        //
        // Transfer the head mapping array,device masks and other info for the clone, spanning and standard modes.
        //
        if (sData.dwState == NVTWINVIEW_STATE_CLONE || sData.dwState == NVTWINVIEW_STATE_NORMAL ||
            sData.dwState == NVTWINVIEW_STATE_DUALVIEW || sData.dwState == NVTWINVIEW_STATE_SPAN)
        {
            for (i=0; i < pInfo->ulNumberDacsActive; i++)
            {
                ulHead = sData.dwDeviceDisplay[i];
                pInfo->ulDeviceDisplay[i] = ulHead;
                pHeadData = &(sData.NVTWINVIEWUNION.nvtwdevdata[ulHead]);
                pInfo->ulDeviceMask[ulHead] = pHeadData->dwDeviceMask;
                pInfo->ulDeviceType[ulHead] = pHeadData->dwDeviceType;
                pInfo->ulTVFormat[ulHead] = pHeadData->dwTVFormat;
                pInfo->ulDisplayWidth[ulHead] = pHeadData->PhysicalRectl.right - pHeadData->PhysicalRectl.left;
                pInfo->ulDisplayHeight[ulHead] = pHeadData->PhysicalRectl.bottom - pHeadData->PhysicalRectl.top;
                pInfo->ulDisplayRefresh[ulHead] = pHeadData->dwRefresh;
                pInfo->ulDisplayPixelDepth[ulHead] = pHeadData->dwBpp;
            }
        }
        else
        {
            ASSERT(FALSE);
        }
    }

    return;
}

// Writes the current flat panel scaling mode to the registry.
// Temporary until resman is able to do this in a more timely fashion.
ULONG WriteFPModeToRegistry (PHW_DEVICE_EXTENSION hwDeviceExtension)
{   
    BOOL   fpstatus = 0;
    ULONG  head;
    ULONG  i;
    NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS fpGetParams; 
     
                                      
    for (i=0;i<hwDeviceExtension->DeskTopInfo.ulNumberDacsActive; i++)
    {
        head = hwDeviceExtension->DeskTopInfo.ulDeviceDisplay[i];
        if(MaskToDeviceType(hwDeviceExtension->DeskTopInfo.ulDeviceMask[head]) ==
                            MONITOR_TYPE_FLAT_PANEL)
        {
            fpGetParams.Head = head;
            fpstatus = RmConfigGetExKernel(hwDeviceExtension->DeviceReference,
                                NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI,
                                &(fpGetParams), 
                                sizeof(NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS));

            if( fpstatus == TRUE && 
                fpGetParams.FlatPanelMode  <= 2 )
            {
                VideoPortSetRegistryParameters(hwDeviceExtension,
                                  L"FlatPanelMode",
                                  &fpGetParams.FlatPanelMode,
                                  sizeof(ULONG));
            } //if scaling mode is reasonable
        }//if flat panel
    }//for each active dac
    return fpGetParams.FlatPanelMode;
} //end WriteFPModeToRegistry.

//
// Reads the SaveSettings into the hwDevExtension from the registry and returns TRUE.
// If the registry entry is absent, returns FALSE.
//
BOOLEAN bReadSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    VP_STATUS RegStatus;
    RegStatus = VideoPortGetRegistryParameters(
                        hwDeviceExtension,
                        L"SaveSettings",
                        FALSE,
                        NVReadRegistrySaveSettingsCallback,
                        hwDeviceExtension->SaveSettings);
    if (RegStatus == NO_ERROR)
    {
    
        return(TRUE);
    }
    VideoDebugPrint((1,"SaveSettings regKey could not be read: error: 0x%x\n",RegStatus));
    return(FALSE);
}

//
// Debug helper routine to print the SaveSettings table.
//
VOID vPrintSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    ULONG i, ulHead;
    ULONG ulDeviceMask, ulDeviceMask0, ulDeviceMask1;
    NVTWINVIEWDATA *pData;
    NVTWINVIEW_DEVICE_TYPE_DATA *pDevData0, *pDevData1;
    CHAR *pcMode;

    for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        switch (pData->dwState)
        {
        case NVTWINVIEW_STATE_NORMAL:
            pcMode = "Standard";
            break;
        case NVTWINVIEW_STATE_CLONE:
            pcMode = "Clone";
            break;
        case NVTWINVIEW_STATE_SPAN:
            pcMode = "Spanning";
            break;
        default:
            pcMode = "Invalid mode";
            break;
        }
        VideoDebugPrint((1,"%d: %s,%d,  (%d,%d), (0x%x, %d), (0x%x, %d)\n",i,
            pcMode, pData->dwOrientation, pData->dwDeviceDisplay[0], pData->dwDeviceDisplay[1], 
            pDevData0->dwDeviceMask, pDevData0->dwTVFormat, pDevData1->dwDeviceMask, pDevData1->dwTVFormat));

        if (pData->DeskTopRectl.left == 0 && pData->DeskTopRectl.top == 0 &&
            pData->DeskTopRectl.right == 0 && pData->DeskTopRectl.bottom == 0)   
        {
            // don't print this since this slot is not valid.
        }
        else
        {
            // This slot is valid and occupied. Print the mode info.
            VideoDebugPrint((1, "   Desktop: (%d, %d), (%d, %d)\n", 
                pData->DeskTopRectl.left,pData->DeskTopRectl.top,pData->DeskTopRectl.right, pData->DeskTopRectl.bottom));
            VideoDebugPrint((1,"    Head0 virt: (%d, %d), (%d, %d)\n",
                pDevData0->VirtualRectl.left,pDevData0->VirtualRectl.top,pDevData0->VirtualRectl.right,pDevData0->VirtualRectl.bottom));
            VideoDebugPrint((1,"    Head0 phys: (%d, %d), (%d, %d), %dbpp, %dHZ\n",
                pDevData0->PhysicalRectl.left,pDevData0->PhysicalRectl.top,pDevData0->PhysicalRectl.right,pDevData0->PhysicalRectl.bottom,
                pDevData0->dwBpp, pDevData0->dwRefresh));
            VideoDebugPrint((1,"    Head1 virt: (%d, %d), (%d, %d)\n",
                pDevData1->VirtualRectl.left,pDevData1->VirtualRectl.top,pDevData1->VirtualRectl.right,pDevData1->VirtualRectl.bottom));
            VideoDebugPrint((1,"    Head0 phys: (%d, %d), (%d, %d), %dbpp, %dHZ\n",
                pDevData1->PhysicalRectl.left,pDevData1->PhysicalRectl.top,pDevData1->PhysicalRectl.right,pDevData1->PhysicalRectl.bottom,
                pDevData1->dwBpp, pDevData1->dwRefresh));
            VideoDebugPrint((1,"\n"));
        }
        
    }

    return;
}

//
// Writes the SaveSettings from hwDeviceExtension into registry
//
VOID vWriteSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    VP_STATUS RegStatus;

    RegStatus = VideoPortSetRegistryParameters(hwDeviceExtension,
                           L"SaveSettings",
                           hwDeviceExtension->SaveSettings,
                           sizeof(hwDeviceExtension->SaveSettings));
    return;
}

//
// If the "SaveSettings" is absent (as with fresh driver installation), creates the structure in registry. 
// If the "SaveSettings" is present but invalid (as with manual driver binary loads), resets the structure.
// If the "SaveSettings" is present and valid, then does nothing.
// Should be called once at boot time.
// Supported devices for now are CRT0, LCD, TV and CRT1
//
VOID vInitializeSaveSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension)
{
    ULONG i, ulHead;
    ULONG ulDeviceMask, ulDeviceMask0, ulDeviceMask1;
    VP_STATUS RegStatus;
    NVTWINVIEWDATA *pData;
    NVTWINVIEW_DEVICE_TYPE_DATA *pDevData0, *pDevData1;

    VideoDebugPrint((1,"Enter vInitializeSaveSettings\n"));

    if (bReadSaveSettings(hwDeviceExtension))
    {
        //
        // Valid SaveSettings was found and has been read into the hwDeviceExtension.
        // Nothing else to do. Return.
        //
        return;
    }
    
    //
    // Either the "saveSettings" was not found or was found to be invalid. So we need to initialize it.
    // First initialize the mapping array. Note that this does not matter for now, since per Ilyas's requirements,
    // LCD+CRT is to be treated the same as CRT+LCD.
    //
    for (i=0; i < NUM_ENTRIES_SAVE_SETTINGS; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pData->dwDeviceDisplay[0] = 0;
        pData->dwDeviceDisplay[1] = 1;
    }

    //
    // Set the standard devices.
    //
    for (i=0; i < 4; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        pData->dwState = NVTWINVIEW_STATE_NORMAL;
        switch (i)
        {
        case 0:
            ulDeviceMask = BITMASK_CRT0;
            break;
        case 1:
            ulDeviceMask = BITMASK_DFP0;
            break;
        case 2:
            ulDeviceMask = BITMASK_TV0;
            break;
        case 3:
            ulDeviceMask = BITMASK_CRT1;
            break;
        default:
            VideoDebugPrint((1, "InitializeSaveSettings(): Invalid index: %d\n",i));
            break;
        }
        //
        // Set the device mask and the TV type. The TV type set here does not matter since TV type is
        // not part of the QUERY_SAVE_SETTINGS. Set both head's devicemask just to be uniform.
        //
        pDevData0->dwDeviceMask = ulDeviceMask;
        pDevData0->dwTVFormat = NTSC_M; 
        pDevData1->dwDeviceMask = ulDeviceMask;
        pDevData1->dwTVFormat = NTSC_M; 
    }

    //
    // Set the clone devices.
    //
    for (i=4; i < 10; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        pData->dwState = NVTWINVIEW_STATE_CLONE;
        switch (i)
        {
        case 4:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_DFP0;
            break;
        case 5:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 6:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 7:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 8:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 9:
            ulDeviceMask0 = BITMASK_TV0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        default:
            VideoDebugPrint((1, "InitializeSaveSettings(): Invalid index: %d\n",i));
            break;
        }
        //
        // Set the device mask and the TV type. The TV type set here does not matter since TV type is
        // not part of the QUERY_SAVE_SETTINGS.
        //
        pDevData0->dwDeviceMask = ulDeviceMask0;
        pDevData0->dwTVFormat = NTSC_M; 
        pDevData1->dwDeviceMask = ulDeviceMask1;
        pDevData1->dwTVFormat = NTSC_M; 
    }

    //
    // Set the horizontal span devices.
    //
    for (i=10; i < 16; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        pData->dwState = NVTWINVIEW_STATE_SPAN;
        pData->dwOrientation = HORIZONTAL_ORIENTATION;
        switch (i)
        {
        case 10:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_DFP0;
            break;
        case 11:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 12:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 13:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 14:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 15:
            ulDeviceMask0 = BITMASK_TV0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        default:
            VideoDebugPrint((1, "InitializeSaveSettings(): Invalid index: %d\n",i));
            break;
        }
        //
        // Set the device mask and the TV type. The TV type set here does not matter since TV type is
        // not part of the QUERY_SAVE_SETTINGS.
        //
        pDevData0->dwDeviceMask = ulDeviceMask0;
        pDevData0->dwTVFormat = NTSC_M; 
        pDevData1->dwDeviceMask = ulDeviceMask1;
        pDevData1->dwTVFormat = NTSC_M; 
    }

    //
    // Set the vertical span devices.
    //
    for (i=16; i < 22; i++)
    {
        pData = &hwDeviceExtension->SaveSettings[i];
        pDevData0 = &pData->NVTWINVIEWUNION.nvtwdevdata[0];
        pDevData1 = &pData->NVTWINVIEWUNION.nvtwdevdata[1];
        pData->dwState = NVTWINVIEW_STATE_SPAN;
        pData->dwOrientation = VERTICAL_ORIENTATION;
        switch (i)
        {
        case 16:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_DFP0;
            break;
        case 17:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 18:
            ulDeviceMask0 = BITMASK_CRT0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 19:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_TV0;
            break;
        case 20:
            ulDeviceMask0 = BITMASK_DFP0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        case 21:
            ulDeviceMask0 = BITMASK_TV0;
            ulDeviceMask1 = BITMASK_CRT1;
            break;
        default:
            VideoDebugPrint((1, "InitializeSaveSettings(): Invalid index: %d\n",i));
            break;
        }
        //
        // Set the device mask and the TV type. The TV type set here does not matter since TV type is
        // not part of the QUERY_SAVE_SETTINGS.
        //
        pDevData0->dwDeviceMask = ulDeviceMask0;
        pDevData0->dwTVFormat = NTSC_M; 
        pDevData1->dwDeviceMask = ulDeviceMask1;
        pDevData1->dwTVFormat = NTSC_M; 
    }

    //
    // Now write the initialized table to registry.
    //
    vWriteSaveSettings(hwDeviceExtension);
    VideoDebugPrint((1,"Exit vInitializeSaveSettings\n"));
    return;
}



//****************************************************************************************
//
//   CheckForcedResolution()
//
//   ( It was SetBestResolution() when it was doing this ->
//     
//     Writes the preferred mode into the DefaultSettings part of the registry.
//     (Hack to force the best mode for next bootup: we're writing to an OS key (hardware profile)
//     that don't belong to us)
//   )
//
// New method: Use a private key to tell us to force a mode during the next bootup. 
//             The key will contain the mode info.
//
// THIS FUNCTION MUST BE CALLED at hwinit(), even if we don't want to set the best resolution :
//  
//  the last parameter, BOOLEAN SetBestResolution, is used for that purpose:
//  When we want to set the best res (using the other function parameters) on next reboot, 
//  set this to TRUE, otherwise FALSE
// 
//  Note that even if the function is called with SetBestResolution == TRUE, 
//  if the ForceModeNextBoot key is set to 1, a forced mode will overide the first modeset 
//  sent by GDI anyway, like it is supposed to. (Because the one-time-after-reboot-forced-mode
//  was already induced, we already have a mode to set, from a previous call to this function)
//
//****************************************************************************************

VOID CheckForcedResolution(
    
            PHW_DEVICE_EXTENSION HwDeviceExtension, 
            USHORT               usWidth, 
            USHORT               usHeight, 
            USHORT               usDepth, 
            USHORT               usRefreshRate,
            BOOLEAN              SetBestResolution )
{
    MODE_ENTRY              ModeEntry;
    NV_REGISTRY_STRUCT      RegStruct;
    VP_STATUS               RegStatus;
    
    WCHAR                   ReBootedNowForceMode_namew[] = {L"ReBootedNowForceMode"};
   
    ULONG                   ForceModeNextBoot;  // see below

    BOOLEAN                 ModeEntryIsUpdated; // did we update the modeentry struct or kept the data from the registry ?



    ModeEntryIsUpdated = FALSE;


    /*
    
    This method won't work all the time: for example, on winxp the path is different, and on Toshiba
    compal (bug 35795) the first boot resolution was incorrect if you had a clean system because the
    NV4 key didnt existed yet)
    
    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, 
        L"\\Registry\\Machine\\System\\CurrentControlSet\\hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\NV4\\Device0",
        L"DefaultSettings.XResolution",
        REG_DWORD, &usWidth, sizeof(ULONG));

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, 
        L"\\Registry\\Machine\\System\\CurrentControlSet\\hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\NV4\\Device0",
        L"DefaultSettings.YResolution",
        REG_DWORD, &usHeight, sizeof(ULONG));
    
    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, 
        L"\\Registry\\Machine\\System\\CurrentControlSet\\hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\NV4\\Device0",
        L"DefaultSettings.BitsPerPel",
        REG_DWORD, &usDepth, sizeof(ULONG));

    RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE, 
        L"\\Registry\\Machine\\System\\CurrentControlSet\\hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\NV4\\Device0",
        L"DefaultSettings.VRefresh",
        REG_DWORD, &usRefreshRate, sizeof(ULONG));
        
    */

    // Write two reg keys: mode info of the mode to force for next bootup, and a flag to tell us when we passed
    // through miniport initialization again for the first mode set of the next boot: 
    //
    // This is done because otherwise, in the drvenablepdev, we won't know if the user tried to change a res
    // without rebooting: if he did just that, we don't want to overide his new choice! We only want to force
    // the best resolution *for the next boot*  *IF AND ONLY IF* the user has not selected a new res prior to that.
    // 
    // One key will be: ForceModeNextBoot  (set here, cleared if  - user changes mode before rebooting OR
    //                                                            - we have rebooted (passed through hwinit again
    //                                                              and this flag was set)
    //
    // The other will tell the DrvEnablePdev function to force a mode: we will use MODE_INFO.validmode
    // (set during hwinit IF ForceModeNextBoot is set, cleared during DrvEnablePdev if it was set)
    //
    // Since this function IS CALLED by hwinit (through handlebestresolution()), we:
    //
    // 1) read ReBootedNowForceMode;
    //
    // 2) read the ForceModeNextBoot flag:  if it is set -> clear it and set ReBootedNowForceMode.ValidMode = 1;
    //                                      else 
    //                                          -> set it (to induce a one-time-after-reboot-forced-mode, since
    //                                             we call setbestresolution for this purpose ) 
    //                                             IF SETBESTRESOLUTION is false, do not set it!!
    //                                             (note that ReBootedNowForceMode.ValidMode = 0);
    // 3) write back the keys;
    //
    //
    //
    // In DrvEnablePdev(): ***!ASSUMING it is called ONLY on modeset!*** 
    //
    //
    //    1) read the ForceModeNextBoot flag: 
    //
    //                                 if it is set ->        clear it ! (the user changed the mode but we haven't rebooted
    //                                                        yet because otherwise, on reboot, in this very function,
    //                                                        we would have cleared it);   ReBootedNowForceMode.ValidMode is 
    //                                                        probably = 0, else the state is inconsistant.
    //                                 else 
    //                                     -> 
    //                                 read the ReBootedNowForceMode.ValidMode flag:  
    //                       
    //                                     if it is set -> clear it and overide the GDI mode with
    //                                                     ReBootedNowForceMode;
    //                                     else 
    //                                         -> nothing special;
    //
    //
    // NOTE: This seems similar to what we do with the UseBestResolution key, but then we might ask "why not use
    //       only that key in the first place?" Because this key is not set *first* by the miniport bootup, but 
    //       by the INF file ! So if the flag is set by the INF, we might think it's ok to turn on
    //       ReBootedNowForceMode.ValidMode, but if the user decides to change the res before rebooting (after the
    //       first install of the drv without reboot) the behavior is going to be wrong: we're going to overide 
    //       the modeset triggered by the user ( because ReBootedNowForceMode.ValidMode will be true! )

    
    // Copy the required values into the input context (submitted to the callback)
    
    RegStruct.keyVal     = (PVOID) &ModeEntry;
    RegStruct.keyValSize = sizeof(MODE_ENTRY);
    RegStruct.keyName    = (PWSTR) ReBootedNowForceMode_namew;

    RegStatus = VideoPortGetRegistryParameters(
                           HwDeviceExtension,
                           ReBootedNowForceMode_namew,
                           FALSE,
                           NVReadRegistryBinaryCallback,
                           (PVOID)&RegStruct);
    
    
    if(RegStatus != NO_ERROR)  
    {
        // the key wasn't there, so fill the structure
        //
        // We only need to to this when we are actually setting 
        // the best resolution, when we check for the forced res
        // sequence, we must have this key valid, so no error
        // on the read should occur.  But if we just check the forced
        // sequence, and WE HAVE an error (the ModeEntry key isnt there, 
        // we will fill a valid mode); this is not necessarily an error
        // condition: if we check the forced resolution sequence, but
        // we don't want to set it, AND the sequenced WAS NOT "started" (by setting the 
        // ForceModeNextBoot key) it is possible not to have any modeentry
        // (ReBootedNowForceMode) registry key set for this...
        // 

        if( SetBestResolution )
        {
            ModeEntry.Depth       = usDepth;        // in bits
            ModeEntry.Height      = usHeight;
            ModeEntry.Width       = usWidth;
            ModeEntry.RefreshRate = usRefreshRate;
            ModeEntry.ValidMode   = 0;              
        }
        else 
        {
            ModeEntry.Depth       = 4;        // in bits
            ModeEntry.Height      = 640;      //
            ModeEntry.Width       = 480;      //
            ModeEntry.RefreshRate = 1;        // this is what windows set as the "safest mode request" 
                                              // in VGASAVE reg key and this is what it sends the driver in safe mode
            ModeEntry.ValidMode   = 0;              
        }
        
        ModeEntryIsUpdated = TRUE;
    }
    
    // when mode data is taken without error from the regkey, assume it is ok


    ForceModeNextBoot = 0;

    RegStatus = VideoPortGetRegistryParameters(
                    HwDeviceExtension,
                    L"ForceModeNextBoot",
                    FALSE,
                    NVRegistryCallback,       
                    (PVOID) &(ForceModeNextBoot));    // This param is passed to our callback. This callback uses ULONGs
    
    if( (RegStatus == NO_ERROR) && (ForceModeNextBoot == 1) )
    {
        // Here, if the forcemode flag was set, we should have read (without error) the mode entry
        // from the registry.  We don't keep and check the status NO_ERROR here because even if 
        // it was invalid, now it is (this case should never happen but it won't do us harm)
        
        ForceModeNextBoot     = 0;
        ModeEntry.ValidMode   = 1;

        ModeEntryIsUpdated = TRUE; // this is not really true, because only one field is updated,
                                   // but we use ModeEntryIsUpdated also to avoid an unecessary 
                                   // write back to the registry ( ModeEntryIsUpdated == FALSE tells
                                   // us we have a mode info from the registry, not from the values
                                   // passed at SetBestResolution()


    } // ... if the key ForceModeNextBoot was set (and it existed)    
    
    else if ( SetBestResolution )     
    {
        // The ForceModeNextBoot key didn't exist, or it was not set:
        // We set it here to induce a one-time-after-reboot-forced-mode, since
        // we called this function with setbestresolution == TRUE for this purpose 
        // We don't call with SetBestResolution == TRUE at each boot because we
        // clear the UseBestResolution flag in HandleBestResolution

        // (the next time we boot, we clear ForceModeNextBoot, by making a call to this
        //  function but with SetBestResolution == FALSE, and we also set modeentry.validmode.  
        //  Even if the function is
        //  called with SetBestResolution == TRUE, if the ForceModeNextBoot key is set
        //  to 1, a forced mode will overide the first modeset sent by GDI, but we
        //  won't update the mode_entry for this mode, so the other function parameters are 
        //  not used, )

        ForceModeNextBoot = 1;

        // Here, one case could make use choose the wrong best resolution:
        // if the key ReBootedNowForceMode was not removed by the wizard uninstall 
        // it could be valid, and we would read some old best mode.  So,
        // if we haven't updated the modeentry, we force it here:

        if( ModeEntryIsUpdated == FALSE )
        {
            ModeEntry.Depth       = usDepth;        // in bits
            ModeEntry.Height      = usHeight;
            ModeEntry.Width       = usWidth;
            ModeEntry.RefreshRate = usRefreshRate;
            ModeEntry.ValidMode   = 0; 
            
            ModeEntryIsUpdated = TRUE;
        }
    
    } // ... else the key ForceModeNextBoot was cleared


    // Write back the keys
    //
    //
    // Note: if the key doesn't exist, it will be created

    
    if( ModeEntryIsUpdated )
    {
        RegStatus = VideoPortSetRegistryParameters(
                           HwDeviceExtension,
                           L"ReBootedNowForceMode",
                           (PVOID) &ModeEntry,
                           sizeof(MODE_ENTRY));    
    }
        
    // Write the ForceModeNextBoot flag 
    
    RegStatus = VideoPortSetRegistryParameters(
                       HwDeviceExtension,
                       L"ForceModeNextBoot",
                       (PVOID) &ForceModeNextBoot,
                       sizeof(ULONG));

} // ... CheckForcedResolution()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv3a_ref.h ===
/* @(#) $Header: /drivers/display/WINNT40/miniport/NV_MINI/NV3A_REF.H 2     1/10/97 7:10p Vidall $
 NVidia Corporation */
/* basis: nv1 manuals 10.1
 95/06/27 NVidia Corporation */

#ifndef _NV_REF_H_
#define _NV_REF_H_

/* dev_bus.ref */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000000FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_NV_0                               0x00000000 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID                           15:0 /* C--UF */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID_NVIDIA_SGS          0x000012D2 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC                     18:16 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_VGA            0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP                     31:19 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV0            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV1            0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV2            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV3            0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_1                               0x00000004 /* RW-4R */
#define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
#define NV_CONFIG_PCI_NV_1_IO_SPACE                             0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_DISABLED             0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_ENABLED              0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE                         1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_DISABLED         0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_ENABLED          0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL                      4:4 /* C--VF */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_DISABLED      0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_ENABLED       0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP                        5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_DISABLED        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_ENABLED         0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_CAPLIST                            20:20 /* R--VF */
#define NV_CONFIG_PCI_NV_1_CAPLIST_NOT_PRESENT           0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_CAPLIST_PRESENT               0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ                              21:21 /* C--VF */
#define NV_CONFIG_PCI_NV_1_66MHZ_INCAPABLE               0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ_CAPABLE                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK                     23:23 /* C--VF */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_INCAPABLE      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_CAPABLE        0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING                      26:25 /* C--VF */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_FAST            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_MEDIUM          0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_SLOW            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET                    27:27 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET                    28:28 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER                    29:29 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_2                               0x00000008 /* R--4R */
#define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
#define NV_CONFIG_PCI_NV_2_REVISION_ID                          7:0 /* C--UF */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_A                 0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE                          31:8 /* C--VF */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_VGA                0x00030000 /* C---V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_MULTIMEDIA         0x00048000 /* ----V */
#define NV_CONFIG_PCI_NV_3                               0x0000000C /* RW-4R */
#define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER                      15:11 /* RWIUF */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_0_CLOCKS        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_8_CLOCKS        0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_240_CLOCKS      0x0000001E /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_248_CLOCKS      0x0000001F /* RW--V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE                        23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_SINGLEFUNC        0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_MULTIFUNC         0x00000080 /* ----V */
#define NV_CONFIG_PCI_NV_4                               0x00000010 /* RW-4R */
#define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_NOT              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_MERGABLE         0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_5                               0x00000014 /* RW-4R */
#define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_NOT              0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_MERGABLE         0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_5_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_6                               0x00000018 /* RW-4R */
#define NV_CONFIG_PCI_NV_6__ALIAS_1                NV_PBUS_PCI_NV_6 /*       */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_MEMORY             0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_IO                 0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_6_BASE_ADDRESS                        31:8 /* RWXUF */
#define NV_CONFIG_PCI_NV_7(i)                    (0x0000001C+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_7__SIZE_1                                4 /*       */
#define NV_CONFIG_PCI_NV_7__ALIAS_1                NV_PBUS_PCI_NV_7 /*       */
#define NV_CONFIG_PCI_NV_7_RESERVED                            31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_7_RESERVED_0                    0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_11                              0x0000002C /* R--4R */
#define NV_CONFIG_PCI_NV_11__ALIAS_1              NV_PBUS_PCI_NV_11 /*       */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID               31:16 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID                       15:0 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_12                              0x00000030 /* RW-4R */
#define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE                          0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_DISABLED          0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_ENABLED           0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_12_ROM_BASE                          31:22 /* RWXUF */
#define NV_CONFIG_PCI_NV_13                              0x00000034 /* RW-4R */
#define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
#define NV_CONFIG_PCI_NV_13_CAP_PTR                             7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_13_CAP_PTR_AGP                  0x00000044 /* C---V */
#define NV_CONFIG_PCI_NV_14                              0x00000038 /* R--4A */
#define NV_CONFIG_PCI_NV_14__ALIAS_1              NV_PBUS_PCI_NV_14 /*       */
#define NV_CONFIG_PCI_NV_14_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_14_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_15                              0x0000003C /* RW-4R */
#define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
#define NV_CONFIG_PCI_NV_15_INTR_LINE                           7:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ0               0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ1               0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ15              0x0000000F /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_UNKNOWN            0x000000FF /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_PIN                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_15_INTR_PIN_INTA                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT                           23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_750NS                0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT                           31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_250NS                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_16                              0x00000040 /* RW-4R */
#define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID               31:16 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID                       15:0 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_17                              0x00000044 /* RW-4R */
#define NV_CONFIG_PCI_NV_17__ALIAS_1              NV_PBUS_PCI_NV_17 /*       */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR                     23:20 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR_1              0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR                     19:16 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR_0              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR_NULL                0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_CAP_ID                              7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_17_CAP_ID_AGP                   0x00000002 /* C---V */
#define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
#define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ                     31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ_4              0x00000004 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA                      9:9 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA_NONE          0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE                     1:0 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_1X           0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
#define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH              31:24 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0       0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE              8:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF   0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE               1:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF    0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20                              0x00000050 /* RW-4R */
#define NV_CONFIG_PCI_NV_20__ALIAS_1              NV_PBUS_PCI_NV_20 /*       */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER                       0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_DISABLED       0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_ENABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS                        1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_DISABLED        0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_ENABLED         0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO                           3:3 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ                          4:4 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_DISABLED          0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_ENABLED           0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING                         5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_DISABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_ENABLED          0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO                        7:7 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_ENABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_DISABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE                             9:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SB_BASE_220H                 0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_240H                 0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_260H                 0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE                          13:12 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_330H                0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_230H                0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_300H                0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP                         16:16 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_21                              0x00000054 /* RW-4R */
#define NV_CONFIG_PCI_NV_21__ALIAS_1              NV_PBUS_PCI_NV_21 /*       */
#define NV_CONFIG_PCI_NV_21_VGA                                 0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_21_VGA_DISABLED                 0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_21_VGA_ENABLED                  0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_22                              0x00000058 /* RW-4R */
#define NV_CONFIG_PCI_NV_22__ALIAS_1              NV_PBUS_PCI_NV_22 /*       */
#define NV_CONFIG_PCI_NV_22_SCRATCH                            23:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_22_SCRATCH_DEFAULT              0x0023D6CE /* RWI-V */
#define NV_CONFIG_PCI_NV_23(i)                   (0x0000005C+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_23__SIZE_1                              41 /*       */
#define NV_CONFIG_PCI_NV_23__ALIAS_1              NV_PBUS_PCI_NV_23 /*       */
#define NV_CONFIG_PCI_NV_23_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_23_RESERVED_0                   0x00000000 /* C---V */
/* dev_bus.ref */
#define NV_RMA_ID                                        0x00000000 /* R--4R */
#define NV_RMA_ID__ALIAS_1                          NV_PRMIO_RMA_ID /*       */
#define NV_RMA_ID_CODE                                         31:0 /* C--UF */
#define NV_RMA_ID_CODE_VALID                             0x2B16D065 /* C---V */
#define NV_RMA_PTR                                       0x00000004 /* RW-4R */
#define NV_RMA_PTR__ALIAS_1                        NV_PRMIO_RMA_PTR /*       */
#define NV_RMA_PTR_ADDRESS                                     24:2 /* RWXUF */
#define NV_RMA_DATA                                      0x00000008 /* RW-4R */
#define NV_RMA_DATA__ALIAS_1                      NV_PRMIO_RMA_DATA /*       */
#define NV_RMA_DATA_PORT                                       31:0 /* RWXUF */
#define NV_RMA_DATA32                                    0x0000000C /* RW-2R */
#define NV_RMA_DATA32__ALIAS_1                  NV_PRMIO_RMA_DATA32 /*       */
#define NV_RMA_DATA32_MSW                                     31:16 /* -WXUF */
#define NV_RMA_DATA32_LSW                                      15:0 /* RWXUF */
#define NV_RMA_INCDATA                                   0x00000010 /* RW-4R */
#define NV_RMA_INCDATA__ALIAS_1                NV_PRMIO_RMA_INCDATA /*       */
#define NV_RMA_INCDATA_PORT                                    31:0 /* RWXUF */
#define NV_RMA_INCDATA32                                 0x00000014 /* RW-4R */
#define NV_RMA_INCDATA32__ALIAS_1            NV_PRMIO_RMA_INCDATA32 /*       */
#define NV_RMA_INCDATA32_PORT                                  31:0 /* RWXUF */
/* dev_bus.ref */
#define NV_RMAIO                              0x000000FF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_PRMIO_RMA_ID                                  0x00007100 /* R--4R */
#define NV_PRMIO_RMA_ID__ALIAS_1                          NV_RMA_ID /*       */
#define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */
#define NV_PRMIO_RMA_PTR__ALIAS_1                        NV_RMA_PTR /*       */
#define NV_PRMIO_RMA_DATA                                0x00007108 /* RW-4R */
#define NV_PRMIO_RMA_DATA__ALIAS_1                      NV_RMA_DATA /*       */
#define NV_PRMIO_RMA_DATA32                              0x0000710C /* RW-2R */
#define NV_PRMIO_RMA_DATA32__ALIAS_1                  NV_RMA_DATA32 /*       */
#define NV_PRMIO_RMA_INCDATA                             0x00007110 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA__ALIAS_1                NV_RMA_INCDATA /*       */
#define NV_PRMIO_RMA_INCDATA32                           0x00007114 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA32__ALIAS_1            NV_RMA_INCDATA32 /*       */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_realmode.ref */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
#define NV_IO_DMA_0000                                   0x00000000 /* -W-1R */
#define NV_IO_DMA_0000_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0001                                   0x00000001 /* -W-1R */
#define NV_IO_DMA_0001_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0002                                   0x00000002 /* -W-1R */
#define NV_IO_DMA_0002_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0003                                   0x00000003 /* -W-1R */
#define NV_IO_DMA_0003_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0004                                   0x00000004 /* -W-1R */
#define NV_IO_DMA_0004_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0005                                   0x00000005 /* -W-1R */
#define NV_IO_DMA_0005_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0006                                   0x00000006 /* -W-1R */
#define NV_IO_DMA_0006_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0007                                   0x00000007 /* -W-1R */
#define NV_IO_DMA_0007_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0008                                   0x00000008 /* -W-1R */
#define NV_IO_DMA_0008_CONTROLLER                               2:2 /* -W-VF */
#define NV_IO_DMA_0008_CONTROLLER_DISABLED               0x00000000 /* -W--V */
#define NV_IO_DMA_0008_CONTROLLER_ENABLED                0x00000001 /* -W--V */
#define NV_IO_DMA_000A                                   0x0000000A /* -W-1R */
#define NV_IO_DMA_000A_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000A_MASK_BIT                                 2:2 /* -W-VF */
#define NV_IO_DMA_000A_MASK_BIT_CLEAR                    0x00000000 /* -W--V */
#define NV_IO_DMA_000A_MASK_BIT_SET                      0x00000001 /* -W--V */
#define NV_IO_DMA_000B                                   0x0000000B /* -W-1R */
#define NV_IO_DMA_000B_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000B_AUTOINITIALIZE                           4:4 /* -W-VF */
#define NV_IO_DMA_000B_AUTOINITIALIZE_DISABLED           0x00000000 /* -W--V */
#define NV_IO_DMA_000B_AUTOINITIALIZE_ENABLED            0x00000001 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION                                5:5 /* -W-VF */
#define NV_IO_DMA_000B_DIRECTION_INCREMENT               0x00000000 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION_DECREMENT               0x00000001 /* -W--V */
#define NV_IO_DMA_000C                                   0x0000000C /* -W-1R */
#define NV_IO_DMA_000C_CLEAR_FLIPFLOP                           7:0 /* -W-VF */
#define NV_IO_DMA_0081                                   0x00000081 /* -W-1R */
#define NV_IO_DMA_0081_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0082                                   0x00000082 /* -W-1R */
#define NV_IO_DMA_0082_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0083                                   0x00000083 /* -W-1R */
#define NV_IO_DMA_0083_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0087                                   0x00000087 /* -W-1R */
#define NV_IO_DMA_0087_ADDRESS                                  3:0 /* -W-UF */
/* dev_dac.ref */
#define NV_PRAMDAC                            0x00680FFF:0x00680300 /* RW--D */
#define NV_PRAMDAC_CU_START_POS                          0x00680300 /* RW-4R */
#define NV_PRAMDAC_CU_START_POS_X                              11:0 /* RWXSF */
#define NV_PRAMDAC_CU_START_POS_Y                             27:16 /* RWXSF */
#define NV_PRAMDAC_APLL_COEFF                            0x00680500 /* RW-4R */
#define NV_PRAMDAC_APLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_MPLL_COEFF                            0x00680504 /* RW-4R */
#define NV_PRAMDAC_MPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_VPLL_COEFF                            0x00680508 /* RW-4R */
#define NV_PRAMDAC_VPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT                      0x0068050C /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS                  4:4 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_FALSE     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_TRUE      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE                 8:8 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS               12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE               16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS               20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE               25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VPLL     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VIP      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_XTALOSC  0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO                28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB1       0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL                     0x00680510 /* RW-4R */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VALUE                     10:0 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VAL                 0x0000044E /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN                   12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON           0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER                      0x00680514 /* RW-4R */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NOOFIPCLKS                  9:0 /* -WIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VALUE                      15:0 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE                    16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET                     20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE                    25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_MCLK          0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_VCLK          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_ACLK          0x00000010 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIV_RST                  28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_DEASSERTED   0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_ASSERTED     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCK                 29:29 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_APLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCK                 30:30 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCK                 31:31 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_TEST                          0x00680518 /* RW-4R */
#define NV_PRAMDAC_PALETTE_TEST_BLUE_DATA                       7:0 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_GREEN_DATA                     15:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_RED_DATA                      23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_MODE                          24:24 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_MODE_8BIT                0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_MODE_24BIT               0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC                       28:28 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_READWRITE        0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_WRITEONLY        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL                       0x00680600 /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF                     1:0 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF_DEF          0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE                     4:4 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_GAMMA        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_INDEX        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE                    8:8 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_NOTSE       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE                   12:12 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_NOTSEL       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_SEL          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL                 16:16 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_OFF        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_ON         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION                17:17 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_37OHM     0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM     0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC                        20:20 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_6BITS             0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS             0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP                  24:24 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_DIS         0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_EN          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK                28:28 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_EN        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_DIS       0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_RECOVERY                      0x00680604 /* R--4R */
#define NV_PRAMDAC_PALETTE_RECOVERY_ACTIVE_ADDRESS              7:0 /* R--UF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER                10:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_RED      0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_GREEN    0x00000010 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_BLUE     0x00000100 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE                 13:12 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_WRITE      0x00000000 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_READ       0x00000011 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RED_DATA                  23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_GREEN_DATA                31:24 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL                          0x00680608 /* RW-4R */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET                       0:0 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE                      4:4 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL                     9:8 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_BLUE         0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_GREEN        0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_RED          0x00000010 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN                     12:12 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC                    16:16 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_ON            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF           0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM                         20:20 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_NORMAL             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_TEST               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1                        24:24 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_CLEAR             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_SET               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31                       25:25 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_CLEAR            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_SET              0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB                        28:28 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_SOMELO            0x00000000 /* R---V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI             0x00000001 /* R---V */
#define NV_PRAMDAC_CHECKSUM                              0x0068060C /* R--4R */
#define NV_PRAMDAC_CHECKSUM_VALUE                              23:0 /* R--VF */
#define NV_PRAMDAC_TESTPOINT_DATA                        0x00680610 /* -W-4R */
#define NV_PRAMDAC_TESTPOINT_DATA_RED                           9:0 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_GREEN                       19:10 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLUE                        29:20 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLACK                       30:30 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK                    31:31 /* -W-VF */
#define NV_PRAMDAC_VSERR_WIDTH                           0x00680700 /* RW-4R */
#define NV_PRAMDAC_VSERR_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_END                              0x00680704 /* RW-4R */
#define NV_PRAMDAC_VEQU_END_VAL                                10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_END                           0x00680708 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_END_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_END                            0x0068070C /* RW-4R */
#define NV_PRAMDAC_VBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_START                          0x00680710 /* RW-4R */
#define NV_PRAMDAC_VBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_START                         0x00680714 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_START_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_START                            0x00680718 /* RW-4R */
#define NV_PRAMDAC_VEQU_START_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VTOTAL                                0x0068071C /* RW-4R */
#define NV_PRAMDAC_VTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HSYNC_WIDTH                           0x00680720 /* RW-4R */
#define NV_PRAMDAC_HSYNC_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_START                          0x00680724 /* RW-4R */
#define NV_PRAMDAC_HBURST_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_END                            0x00680728 /* RW-4R */
#define NV_PRAMDAC_HBURST_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_START                          0x0068072C /* RW-4R */
#define NV_PRAMDAC_HBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_END                            0x00680730 /* RW-4R */
#define NV_PRAMDAC_HBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HTOTAL                                0x00680734 /* RW-4R */
#define NV_PRAMDAC_HTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HEQU_WIDTH                            0x00680738 /* RW-4R */
#define NV_PRAMDAC_HEQU_WIDTH_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HSERR_WIDTH                           0x0068073C /* RW-4R */
#define NV_PRAMDAC_HSERR_WIDTH_VAL                             10:0 /* RWIVF */
/* dev_dac.ref */
#define NV_USER_DAC                           0x00681FFF:0x00681200 /* RW--D */
#define NV_USER_DAC_PIXEL_MASK                           0x006813C6 /* RWI1R */
#define NV_USER_DAC_PIXEL_MASK_VALUE                            7:0 /* RWIVF */
#define NV_USER_DAC_PIXEL_MASK_MASK                      0x000000FF /* RWI-V */
#define NV_USER_DAC_READ_MODE_ADDRESS                    0x006813C7 /* RW-1R */
#define NV_USER_DAC_READ_MODE_ADDRESS_VALUE                     7:0 /* RW-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_WO_VALUE                  7:0 /* -W-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE                  1:0 /* R--VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_WRITE     0x00000000 /* R---V */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_READ      0x00000011 /* R---V */
#define NV_USER_DAC_WRITE_MODE_ADDRESS                   0x006813C8 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE                    7:0 /* RW-VF */
#define NV_USER_DAC_PALETTE_DATA                         0x006813C9 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA_VALUE                          7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1                      0x00000300 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_2                      0x00000230 /* R--1R */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1                    0x00000301 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_2                    0x00000231 /* R--1R */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MPU_401_COM                                0x00000331 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_1                       0x00000301 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_2                       0x00000231 /* -W-1R */
#define NV_IO_MPU_401_COM_UART_MODE                             7:0 /* -WIVF */
#define NV_IO_MPU_401_COM_UART_MODE_COMPLEX              0x000000ff /* -WI-V */
#define NV_IO_MPU_401_COM_UART_MODE_SIMPLE               0x0000003f /* -W--V */
/* dev_master.ref */
#define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
#define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
#define NV_PMC_BOOT_0_FIB_REVISION                              3:0 /* C--VF */
#define NV_PMC_BOOT_0_FIB_REVISION_0                     0x00000000 /* ----V */
#define NV_PMC_BOOT_0_FIB_REVISION_1                     0x00000001 /* ----V */
#define NV_PMC_BOOT_0_FIB_REVISION_2                     0x00000002 /* C---V */
#define NV_PMC_BOOT_0_MASK_REVISION                             7:4 /* C--VF */
#define NV_PMC_BOOT_0_MASK_REVISION_A                    0x00000000 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION_B                    0x00000001 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION_C                    0x00000002 /* C---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION                           15:8 /* R--VF */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV0                 0x00000000 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1V32              0x00000001 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1D32              0x00000002 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_PICASSO             0x00000003 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV2MUTARA           0x00000004 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV3                 0x00000005 /* R---V */
#define NV_PMC_BOOT_0_ARCHITECTURE                            23:16 /* C--VF */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV3                   0x00000003 /* C---V */
#define NV_PMC_BOOT_0_MANUFACTURER                            27:24 /* C--UF */
#define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY                                 31:28 /* C--VF */
#define NV_PMC_BOOT_0_FOUNDRY_SGS                        0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY_HELIOS                     0x00000001 /* ----V */
#define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
#define NV_PMC_INTR_0_PAUDIO                                    0:0 /* R--VF */
#define NV_PMC_INTR_0_PAUDIO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PAUDIO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PMEDIA                                    4:4 /* R--VF */
#define NV_PMC_INTR_0_PMEDIA_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PMEDIA_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
#define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0                                 12:12 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH0_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1                                 13:13 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH1_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PVIDEO                                  16:16 /* R--VF */
#define NV_PMC_INTR_0_PVIDEO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PVIDEO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
#define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFB                                     24:24 /* R--VF */
#define NV_PMC_INTR_0_PFB_NOT_PENDING                    0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFB_PENDING                        0x00000001 /* R---V */
#define NV_PMC_INTR_0_PBUS                                    28:28 /* R--VF */
#define NV_PMC_INTR_0_PBUS_NOT_PENDING                   0x00000000 /* R---V */
#define NV_PMC_INTR_0_PBUS_PENDING                       0x00000001 /* R---V */
#define NV_PMC_INTR_0_SOFTWARE                                31:31 /* RWIVF */
#define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
#define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
#define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
#define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
#define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
#define NV_PMC_ENABLE_PAUDIO                                    0:0 /* RWIVF */
#define NV_PMC_ENABLE_PAUDIO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PAUDIO_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PMEDIA                                    4:4 /* RWIVF */
#define NV_PMC_ENABLE_PMEDIA_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PMEDIA_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
#define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
#define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PPMI                                    16:16 /* RWIVF */
#define NV_PMC_ENABLE_PPMI_DISABLED                      0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PPMI_ENABLED                       0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFB                                     20:20 /* RWIVF */
#define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PCRTC                                   24:24 /* RWIVF */
#define NV_PMC_ENABLE_PCRTC_DISABLED                     0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PCRTC_ENABLED                      0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO                                  28:28 /* RWIVF */
#define NV_PMC_ENABLE_PVIDEO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO_ENABLED                     0x00000001 /* RW--V */
/* dev_bus.ref */
#define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_MODE                                    0:0 /* RWIVF */
#define NV_PBUS_DEBUG_0_MODE_DISABLED                    0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MODE_ENABLED                     0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_DESKEWER                                4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_DESKEWER_ENABLED                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_DESKEWER_BYPASS                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY                        11:8 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_SEL_0                              0x00001090 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_0_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_1                              0x00001094 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_1_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_2                              0x00001098 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_2_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_3                              0x0000109C /* RW-4R */
#define NV_PBUS_DEBUG_SEL_3_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_HOST                               0x000010A0 /* RW-4R */
#define NV_PBUS_DEBUG_HOST_SEL                                  2:0 /* RWXUF */
#define NV_PBUS_DEBUG_1                                  0x00001084 /* RW-4R */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE                           0:0 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED            0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD                                1:1 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY                0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_AGP                                2:2 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_AGP                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_PCI                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD                                4:3 /* RWIVF */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                 0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE                              5:5 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_0_CYCLE               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_1_CYCLE               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_2_1                                6:6 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY                              7:7 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST                           8:8 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST                           9:9 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY                        10:10 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED          0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED           0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO                            11:11 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ                             12:12 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1                                13:13 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE1_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE2                                14:14 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE2_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE2_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_INTR_0                                   0x00001100 /* RW-4R */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR                            0:0 /* RWXVF */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING         0x00000000 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET               0x00000001 /* -W--V */
#define NV_PBUS_INTR_EN_0                                0x00001140 /* RWI4R */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR                         0:0 /* RWIVF */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED         0x00000000 /* RWI-V */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED          0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0                                0x00001E80 /* RW-4R */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_0                        7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_1                       15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_2                      23:16 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT                            24:24 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_CLEAR                 0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_SET                   0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE                      25:25 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_DISABLED        0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION                           26:26 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_DIRECTION_INCREMENT            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION_DECREMENT            0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CHANNEL                             29:28 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER                          30:30 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_DISABLED            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP                            31:31 /* RWIVF */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_0                0x00000000 /* RWI-V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_1                0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_1                                0x00001E84 /* RW-4R */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_0                          7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_1                         15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_STATE                               28:28 /* RWXVF */
#define NV_PBUS_RMC_DMA_1_STATE_CLEAN                    0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_1_STATE_DIRTY                    0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_0                                 0x00001800 /* R--4R */
#define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
#define NV_PBUS_PCI_NV_1                                 0x00001804 /* RW-4R */
#define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
#define NV_PBUS_PCI_NV_2                                 0x00001808 /* R--4R */
#define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_NV_3                                 0x0000180C /* RW-4R */
#define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
#define NV_PBUS_PCI_NV_4                                 0x00001810 /* RW-4R */
#define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
#define NV_PBUS_PCI_NV_5                                 0x00001814 /* RW-4R */
#define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
#define NV_PBUS_PCI_NV_6                                 0x00001818 /* RW-4R */
#define NV_PBUS_PCI_NV_6__ALIAS_1                NV_CONFIG_PCI_NV_6 /*       */
#define NV_PBUS_PCI_NV_7(i)                      (0x0000181C+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_7__SIZE_1                                  4 /*       */
#define NV_PBUS_PCI_NV_7__ALIAS_1                NV_CONFIG_PCI_NV_7 /*       */
#define NV_PBUS_PCI_NV_11                                0x0000182C /* R--4R */
#define NV_PBUS_PCI_NV_11__ALIAS_1              NV_CONFIG_PCI_NV_11 /*       */
#define NV_PBUS_PCI_NV_12                                0x00001830 /* RW-4R */
#define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
#define NV_PBUS_PCI_NV_13                                0x00001834 /* RW-4R */
#define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
#define NV_PBUS_PCI_NV_14                                0x00001838 /* R--4A */
#define NV_PBUS_PCI_NV_14__ALIAS_1              NV_CONFIG_PCI_NV_14 /*       */
#define NV_PBUS_PCI_NV_15                                0x0000183C /* RW-4R */
#define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
#define NV_PBUS_PCI_NV_16                                0x00001840 /* RW-4R */
#define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
#define NV_PBUS_PCI_NV_17                                0x00001844 /* RW-4R */
#define NV_PBUS_PCI_NV_17__ALIAS_1              NV_CONFIG_PCI_NV_17 /*       */
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
#define NV_PBUS_PCI_NV_20                                0x00001850 /* RW-4R */
#define NV_PBUS_PCI_NV_20__ALIAS_1              NV_CONFIG_PCI_NV_20 /*       */
#define NV_PBUS_PCI_NV_21                                0x00001854 /* RW-4R */
#define NV_PBUS_PCI_NV_21__ALIAS_1              NV_CONFIG_PCI_NV_21 /*       */
#define NV_PBUS_PCI_NV_22                                0x00001858 /* RW-4R */
#define NV_PBUS_PCI_NV_22__ALIAS_1              NV_CONFIG_PCI_NV_22 /*       */
#define NV_PBUS_PCI_NV_23(i)                     (0x0000185C+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_23__SIZE_1                                41 /*       */
#define NV_PBUS_PCI_NV_23__ALIAS_1              NV_CONFIG_PCI_NV_23 /*       */
/* dev_fifo.ref */
#define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             7:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
#define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
#define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PUSHER                            12:12 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PUSHER_NOT_PENDING           0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_PENDING               0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_RESET                 0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PTE                               16:16 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PTE_NOT_PENDING              0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_PENDING                  0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_RESET                    0x00000001 /* -W--V */
#define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER                         12:12 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_DISABLED           0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_ENABLED            0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE                            16:16 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_DISABLED              0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_ENABLED               0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0                                0x00002200 /* RW-4R */
#define NV_PFIFO_CONFIG_0_DMA_FETCH                            10:8 /* RWXVF */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_32_BYTES             0x00000000 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_64_BYTES             0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_96_BYTES             0x00000002 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_128_BYTES            0x00000003 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_160_BYTES            0x00000004 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_192_BYTES            0x00000005 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_224_BYTES            0x00000006 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_256_BYTES            0x00000007 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_WATERMARK                       22:18 /* RWXVF */
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */
#define NV_PFIFO_RAMHT_BASE_ADDRESS                           15:12 /* RWXVF */
#define NV_PFIFO_RAMHT_BASE_ADDRESS_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE                                   17:16 /* RWXVF */
#define NV_PFIFO_RAMHT_SIZE_4K                           0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_16K                          0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_32K                          0x00000003 /* RW--V */
#define NV_PFIFO_RAMFC                                   0x00002214 /* RW-4R */
#define NV_PFIFO_RAMFC_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMFC_BASE_ADDRESS_1C00                 0x00001C00 /* RWI-V */
#define NV_PFIFO_RAMRO                                   0x00002218 /* RW-4R */
#define NV_PFIFO_RAMRO_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_1E00                 0x00001E00 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE                                   16:16 /* RWXVF */
#define NV_PFIFO_RAMRO_SIZE_512                          0x00000000 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
#define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
#define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
#define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH1                            0x00003004 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA0                             0x00003220 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA0_ACCESS                             0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_DISABLED             0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_ENABLED              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA0_STATE                              4:4 /* R-IVF */
#define NV_PFIFO_CACHE1_DMA0_STATE_IDLE                  0x00000000 /* R-I-V */
#define NV_PFIFO_CACHE1_DMA0_STATE_BUSY                  0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_DMA1                             0x00003224 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA1_LENGTH                            23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA2                             0x00003228 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA2_ADDRESS                           23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3                             0x0000322C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE                        1:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_PCI             0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_AGP             0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS                       0x00003218 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD                      12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_SUBCHANNEL                 15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD_COUNT               28:18 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON                     30:30 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_DONE           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_NON_CACHE      0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG                      0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS                   23:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE                      0x00003234 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE                        0:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_PRESENT         0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS             31:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE                  0x00003238 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE_ADDRESS                19:2 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL0                            0x00003040 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0                            0x00003240 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL1                            0x00003250 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL1_CTX                               4:4 /* RWXVF */
#define NV_PFIFO_CACHE1_PULL1_CTX_CLEAN                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_CTX_DIRTY                  0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_STATUS                           0x00003014 /* R--4R */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS                           0x00003214 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS_RANOUT                           0:0 /* R-XVF */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PUT                              0x00003010 /* RW-4R */
#define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_PUT                              0x00003210 /* RW-4R */
#define NV_PFIFO_CACHE1_PUT_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
#define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
#define NV_PFIFO_CACHE1_GET_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX(i)                  (0x00003080+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE0_CTX__SIZE_1                               1 /*       */
#define NV_PFIFO_CACHE0_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE0_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_CTX(i)                  (0x00003280+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE1_CTX__SIZE_1                               8 /*       */
#define NV_PFIFO_CACHE1_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE1_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
#define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD(i)                (0x00003300+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD__SIZE_1                           32 /*       */
#define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
#define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA(i)                  (0x00003304+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA__SIZE_1                             32 /*       */
#define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    6:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                     8:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    12:3 /*       */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_audio.ref */
#define NV_PAUDIO                             0x00300FFF:0x00300000 /* RW--D */
#define NV_PAUDIO_PINS                                   0x00300000 /* RW-4R */
#define NV_PAUDIO_PINS_SI_DELAY                                 0:0 /* RWIVF */
#define NV_PAUDIO_PINS_SI_DELAY_NORMAL                   0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SI_DELAY_I2S                      0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_SI_EDGE                                  1:1 /* RWIVF */
#define NV_PAUDIO_PINS_SI_EDGE_NEGATIVE                  0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SI_EDGE_POSITIVE                  0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_SO_DELAY                                 4:4 /* RWIVF */
#define NV_PAUDIO_PINS_SO_DELAY_NORMAL                   0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SO_DELAY_I2S                      0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_SO_EDGE                                  5:5 /* RWIVF */
#define NV_PAUDIO_PINS_SO_EDGE_NEGATIVE                  0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SO_EDGE_POSITIVE                  0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_FMT_AC97                                 8:8 /* RWIVF */
#define NV_PAUDIO_PINS_SERIAL                                   9:9 /* RWIVF */
#define NV_PAUDIO_PINS_SERIAL_DISABLED                   0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_SERIAL_ENABLED                    0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_LEFT_JUST                              10:10 /* RWIVF */
#define NV_PAUDIO_PINS_LEFT_SENSE                             11:11 /* RWIVF */
#define NV_PAUDIO_PINS_LEFT_LOW                          0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_LEFT_HIGH                         0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL                                14:12 /* RWIVF */
#define NV_PAUDIO_PINS_CONTROL_0                         0x00000000 /* RWI-V */
#define NV_PAUDIO_PINS_CONTROL_1                         0x00000001 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_2                         0x00000002 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_3                         0x00000003 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_4                         0x00000004 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_5                         0x00000005 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_6                         0x00000006 /* RW--V */
#define NV_PAUDIO_PINS_CONTROL_7                         0x00000007 /* RW--V */
#define NV_PAUDIO_GREEN_0                                0x003000C0 /* RW-4R */
#define NV_PAUDIO_GREEN_0_CODEC                                 0:0 /* RWIVF */
#define NV_PAUDIO_GREEN_0_CODEC_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_CODEC_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_AUDIO                                 4:4 /* RWIVF */
#define NV_PAUDIO_GREEN_0_AUDIO_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_AUDIO_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_APUMP                                 8:8 /* RWIVF */
#define NV_PAUDIO_GREEN_0_APUMP_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_APUMP_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_CODEC_WARM                            8:8 /* RWIVF */
#define NV_PAUDIO_GREEN_0_CODEC_WARM_END                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_APUMP_WARM_UP                  0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_0                                 0x00300100 /* RW-4R */
#define NV_PAUDIO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PAUDIO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_OVERFLOW                               4:4 /* RWIVF */
#define NV_PAUDIO_INTR_0_OVERFLOW_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_OVERFLOW_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_OVERFLOW_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_AN_OVFL                                8:8 /* RWIVF */
#define NV_PAUDIO_INTR_0_AN_OVFL_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_AN_OVFL_PENDING                 0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_AN_OVFL_RESET                   0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_AN_UNFL                              12:12 /* RWIVF */
#define NV_PAUDIO_INTR_0_AN_UNFL_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_AN_UNFL_PENDING                 0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_AN_UNFL_RESET                   0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1                                 0x00300104 /* RW-4R */
#define NV_PAUDIO_INTR_1_SYNC                                   0:0 /* RWIVF */
#define NV_PAUDIO_INTR_1_SYNC_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_SYNC_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_SYNC_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_IDLE                                   4:4 /* RWIVF */
#define NV_PAUDIO_INTR_1_IDLE_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_IDLE_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_IDLE_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY                              8:8 /* RWIVF */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_TOO_BUSY                             12:12 /* RWIVF */
#define NV_PAUDIO_INTR_1_TOO_BUSY_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2                                 0x00300108 /* RW-4R */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE                           0:0 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE_PENDING            0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_INSTANCE_RESET              0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2_DMA_PRESENT                            4:4 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_PRESENT_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_PRESENT_PENDING             0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_PRESENT_RESET               0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2_DMA_PROTECT                            8:8 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_PROTECT_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_PROTECT_PENDING             0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_PROTECT_RESET               0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR                        12:12 /* RWIVF */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_PENDING           0x00000001 /* R---V */
#define NV_PAUDIO_INTR_2_DMA_BUS_ERROR_RESET             0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3                                 0x0030010C /* RW-4R */
#define NV_PAUDIO_INTR_3_PINS_0                                 0:0 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_0_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_0_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_0_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3_PINS_1                                 4:4 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_1_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_1_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_1_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3_PINS_2                                 8:8 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_2_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_2_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_2_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_3_PINS_3                               12:12 /* RWIVF */
#define NV_PAUDIO_INTR_3_PINS_3_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_3_PINS_3_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_3_PINS_3_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_0                              0x00300140 /* RW-4R */
#define NV_PAUDIO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW                            4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_AN_OVFL                             8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_AN_OVFL_DISABLED             0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_AN_OVFL_ENABLED              0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_AN_UNFL                           12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_AN_UNFL_DISABLED             0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_AN_UNFL_ENABLED              0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1                              0x00300144 /* RW-4R */
#define NV_PAUDIO_INTR_EN_1_SYNC                                0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_SYNC_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_SYNC_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_IDLE                                4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_IDLE_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_IDLE_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY                           8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_DISABLED           0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_ENABLED            0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY                          12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_2                              0x00300148 /* RW-4R */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE                        0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_NOT_PENDING     0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_PENDING         0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_INSTANCE_RESET           0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT                         4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_PENDING          0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_PRESENT_RESET            0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT                         8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_PENDING          0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_PROTECT_RESET            0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR                     12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_NOT_PENDING    0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_PENDING        0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_2_DMA_BUS_ERROR_RESET          0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3                              0x0030014C /* RW-4R */
#define NV_PAUDIO_INTR_EN_3_PINS_0                              0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_0_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_0_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_0_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3_PINS_1                              4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_1_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_1_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_1_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3_PINS_2                              8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_2_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_2_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_2_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_3_PINS_3                            12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_3_PINS_3_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_EN_3_PINS_3_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_EN_3_PINS_3_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_BLOCK_NEW                              0x00300200 /* RW-4R */
#define NV_PAUDIO_BLOCK_NEW_LENGTH                              7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_LG2                     14:12 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_1                  0x00000000 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_2                  0x00000001 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_4                  0x00000002 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_8                  0x00000003 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_16                 0x00000004 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_32                 0x00000005 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_64                 0x00000006 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_SUB_BLOCK_128                0x00000007 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE                           0x00300204 /* RW-4R */
#define NV_PAUDIO_BLOCK_ENGINE_LENGTH                           7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_LG2                  14:12 /* R-XVF */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_1               0x00000000 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_2               0x00000001 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_4               0x00000002 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_8               0x00000003 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_16              0x00000004 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_32              0x00000005 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_64              0x00000006 /* R---V */
#define NV_PAUDIO_BLOCK_ENGINE_SUB_BLOCK_128             0x00000007 /* R---V */
#define NV_PAUDIO_RAMAU                                  0x00300210 /* RW-4R */
#define NV_PAUDIO_RAMAU_BASE_ADDRESS                          15:12 /* RWXVF */
#define NV_PAUDIO_RAMAU_BASE_ADDRESS_1000                0x00001000 /* RWI-V */
#define NV_PAUDIO_ISA_SEL                                0x00300280 /* RW-4R */
#define NV_PAUDIO_ISA_SEL_IRQ                                   2:0 /* RWXVF */
#define NV_PAUDIO_ISA_SEL_IRQ_0                          0x00000001 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_IRQ_1                          0x00000002 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_IRQ_2                          0x00000004 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_DRQ                                   9:8 /* RWXVF */
#define NV_PAUDIO_ISA_SEL_DRQ_0                          0x00000001 /* RWI-V */
#define NV_PAUDIO_ISA_SEL_DRQ_1                          0x00000002 /* RWI-V */
#define NV_PAUDIO_TLB_PTE                                0x00300310 /* R-X4R */
#define NV_PAUDIO_TLB_PTE_PAGE                                31:10 /* R-XVF */
#define NV_PAUDIO_TLB_PTE_READ_ONLY                             1:1 /* R-XVF */
#define NV_PAUDIO_TLB_PTE_PRESENT                               0:0 /* R-XVF */
#define NV_PAUDIO_TLB_TAG                                0x00300320 /* R-X4R */
#define NV_PAUDIO_DMA_TLB_TAG                                 31:12 /* R-XVF */
#define NV_PAUDIO_DMAIA                                  0x00300330 /* R-X4R */
#define NV_PAUDIO_DMA_INSTANCE                                 31:2 /* R-XVF */
#define NV_PAUDIO_DMA_INSTANCE_TARGET                           1:0 /* R-XVF */
#define NV_PAUDIO_NEAR_MARK                              0x00300400 /* RW-4R */
#define NV_PAUDIO_NEAR_MARK_COUNT                               7:0 /* RWXUF */
#define NV_PAUDIO_SAMPLE_COUNT                           0x00300410 /* R--4R */
#define NV_PAUDIO_SAMPLE_COUNT_VALUE                            7:0 /* R-XUF */
#define NV_PAUDIO_SAMPLE_COUNT_BUFFER                           8:8 /* R-XUF */
#define NV_PAUDIO_PROG_COUNTER                           0x00300420 /* R--4R */
#define NV_PAUDIO_PROG_COUNTER_VALUE                            7:0 /* R-XUF */
#define NV_PAUDIO_AN_VOLUME                              0x00300430 /* RWI4R */
#define NV_PAUDIO_AN_VOLUME_INITIAL                               7 /* RWI-V */
#define NV_PAUDIO_AN_VOLUME_VALUE                               2:0 /* RWXUF */
#define NV_PAUDIO_TERM_USAGE                             0x00300C0C /* RW-4R */
#define NV_PAUDIO_TERMINATION_LEVEL                           31:16 /* RWXUF */
#define NV_PAUDIO_TERMINATION_LEVEL_DISABLED             0x00000000 /* RW--V */
#define NV_PAUDIO_USAGE_LEVEL                                  15:0 /* RWXUF */
#define NV_PAUDIO_CONTEXT                                0x00300E10 /* RW-4R */
#define NV_PAUDIO_CONTEXT_INSTANCE                             31:0 /* RWXUF */
#define NV_PAUDIO_BLASTER(i)                       (0x00301000+(i)) /* RW-1A */
#define NV_PAUDIO_BLASTER__SIZE_1                                 1 /*       */
#define NV_PAUDIO_BLASTER_DATA                                  7:0 /* RW-VF */
#define NV_PAUDIO_CODEC(i)                       (0x00302800+(i)*4) /* RW-4A */
#define NV_PAUDIO_CODEC__SIZE_1                                 256 /*       */
#define NV_PAUDIO_CODEC_DATA                                   19:0 /* RW-VF */
#define NV_PAUDIO_INST_TARGET_NVM                        0x00000000 /* RW--V */
#define NV_PAUDIO_INST_TARGET_CART                       0x00000001 /* RW--V */
#define NV_PAUDIO_INST_TARGET_PCI                        0x00000002 /* RW--V */
#define NV_PAUDIO_ROOT_INPUT                             0x00300C00 /* RW-4R */
#define NV_PAUDIO_ROOT_INPUT_TARGET                             1:0 /* RWXUF */
#define NV_PAUDIO_ROOT_INPUT_INSTANCE                          31:2 /* RWXUF */
#define NV_PAUDIO_ROOT_OUTPUT                            0x00300C04 /* RW-4R */
#define NV_PAUDIO_ROOT_OUTPUT_TARGET                            1:0 /* RWXUF */
#define NV_PAUDIO_ROOT_OUTPUT_INSTANCE                         31:2 /* RWXUF */
#define NV_PAUDIO_ROOT_NOTE                              0x00300C08 /* RW-4R */
#define NV_PAUDIO_ROOT_NOTE_TARGET                              1:0 /* RWXUF */
#define NV_PAUDIO_ROOT_NOTE_INSTANCE                           31:2 /* RWXUF */
#define NV_PAUDIO_DIAG(i)                        (0x00300C10+(i)*4) /* RW-4A */
#define NV_PAUDIO_DIAG__SIZE_1                                  252 /*       */
#define NV_PAUDIO_DIAG_DATA                                    31:0 /* RW-VF */
/* dev_graphics.ref */
#define NV_PGRAPH                             0x00401FFF:0x00400000 /* RW--D */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE                         1:1 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE                           2:2 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL             0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE                         3:3 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_BULK_READS                            4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BULK_READS_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BULK_READS_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE1                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE2                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_TILING                              16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_TILING_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_TILING_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D                  20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D                  21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y                           25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X                            8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X                            9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_INSTANCE                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CTX                                 20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CTX_DISABLED                   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CTX_ENABLED                    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CACHE                               24:24 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_CACHE_IGNORE                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_CACHE_FLUSH                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_SPARE1                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND                       0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE1                                4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO                             8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                      13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FOG_3D                              14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D                         15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D                      17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D                        20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ                        21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_PREFETCH                            24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_PREFETCH_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_PREFETCH_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
#define NV_PGRAPH_DEBUG_3_CULLING                               0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH                      4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D                         5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH                                7:7 /* CW-VF */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE                  0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE                0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ                        8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D                        9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ                   10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D                   11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT                        12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT                       14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D                           15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD                         17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK                          20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL                     21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK                        22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_HONOR_ALPHA                         24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_HONOR_ALPHA_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_HONOR_ALPHA_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE1                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_0_RESERVED                               0:0 /* RW-VF */
#define NV_PGRAPH_INTR_0_RESERVED_NOT_PENDING            0x00000000 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_RESET                  0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH                         4:4 /* RWIVF */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_VBLANK                                 8:8 /* RWIVF */
#define NV_PGRAPH_INTR_0_VBLANK_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_VBLANK_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_VBLANK_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_RANGE                                12:12 /* RWIVF */
#define NV_PGRAPH_INTR_0_RANGE_NOT_PENDING               0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_RANGE_PENDING                   0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RANGE_RESET                     0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_FORMAT                               20:20 /* RWIVF */
#define NV_PGRAPH_INTR_0_FORMAT_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_FORMAT_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_FORMAT_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP                         24:24 /* RWIVF */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_NOTIFY                               28:28 /* RWIVF */
#define NV_PGRAPH_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
#define NV_PGRAPH_INTR_1_METHOD                                 0:0 /* RWIVF */
#define NV_PGRAPH_INTR_1_METHOD_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_METHOD_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_METHOD_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DATA                                   4:4 /* RWIVF */
#define NV_PGRAPH_INTR_1_DATA_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DATA_PENDING                    0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DATA_RESET                      0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY                        12:12 /* RWIVF */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_RESET             0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_0_RESERVED                            0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RESERVED_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RESERVED_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH                      4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_VBLANK                              8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_VBLANK_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_VBLANK_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_RANGE                             12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RANGE_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RANGE_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_FORMAT                            20:20 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_FORMAT_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_FORMAT_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP                      24:24 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY                            28:28 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
#define NV_PGRAPH_INTR_EN_1_METHOD                              0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_METHOD_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_METHOD_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DATA                                4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DATA_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DATA_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY                     12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH_COLOR                              2:0 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R5G5B5                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R8G8B8                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R10G10B10             0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y8                    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y16                   0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_V8Y18U8Y08            0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y18V8Y08U8            0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y420                  0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA                              3:3 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1                             4:4 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT                        8:8 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS                         9:9 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2                           10:10 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE                           12:12 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY                       13:13 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK                       14:14 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP                        15:15 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER                       17:16 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_0                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_1                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_2                0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_3                0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0                      20:20 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1                      21:21 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2                      22:22 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3                      23:23 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG                     28:24 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD0          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_DST_SRC    0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_DST    0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_SRC    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_DST    0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_SRC    0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_DST    0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC0   0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC1   0x00000008 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_PAT    0x00000009 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_SRC    0x0000000a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_PAT    0x0000000b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_SRC    0x0000000c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_PAT    0x0000000d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_PAT_SRC    0x0000000e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD1          0x0000000f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_DST    0x00000010 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_DST_SRC    0x00000011 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_DST    0x00000012 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_PAT    0x00000013 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_PAT_SRC    0x00000014 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_PAT    0x00000015 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD2          0x00000016 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_BYPASS     0x00000017 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD0    0x00000018 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC_DST  0x00000019 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_DST_SRC  0x0000001a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD1    0x0000001b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD2    0x0000001c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC      0x0000001d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD3    0x0000001e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD4    0x0000001f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3                           29:29 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE                         31:31 /* CWIVF */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* CWI-V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_CTX_CACHE(i)                   (0x004001a0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE__SIZE_1                               8 /*       */
#define NV_PGRAPH_CTX_CACHE_COLOR                              2:0  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_ALPHA                              3:3  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE1                             4:4  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_MONO_FORMAT                        8:8  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DAC_BYPASS                         9:9  /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_SPARE2                            10:10 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_ZWRITE                            12:12 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_CHROMA_KEY                        13:13 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PLANE_MASK                        14:14 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_USER_CLIP                         15:15 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SRC_BUFFER                        17:16 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER0                       20:20 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER1                       21:21 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER2                       22:22 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER3                       23:23 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PATCH_CONFIG                      28:24 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE3                            29:29 /* RWXVF */
#define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_USER                               0x00400194 /* RW-4R */
#define NV_PGRAPH_CTX_USER_SUBCH                              15:13 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CLASS                              20:16 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CHID                               30:24 /* RWXVF */
#define NV_PGRAPH_FIFO                                   0x004006A4 /* RW-4R */
#define NV_PGRAPH_FIFO_ACCESS                                   0:0 /* RWIVF */
#define NV_PGRAPH_FIFO_ACCESS_DISABLED                   0x00000000 /* RW--V */
#define NV_PGRAPH_FIFO_ACCESS_ENABLED                    0x00000001 /* RWI-V */
#define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_ENGINE                           17:17 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_3D                                   24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_3D_IDLE                         0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_3D_BUSY                         0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_CACHE                                25:25 /* R-IVF */
#define NV_PGRAPH_STATUS_CACHE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_CACHE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_LIGHTING                             26:26 /* R-IVF */
#define NV_PGRAPH_STATUS_LIGHTING_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_LIGHTING_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_ZFIFO                                27:27 /* R-IVF */
#define NV_PGRAPH_STATUS_ZFIFO_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_ZFIFO_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_USER                            28:28 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_USER_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_USER_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x004006B4 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_MTHD                            12:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_SUBCH                          15:13 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CLASS                          20:16 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CHID                           30:24 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x004006B8 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_TRAPPED_INST                           0x004006BC /* R--4R */
#define NV_PGRAPH_TRAPPED_INST_VALUE                           15:0 /* R-XVF */
#define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
#define NV_PGRAPH_CLIP_MISC_REGIONS                             1:0 /* RWIUF */
#define NV_PGRAPH_CLIP_MISC_REGIONS_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_RENDER                              4:4 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_RENDER_INCLUDED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_RENDER_OCCLUDED              0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX                             8:8 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_SRC_CANVAS_MIN                         0x00400550 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MIN_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN                         0x00400558 /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX                         0x00400554 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX                         0x0040055C /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX_Y                            29:16 /* RWXUF */
#define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
#define NV_PGRAPH_CLIP0_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MIN_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
#define NV_PGRAPH_CLIP1_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
#define NV_PGRAPH_CLIP0_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
#define NV_PGRAPH_CLIP1_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX_Y                                 29:16 /* RWXSF */
#define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
#define NV_PGRAPH_DMA_INSTANCE                                 15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
#define NV_PGRAPH_NOTIFY_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY_REQ                                  16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                 0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_REQ_PENDING                     0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE                                 23:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_TYPE_HW                         0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_1                       0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_2                       0x00000002 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_3                       0x00000003 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_4                       0x00000004 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_5                       0x00000005 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_6                       0x00000006 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_7                       0x00000007 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_8                       0x00000008 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_9                       0x00000009 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_10                      0x0000000A /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_11                      0x0000000B /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_12                      0x0000000C /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_13                      0x0000000D /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_14                      0x0000000E /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_15                      0x0000000F /* RW--V */
#define NV_PGRAPH_INSTANCE                               0x00400688 /* RW-4R */
#define NV_PGRAPH_INSTANCE_TAG                                 15:0 /* RWXUF */
#define NV_PGRAPH_INSTANCE_TAG_INVALID                   0x00000000 /* RWI-V */
#define NV_PGRAPH_MEMFMT                                 0x0040068C /* RW-4R */
#define NV_PGRAPH_MEMFMT_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_MEMFMT_LINEAR                               16:16 /* RWIVF */
#define NV_PGRAPH_MEMFMT_LINEAR_OUT                      0x00000000 /* RW--V */
#define NV_PGRAPH_MEMFMT_LINEAR_IN                       0x00000001 /* RW--V */
#define NV_PGRAPH_BOFFSET0                               0x00400630 /* RW-4R */
#define NV_PGRAPH_BOFFSET0_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET0_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET1                               0x00400634 /* RW-4R */
#define NV_PGRAPH_BOFFSET1_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET1_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET2                               0x00400638 /* RW-4R */
#define NV_PGRAPH_BOFFSET2_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET2_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET3                               0x0040063C /* RW-4R */
#define NV_PGRAPH_BOFFSET3_LINADRS                             21:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET3_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH0                                0x00400650 /* RW-4R */
#define NV_PGRAPH_BPITCH0_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH1                                0x00400654 /* RW-4R */
#define NV_PGRAPH_BPITCH1_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH2                                0x00400658 /* RW-4R */
#define NV_PGRAPH_BPITCH2_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH3                                0x0040065C /* RW-4R */
#define NV_PGRAPH_BPITCH3_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPIXEL                                 0x004006a8 /* RW-4R */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT                             1:0 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0                                 2:2 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT                             5:4 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1                                 6:6 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT                             9:8 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2                               10:10 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT                           13:12 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3                               14:14 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX                            0x004006c0 /* RW-4R */
#define NV_PGRAPH_CACHE_INDEX_BANK                              2:2 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_BANK_10                    0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_BANK_32                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS                             12:3 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_ADRS_0                     0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_1024                  0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP                              14:13 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_OP_WR_CACHE                0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_CACHE                0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_INDEX                0x00000002 /* RW--V */
#define NV_PGRAPH_CACHE_RAM                              0x004006c4 /* RW-4R */
#define NV_PGRAPH_CACHE_RAM_VALUE                              31:0 /* RWXVF */
#define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATTERN(i)                     (0x00400610+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X8                0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1               0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X64               0x00000002 /* RW--V */
#define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_BLUE                              9:0 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_GREEN                           19:10 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_RED                             29:20 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_ALPHA                           30:30 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
#define NV_PGRAPH_PLANE_MASK_BLUE                               9:0 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_GREEN                            19:10 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_RED                              29:20 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_ALPHA                            30:30 /* RWXUF */
#define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
#define NV_PGRAPH_CHROMA_BLUE                                   9:0 /* RWXUF */
#define NV_PGRAPH_CHROMA_GREEN                                19:10 /* RWXUF */
#define NV_PGRAPH_CHROMA_RED                                  29:20 /* RWXUF */
#define NV_PGRAPH_CHROMA_ALPHA                                30:30 /* RWXUF */
#define NV_PGRAPH_BETA                                   0x00400640 /* RW-4R */
#define NV_PGRAPH_BETA_VALUE_FRACTION                         30:23 /* RWXUF */
#define NV_PGRAPH_CONTROL_OUT                            0x00400644 /* RW-4R */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR                      1:0 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U                            5:4 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V                            7:6 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING                         13:12 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_CULLING_ILLEGAL            0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER                         15:15 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_ILLEGAL       0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                      22:20 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE                     25:24 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ROP                             28:28 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_PGRAPH_DPRAM_INDEX                            0x00400648 /* RW-4R */
#define NV_PGRAPH_DPRAM_INDEX_ADRS                              5:0 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_ADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT                           10:8 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0              0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1              0x00000001 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0              0x00000002 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1              0x00000003 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE                  0x00000004 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA               0x00000005 /* RW--V */
#define NV_PGRAPH_DPRAM_DATA                             0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_0_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_1_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_0_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_1_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE                               0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE__ALIAS_1            NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_VALUE                               31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA                            0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA__ALIAS_1         NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_VALUE                            31:0 /* RWXVF */
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400514 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                       17:0 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    20:20 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400518 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE            0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2                         0x0040051C /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3                         0x00400520 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0                     0:0 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL         0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY                   4:4 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG                     12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL           0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE           0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX                    22:16 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0             0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX                   30:24 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0            0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400500 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x00400504 /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_EXCEPTIONS                             0x00400508 /* RW-4R */
#define NV_PGRAPH_EXCEPTIONS_VALID                             27:0 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_VALID_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN                         28:28 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN                        29:29 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX                         30:30 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX                        31:31 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
#define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
#define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_PASSTHRU                               0x0040054c /* RW-4R */
#define NV_PGRAPH_PASSTHRU_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_ZFOG_RAM(i)                    (0x00400580+(i)*4) /* RW-4A */
#define NV_PGRAPH_ZFOG_RAM__SIZE_1                               16 /*       */
#define NV_PGRAPH_ZFOG_RAM_ZETA                                15:0 /* RWXUF */
#define NV_PGRAPH_ZFOG_RAM_FOG                                23:16 /* RWXUF */
#define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
#define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_UV                                 0x004005c4 /* RW-4R */
#define NV_PGRAPH_D3D_UV_U_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_UV_V_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_ZETA                               0x004005c8 /* RW-4R */
#define NV_PGRAPH_D3D_ZETA_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_RGB                                0x004005cc /* RW-4R */
#define NV_PGRAPH_D3D_RGB_VALUE                                15:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG                                0x004005d0 /* RW-4R */
#define NV_PGRAPH_D3D_FOG_I0                                    3:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I1                                    7:4 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I2                                   11:8 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I3                                  15:12 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I4                                  19:16 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I5                                  23:20 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_FOG_VALUE                           31:24 /* RWXSF */
#define NV_PGRAPH_D3D_M                                  0x004005d4 /* RW-4R */
#define NV_PGRAPH_D3D_M_VALUE                                  31:0 /* RWXSF */
#define NV_PGRAPH_DMA_INTR_0                             0x00401100 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE                           0:0 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_NOT_PENDING        0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT                            4:4 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_NOT_PENDING         0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_RESET               0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION                         8:8 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_NOT_PENDING      0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR                           12:12 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY                           16:16 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_EN_0                          0x00401140 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE                        0:0 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT                         4:4 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION                      8:8 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR                        12:12 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY                        16:16 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_ACCESS                             0x00401200 /* -W-4R */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE                            0:0 /* -W-VF */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE_ENABLE              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_CONTROL                            0x00401210 /* RW-4R */
#define NV_PGRAPH_DMA_CONTROL_ADJUST                           11:0 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE                      16:16 /* RWXVF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_PRESENT         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE                     25:24 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_NVM            0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_CART           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_PCI            0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_AGP            0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_LIMIT                              0x00401220 /* RW-4R */
#define NV_PGRAPH_DMA_LIMIT_OFFSET                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_PTE                            0x00401230 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE                              0:0 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_NOT_PRESENT           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_PRESENT               0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS                            1:1 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_ONLY           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_WRITE          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_FRAME_ADDRESS                   31:12 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_TAG                            0x00401240 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_TAG_ADDRESS                         31:12 /* RWXUF */
#define NV_PGRAPH_DMA_ADJ_OFFSET                         0x00401250 /* RW-4R */
#define NV_PGRAPH_DMA_ADJ_OFFSET_VALUE                         31:0 /* RWXUF */
#define NV_PGRAPH_DMA_OFFSET                             0x00401260 /* RW-4R */
#define NV_PGRAPH_DMA_OFFSET_VALUE                             31:0 /* RW-UF */
#define NV_PGRAPH_DMA_SIZE                               0x00401270 /* RW-4R */
#define NV_PGRAPH_DMA_SIZE_VALUE                               21:0 /* RW-UF */
#define NV_PGRAPH_DMA_XLATE_INST                         0x00401280 /* RW-4R */
#define NV_PGRAPH_DMA_XLATE_INST_VALUE                         15:0 /* RWXUF */
#define NV_PGRAPH_DMA_Y_SIZE                             0x00401290 /* RW-4R */
#define NV_PGRAPH_DMA_Y_SIZE_VALUE                             10:0 /* RW-UF */
#define NV_PGRAPH_DMA_LINEAR_LIMIT                       0x00401400 /* RW-4R */
#define NV_PGRAPH_DMA_LINEAR_LIMIT_VALUE                       21:0 /* RWXUF */
#define NV_PGRAPH_DMA_START(i)                  (0x00401800+(i)*16) /* RW-4A */
#define NV_PGRAPH_DMA_START__SIZE_1                               3 /*       */
#define NV_PGRAPH_DMA_START_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_DMA_PITCH                              0x00401830 /* RW-4R */
#define NV_PGRAPH_DMA_PITCH_0                                  15:0 /* RWXS4 */
#define NV_PGRAPH_DMA_PITCH_1                                 31:16 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT                             0x00401840 /* RW-4R */
#define NV_PGRAPH_DMA_FORMAT_SRC                                2:0 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST                               10:8 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_MTMF_NOTIFY                        0x00401820 /* RW-4R */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE                         31:0 /* RWIVF */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE_HW                0x00000000 /* RWI-V */
/* dev_video.ref */
#define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
#define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
#define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
#define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
#define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
#define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
#define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
#define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
#define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
#define NV_PVIDEO_BUFF0_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
#define NV_PVIDEO_BUFF1_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
#define NV_PVIDEO_BUFF0_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
#define NV_PVIDEO_BUFF1_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
#define NV_PVIDEO_BUFF0_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_X_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_X_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
#define NV_PVIDEO_BUFF1_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_X_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_X_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
#define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
#define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
#define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
#define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
#define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
#define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
#define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
#define NV_PVIDEO_FIFO_THRES_SIZE                               6:3 /* RW--F */
#define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
#define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
#define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
#define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
#define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
#define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
#define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
#define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
#define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
#define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
#define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
#define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
#define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
#define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
#define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
#define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
#define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
#define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
#define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
#define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
#define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
#define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
/* vga.ref */
#define NV_PRMCIO                             0x00601FFF:0x00601000 /* RW--D */
#define NV_PRMCIO_INP0                                   0x006013c2 /* R--1R */
#define NV_PRMCIO_INP0__MONO                             0x006013ba /* R--1R */
#define NV_PRMCIO_INP0__COLOR                            0x006013da /* R--1R */
#define NV_PRMCIO_INP0__READ_MONO                        0x006013ca /* R--1R */
#define NV_PRMCIO_INP0__WRITE_MONO                       0x006013ba /* -W-1R */
#define NV_PRMCIO_INP0__WRITE_COLOR                      0x006013da /* -W-1R */
#define NV_PRMCIO_ARX                                    0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE                      0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ                       0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_MODE__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE_INDEX                          0x00000010 /*       */
#define NV_PRMCIO_AR_OSCAN__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_OSCAN__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_OSCAN_INDEX                         0x00000011 /*       */
#define NV_PRMCIO_AR_PLANE__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PLANE__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_PLANE_INDEX                         0x00000012 /*       */
#define NV_PRMCIO_AR_HPP__WRITE                          0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_HPP__READ                           0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_HPP_INDEX                           0x00000013 /*       */
#define NV_PRMCIO_AR_CSEL__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_CSEL__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_CSEL_INDEX                          0x00000014 /*       */
#define NV_PRMCIO_CRX__MONO                              0x006013b4 /* RW-1R */
#define NV_PRMCIO_CRX__COLOR                             0x006013d4 /* RW-1R */
#define NV_PRMCIO_CR__MONO                               0x006013b5 /* RW-1R */
#define NV_PRMCIO_CR__COLOR                              0x006013d5 /* RW-1R */
#define NV_PRMCIO_CRE__MONO                              0x006013b5 /* RW-1R */
#define NV_PRMCIO_CRE__COLOR                             0x006013d5 /* RW-1R */

// actually an NV4 register, but nv3ddraw uses this file for both NV3 and NV4
#define NV_PCRTC_RASTER                                  0x00600808 /* R-I4R */
#define NV_PCRTC_RASTER_POSITION                               10:0 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD                               13:12 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD_DISPLAY                  0x00000000 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_BEFORE                   0x00000001 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_AFTER                    0x00000002 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK                            16:16 /* R---F */
#define NV_PCRTC_RASTER_VERT_BLANK_ACTIVE                0x00000001 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK_INACTIVE              0x00000000 /* R---V */

/* vga.ref */
#define NV_CIO                                          0x3DF:0x3B0 /* ----- */
#define NV_CIO_INP0                                      0x000003c2 /* R--1R */
#define NV_CIO_INP0__MONO                                0x000003ba /* R--1R */
#define NV_CIO_INP0__COLOR                               0x000003da /* R--1R */
#define NV_CIO_INP0__READ_MONO                           0x000003ca /* R--1R */
#define NV_CIO_INP0__WRITE_MONO                          0x000003ba /* -W-1R */
#define NV_CIO_INP0__WRITE_COLOR                         0x000003da /* -W-1R */
#define NV_CIO_ARX                                       0x000003c0 /* RW-1R */
#define NV_CIO_AR_PALETTE__WRITE                         0x000003c0 /* -W-1R */
#define NV_CIO_AR_PALETTE__READ                          0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_MODE__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE_INDEX                             0x00000010 /*       */
#define NV_CIO_AR_OSCAN__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_OSCAN__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_OSCAN_INDEX                            0x00000011 /*       */
#define NV_CIO_AR_PLANE__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_PLANE__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_PLANE_INDEX                            0x00000012 /*       */
#define NV_CIO_AR_HPP__WRITE                             0x000003c0 /* -W-1R */
#define NV_CIO_AR_HPP__READ                              0x000003c1 /* R--1R */
#define NV_CIO_AR_HPP_INDEX                              0x00000013 /*       */
#define NV_CIO_AR_CSEL__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_CSEL__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_CSEL_INDEX                             0x00000014 /*       */
#define NV_CIO_CRX__MONO                                 0x000003b4 /* RW-1R */
#define NV_CIO_CRX__COLOR                                0x000003d4 /* RW-1R */
#define NV_CIO_CR__MONO                                  0x000003b5 /* RW-1R */
#define NV_CIO_CR__COLOR                                 0x000003d5 /* RW-1R */
#define NV_CIO_CR_HDT_INDEX                              0x00000000 /*       */
#define NV_CIO_CR_HDE_INDEX                              0x00000001 /*       */
#define NV_CIO_CR_HBS_INDEX                              0x00000002 /*       */
#define NV_CIO_CR_HBE_INDEX                              0x00000003 /*       */
#define NV_CIO_CR_HBE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_HRS_INDEX                              0x00000004 /*       */
#define NV_CIO_CR_HRE_INDEX                              0x00000005 /*       */
#define NV_CIO_CR_HRE_HBE_5                                     7:7 /* RW--F */
#define NV_CIO_CR_HRE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_VDT_INDEX                              0x00000006 /*       */
#define NV_CIO_CR_OVL_INDEX                              0x00000007 /*       */
#define NV_CIO_CR_OVL_VDE_8                                     1:1 /* RW--F */
#define NV_CIO_CR_OVL_VDE_9                                     6:6 /* RW--F */
#define NV_CIO_CR_OVL_VDT_8                                     0:0 /* RW--F */
#define NV_CIO_CR_OVL_VDT_9                                     5:5 /* RW--F */
#define NV_CIO_CR_OVL_VBS_8                                     3:3 /* RW--F */
#define NV_CIO_CR_OVL_VRS_8                                     2:2 /* RW--F */
#define NV_CIO_CR_OVL_VRS_9                                     7:7 /* RW--F */
#define NV_CIO_CR_RSAL_INDEX                             0x00000008 /*       */
#define NV_CIO_CR_RSAL_PANNING                                  6:5 /* RW--F */
#define NV_CIO_CR_CELL_HT_INDEX                          0x00000009 /*       */
#define NV_CIO_CR_CELL_HT_SCANDBL                               7:7 /* RW--F */
#define NV_CIO_CR_CELL_HT_VBS_9                                 5:5 /* RW--F */
#define NV_CIO_CR_CURS_ST_INDEX                          0x0000000A /*       */
#define NV_CIO_CR_CURS_END_INDEX                         0x0000000B /*       */
#define NV_CIO_CR_SA_HI_INDEX                            0x0000000C /*       */
#define NV_CIO_CR_SA_LO_INDEX                            0x0000000D /*       */
#define NV_CIO_CR_TCOFF_HI_INDEX                         0x0000000E /*       */
#define NV_CIO_CR_TCOFF_LO_INDEX                         0x0000000F /*       */
#define NV_CIO_CR_VRS_INDEX                              0x00000010 /*       */
#define NV_CIO_CR_VRE_INDEX                              0x00000011 /*       */
#define NV_CIO_CR_VRE_3_0                                       3:0 /* RW--F */
#define NV_CIO_CR_VDE_INDEX                              0x00000012 /*       */
#define NV_CIO_CR_OFFSET_INDEX                           0x00000013 /*       */
#define NV_CIO_CR_ULINE_INDEX                            0x00000014 /*       */
#define NV_CIO_CR_VBS_INDEX                              0x00000015 /*       */
#define NV_CIO_CR_VBE_INDEX                              0x00000016 /*       */
#define NV_CIO_CR_MODE_INDEX                             0x00000017 /*       */
#define NV_CIO_CR_LCOMP_INDEX                            0x00000018 /*       */
#define NV_CIO_CR_GDATA_INDEX                            0x00000022 /*       */
#define NV_CIO_CR_ARFF_INDEX                             0x00000024 /*       */
#define NV_CIO_CR_ARX_INDEX                              0x00000026 /*       */
#define NV_CIO_CRE__MONO                                 0x000003b5 /* RW-1R */
#define NV_CIO_CRE__COLOR                                0x000003d5 /* RW-1R */
#define NV_CIO_CRE_RPC0_INDEX                           0x00000019 /*       */
#define NV_CIO_CRE_RPC0_START                                   4:0 /* RW--F */
#define NV_CIO_CRE_RPC0_OFFSET_10_8                             7:5 /* RW--F */
#define NV_CIO_CRE_RPC1_INDEX                            0x0000001A /*       */
#define NV_CIO_CRE_RPC1_LARGE                                  2:2 /* RW--F */
#define NV_CIO_CRE_FF_INDEX                              0x0000001B /*       */
#define NV_CIO_CRE_FF_BURST                                     2:0 /* RW--F */
#define NV_CIO_CRE_FF_BURST_8                            0x00000000 /* RW--V */
#define NV_CIO_CRE_FF_BURST_32                           0x00000001 /* RW--V */
#define NV_CIO_CRE_FF_BURST_64                           0x00000002 /* RW--V */
#define NV_CIO_CRE_FF_BURST_128                          0x00000003 /* RW--V */
#define NV_CIO_CRE_FF_BURST_256                          0x00000004 /* RW--V */
#define NV_CIO_CRE_ENH_INDEX                             0x0000001C /*       */
#define NV_CIO_CRE_PAGE0_INDEX                           0x0000001D /*       */
#define NV_CIO_CRE_PAGE1_INDEX                           0x0000001E /*       */
#define NV_CIO_CRE_FFLWM__INDEX                          0x00000020 /*       */
#define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
#define NV_CIO_CRE_LSR_INDEX                             0x00000025 /*       */
#define NV_CIO_CRE_LSR_FORMAT                                   7:6 /* RW--F */
#define NV_CIO_CRE_LSR_FORMAT_8BIT                       0x00000001 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_555                        0x00000002 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_565                        0x00000003 /* RW--V */
#define NV_CIO_CRE_LSR_VDE_10                                   1:1 /* RW--F */
#define NV_CIO_CRE_LSR_VDT_10                                   0:0 /* RW--F */
#define NV_CIO_CRE_LSR_HBE_6                                    4:4 /* RW--F */
#define NV_CIO_CRE_LSR_VBS_10                                   3:3 /* RW--F */
#define NV_CIO_CRE_LSR_VRS_10                                   2:2 /* RW--F */
#define NV_CIO_CRE_PIXEL_INDEX                           0x00000028 /*       */
#define NV_CIO_CRE_PIXEL_FORMAT                                 1:0 /* RW--F */
#define NV_CIO_CRE_PIXEL_FORMAT_VGA                      0x00000000 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_8BPP                     0x00000001 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_16BPP                    0x00000002 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_32BPP                    0x00000003 /* RW--V */
#define NV_CIO_CRE_PIXEL_TILING                                 2:2 /* RW--F */
#define NV_CIO_CRE_DEC__INDEX                            0x00000029 /*       */
#define NV_CIO_CRE_OSCOL__INDEX                          0x0000002A /*       */
#define NV_CIO_CRE_SCRATCH0__INDEX                       0x0000002B /*       */
#define NV_CIO_CRE_SCRATCH1__INDEX                       0x0000002C /*       */
#define NV_CIO_CRE_HEB__INDEX                            0x0000002D /*       */
#define NV_CIO_CRE_HEB_ILC_8                                    4:4 /* RW--F */
#define NV_CIO_CRE_HEB_HRS_8                                    3:3 /* RW--F */
#define NV_CIO_CRE_HEB_HBS_8                                    2:2 /* RW--F */
#define NV_CIO_CRE_HEB_HDE_8                                    1:1 /* RW--F */
#define NV_CIO_CRE_HEB_HDT_8                                    0:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR0_INDEX                      0x00000030 /*       */
#define NV_CIO_CRE_HCUR_ADDR0_ADR                               6:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_INDEX                      0x00000031 /*       */
#define NV_CIO_CRE_HCUR_ADDR1_ADR                               7:3 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_CUR_DBL                           1:1 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_ENABLE                            0:0 /* RW--F */
#define NV_CIO_CRE_VID_END0__INDEX                       0x00000032 /*       */
#define NV_CIO_CRE_VID_END_7_0                                  7:0 /* RW--F */
#define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
#define NV_CIO_CRE_VID_END_ENABLE                               4:4 /* RW--F */
#define NV_CIO_CRE_VID_END_10_8                                 2:0 /* RW--F */
#define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
#define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
#define NV_CIO_CRE_RMA__INDEX                            0x00000038 /*       */
#define NV_CIO_CRE_ILACE__INDEX                          0x00000039 /*       */
#define NV_CIO_CRE_TREG__INDEX                           0x0000003D /*       */
#define NV_CIO_CRE_TREG_HCNT                                    6:6 /* RW--F */
#define NV_CIO_CRE_TREG_VCNT                                    4:4 /* RW--F */
#define NV_CIO_CRE_TREG_HCNT_INDEX                       0x00000000 /*       */
#define NV_CIO_CRE_TREG_VCNTA_INDEX                      0x00000006 /*       */
#define NV_CIO_CRE_TREG_VCNTB_INDEX                      0x00000007 /*       */
#define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
#define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
/* vga.ref */
#define NV_PRMVIO                             0x000C7FFF:0x000C0000 /* RW--D */
#define NV_PRMVIO_MBEN                                   0x000C0094 /* RW-1R */
#define NV_PRMVIO_ADDEN                                  0x000C46e8 /* RW-1R */
#define NV_PRMVIO_VSE1                                   0x000C0102 /* RW-1R */
#define NV_PRMVIO_VSE2                                   0x000C03c3 /* RW-1R */
#define NV_PRMVIO_MISC__READ                             0x000C03cc /* R--1R */
#define NV_PRMVIO_MISC__WRITE                            0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                                    0x000C03c4 /* RW-1R */
#define NV_PRMVIO_SR_RESET                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_RESET_INDEX                         0x00000000 /*       */
#define NV_PRMVIO_SR_CLOCK                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CLOCK_INDEX                         0x00000001 /*       */
#define NV_PRMVIO_SR_PLANE_MASK                          0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_PLANE_MASK_INDEX                    0x00000002 /*       */
#define NV_PRMVIO_SR_CHAR_MAP                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CHAR_MAP_INDEX                      0x00000003 /*       */
#define NV_PRMVIO_SR_MEM_MODE                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_MEM_MODE_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_SR_LOCK                                0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_LOCK_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GRX                                    0x000C03ce /* RW-1R */
#define NV_PRMVIO_GX_SR                                  0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SR_INDEX                            0x00000000 /*       */
#define NV_PRMVIO_GX_SREN                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SREN_INDEX                          0x00000001 /*       */
#define NV_PRMVIO_GX_CCOMP                               0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_CCOMP_INDEX                         0x00000002 /*       */
#define NV_PRMVIO_GX_ROP                                 0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_ROP_INDEX                           0x00000003 /*       */
#define NV_PRMVIO_GX_READ_MAP                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_READ_MAP_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_GX_MODE                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MODE_INDEX                          0x00000005 /*       */
#define NV_PRMVIO_GX_MISC                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MISC_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GX_DONT_CARE                           0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_DONT_CARE_INDEX                     0x00000007 /*       */
#define NV_PRMVIO_GX_BIT_MASK                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_BIT_MASK_INDEX                      0x00000008 /*       */
/* vga.ref */
#define NV_PRMVGA                             0x000BFFFF:0x000A0000 /* RW--D */
/* dev_media.ref */
#define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
#define NV_PME_DEBUG_0                                   0x00200080 /* RWI4R */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH                         0:0 /* RWI-F */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_DISABLED         0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_ENABLED          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1                                   0x00200084 /* RWI4R */
#define NV_PME_DEBUG_1_SEL                                      1:0 /* RWI-F */
#define NV_PME_DEBUG_1_SEL_VIPCLK                        0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_SEL_MCLK                          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1_SEL_GLOB                          0x00000002 /* RW--V */
#define NV_PME_DEBUG_1_VIPCLK_SEL                               6:4 /* RWI-F */
#define NV_PME_DEBUG_1_VIPCLK_SEL_DEFAULT                0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_MCLK_SEL                                 9:8 /* RWI-F */
#define NV_PME_DEBUG_1_MCLK_SEL_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
#define NV_PME_INTR_0_NOTIFY                                    0:0 /* RWIVF */
#define NV_PME_INTR_0_NOTIFY_NOT_PENDING                 0x00000000 /* R-I-V */
#define NV_PME_INTR_0_NOTIFY_PENDING                     0x00000001 /* R---V */
#define NV_PME_INTR_0_NOTIFY_RESET                       0x00000001 /* -W--V */
#define NV_PME_INTR_0_VMI                                       4:4 /* RWIVF */
#define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
#define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
#define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
#define NV_PME_INTR_EN_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PME_INTR_EN_0_NOTIFY_DISABLED                 0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_NOTIFY_ENABLED                  0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VMI                                    4:4 /* RWIVF */
#define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
#define NV_PME_CONFIG_0_CCIR656                                 0:0 /* RWIVF */
#define NV_PME_CONFIG_0_CCIR656_DISABLED                 0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_CCIR656_ENABLED                  0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VMI                                     4:4 /* RWIVF */
#define NV_PME_CONFIG_0_VMI_DISABLED                     0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VMI_ENABLED                      0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
#define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
#define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
#define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
#define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
#define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
#define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
#define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
#define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */
#define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */
#define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */
#define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */
#define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */
#define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */
#define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
#define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */
#define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */
#define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */
#define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */
#define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */
#define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */
#define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */
#define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
#define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */
#define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
#define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */
#define NV_PME_VBI_BUFF0_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */
#define NV_PME_VBI_BUFF1_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */
#define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */
#define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */
#define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */
#define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
#define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
#define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
#define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI                                       0x002003a4 /* RWI4R */
#define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
#define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
#define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */
#define NV_PME_IMAGE_BUFF0_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */
#define NV_PME_IMAGE_BUFF1_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */
#define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */
#define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */
#define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */
#define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
#define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
#define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
#define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
#define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_Y_CROP                              0x0020042c /* RW-4R */
#define NV_PME_IMAGE_Y_CROP_STARTLINE                           8:0 /* RWXVF */
#define NV_PME_FIFO_LINE_START                           0x00200480 /* R--4R */
#define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* R-XVF */
#define NV_PME_FIFO_CURRENT                              0x00200484 /* RWI4R */
#define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
#define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
#define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
#define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R--VF */
#define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
#define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */
#define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
/* usr_beta_solid.ref */
#define NV_UBETA                              0x00411FFF:0x00410000 /* -W--D */
#define NV_UBETA_CTX_SWITCH                              0x00410000 /* -W-4R */
#define NV_UBETA_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBETA_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBETA_SET_NOTIFY                              0x00410104 /* -W-4R */
#define NV_UBETA_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBETA_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBETA_SET_BETA1D31                            0x00410300 /* -W-4R */
#define NV_UBETA_SET_BETA1D31_VALUE_FRACTION                  30:21 /* -W-UF */
#define NV_UBETA_SET_BETA1D31_VALUE                           31:31 /* -W-SF */
/* usr_rop_solid.ref */
#define NV_UROP                               0x00421FFF:0x00420000 /* -W--D */
#define NV_UROP_CTX_SWITCH                               0x00420000 /* -W-4R */
#define NV_UROP_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UROP_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UROP_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UROP_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UROP_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UROP_SET_NOTIFY                               0x00420104 /* -W-4R */
#define NV_UROP_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UROP_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UROP_SET_ROP                                  0x00420300 /* -W-4R */
#define NV_UROP_SET_ROP_VALUE                                   7:0 /* -W-VF */
/* usr_color_key.ref */
#define NV_UCHROMA                            0x00431FFF:0x00430000 /* -W--D */
#define NV_UCHROMA_CTX_SWITCH                            0x00430000 /* -W-4R */
#define NV_UCHROMA_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UCHROMA_SET_NOTIFY                            0x00430104 /* -W-4R */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UCHROMA_SET_COLOR                             0x00430304 /* -W-4R */
#define NV_UCHROMA_SET_COLOR_VALUE                             31:0 /* -W-VF */
/* usr_plane_switch.ref */
#define NV_UPLANE                             0x00441FFF:0x00440000 /* -W--D */
#define NV_UPLANE_CTX_SWITCH                             0x00440000 /* -W-4R */
#define NV_UPLANE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPLANE_SET_NOTIFY                             0x00440104 /* -W-4R */
#define NV_UPLANE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPLANE_SET_COLOR                              0x00440304 /* -W-4R */
#define NV_UPLANE_SET_COLOR_VALUE                              31:0 /* -W-VF */
/* usr_clipping.ref */
#define NV_UCLIP                              0x00451FFF:0x00450000 /* -W--D */
#define NV_UCLIP_CTX_SWITCH                              0x00450000 /* -W-4R */
#define NV_UCLIP_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UCLIP_SET_NOTIFY                              0x00450104 /* -W-4R */
#define NV_UCLIP_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UCLIP_SET_RECT_0                              0x00450300 /* -W-4R */
#define NV_UCLIP_SET_RECT_0_X                                  15:0 /* -W-SF */
#define NV_UCLIP_SET_RECT_0_Y                                 31:16 /* -W-SF */
#define NV_UCLIP_SET_RECT_1                              0x00450304 /* -W-4R */
#define NV_UCLIP_SET_RECT_1_WIDTH                              15:0 /* -W-UF */
#define NV_UCLIP_SET_RECT_1_HEIGHT                            31:16 /* -W-UF */
/* usr_d3d0_triangle_zeta.ref */
#define NV_UD3D0Z                             0x00571FFF:0x00570000 /* -W--D */
#define NV_UD3D0Z_CTX_SWITCH                             0x00570000 /* -W-4R */
#define NV_UD3D0Z_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UD3D0Z_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UD3D0Z_SET_NOTIFY                             0x00570104 /* -W-4R */
#define NV_UD3D0Z_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UD3D0Z_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UD3D0Z_TEXTURE_OFFSET                         0x00570304 /* -W-4R */
#define NV_UD3D0Z_TEXTURE_OFFSET_VALUE                         31:0 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT                         0x00570308 /* -W-4R */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK          15:0 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY                    16:16 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_DISABLED      0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_ENABLED       0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT                 21:20 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5   0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5   0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4B4   0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5     0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN                     27:24 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1X1            0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2X2            0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_4X4            0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_8X8            0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_16X16          0x00000004 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_32X32          0x00000005 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_64X64          0x00000006 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_128X128        0x00000007 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_256X256        0x00000008 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_512X512        0x00000009 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1024X1024      0x0000000a /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2048X2048      0x0000000b /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX                     31:28 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1X1            0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2X2            0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_4X4            0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_8X8            0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_16X16          0x00000004 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_32X32          0x00000005 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_64X64          0x00000006 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_128X128        0x00000007 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_256X256        0x00000008 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_512X512        0x00000009 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1024X1024      0x0000000a /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2048X2048      0x0000000b /* -W-UV */
#define NV_UD3D0Z_FILTER                                 0x0057030C /* -W-4R */
#define NV_UD3D0Z_FILTER_SPREADX                                7:0 /* -W-UF */
#define NV_UD3D0Z_FILTER_SPREADY                               15:8 /* -W-UF */
#define NV_UD3D0Z_FILTER_MIPMAP                               23:16 /* -W-SF */
#define NV_UD3D0Z_FILTER_TURBO                                31:24 /* -W-SF */
#define NV_UD3D0Z_FOG_COLOR                              0x00570310 /* -W-4R */
#define NV_UD3D0Z_FOG_COLOR_BLU                                 7:0 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_GRN                                15:8 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_RED                               23:16 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_VALUE                              31:0 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT                            0x00570314 /* -W-4R */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR                      1:0 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U                            5:4 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V                            7:6 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING                         13:12 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER                         15:15 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE                      22:20 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE                     25:24 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ROP                             28:28 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_UD3D0Z_SPECULAR(i)                   (0x00571000+(i)*32) /* -W-4A */
#define NV_UD3D0Z_SPECULAR__SIZE_1                              128 /*       */
#define NV_UD3D0Z_SPECULAR_I0                                   3:0 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I1                                   7:4 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I2                                  11:8 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I3                                 15:12 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I4                                 19:16 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I5                                 23:20 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_FOG                                31:24 /* -W-UF */
#define NV_UD3D0Z_COLOR(i)                      (0x00571004+(i)*32) /* -W-4A */
#define NV_UD3D0Z_COLOR__SIZE_1                                 128 /*       */
#define NV_UD3D0Z_COLOR_B8                                      7:0 /* -W-UF */
#define NV_UD3D0Z_COLOR_G8                                     16:8 /* -W-UF */
#define NV_UD3D0Z_COLOR_R8                                    23:16 /* -W-UF */
#define NV_UD3D0Z_COLOR_A8                                    32:24 /* -W-UF */
#define NV_UD3D0Z_X(i)                          (0x00571008+(i)*32) /* -W-4A */
#define NV_UD3D0Z_X__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_X_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_Y(i)                          (0x0057100C+(i)*32) /* -W-4A */
#define NV_UD3D0Z_Y__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_Y_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_Z(i)                          (0x00571010+(i)*32) /* -W-4A */
#define NV_UD3D0Z_Z__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_Z_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_M(i)                          (0x00571014+(i)*32) /* -W-4A */
#define NV_UD3D0Z_M__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_M_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_U(i)                          (0x00571018+(i)*32) /* -W-4A */
#define NV_UD3D0Z_U__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_U_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_V(i)                          (0x0057101c+(i)*32) /* -W-4A */
#define NV_UD3D0Z_V__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_V_VALUE                                      31:0 /* -W-FF */
/* usr_pattern.ref */
#define NV_UPATT                              0x00461FFF:0x00460000 /* -W--D */
#define NV_UPATT_CTX_SWITCH                              0x00460000 /* -W-4R */
#define NV_UPATT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UPATT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UPATT_SET_NOTIFY                              0x00460104 /* -W-4R */
#define NV_UPATT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE                               0x00460308 /* -W-4R */
#define NV_UPATT_SET_SHAPE_VALUE                                1:0 /* -W-VF */
#define NV_UPATT_SET_SHAPE_VALUE_8X8                     0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_64X1                    0x00000001 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_1X64                    0x00000002 /* -W--V */
#define NV_UPATT_SET_COLOR0                              0x00460310 /* -W-4R */
#define NV_UPATT_SET_COLOR0_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_COLOR1                              0x00460314 /* -W-4R */
#define NV_UPATT_SET_COLOR1_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_PATTERN(i)                  (0x00460318+(i)*4) /* -W-4A */
#define NV_UPATT_SET_PATTERN__SIZE_1                              2 /*       */
#define NV_UPATT_SET_PATTERN_BITMAP                            31:0 /* -W-VF */
/* usr_point.ref */
#define NV_UPOINT                             0x00481FFF:0x00480000 /* -W--D */
#define NV_UPOINT_CTX_SWITCH                             0x00480000 /* -W-4R */
#define NV_UPOINT_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPOINT_SET_NOTIFY                             0x00480104 /* -W-4R */
#define NV_UPOINT_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPOINT_COLOR                                  0x00480304 /* -W-4R */
#define NV_UPOINT_COLOR_VALUE                                  31:0 /* -W-VF */
#define NV_UPOINT_POINT(i)                       (0x00480400+(i)*4) /* -W-4A */
#define NV_UPOINT_POINT__SIZE_1                                  32 /*       */
#define NV_UPOINT_POINT_X                                      15:0 /* -W-SF */
#define NV_UPOINT_POINT_Y                                     31:16 /* -W-SF */
#define NV_UPOINT_POINT32_0(i)                   (0x00480480+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_0__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_0_X                                  31:0 /* -W-SF */
#define NV_UPOINT_POINT32_1(i)                   (0x00480484+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_1__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_1_Y                                  31:0 /* -W-SF */
#define NV_UPOINT_CPOINT_0(i)                    (0x00480500+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_0__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_0_COLOR                               31:0 /* -W-VF */
#define NV_UPOINT_CPOINT_1(i)                    (0x00480504+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_1__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_1_X                                   15:0 /* -W-SF */
#define NV_UPOINT_CPOINT_1_Y                                  31:16 /* -W-SF */
/* usr_pointz.ref */
#define NV_UPOINTZ                            0x00581FFF:0x00580000 /* -W--D */
#define NV_UPOINTZ_CTX_SWITCH                            0x00580000 /* -W-4R */
#define NV_UPOINTZ_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UPOINTZ_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UPOINTZ_SET_NOTIFY                            0x00580104 /* -W-4R */
#define NV_UPOINTZ_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UPOINTZ_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UPOINTZ_CONTROL_OUT                           0x00580304 /* -W-4R */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE                   19:16 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_FALSE        0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LT           0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_EQ           0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LE           0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GT           0x00000005 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_NE           0x00000006 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GE           0x00000007 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_TRUE         0x00000008 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE                     22:20 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_NEVER          0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALWAYS         0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE                    25:24 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_NEVER         0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA         0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA    0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ROP                            28:28 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ROP_BLEND_AND             0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ROP_ADD_WITH_SATURATION   0x00000001 /* -W-UV */
#define NV_UPOINTZ_POINT                                 0x005807FC /* -W-4R */
#define NV_UPOINTZ_POINT_X                                     15:0 /* -W-SF */
#define NV_UPOINTZ_POINT_Y                                    31:16 /* -W-SF */
#define NV_UPOINTZ_COLOR(i)                      (0x00580800+(i)*8) /* -W-4A */
#define NV_UPOINTZ_COLOR__SIZE_1                                256 /*       */
#define NV_UPOINTZ_COLOR_VALUE                                 31:0 /* -W-VF */
#define NV_UPOINTZ_ZETA(i)                       (0x00580804+(i)*8) /* -W-4A */
#define NV_UPOINTZ_ZETA__SIZE_1                                 256 /*       */
#define NV_UPOINTZ_ZETA_VALUE                                  31:0 /* -W-VF */
/* usr_line.ref */
#define NV_ULINE                              0x00491FFF:0x00490000 /* -W--D */
#define NV_ULINE_CTX_SWITCH                              0x00490000 /* -W-4R */
#define NV_ULINE_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_ULINE_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_ULINE_SET_NOTIFY                              0x00490104 /* -W-4R */
#define NV_ULINE_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_ULINE_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_ULINE_COLOR                                   0x00490304 /* -W-4R */
#define NV_ULINE_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_ULINE_LINE_0(i)                       (0x00490400+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_0__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_0_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_0_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE_1(i)                       (0x00490404+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_1__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_1_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_1_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE32_0(i)                    (0x00490480+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_0__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_0_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_1(i)                    (0x00490484+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_1__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_1_Y                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_2(i)                    (0x00490488+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_2__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_2_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_3(i)                    (0x0049048C+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_3__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_3_Y                                    31:0 /* -W-SF */
#define NV_ULINE_POLYLINE(i)                     (0x00490500+(i)*4) /* -W-4A */
#define NV_ULINE_POLYLINE__SIZE_1                                32 /*       */
#define NV_ULINE_POLYLINE_X                                    15:0 /* -W-SF */
#define NV_ULINE_POLYLINE_Y                                   31:16 /* -W-SF */
#define NV_ULINE_POLYLINE32_0(i)                 (0x00490580+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_0__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_0_X                                31:0 /* -W-SF */
#define NV_ULINE_POLYLINE32_1(i)                 (0x00490584+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_1__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_1_Y                                31:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_0(i)                  (0x00490600+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_0__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_0_COLOR                             31:0 /* -W-VF */
#define NV_ULINE_CPOLYLINE_1(i)                  (0x00490604+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_1__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_1_X                                 15:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_1_Y                                31:16 /* -W-SF */
/* usr_lin.ref */
#define NV_ULIN                               0x004A1FFF:0x004A0000 /* -W--D */
#define NV_ULIN_CTX_SWITCH                               0x004A0000 /* -W-4R */
#define NV_ULIN_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_ULIN_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_ULIN_SET_NOTIFY                               0x004A0104 /* -W-4R */
#define NV_ULIN_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_ULIN_COLOR                                    0x004A0304 /* -W-4R */
#define NV_ULIN_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_ULIN_LIN_0(i)                         (0x004A0400+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_0__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_0_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_0_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN_1(i)                         (0x004A0404+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_1__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_1_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_1_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN32_0(i)                      (0x004A0480+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_0__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_0_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_1(i)                      (0x004A0484+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_1__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_1_Y                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_2(i)                      (0x004A0488+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_2__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_2_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_3(i)                      (0x004A048C+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_3__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_3_Y                                      31:0 /* -W-SF */
#define NV_ULIN_POLYLIN(i)                       (0x004A0500+(i)*4) /* -W-4A */
#define NV_ULIN_POLYLIN__SIZE_1                                  32 /*       */
#define NV_ULIN_POLYLIN_X                                      15:0 /* -W-SF */
#define NV_ULIN_POLYLIN_Y                                     31:16 /* -W-SF */
#define NV_ULIN_POLYLIN32_0(i)                   (0x004A0580+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_0__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_0_X                                  31:0 /* -W-SF */
#define NV_ULIN_POLYLIN32_1(i)                   (0x004A0584+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_1__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_1_Y                                  31:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_0(i)                    (0x004A0600+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_0__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_0_COLOR                               31:0 /* -W-VF */
#define NV_ULIN_CPOLYLIN_1(i)                    (0x004A0604+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_1__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_1_X                                   15:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_1_Y                                  31:16 /* -W-SF */
/* usr_mem_to_mem.ref */
#define NV_UMEMFMT                            0x004D1FFF:0x004D0000 /* -W--D */
#define NV_UMEMFMT_CTX_SWITCH                            0x004D0000 /* -W-4R */
#define NV_UMEMFMT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UMEMFMT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UMEMFMT_SET_NOTIFY                            0x004D0104 /* -W-4R */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UMEMFMT_OFFSET_IN                             0x004D030C /* -W-4R */
#define NV_UMEMFMT_OFFSET_IN_VALUE                             31:0 /* -W-UF */
#define NV_UMEMFMT_OFFSET_OUT                            0x004D0310 /* -W-4R */
#define NV_UMEMFMT_OFFSET_OUT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_PITCH_IN                              0x004D0314 /* -W-4R */
#define NV_UMEMFMT_PITCH_IN_VALUE                              31:0 /* -W-SF */
#define NV_UMEMFMT_PITCH_OUT                             0x004D0318 /* -W-4R */
#define NV_UMEMFMT_PITCH_OUT_VALUE                             31:0 /* -W-SF */
#define NV_UMEMFMT_LINE_LENGTH_IN                        0x004D031C /* -W-4R */
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE                        31:0 /* -W-UF */
#define NV_UMEMFMT_LINE_COUNT                            0x004D0320 /* -W-4R */
#define NV_UMEMFMT_LINE_COUNT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT                                0x004D0324 /* -W-4R */
#define NV_UMEMFMT_FORMAT_INPUT_INC                             2:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT_INPUT_INC_1                    0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_2                    0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_4                    0x00000004 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC                           10:8 /* -W-UF */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_1                   0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_2                   0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_4                   0x00000004 /* -W-UV */
#define NV_UMEMFMT_BUF_NOTIFY                            0x004D0328 /* -W-4R */
#define NV_UMEMFMT_BUF_NOTIFY_VALUE                            31:0 /* -W-UF */
/* usr_triangle.ref */
#define NV_UTRI                               0x004B1FFF:0x004B0000 /* -W--D */
#define NV_UTRI_CTX_SWITCH                               0x004B0000 /* -W-4R */
#define NV_UTRI_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UTRI_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UTRI_SET_NOTIFY                               0x004B0104 /* -W-4R */
#define NV_UTRI_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UTRI_COLOR                                    0x004B0304 /* -W-4R */
#define NV_UTRI_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_UTRI_TRIANGLE_0                               0x004B0310 /* -W-4R */
#define NV_UTRI_TRIANGLE_0_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_0_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_1                               0x004B0314 /* -W-4R */
#define NV_UTRI_TRIANGLE_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_1_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_2                               0x004B0318 /* -W-4R */
#define NV_UTRI_TRIANGLE_2_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_2_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE32_0                             0x004B0320 /* -W-4R */
#define NV_UTRI_TRIANGLE32_0_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_1                             0x004B0324 /* -W-4R */
#define NV_UTRI_TRIANGLE32_1_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_2                             0x004B0328 /* -W-4R */
#define NV_UTRI_TRIANGLE32_2_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_3                             0x004B032C /* -W-4R */
#define NV_UTRI_TRIANGLE32_3_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_4                             0x004B0330 /* -W-4R */
#define NV_UTRI_TRIANGLE32_4_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_5                             0x004B0334 /* -W-4R */
#define NV_UTRI_TRIANGLE32_5_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIMESH(i)                       (0x004B0400+(i)*4) /* -W-4A */
#define NV_UTRI_TRIMESH__SIZE_1                                  32 /*       */
#define NV_UTRI_TRIMESH_X                                      15:0 /* -W-SF */
#define NV_UTRI_TRIMESH_Y                                     31:16 /* -W-SF */
#define NV_UTRI_TRIMESH32_0(i)                   (0x004B0480+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_0__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_0_X                                  31:0 /* -W-SF */
#define NV_UTRI_TRIMESH32_1(i)                   (0x004B0484+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_1__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_1_Y                                  31:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_0(i)                  (0x004B0500+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_0__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_0_COLOR                              31:0 /* -W-VF */
#define NV_UTRI_CTRIANGLE_1(i)                  (0x004B0504+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_1__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_1_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_1_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2(i)                  (0x004B0508+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_2__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_2_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3(i)                  (0x004B050C+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_3__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_3_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIMESH_0(i)                    (0x004B0580+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_0__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_0_COLOR                               31:0 /* -W-VF */
#define NV_UTRI_CTRIMESH_1(i)                    (0x004B0584+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_1__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_CTRIMESH_1_Y                                  31:16 /* -W-SF */
/* usr_rectangle.ref */
#define NV_URECT                              0x00471FFF:0x00470000 /* -W--D */
#define NV_URECT_CTX_SWITCH                              0x00470000 /* -W-4R */
#define NV_URECT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_URECT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_URECT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_URECT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_URECT_SET_NOTIFY                              0x00470104 /* -W-4R */
#define NV_URECT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_URECT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_URECT_COLOR                                   0x00470304 /* -W-4R */
#define NV_URECT_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_URECT_RECTANGLE_0(i)                  (0x00470400+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_0__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_0_X                                 15:0 /* -W-SF */
#define NV_URECT_RECTANGLE_0_Y                                31:16 /* -W-SF */
#define NV_URECT_RECTANGLE_1(i)                  (0x00470404+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_1__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_1_WIDTH                             15:0 /* -W-UF */
#define NV_URECT_RECTANGLE_1_HEIGHT                           31:16 /* -W-UF */
/* usr_image_blit.ref */
#define NV_UBLIT                              0x00501FFF:0x00500000 /* -W--D */
#define NV_UBLIT_CTX_SWITCH                              0x00500000 /* -W-4R */
#define NV_UBLIT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBLIT_SET_NOTIFY                              0x00500104 /* -W-4R */
#define NV_UBLIT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBLIT_POINT_IN                                0x00500300 /* -W-4R */
#define NV_UBLIT_POINT_IN_X                                    15:0 /* -W-SF */
#define NV_UBLIT_POINT_IN_Y                                   31:16 /* -W-SF */
#define NV_UBLIT_POINT_OUT                               0x00500304 /* -W-4R */
#define NV_UBLIT_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UBLIT_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UBLIT_SIZE                                    0x00500308 /* -W-4R */
#define NV_UBLIT_SIZE_WIDTH                                    15:0 /* -W-UF */
#define NV_UBLIT_SIZE_HEIGHT                                  31:16 /* -W-UF */
/* usr_image_from_cpu.ref */
#define NV_UIMAGE                             0x00511FFF:0x00510000 /* -W--D */
#define NV_UIMAGE_CTX_SWITCH                             0x00510000 /* -W-4R */
#define NV_UIMAGE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UIMAGE_SET_NOTIFY                             0x00510104 /* -W-4R */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UIMAGE_POINT                                  0x00510304 /* -W-4R */
#define NV_UIMAGE_POINT_X                                      15:0 /* -W-SF */
#define NV_UIMAGE_POINT_Y                                     31:16 /* -W-SF */
#define NV_UIMAGE_SIZE                                   0x00510308 /* -W-4R */
#define NV_UIMAGE_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UIMAGE_SIZE_IN                                0x0051030C /* -W-4R */
#define NV_UIMAGE_SIZE_IN_WIDTH                                15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_IN_HEIGHT                              31:16 /* -W-UF */
#define NV_UIMAGE_COLOR(i)                       (0x00510400+(i)*4) /* -W-4A */
#define NV_UIMAGE_COLOR__SIZE_1                                  32 /*       */
#define NV_UIMAGE_COLOR_VALUE                                  31:0 /* -W-VF */
/* usr_bitmap_from_cpu.ref */
#define NV_UBITMAP                            0x00521FFF:0x00520000 /* -W--D */
#define NV_UBITMAP_CTX_SWITCH                            0x00520000 /* -W-4R */
#define NV_UBITMAP_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UBITMAP_SET_NOTIFY                            0x00520104 /* -W-4R */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UBITMAP_COLOR0                                0x00520308 /* -W-4R */
#define NV_UBITMAP_COLOR0_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_COLOR1                                0x0052030C /* -W-4R */
#define NV_UBITMAP_COLOR1_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_POINT                                 0x00520310 /* -W-4R */
#define NV_UBITMAP_POINT_X                                     15:0 /* -W-SF */
#define NV_UBITMAP_POINT_Y                                    31:16 /* -W-SF */
#define NV_UBITMAP_SIZE                                  0x00520314 /* -W-4R */
#define NV_UBITMAP_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_UBITMAP_SIZE_IN                               0x00520318 /* -W-4R */
#define NV_UBITMAP_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_UBITMAP_MONOCHROME(i)                 (0x00520400+(i)*4) /* -W-4A */
#define NV_UBITMAP_MONOCHROME__SIZE_1                            32 /*       */
#define NV_UBITMAP_MONOCHROME_BITMAP                           31:0 /* -W-VF */
/* usr_image_to_mem.ref */
#define NV_UTOMEM                             0x00541FFF:0x00540000 /* -W--D */
#define NV_UTOMEM_CTX_SWITCH                             0x00540000 /* -W-4R */
#define NV_UTOMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UTOMEM_SET_NOTIFY                             0x00540104 /* -W-4R */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UTOMEM_POINT                                  0x00540308 /* -W-4R */
#define NV_UTOMEM_POINT_X                                      15:0 /* -W-SF */
#define NV_UTOMEM_POINT_Y                                     31:16 /* -W-SF */
#define NV_UTOMEM_SIZE                                   0x0054030C /* -W-4R */
#define NV_UTOMEM_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UTOMEM_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UTOMEM_IMAGE_PITCH                            0x00540310 /* -W-4R */
#define NV_UTOMEM_IMAGE_PITCH_VALUE                            31:0 /* -W-SF */
#define NV_UTOMEM_IMAGE_START                            0x00540314 /* -W-4R */
#define NV_UTOMEM_IMAGE_START_OFFSET                           31:0 /* -W-UF */
/* usr_scaled_image_from_mem.ref */
#define NV_USCALED                            0x004E1FFF:0x004E0000 /* -W--D */
#define NV_USCALED_CTX_SWITCH                            0x004E0000 /* -W-4R */
#define NV_USCALED_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USCALED_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USCALED_SET_NOTIFY                            0x004E0104 /* -W-4R */
#define NV_USCALED_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USCALED_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USCALED_CLIP_0                                0x004E0308 /* -W-4R */
#define NV_USCALED_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USCALED_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USCALED_CLIP_1                                0x004E030C /* -W-4R */
#define NV_USCALED_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USCALED_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_0                       0x004E0310 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_0_X                           15:0 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_0_Y                          31:16 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_1                       0x004E0314 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH                       15:0 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT                     31:16 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX                           0x004E0318 /* -W-4R */
#define NV_USCALED_DELTA_DU_DX_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DU_DX_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX_R                               31:0 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY                           0x004E031C /* -W-4R */
#define NV_USCALED_DELTA_DV_DY_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DV_DY_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY_R                               31:0 /* -W-UF */
#define NV_USCALED_SIZE                                  0x004E0400 /* -W-4R */
#define NV_USCALED_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_USCALED_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_USCALED_PITCH                                 0x004E0404 /* -W-4R */
#define NV_USCALED_PITCH_VALUE                                 31:0 /* -W-SF */
#define NV_USCALED_OFFSET                                0x004E0408 /* -W-4R */
#define NV_USCALED_OFFSET_VALUE                               31:0  /* -W-UF */
#define NV_USCALED_POINT                                 0x004E040C /* -W-4R */
#define NV_USCALED_POINT_V_FRACTION                            11:0 /* -W-UF */
#define NV_USCALED_POINT_V_INT                                15:12 /* -W-UF */
#define NV_USCALED_POINT_V_VALUE                               15:0 /* -W-UF */
#define NV_USCALED_POINT_U_FRACTION                           19:16 /* -W-UF */
#define NV_USCALED_POINT_U_INT                                31:20 /* -W-UF */
#define NV_USCALED_POINT_U_VALUE                               31:0 /* -W-UF */
#define NV_USCALED_SIZE_Y                                0x004E0400 /* -W-4R */
#define NV_USCALED_SIZE_Y_WIDTH                                15:0 /* -W-UF */
#define NV_USCALED_SIZE_Y_HEIGHT                              31:16 /* -W-UF */
#define NV_USCALED_PITCH_420                             0x004E0404 /* -W-4R */
#define NV_USCALED_PITCH_420_Y                                 15:0 /* -W-UF */
#define NV_USCALED_PITCH_420_UV                               31:16 /* -W-UF */
#define NV_USCALED_OFFSET_Y                              0x004E0408 /* -W-4R */
#define NV_USCALED_OFFSET_Y_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_OFFSET_U                              0x004E040C /* -W-4R */
#define NV_USCALED_OFFSET_U_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_OFFSET_V                              0x004E0410 /* -W-4R */
#define NV_USCALED_OFFSET_V_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_POINT_Y                               0x004E0414 /* -W-4R */
#define NV_USCALED_POINT_Y_V_FRACTION                          11:0 /* -W-UF */
#define NV_USCALED_POINT_Y_V_INT                              15:12 /* -W-UF */
#define NV_USCALED_POINT_Y_V_VALUE                             15:0 /* -W-UF */
#define NV_USCALED_POINT_Y_U_FRACTION                         19:16 /* -W-UF */
#define NV_USCALED_POINT_Y_U_INT                              31:20 /* -W-UF */
#define NV_USCALED_POINT_Y_U_VALUE                            31:16 /* -W-UF */
/* usr_stretch_from_cpu.ref */
#define NV_USTRTCH                            0x00551FFF:0x00550000 /* -W--D */
#define NV_USTRTCH_CTX_SWITCH                            0x00550000 /* -W-4R */
#define NV_USTRTCH_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USTRTCH_SET_NOTIFY                            0x00550104 /* -W-4R */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USTRTCH_SIZE_IN                               0x00550304 /* -W-4R */
#define NV_USTRTCH_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_USTRTCH_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU                           0x00550308 /* -W-4R */
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R                               31:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV                           0x0055030C /* -W-4R */
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R                               31:0 /* -W-UF */
#define NV_USTRTCH_CLIP_0                                0x00550310 /* -W-4R */
#define NV_USTRTCH_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USTRTCH_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USTRTCH_CLIP_1                                0x00550314 /* -W-4R */
#define NV_USTRTCH_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USTRTCH_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USTRTCH_POINT12D4                             0x00550318 /* -W-4R */
#define NV_USTRTCH_POINT12D4_X_FRACTION                         3:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X_INT                             15:4 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X                                 15:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_FRACTION                       19:16 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_INT                            31:20 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y                                31:16 /* -W-SF */
#define NV_USTRTCH_COLOR(i)                      (0x00550400+(i)*4) /* -W-4A */
#define NV_USTRTCH_COLOR__SIZE_1                               1792 /*       */
#define NV_USTRTCH_COLOR_VALUE                                 31:0 /* -W-VF */
/* usr_win95_text.ref */
#define NV_UW95TXT                            0x004C1FFF:0x004C0000 /* -W--D */
#define NV_UW95TXT_CTX_SWITCH                            0x004C0000 /* -W-4R */
#define NV_UW95TXT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UW95TXT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UW95TXT_SET_NOTIFY                            0x004C0104 /* -W-4R */
#define NV_UW95TXT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UW95TXT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UW95TXT_COLOR_A                               0x004C03FC /* -W-4R */
#define NV_UW95TXT_COLOR_A_VALUE                               31:0 /* -W-VF */
#define NV_UW95TXT_RECT_NCLIP_0(i)               (0x004C0400+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_NCLIP_0__SIZE_1                          64 /*       */
#define NV_UW95TXT_RECT_NCLIP_0_Y                              15:0 /* -W-SF */
#define NV_UW95TXT_RECT_NCLIP_0_X                             31:16 /* -W-SF */
#define NV_UW95TXT_RECT_NCLIP_1(i)               (0x004C0404+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_NCLIP_1__SIZE_1                          64 /*       */
#define NV_UW95TXT_RECT_NCLIP_1_HEIGHT                         15:0 /* -W-UF */
#define NV_UW95TXT_RECT_NCLIP_1_WIDTH                         31:16 /* -W-UF */
#define NV_UW95TXT_CLIP_B_0                              0x004C07F4 /* -W-4R */
#define NV_UW95TXT_CLIP_B_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_B_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_B_1                              0x004C07F8 /* -W-4R */
#define NV_UW95TXT_CLIP_B_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_B_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR_B                               0x004C07FC /* -W-4R */
#define NV_UW95TXT_COLOR_B_VALUE                               31:0 /* -W-VF */
#define NV_UW95TXT_RECT_CLIP_0(i)                (0x004C0800+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_CLIP_0__SIZE_1                           64 /*       */
#define NV_UW95TXT_RECT_CLIP_0_LEFT                            15:0 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_0_TOP                            31:16 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_1(i)                (0x004C0804+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_CLIP_1__SIZE_1                           64 /*       */
#define NV_UW95TXT_RECT_CLIP_1_RIGHT                           15:0 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_1_BOTTOM                         31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_C_0                              0x004C0BEC /* -W-4R */
#define NV_UW95TXT_CLIP_C_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_C_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_C_1                              0x004C0BF0 /* -W-4R */
#define NV_UW95TXT_CLIP_C_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_C_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR1_C                              0x004C0BF4 /* -W-4R */
#define NV_UW95TXT_COLOR1_C_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_C                                0x004C0BF8 /* -W-4R */
#define NV_UW95TXT_SIZE_C_WIDTH                                15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_C_HEIGHT                              31:16 /* -W-UF */
#define NV_UW95TXT_POINT_C                               0x004C0BFC /* -W-4R */
#define NV_UW95TXT_POINT_C_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_C_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR1_C(i)              (0x004C0C00+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR1_C__SIZE_1                        128 /*       */
#define NV_UW95TXT_MONO_COLOR1_C_BITMAP                        31:0 /* -W-VF */
#define NV_UW95TXT_CLIP_D_0                              0x004C0FE8 /* -W-4R */
#define NV_UW95TXT_CLIP_D_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_D_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_D_1                              0x004C0FEC /* -W-4R */
#define NV_UW95TXT_CLIP_D_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_D_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR1_D                              0x004C0FF0 /* -W-4R */
#define NV_UW95TXT_COLOR1_D_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_IN_D                             0x004C0FF4 /* -W-4R */
#define NV_UW95TXT_SIZE_IN_D_WIDTH                             15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_IN_D_HEIGHT                           31:16 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_D                            0x004C0FF8 /* -W-4R */
#define NV_UW95TXT_SIZE_OUT_D_WIDTH                            15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_D_HEIGHT                          31:16 /* -W-UF */
#define NV_UW95TXT_POINT_D                               0x004C0FFC /* -W-4R */
#define NV_UW95TXT_POINT_D_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_D_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR1_D(i)              (0x004C1000+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR1_D__SIZE_1                        128 /*       */
#define NV_UW95TXT_MONO_COLOR1_D_BITMAP                        31:0 /* -W-VF */
#define NV_UW95TXT_CLIP_E_0                              0x004C13E4 /* -W-4R */
#define NV_UW95TXT_CLIP_E_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_E_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_E_1                              0x004C13E8 /* -W-4R */
#define NV_UW95TXT_CLIP_E_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_E_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR0_E                              0x004C13EC /* -W-4R */
#define NV_UW95TXT_COLOR0_E_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_COLOR1_E                              0x004C13F0 /* -W-4R */
#define NV_UW95TXT_COLOR1_E_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_IN_E                             0x004C13F4 /* -W-4R */
#define NV_UW95TXT_SIZE_IN_E_WIDTH                             15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_IN_E_HEIGHT                           31:16 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_E                            0x004C13F8 /* -W-4R */
#define NV_UW95TXT_SIZE_OUT_E_WIDTH                            15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_E_HEIGHT                          31:16 /* -W-UF */
#define NV_UW95TXT_POINT_E                               0x004C13FC /* -W-4R */
#define NV_UW95TXT_POINT_E_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_E_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR01_E(i)             (0x004C1400+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR01_E__SIZE_1                       128 /*       */
#define NV_UW95TXT_MONO_COLOR01_E_BITMAP                       31:0 /* -W-VF */
/* usr_image_in_mem.ref */
#define NV_UINMEM                             0x005C1FFF:0x005C0000 /* -W--D */
#define NV_UINMEM_CTX_SWITCH                             0x005C0000 /* -W-4R */
#define NV_UINMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UINMEM_SET_NOTIFY                             0x005C0104 /* -W-4R */
#define NV_UINMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UINMEM_PITCH                                  0x005C0308 /* -W-4R */
#define NV_UINMEM_PITCH_VALUE                                  15:0 /* -WXUF */
#define NV_UINMEM_OFFSET                                 0x005C030C /* -W-4R */
#define NV_UINMEM_OFFSET_LINADRS                               22:0 /* -WIUF */
#define NV_UINMEM_OFFSET_LINADRS_0                       0x00000000 /* -WI-V */
#define NV_UINMEM_FORMAT                                 0x005C0300 /* -W-4R */
#define NV_UINMEM_FORMAT_VALUE                                 31:0 /* -WXUF */
#define NV_UINMEM_FORMAT_VALUE_LE_Y8_P4                  0x01010000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_Y16_P2                 0x01010001 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_P2            0x01000000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8               0x00000001 /* -W--V */
/* dev_framebuffer.ref */
#define NV_PFB                                0x00100FFF:0x00100000 /* RW--D */
#define NV_PFB_BOOT_0                                    0x00100000 /* RW-4R */
#define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB                     0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB                     0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128                             2:2 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_OFF                  0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_ON                   0x00000001 /* RW--V */
// need to consolidate nv3.ref files!
#define NV_PFB_BOOT_0_RAM_AMOUNT_8MB                     0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_UNDEFINED               0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_BANKS                                 3:3 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_BANKS_2BANK                    0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_BANKS_4BANK                    0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE                           4:4 /* RWIVF */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE_OFF                0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE_ON                 0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION                      5:5 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION_OFF           0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION_8MB           0x00000001 /* RW--V */

#define NV_PFB_DELAY_1                                   0x00100044 /* RW-4R */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE                        1:0 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL                        5:4 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_CAS_ENABLE_RISE                          9:8 /* RWIUF */
#define NV_PFB_DELAY_1_CAS_ENABLE_RISE_0                 0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_CAS_ENABLE_FALL                        13:12 /* RWIUF */
#define NV_PFB_DELAY_1_CAS_ENABLE_FALL_0                 0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_OUTPUT_DATA                            17:16 /* RWIUF */
#define NV_PFB_DELAY_1_OUTPUT_DATA_0                     0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_RAS_ENABLE                             21:20 /* RWIUF */
#define NV_PFB_DELAY_1_RAS_ENABLE_0                      0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
#define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
#define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64                        12:8 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT          0x00000010 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
#define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_INVERT                             28:28 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_OFF                    0x00000000 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_ON                     0x00000001 /* RW-VF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON                           29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF                  0x00000000 /* RW-VF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_ON                   0x00000001 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER                             30:30 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_ON                     0x00000000 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_OFF                    0x00000001 /* RW-VF */
#define NV_PFB_GREEN_0                                   0x001000C0 /* RW-4R */
#define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_0                                  0x00100200 /* RW-4R */
#define NV_PFB_CONFIG_0_RESOLUTION                              5:0 /* RWIVF */
#define NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS            0x0000000a /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS            0x0000000d /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS            0x0000000f /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS            0x00000010 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000014 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000019 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS            0x0000001e /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000020 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000024 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000028 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000032 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_DEFAULT               0x00000014 /* RWI-V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT              0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING                                12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_ENABLED                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DISABLED                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG                          23:13 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON                       13:13 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_ENABLED          0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_DISABLED         0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE                 14:14 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_FIXED      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_VARIABLE   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE              17:15 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_PASS    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_1       0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_2       0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_3       0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_4       0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_5       0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_6       0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_7       0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT             19:18 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_0      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_1      0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_2      0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP                20:20 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_OFF       0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_ON        0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB            22:21 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_1M    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_2M    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_4M    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_UNUSED                   23:23 /* RW--V */
#define NV_PFB_CONFIG_1                                  0x00100204 /* RW-4R */
#define NV_PFB_CONFIG_1_CAS_LATENCY                             2:0 /* RWIVF */
#define NV_PFB_CONFIG_1_CAS_LATENCY_3                    0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_1_SGRAM100                                3:3 /* RWIVF */
#define NV_PFB_CONFIG_1_SGRAM100_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_SGRAM100_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS                                 7:4 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_RAS_DEFAULT                  0x00000009 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_RAS_9CYCLES                  0x00000008 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS_SG100                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_PCHG                               10:8 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_PCHG_SG100                   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW                               14:12 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_LOW_DEFAULT                  0x00000006 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_LOW_SG100                    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS                            18:16 /* RWIUF */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT               0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_SG100                 0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_WRITE_TO_READ                         22:20 /* RWIUF */
#define NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_WRITE_TO_READ_SG100              0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1                         26:24 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT            0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_SG100              0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE                         30:28 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT            0x00000004 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_SG100              0x00000002 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG                          31:31 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_ON                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_OFF                 0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_ED_RAC1                                 0:0 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RWT1                                 1:1 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RWT1_DEFAULT                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1                                 2:2 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_DEFAULT                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_PMAW                                 4:4 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_PMAW_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_PAGE                                 5:5 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_PAGE_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC0_0                               8:8 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC0_0_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC0_1                               9:9 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC0_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC1_0                             10:10 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC1_1                             12:12 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAD0_0                             13:13 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAD0_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAD0_1                             14:14 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAD0_1_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC0_0                             16:16 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC0_0_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC0_1                             17:17 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC0_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1_0                             18:18 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1_1                             20:20 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_1_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_RTL                                       0x00100300 /* RW-4R */
#define NV_PFB_RTL_S                                            1:0 /* RWIUF */
#define NV_PFB_RTL_S_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_V                                            5:4 /* RWIUF */
#define NV_PFB_RTL_V_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_M                                            9:8 /* RWIUF */
#define NV_PFB_RTL_M_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_H                                          13:12 /* RWIUF */
#define NV_PFB_RTL_H_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_A                                          17:16 /* RWIUF */
#define NV_PFB_RTL_A_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_G                                          21:20 /* RWIUF */
#define NV_PFB_RTL_G_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_ARB_GR_HI_PRIOR                            24:24 /* RWIUF */
#define NV_PFB_RTL_ARB_GR_HI_PRIOR_DEFAULT               0x00000000 /* RWI-V */
#define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR                         28:28 /* RWIUF */
#define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR_DEFAULT            0x00000000 /* RWI-V */
/* dev_framebuffer.ref */
#define NV_PNVM                               0x01BFFFFF:0x01800000 /* RW--M */
#define NV_PNVM_DATA032(i)                       (0x01800000+(i)*4) /* RW-4A */
#define NV_PNVM_DATA032__SIZE_1                              524288 /*       */
#define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PNVM_DATA024(i)           (0x01800000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PNVM_DATA024__SIZE_1                             1048576 /*       */
#define NV_PNVM_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PNVM_DATA016(i)           (0x01800000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PNVM_DATA016__SIZE_1                             1572864 /*       */
#define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PNVM_DATA008(i)                         (0x01800000+(i)) /* RW-1A */
#define NV_PNVM_DATA008__SIZE_1                             2097152 /*       */
#define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_framebuffer.ref */
#define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_DATA032(i)                       (0x01C00000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                              524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PRAMIN_DATA024(i)           (0x01C00000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PRAMIN_DATA024__SIZE_1                             1048576 /*       */
#define NV_PRAMIN_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PRAMIN_DATA016(i)           (0x01C00000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PRAMIN_DATA016__SIZE_1                             1572864 /*       */
#define NV_PRAMIN_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PRAMIN_DATA008(i)                         (0x01C00000+(i)) /* RW-1A */
#define NV_PRAMIN_DATA008__SIZE_1                             2097152 /*       */
#define NV_PRAMIN_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
#define NV_PRAMIN_RAMHT_0                     0x01400FFF:0x01400000 /* RW--M */
#define NV_PRAMIN_RAMAU_0                     0x01401BFF:0x01401000 /* RW--M */
#define NV_PRAMIN_RAMFC_0                     0x01401DFF:0x01401C00 /* RW--M */
#define NV_PRAMIN_RAMRO_0                     0x01401FFF:0x01401E00 /* RW--M */
#define NV_PRAMIN_RAMRM_0                     0x01402FFF:0x01402000 /* RW--M */
/* dev_framebuffer.ref */
#define NV_PDFB                               0x017FFFFF:0x01000000 /* RW--D */
#define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PDFB_DATA032__SIZE_1                              524288 /*       */
#define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PDFB_DATA024__SIZE_1                             1048576 /*       */
#define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PDFB_DATA016__SIZE_1                             1572864 /*       */
#define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PDFB_DATA008__SIZE_1                             2097152 /*       */
#define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
/* dev_ext_devices.ref */
#define NV_PEXTDEV                            0x00101FFF:0x00101000 /* RW--D */
#define NV_PEXTDEV_BOOT_0                                0x00101000 /* R--4R */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED                       0:0 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ          0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR                      1:1 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS       0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        3:2 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K      0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_RESERVED        0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K      0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH                       4:4 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128            0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        5:5 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP             0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL                         6:6 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K           0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180         0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE                          8:7 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC              0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL               0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED          0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE                        9:9 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_20              0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_MODE_21              0x00000001 /* R---V */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00500000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
/* dev_ext_devices.ref */
#define NV_PROM                               0x0011FFFF:0x00110000 /* RW--D */
#define NV_PROM_DATA(i)                            (0x00110000+(i)) /* RW-1A */
#define NV_PROM_DATA__SIZE_1                                  65536 /*       */
#define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
#define NV_PALT                               0x0012FFFF:0x00120000 /* RW--D */
#define NV_PALT_DATA(i)                            (0x00120000+(i)) /* RW-1A */
#define NV_PALT_DATA__SIZE_1                                  65536 /*       */
#define NV_PALT_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_PRM                                0x00005FFF:0x00004000 /* RW--D */
#define NV_PRM_INTR_0                                    0x00004100 /* RW-4R */
#define NV_PRM_INTR_0_TRACE_MPU401                              0:0 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING           0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_PENDING               0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_RESET                 0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_FM                                  4:4 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_FM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_PENDING                   0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_RESET                     0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL                          8:8 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING       0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING           0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET             0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER                          12:12 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_EN_0                                 0x00004140 /* RW-4R */
#define NV_PRM_INTR_EN_0_TRACE_MPU401                           0:0 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED           0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED            0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_FM                               4:4 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_FM_DISABLED               0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_FM_ENABLED                0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL                       8:8 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED       0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED        0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER                       12:12 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_RAMRM                                     0x00004200 /* RW-4R */
#define NV_PRM_RAMRM_BASE_ADDRESS                             15:12 /* RWXVF */
#define NV_PRM_RAMRM_BASE_ADDRESS_2000                   0x00002000 /* RWI-V */
#define NV_PRM_TRACE                                     0x00004300 /* RW-4R */
#define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
#define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWXVF */
#define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_IO_READ                                    5:5 /* RWXVF */
#define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
#define NV_PRM_TRACE_INDEX                               0x00004310 /* RW-4R */
#define NV_PRM_TRACE_INDEX_ADDRESS                              9:0 /* RWXUF */
#define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0                                  0x00004320 /* RW-4R */
#define NV_PRM_IGNORE_0_MPU401                                  1:0 /* RWXVF */
#define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_FM                                      5:4 /* RWXVF */
#define NV_PRM_IGNORE_0_FM_DISABLED                      0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_FM_WRITES                        0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS                         0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS_WRITES                  0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL                              9:8 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED              0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS                 0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER                              13:12 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_MIXER_DISABLED                0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES            0x00000003 /* RW--V */
/* dev_realmode.ref */
#define NV_PRMIO                              0x00007FFF:0x00007000 /* RW--D */
/* dev_realmode.ref */
/* dev_fifo.ref */
#define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                  128 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                 128 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                 128 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                 128 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                 128 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
/* dev_misc.ref */
#define NV_USER_ADR_CHID                                      22:16 /*       */
#define NV_USER_ADR_SUBCHID                                   15:13 /*       */
#define NV_USER_ADR_METHOD                                     12:0 /*       */
#define NV_USER_DEVICE                                        22:16 /*       */
/* dev_timer.ref */
#define NV_PTIMER                             0x00009FFF:0x00009000 /* RW--D */
#define NV_PTIMER_INTR_0                                 0x00009100 /* RW-4R */
#define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
#define NV_PTIMER_INTR_EN_0                              0x00009140 /* RW-4R */
#define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
#define NV_PTIMER_NUMERATOR                              0x00009200 /* RW-4R */
#define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
#define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
#define NV_PTIMER_DENOMINATOR                            0x00009210 /* RW-4R */
#define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
#define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
#define NV_PTIMER_TIME_0                                 0x00009400 /* RW-4R */
#define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
#define NV_PTIMER_TIME_1                                 0x00009410 /* RW-4R */
#define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
#define NV_PTIMER_ALARM_0                                0x00009420 /* RW-4R */
#define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
/* dev_realmode.ref */
#define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
#define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
#define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
#define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
#define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
#define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
#define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_DEVICE                       ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMHT_ENGINE                       ( 1*32+23):( 1*32+23) /* RWXVF */
#define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMHT_CHID                         ( 1*32+30):( 1*32+24) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXVF */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_RAMAU                              0x00000BFF:0x00000000 /* RW--M */
#define NV_RAMAU_DATA                                          31:0 /* RWXVF */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMFC_INSTANCE_0                   ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_0                     ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_0_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_0                     ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_0_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_0_GRAPHICS                       0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_1                   ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_1                     ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_1_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_1                     ( 1*32+23):( 1*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_1_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_1_GRAPHICS                       0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_7                   ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_7                     ( 7*32+22):( 7*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_7_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_7                     ( 7*32+23):( 7*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_7_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_7_GRAPHICS                       0x00000001 /* RW--V */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_DMA_ADJUST                         ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE                    ( 0*32+25):( 0*32+24) /* RWXVF */
#define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
#define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_PAGE                           ( 2*32+ 0):( 2*32+ 0) /* RWXVF */
#define NV_DMA_PAGE_NOT_PRESENT                          0x00000000 /* RW--V */
#define NV_DMA_PAGE_PRESENT                              0x00000001 /* RW--V */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
#define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
#define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_AUDIN                              0x00000033:0x00000000 /* RW--M */
#define NV_AUDIN_AE_STATE                       (0*32+15):(0*32+ 0) /* RWWVF */
#define NV_AUDIN_AE_SKIP_COUNT                  (1*32+31):(1*32+ 0) /* RWWUF */
#define NV_AUDIN_AE_POSITION                    (2*32+31):(2*32+ 0) /* RWWUF */
#define NV_AUDIN_RM_NEXT_INSTANCE               (3*32+31):(3*32+ 0) /* RWWUF */
#define NV_AUDIN_RM_STATE                       (4*32+15):(4*32+ 0) /* RWWVF */
#define NV_AUDIN_SU_STATE                       (5*32+15):(5*32+ 0) /* RWWVF */
#define NV_AUDIN_SU_START_TIME_LOW              (5*32+31):(5*32+16) /* RWWUF */
#define NV_AUDIN_SU_START_TIME_HIGH             (6*32+31):(6*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_SKIP_INC                    (7*32+31):(7*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_DMA_INSTANCE          (8*32+15):(8*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_DMA_INSTANCE          (8*32+31):(8*32+16) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_START_POSITION        (9*32+31):(9*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_LAST_PLUS1          (10*32+31):(10*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_START_POSITION      (11*32+31):(11*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_LAST_PLUS1          (12*32+31):(12*32+ 0) /* RWWUF */
#define NV_AUDIN_AE_EVENT_START               ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_INTR_NOTIFY         ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_INTR_NOTIFY         ( 0*32+ 5):( 0*32+ 5) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_INTR_CHAIN_GAP      ( 0*32+ 6):( 0*32+ 6) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_INTR_CHAIN_GAP      ( 0*32+ 7):( 0*32+ 7) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_IN_USE              ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_IN_USE              ( 0*32+ 9):( 0*32+ 9) /* RWXVF */
#define NV_AUDIN_AE_CURRENT_BUFFER            ( 0*32+12):( 0*32+12) /* RWXVF */
#define NV_AUDIN_AE_CURRENT_BUFFER_0                     0x00000000 /* RW--V */
#define NV_AUDIN_AE_CURRENT_BUFFER_1                     0x00000001 /* RW--V */
#define NV_AUDIN_AE_INTR_DMA                  ( 0*32+11):( 0*32+11) /* RWXVF */
#define NV_AUDIN_RM_BUFF0_INTR_NOTIFY         ( 4*32+ 4):( 4*32+ 4) /* RWXVF */
#define NV_AUDIN_RM_BUFF1_INTR_NOTIFY         ( 4*32+ 5):( 4*32+ 5) /* RWXVF */
#define NV_AUDIN_RM_BUFF0_INTR_CHAIN_GAP      ( 4*32+ 6):( 4*32+ 6) /* RWXVF */
#define NV_AUDIN_RM_BUFF1_INTR_CHAIN_GAP      ( 4*32+ 7):( 4*32+ 7) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_OFFSET              ( 5*32+ 1):( 5*32+ 0) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_OFFSET              ( 5*32+ 3):( 5*32+ 2) /* RWXVF */
#define NV_AUDIN_SU_BYPASS_PTE                ( 5*32+ 4):( 5*32+ 4) /* RWXVF */
#define NV_AUDIN_SU_BYPASS_PTE_DISABLED                  0x00000000 /* RW--V */
#define NV_AUDIN_SU_BYPASS_PTE_ENABLED                   0x00000001 /* RW--V */
#define NV_AUDIN_SU_BYPASS_TARGET             ( 5*32+ 6):( 5*32+ 5) /* RWXVF */
#define NV_AUDIN_SU_BYPASS_TARGET_NVM                    0x00000000 /* RW--V */
#define NV_AUDIN_SU_BYPASS_TARGET_PCI                    0x00000002 /* RW--V */
#define NV_AUDIN_SU_BYPASS_TARGET_AGP                    0x00000003 /* RW--V */
#define NV_AUDIN_SU_BUFF0_IN_USE              ( 5*32+ 8):( 5*32+ 8) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_IN_USE              ( 5*32+ 9):( 5*32+ 9) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_NOTIFY              (16*32+10):(16*32+10) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
#define NV_AUDIN_SU_BUFF0_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
#define NV_AUDIN_SU_BUFF1_NOTIFY              (16*32+11):(16*32+11) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
#define NV_AUDIN_SU_BUFF1_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
#define NV_AUDIN_SU_CHANNEL                   ( 5*32+12):( 5*32+12) /* RWXVF */
#define NV_AUDIN_SU_CHANNEL_MONO                         0x00000000 /* RW--V */
#define NV_AUDIN_SU_CHANNEL_STEREO                       0x00000001 /* RW--V */
#define NV_AUDIN_SU_FORMAT                    ( 5*32+15):( 5*32+13) /* RWXVF */
#define NV_AUDIN_SU_FORMAT_LINEAR                        0x00000000 /* RW--V */
#define NV_AUDIN_SU_FORMAT_ULAW                          0x00000001 /* RW--V */
#define NV_AUDIN_SU_FORMAT_ALAW                          0x00000002 /* RW--V */
#define NV_AUDIN_SU_FORMAT_OFFSET8                       0x00000003 /* RW--V */
/* dev_ram.ref */
#define NV_AUDOUT                             0x0000003b:0x00000000 /* RW--M */
#define NV_AUDOUT_AE_STATE                      (0*32+15):(0*32+ 0) /* RWWVF */
#define NV_AUDOUT_AE_POSITION_LOW               (0*32+31):(0*32+16) /* RWWUF */
#define NV_AUDOUT_AE_POSITION                   (1*32+31):(1*32+ 0) /* RWWUF */
#define NV_AUDOUT_AE_VOLUME_1                   (2*32+15):(2*32+ 0) /* RWWUF */
#define NV_AUDOUT_AE_VOLUME_0                   (2*32+31):(2*32+16) /* RWWUF */
#define NV_AUDOUT_RM_VOLUME_0                   (3*32+15):(3*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_VOLUME_0                   (3*32+31):(3*32+16) /* RWWUF */
#define NV_AUDOUT_RM_VOLUME_1                   (4*32+15):(4*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_VOLUME_1                   (4*32+31):(4*32+16) /* RWWUF */
#define NV_AUDOUT_AE_POSITION_INC               (5*32+31):(5*32+ 0) /* RWWUF */
#define NV_AUDOUT_RM_NEXT_INSTANCE              (6*32+31):(6*32+ 0) /* RWWUF */
#define NV_AUDOUT_RM_STATE                      (7*32+15):(7*32+ 0) /* RWWVF */
#define NV_AUDOUT_SU_STATE                      (8*32+15):(8*32+ 0) /* RWWVF */
#define NV_AUDOUT_SU_START_TIME_LOW             (8*32+31):(8*32+16) /* RWWUF */
#define NV_AUDOUT_SU_START_TIME_HIGH            (9*32+31):(9*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF0_DMA_INSTANCE       (10*32+15):(10*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF1_DMA_INSTANCE       (10*32+31):(10*32+16) /* RWWUF */
#define NV_AUDOUT_SU_BUFF0_START_POSITION     (11*32+31):(11*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF0_LAST_PLUS1         (12*32+31):(12*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF1_START_POSITION     (13*32+31):(13*32+ 0) /* RWWUF */
#define NV_AUDOUT_SU_BUFF1_LAST_PLUS1         (14*32+31):(14*32+ 0) /* RWWUF */
#define NV_AUDOUT_AE_INTR_MIXING              ( 0*32+ 0):( 0*32+ 0) /* RWXVF */
#define NV_AUDOUT_AE_INTR_VOLUME              ( 0*32+ 1):( 0*32+ 1) /* RWXVF */
#define NV_AUDOUT_AE_EVENT_START              ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_INTR_NOTIFY        ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_INTR_NOTIFY        ( 0*32+ 5):( 0*32+ 5) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_INTR_CHAIN_GAP     ( 0*32+ 6):( 0*32+ 6) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_INTR_CHAIN_GAP     ( 0*32+ 7):( 0*32+ 7) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_IN_USE             ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_IN_USE             ( 0*32+ 9):( 0*32+ 9) /* RWXVF */
#define NV_AUDOUT_AE_GAP_DETECT               ( 0*32+10):( 0*32+10) /* RWXVF */
#define NV_AUDOUT_AE_INTR_DMA                 ( 0*32+11):( 0*32+11) /* RWXVF */
#define NV_AUDOUT_AE_CURRENT_BUFFER           ( 0*32+12):( 0*32+12) /* RWXVF */
#define NV_AUDOUT_AE_CURRENT_BUFFER_0                    0x00000000 /* RW--V */
#define NV_AUDOUT_AE_CURRENT_BUFFER_1                    0x00000001 /* RW--V */
#define NV_AUDOUT_RM_INTR_MIXING              (15*32+ 0):(15*32+ 0) /* RWXVF */
#define NV_AUDOUT_RM_INTR_VOLUME              (15*32+ 1):(15*32+ 1) /* RWXVF */
#define NV_AUDOUT_RM_BUFF0_INTR_NOTIFY        (15*32+ 4):(15*32+ 4) /* RWXVF */
#define NV_AUDOUT_RM_BUFF1_INTR_NOTIFY        (15*32+ 5):(15*32+ 5) /* RWXVF */
#define NV_AUDOUT_RM_BUFF0_INTR_CHAIN_GAP     (15*32+ 6):(15*32+ 6) /* RWXVF */
#define NV_AUDOUT_RM_BUFF1_INTR_CHAIN_GAP     (15*32+ 7):(15*32+ 7) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_OFFSET             (16*32+ 1):(16*32+ 0) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_OFFSET             (16*32+ 3):(16*32+ 2) /* RWXVF */
#define NV_AUDOUT_SU_BYPASS_PTE               (16*32+ 4):(16*32+ 4) /* RWXVF */
#define NV_AUDOUT_SU_BYPASS_PTE_DISABLED                 0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BYPASS_PTE_ENABLED                  0x00000001 /* RW--V */
#define NV_AUDOUT_SU_BYPASS_TARGET            (16*32+ 6):(16*32+ 5) /* RWXVF */
#define NV_AUDOUT_SU_BYPASS_TARGET_NVM                   0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BYPASS_TARGET_PCI                   0x00000002 /* RW--V */
#define NV_AUDOUT_SU_BYPASS_TARGET_AGP                   0x00000003 /* RW--V */
#define NV_AUDOUT_SU_BUFF0_IN_USE             (16*32+ 8):(16*32+ 8) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_IN_USE             (16*32+ 9):(16*32+ 9) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY             (16*32+10):(16*32+10) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDOUT_SU_BUFF1_NOTIFY             (16*32+11):(16*32+11) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDOUT_SU_CHANNEL                  (16*32+12):(16*32+12) /* RWXVF */
#define NV_AUDOUT_SU_CHANNEL_MONO                        0x00000000 /* RW--V */
#define NV_AUDOUT_SU_CHANNEL_STEREO                      0x00000001 /* RW--V */
#define NV_AUDOUT_SU_FORMAT                   (16*32+15):(16*32+13) /* RWXVF */
#define NV_AUDOUT_SU_FORMAT_LINEAR                       0x00000000 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_ULAW                         0x00000001 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_ALAW                         0x00000002 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_OFFSET8                      0x00000003 /* RW--V */
#define NV_AUDOUT_SU_BUFF0_OFFSET             (16*32+ 1):(16*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_AUDNOTE                            0x00000083:0x00000000 /* RW--M */
#define NV_AUDNOTE_AE_STATE                     (0*32+15):(0*32+ 0) /* RWWVF */
#define NV_AUDNOTE_AE_POSITION_LOW              (0*32+31):(0*32+16) /* RWWUF */
#define NV_AUDNOTE_AE_POSITION                  (1*32+31):(1*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_POSITION_INC              (2*32+31):(2*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_EG_ADSR_LEVEL             (3*32+31):(3*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_PE_ADSR_LEVEL             (4*32+31):(4*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_ADSR_VOLUME               (5*32+15):(5*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_VIBRATO_TREMOLO_LEVEL     (5*32+31):(5*32+16) /* RWWUF */
#define NV_AUDNOTE_AE_VIBRATO_POSITION          (6*32+31):(6*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_TREMOLO_POSITION          (7*32+31):(7*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_VOLUME_1                  (8*32+15):(8*32+ 0) /* RWWUF */
#define NV_AUDNOTE_AE_VOLUME_0                  (8*32+31):(8*32+16) /* RWWUF */
#define NV_AUDNOTE_RM_NEXT_INSTANCE             (9*32+31):(9*32+ 0) /* RWWUF */
#define NV_AUDNOTE_RM_VOLUME_0                (10*32+15):(10*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VOLUME_0                (10*32+31):(10*32+16) /* RWWUF */
#define NV_AUDNOTE_RM_VOLUME_1                (11*32+15):(11*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VOLUME_1                (11*32+31):(11*32+16) /* RWWUF */
#define NV_AUDNOTE_RM_STATE                   (12*32+15):(12*32+ 0) /* RWWVF */
#define NV_AUDNOTE_SU_STOP_TIME_LOW           (12*32+31):(12*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_STATE                   (13*32+15):(13*32+ 0) /* RWWVF */
#define NV_AUDNOTE_SU_START_TIME_LOW          (13*32+31):(13*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_START_TIME_HIGH         (14*32+31):(14*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_STOP_TIME_HIGH          (15*32+31):(15*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_FM_STATE                (16*32+15):(16*32+ 0) /* RWWVF */
#define NV_AUDNOTE_SU_RELEASE_TIME_LOW        (16*32+31):(16*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_DMA_INSTANCE            (17*32+15):(17*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_LO (17*32+31):(17*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_HI (18*32+31):(18*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_RELEASE_TIME_HIGH       (19*32+31):(19*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_POSITION_INC            (20*32+31):(20*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_LOOP_START              (21*32+31):(21*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_LOOP_END_PLUS1          (22*32+31):(22*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_LAST_PLUS1              (23*32+31):(23*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_EG_ATTACK_RATE          (24*32+15):(24*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_EG_DECAY_RATE           (24*32+31):(24*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_EG_SUSTAIN_RATE         (25*32+15):(25*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_EG_RELEASE_RATE         (25*32+31):(25*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_PE_ATTACK_RATE          (26*32+15):(26*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_PE_DECAY_RATE           (26*32+31):(26*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_PE_SUSTAIN_RATE         (27*32+15):(27*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_PE_RELEASE_RATE         (27*32+31):(27*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_ATTACK  (28*32+15):(28*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_DEPTH           (29*32+15):(29*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_EG_SUSTAIN_LEVEL        (29*32+31):(29*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_PE_SCALE                (30*32+15):(30*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_PE_SUSTAIN_LEVEL        (30*32+31):(30*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_TREMOLO_POSITION_INC    (31*32+15):(31*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_VIBRATO_POSITION_INC    (31*32+31):(31*32+16) /* RWWUF */
#define NV_AUDNOTE_SU_TREMOLO_DEPTH           (32*32+15):(32*32+ 0) /* RWWUF */
#define NV_AUDNOTE_SU_TREMOLO_OFFSET          (32*32+31):(32*32+16) /* RWWUF */
#define NV_AUDNOTE_AE_INTR_MIXING             ( 0*32+ 0):( 0*32+ 0) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_VOLUME             ( 0*32+ 1):( 0*32+ 1) /* RWXVF */
#define NV_AUDNOTE_AE_EVENT_STOP              ( 0*32+ 2):( 0*32+ 2) /* RWXVF */
#define NV_AUDNOTE_AE_EVENT_START             ( 0*32+ 3):( 0*32+ 3) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_NOTIFY             ( 0*32+ 4):( 0*32+ 4) /* RWXVF */
#define NV_AUDNOTE_AE_PE_STATE                ( 0*32+ 7):( 0*32+ 6) /* RWXVF */
#define NV_AUDNOTE_AE_PE_ATTACK                          0x00000000 /* RW--V */
#define NV_AUDNOTE_AE_PE_DECAY                           0x00000001 /* RW--V */
#define NV_AUDNOTE_AE_PE_SUSTAIN                         0x00000002 /* RW--V */
#define NV_AUDNOTE_AE_PE_RELEASE                         0x00000003 /* RW--V */
#define NV_AUDNOTE_AE_IN_USE                  ( 0*32+ 8):( 0*32+ 8) /* RWXVF */
#define NV_AUDNOTE_AE_GAP_DETECT              ( 0*32+10):( 0*32+10) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_DMA                ( 0*32+11):( 0*32+11) /* RWXVF */
#define NV_AUDNOTE_AE_EG_STATE                ( 0*32+14):( 0*32+13) /* RWXVF */
#define NV_AUDNOTE_AE_EG_ATTACK                          0x00000000 /* RW--V */
#define NV_AUDNOTE_AE_EG_DECAY                           0x00000001 /* RW--V */
#define NV_AUDNOTE_AE_EG_SUSTAIN                         0x00000002 /* RW--V */
#define NV_AUDNOTE_AE_EG_RELEASE                         0x00000003 /* RW--V */
#define NV_AUDNOTE_AE_POS_VALID               ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_MIXING             (14*32+ 0):(14*32+ 0) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_VOLUME             (14*32+ 1):(14*32+ 1) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_NOTIFY             (14*32+ 4):(14*32+ 4) /* RWXVF */
#define NV_AUDNOTE_SU_BYPASS_PTE              (12*32+ 4):(12*32+ 4) /* RWXVF */
#define NV_AUDNOTE_SU_BYPASS_PTE_DISABLED                0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_BYPASS_PTE_ENABLED                 0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_BYPASS_TARGET           (12*32+ 6):(12*32+ 5) /* RWXVF */
#define NV_AUDNOTE_SU_BYPASS_TARGET_NVM                  0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_BYPASS_TARGET_PCI                  0x00000002 /* RW--V */
#define NV_AUDNOTE_SU_BYPASS_TARGET_AGP                  0x00000003 /* RW--V */
#define NV_AUDNOTE_SU_EG_LINEAR               (12*32+ 7):(12*32+ 7) /* RWXVF */
#define NV_AUDNOTE_SU_EG_ATCK_NV1                        0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_EG_ATCK_LINEAR                     0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_IN_USE                  (12*32+ 8):(12*32+ 8) /* RWXVF */
#define NV_AUDNOTE_SU_BUFF_NOTIFY             (16*32+10):(16*32+10) /* RWXVF */
#define NV_AUDNOTE_SU_BUFF_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_BUFF_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_CHANNEL                 (12*32+12):(12*32+12) /* RWXVF */
#define NV_AUDNOTE_SU_CHANNEL_MONO                       0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_CHANNEL_STEREO                     0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT                  (12*32+15):(12*32+13) /* RWXVF */
#define NV_AUDNOTE_SU_FORMAT_LINEAR                      0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_ULAW                        0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_ALAW                        0x00000002 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_OFFSET8                     0x00000003 /* RW--V */
#define NV_AUDNOTE_FM_FEEDBACK                (15*32+ 6):(15*32+ 4) /* RWXVF */
#define NV_AUDNOTE_FM_FB_0                               0x00000000 /* RW--V */
#define NV_AUDNOTE_FM_FB_PI_16                           0x00000001 /* RW--V */
#define NV_AUDNOTE_FM_FB_PI_8                            0x00000002 /* RW--V */
#define NV_AUDNOTE_FM_FB_PI_4                            0x00000003 /* RW--V */
#define NV_AUDNOTE_FM_FB_PI_2                            0x00000004 /* RW--V */
#define NV_AUDNOTE_FM_FB_1_PI                            0x00000005 /* RW--V */
#define NV_AUDNOTE_FM_FB_2_PI                            0x00000006 /* RW--V */
#define NV_AUDNOTE_FM_FB_4_PI                            0x00000007 /* RW--V */
#define NV_AUDNOTE_FM_WAVE_SELECT             (15*32+ 2):(15*32+ 0) /* RWXVF */
#define NV_AUDNOTE_FM_WS_SINE                            0x00000000 /* RW--V */
#define NV_AUDNOTE_FM_WS_HALF_SINE                       0x00000001 /* RW--V */
#define NV_AUDNOTE_FM_WS_ABS_SINE                        0x00000002 /* RW--V */
#define NV_AUDNOTE_FM_WS_SHARK_SINE                      0x00000003 /* RW--V */
#define NV_AUDNOTE_FM_WS_QUICK_SINE                      0x00000004 /* RW--V */
#define NV_AUDNOTE_FM_WS_ABS_QUICK                       0x00000005 /* RW--V */
#define NV_AUDNOTE_FM_WS_SQUARE                          0x00000006 /* RW--V */
#define NV_AUDNOTE_FM_WS_INV_SINE                        0x00000007 /* RW--V */
#define NV_AUDNOTE_FM_PHASE_OUT               (15*32+ 8):(15*32+ 8) /* RWXVF */
#define NV_AUDNOTE_FM_SYNTHESIS               (15*32+12):(15*32+12) /* RWXVF */
#endif /* _NV_REF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv1.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NV1.C
//
// Abstract:
//
//     This is code specific to NV1
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"
#include "nv1c_ref.h"
#include "nv1_32.h"
#include "nvsubch.h"
#include "nvalpha.h"

#include "sgs_dac.h"

#include "cmdcnst.h"

//******************************************************************************
//
// Function Declarations
//
//******************************************************************************

VOID SetRop(PHW_DEVICE_EXTENSION,ULONG);
VOID SetPattern(PHW_DEVICE_EXTENSION);
VOID SetColorKey(PHW_DEVICE_EXTENSION,ULONG);
VOID SetClip(PHW_DEVICE_EXTENSION, ULONG, ULONG, ULONG, ULONG);
VOID ImageMonoBlit(PHW_DEVICE_EXTENSION,LONG,LONG,ULONG,ULONG);
VOID MemoryToScreenBlit(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG,ULONG);
VOID ScreenToScreenBlit(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG,ULONG,ULONG,ULONG);
VOID RenderTriangle(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG);
VOID RenderRectangle(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG);
VOID UpdateRenderObjectContext(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG);
VOID CalculateRenderObjectContext(PHW_DEVICE_EXTENSION,PRENDEROBJECT,ULONG);
VOID SetContextRopSolid(PHW_DEVICE_EXTENSION,ULONG);
VOID SetContextPattern(PHW_DEVICE_EXTENSION,ULONG);
VOID SetContextBlackRectangle(PHW_DEVICE_EXTENSION,ULONG);
VOID SetContextImageSolid(PHW_DEVICE_EXTENSION,ULONG);
VOID SetPatchContext(PHW_DEVICE_EXTENSION,ULONG);
VOID InitColorFormatTable(PHW_DEVICE_EXTENSION);
VOID SetObjectColorFormat(PHW_DEVICE_EXTENSION,PCOMMONOBJECT,ULONG,ULONG);
VOID ClearPatchContext(PHW_DEVICE_EXTENSION,PPATCHCONTEXT);
VOID NV1SetupPatches(PHW_DEVICE_EXTENSION);
VOID SetupRenderObject(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG,ULONG,ULONG,ULONG);
VOID ClearOutRenderObjects(PHW_DEVICE_EXTENSION);
BOOLEAN NV1GetNVInfo(PHW_DEVICE_EXTENSION);
VOID NV1SetupGraphicsEngine(PHW_DEVICE_EXTENSION);
VOID NV1SetMode(PHW_DEVICE_EXTENSION,PMODE_ENTRY);
VOID SetObjectCachedCtxRegs(PHW_DEVICE_EXTENSION,ULONG,ULONG,ULONG);
VOID SetObjectHash(PHW_DEVICE_EXTENSION,ULONG,ULONG);
VOID FifoResend(PHW_DEVICE_EXTENSION);
VOID ClearOutGrTable(PHW_DEVICE_EXTENSION);
VOID ClearOutFifoTable(PHW_DEVICE_EXTENSION);
VOID ClearOutNVInfo(PHW_DEVICE_EXTENSION);
VOID ClearOutHashTables(PHW_DEVICE_EXTENSION);
VOID ClearOutContextMemoryAndRegisters(PHW_DEVICE_EXTENSION);
VOID LoadChannelContext(PHW_DEVICE_EXTENSION);
VOID NV1_SetColorLookup(PHW_DEVICE_EXTENSION,PVIDEO_CLUT,ULONG);
VOID NV1_InitPalette(PHW_DEVICE_EXTENSION);
ULONG NV1_MapMemoryRanges(PVOID HwDeviceExtension);
BOOLEAN NV1_IsPresent(PHW_DEVICE_EXTENSION,PVIDEO_ACCESS_RANGE,PULONG);
BOOLEAN NV1Interrupt(PHW_DEVICE_EXTENSION);
VOID dacCalcPClkVClkRatio(PHW_DEVICE_EXTENSION);
VOID dacCalcPLL(PHW_DEVICE_EXTENSION);
VOID NV1GraphicsTest(PHW_DEVICE_EXTENSION);
VOID NV1ClearScreen(PHW_DEVICE_EXTENSION);
VOID NV1WaitUntilFinished(PHW_DEVICE_EXTENSION);
VOID ImageMonoLetterY(PHW_DEVICE_EXTENSION,LONG,LONG,ULONG,ULONG);
VOID NV1SetOpenGLPatch(PHW_DEVICE_EXTENSION);
VOID NV1RestoreDisplayDriverPatch(PHW_DEVICE_EXTENSION);



VOID NV1ObjectSwappingTest(PHW_DEVICE_EXTENSION);
VOID NV1ObjectSwappingTryIt(PHW_DEVICE_EXTENSION);
VOID NV1ObjectSwappingRestore(PHW_DEVICE_EXTENSION);

// Make all other functions pageable???
#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NV1SetMode)
#pragma alloc_text(PAGE,NV1SetupGraphicsEngine)
#endif


//******************************************************************************
//
//  Function:   SetRop()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetRop(PHW_DEVICE_EXTENSION HwDeviceExtension,ULONG Rop)

    {

    NvChannel *nv;
    volatile ULONG FreeCount;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    FreeCount = nv->subchannel[ROP_SOLID_SUBCHANNEL].control.free;

    while (FreeCount < 1*4)
        FreeCount = nv->subchannel[ROP_SOLID_SUBCHANNEL].control.free;
    FreeCount -= 1*4;

    //**************************************************************************
    // Set ROP
    //**************************************************************************

    nv->subchannel[ROP_SOLID_SUBCHANNEL].ropSolid.SetRop = Rop;


    }


//******************************************************************************
//
//  Function:   SetPattern()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetPattern(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {

    NvChannel *nv;
    ULONG color0;
    ULONG color1;
    PHWINFO NVInfo;

    //**************************************************************************
    // Get pointer to NVInfo structure, then init colors
    // according to what the current pixel depth is
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            color0 =    NV_ALPHA_1_32 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_32 | 0x00ffffff;         // WHITE
            break;
        case 16:
            color0 =    NV_ALPHA_1_16 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_16 | 0x00007fff;         // WHITE
            break;
        case 8:
            color0 =    NV_ALPHA_1_08 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_08 | 0x000000ff;         // WHITE
            break;
        }

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].control.free < 5*4);

    //*************************************************************************
    //
    //  nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
    //  nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetMonochromeFormat = NV_MONO_CGA6_M1_P32;
    //
    // Do NOT set ColorFormat and Monochrome format here, because
    // they require a Resource Manager to service them!  Doing so will cause
    // a lockup/interrupt. The remaining methods are hardware methods and go
    // straight to hardware. They will NOT generate an interrupt/lockup.
    //*************************************************************************

    //*************************************************************************
    // Regardless of what the pixel depth is, we should see a jailbar pattern.
    //*************************************************************************

    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPatternShape = NV_PATTERN_SHAPE_64X1;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetColor0 = color0;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetColor1 = color1;
//    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPattern.monochrome[0] = 0x50505050;
//    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPattern.monochrome[1] = 0x12345678;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPattern.monochrome[0] = 0xffffffff;
    nv->subchannel[IMAGE_PATTERN_SUBCHANNEL].imagePattern.SetPattern.monochrome[1] = 0x50505050;

    }


//******************************************************************************
//
//  Function:   SetColorKey()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetColorKey(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG Color)

    {

    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[7].control.free < 1*4);

    //**************************************************************************
    // Set color key value
    //**************************************************************************

    nv->subchannel[7].imageSolid.SetColor = Color; // 0 will disable color keying

    }


//******************************************************************************
//
//  Function:   SetClip()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetClip(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG x, ULONG y, ULONG width, ULONG height)

    {
    ULONG i;

    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[CLIP_SUBCHANNEL].control.free < 2*4);

    //**************************************************************************
    // Set the clipping rectangle
    //**************************************************************************

    nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.y_x = ((y << 16) | x );
    nv->subchannel[CLIP_SUBCHANNEL].imageBlackRectangle.SetRectangle.height_width = ((height<<16) | width);

    }


//******************************************************************************
//
//  Function:   ImageMonoLetterY()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ImageMonoLetterY(PHW_DEVICE_EXTENSION HwDeviceExtension,
                       LONG x,LONG y, ULONG Color0, ULONG Color1)
    {

    NvChannel *nv;
    ULONG xscan, yscan;
    ULONG pixel;
    ULONG width,height;
    ULONG NumDwords;
    ULONG DwordCount;
    ULONG SizeInWidth;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // IMAGE MONO FROM CPU classes requires an UNpacked format !!!!
    //
    //          |<------------->| SizeIn = 8    (Data Width sent)
    //
    //          |<------->|  Size = 5           (Clipped size)
    //                    |
    //   ___     -------|-------
    //    ^     | | | | | | | | |
    //    |     | | | | | | | | |  1 dword = 0x00000000
    //    |     | | | | | | | | |
    //    |     | | | | | | | | |_________
    //    |     |x| | |x| | | | |
    //    |     |x| | |x| | | | |
    //Height=12 |x| | |x| | | | |  1 dword = 0x90909090
    //    |     |x| | |x| | | | |_________
    //    |     |x| | |x| | | | |
    //    |     | |x|x|x| | | | |
    //    |     | | | |x| | | | |  1 dword = 0xE0107090
    //    |     |x|x|x| | | | | |
    //   ---     ---------------
    //
    //**************************************************************************

    width = 5;
    height= 12;
    SizeInWidth = 8;

    //**************************************************************************
    // We'll set the alpha bits to test color 0 = transparent
    //                                  color 1 = visible
    //**************************************************************************

    while (nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].control.free < 5*4);
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Color0 =  Color0 ;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Color1 =  Color1 ;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Point =  ( (y <<16) | (x & 0xffff) );
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Size = ( (height <<16) | width );
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.SizeIn = ( (height <<16) | SizeInWidth );

    while (nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].control.free < 12);
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Monochrome[0] = 0x0;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Monochrome[1] = 0x090909090;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Monochrome[2] = 0x0E0107090;


    }



//******************************************************************************
//
//  Function:   ImageMonoBlit()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ImageMonoBlit(PHW_DEVICE_EXTENSION HwDeviceExtension,
                       LONG x,LONG y, ULONG Color0, ULONG Color1)
    {

    NvChannel *nv;
    ULONG xscan, yscan;
    ULONG pixel;
    ULONG width,height;
    ULONG NumDwords;
    ULONG DwordCount;
    ULONG SizeInWidth;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // IMAGE MONO FROM CPU classes requires an UNpacked format !!!!
    //**************************************************************************

    width = 50;
    height= 20;
    SizeInWidth = (width + 31) & 0xffe0;    // Specify pixels as multiple of 32 since
                                            // we always output DWORDS at a time

    NumDwords = (width + 31)/32;            // Dwords at a time (32 pixels per dword)

    //**************************************************************************
    // We'll set the alpha bits to test color 0 = transparent
    //                                  color 1 = visible
    //**************************************************************************

    while (nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].control.free < 5*4);
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Color0 =  Color0 ;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Color1 =  Color1 ;
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Point =  ( (y <<16) | (x & 0xffff) );
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Size = ( (height <<16) | width );
    nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.SizeIn = ( (height <<16) | SizeInWidth );

    //**************************************************************************
    // The following method is EXTREMELY inefficient, but simple and works.
    // To get much better performance, do NOT constantly read the
    // freecount inside the loop.  Instead, CACHE it in local memory.
    // Also, don't constantly write to the same monochrome[0] location.
    // Use increasing locations to allow for PCI burst mode, and better performance.
    // See Text accleration code in the display driver for better examples.
    //**************************************************************************

    for (yscan=0; yscan < height; yscan ++)
        for (DwordCount = 0; DwordCount < NumDwords; DwordCount++)
            {
            while (nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].control.free < 4);
            nv->subchannel[IMAGE_MONO_FROM_CPU_SUBCHANNEL].imageMonochromeFromCpu.Monochrome[0] = 0x0f0f0f0f;
            }


    }


//******************************************************************************
//
//  Function:   MemoryToScreenBlit()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID MemoryToScreenBlit(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        ULONG width,ULONG height, ULONG x,ULONG y)
    {

    NvChannel *nv;
    ULONG xscan, yscan;
    ULONG pixeldata;
    PHWINFO NVInfo;

    //**************************************************************************
    // Get pointer to NVInfo structure, then init colors
    // according to what the current pixel depth is
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            pixeldata = NV_ALPHA_1_32 | 0x00ff0000;         // RED
            break;
        case 16:
            pixeldata = (ULONG) ((NV_ALPHA_1_16 | 0x7c00)<<16) |
                         (NV_ALPHA_1_16 | 0x7c00);          // RED
            break;
        case 8:
            pixeldata =   (ULONG) ( 0xff<<24) |
                                  ( 0xff<<16) |
                                  ( 0xff<<8)  |
                                  ( 0xff)     ;                     // WHITE
            break;
        }

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    // IMAGE FROM CPU classes require a PACKED format !!!!
    //**************************************************************************

    while (nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free < 3*4);
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].imageFromCpu.Point =  ( (y <<16) | x );
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].imageFromCpu.Size = ( (height <<16) | width );
    nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].imageFromCpu.SizeIn = ( (height <<16) | width );

    for (yscan=0;yscan < height; yscan++)
        for (xscan=0; xscan < width; xscan++)
            {
            while (nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free < 4);
            nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].imageFromCpu.Color[0] =  pixeldata;
            }


    }

//******************************************************************************
//
//  Function:   ScreenToScreenBlit()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ScreenToScreenBlit(PHW_DEVICE_EXTENSION HwDeviceExtension,ULONG width,ULONG height,
                        ULONG xsrc,ULONG ysrc, ULONG xdst,ULONG ydst)

    {

    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[BLIT_SUBCHANNEL].control.free < 3*4);


    nv->subchannel[BLIT_SUBCHANNEL].imageBlit.ControlPointIn =  ( (ysrc <<16) | xsrc );
    nv->subchannel[BLIT_SUBCHANNEL].imageBlit.ControlPointOut = ( (ydst <<16) | xdst );
    nv->subchannel[BLIT_SUBCHANNEL].imageBlit.Size = ( (height <<16) | width );


    }


//******************************************************************************
//
//  Function:   RenderTriangle()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID RenderTriangle(PHW_DEVICE_EXTENSION HwDeviceExtension,ULONG x,ULONG y,ULONG Color)

    {
    ULONG i;

    NvChannel *nv;

    //**************************************************************************
    // Since we've only got 8 subchannels, we don't have enough room for the
    // TRIANGLE object.  If we need it use it later (i.e. Direct 3D/OpenGL), we'll need
    // to manually swap out one of the current objects and load the TRIANGLE object
    //**************************************************************************

//    //**************************************************************************
//    // Get pointer to NV channel area
//    //**************************************************************************
//
//    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);
//
//    //**************************************************************************
//    // Wait for FIFO
//    //**************************************************************************
//
//    while (nv->subchannel[TRIANGLE_SUBCHANNEL].control.free < 4*4);
//
//    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidTriangle.Color = 0x00000000 | Color;
//    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y0_x0 = (((y+10) << 16) | (x-10) );
//    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y1_x1 = (((y+10) << 16) | (x+10) );
//    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y2_x2 = (((y-10) << 16) | x);

    }


//******************************************************************************
//
//  Function:   RenderRectangle()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID RenderRectangle(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG x,ULONG y,ULONG Color)

    {
    ULONG i;

    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait for FIFO
    //**************************************************************************

    while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < 3*4);

    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = Color;
    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ((y << 16) | x );
    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = 0x00400040;

    }

//******************************************************************************
//
//  Function:   UpdateRenderObjectContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID UpdateRenderObjectContext(PHW_DEVICE_EXTENSION HwDeviceExtension,
                      ULONG ObjectName, ULONG SubChannel, ULONG Context)


    {
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Cache1 access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Add object to hash table
    //**************************************************************************

    SetObjectHash(HwDeviceExtension, ObjectName, Context);

    //**************************************************************************
    // Update the cached context register
    //**************************************************************************

    SetObjectCachedCtxRegs(HwDeviceExtension, SubChannel, ObjectName, Context);

    //**************************************************************************
    // Restore Cache1 state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);


    }

//******************************************************************************
//
//  Function:   CalculateRenderObjectContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID CalculateRenderObjectContext(PHW_DEVICE_EXTENSION HwDeviceExtension,
                                   PRENDEROBJECT PObject,ULONG RenderObjectClass)

    {
    ULONG Context;
    ULONG Device;
    ULONG Buffer;

    switch (RenderObjectClass)
        {
        case NV_RENDER_SOLID_POINT:
            Device = DEVICE_BASE(NV_UPOINT);
            break;
        case NV_RENDER_SOLID_LINE:
            Device = DEVICE_BASE(NV_ULINE);
            break;
        case NV_RENDER_SOLID_LIN:
            Device = DEVICE_BASE(NV_ULIN);
            break;
        case NV_RENDER_SOLID_TRIANGLE:
            Device = DEVICE_BASE(NV_UTRI);
            break;
        case NV_RENDER_SOLID_RECTANGLE:
            Device = DEVICE_BASE(NV_URECT);
            break;
        case NV_RENDER_TEXTURE_BILINEAR:
            Device = DEVICE_BASE(NV_UBTM);
            break;
        case NV_RENDER_TEXTURE_QUADRATIC:
            Device = DEVICE_BASE(NV_UQTM);
            break;
        case NV_IMAGE_FROM_CPU:
            Device = DEVICE_BASE(NV_UIMAGE);
            break;
        case NV_IMAGE_MONOCHROME_FROM_CPU:
            Device = DEVICE_BASE(NV_UBITMAP);
            break;
//        case NV_IMAGE_FROM_MEM:
//            Device = DEVICE_BASE(NV_UFROMEM);
//            break;
//        case NV_IMAGE_TO_MEM:
//            Device = DEVICE_BASE(NV_UTOMEM);
//          break;
        case NV_IMAGE_BLIT:
            Device = DEVICE_BASE(NV_UBLIT);
            break;
        }

    //**************************************************************************
    // Generate the CONTEXT for this device...
    // It consists of 2 parts...the physical DEVICE and phyiscal INSTANCE
    //
    //    ----------------------------------------------------
    //   |       DEVICE           |         Instance          |
    //    ----------------------------------------------------
    //
    //
    //  Label   Bits    Name        Description
    //  -----   ----    ----        -----------
    //  a       (0-4)   Patch Cfg   Encoded configuration value for data path units
    //                                      Value   Meaning
    //                                      -----   -------
    //                                      0 thru 1f   Many different cfgs
    //
    //  b       (5)     ChromaKey   Enables Chroma Key or Beta Maximum
    //  c       (6)     PlaneMask   Enables Plane Mask
    //  d       (7)     UserClip    Enables User Clip
    //  e       (8)     Notify      Notify valid or invalid for object
    //  f       (9-12)  Color Buffer Specifies color format of source pixel data
    //                                      Value   Meaning (Single Buffer 0)
    //                                      -----   -------
    //                                      0x0     R5G5B5
    //                                      0x1     R8G8B8
    //                                      0x2     R10G10B10
    //                                      0x3     Y8
    //                                      0x4     Y16
    //
    //  g       (13)    Alpha       Enables Alpha
    //  h       (14)    Mono        Specifies little endian or CGA6 format
    //  i       (15)    Patch ID    Resource Manager is needed to do heavy weigh context switch
    //
    //**************************************************************************

    Buffer = 0;         // Is this the correct value ???
                        // 1 for R8G8B8 ???
    Context = Device                                      |
              PObject->RCPatchContext.ImageConfig         |
              PObject->CColorFormat                       |
              PObject->CMonoFormat +
              DRF_NUM(_PGRAPH,_CTX_SWITCH,_COLOR_BUFFER, Buffer);

    //**************************************************************************
    // .. and return it.
    //**************************************************************************

    PObject->CContext = Context;
    }


//******************************************************************************
//
//  Function:   SetContextRopSolid()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetContextRopSolid(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PCOMMONOBJECT StaticObjectPtr;
    PPATCHCONTEXT PatchContextPtr;
    ULONG Context;
    PHWINFO NVInfo;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // If a true resource manager were implemented, then there would probably
    // be several different patches setup (conceptually).  But since we don't
    // have a resource manager, we're programming at the hardware/physical level.
    // So basically, all rendering objects will share the ROP SOLID , PATTERN,
    // CLIP, and IMAGE SOLID devices.  Another way to look at it at this level,
    // is that we only implement ONE patch and all the rendering objects
    // will share it.
    //
    //
    //          ROP SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
    //              |           |           |                   |
    //  RENDER--     ---    ----            |                   |
    //  OBJECT  |       |  |                |                   |
    //          |    -----------         -------------       ----------
    //           ---|           |       |             |     |          |
    //  RENDER _____|   IMAGE   |_______|    IMAGE    |_____|  IMAGE   |__IMAGE TO__VIDEO
    //  OBJECT      |  ROP AND  |       |   STENCIL   |     | COLORKEY |   VIDEO    SINK
    //           ---|           |       |             |     |          |
    //  RENDER _|  - -----------         -------------       ----------
    //  OBJECT    |
    //            |
    //  RENDER ---
    //  OBJECT
    //
    //  etc...
    //
    //  Touching any of the ROP SOLID,PATTERN, CLIP, or IMAGE SOLID devices
    //  will affect ALL rendering objects.  In essence, we're programming
    //  this card without the assistance of context switching from a resource
    //  manager.  We have to do it ourselves.
    //
    // See function MthdStaticImage() in the Win 95 Resource manager
    // for more information on how the following contexts are initialized
    //
    //**************************************************************************

    //**************************************************************************
    // Update the context for the STATIC OBJECT (IMAGE_ROP_SOLID).
    // Enable COLORKEY'ing
    //**************************************************************************

    StaticObjectPtr = (PCOMMONOBJECT)&(HwDeviceExtension->CommonObject[IMAGE_ROP_ID]);

    //**************************************************************************
    // Set the color format according to the current frame buffer depth
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    if (NVInfo->Framebuffer.Depth == 8)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A8Y8;
    else if (NVInfo->Framebuffer.Depth == 16)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A1R5G5B5;
    else
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_A8R8G8B8;

    StaticObjectPtr->MonoFormat = 0;

    StaticObjectPtr->Context = DEVICE_BASE(NV_UROP) | StaticObjectPtr->ColorFormat;

    //**************************************************************************
    // Update the context for the associated RENDER OBJECT.
    // Enable COLORKEY'ing
    //**************************************************************************

    PatchContextPtr = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    ;   // No updates necessary

    //**************************************************************************
    // Specify the actual ROP value.
    //**************************************************************************

    PatchContextPtr->Rop.Rop3 = 0xcc;   // Source Copy for now

    //**************************************************************************
    // Save the name of this STATIC object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    StaticObjectPtr->Base.Name = MY_ROP_SOLID;
    HwDeviceExtension->FifoTable.ObjectStack[ROP_SOLID_SUBCHANNEL] = MY_ROP_SOLID;

    //**************************************************************************
    // Add STATIC object to hash table and update the cached context register
    //**************************************************************************

    Context = StaticObjectPtr->Context;
    SetObjectHash(HwDeviceExtension, MY_ROP_SOLID, Context);
    SetObjectCachedCtxRegs(HwDeviceExtension, ROP_SOLID_SUBCHANNEL, MY_ROP_SOLID, Context);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }


//******************************************************************************
//
//  Function:   SetContextPattern()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetContextPattern(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PCOMMONOBJECT StaticObjectPtr;
    PPATCHCONTEXT PatchContextPtr;
    ULONG Context;
    PHWINFO NVInfo;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // If a true resource manager were implemented, then there would probably
    // be several different patches setup (conceptually).  But since we don't
    // have a resource manager, we're programming at the hardware/physical level.
    // So basically, all rendering objects will share the ROP SOLID , PATTERN,
    // CLIP, and IMAGE SOLID devices.  Another way to look at it at this level,
    // is that we only implement ONE patch and all the rendering objects
    // will share it.
    //
    //
    //          ROP SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
    //              |           |           |                   |
    //  RENDER--     ---    ----            |                   |
    //  OBJECT  |       |  |                |                   |
    //          |    -----------         -------------       ----------
    //           ---|           |       |             |     |          |
    //  RENDER _____|   IMAGE   |_______|    IMAGE    |_____|  IMAGE   |__IMAGE TO__VIDEO
    //  OBJECT      |  ROP AND  |       |   STENCIL   |     | COLORKEY |   VIDEO    SINK
    //           ---|           |       |             |     |          |
    //  RENDER _|  - -----------         -------------       ----------
    //  OBJECT    |
    //            |
    //  RENDER ---
    //  OBJECT
    //
    //  etc...
    //
    //  Touching any of the ROP SOLID,PATTERN, CLIP, or IMAGE SOLID devices
    //  will affect ALL rendering objects.  In essence, we're programming
    //  this card without the assistance of context switching from a resource
    //  manager.  We have to do it ourselves.
    //
    // See function MthdStaticImage() in the Win 95 Resource manager
    // for more information on how the following contexts are initialized
    //
    //**************************************************************************

    //**************************************************************************
    // Update the context for the STATIC OBJECT (IMAGE_PATTERN).
    //**************************************************************************

    StaticObjectPtr = (PCOMMONOBJECT)&(HwDeviceExtension->CommonObject[IMAGE_PATTERN_ID]);

    //**************************************************************************
    // Set the color format according to the current frame buffer depth
    //**************************************************************************

//    if (NVInfo->Framebuffer.Depth == 8)
//        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A8Y8;
//    else if (NVInfo->Framebuffer.Depth == 16)
//        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A1R5G5B5;
//    else
//        StaticObjectPtr->ColorFormat = COLOR_FORMAT_A8R8G8B8;

    if (NVInfo->Framebuffer.Depth == 8)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X24Y8;
    else if (NVInfo->Framebuffer.Depth == 16)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X17R5G5B5;
    else
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X8R8G8B8;

    StaticObjectPtr->MonoFormat = MONO_FORMAT_CGA6;
    StaticObjectPtr->Context = DEVICE_BASE(NV_UPATT)                    |
                              StaticObjectPtr->ColorFormat              |
                              StaticObjectPtr->MonoFormat;

    //**************************************************************************
    // Update the context for the associated RENDER OBJECT.
    // Here we just specify the patch configuration.
    //
    // - PatchConfig - See the Patch Configuration table (7-1) in the
    //                 graphics reference to determine how to set this value.
    //                 It is determined by where src, pattern, and destination
    //                 are hooked up to the ROP_AND object.  For the DISPLAY
    //                 driver, we will be using the following conceptual hookup patch.
    //
    //                                                     ---
    //                  IMAGE_TO_VIDEO (DST)---> input 0  | R |
    //                  RENDER OBJECT (SRC) ---> input 1  | O |
    //                  PATTERN OBJECT (PAT)---> input 2  | P |
    //                                                     ---
    //                  This corresponds to patch configuration 0x10
    //                  for the CTX_SWITCH register bits 0-4.
    //
    //**************************************************************************

    PatchContextPtr = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    PatchContextPtr->ImageConfig &= 0xffffffe0;
    PatchContextPtr->ImageConfig |= DRF_NUM(_PGRAPH,_CTX_SWITCH, _PATCH_CONFIG, 0x10);

    //**************************************************************************
    // Specify the actual PATTERN values.  These will actually get written
    // to hardware later.
    //**************************************************************************

    PatchContextPtr->RopPat.PattColor0      = 0xff00ff00;
    PatchContextPtr->RopPat.PattColor0Alpha = 0xff00ff00;
    PatchContextPtr->RopPat.PattColor1      = 0xffffff00;
    PatchContextPtr->RopPat.Pattern0        = 0x50505050;
    PatchContextPtr->RopPat.Pattern1        = 0x12345678;
    PatchContextPtr->RopPat.PatternShape = NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1;

    //**************************************************************************
    // Save the name of this STATIC object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    StaticObjectPtr->Base.Name = MY_IMAGE_PATTERN;
    HwDeviceExtension->FifoTable.ObjectStack[IMAGE_PATTERN_SUBCHANNEL] = MY_IMAGE_PATTERN;

    //**************************************************************************
    // Add STATIC object to hash table and update the cached context register
    //**************************************************************************

    Context = StaticObjectPtr->Context;
    SetObjectHash(HwDeviceExtension, MY_IMAGE_PATTERN, Context);
    SetObjectCachedCtxRegs(HwDeviceExtension, IMAGE_PATTERN_SUBCHANNEL, MY_IMAGE_PATTERN, Context);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }


//******************************************************************************
//
//  Function:   SetContextBlackRectangle()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetContextBlackRectangle(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PCOMMONOBJECT StaticObjectPtr;
    PPATCHCONTEXT PatchContextPtr;
    ULONG Context;
    PHWINFO NVInfo;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // If a true resource manager were implemented, then there would probably
    // be several different patches setup (conceptually).  But since we don't
    // have a resource manager, we're programming at the hardware/physical level.
    // So basically, all rendering objects will share the ROP SOLID , PATTERN,
    // CLIP, and IMAGE SOLID devices.  Another way to look at it at this level,
    // is that we only implement ONE patch and all the rendering objects
    // will share it.
    //
    //
    //          ROP SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
    //              |           |           |                   |
    //  RENDER--     ---    ----            |                   |
    //  OBJECT  |       |  |                |                   |
    //          |    -----------         -------------       ----------
    //           ---|           |       |             |     |          |
    //  RENDER _____|   IMAGE   |_______|    IMAGE    |_____|  IMAGE   |__IMAGE TO__VIDEO
    //  OBJECT      |  ROP AND  |       |   STENCIL   |     | COLORKEY |   VIDEO    SINK
    //           ---|           |       |             |     |          |
    //  RENDER _|  - -----------         -------------       ----------
    //  OBJECT    |
    //            |
    //  RENDER ---
    //  OBJECT
    //
    //  etc...
    //
    //  Touching any of the ROP SOLID,PATTERN, CLIP, or IMAGE SOLID devices
    //  will affect ALL rendering objects.  In essence, we're programming
    //  this card without the assistance of context switching from a resource
    //  manager.  We have to do it ourselves.
    //
    // See function MthdStaticImage() in the Win 95 Resource manager
    // for more information on how the following contexts are initialized
    //
    //**************************************************************************


    //**************************************************************************
    // Update the context for the STATIC OBJECT (IMAGE_BLACK_RECTANGLE).
    //**************************************************************************

    StaticObjectPtr = (PCOMMONOBJECT)&(HwDeviceExtension->CommonObject[IMAGE_BLACK_RECTANGLE_ID]);

    //**************************************************************************
    // Set the color format according to the current frame buffer depth
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    if (NVInfo->Framebuffer.Depth == 8)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A8Y8;
    else if (NVInfo->Framebuffer.Depth == 16)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A1R5G5B5;
    else
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_A8R8G8B8;

    StaticObjectPtr->MonoFormat = 0;


    StaticObjectPtr->Context = DEVICE_BASE(NV_UCLIP) | StaticObjectPtr->ColorFormat;

    //**************************************************************************
    // Update the context for the associated RENDER OBJECT.
    // Enable CLIPPING
    //**************************************************************************

    PatchContextPtr = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    PatchContextPtr->ImageConfig |= DRF_DEF(_PGRAPH,_CTX_SWITCH, _USER_CLIP, _ENABLED);

    //**************************************************************************
    // Specify the actual CLIP values.  These will actually get written
    // to hardware later.
    //**************************************************************************

    PatchContextPtr->Clip.xClipMin = 100;
    PatchContextPtr->Clip.xClipMax = 320;  // TO DO :Get values from NVINFO !!!
    PatchContextPtr->Clip.yClipMin = 100;
    PatchContextPtr->Clip.yClipMax = 240;  // TO DO: Get values from NVINFO

    //**************************************************************************
    // Save the name of this STATIC object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    StaticObjectPtr->Base.Name = MY_BLACK_RECTANGLE;
    HwDeviceExtension->FifoTable.ObjectStack[CLIP_SUBCHANNEL] = MY_BLACK_RECTANGLE;

    //**************************************************************************
    // Add STATIC object to hash table and update the cached context register
    //**************************************************************************

    Context = StaticObjectPtr->Context;
    SetObjectHash(HwDeviceExtension, MY_BLACK_RECTANGLE, Context);
    SetObjectCachedCtxRegs(HwDeviceExtension, CLIP_SUBCHANNEL, MY_BLACK_RECTANGLE, Context);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }



//******************************************************************************
//
//  Function:   SetContextImageSolid()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetContextImageSolid(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PCOMMONOBJECT StaticObjectPtr;
    PPATCHCONTEXT PatchContextPtr;
    ULONG Context;
    PHWINFO NVInfo;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // If a true resource manager were implemented, then there would probably
    // be several different patches setup (conceptually).  But since we don't
    // have a resource manager, we're programming at the hardware/physical level.
    // So basically, all rendering objects will share the ROP SOLID , PATTERN,
    // CLIP, and IMAGE SOLID devices.  Another way to look at it at this level,
    // is that we only implement ONE patch and all the rendering objects
    // will share it.
    //
    //
    //          ROP SOLID   PATTERN     BLACK RECTANGLE     IMAGE SOLID
    //              |           |           |                   |
    //  RENDER--     ---    ----            |                   |
    //  OBJECT  |       |  |                |                   |
    //          |    -----------         -------------       ----------
    //           ---|           |       |             |     |          |
    //  RENDER _____|   IMAGE   |_______|    IMAGE    |_____|  IMAGE   |__IMAGE TO__VIDEO
    //  OBJECT      |  ROP AND  |       |   STENCIL   |     | COLORKEY |   VIDEO    SINK
    //           ---|           |       |             |     |          |
    //  RENDER _|  - -----------         -------------       ----------
    //  OBJECT    |
    //            |
    //  RENDER ---
    //  OBJECT
    //
    //  etc...
    //
    //  Touching any of the ROP SOLID,PATTERN, CLIP, or IMAGE SOLID devices
    //  will affect ALL rendering objects.  In essence, we're programming
    //  this card without the assistance of context switching from a resource
    //  manager.  We have to do it ourselves.
    //
    // See function MthdStaticImage() in the Win 95 Resource manager
    // for more information on how the following contexts are initialized
    //
    //**************************************************************************

    //**************************************************************************
    // Update the context for the STATIC OBJECT (IMAGE_SOLID).
    // Enable COLORKEY'ing
    //
    // Color Format information (Assumes only Destination Buffer 0 Enabled):
    // See Table 7-2 in the NV1 Graphics Reference Manual for more information
    // on Color and Buffer Configuration Bits 9-12 in CTX_SWITCH register
    //
    //              DEFINE  corresponds to  COLOR FORMAT
    //              --------------          ------------
    //              X17R5G5B5               0x00000000
    //              X16A1R5G5B5             0x00002000
    //              X8R8G8B8                0x00000200
    //              A8RG8B8                 0x00002200
    //              X2R10G10B10             0x00000400
    //              A2R10G10B10             0x00002400
    //              etc..
    //
    //**************************************************************************

    StaticObjectPtr = (PCOMMONOBJECT)&(HwDeviceExtension->CommonObject[IMAGE_SOLID_ID]);

    //**************************************************************************
    // Set the color format according to the current frame buffer depth
    //**************************************************************************

    if (NVInfo->Framebuffer.Depth == 8)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A8Y8;
    else if (NVInfo->Framebuffer.Depth == 16)
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_X16A1R5G5B5;
    else
        StaticObjectPtr->ColorFormat = COLOR_FORMAT_A8R8G8B8;

    StaticObjectPtr->MonoFormat = 0;
    StaticObjectPtr->Context = DEVICE_BASE(NV_UCHROMA)                    |
                              StaticObjectPtr->ColorFormat;

    //**************************************************************************
    // Update the context for the associated RENDER OBJECT.
    // Enable COLORKEY'ing
    //**************************************************************************

    PatchContextPtr = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    PatchContextPtr->ImageConfig |= DRF_DEF(_PGRAPH,_CTX_SWITCH,_CHROMA_KEY,_ENABLED);

    //**************************************************************************
    // Specify the actual ROP value.  This will actually get written
    // to hardware later.
    //**************************************************************************

    PatchContextPtr->ColorKey.Color = 0;  //Disable color keying

    //**************************************************************************
    // Save the name of this STATIC object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    StaticObjectPtr->Base.Name = MY_IMAGE_SOLID;
    HwDeviceExtension->FifoTable.ObjectStack[7] = MY_IMAGE_SOLID;

    //**************************************************************************
    // Add STATIC object to hash table and update the cached context register
    //**************************************************************************

    Context = StaticObjectPtr->Context;
    SetObjectHash(HwDeviceExtension, MY_IMAGE_SOLID, Context);
    SetObjectCachedCtxRegs(HwDeviceExtension, 7, MY_IMAGE_SOLID, Context);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }


//******************************************************************************
//
//  Function:   SetPatchContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetPatchContext(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG PatchID)

    {
    ULONG i;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;
    PPATCHCONTEXT PatchContext;
    PGRAPHICSCHANNEL GrTablePtr;
    PCOMMONOBJECT StaticObjectPtr;
    ULONG Data;
    ULONG XYLogicMisc1;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    //
    // grLoadPatch vs. grLoadChannelContext in Win 95RM
    // ------------------------------------------------
    // In the Win95 Resource Manager (for NV1), these functions are very similar.
    // The difference between these two functions is that grLoadChannelContext
    // is used mainly during Context Switching, whereas grLoadPatch is used
    // update the contexts of the NON-RENDERING objects, usually the first time.
    // grLoadChannelContext just manually goes in an modifies the global registers
    // and restores the global state of the graphics engine. In other words,
    // grLoadPatch is a SuperSet/One Time init of grLoadChannelContext.
    // Not only does it set the registers, it also sets up an entry in the
    // HASH TABLE for the object, and updates the object's context in the
    // appropriate cached context register.
    //
    // Here, in this miniport, the SetPatchContextXXXXX functions will be
    // analogous to grLoadPatch.
    //
    // This function will:
    //
    //         1) Set up the static object states (ROP,CLIP,PATTERN,COLOR KEY)
    //            This includes
    //                  - Adding an entry into the HASH table for each static object
    //                  - Setting up the context of static object in
    //                    the cached context registers
    //                  - Updating the associated RENDERING object's context.
    //                    It is affected by whatever values we specify in the
    //                    static objects (i.e.  enables clipping )
    //         2) Set the actual hardware registers for ROP, CLIP, PATTERN, and COLOR KEY
    //
    //**************************************************************************

    //**************************************************************************
    // The following functions will:
    //
    //      1) Calculate the context for the specific static object
    //         according to what attributes we specify
    //      2) Update the Hash Table and store the Context in the
    //         corresponding cached context register
    //      3) Update the context for the corresponding RENDER object
    //         associated with this patch
    //
    // Static Objects: ROP, PATTERN, BLACK RECTANGLE(CLIP), and IMAGE SOLID (COLOR KEY)
    //**************************************************************************

    //**************************************************************************
    // Color Keying is currently DISABLED !!! (Because we only have 8 subchannels
    // and color keying is not that important for a display driver.
    //
    // Update: Added SetContextImageSolid back in because DDRAW requires it!!
    //**************************************************************************

    SetContextImageSolid(HwDeviceExtension,PatchID);

    SetContextBlackRectangle(HwDeviceExtension,PatchID);

    SetContextRopSolid(HwDeviceExtension,PatchID);

    SetContextPattern(HwDeviceExtension,PatchID);

    //**************************************************************************
    // Get pointers to each of the static state objects so that
    // we can setup the hardware register values.
    //**************************************************************************

    PatchContext = (PPATCHCONTEXT)&(HwDeviceExtension->RenderObject[PatchID].RCPatchContext);
    GrTablePtr   = &(HwDeviceExtension->GrTable);

    GrTablePtr->CurrentColorKey  = &(PatchContext->ColorKey);
    GrTablePtr->CurrentRop       = &(PatchContext->Rop);
    GrTablePtr->CurrentClip      = &(PatchContext->Clip);
    GrTablePtr->CurrentPattern   = &(PatchContext->RopPat);

    //**************************************************************************
    // Load STATIC STATE into hardware registers:
    //**************************************************************************

    // Color Key/Image Solid
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CHROMA, GrTablePtr->CurrentColorKey->Color);

    // Clip/Black Rectangle (ALWAYS write MIN values before MAX values!!)
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMIN, GrTablePtr->CurrentClip->xClipMin);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMIN, GrTablePtr->CurrentClip->yClipMin);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMAX, GrTablePtr->CurrentClip->xClipMax);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMAX, GrTablePtr->CurrentClip->yClipMax);

    // Always use the USER clip rects
    XYLogicMisc1=0;
    XYLogicMisc1 |= (DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMAX, _USERMAX)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMAX, _USERMAX)) ;
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC1,XYLogicMisc1);

    // Pattern
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR0_0, GrTablePtr->CurrentPattern->PattColor0);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR0_1, GrTablePtr->CurrentPattern->PattColor0Alpha);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR1_0, GrTablePtr->CurrentPattern->PattColor1);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR1_1, GrTablePtr->CurrentPattern->PattColor1Alpha);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN(0), GrTablePtr->CurrentPattern->Pattern0);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN(1), GrTablePtr->CurrentPattern->Pattern1);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN_SHAPE, GrTablePtr->CurrentPattern->PatternShape);

    // Rop
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ROP3, GrTablePtr->CurrentRop->Rop3);

    // Beta and Plane Mask
////    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_BETA, GrTablePtr->CurrentBeta->Beta);
////    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PLANE_MASK, GrTablePtr->CurrentPlaneMask->Color);

    //**************************************************************************
    // Reset context switch bits
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_EXCEPTIONS,0x00000000);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);


    }


//******************************************************************************
//
//  Function:   InitColorFormatTable()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID InitColorFormatTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    HwDeviceExtension->ColorFormatTable[0] = 0x00000000;
    HwDeviceExtension->ColorFormatTable[1] = 0x00000001;
    HwDeviceExtension->ColorFormatTable[2] = 0x00000002;
    HwDeviceExtension->ColorFormatTable[3] = 0x00010000;
    HwDeviceExtension->ColorFormatTable[4] = 0x00010001;
    }



//******************************************************************************
//
//  Function:   SetObjectColorFormat()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetObjectColorFormat(PHW_DEVICE_EXTENSION HwDeviceExtension,
                          PCOMMONOBJECT Pobject, ULONG UserColorFormat,
                          ULONG MonoFormat)

    {
    ULONG AdjustedColor;
    ULONG i;

    //**************************************************************************
    // This function is used to convert the user specified color format
    // into the hardware context field
    //**************************************************************************

    //**************************************************************************
    // Mask off 2 bits. (Don't accept monochrome formats)
    //*****