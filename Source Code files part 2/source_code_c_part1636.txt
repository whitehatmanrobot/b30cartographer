of(Message)
        );

    // success
    return TRUE;
}


BOOL
H323SendVideoFastUpdatePictureCommand(
    PH323_CALL pCall,
    PH323_CHANNEL pChannel
     )
/*++

Routine Description:

    Sends VIDEO_FAST_UPDATE_PICTURE_COMMAND from TSP to MSP.

Arguments:

    pCall - Specifies a pointer to the call object.

    pChannel - Specifies a pointer to the channel object to open.

Return Values:

    Returns TRUE if successful.
    
--*/

{
    H323TSP_MESSAGE Message;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "TSP->MSP I-Frame request. hmChannel=0x%08lx.\n",
        pChannel->hmChannel
        ));

    // set the appropriate message type
    Message.Type = H323TSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND;

    // initialize tsp channel handle
    Message.VideoFastUpdatePictureCommand.hChannel = 
                pChannel->hmChannel;

    // send msp message
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_SENDMSPDATA,
        MSP_HANDLE_UNKNOWN,
        (DWORD_PTR)&Message,
        sizeof(Message)
        );

    // success
    return TRUE;
}


BOOL
H323SendFlowControlCommand(
    PH323_CALL pCall,
    PH323_CHANNEL pChannel,
    DWORD dwBitRate
    )
        
/*++
Routine Description:

    Sends FLOW_CONTROL_COMMAND from TSP to MSP.

Arguments:

    pCall - Specifies a pointer to the call object.

    pChannel - Specifies a pointer to the channel object to open.

    dwBitRate - Specifies new media stream bit rate (in bps) for MSP

Return Values:

    Returns true if successful.
    
--*/

{
    H323TSP_MESSAGE Message;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "TSP->MSP Flow Control request. hmChannel=0x%08lx. Req. rate=%08d.\n",
        pChannel->hmChannel,
        dwBitRate
        ));

    // set the appropriate message type
    Message.Type = H323TSP_FLOW_CONTROL_COMMAND;

    // initialize tsp channel handle
    Message.FlowControlCommand.hChannel = pChannel->hmChannel;

    // transfer stream settings
    Message.FlowControlCommand.dwBitRate = dwBitRate;

    // send msp message
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_SENDMSPDATA,
        MSP_HANDLE_UNKNOWN,
        (DWORD_PTR)&Message,
        sizeof(Message)
        );

    // success
    return TRUE;
}


BOOL
H323UpdateMediaModes(
    PH323_CALL pCall
    )
        
/*++

Routine Description:

    Updates media modes based on new channel table.

Arguments:

    pCall - Pointer to call object to update.

Return Values:

    Returns true if successful.
      
--*/

{
    DWORD i;
    DWORD dwIncomingModesOld;
    DWORD dwOutgoingModesOld;
    PH323_CHANNEL_TABLE pChannelTable = pCall->pChannelTable;

    // save old media modes
    dwIncomingModesOld = pCall->dwIncomingModes;
    dwOutgoingModesOld = pCall->dwOutgoingModes;

    // clear modia modes
    pCall->dwIncomingModes = 0;
    pCall->dwOutgoingModes = 0;

    // loop through each object in table
    for (i = 0; i < pChannelTable->dwNumSlots; i++) {

        // see if there are any open channels in table
        if (H323IsChannelOpen(pChannelTable->pChannels[i])) {

            // see if open channel is incoming 
            if (H323IsChannelInbound(pChannelTable->pChannels[i])) {

                // add media mode to list of media modes
                pCall->dwIncomingModes |= 
                    H323IsVideoPayloadType(pChannelTable->pChannels[i]->Settings.dwPayloadType)
                        ? LINEMEDIAMODE_VIDEO
                        : H323IsInteractiveVoiceRequested(pCall)
                            ? LINEMEDIAMODE_INTERACTIVEVOICE
                            : LINEMEDIAMODE_AUTOMATEDVOICE
                            ;

            } else {

                // add media mode to list of media modes
                pCall->dwOutgoingModes |= 
                    H323IsVideoPayloadType(pChannelTable->pChannels[i]->Settings.dwPayloadType)
                      ? LINEMEDIAMODE_VIDEO                      
                      : H323IsInteractiveVoiceRequested(pCall)                      
                          ? LINEMEDIAMODE_INTERACTIVEVOICE                      
                          : LINEMEDIAMODE_AUTOMATEDVOICE                      
                          ;                      
            }
        }
    }

    // see if media modes were modified
    if ((dwIncomingModesOld | dwOutgoingModesOld) != 
        (pCall->dwIncomingModes | pCall->dwOutgoingModes)) {

        // announce media change
        (*g_pfnLineEventProc)(
            pCall->pLine->htLine,
            pCall->htCall,
            LINE_CALLINFO,
            LINECALLINFOSTATE_MEDIAMODE,
            0,
            0
            );
    }
    
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx incoming modes 0x%08x (old=0x%08lx).\n",
        pCall,
        pCall->dwIncomingModes,
        dwIncomingModesOld
        ));

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx outgoing modes 0x%08x (old=0x%08lx).\n",
        pCall,
        pCall->dwOutgoingModes,
        dwOutgoingModesOld
        ));

    // success
    return TRUE;
}


BOOL
H323SendAcceptChannelRequest(
    PH323_CALL pCall,
    PH323_CHANNEL pChannel
    )
        
/*++

Routine Description:

    Sends ACCEPT_CHANNEL_REQUEST from TSP to MSP.

Arguments:

    pCall - Specifies a pointer to the call object.

    pChannel - Specifies a pointer to the channel object to open.

Return Values:

    Returns true if successful.
    
--*/

{
    H323TSP_MESSAGE Message;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "Accept channel request to MSP. htChannel=0x%08lx.\n",
        pChannel->hccChannel
        ));

    // set the appropriate message type
    Message.Type = H323TSP_ACCEPT_CHANNEL_REQUEST;

    // initialize tsp channel handle
    Message.AcceptChannelRequest.htChannel = (HANDLE)(DWORD)pChannel->hccChannel;

    // transfer stream settings
    Message.AcceptChannelRequest.Settings = pChannel->Settings;

    // send msp message
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_SENDMSPDATA,
        MSP_HANDLE_UNKNOWN,
        (DWORD_PTR)&Message,
        sizeof(Message)
        );

    // success
    return TRUE;
}


BOOL
H323SendOpenChannelResponse(
    PH323_CALL pCall,
    PH323_CHANNEL pChannel
    )
        
/*++

Routine Description:

    Sends OPEN_CHANNEL_RESPONSE from TSP to MSP.

Arguments:

    pCall - Specifies a pointer to the call object.

    pChannel - Specifies a pointer to the channel object to open.

Return Values:

    Returns true if successful.
    
--*/

{
    H323TSP_MESSAGE Message;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "Open channel response to MSP. hmChannel=0x%08lx.\n",
        pChannel->hmChannel
        ));

    // set the appropriate message type
    Message.Type = H323TSP_OPEN_CHANNEL_RESPONSE;

    // initialize channel handles
    Message.OpenChannelResponse.hmChannel = pChannel->hmChannel;
    Message.OpenChannelResponse.htChannel = (HANDLE)(DWORD)pChannel->hccChannel;

    // transfer stream settings
    Message.OpenChannelResponse.Settings = pChannel->Settings;

    // send msp message
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_SENDMSPDATA,
        MSP_HANDLE_UNKNOWN,
        (DWORD_PTR)&Message,
        sizeof(Message)
        );

    // success
    return TRUE;
}


BOOL
H323SendCloseChannelCommand(
    PH323_CALL    pCall,
    HANDLE        hmChannel,
    DWORD         dwReason
    )
        
/*++

Routine Description:

    Sends CLOSE_CHANNEL_COMMAND from TSP to MSP.

Arguments:

    pCall - Specifies a pointer to the call object.

    hmChannel - Specifies a handle to the channel to close.

    dwReason - Specifies reason for closing channel.

Return Values:

    Returns true if successful.
    
--*/

{
    H323TSP_MESSAGE Message;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "Close channel command to MSP. hmChannel=0x%08lx.\n",
        hmChannel
        ));

    // set the appropriate message type
    Message.Type = H323TSP_CLOSE_CHANNEL_COMMAND;

    // transfer reason
    Message.CloseChannelCommand.dwReason = dwReason;

    // initialize channel handles
    Message.CloseChannelCommand.hChannel = hmChannel;

    // send msp message
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_SENDMSPDATA,
        MSP_HANDLE_UNKNOWN,
        (DWORD_PTR)&Message,
        sizeof(Message)
        );

    // success
    return TRUE;
}


BOOL
H323ProcessOpenChannelRequest(
    PH323_CALL                    pCall,
    PH323MSG_OPEN_CHANNEL_REQUEST pRequest
    )
        
/*++

Routine Description:

    Process command from MSP.

Arguments:

    pCall - Specifies a pointer to the call object to process.

    pRequest - Specifies a pointer to the command block.

Return Values:

    Returns true if successful.
    
--*/

{
    BOOL fOpened = FALSE;
    PH323_CHANNEL pChannel = NULL;
    PH323_CHANNEL pAssociatedChannel = NULL;
    BYTE bSessionID;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "open channel reqest from MSP. hmChannel=0x%08lx.\n",
        pRequest->hmChannel
        ));

    // determine session id from media type
    bSessionID = (pRequest->Settings.MediaType == MEDIA_AUDIO)
                    ? H245_SESSIONID_AUDIO
                    : H245_SESSIONID_VIDEO
                    ;

    // look for existing session
    H323LookupChannelBySessionID(
        &pAssociatedChannel,
        pCall->pChannelTable,
        bSessionID
        );

    // allocate new channel object
    if (!H323AllocChannelFromTable(
            &pChannel,
            &pCall->pChannelTable,
            pCall)) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "could not allocate channel hmChannel=0x%08lx.\n",
            pRequest->hmChannel
            ));

        // close the requested channel
        H323SendCloseChannelCommand(
            pCall,
            pRequest->hmChannel,
            ERROR_NOT_ENOUGH_MEMORY
            );

        // failure
        return FALSE;
    }

    // save msp channel handle
    pChannel->hmChannel = pRequest->hmChannel;

    // initialize common information
    pChannel->bSessionID = bSessionID;
    pChannel->pCall = pCall;

    // examine existing session
    if (pAssociatedChannel != NULL) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "overriding default local RTCP port for session %d\n",
            pChannel->bSessionID
            ));

        // override default RTCP port with existing one
        pChannel->ccLocalRTCPAddr.Addr.IP_Binary.wPort =
            pAssociatedChannel->ccLocalRTCPAddr.Addr.IP_Binary.wPort;
    }

    // see if outgoing audio requested
    if (bSessionID == H245_SESSIONID_AUDIO) {

        // transfer capabilities from call object
        pChannel->ccTermCaps = pCall->ccRemoteAudioCaps;

        // check terminal capabilities for g723
        if (pChannel->ccTermCaps.ClientType == H245_CLIENT_AUD_G723) {

            // complete stream description structure
            pChannel->Settings.MediaType = MEDIA_AUDIO;
            pChannel->Settings.dwPayloadType = G723_RTP_PAYLOAD_TYPE;
            pChannel->Settings.dwDynamicType = G723_RTP_PAYLOAD_TYPE;
            pChannel->Settings.Audio.dwMillisecondsPerPacket =
                G723_MILLISECONDS_PER_PACKET(
                    pChannel->ccTermCaps.Cap.H245Aud_G723.maxAl_sduAudioFrames
                    );
            pChannel->Settings.Audio.G723Settings.bG723LowSpeed =
                                 H323IsSlowLink(pCall->dwLinkSpeed);

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "outgoing G723 stream (%d milliseconds).\n",
                pChannel->Settings.Audio.dwMillisecondsPerPacket
                ));

            // open outgoing channel
            fOpened = H323OpenChannel(pChannel);

        } else if (pChannel->ccTermCaps.ClientType == H245_CLIENT_AUD_G711_ULAW64) {

            // complete stream description structure
            pChannel->Settings.MediaType = MEDIA_AUDIO;
            pChannel->Settings.dwPayloadType = G711U_RTP_PAYLOAD_TYPE;
            pChannel->Settings.dwDynamicType = G711U_RTP_PAYLOAD_TYPE;
            pChannel->Settings.Audio.dwMillisecondsPerPacket =
                G711_MILLISECONDS_PER_PACKET(
                    pChannel->ccTermCaps.Cap.H245Aud_G711_ULAW64
                    );

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "outgoing G711U stream (%d milliseconds).\n",
                pChannel->Settings.Audio.dwMillisecondsPerPacket
                ));

            // open outgoing channel
            fOpened = H323OpenChannel(pChannel);

        } else if (pChannel->ccTermCaps.ClientType == H245_CLIENT_AUD_G711_ALAW64) {

            // complete stream description structure
            pChannel->Settings.MediaType = MEDIA_AUDIO;
            pChannel->Settings.dwPayloadType = G711A_RTP_PAYLOAD_TYPE;
            pChannel->Settings.dwDynamicType = G711A_RTP_PAYLOAD_TYPE;
            pChannel->Settings.Audio.dwMillisecondsPerPacket =
                G711_MILLISECONDS_PER_PACKET(
                    pChannel->ccTermCaps.Cap.H245Aud_G711_ALAW64
                    );

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "outgoing G711A stream (%d milliseconds).\n",
                pChannel->Settings.Audio.dwMillisecondsPerPacket
                ));

            // open outgoing channel
            fOpened = H323OpenChannel(pChannel);
        }

    } else if (bSessionID == H245_SESSIONID_VIDEO) {

        // transfer capabilities from call object
        pChannel->ccTermCaps = pCall->ccRemoteVideoCaps;

        // check terminal capabilities for h263
        if (pChannel->ccTermCaps.ClientType == H245_CLIENT_VID_H263) {

            DWORD dwFinalMaxBitRate;
            DWORD dwStartUpBitRate;
            DWORD dwAudioBitRate;

            // complete stream description structure
            pChannel->Settings.MediaType = MEDIA_VIDEO;
            pChannel->Settings.dwPayloadType = H263_RTP_PAYLOAD_TYPE;
            pChannel->Settings.dwDynamicType = H263_RTP_PAYLOAD_TYPE;
            pChannel->Settings.Video.bCIF = FALSE;

            if (pCall->ccRemoteAudioCaps.ClientType == H245_CLIENT_AUD_G723)
            {
                DWORD dwFramesPerPacket = 
                    pCall->ccRemoteAudioCaps.Cap.H245Aud_G723.maxAl_sduAudioFrames;

                 dwAudioBitRate = 
                     (TOTAL_HEADER_SIZE + dwFramesPerPacket * G723_BYTES_PER_FRAME)
                     * CHAR_BIT * 1000 / (dwFramesPerPacket * G723_MILLISECONDS_PER_FRAME);
                 
            }
            else
            {
                // Since for other  types of audio encoding the
                // call to H323ComputeVideoChannelBitRates will have
                // no effect, we set the audio bit rate to a dummy
                // value.

                dwAudioBitRate = H323_MINIMUM_AUDIO_BANDWIDTH;
            }

            // ajust three percent to make QOS happy.
            dwAudioBitRate = dwAudioBitRate * 103 / 100;

            H323ComputeVideoChannelBitRates(
                pChannel->ccTermCaps.Cap.H245Vid_H263.maxBitRate,
                dwAudioBitRate / 100 + 1,
                &dwFinalMaxBitRate,
                &dwStartUpBitRate
                );

            pChannel->ccTermCaps.Cap.H245Vid_H263.maxBitRate = dwFinalMaxBitRate;
            pChannel->Settings.Video.dwMaxBitRate = dwFinalMaxBitRate * 100;
            pChannel->Settings.Video.dwStartUpBitRate = dwStartUpBitRate;

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "outgoing H263 stream (%d bps).\n",
                pChannel->Settings.Video.dwMaxBitRate
                ));

            // open outgoing channel
            fOpened = H323OpenChannel(pChannel);

        } else if (pChannel->ccTermCaps.ClientType == H245_CLIENT_VID_H261) {

            DWORD dwFinalMaxBitRate;
            DWORD dwStartUpBitRate;
            DWORD dwAudioBitRate;

            // complete stream description structure
            pChannel->Settings.MediaType = MEDIA_VIDEO;
            pChannel->Settings.dwPayloadType = H261_RTP_PAYLOAD_TYPE;
            pChannel->Settings.dwDynamicType = H261_RTP_PAYLOAD_TYPE;
            pChannel->Settings.Video.bCIF = FALSE;

            if (pCall->ccRemoteAudioCaps.ClientType == H245_CLIENT_AUD_G723)
            {
                DWORD dwFramesPerPacket = 
                    pCall->ccRemoteAudioCaps.Cap.H245Aud_G723.maxAl_sduAudioFrames;

                 dwAudioBitRate = 
                     (TOTAL_HEADER_SIZE + dwFramesPerPacket * G723_BYTES_PER_FRAME)
                     * CHAR_BIT * 1000 / (dwFramesPerPacket * G723_MILLISECONDS_PER_FRAME);
            }
            else
            {
                // Since for other  types of audio encoding the
                // call to H323ComputeVideoChannelBitRates will have
                // no effect, we set the audio bit rate to a dummy
                // value.

                dwAudioBitRate = H323_MINIMUM_AUDIO_BANDWIDTH;
            }

            // ajust three percent to make QOS happy.
            dwAudioBitRate = dwAudioBitRate * 103 / 100;

            H323ComputeVideoChannelBitRates(
                (DWORD)pChannel->ccTermCaps.Cap.H245Vid_H261.maxBitRate,
                dwAudioBitRate / 100 + 1,
                &dwFinalMaxBitRate,
                &dwStartUpBitRate
                );

            pChannel->ccTermCaps.Cap.H245Vid_H261.maxBitRate = (WORD)dwFinalMaxBitRate;
            pChannel->Settings.Video.dwMaxBitRate = dwFinalMaxBitRate * 100;
            pChannel->Settings.Video.dwStartUpBitRate = dwStartUpBitRate;

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "outgoing H261 stream (%d bps).\n",
                pChannel->Settings.Video.dwMaxBitRate
                ));

            // open outgoing channel
            fOpened = H323OpenChannel(pChannel);
        }
    }

    // validate
    if (!fOpened) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "could not open channel hmChannel=0x%08lx.\n",
            pRequest->hmChannel
            ));

        // close the requested channel
        H323SendCloseChannelCommand(
            pCall,
            pRequest->hmChannel,
            ERROR_GEN_FAILURE
            );

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}


BOOL
H323ProcessAcceptChannelResponse(
    PH323_CALL pCall,
    PH323MSG_ACCEPT_CHANNEL_RESPONSE pResponse
    )
        
/*++

Routine Description:

    Process command from MSP.

Arguments:

    pCall - Specifies a pointer to the call object to process.

    pResponse - Specifies a pointer to the command block.

Return Values:

    Returns true if successful.
    
--*/

{
    PH323_CHANNEL pChannel = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "accept channel response from MSP. hmChannel=0x%08lx. htChannel=0x%08lx.\n",
        pResponse->hmChannel,
        pResponse->htChannel
        ));

    // retrieve channel given handle
    if (!H323LookupChannelByHandle(
            &pChannel,
            pCall->pChannelTable,
            (CC_HCHANNEL)PtrToUlong(pResponse->htChannel))) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not accept unknown htChannel 0x%08lx",
            pResponse->htChannel
            ));

        // done
        return TRUE;
    }

    // accept channel
    CC_AcceptChannel(
        pChannel->hccChannel,           // hChannel
        &pChannel->ccLocalRTPAddr,      // pRTPAddr
        &pChannel->ccLocalRTCPAddr,     // pRTCPAddr
        0                               // dwChannelBitRate
        );

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx accepted htChannel 0x%08lx.\n",
        pCall,
        pChannel->hccChannel
        ));

    // change state to opened
    pChannel->nState = H323_CHANNELSTATE_OPENED;

    // update media modes
    H323UpdateMediaModes(pCall);

    // success
    return TRUE;
}


BOOL
H323ProcessVideoFastUpdatePictureCommand(
    PH323_CALL pCall,
    PH323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND pCommand
    )
        
/*++

Routine Description:

    Process I-frame request command from MSP.

Arguments:

    pCall - Specifies a pointer to the call object to process.

    pCommand - Specifies a pointer to the command block.

Return Values:

    Returns TRUE if successful.
    
--*/

{
    PH323_CHANNEL pChannel = NULL;
    MiscellaneousCommand   h245miscellaneousCommand;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "MSP->TSP I-frame request. hChannel=0x%08lx.\n",
        pCommand->hChannel
        ));

    h245miscellaneousCommand.type.choice = videoFastUpdatePicture_chosen;

    // retrieve channel given handle
    if (!H323LookupChannelByHandle(
            &pChannel,
            pCall->pChannelTable,
            (CC_HCHANNEL)PtrToUlong(pCommand->hChannel))) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "Could not process MSP->TSP I-frame request. Unknown hChannel 0x%08lx.\n",
            pCommand->hChannel
            ));

        // done
        return TRUE;
    }

    // send H245 Miscellaneous Command to the remote entity
    CC_H245MiscellaneousCommand(
        pCall->hccCall,                    // hCall
        pChannel->hccChannel,           // hChannel
        &h245miscellaneousCommand        // Command
        );

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "MSP->TSP I-frame request processed. call 0x%08lx -- hccChannel 0x%08lx. \n",
        pCall,
        pChannel->hccChannel
        ));

    // success
    return TRUE;
}


BOOL
H323ProcessFlowControlCommand(
    PH323_CALL pCall,
    PH323MSG_FLOW_CONTROL_COMMAND pCommand
    )
        
/*++

Routine Description:

    Process flow control command from MSP.

Arguments:

    pCall - Specifies a pointer to the call object to process.

    pCommand - Specifies a pointer to the command block.

Return Values:

    Returns true if successful.
    
--*/

{
    PH323_CHANNEL pChannel = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "MSP->TSP Flow control cmd. hChannel=0x%08lx. Req. rate=%08d.\n",
        pCommand->hChannel,
        pCommand->dwBitRate
        ));

    // retrieve channel given handle
    if (!H323LookupChannelByHandle(
            &pChannel,
            pCall->pChannelTable,
            (CC_HCHANNEL)PtrToUlong(pCommand->hChannel))) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "Could not process MSP->TSP flow control cmd. Unknown hChannel 0x%08lx",
            pCommand->hChannel
            ));

        // done
        return TRUE;
    }

    // send flow control command to the remote entity
    CC_FlowControl(
        pChannel->hccChannel,           // hChannel
        pCommand->dwBitRate                // requested bit rate, bps
        );

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx -- hccChannel 0x%08lx, MSP->TSP flow control cmd processed.\n",
        pCall,
        pChannel->hccChannel
        ));

    // success
    return TRUE;
}


BOOL
H323ProcessQoSEventIndication(
    PH323_CALL pCall,
    PH323MSG_QOS_EVENT pCommand
    )
        
/*++

Routine Description:

    Process QoS event indication from MSP.

Arguments:

    pCall - Specifies a pointer to the call object to process.

    pCommand - Specifies a pointer to the command block.

Return Values:

    Returns true if successful.
    
--*/

{
    PH323_CHANNEL pChannel = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "MSP->TSP QoS event. htChannel=0x%08lx. dwEvent=%08d.\n",
        pCommand->htChannel,
        pCommand->dwEvent
        ));

    // retrieve channel given handle
    if (!H323LookupChannelByHandle(
            &pChannel,
            pCall->pChannelTable,
            (CC_HCHANNEL)PtrToUlong(pCommand->htChannel))) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "Could not process MSP->TSP QoS event. Unknown htChannel 0x%08lx",
            pCommand->htChannel
            ));

        // done
        return TRUE;
    }

    // report qos event
    (*g_pfnLineEventProc)(
        pCall->pLine->htLine,
        pCall->htCall,
        LINE_QOSINFO,
        pCommand->dwEvent,
        (pChannel->Settings.MediaType == MEDIA_AUDIO)
            ? LINEMEDIAMODE_INTERACTIVEVOICE
            : LINEMEDIAMODE_VIDEO,
        0
        );

    // success
    return TRUE;
}


BOOL
H323ProcessCloseChannelCommand(
    PH323_CALL pCall,
    PH323MSG_CLOSE_CHANNEL_COMMAND pCommand
    )
        
/*++

Routine Description:

    Process command from MSP.

Arguments:

    pCall - Specifies a pointer to the call object to process.

    pCommand - Specifies a pointer to the command block.

Return Values:

    Returns true if successful.
    
--*/

{
    PH323_CHANNEL pChannel = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "close channel command from MSP. htChannel=0x%08lx.\n",
        pCommand->hChannel
        ));


    // retrieve channel given handle
    if (!H323LookupChannelByHandle(
            &pChannel,
            pCall->pChannelTable,
            (CC_HCHANNEL)PtrToUlong(pCommand->hChannel))) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not close unknown htChannel 0x%08lx",
            pCommand->hChannel
            ));

        // done
        return TRUE;
    }

    H323DBG((
        DEBUG_LEVEL_WARNING,
        "closing htChannel 0x%08lx.\n",
        pCommand->hChannel
        ));

    // close channel
    H323CloseChannel(pChannel);

    // release channel resources
    H323FreeChannelFromTable(pChannel,pCall->pChannelTable);

    // success
    return TRUE;
}


VOID
H323ProcessPlaceCallMessage(
    HDRVCALL hdCall
    )
        
/*++

Routine Description:

    Processes async place call messages.

Arguments:

    hdCall - Handle to call to be placed.

Return Values:

    None.
      
--*/

{
    PH323_CALL pCall = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "place call message received (hdCall=0x%08lx).\n",
        PtrToUlong(hdCall)
        ));
    
    // retrieve call pointer from handle
    if (H323GetCallAndLock(&pCall, hdCall)) {

        // place outgoing call
        if (!H323PlaceCall(pCall)) {

            // drop call using disconnect mode
            H323DropCall(pCall, LINEDISCONNECTMODE_TEMPFAILURE);
        }

        // unlock line device
        H323UnlockLine(pCall->pLine);

    } else {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid handle in place call message.\n"
            ));
    }
}


VOID
H323ProcessAcceptCallMessage(
    HDRVCALL hdCall
    )
        
/*++

Routine Description:

    Processes async accept call messages.

Arguments:

    hdCall - Handle to call to be placed.

Return Values:

    None.
      
--*/

{
    PH323_CALL pCall = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "accept call message received (hdCall=0x%08lx).\n",
        PtrToUlong(hdCall)
        ));
    
    // retrieve call pointer from handle
    if (H323GetCallAndLock(&pCall, hdCall)) {

        // place outgoing call
        if (!H323AcceptCall(pCall)) {

            // drop call using disconnect mode
            H323DropCall(pCall, LINEDISCONNECTMODE_TEMPFAILURE);
        }

        // unlock line device
        H323UnlockLine(pCall->pLine);

    } else {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid handle in accept call message.\n"
            ));
    }
}


VOID
H323ProcessDropCallMessage(
    HDRVCALL hdCall,
    DWORD    dwDisconnectMode
    )
        
/*++

Routine Description:

    Processes async drop call messages.

Arguments:

    hdCall - Handle to call to be hung up.

    dwDisconnectMode - Status to be placed in disconnected message.

Return Values:

    None.
      
--*/

{
    PH323_CALL pCall = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "drop call message received (hdCall=0x%08lx).\n",
        PtrToUlong(hdCall)
        ));
    
    // retrieve call pointer from handle
    if (H323GetCallAndLock(&pCall, hdCall)) {

        // drop call using disconnect code
        H323DropCall(pCall, dwDisconnectMode);

        // unlock line device
        H323UnlockLine(pCall->pLine);

    } else {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid handle in place call message.\n"
            ));
    }
}


VOID
H323ProcessCloseCallMessage(
    HDRVCALL hdCall
    )
        
/*++

Routine Description:

    Processes async close call messages.

Arguments:

    hdCall - Handle to call to be closed.

Return Values:

    None.
      
--*/

{
    PH323_CALL pCall = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "close call message received (hdCall=0x%08lx).\n",
        PtrToUlong(hdCall)
        ));
    
    // retrieve call pointer from handle
    if (H323GetCallAndLock(&pCall, hdCall)) {

        // close call
        H323CloseCall(pCall);

        // unlock line device
        H323UnlockLine(pCall->pLine);

    } else {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid handle in place call message.\n"
            ));
    }
}


VOID
H323ProcessCallListenMessage(
    HDRVLINE hdLine
    )
        
/*++

Routine Description:

    Processes async call listen messages.

Arguments:

    hdLine - Line to be placed into listening state.

Return Values:

    None.
      
--*/

{   
    PH323_LINE pLine = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "call listen message received (hdLine=0x%08lx).\n",
        PtrToUlong(hdLine)
        ));
        
    // retrieve line pointer from handle
    if (H323GetLineAndLock(&pLine, hdLine)) {

        // start listening for calls
        if (!H323CallListen(pLine)) {
    
            // change state to opened
            pLine->nState = H323_LINESTATE_OPENED;        
        }

        // unlock line device
        H323UnlockLine(pLine);

    } else {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid handle in call listen message.\n"
            ));
    }
}


DWORD
WINAPI
H323CallbackThread(
    LPVOID pParam
    )
        
/*++

Routine Description:

    Worker thread to handle async operations.

Arguments:

    pParam - Pointer to opaque thread parameter (unused).

Return Values:

    Win32 error codes.
      
--*/

{
    MSG msg;
    DWORD dwStatus;

    // associate event with key
    H323ListenForRegistryChanges(
        g_WaitableObjects[WAIT_OBJECT_REGISTRY_CHANGE]
        );

    // loop...
    for (;;) {

        // wait for message or termination
        dwStatus = MsgWaitForMultipleObjectsEx(
                        NUM_WAITABLE_OBJECTS, 
                        g_WaitableObjects, 
                        INFINITE, 
                        QS_ALLINPUT,
                        MWMO_ALERTABLE
                        );

        // see if new message has arrived
        if (dwStatus == WAIT_OBJECT_INCOMING_MESSAGE) {

            // retrieve next item in thread message queue
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                
                // handle service provider messages
                if (H323IsPlaceCallMessage(&msg)) {

                    // process place call message
                    H323ProcessPlaceCallMessage((HDRVCALL)msg.wParam);

                } else if (H323IsAcceptCallMessage(&msg)) {

                    // process accept call message
                    H323ProcessAcceptCallMessage((HDRVCALL)msg.wParam);

                } else if (H323IsDropCallMessage(&msg)) {

                    // process drop call message
                    H323ProcessDropCallMessage((HDRVCALL)msg.wParam,(DWORD)msg.lParam);

                } else if (H323IsCloseCallMessage(&msg)) {

                    // process close call message
                    H323ProcessCloseCallMessage((HDRVCALL)msg.wParam);

                } else if (H323IsCallListenMessage(&msg)) {

                    // process call listen message
                    H323ProcessCallListenMessage((HDRVLINE)msg.wParam);

                } else {

                    // translate message
                    TranslateMessage(&msg);

                    // dispatch message
                    DispatchMessage(&msg);
                }
            } 

        } else if (dwStatus == WAIT_OBJECT_REGISTRY_CHANGE) {

            // lock provider
            H323LockProvider();

            // refresh registry settings
            H323GetConfigFromRegistry();

            // associate event with registry key
            H323ListenForRegistryChanges(g_WaitableObjects[WAIT_OBJECT_REGISTRY_CHANGE]);

            // unlock provider
            H323UnlockProvider();

        } else if (dwStatus == WAIT_IO_COMPLETION) {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "callback thread %x io completion.\n",
                g_dwCallbackThreadID
                ));

        } else if (dwStatus == WAIT_OBJECT_TERMINATE_EVENT) {

            H323DBG((   
                DEBUG_LEVEL_TRACE,
                "callback thread %x terminating on command.\n",
                g_dwCallbackThreadID
                ));

            break; // bail...

        } else {

            H323DBG((   
                DEBUG_LEVEL_TRACE,
                "callback thread %x terminating (dwStatus=0x%08lx).\n",
                g_dwCallbackThreadID,
                dwStatus
                ));

            break; // bail...
        }
    } 

    // stop listening for registry changes
    H323StopListeningForRegistryChanges();

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "callback thread %x exiting.\n",
        g_dwCallbackThreadID
        ));

    // success
    return NOERROR;
}


DWORD
H323RejectReasonToDisconnectMode(
    BYTE bRejectReason
    )
        
/*++

Routine Description:

    Converts connect reject reason to tapi disconnect mode.

Arguments:

    bRejectReason - Specifies reason peer rejected call.

Return Values:

    Returns disconnect mode corresponding to reject reason.
      
--*/

{
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "Reject Reason: %s.\n",
        CCRejectReasonToString((DWORD)bRejectReason)
        ));

    // determine reject reason
    switch (bRejectReason) {

    case CC_REJECT_NORMAL_CALL_CLEARING:

        // call was terminated normally
        return LINEDISCONNECTMODE_NORMAL;

    case CC_REJECT_UNREACHABLE_DESTINATION:

        //  remote user could not be reached
        return LINEDISCONNECTMODE_UNREACHABLE;

    case CC_REJECT_DESTINATION_REJECTION:

        // remote user has rejected the call
        return LINEDISCONNECTMODE_REJECT;

    case CC_REJECT_USER_BUSY:

        // remote user's station is busy
        return LINEDISCONNECTMODE_BUSY;

    case CC_REJECT_NO_ANSWER:

        // remote user's station does not answer
        return LINEDISCONNECTMODE_NOANSWER;

    case CC_REJECT_BAD_FORMAT_ADDRESS:

        // destination address in invalid
        return LINEDISCONNECTMODE_BADADDRESS;

    default:
        
        // reason for the disconnect is unavailable
        return LINEDISCONNECTMODE_UNAVAIL;
    }
}


BOOL
H323GetTermCapById(
    H245_CAPID_T    CapId,
    PCC_TERMCAPLIST pTermCapList,
    PCC_TERMCAP *   ppTermCap
    )

/*++

Routine Description:

    Retrieve pointer to termcap from list via id.

Arguments:

    CapId - Id of termcap of interest.

    pTermCapList - Pointer to termcap list.

    ppTermCap - Pointer to place to copy termcap pointer.

Return Values:

    Returns TRUE if successful.
      
--*/

{
    WORD        wIndex;
    PCC_TERMCAP pTermCap;

    // walk caps
    for (wIndex = 0; wIndex < pTermCapList->wLength; wIndex++) {

        // compare id with the next item in the list
        if (pTermCapList->pTermCapArray[wIndex]->CapId == CapId) {

            // return pointer
            *ppTermCap = pTermCapList->pTermCapArray[wIndex];

            // success
            return TRUE;
        }
    }

    // failure
    return FALSE;
}


BOOL
H323GetTermCapByType(
    H245_DATA_T     DataType,
    H245_CLIENT_T   ClientType,
    PCC_TERMCAPLIST pTermCapList,
    PCC_TERMCAP *   ppTermCap
    )

/*++

Routine Description:

    Retrieve pointer to termcap from list via id.

Arguments:

    DataType - Type of capability.

    ClientType - Type of media-specific cabability.

    pTermCapList - Pointer to termcap list.

    ppTermCap - Pointer to place to copy termcap pointer.

Return Values:

    Returns TRUE if successful.
      
--*/

{
    WORD        wIndex;
    PCC_TERMCAP pTermCap;

    // walk caps
    for (wIndex = 0; wIndex < pTermCapList->wLength; wIndex++) {

        // compare id with the next item in the list
        if ((pTermCapList->pTermCapArray[wIndex]->DataType == DataType) &&
            (pTermCapList->pTermCapArray[wIndex]->ClientType == ClientType)) {

            // return pointer
            *ppTermCap = pTermCapList->pTermCapArray[wIndex];

            // success
            return TRUE;
        }
    }

    // failure
    return FALSE;
}


BOOL
H323SavePreferredTermCap(
    PH323_CALL  pCall,
    PCC_TERMCAP pLocalCap,
    PCC_TERMCAP pRemoteCap
    )

/*++

Routine Description:

    Save remote cap adjusted for outgoing settings.

Arguments:

    pCall - Pointer to call object.

    pLocalCap - Pointer to local capability.

    pRemoteCap - Pointer to termcap to save.

Return Values:

    Returns TRUE if both audio and video termcaps resolved.
      
--*/

{
    PCC_TERMCAP pPreferredCap;
    WORD wMillisecondsPerPacket;

    // retrieve pointer to stored termcap preferences
    pPreferredCap = H323IsValidAudioClientType(pRemoteCap->ClientType)
                        ? &pCall->ccRemoteAudioCaps
                        : &pCall->ccRemoteVideoCaps
                        ;

    // make sure we have not already saved preferred type
    if (H323IsValidClientType(pPreferredCap->ClientType)) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "call 0x%08lx ignoring remote cap %d\n",
            pCall,
            pRemoteCap->CapId
            ));

        // failure
        return FALSE;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx saving remote cap %d\n",
        pCall,
        pRemoteCap->CapId
        ));

    // modify preferred caps
    *pPreferredCap = *pLocalCap;

    // reverse capability direction
    pPreferredCap->Dir = H245_CAPDIR_LCLTX;

    // determine client type
    switch (pPreferredCap->ClientType) {

    case H245_CLIENT_AUD_G723:

        // determine packet size
        wMillisecondsPerPacket =
            H323IsSlowLink(pCall->dwLinkSpeed)
                ? G723_SLOWLNK_MILLISECONDS_PER_PACKET
                : G723_DEFAULT_MILLISECONDS_PER_PACKET
                ;

        // adjust default parameters for link speed
        pPreferredCap->Cap.H245Aud_G723.maxAl_sduAudioFrames =
            G723_FRAMES_PER_PACKET(wMillisecondsPerPacket)
            ;

        // see if remote maximum less than default
        if (pRemoteCap->Cap.H245Aud_G723.maxAl_sduAudioFrames <
            pPreferredCap->Cap.H245Aud_G723.maxAl_sduAudioFrames) {

            // use remote maximum instead of default
            pPreferredCap->Cap.H245Aud_G723.maxAl_sduAudioFrames =
                pRemoteCap->Cap.H245Aud_G723.maxAl_sduAudioFrames
                ;
        }

        break;

    case H245_CLIENT_AUD_G711_ULAW64:

        // store default parameters
        pPreferredCap->Cap.H245Aud_G711_ULAW64 =
            G711_FRAMES_PER_PACKET(
                G711_DEFAULT_MILLISECONDS_PER_PACKET
                );

        // see if remote maximum less than default
        if (pRemoteCap->Cap.H245Aud_G711_ULAW64 <
            pPreferredCap->Cap.H245Aud_G711_ULAW64) {

            // use remote maximum instead of default
            pPreferredCap->Cap.H245Aud_G711_ULAW64 =
                pRemoteCap->Cap.H245Aud_G711_ULAW64
                ;
        }

        break;

    case H245_CLIENT_AUD_G711_ALAW64:

        // store default parameters
        pPreferredCap->Cap.H245Aud_G711_ALAW64 =
            G711_FRAMES_PER_PACKET(
                G711_DEFAULT_MILLISECONDS_PER_PACKET
                );

        // see if remote maximum less than default
        if (pRemoteCap->Cap.H245Aud_G711_ALAW64 <
            pPreferredCap->Cap.H245Aud_G711_ALAW64) {

            // use remote maximum instead of default
            pPreferredCap->Cap.H245Aud_G711_ALAW64 =
                pRemoteCap->Cap.H245Aud_G711_ALAW64
                ;
        }

        break;

    case H245_CLIENT_VID_H263:

        // see if remote maximum less than local
        if (pRemoteCap->Cap.H245Vid_H263.maxBitRate <
            pPreferredCap->Cap.H245Vid_H263.maxBitRate) {

            // use remote maximum instead of local
            pPreferredCap->Cap.H245Vid_H263.maxBitRate =
                pRemoteCap->Cap.H245Vid_H263.maxBitRate
                ;
        }

        break;

    case H245_CLIENT_VID_H261:

        // see if remote maximum less than local
        if (pRemoteCap->Cap.H245Vid_H261.maxBitRate <
            pPreferredCap->Cap.H245Vid_H261.maxBitRate) {

            // use remote maximum instead of local
            pPreferredCap->Cap.H245Vid_H261.maxBitRate =
                pRemoteCap->Cap.H245Vid_H261.maxBitRate
                ;
        }

        break;
    }

    // return success if we have resolved both audio and video caps
    return (H323IsValidClientType(pCall->ccRemoteAudioCaps.ClientType) &&
            H323IsValidClientType(pCall->ccRemoteVideoCaps.ClientType));
}


VOID
H323GetPreferedTransmitTypes(
    PCC_TERMCAPDESCRIPTORS pTermCapDescriptors,
    H245_CLIENT_T *pPreferredAudioType,
    H245_CLIENT_T *pPreferredVideoType
    )

/*++

Routine Description:

    Find the preferred audio and video format in the local terminal capability
    descriptors array if they exist.

Arguments:

    pTermCapDescriptors - pointer to the local terminal capability descriptor.
    
    pPreferredAudioType - return the preferred audio type.

    pPreferredVideoType - return the preferred video type.

Return Values:

    NONE
      
--*/
{
    WORD wDescIndex;
    WORD wSimCapIndex;
    WORD wAltCapIndex;

    // process descriptors
    for (wDescIndex = 0; wDescIndex < pTermCapDescriptors->wLength; wDescIndex++) 
    {
        H245_TOTCAPDESC_T * pTotCapDesc;

        // retrieve pointer to capability structure
        pTotCapDesc = pTermCapDescriptors->pTermCapDescriptorArray[wDescIndex];

        // process simultaneous caps
        for (wSimCapIndex = 0; wSimCapIndex < pTotCapDesc->CapDesc.Length; wSimCapIndex++) 
        {
            H245_SIMCAP_T * pSimCap;

            // retrieve pointer to simulateous cap
            pSimCap = &pTotCapDesc->CapDesc.SimCapArray[wSimCapIndex];

            if (pSimCap->Length > 0)
            {
                // the first one in the altcaps array is the preferred one.
                switch (pSimCap->AltCaps[0])
                {
                case H245_TERMCAPID_G723:
                    *pPreferredAudioType = H245_CLIENT_AUD_G723;
                    break;
                    
                case H245_TERMCAPID_H263:
                    *pPreferredVideoType = H245_CLIENT_VID_H263;
                    break;

                case H245_TERMCAPID_G711_ULAW64:
                    *pPreferredAudioType = H245_CLIENT_AUD_G711_ULAW64;
                    break;

                case H245_TERMCAPID_G711_ALAW64:
                    *pPreferredAudioType = H245_CLIENT_AUD_G711_ALAW64;
                    break;

                case H245_TERMCAPID_H261:
                    *pPreferredVideoType = H245_CLIENT_VID_H261;
                    break;
                }
            }
        }
    }
}


BOOL
H323ProcessRemoteTermCaps(
    PH323_CALL             pCall,
    PCC_TERMCAPLIST        pRemoteTermCapList,
    PCC_TERMCAPDESCRIPTORS pRemoteTermCapDescriptors
    )

/*++

Routine Description:

    Process remote capabilities and establish outgoing termcaps.

Arguments:

    pCall - Pointer to call object.

    pRemoteTermCapList - Pointer to termcap list.

    pRemoteTermCapDescriptors - Pointer to descriptor list.

Return Values:

    Returns TRUE if successful.
      
--*/

{
    WORD wDescIndex;
    WORD wSimCapIndex;
    WORD wAltCapIndex;
    PCC_TERMCAP pLocalCap = NULL;
    PCC_TERMCAP pRemoteCap = NULL;
    CC_TERMCAPLIST LocalTermCapList;
    CC_TERMCAPDESCRIPTORS LocalTermCapDescriptors;
    CC_TERMCAP SavedAudioCap;
    CC_TERMCAP SavedVideoCap;
    H245_CLIENT_T PreferredAudioType = H245_CLIENT_DONTCARE;
    H245_CLIENT_T PreferredVideoType = H245_CLIENT_DONTCARE;

    // initialize cached termcaps
    memset(&SavedAudioCap,0,sizeof(CC_TERMCAP));
    memset(&SavedVideoCap,0,sizeof(CC_TERMCAP));

    // retrieve local caps
    H323GetTermCapList(pCall,&LocalTermCapList,&LocalTermCapDescriptors);

    H323GetPreferedTransmitTypes(
        &LocalTermCapDescriptors, 
        &PreferredAudioType,
        &PreferredVideoType
        );

    // look for our preferred audio format.
    if (PreferredAudioType != H245_CLIENT_DONTCARE)
    {
        // look for match
        if (H323GetTermCapByType(H245_DATA_AUDIO, PreferredAudioType, 
                    pRemoteTermCapList, &pRemoteCap )
          && H323GetTermCapByType(H245_DATA_AUDIO, PreferredAudioType, 
                    &LocalTermCapList, &pLocalCap )) 
        {
            // adjust termcaps and save
            if (H323SavePreferredTermCap(
                    pCall,
                    pLocalCap,
                    pRemoteCap
                    )) 
            {

                //
                // The function above will only return
                // true when both audio and video caps
                // have been successfully resolved.
                //

                return TRUE;
            }
        }
    }

    // look for our preferred video format.
    if (PreferredVideoType != H245_CLIENT_DONTCARE)
    {
        // look for match
        if (H323GetTermCapByType(H245_DATA_VIDEO, PreferredVideoType, 
                    pRemoteTermCapList, &pRemoteCap )
          && H323GetTermCapByType(H245_DATA_VIDEO, PreferredVideoType, 
                    &LocalTermCapList, &pLocalCap )) 
        {
            // adjust termcaps and save
            if (H323SavePreferredTermCap(
                    pCall,
                    pLocalCap,
                    pRemoteCap
                    )) 
            {

                //
                // The function above will only return
                // true when both audio and video caps
                // have been successfully resolved.
                //

                return TRUE;
            }
        }
    }

    // process descriptors
    for (wDescIndex = 0;
         wDescIndex < pRemoteTermCapDescriptors->wLength;
         wDescIndex++) {

        H245_TOTCAPDESC_T * pTotCapDesc;

        // retrieve pointer to capability structure
        pTotCapDesc = pRemoteTermCapDescriptors->pTermCapDescriptorArray[wDescIndex];

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "call 0x%08lx processing CapDescId %d\n",
            pCall,
            pTotCapDesc->CapDescId
            ));

        // process simultaneous caps
        for (wSimCapIndex = 0;
             wSimCapIndex < pTotCapDesc->CapDesc.Length;
             wSimCapIndex++) {

            H245_SIMCAP_T * pSimCap;

            // retrieve pointer to simulateous cap
            pSimCap = &pTotCapDesc->CapDesc.SimCapArray[wSimCapIndex];

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "call 0x%08lx processing SimCap %d\n",
                pCall,
                wSimCapIndex + 1
                ));

            // process alternative caps
            for (wAltCapIndex = 0;
                 wAltCapIndex < pSimCap->Length;
                 wAltCapIndex++) {

                H245_CAPID_T CapId;

                // re-initialize
                pRemoteCap = NULL;

                // retrieve alternative capid
                CapId = pSimCap->AltCaps[wAltCapIndex];

                H323DBG((
                    DEBUG_LEVEL_VERBOSE,
                    "call 0x%08lx processing AltCapId %d\n",
                    pCall,
                    CapId
                    ));

                // lookup termcap from id
                if (H323GetTermCapById(
                        CapId,
                        pRemoteTermCapList,
                        &pRemoteCap
                        )) {

                    H323DBG((
                        DEBUG_LEVEL_VERBOSE,
                        "call 0x%08lx examining remote cap %d:\n\t%s\n\t%s\n\t%s\n",
                        pCall,
                        pRemoteCap->CapId,
                        H323DirToString(pRemoteCap->Dir),
                        H323DataTypeToString(pRemoteCap->DataType),
                        H323ClientTypeToString(pRemoteCap->ClientType)
                        ));

                    // validate remote termcap and check priority
                    if (H323IsReceiveCapability(pRemoteCap->Dir)) {

                        // re-initialize
                        pLocalCap = NULL;

                        // look for match
                        if (H323GetTermCapByType(
                                pRemoteCap->DataType,
                                pRemoteCap->ClientType,
                                &LocalTermCapList,
                                &pLocalCap
                                )) {

                            // adjust termcaps and save
                            if (H323SavePreferredTermCap(
                                    pCall,
                                    pLocalCap,
                                    pRemoteCap
                                    )) {

                                //
                                // The function above will only return
                                // true when both audio and video caps
                                // have been successfully resolved.
                                //

                                return TRUE;
                            }
                        }
                    }
                }
            }
        }

        // see if we discovered any audio-only caps we would like to save
        if (H323IsValidClientType(pCall->ccRemoteAudioCaps.ClientType) &&
           !H323IsValidClientType(SavedAudioCap.ClientType)) {

            // save discovered audio-only cap
            SavedAudioCap = pCall->ccRemoteAudioCaps;

            // reset video-only cap (prefer audio-only)
            memset(&SavedVideoCap,0,sizeof(CC_TERMCAP));
        }

        // see if we discovered any video-only caps we would like to save
        if (H323IsValidClientType(pCall->ccRemoteVideoCaps.ClientType) &&
           !H323IsValidClientType(SavedAudioCap.ClientType)) {

            // save video-only cap (only if no saved audio-only cap)
            SavedVideoCap = pCall->ccRemoteVideoCaps;
        }

        // reset capability stored in call for next iteration
        memset(&pCall->ccRemoteAudioCaps,0,sizeof(CC_TERMCAP));
        memset(&pCall->ccRemoteVideoCaps,0,sizeof(CC_TERMCAP));
    }

    // see if we saved any audio-only capabilities
    if (H323IsValidClientType(SavedAudioCap.ClientType)) {

        // restore saved audio-only capabilities
        pCall->ccRemoteAudioCaps = SavedAudioCap;

        // success
        return TRUE;
    }

    // see if we saved any video-only capabilities
    if (H323IsValidClientType(SavedVideoCap.ClientType)) {

        // restore saved video-only capabilities
        pCall->ccRemoteVideoCaps = SavedVideoCap;

        // success
        return TRUE;
    }

    // failure
    return FALSE;
}


HRESULT
H323ConnectCallback(
    PH323_CALL                  pCall,
    HRESULT                     hrConf,
    PCC_CONNECT_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Callback for connect indications.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    DWORD dwDisconnectMode;
    PH323_CHANNEL pChannel = NULL;
    BOOL  bRemoteVideoSupported;
    DWORD dwRemoteVideoBitRate;
    WORD  wRemoteMaxAl_sduAudioFrames;

    // validate status
    if (hrConf != CC_OK) {    

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error %s (0x%08lx) connecting call 0x%08lx.\n",
            H323StatusToString(hrConf), hrConf,
            pCall
            ));    

        // see if we timed out
        if (hrConf == MAKE_WINSOCK_ERROR(WSAETIMEDOUT)) {

            // if so, report it as an unreachable destination
            dwDisconnectMode = LINEDISCONNECTMODE_UNREACHABLE;

        } else if (hrConf == CC_PEER_REJECT) {

            // translate reject code into failure
            dwDisconnectMode = H323RejectReasonToDisconnectMode(
                                 pCallbackParams->bRejectReason
                                 );
        } else {

            // default to temp failure
            dwDisconnectMode = LINEDISCONNECTMODE_TEMPFAILURE;
        }

        // drop call using disconnect mode
        H323DropCall(pCall, dwDisconnectMode);

        // release line device
        H323UnlockLine(pCall->pLine);

        // processed
        return CC_OK; 
    }

    // send msp new call indication
    H323SendNewCallIndication(pCall);

    // process remote terminal capabilities
    if ((pCallbackParams->pTermCapList != NULL) &&
        (pCallbackParams->pTermCapDescriptors != NULL)) {

        // process capabilirties
        H323ProcessRemoteTermCaps(
            pCall,
            pCallbackParams->pTermCapList,
            pCallbackParams->pTermCapDescriptors
            );
    }

    // By this time remote capabilities have been discovered.
    // Thus, we can classify the call as a 'FastLink' call, if
    // both local and remote links are LAN connections; or as a
    // 'SlowLink' call otherwise.
    // Using this classification we then determine the length of
    // the interval of audio signal to be packed into one IP
    // packet.

    bRemoteVideoSupported = FALSE;

    // Determine remote side video bit rate, in case it
    // supports video in one of the recognizable formats
    switch (pCall->ccRemoteVideoCaps.ClientType)
    {

    case H245_CLIENT_VID_H263:

        dwRemoteVideoBitRate =
             pCall->ccRemoteVideoCaps.Cap.H245Vid_H263.maxBitRate;

        bRemoteVideoSupported = TRUE;

        break;

    case H245_CLIENT_VID_H261:

        dwRemoteVideoBitRate =
             pCall->ccRemoteVideoCaps.Cap.H245Vid_H261.maxBitRate;

        bRemoteVideoSupported = TRUE;

        break;

    default:

        // Remote side either does not support video, or
        // supports unrecognizable video format
        bRemoteVideoSupported = FALSE;

        break;
    }

    // If the remote end supports video in one of the recognizable
    // formats, then we can guess, based on the remote video bit rate
    // capability, whether it sits on a slow link or not.

    if (   bRemoteVideoSupported
        && H323IsSlowLink(dwRemoteVideoBitRate * 100)){

        // Remote end has slow link. Adjust the number of
        // milliseconds of audio signal per packet.
        // Note that if the local end has slow link, the
        // adjustment has already been made, but there is
        // no harm in resetting the number.

        if (pCall->ccRemoteAudioCaps.ClientType == H245_CLIENT_AUD_G723){

            // recalculate new setting
            wRemoteMaxAl_sduAudioFrames =
                G723_FRAMES_PER_PACKET(G723_SLOWLNK_MILLISECONDS_PER_PACKET);

            // see if new setting less than current
            if (wRemoteMaxAl_sduAudioFrames <
                pCall->ccRemoteAudioCaps.Cap.H245Aud_G723.maxAl_sduAudioFrames){

               // use new setting instead of current
               pCall->ccRemoteAudioCaps.Cap.H245Aud_G723.maxAl_sduAudioFrames =
                    wRemoteMaxAl_sduAudioFrames;
            }
        }
    }

    // see if user user information specified
    if ((pCallbackParams->pNonStandardData != NULL) &&
        H323IsValidU2U(pCallbackParams->pNonStandardData)) {

        // add user user info
        if (H323AddU2U(
                &pCall->IncomingU2U,
                pCallbackParams->pNonStandardData->sData.wOctetStringLength,
                pCallbackParams->pNonStandardData->sData.pOctetString
                )) {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "user user info available in CONNECT PDU.\n"
                ));

            // signal incoming
            (*g_pfnLineEventProc)(
                pCall->pLine->htLine,
                pCall->htCall,
                LINE_CALLINFO,
                LINECALLINFOSTATE_USERUSERINFO,
                0,
                0
                );

        } else {

            H323DBG((
                DEBUG_LEVEL_WARNING,
                "could not save incoming user user info.\n"
                ));
        }
    }

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "call 0x%08lx connected to %S.\n",
        pCall,
        pCallbackParams->pszPeerDisplay
        ));

    // no outgoing channels so connect
    H323ChangeCallState(pCall, LINECALLSTATE_CONNECTED, 0);

    // release line device
    H323UnlockLine(pCall->pLine);

    // processed
    return CC_OK;
}


HRESULT
H323RingingCallback(
    PH323_CALL pCall
    )
        
/*++

Routine Description:

    Callback for ringing indications.

Arguments:

    pCall - Pointer to call object.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08x ringing.\n",
        pCall
        ));

    // change state to ringback
    H323ChangeCallState(pCall, LINECALLSTATE_RINGBACK, 0);

    // release line device
    H323UnlockLine(pCall->pLine);

    // processed
    return CC_OK;
}


HRESULT
H323TerminationCallback(
    PH323_CALL                                 pCall,
    HRESULT                                    hrConf,
    PCC_CONFERENCE_TERMINATION_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Callback for termination indications.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    DWORD dwDisconnectMode;

    // validate status
    if (hrConf == CC_OK) {    

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "call 0x%08lx is being terminated.\n",
            pCall
            ));    

        // set disconnect mode to normal
        dwDisconnectMode = LINEDISCONNECTMODE_NORMAL;

    } else {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "call 0x%08lx could not be terminated.\n",
            pCall
            ));    

        // unable to determine disconnect mode 
        dwDisconnectMode = LINEDISCONNECTMODE_UNKNOWN;
    }

    // change call state to disconnected before dropping call
    H323ChangeCallState(pCall, LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

    // drop call using disconnect mode
    H323DropCall(pCall, dwDisconnectMode);

    // release line device
    H323UnlockLine(pCall->pLine);

    // processed
    return CC_OK; 
}


HRESULT
H323RxChannelRequestCallback(
    PH323_CALL                             pCall,
    HRESULT                                hrConf,
    PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Callback for channel request indications.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    HRESULT hr;
    DWORD dwIndex;
    DWORD dwRejectReason;
    CC_TERMCAPLIST TermCapList;
    CC_TERMCAPDESCRIPTORS TermCapDescriptors;
    PCC_TERMCAP pRemoteCap;
    PCC_TERMCAP pLocalCap = NULL;
    PH323_CHANNEL pChannel = NULL;
    PH323_CHANNEL pAssociatedChannel = NULL;
#if DBG
    DWORD dwIPAddr;
#endif

    // retrieve pointer to capabilities structure
    pRemoteCap = pCallbackParams->pChannelCapability;
        
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx incoming channel:\n\t%s\n\t%s\n\t%s\n",
        pCall,
        H323DirToString(pRemoteCap->Dir),
        H323DataTypeToString(pRemoteCap->DataType),
        H323ClientTypeToString(pRemoteCap->ClientType)
        ));

    // validate data and client type
    if (!H323IsValidDataType(pRemoteCap->DataType)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "channel rejected invalid type(s).\n"
            ));

        // initialize reject reason
        dwRejectReason = H245_REJ_TYPE_UNKNOWN;

        // bail...
        goto reject;
    }

    // see whether incoming channel is available
    if (H323IsVideoDataType(pRemoteCap->DataType) &&
       !H323IsVideoRequested(pCall)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "channel rejected video not enabled.\n"
            ));

        // initialize reject reason
        dwRejectReason = H245_REJ_TYPE_NOTAVAIL;

        // bail...
        goto reject;

    } else if (H323IsAudioDataType(pRemoteCap->DataType) &&
              !H323IsAudioRequested(pCall)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "channel rejected audio not enabled.\n"
            ));

        // initialize reject reason
        dwRejectReason = H245_REJ_TYPE_NOTAVAIL;

        // bail...
        goto reject;
    }

    // retrieve local caps
    H323GetTermCapList(pCall,&TermCapList,&TermCapDescriptors);

    // search term cap list for incoming cap
    for (dwIndex = 0; dwIndex < TermCapList.wLength; dwIndex++) {

        // see if local cap matchs incoming channel cap
        if (TermCapList.pTermCapArray[dwIndex]->ClientType ==
            pRemoteCap->ClientType) {

            // save pointer to termcap for later use
            pLocalCap = TermCapList.pTermCapArray[dwIndex];

            // done
            break;
        }
    }

    // validate termcap
    if (pLocalCap == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "channel rejected unsupported termcap.\n"
            ));

        // initialize reject reason
        dwRejectReason = H245_REJ_TYPE_NOTSUPPORT;

        // bail...
        goto reject;
    }

    // determine client type
    switch (pRemoteCap->ClientType) {

    case H245_CLIENT_VID_H263:

        // see if incoming bitrate too large
        if (pLocalCap->Cap.H245Vid_H263.maxBitRate <
            pRemoteCap->Cap.H245Vid_H263.maxBitRate) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "incoming H263 bitrate too large (%d bps).\n",
                pRemoteCap->Cap.H245Vid_H263.maxBitRate * 100
                ));

            // initialize reject reason
            dwRejectReason = H245_REJ_BANDWIDTH;

            // bail...
            goto reject;
        }

        break;

    case H245_CLIENT_VID_H261:

        // see if incoming bitrate too large
        if (pLocalCap->Cap.H245Vid_H261.maxBitRate <
            pRemoteCap->Cap.H245Vid_H261.maxBitRate) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "incoming H261 bitrate too large (%d bps).\n",
                pRemoteCap->Cap.H245Vid_H261.maxBitRate * 100
                ));

            // initialize reject reason
            dwRejectReason = H245_REJ_BANDWIDTH;

            // bail...
            goto reject;
        }

        break;
    }

    // look for existing session
    H323LookupChannelBySessionID(
        &pAssociatedChannel,
        pCall->pChannelTable,
        pCallbackParams->bSessionID
        );

    // allocate channel object 
    if (!H323AllocChannelFromTable(
            &pChannel,
            &pCall->pChannelTable,
            pCall)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "channel rejected could not allocate.\n"
            ));

        // initialize reject reason
        dwRejectReason = H245_REJ_TYPE_UNKNOWN;

        // bail...
        goto reject;
    }

    // transfer peer rtcp address from callback parameters
    // fail if the peer address was invalid
    if (NULL == pCallbackParams->pPeerRTCPAddr)
    {
        H323DBG((
            DEBUG_LEVEL_ERROR,
            "channel rejected: empty peer RTCP address.\n"
            ));

        // initialize reject reason
        dwRejectReason = H245_REJ_TYPE_UNKNOWN;

        // bail...
        goto reject;
    }

    pChannel->ccRemoteRTCPAddr = *pCallbackParams->pPeerRTCPAddr;

    // transfer channel information from callback parameters
    pChannel->hccChannel = pCallbackParams->hChannel;
    pChannel->bSessionID = pCallbackParams->bSessionID;

    // transfer termcap to channel
    pChannel->ccTermCaps = *pRemoteCap;

    // initialize direction
    pChannel->fInbound = TRUE;

    // determine payload type from channel capability data type
    pChannel->Settings.MediaType = H323IsVideoDataType(pRemoteCap->DataType)
                                        ? MEDIA_VIDEO
                                        : MEDIA_AUDIO
                                        ;

    // examine existing session
    if (pAssociatedChannel != NULL) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "overriding default local RTCP port for session %d\n",
            pChannel->bSessionID
            ));

        // override default RTCP port with existing one
        pChannel->ccLocalRTCPAddr.Addr.IP_Binary.wPort =
            pAssociatedChannel->ccLocalRTCPAddr.Addr.IP_Binary.wPort;
    }

    // complete media stream address information
    pChannel->Settings.dwIPLocal = pChannel->ccLocalRTPAddr.Addr.IP_Binary.dwAddr;
    pChannel->Settings.wRTPPortLocal = pChannel->ccLocalRTPAddr.Addr.IP_Binary.wPort;
    pChannel->Settings.wRTCPPortLocal = pChannel->ccLocalRTCPAddr.Addr.IP_Binary.wPort;

    pChannel->Settings.dwIPRemote = pChannel->ccRemoteRTCPAddr.Addr.IP_Binary.dwAddr;
    pChannel->Settings.wRTPPortRemote = 0;
    pChannel->Settings.wRTCPPortRemote = pChannel->ccRemoteRTCPAddr.Addr.IP_Binary.wPort;

#if DBG

    // convert local address to network order
    dwIPAddr = htonl(pChannel->Settings.dwIPLocal);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "incoming RTP stream %s:%d\n",
        H323AddrToString(dwIPAddr),
        pChannel->Settings.wRTPPortLocal
        ));

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "incoming RTCP stream %s:%d\n",
        H323AddrToString(dwIPAddr),
        pChannel->Settings.wRTCPPortLocal
        ));

    // convert remote address to network order
    dwIPAddr = htonl(pChannel->Settings.dwIPRemote);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "outgoing RTCP stream %s:%d\n",
        H323AddrToString(dwIPAddr),
        pChannel->Settings.wRTCPPortRemote
        ));

#endif

    // check incoming stream type
    switch (pRemoteCap->ClientType) {

    case H245_CLIENT_AUD_G723:

        // initialize rtp payload type
        pChannel->Settings.dwPayloadType = G723_RTP_PAYLOAD_TYPE;
        pChannel->Settings.dwDynamicType =
            (pCallbackParams->bRTPPayloadType != 0)
                ? (DWORD)(BYTE)(pCallbackParams->bRTPPayloadType)
                : G723_RTP_PAYLOAD_TYPE
                ;

        pChannel->Settings.Audio.dwMillisecondsPerPacket =
            G723_MILLISECONDS_PER_PACKET(
                pRemoteCap->Cap.H245Aud_G723.maxAl_sduAudioFrames
                );

        pChannel->Settings.Audio.G723Settings.bG723LowSpeed = 
                    H323IsSlowLink(pCall->dwLinkSpeed);

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "incoming G723 stream (%d milliseconds).\n",
            pChannel->Settings.Audio.dwMillisecondsPerPacket
            ));

        break;

    case H245_CLIENT_AUD_G711_ULAW64:

        // complete audio information
        pChannel->Settings.dwPayloadType = G711U_RTP_PAYLOAD_TYPE;
        pChannel->Settings.dwDynamicType =
            (pCallbackParams->bRTPPayloadType != 0)
                ? (DWORD)(BYTE)(pCallbackParams->bRTPPayloadType)
                : G711U_RTP_PAYLOAD_TYPE
                ;

        pChannel->Settings.Audio.dwMillisecondsPerPacket =
            G711_MILLISECONDS_PER_PACKET(
                pRemoteCap->Cap.H245Aud_G711_ULAW64
                );

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "incoming G711U stream (%d milliseconds).\n",
            pChannel->Settings.Audio.dwMillisecondsPerPacket
            ));

        break;

    case H245_CLIENT_AUD_G711_ALAW64:

        // complete audio information
        pChannel->Settings.dwPayloadType = G711A_RTP_PAYLOAD_TYPE;
        pChannel->Settings.dwDynamicType =
            (pCallbackParams->bRTPPayloadType != 0)
                ? (DWORD)(BYTE)(pCallbackParams->bRTPPayloadType)
                : G711A_RTP_PAYLOAD_TYPE
                ;

        pChannel->Settings.Audio.dwMillisecondsPerPacket =
            G711_MILLISECONDS_PER_PACKET(
                pRemoteCap->Cap.H245Aud_G711_ALAW64
                );

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "incoming G711A stream (%d milliseconds).\n",
            pChannel->Settings.Audio.dwMillisecondsPerPacket
            ));

        break;

    case H245_CLIENT_VID_H263:

        // complete video information
        pChannel->Settings.dwPayloadType = H263_RTP_PAYLOAD_TYPE;
        pChannel->Settings.dwDynamicType =
            (pCallbackParams->bRTPPayloadType != 0)
                ? (DWORD)(BYTE)(pCallbackParams->bRTPPayloadType)
                : H263_RTP_PAYLOAD_TYPE
                ;
        pChannel->Settings.Video.bCIF = FALSE;

        pChannel->Settings.Video.dwMaxBitRate =
            pRemoteCap->Cap.H245Vid_H263.maxBitRate * 100
            ;

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "incoming H263 stream (%d bps).\n",
            pChannel->Settings.Video.dwMaxBitRate
            ));

        break;

    case H245_CLIENT_VID_H261:

        // complete video information
        pChannel->Settings.dwPayloadType = H261_RTP_PAYLOAD_TYPE;
        pChannel->Settings.dwDynamicType =
            (pCallbackParams->bRTPPayloadType != 0)
                ? (DWORD)(BYTE)(pCallbackParams->bRTPPayloadType)
                : H261_RTP_PAYLOAD_TYPE
                ;
        pChannel->Settings.Video.bCIF = FALSE;

        pChannel->Settings.Video.dwMaxBitRate =
            pRemoteCap->Cap.H245Vid_H261.maxBitRate * 100
            ;

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "incoming H261 stream (%d bps).\n",
            pChannel->Settings.Video.dwMaxBitRate
            ));

        break;
    }

    // save back pointer
    pChannel->pCall = pCall;

    // let msp accept incoming channel
    H323SendAcceptChannelRequest(pCall, pChannel);

    // release line device
    H323UnlockLine(pCall->pLine);

    // processed
    return CC_OK;

reject:

    // reject channel
    CC_RejectChannel(
        pCallbackParams->hChannel,
        dwRejectReason
        );

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "call 0x%08lx incoming channel rejected.\n",
        pCall
        ));

    // release line device
    H323UnlockLine(pCall->pLine);

    // processed
    return CC_OK;
}


HRESULT
H323RxChannelCloseCallback(
    PH323_CALL                           pCall,
    HRESULT                              hrConf,
    PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Callback for channel close indications.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    PH323_CHANNEL pChannel = NULL;

    // attempt to retrieve channel
    if (!H323LookupChannelByHandle(
            &pChannel, 
            pCall->pChannelTable, 
            pCallbackParams->hChannel
            )) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not close unknown rx channel 0x%08lx.\n",
            pCallbackParams->hChannel
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // could not find channel
        return CC_NOT_IMPLEMENTED;
    }

    // notify msp of channel closure
    H323SendCloseChannelCommand(pCall, pChannel->hmChannel,ERROR_SUCCESS);

    // release memory for logical channel
    H323FreeChannelFromTable(pChannel, pCall->pChannelTable);
    
    // update media modes
    H323UpdateMediaModes(pCall);

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return CC_OK; 
}


HRESULT
H323TxChannelOpenCallback(
    PH323_CALL                          pCall,
    HRESULT                             hrConf,
    PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Callback for channel open indications.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    PH323_CHANNEL pChannel = NULL;

    // attempt to retrieve channel
    if (!H323LookupChannelByHandle(
            &pChannel, 
            pCall->pChannelTable, 
            pCallbackParams->hChannel
            )) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not open unknown tx channel 0x%08lx.\n",
            pCallbackParams->hChannel
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // could not find channel
        return CC_NOT_IMPLEMENTED;
    }

    // validate status
    if (hrConf != CC_OK) {

        // see if peer rejected
        if (hrConf == CC_PEER_REJECT) {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "channel 0x%08lx rejected 0x%08lx.\n",
                pChannel,
                pCallbackParams->dwRejectReason
                ));

        } else {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "channel 0x%08lx unable to be opened.\n",
                pChannel
                ));
        }

        // close channel (with error)
        H323SendCloseChannelCommand(pCall, pChannel->hmChannel,(DWORD)-1);

        // release channel object
        H323FreeChannelFromTable(pChannel,pCall->pChannelTable);

    } else {
        
        // transfer peer rtcp address from callback parameters
        pChannel->ccRemoteRTPAddr = *pCallbackParams->pPeerRTPAddr;

        // transfer peer rtcp address from callback parameters
        pChannel->ccRemoteRTCPAddr = *pCallbackParams->pPeerRTCPAddr;

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "channel 0x%08lx accepted by peer.\n",
            pChannel
        ));

        // complete media stream address information
        pChannel->Settings.dwIPLocal = pChannel->ccLocalRTCPAddr.Addr.IP_Binary.dwAddr;
        pChannel->Settings.wRTPPortLocal = 0;
        pChannel->Settings.wRTCPPortLocal = pChannel->ccLocalRTCPAddr.Addr.IP_Binary.wPort;

        pChannel->Settings.dwIPRemote = pChannel->ccRemoteRTPAddr.Addr.IP_Binary.dwAddr;
        pChannel->Settings.wRTPPortRemote = pChannel->ccRemoteRTPAddr.Addr.IP_Binary.wPort;
        pChannel->Settings.wRTCPPortRemote = pChannel->ccRemoteRTCPAddr.Addr.IP_Binary.wPort;

#if DBG
        {
            DWORD dwIPAddr;

            // convert local address to network order
            dwIPAddr = htonl(pChannel->Settings.dwIPLocal);

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "incoming RTCP stream %s:%d\n",
                H323AddrToString(dwIPAddr),
                pChannel->Settings.wRTCPPortLocal
                ));

            // convert remote address to network order
            dwIPAddr = htonl(pChannel->Settings.dwIPRemote);

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "outgoing RTP stream %s:%d\n",
                H323AddrToString(dwIPAddr),
                pChannel->Settings.wRTPPortRemote
                ));

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "outgoing RTCP stream %s:%d\n",
                H323AddrToString(dwIPAddr),
                pChannel->Settings.wRTCPPortRemote
                ));
        }
#endif

        // change state to opened
        pChannel->nState = H323_CHANNELSTATE_OPENED;

        // notify msp channel is opened
        H323SendOpenChannelResponse(pCall, pChannel);
    }

    // update media modes
    H323UpdateMediaModes(pCall);

    // release line device
    H323UnlockLine(pCall->pLine);

    // processed
    return CC_OK;
}


HRESULT
H323TxChannelCloseCallback(
    PH323_CALL                                   pCall,
    HRESULT                                      hrConf,
    PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Callback for channel close indications.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    PH323_CHANNEL pChannel = NULL;

    // attempt to retrieve channel
    if (!H323LookupChannelByHandle(
            &pChannel, 
            pCall->pChannelTable, 
            pCallbackParams->hChannel
            )) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not close unknown tx channel 0x%08lx.\n",
            pCallbackParams->hChannel
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // could not find channel
        return CC_NOT_IMPLEMENTED;
    }

    // notify msp channel is closed
    H323SendCloseChannelCommand(pCall, pChannel->hmChannel,ERROR_SUCCESS);

    // release memory for logical channel
    H323FreeChannelFromTable(pChannel, pCall->pChannelTable);
    
    // update media modes
    H323UpdateMediaModes(pCall);

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return CC_OK; 
}


HRESULT
H323FlowControlCallback(
    PH323_CALL                                   pCall,
    HRESULT                                      hrConf,
    PCC_FLOW_CONTROL_CALLBACK_PARAMS              pCallbackParams
    )
        
/*++

Routine Description:

    Callback for flow control commands.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns CC_OK. 
      
--*/

{
    PH323_CHANNEL pChannel = NULL;

    // attempt to retrieve channel
    if (!H323LookupChannelByHandle(
            &pChannel, 
            pCall->pChannelTable, 
            pCallbackParams->hChannel
            )) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not process flow control command for channel 0x%08lx.\n",
            pCallbackParams->hChannel
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // could not find channel
        return CC_OK;
    }

    // notify msp that media stream bit rate is to be changed
    H323SendFlowControlCommand(
         pCall,
         pChannel,
         pCallbackParams->dwRate
          );

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return CC_OK; 
}


HRESULT
H323VideoFastUpdatePictureCallback(
    PH323_CALL                                       pCall,
    HRESULT                                          hrConf,
    PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS     pCallbackParams
    )
        
/*++

Routine Description:

    Callback for Video Fast Update Picture command (a.k.a. I-frame request command)

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns CC_OK. 
      
--*/

{
    PH323_CHANNEL pChannel = NULL;

    // attempt to retrieve channel
    if (!H323LookupChannelByHandle(
            &pChannel, 
            pCall->pChannelTable, 
            pCallbackParams->hChannel
            )) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not process I-frame request cmd for channel 0x%08lx.\n",
            pCallbackParams->hChannel
            ));

        // release line device
        H323UnlockLine(pCall->pLine);

        // could not find channel
        return CC_OK;
    }

    // notify msp that media stream bit rate is to be changed
    H323SendVideoFastUpdatePictureCommand(
         pCall,
         pChannel
          );

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return CC_OK; 
}


HRESULT
H245MiscellaneousCommandCallback(
    PH323_CALL                                     pCall,
    HRESULT                                        hrConf,
    PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Callback for miscellaneous H.245 commands.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    // retrieve command structure from incoming callback parameters
    MiscellaneousCommand * pCommand = pCallbackParams->pMiscellaneousCommand;

    switch (pCommand->type.choice) {

    case videoFastUpdatePicture_chosen:
            
       // process I-frame request from remote entity
       return H323VideoFastUpdatePictureCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
                    );

    default:
        // intentionally left blank
        break;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "misc command %s ignored.\n",
        H323MiscCommandToString((DWORD)(USHORT)pCommand->type.choice)
        ));

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return CC_NOT_IMPLEMENTED; 
}


HRESULT
H245RxNonStandardMessageCallback(
    PH323_CALL                                 pCall,
    HRESULT                                    hrConf,
    PCC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Callback for miscellaneous H.245 commands.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    // validate status
    if (hrConf == CC_OK) {

        // validate incoming parameters
        if ((pCallbackParams->bH245MessageType == CC_H245_MESSAGE_COMMAND) &&
            H323IsValidU2U(&pCallbackParams->NonStandardData)) {

            // add user user info
            if (H323AddU2U(
                    &pCall->IncomingU2U,
                    pCallbackParams->NonStandardData.sData.wOctetStringLength,
                    pCallbackParams->NonStandardData.sData.pOctetString
                    )) {

                H323DBG((
                    DEBUG_LEVEL_VERBOSE,
                    "user user info available in NONSTANDARD MESSAGE.\n"
                    ));

                // signal incoming
                (*g_pfnLineEventProc)(
                    pCall->pLine->htLine,
                    pCall->htCall,
                    LINE_CALLINFO,
                    LINECALLINFOSTATE_USERUSERINFO,
                    0,
                    0
                    );
            }
        }

    } else {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "error 0x%08lx receiving non-standard message.\n",
            hrConf
            ));
    }

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return CC_OK; 
}


HRESULT
H245UserInputCallback(
    PH323_CALL               pCall,
    HRESULT               hrConf,
    PCC_USER_INPUT_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Callback for miscellaneous H.245 commands.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    // validate status
    if (hrConf == CC_OK) {

        // check monitoring mode
        if (pCall->fMonitoringDigits == TRUE) {

            WCHAR * pwch;

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "incoming user input %S.\n",
                pCallbackParams->pUserInput
                ));

            // initialize string pointer
            pwch = pCallbackParams->pUserInput;

            // process each digit
            while (*pwch != L'\0') {

                // signal incoming
                (*g_pfnLineEventProc)(
                    pCall->pLine->htLine,
                    pCall->htCall,
                    LINE_MONITORDIGITS,
                    (DWORD_PTR)*pwch,
                    LINEDIGITMODE_DTMF,
                    GetTickCount()
                    );

                // next
                ++pwch;
            }

        } else {

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "ignoring incoming user input message.\n"
                ));
        }

    } else {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "error 0x%08lx receiving user input message.\n",
            hrConf
            ));
    }

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return CC_OK; 
}


HRESULT
H245T120ChannelRequestCallback(
    PH323_CALL               pCall,
    HRESULT               hrConf,
	PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS pT120RequestParams
    )
        
/*++

Routine Description:

    Callback for a T120 open channel request.

Arguments:

    pCall - Pointer to call object.

    hrConf - Current status of H.323 conference.

    pCallbackParams - Parameters returned by call control module.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/
{
    HRESULT hr;

    // validate status
    if (hrConf == CC_OK) {

    	CC_ADDR ChannelAddr;
		ChannelAddr.nAddrType = CC_IP_BINARY;
		ChannelAddr.bMulticast = FALSE;

		ChannelAddr.Addr.IP_Binary.wPort = g_wPortT120;

        if (g_dwIPT120 != INADDR_ANY)
        {
    		ChannelAddr.Addr.IP_Binary.dwAddr = g_dwIPT120;
        }
        else
        {
            ChannelAddr.Addr.IP_Binary.dwAddr = 
                H323IsCallInbound(pCall)
                    ? pCall->ccCalleeAddr.Addr.IP_Binary.dwAddr
                    : pCall->ccCallerAddr.Addr.IP_Binary.dwAddr
                    ;
        }

	    hr = CC_AcceptT120Channel(
		    pT120RequestParams->hChannel,
		    FALSE,	// BOOL bAssociateConference,
		    NULL, 	// PCC_OCTETSTRING					pExternalReference,
		    &ChannelAddr
            );

        if (hr != CC_OK)
        {
            H323DBG((
                DEBUG_LEVEL_WARNING,
                "error 0x%08lx accepting T120 channel.\n",
                hr
                ));
        }

    } else {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "error 0x%08lx receiving user input message.\n",
            hrConf
            ));
    }

    // release line device
    H323UnlockLine(pCall->pLine);

    // success
    return CC_OK; 
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT 
H323ConferenceCallback(
    BYTE                            bIndication,    
    HRESULT                         hrConf,
    CC_HCONFERENCE                  hConference,
    DWORD                           dwConferenceToken,
    PCC_CONFERENCE_CALLBACK_PARAMS  pCallbackParams
    )
        
/*++

Routine Description:

    Conference callback for Intel Call Control module.

Arguments:

    bIndication - indicates the reason for the callback.

    hrConf - indicates the asynchronous status of the call.

    hConference - conference handle associated with the callback.

    dwConferenceToken - conference token specified in the CC_CreateConference().

    pCallbackParams - pointer to a structure containing callback 
        parameters specific for the callback indication.

Return Values:

    Returns either CC_OK or CC_NOT_IMPLEMENTED.
      
--*/

{
    HRESULT hr;
    HDRVCALL hdCall;
    PH323_CALL pCall = NULL;
    
    H323DBG((
        DEBUG_LEVEL_TRACE,
        "%s %s (0x%08lx).\n",
        H323IndicationToString(bIndication),
        H323StatusToString((DWORD)hrConf),
        hrConf
        ));

    // retrieve call handle from token
    hdCall = (HDRVCALL)dwConferenceToken;        

    // handle hangup indications separately
    if (bIndication == CC_HANGUP_INDICATION) {
        
        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "hangup confirmed (hdCall=0x%08lx).\n",
            hdCall
            ));

        // success
        return CC_OK;

    } else if (bIndication == CC_ACCEPT_CHANNEL_INDICATION) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "ignoring accept channel indication (hdCall=0x%08lx).\n",
            hdCall
            ));

        // success
        return CC_OK;
    }

    // retrieve call pointer from handle
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid call handle in callback.\n"
            ));

        // need to return error
        return CC_NOT_IMPLEMENTED;
    }    

    // validate conference handle
    if (pCall->hccConf != hConference) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "conference handle mismatch.\n"
            ));

        // unlock line device
        H323UnlockLine(pCall->pLine);

        // need to return error
        return CC_NOT_IMPLEMENTED;
    }

    // determine message
    switch (bIndication) {

    case CC_CONNECT_INDICATION:
    
        // process connect indication
        return H323ConnectCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
                    );

    case CC_RINGING_INDICATION:
    
        // process ringing indication
        return H323RingingCallback(
                    pCall
                    );

    case CC_CONFERENCE_TERMINATION_INDICATION:

        // process termination indication
        return H323TerminationCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
                    );

    case CC_RX_CHANNEL_REQUEST_INDICATION:

        // process termination indication
        return H323RxChannelRequestCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
                    );

    case CC_RX_CHANNEL_CLOSE_INDICATION:

        // process channel close
        return H323RxChannelCloseCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
                    );

    case CC_TX_CHANNEL_OPEN_INDICATION:

        // process channel open
        return H323TxChannelOpenCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
                    );

    case CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION:

        // process channel close 
        return H323TxChannelCloseCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
                    );

    case CC_FLOW_CONTROL_INDICATION:

        // process flow control command
        return H323FlowControlCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
                    );

    case CC_H245_MISCELLANEOUS_COMMAND_INDICATION:
    
        // process miscellaneous commands
        return H245MiscellaneousCommandCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
                    );

    case CC_RX_NONSTANDARD_MESSAGE_INDICATION:

        // process nonstandard commands
        return H245RxNonStandardMessageCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
            );

    case CC_USER_INPUT_INDICATION:

        // process nonstandard commands
        return H245UserInputCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
            );

    case CC_T120_CHANNEL_REQUEST_INDICATION:

        // process T120 channel request
        return H245T120ChannelRequestCallback(
                    pCall,
                    hrConf,
                    (PVOID)pCallbackParams
            );
    }

    H323DBG((
        DEBUG_LEVEL_WARNING,
        "conference callback indication not supported.\n"
        ));

    // unlock line device
    H323UnlockLine(pCall->pLine);

    // not yet supported
    return CC_NOT_IMPLEMENTED;
}


VOID 
H323ListenCallback(
    HRESULT                    hrListen,
    PCC_LISTEN_CALLBACK_PARAMS pCallbackParams
    )
        
/*++

Routine Description:

    Conference callback for Intel Call Control module.

Arguments:

    hrListen - indicates the asynchronous status of the call.

    pCallbackParams - pointer to a structure containing callback 
        parameters specific for the callback indication.

Return Values:

    None.
      
--*/

{
    HRESULT hr;
    HDRVLINE hdLine;
    PH323_LINE pLine = NULL;
    PH323_CALL pCall = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "INCOMING CALL %s (0x%08lx).\n",
        H323StatusToString(hrListen),
        hrListen
        ));
        
    // retrieve line handle from token
    hdLine = (HDRVLINE)pCallbackParams->dwListenToken;

    // retrieve line pointer from handle
    if (!H323GetLineAndLock(&pLine, hdLine)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid line handle in listen callback.\n"
            ));

        // failure
        return ;
    }    

    // validate status
    if (hrListen != CC_OK) {

        // check for active call
        if (H323GetCallByHCall(
                &pCall,
                pLine,
                pCallbackParams->hCall)) {

            // drop offering call
            H323DropCall(pCall,LINEDISCONNECTMODE_CANCELLED);
        }

        // release line device
        H323UnlockLine(pLine);

        // done
        return;
    }

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "line %d receiving call request from %S.\n",
        pLine->dwDeviceID,
        pCallbackParams->pszDisplay
        ));
    
    // allocate outgoing call from line call table
    if (!H323AllocCallFromTable(&pCall,&pLine->pCallTable,pLine)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate call object.\n"
            ));

        // release line device
        H323UnlockLine(pLine);

        // failure
        return;
    }

    // save back pointer
    pCall->pLine = pLine;
    
    // clear incoming modes
    pCall->dwIncomingModes = 0;

    // outgoing modes will be finalized during H.245 phase
    pCall->dwOutgoingModes = pLine->dwMediaModes | LINEMEDIAMODE_UNKNOWN;

    // save media modes specified
    pCall->dwRequestedModes = pLine->dwMediaModes;

    // specify incoming call direction
    pCall->dwOrigin = LINECALLORIGIN_INBOUND;    

    // save incoming call handle
    pCall->hccCall = pCallbackParams->hCall;

    // save caller transport address
    pCall->ccCallerAddr = *pCallbackParams->pCallerAddr;

    // save callee transport address
    pCall->ccCalleeAddr = *pCallbackParams->pCalleeAddr;

#if DBG
    {
        DWORD dwIPAddr;

        // retrieve ip address in network byte order
        dwIPAddr = htonl(pCall->ccCalleeAddr.Addr.IP_Binary.dwAddr);

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "callee address resolved to %s.\n",
            H323AddrToString(dwIPAddr)
            ));

        // retrieve ip address in network byte order
        dwIPAddr = htonl(pCall->ccCallerAddr.Addr.IP_Binary.dwAddr);

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "caller address resolved to %s.\n",
            H323AddrToString(dwIPAddr)
            ));
    }
#endif

    // determine link speed for local interface
    pCall->dwLinkSpeed = H323DetermineLinkSpeed(
                            pCall->ccCalleeAddr.Addr.IP_Binary.dwAddr
                            );

    // bind incoming call
    if (!H323BindCall(pCall,NULL)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not bind call object.\n"
            ));

        // failure
        goto cleanup;
    }    

    // see if caller alias was specified
    if ((pCallbackParams->pCallerAliasNames != NULL) &&
        (pCallbackParams->pCallerAliasNames->wCount > 0)) {

        PCC_ALIASITEM pCallerAlias;

        // retrieve pointer to caller alias
        pCallerAlias = pCallbackParams->pCallerAliasNames->pItems;

        // validate alias type
        if ((pCallerAlias->wDataLength > 0) &&
           ((pCallerAlias->wType == CC_ALIAS_H323_ID) ||
            (pCallerAlias->wType == CC_ALIAS_H323_PHONE))) {

            // initialize alias
            pCall->ccCallerAlias.wType         = pCallerAlias->wType;
            pCall->ccCallerAlias.wDataLength   = pCallerAlias->wDataLength;
            pCall->ccCallerAlias.wPrefixLength = 0;
            pCall->ccCallerAlias.pPrefix       = NULL;

            // allocate memory for caller string
            pCall->ccCallerAlias.pData = H323HeapAlloc(
                (pCallerAlias->wDataLength + 1) * sizeof(WCHAR)
                );

            // validate pointer
            if (pCall->ccCallerAlias.pData == NULL) {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "could not allocate caller name.\n"
                    ));

                // failure
                goto cleanup;
            }

            // transfer string information
            memcpy(pCall->ccCallerAlias.pData,
                   pCallerAlias->pData,
                   pCallerAlias->wDataLength * sizeof(WCHAR)
                   );

            // terminate incoming string
            pCall->ccCallerAlias.pData[pCallerAlias->wDataLength] = L'\0';

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "incoming caller alias is %S.\n",
                pCall->ccCallerAlias.pData
                ));
        }
    }

    // see if callee alias was specified
    if ((pCallbackParams->pCalleeAliasNames != NULL) &&
        (pCallbackParams->pCalleeAliasNames->wCount > 0)) {

        PCC_ALIASITEM pCalleeAlias;

        // retrieve pointer to callee alias
        pCalleeAlias = pCallbackParams->pCalleeAliasNames->pItems;

        // validate alias type
        if ((pCalleeAlias->wDataLength > 0) &&
           ((pCalleeAlias->wType == CC_ALIAS_H323_ID) ||
            (pCalleeAlias->wType == CC_ALIAS_H323_PHONE))) {

            // initialize alias
            pCall->ccCalleeAlias.wType         = pCalleeAlias->wType;
            pCall->ccCalleeAlias.wDataLength   = pCalleeAlias->wDataLength;
            pCall->ccCalleeAlias.wPrefixLength = 0;
            pCall->ccCalleeAlias.pPrefix       = NULL;

            // allocate memory for caller string
            pCall->ccCalleeAlias.pData = H323HeapAlloc(
                (pCalleeAlias->wDataLength + 1) * sizeof(WCHAR)
                );

            // validate pointer
            if (pCall->ccCalleeAlias.pData == NULL) {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "could not allocate callee name.\n"
                    ));

                // failure
                goto cleanup;
            }

            // transfer string information
            memcpy(pCall->ccCalleeAlias.pData,
                   pCalleeAlias->pData,
                   pCalleeAlias->wDataLength * sizeof(WCHAR)
                   );

            // terminate incoming string
            pCall->ccCalleeAlias.pData[pCalleeAlias->wDataLength] = L'\0';

            H323DBG((
                DEBUG_LEVEL_VERBOSE,
                "incoming callee alias is %S.\n",
                pCall->ccCalleeAlias.pData
                ));
        }
    }

    // validate user user info specified
    if ((pCallbackParams->pNonStandardData != NULL) &&
        H323IsValidU2U(pCallbackParams->pNonStandardData)) {

        // add user user info
        if (!H323AddU2U(
                &pCall->IncomingU2U,
                pCallbackParams->pNonStandardData->sData.wOctetStringLength,
                pCallbackParams->pNonStandardData->sData.pOctetString
                )) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "could not save incoming user user info.\n"
                ));

            // failure
            goto cleanup;
        }
    }

    // signal incoming call
    (*g_pfnLineEventProc)(
        pLine->htLine,
        (HTAPICALL)NULL,
        LINE_NEWCALL,
        (DWORD_PTR)pCall->hdCall,
        (DWORD_PTR)&pCall->htCall,
        0
        );

    // see if user user info specified
    if (!IsListEmpty(&pCall->IncomingU2U)) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "user user info available in SETUP PDU.\n"
            ));

        // signal incoming
        (*g_pfnLineEventProc)(
            pLine->htLine,
            pCall->htCall,
            LINE_CALLINFO,
            LINECALLINFOSTATE_USERUSERINFO,
            0,
            0
            );
    }

    // change state to offering
    H323ChangeCallState(pCall, LINECALLSTATE_OFFERING, 0);

    // release line device
    H323UnlockLine(pLine);

    // success
    return;

cleanup:

    // unbind call
    H323UnbindCall(pCall);

    // release outgoing call from line call table
    H323FreeCallFromTable(pCall,pLine->pCallTable);

    // release line device
    H323UnlockLine(pLine);

    // failure
    return;
}


BOOL
H323StartCallbackThread(
    )

/*++

Routine Description:

    Creates thread which handles async processing.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // transfer registry key change event to waitable object array
    g_WaitableObjects[WAIT_OBJECT_REGISTRY_CHANGE] = CreateEvent(
                                                        NULL,   // lpEventAttributes 
                                                        FALSE,  // bManualReset
                                                        FALSE,  // bInitialState 
                                                        NULL    // lpName 
                                                        );

    // transfer termination event to waitable object array
    g_WaitableObjects[WAIT_OBJECT_TERMINATE_EVENT] = CreateEvent(
                                                        NULL,   // lpEventAttributes 
                                                        TRUE,   // bManualReset 
                                                        FALSE,  // bInitialState 
                                                        NULL    // lpName 
                                                        );

    // validate waitable object handles
    if ((g_WaitableObjects[WAIT_OBJECT_REGISTRY_CHANGE] == NULL) ||
        (g_WaitableObjects[WAIT_OBJECT_TERMINATE_EVENT] == NULL)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate waitable objects.\n"
            ));

        // cleanup resources
        H323StopCallbackThread();

        // failure
        return FALSE;
    }

    // attempt to start thread
    g_hCallbackThread = CreateThread(
                            NULL,                   // lpThreadAttributes
                            0,                      // dwStackSize
                            H323CallbackThread,
                            NULL,                   // lpParameter
                            0,                      // dwCreationFlags
                            &g_dwCallbackThreadID
                            );

    // validate thread handle
    if (g_hCallbackThread == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx creating callback thread.\n",
            GetLastError()
            ));

        // cleanup resources
        H323StopCallbackThread();

        // failure
        return FALSE;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "callback thread %x started.\n",
        g_dwCallbackThreadID
        ));

    // success
    return TRUE;
}


BOOL
H323StopCallbackThread(
    )

/*++

Routine Description:

    Destroys thread which handles async processing.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HRESULT hr;
    DWORD dwStatus;

    // validate thread handle
    if (g_hCallbackThread != NULL) {

        // signal termination event
        SetEvent(g_WaitableObjects[WAIT_OBJECT_TERMINATE_EVENT]);

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "callback thread %x stopping.\n",
            g_dwCallbackThreadID
            ));

        // unlock temporarily
        H323UnlockProvider();

        // wait for callback thread to terminate
        dwStatus = WaitForSingleObject(g_hCallbackThread, INFINITE);

        // relock provider
        H323LockProvider();

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "callback thread %x stopped (dwStatus=0x%08lx).\n",
            g_dwCallbackThreadID,
            dwStatus
            ));

        // close thread handle
        CloseHandle(g_hCallbackThread);
    
        // re-initialize callback thread id
        g_dwCallbackThreadID = UNINITIALIZED;
        g_hCallbackThread = NULL;
    }

    // validate waitable object handle
    if (g_WaitableObjects[WAIT_OBJECT_REGISTRY_CHANGE] != NULL) {

        // release waitable object handle
        CloseHandle(g_WaitableObjects[WAIT_OBJECT_REGISTRY_CHANGE]);

        // re-initialize waitable object handle
        g_WaitableObjects[WAIT_OBJECT_REGISTRY_CHANGE] = NULL;
    }

    // validate waitable object handle
    if (g_WaitableObjects[WAIT_OBJECT_TERMINATE_EVENT] != NULL) {

        // release waitable object handle
        CloseHandle(g_WaitableObjects[WAIT_OBJECT_TERMINATE_EVENT]);

        // re-initialize waitable object handle
        g_WaitableObjects[WAIT_OBJECT_TERMINATE_EVENT] = NULL;
    }

    // success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\callback.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    callback.h

Abstract:

    Definitions for callback routines for Intel Call Control Module.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_CALLBACK
#define _INC_CALLBACK
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Window message definitions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323_MSG_WINSOCK        (WM_USER+1)  // H245ws component uses this
#define H323_MSG_PLACE_CALL     (WM_USER+10)
#define H323_MSG_ACCEPT_CALL    (WM_USER+11)
#define H323_MSG_CLOSE_CALL     (WM_USER+12)
#define H323_MSG_DROP_CALL      (WM_USER+13)
#define H323_MSG_CALL_LISTEN    (WM_USER+14)
#define H323_MSG_TERMINATION    (WM_USER+15)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern DWORD g_dwCallbackThreadID;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define WAIT_OBJECT_REGISTRY_CHANGE     (WAIT_OBJECT_0)
#define WAIT_OBJECT_TERMINATE_EVENT     (WAIT_OBJECT_REGISTRY_CHANGE + 1)
#define WAIT_OBJECT_INCOMING_MESSAGE    (WAIT_OBJECT_TERMINATE_EVENT + 1)

#define NUM_WAITABLE_OBJECTS            2

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323IsTerminationMessage(_msg_) \
    ((_msg_)->message == H323_MSG_TERMINATION)

#define H323IsPlaceCallMessage(_msg_) \
    ((_msg_)->message == H323_MSG_PLACE_CALL)

#define H323IsAcceptCallMessage(_msg_) \
    ((_msg_)->message == H323_MSG_ACCEPT_CALL)

#define H323IsCloseCallMessage(_msg_) \
    ((_msg_)->message == H323_MSG_CLOSE_CALL)

#define H323IsDropCallMessage(_msg_) \
    ((_msg_)->message == H323_MSG_DROP_CALL)

#define H323IsCallListenMessage(_msg_) \
    ((_msg_)->message == H323_MSG_CALL_LISTEN)

#define H323PostTerminationMessage() \
    (PostThreadMessage(g_dwCallbackThreadID, \
                       H323_MSG_TERMINATION, \
                       (WPARAM)0, \
                       (LPARAM)0))

#define H323PostPlaceCallMessage(_hdCall_) \
    (PostThreadMessage(g_dwCallbackThreadID, \
                       H323_MSG_PLACE_CALL, \
                       (WPARAM)(_hdCall_), \
                       (LPARAM)(0)))

#define H323PostAcceptCallMessage(_hdCall_) \
    (PostThreadMessage(g_dwCallbackThreadID, \
                       H323_MSG_ACCEPT_CALL, \
                       (WPARAM)(_hdCall_), \
                       (LPARAM)(0)))

#define H323PostCloseCallMessage(_hdCall_) \
    (PostThreadMessage(g_dwCallbackThreadID, \
                       H323_MSG_CLOSE_CALL, \
                       (WPARAM)(_hdCall_), \
                       (LPARAM)(0)))

#define H323PostDropCallMessage(_hdCall_,_dwDisconnectMode_) \
    (PostThreadMessage(g_dwCallbackThreadID, \
                       H323_MSG_DROP_CALL, \
                       (WPARAM)(_hdCall_), \
                       (LPARAM)(_dwDisconnectMode_)))

#define H323PostCallListenMessage(_hdLine_) \
    (PostThreadMessage(g_dwCallbackThreadID, \
                       H323_MSG_CALL_LISTEN, \
                       (WPARAM)(_hdLine_), \
                       (LPARAM)(0)))

#define H323IsValidU2U(_pNS_) \
    (((_pNS_)->bCountryCode      == H221_COUNTRY_CODE_USA) && \
     ((_pNS_)->bExtension        == H221_COUNTRY_EXT_USA) && \
     ((_pNS_)->wManufacturerCode == H221_MFG_CODE_MICROSOFT))

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT 
H323ConferenceCallback(
    BYTE                            bIndication,    
    HRESULT                         hStatus,
    CC_HCONFERENCE                  hConference,
    DWORD                           dwConferenceToken,
    PCC_CONFERENCE_CALLBACK_PARAMS  pConferenceCallbackParams
    );
        
VOID 
H323ListenCallback(
    HRESULT                    hStatus,
    PCC_LISTEN_CALLBACK_PARAMS pListenCallbackParams
    );

BOOL
H323StartCallbackThread(
	);

BOOL
H323StopCallbackThread(
	);

#endif // _INC_CALLBACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\channel.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    channel.h

Abstract:

    Definitions for H.323 TAPI Service Provider channel objects.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_CHANNEL
#define _INC_CHANNEL

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "h323pdu.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Type definitions                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef enum _H323_CHANNELSTATE {

    H323_CHANNELSTATE_ALLOCATED = 0,        
    H323_CHANNELSTATE_CLOSED,
    H323_CHANNELSTATE_OPENING,              
    H323_CHANNELSTATE_OPENED                

} H323_CHANNELSTATE, *PH323_CHANNELSTATE;

typedef struct _H323_CHANNEL {

    H323_CHANNELSTATE   nState;             // state of channel
    STREAMSETTINGS      Settings;           // stream settings
    HANDLE              hmChannel;          // msp channel handle
    CC_HCHANNEL         hccChannel;         // intelcc channel handle
    CC_ADDR             ccLocalRTPAddr;     // local rtp address
    CC_ADDR             ccLocalRTCPAddr;    // local rtcp address
    CC_ADDR             ccRemoteRTPAddr;    // remote rtp address
    CC_ADDR             ccRemoteRTCPAddr;   // remote rtcp address
    CC_TERMCAP          ccTermCaps;         // channel capabilities
    BYTE                bPayloadType;       // rtp payload type
    BYTE                bSessionID;         // rtp session id
    BOOL                fInbound;           // inbound channel
    struct _H323_CALL * pCall;              // containing call object

} H323_CHANNEL, *PH323_CHANNEL;

typedef struct _H323_CHANNEL_TABLE {

    DWORD           dwNumSlots;             // number of entries
    DWORD           dwNumInUse;             // number of entries in use
    DWORD           dwNumAllocated;         // number of entries allocated
    DWORD           dwNextAvailable;        // next available table index 
    PH323_CHANNEL   pChannels[ANYSIZE];     // array of object pointers

} H323_CHANNEL_TABLE, *PH323_CHANNEL_TABLE;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323IsChannelAllocated(_pChannel_) \
    ((_pChannel_) != NULL)

#define H323IsChannelInUse(_pChannel_) \
    (H323IsChannelAllocated(_pChannel_) && \
     ((_pChannel_)->nState > H323_CHANNELSTATE_ALLOCATED))

#define H323IsChannelOpen(_pChannel_) \
    (H323IsChannelAllocated(_pChannel_) && \
     ((_pChannel_)->nState == H323_CHANNELSTATE_OPENED))

#define H323IsChannelEqual(_pChannel_,_hccChannel_) \
    (H323IsChannelInUse(_pChannel_) && \
     ((_hccChannel_) == ((_pChannel_)->hccChannel)))

#define H323IsSessionIDEqual(_pChannel_,_bSessionID_) \
    (H323IsChannelInUse(_pChannel_) && \
     ((_bSessionID_) == ((_pChannel_)->bSessionID)))

#define H323IsChannelInbound(_pChannel_) \
    ((_pChannel_)->fInbound == TRUE)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323OpenChannel(
    PH323_CHANNEL pChannel
    );
        
BOOL
H323CloseChannel(
    PH323_CHANNEL pChannel
    );
        
BOOL
H323AllocChannelTable(
    PH323_CHANNEL_TABLE * ppChannelTable
    );

BOOL
H323FreeChannelTable(
    PH323_CHANNEL_TABLE pChannelTable
    );
        
BOOL
H323CloseChannelTable(
    PH323_CHANNEL_TABLE pChannelTable
    );

BOOL
H323AllocChannelFromTable(
    PH323_CHANNEL *       ppChannel,
    PH323_CHANNEL_TABLE * ppChannelTable,
    struct _H323_CALL *   pCall
    );
        
BOOL
H323FreeChannelFromTable(
    PH323_CHANNEL       pChannel,
    PH323_CHANNEL_TABLE pChannelTable
    );

BOOL
H323LookupChannelByHandle(
    PH323_CHANNEL *     ppChannel,
    PH323_CHANNEL_TABLE pChannelTable,
    CC_HCHANNEL         hccChannel
    );

BOOL
H323LookupChannelBySessionID(
    PH323_CHANNEL *     ppChannel,
    PH323_CHANNEL_TABLE pChannelTable,
    BYTE                bSessionID
    );

BOOL
H323AreThereOutgoingChannels(
    PH323_CHANNEL_TABLE pChannelTable,
    BOOL                fIgnoreOpenChannels
    );

#endif // _INC_CHANNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\config.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    config.h

Abstract:

    Definitions for H.323 TAPI Service Provider UI.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_CONFIG
#define _INC_CONFIG

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Function prototype                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT_PTR
CALLBACK
ProviderConfigDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// String definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define IDC_STATIC              (-1)

#define IDS_LINENAME            1
#define IDS_PROVIDERNAME        2
#define IDS_REGOPENKEY          3

#define IDD_TSPCONFIG           10
#define IDC_GATEWAY_GROUP       11
#define IDI_PHONE               12
#define IDC_USEGATEWAY          13
#define IDC_H323_GATEWAY        14

#define IDC_PROXY_GROUP         15
#define IDI_PROXY               16
#define IDC_USEPROXY            17
#define IDC_H323_PROXY          18

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Help Support                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323SP_HELP_FILE                    TEXT("tapi.hlp")

#define IDH_NOHELP                          ((DWORD) -1)
#define IDH_H323SP_USE_GATEWAY              10001
#define IDH_H323SP_USE_PROXY                10002
#define IDH_H323SP_USE_GATEWAY_COMPUTER     10003
#define IDH_H323SP_USE_PROXY_COMPUTER       10004

#endif // _INC_CONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\confcall.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confcall.c

Abstract:

    TAPI Service Provider functions related to conference calls.

        TSPI_lineAddToConference        
        TSPI_lineCompleteTransfer
        TSPI_linePrepareAddToConference
        TSPI_lineRemoveFromConference
        TSPI_lineSetupConference

Environment:

    User Mode - Win32

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI procedures                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
TSPIAPI
TSPI_lineAddToConference(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdConfCall,
    HDRVCALL      hdConsultCall
    )
    
/*++

Routine Description:

    This function adds the call specified by hdConsultCall to the conference 
    call specified by hdConfCall.

    Note that the call handle of the added party remains valid after adding 
    the call to a conference; its state will typically change to conferenced 
    while the state of the conference call will typically become connected.  
    The handle to an individual participating call can be used later to remove 
    that party from the conference call using TSPI_lineRemoveFromConference. 

    The call states of the calls participating in a conference are not 
    independent. For example, when dropping a conference call, all 
    participating calls may automatically become idle. The TAPI DLL may consult
    the line's device capabilities to determine what form of conference removal 
    is available. The TAPI DLL or its client applications should track the 
    LINE_CALLSTATE messages to determine what really happened to the calls 
    involved.
    
    The conference call is established either via TSPI_lineSetupConference or 
    TSPI_lineCompleteTransfer. The call added to a conference will typically be
    established using TSPI_lineSetupConference or 
    TSPI_linePrepareAddToConference. Some switches may allow adding of an 
    arbitrary calls to conference, and such a call may have been set up using 
    TSPI_lineMakeCall and be on (hard) hold.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdConfCall - Specifies the Service Provider's opaque handle to the 
        conference call.  Valid call states: onHoldPendingConference, onHold.

    hdAddCall - Specifies the Service Provider's opaque handle to the call to 
        be added to the conference call.  Valid call states: connected, onHold.        

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred.  Possible error returns are: 
    
        LINEERR_INVALCONFCALLHANDLE - The specified call handle for the 
            conference call is invalid or is not a handle for a conference 
            call.

        LINEERR_INVALCALLHANDLE - The specified call handle for the added 
            call is invalid.

        LINEERR_INVALCALLSTATE - One or both of the specified calls are not 
            in a valid state for the requested operation.

        LINEERR_CONFERENCEFULL - The maximum number of parties for a 
            conference has been reached.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG
TSPIAPI
TSPI_lineCompleteTransfer(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall,
    HDRVCALL      hdConsultCall,
    HTAPICALL     htConfCall,
    LPHDRVCALL    lphdConfCall,
    DWORD         dwTransferMode
    )
    
/*++

Routine Description:

    This function completes the transfer of the specified call to the party 
    connected in the consultation call.
    
    This operation completes the transfer of the original call, hdCall, to 
    the party currently connected via hdConsultCall. The consultation call 
    will typically have been dialed on the consultation call allocated as 
    part of TSPI_lineSetupTransfer, but it may be any call to which the 
    switch is capable of transferring hdCall.

    The transfer request can be resolved either as a transfer or as a 
    three-way conference call. When resolved as a transfer, the parties 
    connected via hdCall and hdConsultCall will be connected to each other, 
    and both hdCall and hdConsultCall will typically be removed from the line 
    they were on and both will transition to the idle state. Note that the 
    Service Provider's opaque handles for these calls must remain valid after 
    the transfer has completed.  The TAPI DLL causes these handles to be 
    invalidated when it is no longer interested in them using 
    TSPI_lineCloseCall.

    When resolved as a conference, all three parties will enter in a 
    conference call. Both existing call handles remain valid, but will 
    transition to the conferenced state. A conference call handle will created
    and returned, and it will transition to the connected state.
    
    It may also be possible to perform a blind transfer of a call using 
    TSPI_lineBlindTransfer.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call to be 
        transferred.  Valid call states: onHoldPendingTransfer.

    hdConsultCall - Specifies a handle to the call that represents a connection
        with the destination of the transfer.  Valid call states: connected, 
        ringback, busy.

    htConfCall - Specifies the TAPI DLL's opaque handle to the new call.  If 
        dwTransferMode is specified as LINETRANSFERMODE_CONFERENCE then the 
        Service Provider must save this and use it in all subsequent calls to 
        the LINEEVENT procedure reporting events on the call.  Otherwise this 
        parameter is ignored.

    lphdConfCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for the call.   If dwTransferMode is 
        specified as LINETRANSFERMODE_CONFERENCE then the Service Provider must
        fill this location with its opaque handle for the new conference call 
        before this procedure returns, whether it decides to execute the 
        request sychronously or asynchronously.  This handle is invalid if the
        function results in an error (either synchronously or asynchronously).  
        If dwTransferMode is some other value this parameter is ignored.

    dwTransferMode - Specifies how the initiated transfer request is to be 
        resolved, of type LINETRANSFERMODE. Values are:

        LINETRANSFERMODE_TRANSFER - Resolve the initiated transfer by 
            transferring the initial call to the consultation call.

        LINETRANSFERMODE_CONFERENCE - Resolve the initiated transfer by 
            conferencing all three parties into a three-way conference call. 
            A conference call is created and returned to the TAPI DLL.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred.  Possible error returns are:
    
        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALCONSULTCALLHANDLE - The specified consultation call 
            handle is invalid.

        LINEERR_INVALCALLSTATE - One or both calls are not in a valid state 
            for the requested operation.

        LINEERR_INVALTRANSFERMODE - The specified transfer mode parameter is 
            invalid.

        LINEERR_INVALPOINTER - The specified pointer parameter is invalid.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG
TSPIAPI
TSPI_linePrepareAddToConference(
    DRV_REQUESTID    dwRequestID,
    HDRVCALL         hdConfCall,
    HTAPICALL        htConsultCall,
    LPHDRVCALL       lphdConsultCall,
    LPLINECALLPARAMS const lpCallParams
    )
    
/*++

Routine Description:

    This function prepares an existing conference call for the addition of 
    another party.  It creates a new, temporary consultation call.  The new 
    consulatation call can be subsequently added to the conference call.

    A conference call handle can be obtained via TSPI_lineSetupConference or 
    via TSPI_lineCompleteTransfer that is resolved as a three-way conference 
    call. The function TSPI_linePrepareAddToConference typically places the 
    existing conference call in the onHoldPendingConference state and creates 
    a consultation call that can be added later to the existing conference 
    call via TSPI_lineAddToConference. 
    
    The consultation call can be canceled using TSPI_lineDrop. It may also 
    be possible for the TAPI DLL to swap between the consultation call and 
    the held conference call via TSPI_lineSwapHold.
    
    The Service Provider initially does media monitoring on the new call for
    at least the set of media modes that were monitored for on the line.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdConfCall - Specifies the Service Provider's opaque handle to a 
        conference call.  Valid call states: connected.

    htAddCall - Specifies the TAPI DLL's opaque handle to the new, temporary 
        consultation call.  The Service Provider must save this and use it in 
        all subsequent calls to the LINEEVENT procedure reporting events on 
        the new call.

    lphdAddCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for the new, temporary consultation 
        call.  The Service Provider must fill this location with its opaque 
        handle for the new call before this procedure returns, whether it 
        decides to execute the request sychronously or asynchronously.  This 
        handle is invalid if the function results in an error (either 
        synchronously or asynchronously).

    lpCallParams - Specifies a far pointer to call parameters to be used when 
        establishing the consultation call. This parameter may be set to NULL 
        if no special call setup parameters are desired.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCONFCALLHANDLE - The specified call handle for the 
            conference call is invalid.

        LINEERR_INVALPOINTER - One or more of the specified pointer 
            parameters are invalid.

        LINEERR_INVALCALLSTATE - The conference call is not in a valid state 
            for the requested operation.

        LINEERR_CALLUNAVAIL - All call appearances on the specified address 
            are currently allocated.

        LINEERR_CONFERENCEFULL - The maximum number of parties for a 
            conference has been reached.

        LINEERR_INVALCALLPARAMS - The specified call parameters are invalid.
    
        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG
TSPIAPI
TSPI_lineSetupConference(
    DRV_REQUESTID    dwRequestID,
    HDRVCALL         hdCall,
    HDRVLINE         hdLine,
    HTAPICALL        htConfCall,
    LPHDRVCALL       lphdConfCall,
    HTAPICALL        htConsultCall,
    LPHDRVCALL       lphdConsultCall,
    DWORD            dwNumParties,
    LPLINECALLPARAMS const lpCallParams
    )
    
/*++

Routine Description:

    This function sets up a conference call for the addition of the third 
    party. 

    TSPI_lineSetupConference provides two ways for establishing a new 
    conference call, depending on whether a normal two-party call is required 
    to pre-exist or not. When setting up a conference call from an existing 
    two-party call, the hdCall parameter is a valid call handle that is 
    initially added to the conference call by the TSPI_lineSetupConference 
    request and hdLine is ignored. On switches where conference call setup 
    does not start with an existing call, hdCall must be NULL and hdLine 
    must be specified to identify the line device on which to initiate the 
    conference call.  In either case, a consultation call is allocated for 
    connecting to the party that is to be added to the call. The TAPI DLL 
    can use TSPI_lineDial to dial the address of the other party.
    
    The conference call will typically transition into the 
    onHoldPendingConference state, the consultation call dialtone state and 
    the initial call (if one) into the conferenced state.
    
    A conference call can also be set up via a TSPI_lineCompleteTransfer that 
    is resolved into a three-way conference.
    
    The TAPI DLL may be able to toggle between the consultation call and the 
    conference call by using TSPI_lineSwapHold.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the initial 
        call that identifies the first party of a conference call. In some 
        environments, a call must exist in order to start a conference call. 
        In other telephony environments, no call initially exists and hdCall 
        is left NULL.  Valid call states: connected.

    hdLine - Specifies the Service Provider's opaque handle to the line device 
        on which to originate the conference call if hdCall is NULL.  The 
        hdLine parameter is ignored if hdCall is non-NULL.  The Service 
        Provider reports which model it supports through the setupConfNull 
        flag of the LINEADDRESSCAPS data structure.

    htConfCall - Specifies the TAPI DLL's opaque handle to the new conference 
        call.  The Service Provider must save this and use it in all subsequent 
        calls to the LINEEVENT procedure reporting events on the new call.

    lphdConfCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for the newly created conference 
        call.  The Service Provider must fill this location with its opaque 
        handle for the new call before this procedure returns, whether it 
        decides to execute the request sychronously or asynchronously.  This 
        handle is invalid if the function results in an error (either 
        synchronously or asynchronously).

    htAddCall - Specifies the TAPI DLL's opaque handle to a new call.  When 
        setting up a call for the addition of a new party, a new temporary call
        (consultation call) is automatically allocated.  The Service Provider 
        must save the htAddCall and use it in all subsequent calls to the 
        LINEEVENT procedure reporting events on the new consultation call.

    lphdAddCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for a call.  When setting up a call 
        for the addition of a new party, a new temporary call (consultation 
        call) is automatically allocated. The Service Provider must fill this 
        location with its opaque handle for the new consultation call before 
        this procedure returns, whether it decides to execute the request 
        sychronously or asynchronously.  This handle is invalid if the 
        function results in an error (either synchronously or asynchronously).

    dwNumParties - Specifies the expected number of parties in the conference 
        call.  The service provider is free to do with this number as it 
        pleases; ignore it, use it a hint to allocate the right size 
        conference bridge inside the switch, etc.

    lpCallParams - Specifies a far pointer to call parameters to be used when 
        establishing the consultation call. This parameter may be set to NULL 
        if no special call setup parameters are desired.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle for the conference 
            call is invalid.  This error may also indicate that the telephony 
            environment requires an initial call to set up a conference but a 
            NULL call handle was supplied.

        LINEERR_INVALLINEHANDLE - The specified line handle for the line 
            containing the conference call is invalid.  This error may also 
            indicate that the telephony environment requires an initial line 
            to set up a conference but a non-NULL call handle was supplied 
            instead.

        LINEERR_INVALCALLSTATE - The call is not in a valid state for the 
            requested operation.

        LINEERR_CALLUNAVAIL - All call appearances on the specified address 
            are currently allocated.

        LINEERR_CONFERENCEFULL - The requested number of parties cannot be 
            satisfied.

        LINEERR_INVALPOINTER - One or more of the specified pointer 
            parameters are invalid.
    
        LINEERR_INVALCALLPARAMS - The specified call parameters are invalid.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG
TSPIAPI
TSPI_lineRemoveFromConference(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall
    )
    
/*++

Routine Description:

    This function removes the specified call from the conference call to 
    which it currently belongs. The remaining calls in the conference 
    call are unaffected.

    This operation removes a party that currently belongs to a conference 
    call. After the call has been successfully removed, it may be possible 
    to further manipulate it using its handle. The availability of this 
    operation and its result are likely to be limited in many 
    implementations. For example, in many implementations, only the most 
    recently added party may be removed from a conference, and the removed 
    call may be automatically dropped (becomes idle). Consult the line's 
    device capabilities to determine the available effects of removing a 
    call from a conference.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call 
        to be removed from the conference.  Valid call states: conferenced.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.
        
        LINEERR_INVALCALLSTATE - The call is not in a valid state for the 
            requested operation.
    
        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reasons.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\config.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    config.c

Abstract:

    TAPI Service Provider functions related to tsp config.

        TSPI_providerConfig

        TUISPI_providerConfig

Environment:

    User Mode - Win32

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef UNICODE
#define UNICODE         // make this a UNICODE module...
#endif

#ifndef _UNICODE
#define _UNICODE        // make this a UNICODE module...
#endif

#include "globals.h"
#include "provider.h"
#include "callback.h"
#include "registry.h"
#include "termcaps.h"
#include "version.h"
#include "line.h"
#include "config.h"
#include <tchar.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT_PTR
CALLBACK
ProviderConfigDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HKEY hKey;
    LONG lStatus;
    DWORD dwValue;
    DWORD dwValueSize;
    DWORD dwValueType;
    LPTSTR pszValue;
    TCHAR szAddr[H323_MAXDESTNAMELEN];

   static const DWORD IDD_GATEWAY_HelpIDs[]=
   {
        IDC_GATEWAY_GROUP,      IDH_H323SP_USE_GATEWAY,                         // group
        IDC_USEGATEWAY,         IDH_H323SP_USE_GATEWAY,                         // checkbox
        IDC_H323_GATEWAY,       IDH_H323SP_USE_GATEWAY_COMPUTER,    // edit box
        IDC_PROXY_GROUP,        IDH_H323SP_USE_PROXY,                           // group
        IDC_USEPROXY,           IDH_H323SP_USE_PROXY,                           // checkbox
        IDC_H323_PROXY,         IDH_H323SP_USE_PROXY_COMPUTER,      // edit box
        IDC_STATIC,             IDH_NOHELP,                                                     // graphic(s)
        0,                      0
    };

    // decode
    switch (uMsg) {

    case WM_HELP:

        // F1 key or the "?" button is pressed
        (void) WinHelp(
                    ((LPHELPINFO) lParam)->hItemHandle,
                    H323SP_HELP_FILE,
                    HELP_WM_HELP,
                    (DWORD_PTR) (LPVOID)IDD_GATEWAY_HelpIDs
                    );

        break;

    case WM_CONTEXTMENU:

        // Right-mouse click on a dialog control
        (void) WinHelp(
                    (HWND) wParam,
                    H323SP_HELP_FILE,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR) (LPVOID) IDD_GATEWAY_HelpIDs
                    );

        break;

    case WM_INITDIALOG:

        // open registry subkey
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    H323_REGKEY_ROOT,
                    0,
                    KEY_READ,
                    &hKey
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS) {

            TCHAR szErrorMsg[256];

            H323DBG((
                DEBUG_LEVEL_WARNING,
                "error 0x%08lx opening tsp registry key.\n",
                lStatus
                ));

            // load error string
            LoadString(g_hInstance,
                        IDS_REGOPENKEY,
                        szErrorMsg,
                        sizeof(szErrorMsg)
                        );

            // pop up error dialog
            MessageBox(hDlg,szErrorMsg,NULL,MB_OK);

            // stop dialog
            EndDialog(hDlg, 0);

            break;
        }

        // initialize value name
        pszValue = H323_REGVAL_GATEWAYADDR;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus == ERROR_SUCCESS) {

            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_GATEWAY,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_GATEWAYENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS) {

            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEGATEWAY,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string
        EnableWindow(
            GetDlgItem(hDlg,IDC_H323_GATEWAY),
            (dwValue != 0)
            );

        // initialize value name
        pszValue = H323_REGVAL_PROXYADDR;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus == ERROR_SUCCESS) {

            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_PROXY,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_PROXYENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS) {

            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEPROXY,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string
        EnableWindow(
            GetDlgItem(hDlg,IDC_H323_PROXY),
            (dwValue != 0)
            );

        // close registry
        RegCloseKey(hKey);

        break;

    case WM_COMMAND:

        // decode command
        switch (LOWORD(wParam)) {

        case IDOK:

            // open registry subkey
            lStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        H323_REGKEY_ROOT,
                        0,
                        KEY_WRITE,
                        &hKey
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS) {

                TCHAR szErrorMsg[256];

                H323DBG((
                    DEBUG_LEVEL_WARNING,
                    "error 0x%08lx opening tsp registry key.\n",
                    lStatus
                    ));

                // load error string
                LoadString(g_hInstance,
                           IDS_REGOPENKEY,
                           szErrorMsg,
                           sizeof(szErrorMsg)
                           );

                // pop up error dialog
                MessageBox(hDlg,szErrorMsg,NULL,MB_OK);

                // stop dialog
                EndDialog(hDlg, 0);

                break;
            }

            // initialize value name
            pszValue = H323_REGVAL_GATEWAYADDR;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_GATEWAY,szAddr,sizeof(szAddr));

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (_tcslen(szAddr) + 1) * sizeof(TCHAR);

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS) {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gateway address\n",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_GATEWAYENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEGATEWAY,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS) {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gateway flag\n",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_PROXYADDR;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_PROXY,szAddr,sizeof(szAddr));

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (_tcslen(szAddr) + 1) * sizeof(TCHAR);

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS) {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing proxy address\n",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_PROXYENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEPROXY,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS) {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing proxy flag\n",
                    lStatus
                    ));
            }

            // close registry
            RegCloseKey(hKey);

            // close dialog
            EndDialog(hDlg, 0);
            break;

        case IDCANCEL:

            // close dialog
            EndDialog(hDlg, 0);
            break;

        case IDC_USEGATEWAY:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_GATEWAY),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEGATEWAY,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));

            break;

        case IDC_USEPROXY:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_PROXY),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEPROXY,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));

            break;
        }

        break;
    }

    // success
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI procedures                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
TSPIAPI
TSPI_providerConfig(
    HWND  hwndOwner,
    DWORD dwPermanentProviderID
    )

/*++

Routine Description:

    The original TSPI UI-generating functions (TSPI_lineConfigDialog,
    TSPI_lineConfigDialogEdit, TSPI_phoneConfigDialog, TSPI_providerConfig,
    TSPI_providerInstall, and TSPI_providerRemove) are obsolete and will
    never be called by TAPISRV.EXE.  However, if the service provider desires
    to be listed as one that can be added by the Telephony control panel,
    it must export TSPI_providerInstall; if it wants to have the Remove
    button enabled in the Telephony CPL when it is selected, it must export
    TSPI_providerRemove, and it if wants the Setup button to be enabled
    in the Telephony CPL when it is selected, it must export
    TSPI_providerConfig.

    The Telephony CPL checks for the presence of these functions in the
    service provider TSP file in order to adjust its user interface to
    reflect which operations can be performed.

    See TUISPI_lineConfigDialog for dialog code.

Arguments:

    hwndOwner - Specifies the handle of the parent window in which the function
        may create any dialog windows required during the configuration.

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        configured.

Return Values:

    Returns zero if the request is successful or a negative error number if
    an error has occurred. Possible return values are:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    UNREFERENCED_PARAMETER(hwndOwner);              // no dialog here
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // not needed anymore

    // success
    return NOERROR;
}


LONG
TSPIAPI
TUISPI_providerConfig(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND              hwndOwner,
    DWORD             dwPermanentProviderID
    )
{
    INT_PTR nResult;

    UNREFERENCED_PARAMETER(pfnUIDLLCallback);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    // invoke dialog box
    nResult = DialogBoxW(
                g_hInstance,
                MAKEINTRESOURCE(IDD_TSPCONFIG),
                hwndOwner,
                ProviderConfigDlgProc,
                );

    // status based on whether dialog executed properly
    return ((DWORD)nResult == 0) ? NOERROR : LINEERR_OPERATIONFAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\debug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug definitions for H.323 TAPI Service Provider.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_DEBUG
#define _INC_DEBUG
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern DWORD g_dwLogLevel;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Debug definitions                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEBUG_LEVEL_SILENT      0x0
#define DEBUG_LEVEL_FATAL       0x1
#define DEBUG_LEVEL_ERROR       0x2
#define DEBUG_LEVEL_WARNING     0x3
#define DEBUG_LEVEL_TRACE       0x4
#define DEBUG_LEVEL_VERBOSE     0x5

#define DEBUG_OUTPUT_NONE       0x0
#define DEBUG_OUTPUT_FILE       0x1   
#define DEBUG_OUTPUT_DEBUGGER   0x2

#define H323_DEBUG_LOGTYPE      DEBUG_OUTPUT_FILE | DEBUG_OUTPUT_DEBUGGER
#define H323_DEBUG_LOGLEVEL     DEBUG_LEVEL_SILENT
#define H323_DEBUG_LOGFILE      "H323DBG.LOG"
#define H323_DEBUG_MAXPATH      128

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
H323DbgPrint(
    DWORD dwLevel, 
    LPSTR szFormat, 
    ...
    );

#if DBG
#define H323DBG(_x_)            H323DbgPrint _x_
#else
#define H323DBG(_x_)
#endif

PSTR
H323StatusToString(
    DWORD dwStatus
    );

PSTR
H323IndicationToString(
    BYTE bIndication
    );

PSTR
H323CallStateToString(
    DWORD dwCallState
    );

PSTR
H323FeedbackToString(
    DWORD dwStatus
    );

PSTR
H245StatusToString(
    DWORD dwStatus
    );

PSTR
CCRejectReasonToString(
    DWORD dwReason
    );

PSTR
H323DirToString(
    DWORD dwDir
    );

PSTR
H323DataTypeToString(
    DWORD dwDataType
    );

PSTR
H323ClientTypeToString(
    DWORD dwClientType
    );

PSTR
H323MiscCommandToString(
    DWORD dwMiscCommand
    );

PSTR
H323MSPCommandToString(
    DWORD dwCommand
    );

PSTR
H323AddressTypeToString(
    DWORD dwAddressType
    );

#endif // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\debug.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Routines for displaying debug messages.

Environment:

    User Mode - Win32

--*/

#if DBG

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "provider.h"
#include "registry.h"
#include <stdio.h>
#include <stdarg.h>
#include <crtdbg.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEBUG_FORMAT_HEADER     "H323 "
#define DEBUG_FORMAT_TIMESTAMP  "[%02u:%02u:%02u.%03u"
#define DEBUG_FORMAT_THREADID   ",tid=%x] "

#define MAX_DEBUG_STRLEN        512

#define STATUS_MASK_ERROR       0x0000FFFF
#define STATUS_MASK_FACILITY    0x0FFF0000


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
OutputDebugMessage(
    LPSTR pszDebugMessage
    )

/*++

Routine Description:

    Writes debug message to specified log(s).

Args:

    pszDebugMessage - zero-terminated string containing debug message.

Return Values:

    None.

--*/

{
    // initialize descriptor
    static FILE * fd = NULL;

    // check if logfile output specified
    if (g_RegistrySettings.dwLogType & DEBUG_OUTPUT_FILE) {

        // validate
        if (fd == NULL) {

            // attempt to open log file
            fd = fopen(g_RegistrySettings.szLogFile, "w");
        }

        // validate
        if (fd != NULL) {

            // output entry to stream
            fprintf(fd, "%s", pszDebugMessage);

            // flush stream
            fflush(fd);
        }
    }

    // check if debugger output specified
    if (g_RegistrySettings.dwLogType & DEBUG_OUTPUT_DEBUGGER) {

        // output entry to debugger
        OutputDebugStringA(pszDebugMessage);
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
H323DbgPrint(
    DWORD dwLevel, 
    LPSTR szFormat, 
    ...
    )
        
/*++

Routine Description:

    Debug output routine for service provider.

Arguments:

    Same as printf.

Return Values:

    None.   
    
--*/

{
    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[MAX_DEBUG_STRLEN+1];
    int nLengthRemaining;
    int nLength = 0;

    // see if level enabled
    if (dwLevel <= g_RegistrySettings.dwLogLevel) {    

        // retrieve local time
        GetLocalTime(&SystemTime);    

        // add component header to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_HEADER
                           );

        // add timestamp to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_TIMESTAMP,
                           SystemTime.wHour,
                           SystemTime.wMinute,
                           SystemTime.wSecond,
                           SystemTime.wMilliseconds
                           ); 

        // add thread id to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_THREADID,
                           GetCurrentThreadId()
                           );

        // point at first argument
        va_start(Args, szFormat);

        // determine number of bytes left in buffer
        nLengthRemaining = sizeof(szDebugMessage) - nLength;

        // add user specified debug message 
        _vsnprintf(&szDebugMessage[nLength], 
                   nLengthRemaining, 
                   szFormat, 
                   Args
                   );

        // release pointer
        va_end(Args);

        // output message to specified sink
        OutputDebugMessage(szDebugMessage);
    }
}


PSTR
H323IndicationToString(
    BYTE bIndication
    )
        
/*++

Routine Description:

    Converts indication from call control module to string.

Arguments:

    bIndication - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszIndicationStrings[] = {
                    NULL,
                    "CC_RINGING_INDICATION",
                    "CC_CONNECT_INDICATION",
                    "CC_TX_CHANNEL_OPEN_INDICATION",
                    "CC_RX_CHANNEL_REQUEST_INDICATION",
                    "CC_RX_CHANNEL_CLOSE_INDICATION",
                    "CC_MUTE_INDICATION",
                    "CC_UNMUTE_INDICATION",
                    "CC_PEER_ADD_INDICATION",
                    "CC_PEER_DROP_INDICATION",
                    "CC_PEER_CHANGE_CAP_INDICATION",
                    "CC_CONFERENCE_TERMINATION_INDICATION",
                    "CC_HANGUP_INDICATION",
                    "CC_RX_NONSTANDARD_MESSAGE_INDICATION",
                    "CC_MULTIPOINT_INDICATION",
                    "CC_PEER_UPDATE_INDICATION",
                    "CC_H245_MISCELLANEOUS_COMMAND_INDICATION",
                    "CC_H245_MISCELLANEOUS_INDICATION_INDICATION",
                    "CC_H245_CONFERENCE_REQUEST_INDICATION",
                    "CC_H245_CONFERENCE_RESPONSE_INDICATION",
                    "CC_H245_CONFERENCE_COMMAND_INDICATION",
                    "CC_H245_CONFERENCE_INDICATION_INDICATION",
                    "CC_FLOW_CONTROL_INDICATION",
                    "CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION",
                    "CC_REQUEST_MODE_INDICATION",
                    "CC_REQUEST_MODE_RESPONSE_INDICATION",
                    "CC_VENDOR_ID_INDICATION",
                    "CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION",
                    "CC_T120_CHANNEL_REQUEST_INDICATION",
                    "CC_T120_CHANNEL_OPEN_INDICATION",
                    "CC_BANDWIDTH_CHANGED_INDICATION",
                    "CC_ACCEPT_CHANNEL_INDICATION",
                    "CC_TERMINAL_ID_REQUEST_INDICATION"
                    };

    // make sure index value within bounds
    return (bIndication < H323GetNumStrings(apszIndicationStrings))
                ? apszIndicationStrings[bIndication]
                : NULL
                ;  
}        


PSTR
CCStatusToString(
    DWORD dwStatus
    )
        
/*++

Routine Description:

    Converts call control status to string.

Arguments:

    dwStatus - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszCCStatusStrings[] = {
                    NULL,
                    "CC_PEER_REJECT",
                    "CC_BAD_PARAM",
                    "CC_BAD_SIZE",
                    "CC_ACTIVE_CONNECTIONS",
                    "CC_INTERNAL_ERROR",
                    "CC_NOT_IMPLEMENTED",
                    "CC_DUPLICATE_CONFERENCE_ID",
                    "CC_ILLEGAL_IN_MULTIPOINT",
                    "CC_NOT_MULTIPOINT_CAPABLE",
                    "CC_PEER_CANCEL",
                    NULL,
                    NULL,
                    NULL,
                    "CC_NO_MEMORY",
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    "CC_GKI_STATE",
                    "CC_GKI_CALL_STATE",
                    "CC_GKI_LISTEN_NOT_FOUND",
                    "CC_GATEKEEPER_REFUSED",
                    "CC_INVALID_WITHOUT_GATEKEEPER",
                    "CC_GKI_IP_ADDRESS",
                    "CC_GKI_LOAD"
                    };

    // adjust code within bounds
    dwStatus -= ERROR_LOCAL_BASE_ID;

    // make sure index value within bounds
    return (dwStatus < H323GetNumStrings(apszCCStatusStrings))
                ? apszCCStatusStrings[dwStatus]
                : NULL
                ;
}


PSTR
CCRejectReasonToString(
    DWORD dwReason
    )
{
	static PSTR apszCCRejectReasonStrings[] = {
		NULL,
		"CC_REJECT_NO_BANDWIDTH",
		"CC_REJECT_GATEKEEPER_RESOURCES",
		"CC_REJECT_UNREACHABLE_DESTINATION",
		"CC_REJECT_DESTINATION_REJECTION",
		"CC_REJECT_INVALID_REVISION",
		"CC_REJECT_NO_PERMISSION",
		"CC_REJECT_UNREACHABLE_GATEKEEPER",
		"CC_REJECT_GATEWAY_RESOURCES",
		"CC_REJECT_BAD_FORMAT_ADDRESS",
		"CC_REJECT_ADAPTIVE_BUSY",
		"CC_REJECT_IN_CONF",
		"CC_REJECT_ROUTE_TO_GATEKEEPER",
		"CC_REJECT_CALL_FORWARDED",
		"CC_REJECT_ROUTE_TO_MC",
		"CC_REJECT_UNDEFINED_REASON",
		"CC_REJECT_INTERNAL_ERROR",
		"CC_REJECT_NORMAL_CALL_CLEARING",
		"CC_REJECT_USER_BUSY",
		"CC_REJECT_NO_ANSWER",
		"CC_REJECT_NOT_IMPLEMENTED",
		"CC_REJECT_MANDATORY_IE_MISSING",
		"CC_REJECT_INVALID_IE_CONTENTS",
		"CC_REJECT_TIMER_EXPIRED",
		"CC_REJECT_CALL_DEFLECTION",
		"CC_REJECT_GATEKEEPER_TERMINATED"
	};

	// make sure index value within bounds
	return (dwReason < H323GetNumStrings(apszCCRejectReasonStrings))
				? apszCCRejectReasonStrings[dwReason]
				: NULL
				;
}


PSTR
Q931StatusToString(
    DWORD dwStatus
    )
        
/*++

Routine Description:

    Converts Q.931 status to string.

Arguments:

    dwStatus - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszQ931StatusStrings[] = {
                    NULL,
                    "Q931_BAD_PARAM",
                    "Q931_DUPLICATE_LISTEN",
                    "Q931_INTERNAL_ERROR",
                    "Q931_BAD_SIZE",
                    "Q931_NO_MEMORY",
                    "Q931_NOT_IMPLEMENTED",
                    "Q931_NOT_INITIALIZED",
                    "Q931_DUPLICATE_INITIALIZE",
                    "Q931_SUBSYSTEM_FAILURE",
                    "Q931_OUT_OF_SEQUENCE",
                    "Q931_PEER_UNREACHABLE",
                    "Q931_SETUP_TIMER_EXPIRED",
                    "Q931_RINGING_TIMER_EXPIRED",
                    "Q931_INCOMPATIBLE_VERSION",
                    "Q931_OPTION_NOT_IMPLEMENTED",
                    "Q931_ENDOFINPUT",
                    "Q931_INVALID_FIELD",
                    "Q931_NO_FIELD_DATA",
                    "Q931_INVALID_PROTOCOL",
                    "Q931_INVALID_MESSAGE_TYPE",
                    "Q931_MANDATORY_IE_MISSING",
                    "Q931_BAD_IE_CONTENT"
                    };

    // adjust code within bounds
    dwStatus -= ERROR_LOCAL_BASE_ID;

    // make sure index value within bounds
    return (dwStatus < H323GetNumStrings(apszQ931StatusStrings))
                ? apszQ931StatusStrings[dwStatus]
                : NULL
                ;
}


PSTR
H245StatusToString(
    DWORD dwStatus
    )
        
/*++

Routine Description:

    Converts H.245 status to string.

Arguments:

    dwStatus - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszH245StatusStrings[] = {
                    NULL,
                    "H245_ERROR_INVALID_DATA_FORMAT",
                    "H245_ERROR_NOMEM",
                    "H245_ERROR_NOSUP",
                    "H245_ERROR_PARAM",
                    "H245_ERROR_ALREADY_INIT",
                    "H245_ERROR_NOT_CONNECTED",
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    "H245_ERROR_NORESOURCE",
                    "H245_ERROR_NOTIMP",
                    "H245_ERROR_SUBSYS",
                    "H245_ERROR_FATAL",
                    "H245_ERROR_MAXTBL",
                    "H245_ERROR_CHANNEL_INUSE",
                    "H245_ERROR_INVALID_CAPID",
                    "H245_ERROR_INVALID_OP",
                    "H245_ERROR_UNKNOWN",
                    "H245_ERROR_NOBANDWIDTH",
                    "H245_ERROR_LOSTCON",
                    "H245_ERROR_INVALID_MUXTBLENTRY",
                    "H245_ERROR_INVALID_INST",
                    "H245_ERROR_INPROCESS",
                    "H245_ERROR_INVALID_STATE",
                    "H245_ERROR_TIMEOUT",
                    "H245_ERROR_INVALID_CHANNEL",
                    "H245_ERROR_INVALID_CAPDESCID",
                    "H245_ERROR_CANCELED",
                    "H245_ERROR_MUXELEMENT_DEPTH",
                    "H245_ERROR_MUXELEMENT_WIDTH",
                    "H245_ERROR_ASN1",
                    "H245_ERROR_NO_MUX_CAPS",
                    "H245_ERROR_NO_CAPDESC"
                    };

    // remove error base id
    dwStatus -= ERROR_BASE_ID;

    // make sure index value within bounds
    return (dwStatus < H323GetNumStrings(apszH245StatusStrings))
                ? apszH245StatusStrings[dwStatus]
                : NULL
                ;
}


PSTR
WinsockStatusToString(
    DWORD dwStatus
    )
        
/*++

Routine Description:

    Converts winsock status to string.

Arguments:

    dwStatus - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszWinsockStatusStrings[] = {
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    "WSAEINTR",               
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    "WSAEBADF",               
                    NULL,
                    NULL,
                    NULL,
                    "WSAEACCES",              
                    "WSAEFAULT",              
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    "WSAEINVAL",              
                    NULL,
                    "WSAEMFILE",              
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    "WSAEWOULDBLOCK",         
                    "WSAEINPROGRESS",         
                    "WSAEALREADY",            
                    "WSAENOTSOCK",            
                    "WSAEDESTADDRREQ",        
                    "WSAEMSGSIZE",            
                    "WSAEPROTOTYPE",          
                    "WSAENOPROTOOPT",         
                    "WSAEPROTONOSUPPORT",     
                    "WSAESOCKTNOSUPPORT",     
                    "WSAEOPNOTSUPP",          
                    "WSAEPFNOSUPPORT",        
                    "WSAEAFNOSUPPORT",        
                    "WSAEADDRINUSE",          
                    "WSAEADDRNOTAVAIL",       
                    "WSAENETDOWN",            
                    "WSAENETUNREACH",         
                    "WSAENETRESET",           
                    "WSAECONNABORTED",        
                    "WSAECONNRESET",          
                    "WSAENOBUFS",             
                    "WSAEISCONN",             
                    "WSAENOTCONN",            
                    "WSAESHUTDOWN",           
                    "WSAETOOMANYREFS",        
                    "WSAETIMEDOUT",           
                    "WSAECONNREFUSED",        
                    "WSAELOOP",               
                    "WSAENAMETOOLONG",        
                    "WSAEHOSTDOWN",           
                    "WSAEHOSTUNREACH",        
                    "WSAENOTEMPTY",           
                    "WSAEPROCLIM",            
                    "WSAEUSERS",              
                    "WSAEDQUOT",              
                    "WSAESTALE",              
                    "WSAEREMOTE"              
                    };

    // validate status
    if (dwStatus < WSABASEERR) {
        return NULL;
    }

    // adjust error code
    dwStatus -= WSABASEERR;

    // make sure index value within bounds
    return (dwStatus < H323GetNumStrings(apszWinsockStatusStrings))
                ? apszWinsockStatusStrings[dwStatus]
                : NULL
                ;
}


PSTR
H323StatusToString(
    DWORD dwStatus
    )
        
/*++

Routine Description:

    Converts status to string.

Arguments:

    dwStatus - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    DWORD dwFacility;

    static PSTR pszDefaultString = "ERROR";
    static PSTR pszNoErrorString = "NOERROR";

    // retrieve facility code from statuse code
    dwFacility = ((dwStatus & STATUS_MASK_FACILITY) >> 16);

    // check for success
    if (dwStatus == NOERROR) {

        // return success string
        return pszNoErrorString;

    } else if (dwFacility == FACILITY_CALLCONTROL) {

        // return call control status string    
        return CCStatusToString(dwStatus & STATUS_MASK_ERROR);

    } else if (dwFacility == FACILITY_Q931) {

        // return Q931 status string    
        return Q931StatusToString(dwStatus & STATUS_MASK_ERROR);

    } else if (dwFacility == FACILITY_H245) {

        // return H245 status string    
        return H245StatusToString(dwStatus & STATUS_MASK_ERROR);

    } else if (dwFacility == FACILITY_WINSOCK) {

        // return H245 status string    
        return WinsockStatusToString(dwStatus & STATUS_MASK_ERROR);

    } else {

        // return default string
        return pszDefaultString;
    }
}


PSTR
H323CallStateToString(
    DWORD dwCallState
    )
        
/*++

Routine Description:

    Converts tapi call state to string.

Arguments:

    dwCallState - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    DWORD i;
    DWORD dwBitMask;

    static PSTR apszCallStateStrings[] = {
                    "IDLE",
                    "OFFERING",
                    "ACCEPTED",
                    "DIALTONE",
                    "DIALING",
                    "RINGBACK",
                    "BUSY",
                    "SPECIALINFO",
                    "CONNECTED",
                    "PROCEEDING",
                    "ONHOLD",
                    "CONFERENCED",
                    "ONHOLDPENDCONF",
                    "ONHOLDPENDTRANSFER",
                    "DISCONNECTED",
                    "UNKNOWN"
                    };

    // keep shifting bit until the call state matchs the one specified
    for(i = 0, dwBitMask = 1; dwCallState != dwBitMask; i++, dwBitMask <<= 1)
        ;

    // return corresponding string
    return apszCallStateStrings[i];
}


PSTR
H323DirToString(
    DWORD dwDir
    )
        
/*++

Routine Description:

    Converts H.245 direction to string.

Arguments:

    dwDir - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszH245DirStrings[] = {
                    "H245_CAPDIR_DONTCARE",
                    "H245_CAPDIR_RMTRX",
                    "H245_CAPDIR_RMTTX",
                    "H245_CAPDIR_RMTRXTX",
                    "H245_CAPDIR_LCLRX",
                    "H245_CAPDIR_LCLTX",
                    "H245_CAPDIR_LCLRXTX"
                    };

    // make sure index value within bounds
    return (dwDir < H323GetNumStrings(apszH245DirStrings))
                ? apszH245DirStrings[dwDir]
                : NULL
                ;
}


PSTR
H323DataTypeToString(
    DWORD dwDataType
    )
        
/*++

Routine Description:

    Converts H.245 data type to string.

Arguments:

    dwDataType - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszH245DataTypeStrings[] = {
                    "H245_DATA_DONTCARE",
                    "H245_DATA_NONSTD",
                    "H245_DATA_NULL",
                    "H245_DATA_VIDEO",
                    "H245_DATA_AUDIO",
                    "H245_DATA_DATA",
                    "H245_DATA_ENCRYPT_D",
                    "H245_DATA_CONFERENCE",
                    "H245_DATA_MUX"
                    };

    // make sure index value within bounds
    return (dwDataType < H323GetNumStrings(apszH245DataTypeStrings))
                ? apszH245DataTypeStrings[dwDataType]
                : NULL
                ;
}


PSTR
H323ClientTypeToString(
    DWORD dwClientType
    )
        
/*++

Routine Description:

    Converts H.245 client type to string.

Arguments:

    dwClientType - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszH245ClientTypeStrings[] = {
                    "H245_CLIENT_DONTCARE", 
                    "H245_CLIENT_NONSTD",
                    "H245_CLIENT_VID_NONSTD",
                    "H245_CLIENT_VID_H261",
                    "H245_CLIENT_VID_H262",
                    "H245_CLIENT_VID_H263",
                    "H245_CLIENT_VID_IS11172",
                    "H245_CLIENT_AUD_NONSTD",
                    "H245_CLIENT_AUD_G711_ALAW64",
                    "H245_CLIENT_AUD_G711_ALAW56",
                    "H245_CLIENT_AUD_G711_ULAW64",
                    "H245_CLIENT_AUD_G711_ULAW56",
                    "H245_CLIENT_AUD_G722_64",
                    "H245_CLIENT_AUD_G722_56",
                    "H245_CLIENT_AUD_G722_48",
                    "H245_CLIENT_AUD_G723",
                    "H245_CLIENT_AUD_G728",
                    "H245_CLIENT_AUD_G729",
                    "H245_CLIENT_AUD_GDSVD",
                    "H245_CLIENT_AUD_IS11172",
                    "H245_CLIENT_AUD_IS13818",
                    "H245_CLIENT_DAT_NONSTD",
                    "H245_CLIENT_DAT_T120",
                    "H245_CLIENT_DAT_DSMCC",
                    "H245_CLIENT_DAT_USERDATA",
                    "H245_CLIENT_DAT_T84",
                    "H245_CLIENT_DAT_T434",
                    "H245_CLIENT_DAT_H224",
                    "H245_CLIENT_DAT_NLPID",
                    "H245_CLIENT_DAT_DSVD",
                    "H245_CLIENT_DAT_H222",
                    "H245_CLIENT_ENCRYPTION_TX",
                    "H245_CLIENT_ENCRYPTION_RX",
                    "H245_CLIENT_CONFERENCE",
                    "H245_CLIENT_MUX_NONSTD",
                    "H245_CLIENT_MUX_H222",
                    "H245_CLIENT_MUX_H223",
                    "H245_CLIENT_MUX_VGMUX",
                    "H245_CLIENT_MUX_H2250",
                    "H245_CLIENT_MUX_H223_ANNEX_A"
                    };

    // make sure index value within bounds
    return (dwClientType < H323GetNumStrings(apszH245ClientTypeStrings))
                ? apszH245ClientTypeStrings[dwClientType]
                : NULL
                ;
}


PSTR
H323MiscCommandToString(
    DWORD dwMiscCommand
    )
        
/*++

Routine Description:

    Converts H.245 command to string.

Arguments:

    dwMiscCommand - Miscellaneous H.245 command.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszH245MiscCommandStrings[] = {
                    "equaliseDelay",
                    "zeroDelay",
                    "multipointModeCommand",
                    "cnclMltpntMdCmmnd",
                    "videoFreezePicture",
                    "videoFastUpdatePicture",
                    "videoFastUpdateGOB",
                    "MCd_tp_vdTmprlSptlTrdOff",
                    "videoSendSyncEveryGOB",
                    "vdSndSyncEvryGOBCncl",
                    "videoFastUpdateMB"
                    };

    // make sure index value within bounds
    return (dwMiscCommand < H323GetNumStrings(apszH245MiscCommandStrings))
                ? apszH245MiscCommandStrings[dwMiscCommand]
                : "Unknown"
                ;
}


PSTR
H323MSPCommandToString(
    DWORD dwCommand
    )

/*++

Routine Description:

    Converts MSP command to string.

Arguments:

    Command - Type of MSP command.

Return Values:

    Returns string describing value.
    
--*/

{
    static PSTR apszMSPCommandStrings[] = {
                    "CMD_CHANNEL_OPEN",
                    "CMD_CHANNEL_OPEN_REPLY",
                    "CMD_CHANNEL_CLOSE",
                    "CMD_CALL_CONNECT",
                    "CMD_CALL_DISCONNECT",
                    "CMD_KEYFRAME"
                    };

    // make sure index value within bounds
    return (dwCommand < H323GetNumStrings(apszMSPCommandStrings))
                ? apszMSPCommandStrings[dwCommand]
                : NULL
                ;
}


PSTR
H323AddressTypeToString(
    DWORD dwAddressType
    )

/*++

Routine Description:

    Converts TAPI address type to string.

Arguments:

    dwAddressType - TAPI address type.

Return Values:

    Returns string describing value.
    
--*/

{
    switch (dwAddressType) {

    case LINEADDRESSTYPE_PHONENUMBER:
        return "PHONENUMBER";
    case LINEADDRESSTYPE_SDP:
        return "SDP";
    case LINEADDRESSTYPE_EMAILNAME:
        return "EMAILNAME";
    case LINEADDRESSTYPE_DOMAINNAME:
        return "DOMAINNAME";
    case LINEADDRESSTYPE_IPADDRESS:
        return "IPADDRESS";
    default:
        return "unknown";
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\h323tsp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    H323TSP.H

Abstract:

    Microsoft H.323 TAPI Service Provider Extensions.

Environment:

    User Mode - Win32

--*/

#ifndef _H323TSP_H_
#define _H323TSP_H_

#if _MSC_VER > 1000
#pragma once
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Extension version                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323TSP_CURRENT_VERSION     1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Structure definitions                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#pragma pack(push,1)

#define H245_MESSAGE_REQUEST        0
#define H245_MESSAGE_RESPONSE       1
#define H245_MESSAGE_COMMAND        2
#define H245_MESSAGE_INDICATION     3

typedef struct _H323_USERUSERINFO {

    DWORD   dwTotalSize;
    DWORD   dwH245MessageType;
    DWORD   dwUserUserInfoSize;
    DWORD   dwUserUserInfoOffset;
    BYTE    bCountryCode;
    BYTE    bExtension;
    WORD    wManufacturerCode;

} H323_USERUSERINFO, * PH323_USERUSERINFO;

#pragma pack(pop)

#endif // _H323TSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\globals.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    Global definitions for H.323 TAPI Service Provider.

Environment:

    User Mode - Win32

Revision History:

    28-Mar-1997 DonRyan
        Created.

--*/

#ifndef _INC_GLOBALS
#define _INC_GLOBALS
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <incommon.h>
#include <callcont.h>
#include <tapi.h>
#include <tspi.h>
#include <h323pdu.h>
#include "debug.h"
#include "mem.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern WCHAR *          g_pwszProviderInfo;
extern WCHAR *          g_pwszLineName;
extern ASYNC_COMPLETION g_pfnCompletionProc;
extern LINEEVENT g_pfnLineEventProc;
extern HPROVIDER g_hProvider;
extern HINSTANCE        g_hInstance;

extern WCHAR g_strAlias[MAX_ALIAS_LENGTH+1];
extern DWORD g_dwAliasLength;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// String definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323_MAXADDRSPERLINE    1
#define H323_MAXCALLSPERADDR    256 // limited by static H.245 instance table
#define H323_MAXCALLSPERLINE    (H323_MAXADDRSPERLINE * H323_MAXCALLSPERADDR)

#define H323_DEFLINESPERINST    2
#define H323_DEFCALLSPERLINE    8
#define H323_DEFMEDIAPERCALL    4
#define H323_DEFDESTNUMBER      4

#define H323_MAXLINENAMELEN     16
#define H323_MAXPORTNAMELEN     16
#define H323_MAXADDRNAMELEN     (H323_MAXLINENAMELEN + H323_MAXPORTNAMELEN)
#define H323_MAXPATHNAMELEN     256
#define H323_MAXDESTNAMELEN     256
#define H323_MAXUSERNAMELEN     256
#define H323_MAXDESTNUMBER      16

#define H323_ADDRNAMEFORMAT     L"%S"
#define H323_DEVICECLASS        T3_MSPDEVICECLASS
#define H323_UIDLL              L"H323.TSP"
#define H323_TSPDLL              "H323.TSP"
#define H323_WINSOCKVERSION     MAKEWORD(1,1)

#define H221_COUNTRY_CODE_USA   0xB5
#define H221_COUNTRY_EXT_USA    0x00
#define H221_MFG_CODE_MICROSOFT 0x534C

#define H323_PRODUCT_ID         "Microsoft TAPI\0"
#define H323_PRODUCT_VERSION    "Version 3.0\0"

#define MSP_HANDLE_UNKNOWN      0

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323AddrToAddrIn(_dwAddr_) \
    (*((struct in_addr *)&(_dwAddr_)))

#define H323AddrToString(_dwAddr_) \
    (inet_ntoa(H323AddrToAddrIn(_dwAddr_)))

#define H323SizeOfWSZ(wsz) \
    (((wsz) == NULL) ? 0 : ((wcslen(wsz) + 1) * sizeof(WCHAR)))

#define H323GetNextIndex(_i_,_dwNumSlots_) \
    (((_i_) + 1) & ((_dwNumSlots_) - 1))

#define H323GetNumStrings(_apsz_) \
    (sizeof(_apsz_)/sizeof(PSTR))

#define H323GetPointer(_pBase_,_offset_) \
    ((LPBYTE)(_pBase_) + (DWORD)(_pBase_->_offset_))
    
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous definitions                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define UNINITIALIZED   ((DWORD)(-1))
#define ANYSIZE         (1)

#endif // _INC_GLOBALS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\h323.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    H323.c

Abstract:

    Entry point for H323 TAPI Service Provider.

Environment:

    User Mode - Win32

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "provider.h"
#include "config.h"
#include "line.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRITICAL_SECTION g_GlobalLock;
HINSTANCE        g_hInstance;
WCHAR *          g_pwszProviderInfo = NULL;
WCHAR *          g_pwszLineName = NULL;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private prototypes                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
WINAPI
CCDllMain(
    PVOID  DllHandle,
    ULONG  Reason,
    LPVOID lpReserved 
    );

BOOL
WINAPI
H245DllMain(
    PVOID  DllHandle,
    ULONG  Reason,
    LPVOID lpReserved 
    );

BOOL
WINAPI
H245WSDllMain(
    PVOID  DllHandle,
    ULONG  Reason,
    LPVOID lpReserved 
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323LoadStrings(
    )

/*++

Routine Description:

    Loads strings from resource table.

Arguments:

    None.

Return Values:

    Returns true if successful. 

--*/

{
    DWORD dwNumBytes;
    DWORD dwNumChars;
    WCHAR wszBuffer[256];

    // load string into buffer
    dwNumChars = LoadStringW(
                    g_hInstance,
                    IDS_LINENAME,
                    wszBuffer,
                    sizeof(wszBuffer)
                    );

    // determine memory needed
    dwNumBytes = (dwNumChars + 1) * sizeof(WCHAR);

    // allocate memory for unicode string
    g_pwszLineName = H323HeapAlloc(dwNumBytes);

    // validate pointer
    if (g_pwszLineName == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate strings.\n"
            ));

        // failure
        return FALSE;
    }

    // copy loaded string into buffer
    memcpy(g_pwszLineName, wszBuffer, dwNumBytes);

    // load string into buffer
    dwNumChars = LoadStringW(
                    g_hInstance,
                    IDS_PROVIDERNAME,
                    wszBuffer,
                    sizeof(wszBuffer)
                    );

    // determine memory needed
    dwNumBytes = (dwNumChars + 1) * sizeof(WCHAR);

    // allocate memory for unicode string
    g_pwszProviderInfo = H323HeapAlloc(dwNumBytes);

    // validate pointer
    if (g_pwszProviderInfo == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate strings.\n"
            ));

        // failure
        return FALSE;
    }

    // copy loaded string into buffer
    memcpy(g_pwszProviderInfo, wszBuffer, dwNumBytes);

    // success
    return TRUE;
}


BOOL
H323UnloadStrings(
    )

/*++

Routine Description:

    Unloads strings from resource table.

Arguments:

    None.

Return Values:

    Returns true if successful. 

--*/

{
    // validate string pointer
    if (g_pwszLineName != NULL) {

        // release memory consumed
        H323HeapFree(g_pwszLineName);

        // re-initialize pointer
        g_pwszLineName = NULL;
    }

    // validate string pointer
    if (g_pwszProviderInfo != NULL) {

        // release memory consumed
        H323HeapFree(g_pwszProviderInfo);

        // re-initialize pointer
        g_pwszProviderInfo = NULL;
    }

    // success
    return TRUE;
}


BOOL
H323StartupTSP(
    )

/*++

Routine Description:

    Loads H.323 TAPI service provider.

Arguments:

    None.

Return Values:

    Returns true if successful. 

--*/

{
    __try {

        // initialize global lock (and allocate event immediately)
        InitializeCriticalSectionAndSpinCount(&g_GlobalLock,H323_SPIN_COUNT);

    } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH
                ) {

        // failure
        return FALSE;
    }

    // create heap
    if (!H323HeapCreate()) {

        // failure
        return FALSE;
    }

    // load resource strings
    if (!H323LoadStrings()) {

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}


BOOL
H323ShutdownTSP(
    )

/*++

Routine Description:

    Unloads H.323 TAPI service provider.

Arguments:

    None.

Return Values:

    Returns true if successful. 

--*/

{   
    // unload strings
    H323UnloadStrings();

    // nuke heap
    H323HeapDestroy();

    // release global lock resource
    DeleteCriticalSection(&g_GlobalLock);

    // success
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
WINAPI
DllMain(
    PVOID  DllHandle,
    ULONG  Reason,
    LPVOID lpReserved 
    )

/*++

Routine Description:

    Dll entry point.

Arguments:

    Same as DllMain.

Return Values:

    Returns true if successful. 

--*/

{
    BOOL fOk;

    // check if new process attaching
    if (Reason == DLL_PROCESS_ATTACH) { 

        // store the handle into a global variable so that
        // the UI code can use it.
        g_hInstance = (HINSTANCE)DllHandle;

        // turn off thread attach messages
        DisableThreadLibraryCalls(DllHandle);

        // start h323 tsp
        fOk = CCDllMain(DllHandle,Reason,lpReserved) &&
              H245DllMain(DllHandle,Reason,lpReserved) &&
              H245WSDllMain(DllHandle,Reason,lpReserved) &&
              H323StartupTSP();

    // check if new process detaching
    } else if (Reason == DLL_PROCESS_DETACH) {

        // stop h323 tsp
        fOk = CCDllMain(DllHandle,Reason,lpReserved) &&
              H245DllMain(DllHandle,Reason,lpReserved) &&
              H245WSDllMain(DllHandle,Reason,lpReserved) &&
              H323ShutdownTSP();
    }

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\mem.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    mem.c

Abstract:

    Routines for memory allocation and deallocation.

Environment:

    User Mode - Win32

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HANDLE g_HeapHandle;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procudures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323HeapCreate(
    )

/*++

Routine Description:

    Creates private heap for service provider's private structures.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // create master agent heap
    g_HeapHandle = HeapCreate(
                        H323_HEAP_FLAGS, 
                        H323_HEAP_INITIAL_SIZE, 
                        H323_HEAP_MAXIMUM_SIZE
                        );

    // validate heap handle
    if (g_HeapHandle == NULL) {
            
        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error %d creating private heap.\n",
            GetLastError()
            ));
    }

    // return success if created
    return (g_HeapHandle != NULL);
}


BOOL
H323HeapDestroy(
    )

/*++

Routine Description:

    Destroys private heap for service provider's private structures.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // validate handle
    if (g_HeapHandle != NULL) {

        // release heap handle
        HeapDestroy(g_HeapHandle);

        // re-initialize
        g_HeapHandle = NULL;
    }

    return TRUE;
}


LPVOID
H323HeapAlloc(
    UINT nBytes
    )

/*++

Routine Description:

    Allocates memory from service provider's private heap.

Arguments:

    nBytes - number of bytes to allocate.

Return Values:

    Returns true if successful.

--*/

{
    // allocate memory from private heap (and initialize)
    return HeapAlloc(g_HeapHandle, HEAP_ZERO_MEMORY, nBytes);
}


LPVOID
H323HeapReAlloc(
    LPVOID pMem,
    UINT   nBytes
    )

/*++

Routine Description:

    Reallocates memory from service provider's private heap.

Arguments:

    pMem - pointer to memory block to reallocate.

    nBytes - number of bytes to allocate.

Return Values:

    Returns true if successful.

--*/

{
    // reallocate memory from private heap (and initialize)
    return HeapReAlloc(g_HeapHandle, HEAP_ZERO_MEMORY, pMem, nBytes);
}


VOID
H323HeapFree(
    LPVOID pMem
    )

/*++

Routine Description:

    Frees memory from service provider's private heap.

Arguments:

    pMem - pointer to memory block to release.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pMem != NULL) {

        // release agent memory
        HeapFree(g_HeapHandle, 0, pMem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\mem.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    mem.h

Abstract:

    Contains memory allocation routines for TAPI service provider.

Environment:

    User Mode - Win32

Revision History:

--*/
 
#ifndef _MEM_H_
#define _MEM_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public definitions                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323_HEAP_FLAGS            0
#define H323_HEAP_INITIAL_SIZE     0xffff
#define H323_HEAP_MAXIMUM_SIZE     0

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern HANDLE g_HeapHandle;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323HeapCreate(
    );

BOOL
H323HeapDestroy(
    );

LPVOID
H323HeapAlloc(
    UINT nBytes
    );

LPVOID
H323HeapReAlloc(
    LPVOID pMem,
    UINT   nBytes
    );

VOID
H323HeapFree(
    LPVOID pMem
    );

#endif // _MEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\media.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    media.c

Abstract:

    TAPI Service Provider functions related to media.

        TSPI_lineConditionalMediaDetection
        TSPI_lineGetID
        TSPI_lineMSPIdentify
        TSPI_lineReceiveMSPData
        TSPI_lineSetDefaultMediaDetection
        TSPI_lineSetMediaMode

Environment:

    User Mode - Win32

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "provider.h"
#include "termcaps.h"
#include "callback.h"

#include <objbase.h>
#include <initguid.h>
#include "line.h"

// {0F1BE7F8-45CA-11d2-831F-00A0244D2298}
DEFINE_GUID(CLSID_IPMSP,
0x0F1BE7F8,0x45CA, 0x11d2, 0x83, 0x1F, 0x0, 0xA0, 0x24, 0x4D, 0x22, 0x98);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI procedures                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE               hdLine, 
    DWORD                  dwMediaModes,
    LPLINECALLPARAMS const pCallParams
    )
    
/*++

Routine Description:

    If the Service Provider can monitor for the indicated set of media modes 
    AND support the capabilities indicated in pCallParams, then it sets the 
    indicated media moditoring modes for the line and replies with a "success" 
    indication.  Otherwise, it leaves the media monitoring modes for the line 
    unchanged and replies with a "failure" indication.  
    
    A TAPI lineOpen that specifies the device ID LINE_MAPPER typically results
    in calling this procedure for multiple line devices to hunt for a suitable
    line, possibly also opening as-yet unopened lines.  A "success" result 
    indicates that the line is suitable for the calling application's 
    requirements.  Note that the media monitoring modes demanded at the TSPI 
    level are the union of monitoring modes demanded by multiple applications
    at the TAPI level.  As a consequence of this, it is most common for 
    multiple media mode flags to be set simultaneously at this level.  The 
    Service Provider should test to determine if it can support at least the 
    specified set regardless of what modes are currently in effect.

    The Device ID LINE_MAPPER is never used at the TSPI level.

    The service provider shall return an error (e.g., LINEERR_RESOURCEUNAVAIL)
    if, at the time this function is called, it is impossible to place a new 
    call on the specified line device (in other words, if it would return 
    LINEERR_CALLUNAVAIL or LINEERR_RESOURCEUNAVAIL should TSPI_lineMakeCall be 
    invoked immediately after opening the line).

    The function operates strictly synchronously.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line to 
        have media monitoring and parameter capabilities tested and set.

    dwMediaModes - Specifies the media mode(s) of interest to the app, of 
        type LINEMEDIAMODE. The dwMediaModes parameter is used to register 
        the app as a potential target for inbound call and call hand off for 
        the specified media mode. This parameter is ignored if the OWNER flag 
        is not set in dwPrivileges. 

    pCallParams - Specifies a far pointer to a structure of type 
        LINECALLPARAMS.  It describes the call parameters that the line device 
        should be able to provide.  

Return Values:

    Returns zero if the function is successful, or a negative error number if 
    an error has occurred. Possible error returns are:

        LINEERR_INVALADDRESSMODE - The address mode is invalid.

        LINEERR_INVALBEARERMODE - The bearer mode is invalid.

        LINEERR_INVALLINEHANDLE - The specified line handle is invalid.

        LINEERR_INVALMEDIAMODE - One or more media modes specified as a 
            parameter or in a list is invalid or not supported by the the 
            service provider. 

        LINEERR_RESOURCEUNAVAIL - The specified operation cannot be completed 
            because of resource overcommitment.

--*/

{
    PH323_LINE pLine = NULL;
    
    // see if we support media modes specified
    if (dwMediaModes & ~H323_LINE_MEDIAMODES) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "do not support media modes 0x%08lx.\n",
             dwMediaModes
             ));

        // do not support media mode
        return LINEERR_INVALMEDIAMODE;
    }

    // validate pointer
    if (pCallParams != NULL) {

        // see if we support media modes specified
        if (pCallParams->dwMediaMode & ~H323_LINE_MEDIAMODES) {
            

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "do not support media modes 0x%08lx.\n",
                 pCallParams->dwMediaMode
                 ));

            // do not support media mode
            return LINEERR_INVALMEDIAMODE;
        }

        // see if we support bearer modes
        if (pCallParams->dwBearerMode & ~H323_LINE_BEARERMODES) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "do not support bearer mode 0x%08lx.\n",
                pCallParams->dwBearerMode 
                ));

            // do not support bearer mode
            return LINEERR_INVALBEARERMODE;
        }

        // see if we support address modes
        if (pCallParams->dwAddressMode & ~H323_LINE_ADDRESSMODES) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "do not support address mode 0x%08lx.\n",
                pCallParams->dwAddressMode 
                ));

            // do not support address mode
            return LINEERR_INVALADDRESSMODE;
        }
    }

    // retrieve line device pointer from handle
    if (!H323GetLineAndLock(&pLine, hdLine)) {

        // invalid line device handle
        return LINEERR_INVALLINEHANDLE;
    }

    // see if line is available 
    if (!H323IsLineAvailable(pLine)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "line %d is currently at maximum capacity.\n",
            pLine->dwDeviceID
            ));
    
        // release line device
        H323UnlockLine(pLine);

        // no addresses available
        return LINEERR_RESOURCEUNAVAIL;
    }

    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING pDeviceID,
    LPCWSTR     pwszDeviceClass,
    HANDLE      hTargetProcess
    )
    
/*++

Routine Description:

    This function returns a device ID for the specified device class 
    associated with the selected line, address or call.

    This function can be used to retrieve a line device ID given a 
    line handle. Although the TAPI DLL has sufficient information to 
    determine the line device ID from a line handle, it may still call 
    this operation in such a fashion on behalf of an application that 
    has opened a line device using LINE_MAPPER.  The Service Provider 
    should support the "line" device class to allow applications to 
    determine the real line device ID of an opened line.

    This function can also be used to obtain the device ID of a phone 
    device or media device (e.g., mci waveform, mci midi, wave, fax, 
    etc.) associated with a call, address or line. This ID can then be 
    used with the appropriate API (e.g., phone, mci, midi, wave, etc.) 
    to select the corresponding media device associated with the specified 
    call.

    Note that the notion of Windows device class is different from that of 
    media mode. For example, the interactive voice or stored voice media 
    modes may be accessed using either the mci waveaudio or the low level 
    wave device classes. A media modes describes a format of information 
    on a call, a device class defines a Windows API used to manage that 
    stream. Often, a single media stream may be accessed using multiple 
    device classes, or a single device class (e.g., the Windows COMM API) 
    may provide access to multiple media modes. 

    Note that a new device class value is defined in TAPI 2.0: 
    
        "comm/datamodem/portname" 
        
    When TSPI_lineGetID is called specifying this device class on a line 
    device that supports the class, the VARSTRING structure returned will 
    contain a null-terminated ANSI (not UNICODE) string specifying the name 
    of the port to which the specified modem is attached, such as "COM1\0". 
    This is intended primarily for identification purposes in user interface, 
    but could be used under some circumstances to open the device directly, 
    bypassing the service provider (if the service provider does not already 
    have the device open itself). If there is no port associated with the 
    device, a null string ("\0") is returned in the VARSTRING structure (with 
    a string length of 1).

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line 
        to be queried.

    dwAddressID - Specifies an address on the given open line device.

    hdCall - Specifies the Service Provider's opaque handle to the call 
        to be queried.

    dwSelect - Specifies the whether the device ID requested is associated 
        with the line, address or a single call, of type LINECALLSELECT. 

    pDeviceID - Specifies a far pointer to the memory location of type 
        VARSTRING where the device ID is returned. Upon successful completion 
        of the request, this location is filled with the device ID. The 
        format of the returned information depends on the method used by the 
        device class (API) for naming devices. 

    pwszDeviceClass - Specifies a far pointer to a NULL-terminated ASCII 
        string that specifies the device class of the device whose ID is 
        requested. Valid device class strings are those used in the SYSTEM.INI 
        section to identify device classes.

    hTargetProcess - The process handle of the application on behalf of which 
        the TSPI_lineGetID function is being invoked. If the information being 
        returned in the VARSTRING structure includes a handle for use by the 
        application, the service provider should create or duplicate the handle
        for the process.

        If hTargetProcess is set to INVALID_HANDLE_VALUE, then the application
        is executing on a remote client system and it is not possible to create
        a duplicate handle directly. Instead, the VARSTRING structure should 
        contain a UNC name of a network device or other name that the remote 
        client can use to access the device. If this is not possible, then the 
        function should fail.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The hdCall parameter is an invalid handle.

        LINEERR_INVALCALLSELECT - The specified dwCallSelect parameter is 
            invalid.

        LINEERR_INVALCALLSTATE - One or more of the specified calls are not in 
            a valid state for the requested operation. 

        LINEERR_NODEVICE - The line device has no associated device for the 
            given device class.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.
        
--*/

{
    // do not support device
    return LINEERR_NODEVICE;
}


LONG
TSPIAPI
TSPI_lineMSPIdentify(
    DWORD  dwDeviceID,
    GUID * pCLSID
    )
    
/*++

Routine Description:

    This procedure is called after TAPI has initialized the line device in 
    order to determine the assoicated Media Service Provider.

Arguments:

    dwDeviceID - Identifies the line device to be opened.  The value 
        LINE_MAPPER for a device ID is not permitted.

    pCLSID - Points to a GUID-sized memory location which the service 
        provider writes the class identifier of the associated media 
        service provider.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified or 
            unknown reason. 

--*/

{
    PH323_LINE pLine = NULL;
    
    // retrieve pointer to line device from device id
    if (!H323GetLineFromIDAndLock(&pLine, dwDeviceID)) {

        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // copy class id
    *pCLSID = CLSID_IPMSP;

    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG 
TSPIAPI 
TSPI_lineReceiveMSPData( 
    HDRVLINE hdLine,
    HDRVCALL hdCall,
    HDRVMSPLINE hdMSPLine,
    LPVOID pBuffer, 
    DWORD dwSize 
    )
    
/*++

Routine Description:

    This procedure is called to deliver a payload from the MSP.

Arguments:
    
    hdCall - Handle to line object.

    hdCall - Handle to call object associated with MSP.

    hdMSPLine - Handle to MSP.

    pBuffer - Pointer to opaque buffer with MSP data.

    dwSize - Size of buffer above.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified or 
            unknown reason. 

--*/

{
    PH323_CALL pCall = NULL;
    PH323MSP_MESSAGE pMessage = (PH323MSP_MESSAGE)pBuffer;

    // validate pointer and message size
    if ((pMessage == NULL) || (dwSize != sizeof(H323MSP_MESSAGE))) {

        // could not cancel listen
        return LINEERR_OPERATIONFAILED;
    }

    // see if call handle is valid
    if (!H323GetCallAndLock(&pCall, hdCall)) {

        // see if this is a line message.
        switch (pMessage->Type) {

        case H323MSP_CONFIG_T120_COMMAND:

            H323LockProvider();

            H323ProcessConfigT120Command(
                &pMessage->ConfigT120Command
                );

            H323UnlockProvider();

            break;

        case H323MSP_CONFIG_CAPABILITY_COMMAND:

            H323LockProvider();

            H323ProcessConfigCapabilityCommand(
                &pMessage->ConfigCapabilityCommand
                );

            H323UnlockProvider();

            break;

        case H323MSP_SET_ALIAS_COMMAND:

            H323LockProvider ();

            if (pMessage->SetAliasCommand.dwLength > 0)
            {
                // check pointer
                if (IsBadReadPtr (
                        pMessage->SetAliasCommand.strAlias,
                        pMessage->SetAliasCommand.dwLength * sizeof (WCHAR)
                        ))
                {
                    H323DBG((
                        DEBUG_LEVEL_ERROR,
                        "H323MSP_SET_ALIAS_COMMAND receives bad pointer"
                         ));
                    break;
                }

                // check wcs length
                g_dwAliasLength = pMessage->SetAliasCommand.dwLength < MAX_ALIAS_LENGTH
                    ?pMessage->SetAliasCommand.dwLength
                    :MAX_ALIAS_LENGTH;

                // copy
                CopyMemory (
                    g_strAlias,
                    pMessage->SetAliasCommand.strAlias,
                    g_dwAliasLength * sizeof (WCHAR)
                    );

                // end char
                g_strAlias[g_dwAliasLength] = L'\0';
            }

            H323UnlockProvider ();

            break;

        default:
            // invalid call handle
            return LINEERR_INVALCALLHANDLE;
        }

        // success
        return NOERROR;
    }

    switch (pMessage->Type) {

    case H323MSP_OPEN_CHANNEL_REQUEST:

        H323ProcessOpenChannelRequest(
            pCall,
            &pMessage->OpenChannelRequest
            );

        break;

    case H323MSP_ACCEPT_CHANNEL_RESPONSE:

        H323ProcessAcceptChannelResponse(
            pCall,
            &pMessage->AcceptChannelResponse
            );

        break;

    case H323MSP_CLOSE_CHANNEL_COMMAND:

        H323ProcessCloseChannelCommand(
            pCall,
            &pMessage->CloseChannelCommand
            );

        break;

    case H323MSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND:

        H323ProcessVideoFastUpdatePictureCommand(
            pCall,
            &pMessage->VideoFastUpdatePictureCommand
            );

        break;

    case H323MSP_FLOW_CONTROL_COMMAND:

        H323ProcessFlowControlCommand(
            pCall,
            &pMessage->FlowControlCommand
            );

        break;

    case H323MSP_QOS_Evnet:

        H323ProcessQoSEventIndication(
            pCall,
            &pMessage->QOSEvent
            );

        break;
    }

    // unlock line device
    H323UnlockLine(pCall->pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
    
/*++

Routine Description:

    This procedure tells the Service Provider the new set of Media Modes to 
    detect for the indicated line (replacing any previous set). It also sets 
    the initial set of Media Modes that should be monitored for on subsequent 
    calls (inbound or outbound) on this line. 

    The TAPI DLL typically calls this function to update the set of detected 
    media modes for the line to the union of all modes selected by all 
    outstanding lineOpens whenever a line is Opened or Closed at the TAPI 
    level. A lineOpen attempt is rejected if media detection is rejected. 
    A single call to this procedure is typically the result of a lineOpen 
    that does not specify the device ID LINE_MAPPER. The Device ID LINE_MAPPER
    is never used at the TSPI level.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line to 
        have media monitoring set.

    dwMediaModes - Specifies the media mode(s) of interest to the TAPI DLL, 
        of type LINEMEDIAMODE. 

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified line handle is invalid.

        LINEERR_INVALMEDIAMODE - One or more media modes specified as a 
            parameter or in a list is invalid or not supported by the the 
            service provider. 

--*/

{
    HRESULT hr;
    PH323_LINE pLine = NULL;
        
    // see if unknown bit is specified 
    if (dwMediaModes & LINEMEDIAMODE_UNKNOWN) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "clearing unknown media mode.\n"
             ));

        // clear unknown bit from modes
        dwMediaModes &= ~LINEMEDIAMODE_UNKNOWN;
    }

    // see if both audio bits are specified 
    if ((dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE) &&
        (dwMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE)) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "clearing automated voice media mode.\n"
             ));

        // clear extra audio bit from modes
        dwMediaModes &= ~LINEMEDIAMODE_INTERACTIVEVOICE;
    }

    // see if we support media modes specified
    if (dwMediaModes & ~H323_LINE_MEDIAMODES) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "do not support media modes 0x%08lx.\n",
             dwMediaModes 
             ));

        // do not support media mode
        return LINEERR_INVALMEDIAMODE;
    }
    
    // retrieve line device pointer from handle
    if (!H323GetLineAndLock(&pLine, hdLine)) {

        // invalid line device handle
        return LINEERR_INVALLINEHANDLE;
    }

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "line %d enabled to detect media modes 0x%08lx.\n",
         pLine->dwDeviceID,
         dwMediaModes
         ));

    // record media modes to detect
    pLine->dwMediaModes = dwMediaModes;     

    // see if we need to start listening
    if (H323IsMediaDetectionEnabled(pLine) &&
       !H323IsListening(pLine) &&
       !H323StartListening(pLine)) {
        
        // release line device
        H323UnlockLine(pLine);

        // could not cancel listen
        return LINEERR_OPERATIONFAILED;

    // see if we need to stop listening
    } else if (H323IsListening(pLine) &&
              !H323IsMediaDetectionEnabled(pLine) &&
              !H323StopListening(pLine)) {
        
        // release line device
        H323UnlockLine(pLine);

        // could not cancel listen
        return LINEERR_OPERATIONFAILED;
    }
               
    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL hdCall,
    DWORD    dwMediaMode
    )
    
/*++

Routine Description:

    This function changes the call's media as stored in the call's 
    LINECALLINFO structure.

    Other than changing the call's media as stored in the call's 
    LINECALLINFO structure, this procedure is simply "advisory" in the sense 
    that it indicates an expected media change that is about to occur, rather 
    than forcing a specific change to the call.  Typical usage is to set a 
    calls media mode to a specific known media mode, or to exclude possible 
    media modes as long as the call's media mode is not fully known; i.e., 
    the UNKNOWN media mode flag is set.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        undergoing a change in media mode.  Valid call states: any.

    dwMediaMode - Specifies the new media mode(s) for the call, of type 
        LINEMEDIAMODE. As long as the UNKNOWN media mode flag is set, 
        multiple other media mode flags may be set as well. This is used 
        to indentify a call's media mode as not fully determined, but 
        narrowed down to one of just a small set of specified media modes. 
        If the UNKNOWN flag is not set, then only a single media mode can 
        be specified. 

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALMEDIAMODE - The specified media mode parameter is invalid.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reasons.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\provider.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    provider.h

Abstract:

    Definitions for H.323 TAPI Service Provider.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_PROVIDER
#define _INC_PROVIDER

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern DWORD g_dwTSPIVersion;
extern DWORD g_dwLineDeviceIDBase;
extern DWORD g_dwPermanentProviderID;
extern CRITICAL_SECTION g_GlobalLock;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323_SPIN_COUNT 0x80001000

#if defined(DBG) && defined(DEBUG_CRITICAL_SECTIONS)

VOID
H323LockProvider(
    );

VOID
H323UnlockProvider(
    );

#else  // DBG && DEBUG_CRITICAL_SECTIONS

#define H323LockProvider() \
    {EnterCriticalSection(&g_GlobalLock);}

#define H323UnlockProvider() \
    {LeaveCriticalSection(&g_GlobalLock);}

#endif // DBG && DEBUG_CRITICAL_SECTIONS

#ifdef __cplusplus
}
#endif

#endif // _INC_PROVIDER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\registry.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Routines for reading registry configuration.

Environment:

    User Mode - Win32

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "registry.h"
#include "termcaps.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HKEY g_hKey = NULL;
H323_REGISTRY_SETTINGS g_RegistrySettings;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323SetDefaultConfig(
    )

/*++

Routine Description:
    
    Changes configuration settings back to defaults.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
#if DBG

    // initialize debug settings to defaults
    g_RegistrySettings.dwLogType      = H323_DEBUG_LOGTYPE;
    g_RegistrySettings.dwLogLevel     = H323_DEBUG_LOGLEVEL;
    g_RegistrySettings.dwH245LogLevel = g_RegistrySettings.dwLogLevel;
    g_RegistrySettings.dwH225LogLevel = g_RegistrySettings.dwLogLevel;
    g_RegistrySettings.dwQ931LogLevel = g_RegistrySettings.dwLogLevel;
    g_RegistrySettings.dwLinkLogLevel = g_RegistrySettings.dwLogLevel;

    // copy default debug log file name
    lstrcpy(g_RegistrySettings.szLogFile, H323_DEBUG_LOGFILE);

#endif // DBG

    // initialize alerting timeout to default
    g_RegistrySettings.dwQ931AlertingTimeout = 0;

    // set alerting timeout
    CC_SetCallControlTimeout(
        CC_Q931_ALERTING_TIMEOUT,
        g_RegistrySettings.dwQ931AlertingTimeout
        );

    // initialize call signalling port to default
    g_RegistrySettings.dwQ931CallSignallingPort = CC_H323_HOST_CALL;

    // initialize g711 audio codec settings
    g_RegistrySettings.dwG711MillisecondsPerPacket =
        G711_DEFAULT_MILLISECONDS_PER_PACKET
        ;

    // initialize g723 audio codec settings
    g_RegistrySettings.dwG723MillisecondsPerPacket =
        G723_DEFAULT_MILLISECONDS_PER_PACKET
        ;

    // success
    return TRUE;
}


BOOL
H323GetConfigFromRegistry(
    )
    
/*++

Routine Description:
    
    Loads registry settings for service provider.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    LONG lStatus = ERROR_SUCCESS;
    CHAR szAddr[H323_MAXDESTNAMELEN];
    DWORD dwValue;
    DWORD dwValueSize;
    DWORD dwValueType;
    LPSTR pszValue;

    // see if key open
    if (g_hKey == NULL) {

        // open registry subkey
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    H323_REGKEY_ROOT,
                    0,
                    KEY_READ,
                    &g_hKey
                    );
    }

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "error 0x%08lx opening tsp registry key.\n",
            lStatus
            ));

        // success
        return TRUE;
    }

#if DBG

    // do not support modifying log type via registry    
    g_RegistrySettings.dwLogType  = H323_DEBUG_LOGTYPE;

    // initialize value name
    pszValue = H323_REGVAL_DEBUGLEVEL;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwLogLevel,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // copy default value into global settings
        g_RegistrySettings.dwLogLevel = H323_DEBUG_LOGLEVEL;
    }

    // initialize value name
    pszValue = H245_REGVAL_DEBUGLEVEL;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwH245LogLevel,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // copy default value into global settings
        g_RegistrySettings.dwH245LogLevel = g_RegistrySettings.dwLogLevel;
    }

    // initialize value name
    pszValue = H225_REGVAL_DEBUGLEVEL;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwH225LogLevel,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // copy default value into global settings
        g_RegistrySettings.dwH225LogLevel = g_RegistrySettings.dwLogLevel;
    }

    // initialize value name
    pszValue = Q931_REGVAL_DEBUGLEVEL;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwQ931LogLevel,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // copy default value into global settings
        g_RegistrySettings.dwQ931LogLevel = g_RegistrySettings.dwLogLevel;
    }

    // initialize value name
    pszValue = LINK_REGVAL_DEBUGLEVEL;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwLinkLogLevel,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // copy default value into global settings
        g_RegistrySettings.dwLinkLogLevel = g_RegistrySettings.dwLogLevel;
    }

    // initialize value name
    pszValue = H323_REGVAL_DEBUGLOG;

    // initialize type 
    dwValueType = REG_SZ;
    dwValueSize = sizeof(g_RegistrySettings.szLogFile);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                g_RegistrySettings.szLogFile,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // copy default value into global settings
        lstrcpy(g_RegistrySettings.szLogFile, H323_DEBUG_LOGFILE);
    }
    
#endif // DBG

    // initialize value name
    pszValue = H323_REGVAL_CALLSIGNALLINGPORT;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwQ931CallSignallingPort,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // copy default value into global settings
        g_RegistrySettings.dwQ931CallSignallingPort = CC_H323_HOST_CALL;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "using call signalling port %d.\n",
        g_RegistrySettings.dwQ931CallSignallingPort
        ));

    // initialize value name
    pszValue = H323_REGVAL_Q931ALERTINGTIMEOUT;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwQ931AlertingTimeout,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus == ERROR_SUCCESS) {
    
        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "using Q931 timeout of %d milliseconds.\n",
            g_RegistrySettings.dwQ931AlertingTimeout
            ));

    } else {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "using default Q931 timeout.\n"
            ));

        // copy default value into global settings
        g_RegistrySettings.dwQ931AlertingTimeout = 0;
    }   
    
    // set alerting timeout
    CC_SetCallControlTimeout(
        CC_Q931_ALERTING_TIMEOUT,
        g_RegistrySettings.dwQ931AlertingTimeout
        );

    // initialize value name
    pszValue = H323_REGVAL_G711MILLISECONDSPERPACKET;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwG711MillisecondsPerPacket,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // copy default value into global settings
        g_RegistrySettings.dwG711MillisecondsPerPacket =
            G711_DEFAULT_MILLISECONDS_PER_PACKET
            ;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "using G.711 setting of %d milliseconds per packet.\n",
        g_RegistrySettings.dwG711MillisecondsPerPacket
        ));

    // initialize value name
    pszValue = H323_REGVAL_G723MILLISECONDSPERPACKET;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwG723MillisecondsPerPacket,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        // copy default value into global settings
        g_RegistrySettings.dwG723MillisecondsPerPacket =
            G723_DEFAULT_MILLISECONDS_PER_PACKET
            ;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "using G.723 setting of %d milliseconds per packet.\n",
        g_RegistrySettings.dwG723MillisecondsPerPacket
        ));

    // initialize value name
    pszValue = H323_REGVAL_GATEWAYADDR;

    // initialize type 
    dwValueType = REG_SZ;
    dwValueSize = sizeof(szAddr);

    // initialize ip address
    dwValue = UNINITIALIZED;

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                szAddr,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // convert ip address
        dwValue = inet_addr(szAddr);

        // see if address converted
        if (dwValue == UNINITIALIZED) {

            struct hostent * pHost;

            // attempt to lookup hostname
            pHost = gethostbyname(szAddr);

            // validate pointer
            if (pHost != NULL) {

                // retrieve host address from structure
                dwValue = *(unsigned long *)pHost->h_addr;
            }
        }
    }

    // see if address converted and check for null
    if ((dwValue > 0) && (dwValue != UNINITIALIZED)) {

        // save new gateway address in registry structure
        g_RegistrySettings.ccGatewayAddr.nAddrType = CC_IP_BINARY;
        g_RegistrySettings.ccGatewayAddr.Addr.IP_Binary.dwAddr = ntohl(dwValue);
        g_RegistrySettings.ccGatewayAddr.Addr.IP_Binary.wPort =
            LOWORD(g_RegistrySettings.dwQ931CallSignallingPort);
        g_RegistrySettings.ccGatewayAddr.bMulticast =
            IN_MULTICAST(g_RegistrySettings.ccGatewayAddr.Addr.IP_Binary.dwAddr);

        H323DBG((
            DEBUG_LEVEL_TRACE,
            "gateway address resolved to %s.\n",
            H323AddrToString(dwValue)
            ));

    } else {

        // clear memory used for gateway address
        memset(&g_RegistrySettings.ccGatewayAddr,0,sizeof(CC_ADDR));
    }

    // initialize value name
    pszValue = H323_REGVAL_GATEWAYENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsGatewayEnabled = (dwValue != 0);

    } else {

        // copy default value into settings
        g_RegistrySettings.fIsGatewayEnabled = FALSE;
    }

    // initialize value name
    pszValue = H323_REGVAL_PROXYADDR;

    // initialize type 
    dwValueType = REG_SZ;
    dwValueSize = sizeof(szAddr);

    // initialize ip address
    dwValue = UNINITIALIZED;

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                szAddr,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // convert ip address
        dwValue = inet_addr(szAddr);

        // see if address converted
        if (dwValue == UNINITIALIZED) {

            struct hostent * pHost;

            // attempt to lookup hostname
            pHost = gethostbyname(szAddr);

            // validate pointer
            if (pHost != NULL) {

                // retrieve host address from structure
                dwValue = *(unsigned long *)pHost->h_addr;
            }
        }
    }

    // see if address converted
    if ((dwValue > 0) && (dwValue != UNINITIALIZED)) {

        // save new gateway address in registry structure
        g_RegistrySettings.ccProxyAddr.nAddrType = CC_IP_BINARY;
        g_RegistrySettings.ccProxyAddr.Addr.IP_Binary.dwAddr = ntohl(dwValue);
        g_RegistrySettings.ccProxyAddr.Addr.IP_Binary.wPort =
            LOWORD(g_RegistrySettings.dwQ931CallSignallingPort);
        g_RegistrySettings.ccProxyAddr.bMulticast =
            IN_MULTICAST(g_RegistrySettings.ccProxyAddr.Addr.IP_Binary.dwAddr);

        H323DBG((
            DEBUG_LEVEL_TRACE,
            "proxy address resolved to %s.\n",
            H323AddrToString(dwValue)
            ));

    } else {

        // clear memory used for gateway address
        memset(&g_RegistrySettings.ccProxyAddr,0,sizeof(CC_ADDR));
    }

    // initialize value name
    pszValue = H323_REGVAL_PROXYENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_hKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsProxyEnabled = (dwValue != 0);

    } else {

        // copy default value into settings
        g_RegistrySettings.fIsProxyEnabled = FALSE;
    }

    // success
    return TRUE;
}


BOOL
H323ListenForRegistryChanges(
    HANDLE hEvent
    )
    
/*++

Routine Description:
    
    Initializes registry key change notification.

Arguments:

    hEvent - event to associate with registry key.

Return Values:

    Returns true if successful.

--*/

{
    LONG lStatus = ERROR_SUCCESS;

    // see if key open
    if (g_hKey == NULL) {

        // open registry subkey
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    H323_REGKEY_ROOT,
                    0,
                    KEY_READ,
                    &g_hKey
                    );
    }

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "error 0x%08lx opening tsp registry key.\n",
            lStatus
            ));

        // failure
        return FALSE;
    }

    // registry event with registry key
    lStatus = RegNotifyChangeKeyValue(
                    g_hKey,                        // hKey
                    FALSE,                         // bWatchSubTree
                    REG_NOTIFY_CHANGE_ATTRIBUTES | // dwNotifyFilter
                    REG_NOTIFY_CHANGE_LAST_SET |
                    REG_NOTIFY_CHANGE_SECURITY,
                    hEvent,                        // hEvent
                    TRUE                           // fAsychnronous
                    );

    // validate return code
    if (lStatus != ERROR_SUCCESS) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "error 0x%08lx associating event with registry key.\n",
            lStatus
            ));

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}


BOOL
H323StopListeningForRegistryChanges(
    )
    
/*++

Routine Description:
    
    Closes registry key.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // see if key open
    if (g_hKey != NULL) {

        // close key
        RegCloseKey(g_hKey);

        // re-init
        g_hKey = NULL;
    }

    // success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\line.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    line.h

Abstract:

    Definitions for H.323 TAPI Service Provider line device.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_LINE
#define _INC_LINE
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "call.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Line device GUID                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DEFINE_GUID(LINE_H323,
0xe41e1898, 0x7292, 0x11d2, 0xba, 0xd6, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Type definitions                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef enum _H323_LINESTATE {

    H323_LINESTATE_ALLOCATED = 0,
    H323_LINESTATE_WAITING_FOR_ID,
    H323_LINESTATE_CLOSED,               
    H323_LINESTATE_OPENED,
    H323_LINESTATE_CLOSING,
    H323_LINESTATE_LISTENING

} H323_LINESTATE, *PH323_LINESTATE;

typedef struct _H323_LINE {

    CRITICAL_SECTION Lock;                  // synchronization object
    H323_LINESTATE   nState;                // state of line object
    BOOL             fIsMarkedForDeletion;  // additional state

//  DWORD            dwIPAddr;              // network interface ip address
//  DWORD            dwIPPort;              // network interface ip port
    DWORD            dwNextPort;            // next rtp/rtcp port
    
    HDRVLINE         hdLine;                // tspi line handle
    HTAPILINE        htLine;                // tapi line handle
    DWORD            dwDeviceID;            // tapi line device id

    DWORD            dwTSPIVersion;         // tapi selected version
    DWORD            dwMediaModes;          // tapi selected media modes

    DWORD            dwNextMSPHandle;       // bogus msp handle count

    CC_HLISTEN       hccListen;             // intelcc listen handle

    PH323_CALL_TABLE pCallTable;            // table of allocated calls

    WCHAR wszAddr[H323_MAXADDRNAMELEN+1];   // line address

} H323_LINE, *PH323_LINE;

typedef struct _H323_LINE_TABLE {

    DWORD       dwNumSlots;                 // number of entries
    DWORD       dwNumInUse;                 // number of entries in use
    DWORD       dwNumAllocated;             // number of entries allocated
    DWORD       dwNextAvailable;            // next available table index 
    PH323_LINE  pLines[ANYSIZE];            // array of object pointers
                
} H323_LINE_TABLE, *PH323_LINE_TABLE;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern PH323_LINE_TABLE g_pLineTable;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Line capabilities                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
                                
#define H323_LINE_ADDRESSMODES      LINEADDRESSMODE_ADDRESSID
#define H323_LINE_ADDRESSTYPES     (LINEADDRESSTYPE_DOMAINNAME | \
                                    LINEADDRESSTYPE_IPADDRESS  | \
                                    LINEADDRESSTYPE_PHONENUMBER | \
                                    LINEADDRESSTYPE_EMAILNAME)
#define H323_LINE_BEARERMODES      (LINEBEARERMODE_DATA | \
                                    LINEBEARERMODE_VOICE)
#define H323_LINE_DEFMEDIAMODES     LINEMEDIAMODE_AUTOMATEDVOICE
#define H323_LINE_DEVCAPFLAGS      (LINEDEVCAPFLAGS_CLOSEDROP | \
                                    LINEDEVCAPFLAGS_MSP)
#define H323_LINE_DEVSTATUSFLAGS   (LINEDEVSTATUSFLAGS_CONNECTED | \
                                    LINEDEVSTATUSFLAGS_INSERVICE)
#define H323_LINE_MAXRATE           1048576 
#define H323_LINE_MEDIAMODES       (H323_LINE_DEFMEDIAMODES | \
                                    LINEMEDIAMODE_INTERACTIVEVOICE | \
                                    LINEMEDIAMODE_VIDEO)
#define H323_LINE_LINEFEATURES      LINEFEATURE_MAKECALL

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Address capabilities                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323_ADDR_ADDRESSSHARING    LINEADDRESSSHARING_PRIVATE
#define H323_ADDR_ADDRFEATURES      LINEADDRFEATURE_MAKECALL
#define H323_ADDR_CALLFEATURES     (LINECALLFEATURE_ACCEPT | \
                                    LINECALLFEATURE_ANSWER | \
                                    LINECALLFEATURE_DROP | \
                                    LINECALLFEATURE_RELEASEUSERUSERINFO | \
				    LINECALLFEATURE_SENDUSERUSER | \
				    LINECALLFEATURE_MONITORDIGITS | \
				    LINECALLFEATURE_GENERATEDIGITS)
#define H323_ADDR_CALLINFOSTATES    LINECALLINFOSTATE_MEDIAMODE
#define H323_ADDR_CALLPARTYIDFLAGS  LINECALLPARTYID_NAME
#define H323_ADDR_CALLERIDFLAGS    (LINECALLPARTYID_NAME | \
                                    LINECALLPARTYID_ADDRESS)
#define H323_ADDR_CALLEDIDFLAGS  LINECALLPARTYID_NAME
#define H323_ADDR_CALLSTATES       (H323_CALL_INBOUNDSTATES | \
                                    H323_CALL_OUTBOUNDSTATES)
#define H323_ADDR_CAPFLAGS         (LINEADDRCAPFLAGS_DIALED | \
                                    LINEADDRCAPFLAGS_ORIGOFFHOOK)                
#define H323_ADDR_DISCONNECTMODES  (LINEDISCONNECTMODE_BADADDRESS | \
                                    LINEDISCONNECTMODE_BUSY | \
                                    LINEDISCONNECTMODE_NOANSWER | \
                                    LINEDISCONNECTMODE_NORMAL | \
                                    LINEDISCONNECTMODE_REJECT | \
                                    LINEDISCONNECTMODE_UNAVAIL)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define H323IsLineAllocated(_pLine_) \
    ((_pLine_) != NULL)

#define H323IsLineInUse(_pLine_) \
    (H323IsLineAllocated(_pLine_) && \
     ((_pLine_)->nState > H323_LINESTATE_ALLOCATED))

#define H323IsLineEqual(_pLine_,_hdLine_) \
    (H323IsLineInUse(_pLine_) && \
     ((_pLine_)->hdLine == (_hdLine_)))

#define H323IsLineEqualIP(_pLine_,_dwIPAddr_) \
    (H323IsLineInUse(_pLine_) && \
     ((_pLine_)->dwIPAddr == (_dwIPAddr_)))

#define H323IsLineClosed(_pLine_) \
    ((_pLine_)->nState == H323_LINESTATE_CLOSED)

#define H323IsLineOpen(_pLine_) \
    ((_pLine_)->nState >= H323_LINESTATE_OPENED)

#define H323IsLineAvailable(_pLine_) \
    ((_pLine_)->pCallTable->dwNumInUse < H323_MAXCALLSPERLINE)

#define H323IsValidAddressID(_dwID_) \
    ((_dwID_) == 0)

#define H323IsTapiControlCode(_wch_) \
    (((_wch_) == L'T') || ((_wch_) == L'P'))

#define H323IsSeparator(_wch_) \
    ((_wch_) == L'/')

#define H323IsListening(_pLine_) \
    ((_pLine_)->nState == H323_LINESTATE_LISTENING)

#define H323IsClosing(_pLine_) \
    ((_pLine_)->nState == H323_LINESTATE_CLOSING)

#define H323IsMediaDetectionEnabled(_pLine_) \
    (((_pLine_)->dwMediaModes != 0) && \
     ((_pLine_)->dwMediaModes != LINEMEDIAMODE_UNKNOWN))

#define H323IsVideoDetectionEnabled(_pLine_) \
    ((_pLine_)->dwMediaModes & LINEMEDIAMODE_VIDEO)

#define H323IsAudioDetectionEnabled(_pLine_) \
    (H323IsVideoDetectionEnabled(_pLine_) || \
     ((_pLine_)->dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE) || \
     ((_pLine_)->dwMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE))

#define H323IsValidInterface(_dwAddr_) \
    (((_dwAddr_) != 0) && \
     ((_dwAddr_) != htonl(INADDR_LOOPBACK)))

#define H323GetLineTableIndex(_hdLine_) \
    ((DWORD)(_hdLine_))

#define H323CreateLineHandle(_i_) \
    ((HDRVLINE)(DWORD)(_i_))

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323GetLineAndLock(
    PH323_LINE * ppLine, 
    HDRVLINE     hdLine
    );

BOOL
H323GetLineFromIDAndLock(
    PH323_LINE * ppLine, 
    DWORD        dwDeviceID
    );

BOOL
H323InitializeLine(
    PH323_LINE pLine,
    DWORD      dwDeviceID
    );

BOOL
H323CallListen(
    PH323_LINE pLine
    );
        
BOOL
H323StartListening(
    PH323_LINE pLine
    );
        
BOOL
H323StopListening(
    PH323_LINE pLine
    );
        
BOOL
H323AllocLineTable(
    PH323_LINE_TABLE * ppLineTable
    );

BOOL
H323FreeLineTable(
    PH323_LINE_TABLE pLineTable
    );
        
BOOL
H323CloseLineTable(
    PH323_LINE_TABLE pLineTable
    );
        
BOOL
H323InitializeLineTable(
    PH323_LINE_TABLE pLineTable,
    DWORD            dwLineDeviceIDBase
    );

BOOL
H323AllocLineFromTable(
    PH323_LINE *       ppLine,
    PH323_LINE_TABLE * ppLineTable
    );
        
BOOL
H323FreeLineFromTable(
    PH323_LINE       pLine,
    PH323_LINE_TABLE pLineTable
    );

BOOL
H323ProcessCloseChannelCommand(
    PH323_CALL pCall,
    PH323MSG_CLOSE_CHANNEL_COMMAND pCommand
    );

BOOL
H323ProcessAcceptChannelResponse(
    PH323_CALL pCall,
    PH323MSG_ACCEPT_CHANNEL_RESPONSE pResponse
    );

BOOL
H323ProcessOpenChannelRequest(
    PH323_CALL                    pCall,
    PH323MSG_OPEN_CHANNEL_REQUEST pRequest
    );

BOOL
H323ProcessFlowControlCommand(
    PH323_CALL 					  pCall,
    PH323MSG_FLOW_CONTROL_COMMAND pCommand
    );

BOOL
H323ProcessVideoFastUpdatePictureCommand(
    PH323_CALL pCall,
    PH323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND pCommand
    );

BOOL
H323ProcessQoSEventIndication(
    PH323_CALL pCall,
    PH323MSG_QOS_EVENT pCommand
    );

BOOL
H323ProcessConfigT120Command(
    PH323MSG_CONFIG_T120_COMMAND pCommand
    );

BOOL
H323ProcessConfigCapabilityCommand(
    PH323MSG_CONFIG_CAPABILITY_COMMAND pCommand
    );

#if defined(USE_PROVIDER_LOCK)

#define H323LockLine(_pLine_) H323LockProvider();

#define H323UnlockLine(_pLine_) H323UnlockProvider();

#elif defined(DBG) && defined(DEBUG_CRITICAL_SECTIONS)

VOID
H323LockLine(
    PH323_LINE pLine
    );

VOID
H323UnlockLine(
    PH323_LINE pLine
    );

#else

#define H323LockLine(_pLine_) \
    {EnterCriticalSection(&(_pLine_)->Lock);}

#define H323UnlockLine(_pLine_) \
    {LeaveCriticalSection(&(_pLine_)->Lock);}

#endif

#endif // _INC_LINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\line.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    line.c

Abstract:

    TAPI Service Provider functions related to manipulating lines.

        TSPI_lineClose
        TSPI_lineGetDevCaps         
        TSPI_lineGetLineDevStatus
        TSPI_lineGetNumAddressIDs
        TSPI_lineOpen
        TSPI_lineSetLineDevStatus

Environment:

    User Mode - Win32

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "provider.h"
#include "callback.h"
#include "registry.h"
#include "version.h"
#include "line.h"
#include "call.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

PH323_LINE_TABLE g_pLineTable = NULL;
DWORD            g_dwLineDeviceUniqueID = 0;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323ResetLine(
    PH323_LINE pLine
    )
        
/*++

Routine Description:

    Resets line object to original state for re-use.

Arguments:

    pLine - Pointer to line object to reset.

Return Values:

    Returns true if successful.
    
--*/

{
    // reset state of line object
    pLine->nState = H323_LINESTATE_ALLOCATED;

    // line not marked for deletion
    pLine->fIsMarkedForDeletion = FALSE;

    // reset tapi handles
    pLine->hdLine = (HDRVLINE)NULL;
    pLine->htLine = (HTAPILINE)NULL;
    pLine->dwDeviceID = UNINITIALIZED;

    // reset tapi info
    pLine->dwTSPIVersion = 0;
    pLine->dwMediaModes  = 0;

    // reset bogus handle count
    pLine->dwNextMSPHandle = 0;

    // uninitialize listen handle
    pLine->hccListen = UNINITIALIZED;

    // reset line name
    pLine->wszAddr[0] = UNICODE_NULL;

    // success
    return TRUE;
}


BOOL
H323AllocLine(
    PH323_LINE * ppLine
    )
        
/*++

Routine Description:

    Allocates line device.

Arguments:

    ppLine - Pointer to DWORD-sized value which service provider must
        write the newly allocated line.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;
    PH323_LINE pLine;

    // allocate object from heap
    pLine = H323HeapAlloc(sizeof(H323_LINE));

    // validate pointer
    if (pLine == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate line object.\n"
            ));

        // failure
        return FALSE;
    }

    __try {

        // initialize lock (and allocate event immediately)
        InitializeCriticalSectionAndSpinCount(&pLine->Lock,H323_SPIN_COUNT);

    } __except ((GetExceptionCode() == STATUS_NO_MEMORY)
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH
                ) {

        // release object
        H323HeapFree(pLine);

        // failure
        return FALSE;
    }

    // allocate call table
    if (!H323AllocCallTable(&pLine->pCallTable)) {

        // release critical section
        DeleteCriticalSection(&pLine->Lock);

        // release object
        H323HeapFree(pLine);

        // failure
        return FALSE;
    }

    // initialize rtp/rtcp base port
    pLine->dwNextPort = H323_RTPBASEPORT;

    // reset line
    H323ResetLine(pLine);

    // transfer
    *ppLine = pLine;

    // success
    return TRUE;    
}


BOOL
H323FreeLine(
    PH323_LINE pLine
    )
        
/*++

Routine Description:

    Releases line device.

Arguments:

    pLine - Pointer to line device to release.

Return Values:

    Returns true if successful.
    
--*/

{
    // validate pointer
    if (pLine != NULL) {
                
        // release memory for call table
        H323FreeCallTable(pLine->pCallTable);
        
        // release critical section
        DeleteCriticalSection(&pLine->Lock);

        // release line
        H323HeapFree(pLine);
    }
    
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "line 0x%08lx released.\n",
        pLine
        ));

    // success
    return TRUE;
}


BOOL
H323OpenLine(
    PH323_LINE pLine,
    HTAPILINE  htLine,
    DWORD      dwTSPIVersion
    )
        
/*++

Routine Description:

    Initiate activities on line device and allocate resources.

Arguments:

    pLine - Pointer to line device to open.

    htLine - TAPI's handle describing line device to open.

    dwTSPIVersion - The TSPI version negotiated through 
        TSPI_lineNegotiateTSPIVersion under which the Service Provider is 
        willing to operate.

Return Values:

    Returns true if successful.
    
--*/

{
    H323DBG((
        DEBUG_LEVEL_TRACE,
        "line %d opening.\n",
        pLine->dwDeviceID
        ));

    // start listen if necessary
    if (H323IsMediaDetectionEnabled(pLine) &&
       !H323StartListening(pLine)) {
        
        // failure
        return FALSE;
    }

    // save line variables now
    pLine->htLine = htLine;
    pLine->dwTSPIVersion = dwTSPIVersion;

    // change line device state to opened
    pLine->nState = H323_LINESTATE_OPENED;

    // success
    return TRUE;
}


BOOL
H323CloseLine(
    PH323_LINE pLine
    )
        
/*++

Routine Description:

    Terminate activities on line device.

Arguments:

    pLine - Pointer to line device to close.

Return Values:

    Returns true if successful.
    
--*/

{
    H323DBG((
        DEBUG_LEVEL_TRACE,
        "line %d %s.\n",
        pLine->dwDeviceID,
        pLine->fIsMarkedForDeletion
            ? "closing and being removed"
            : "closing"
        ));

    // see if we are listening
    if (H323IsListening(pLine)) {
   
        // stop listening first 
        H323StopListening(pLine);
    }

    // change line device state to closing
    pLine->nState = H323_LINESTATE_CLOSING;

    // close all calls now in table
    H323CloseCallTable(pLine->pCallTable);

    // delete line if marked
    if (pLine->fIsMarkedForDeletion) {

        // remove line device from table
        H323FreeLineFromTable(pLine, g_pLineTable);

    } else {

        // reset variables
        pLine->htLine = (HTAPILINE)NULL;
        pLine->dwTSPIVersion = 0;
        pLine->dwMediaModes = 0;

        // change line device state to closed
        pLine->nState = H323_LINESTATE_CLOSED;
    }

    // success
    return TRUE; 
}


BOOL
H323InitializeLine(
    PH323_LINE pLine,
    DWORD      dwDeviceID
    )
        
/*++

Routine Description:

    Updates line device based on changes in registry.

Arguments:

    pLine - Pointer to line device to update.

    dwDeviceID - Device ID specified in TSPI_providerInit.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD dwSize = sizeof(pLine->wszAddr);

    // save line device id
    pLine->dwDeviceID = dwDeviceID;

    // create displayable address
    GetComputerNameW(pLine->wszAddr, &dwSize);

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "line %d initialized (addr=%S).\n",
        pLine->dwDeviceID,
        pLine->wszAddr
        ));

    // change line device state to closed
    pLine->nState = H323_LINESTATE_CLOSED;

    // success
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323GetLineAndLock(
    PH323_LINE * ppLine, 
    HDRVLINE     hdLine
    )

/*++

Routine Description:

    Retrieves pointer to line device given line handle.

Arguments:

    ppLine - Specifies a pointer to a DWORD-sized memory location
        into which the service provider must write the line device pointer
        associated with the given line handle.

    hdLine - Specifies the Service Provider's opaque handle to the line.

Return Values:

    Returns true if successful.

--*/

{
    DWORD i;
    PH323_LINE pLine = NULL;

    // lock provider
    H323LockProvider();

    // retrieve line table index
    i = H323GetLineTableIndex(PtrToUlong(hdLine));

    // validate line table index
    if (i >= g_pLineTable->dwNumSlots) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "line handle 0x%08lx invalid.\n",
            PtrToUlong(hdLine)
            ));

        // unlock provider
        H323UnlockProvider();

        // failure
        return FALSE;
    }
    
    // retrieve line pointer from table
    pLine = g_pLineTable->pLines[i];

    // validate call information
    if (!H323IsLineEqual(pLine,hdLine)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "line handle 0x%08lx invalid.\n",
            PtrToUlong(hdLine)
            ));

        // unlock provider
        H323UnlockProvider();

        // failure
        return FALSE;
    }

    // lock line device
    H323LockLine(pLine);
    
    // unlock provider
    H323UnlockProvider();

    // transfer 
    *ppLine = pLine;

    // success
    return TRUE;    
}


BOOL
H323GetLineFromIDAndLock(
    PH323_LINE * ppLine, 
    DWORD        dwDeviceID
    )
        
/*++

Routine Description:

    Retrieves pointer to line device given device id.

Arguments:

    ppLine - Specifies a pointer to a DWORD-sized memory location
        into which the service provider must write the line device pointer
        associated with the given device ID.

    dwDeviceID - Identifies the line device.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;

    // lock provider
    H323LockProvider();

    // loop through each objectin table
    for (i = 0; i < g_pLineTable->dwNumSlots; i++) {

        // validate object is allocated
        if (H323IsLineAllocated(g_pLineTable->pLines[i])) {

            // lock line device
            H323LockLine(g_pLineTable->pLines[i]);

            // compare stored device id with the one specified
            if (H323IsLineInUse(g_pLineTable->pLines[i]) &&
               (g_pLineTable->pLines[i]->dwDeviceID == dwDeviceID)) {

                // transfer line device pointer
                *ppLine = g_pLineTable->pLines[i];

                // unlock provider
                H323UnlockProvider();

                // success
                return TRUE;
            }

            // release line device
            H323UnlockLine(g_pLineTable->pLines[i]);
        }
    }

    // unlock provider
    H323UnlockProvider();

    // initialize
    *ppLine = NULL;

    // failure
    return FALSE;
}


BOOL
H323CallListen(
    PH323_LINE pLine
    )
        
/*++

Routine Description:

    Starts listening for calls on given line device.

Arguments:

    pLine - Pointer to line device to start listening.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;
    CC_ADDR ListenAddr;

    // construct listen address
    ListenAddr.nAddrType = CC_IP_BINARY;
    ListenAddr.Addr.IP_Binary.dwAddr = INADDR_ANY;
    ListenAddr.Addr.IP_Binary.wPort =
        LOWORD(g_RegistrySettings.dwQ931CallSignallingPort);
    ListenAddr.bMulticast = FALSE;

    // start listening
    hr = CC_CallListen(
            &pLine->hccListen,      // phListen
            &ListenAddr,            // pListenAddr
            NULL,                   // pLocalAliasNames        
            PtrToUlong(pLine->hdLine),   // dwListenToken
            H323ListenCallback      // ListenCallback
            );

    // validate status
    if (hr != S_OK) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx calling CC_CallListen.\n", hr
            ));
    
        // re-initialize call listen handle
        pLine->hccListen = UNINITIALIZED;

        // failure
        return FALSE;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "line %d listening for incoming calls.\n", 
        pLine->dwDeviceID
        ));

    // success
    return TRUE;    
}


BOOL
H323StartListening(
    PH323_LINE pLine
    )
        
/*++

Routine Description:

    Starts listening for calls on given line device.

Arguments:

    pLine - Pointer to line device to start listening.

Return Values:

    Returns true if successful.
    
--*/

{   
    // attempt to post call listen message
    if (!H323PostCallListenMessage(pLine->hdLine)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx posting call listen.\n", 
            GetLastError()
            ));
    
        // failure
        return FALSE;
    }

    // change state to listening
    pLine->nState = H323_LINESTATE_LISTENING;

    // success
    return TRUE; 
}


BOOL
H323StopListening(
    PH323_LINE pLine
    )
        
/*++

Routine Description:

    Stops listening for calls on given line device.

Arguments:

    pLine - Pointer to line device to stop listening.

Return Values:

    Returns true if successful.
    
--*/

{
    HRESULT hr;
    
    // stop listening
    hr = CC_CancelListen(pLine->hccListen);

    // validate status
    if (hr != S_OK) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx calling CC_CancelListen.\n", hr
            ));

        // 
        // Unable to cancel listen on line
        // device so uninitialize handle and
        // continue...
        // 
    }

    // change state to opened
    pLine->nState = H323_LINESTATE_OPENED;
    
    // uninitialize listen handle
    pLine->hccListen = UNINITIALIZED;

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "line %d no longer listening for incoming calls.\n", 
        pLine->dwDeviceID
        ));

    // success
    return TRUE;    
}


BOOL
H323AllocLineTable(
    PH323_LINE_TABLE * ppLineTable
    )
        
/*++

Routine Description:

    Allocates table of line objects.

Arguments:

    ppLineTable - Pointer to LPVOID-size memory location in which
        service provider will write pointer to line table.

Return Values:

    Returns true if successful.
    
--*/

{
    int i;
    DWORD dwStatus;
    PH323_LINE_TABLE pLineTable;
    PH323_LINE pLine;
    BOOL fOk = FALSE;

    // allocate table from heap
    pLineTable = H323HeapAlloc(
                     sizeof(H323_LINE_TABLE) + 
                     sizeof(PH323_LINE) * H323_DEFLINESPERINST
                     );

    // validate table pointer
    if (pLineTable == NULL) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate line table.\n"
            ));

        // failure
        goto cleanup;
    }

    // initialize number of slots
    pLineTable->dwNumSlots = H323_DEFLINESPERINST;

    // allocate line device
    if (!H323AllocLineFromTable(&pLine,&pLineTable)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "could not allocate default line.\n"
            ));

        // failure
        goto cleanup;
    }

    // transfer pointer
    *ppLineTable = pLineTable;

    // re-initialize
    pLineTable = NULL;

    // success
    fOk = TRUE;

cleanup:

    // validate pointer
    if (pLineTable != NULL) {

        // free new table
        H323FreeLineTable(pLineTable);
    }

    // done...
    return fOk;
}


BOOL
H323FreeLineTable(
    PH323_LINE_TABLE pLineTable
    )
        
/*++

Routine Description:

    Deallocates table of line objects.

Arguments:

    pLineTable - Pointer to line table to release.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;

    // loop through each object in table
    for (i = 0; i < pLineTable->dwNumSlots; i++) {

        // validate object has been allocated
        if (H323IsLineAllocated(pLineTable->pLines[i])) {

            // release memory for object 
            H323FreeLine(pLineTable->pLines[i]);
        }
    }

    // release memory for table 
    H323HeapFree(pLineTable);

    // success
    return TRUE;
}


BOOL
H323CloseLineTable(
    PH323_LINE_TABLE pLineTable
    )
        
/*++

Routine Description:

    Closes table of line objects.

Arguments:

    pLineTable - Pointer to table to close.

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    
    // loop through each objectin table
    for (i = 0; i < pLineTable->dwNumSlots; i++) {

        // validate object is allocated
        if (H323IsLineAllocated(pLineTable->pLines[i])) {

            // lock line device
            H323LockLine(pLineTable->pLines[i]);

            // see if line device in use
            if (H323IsLineInUse(pLineTable->pLines[i])) {
                        
                // close previously opened object 
                H323CloseLine(pLineTable->pLines[i]);
            }

            // release line device
            H323UnlockLine(pLineTable->pLines[i]);
        }
    }

    // reset table information
    pLineTable->dwNumInUse = 0;
    pLineTable->dwNextAvailable = 0;

    // success
    return TRUE;
}


BOOL
H323AllocLineFromTable(
    PH323_LINE *       ppLine,
    PH323_LINE_TABLE * ppLineTable
    )
        
/*++

Routine Description:

    Allocates line object in table.

Arguments:

    ppLine - Specifies a pointer to a DWORD-sized value in which the
        service provider must write the allocated line object.

    ppLineTable - Pointer to pointer to line table in which to 
        allocate line from (expands table if necessary).

Return Values:

    Returns true if successful.
    
--*/

{
    DWORD i;
    PH323_LINE pLine = NULL;
    PH323_LINE_TABLE pLineTable = *ppLineTable;
    
    // retrieve index to next entry
    i = pLineTable->dwNextAvailable;

    // see if previously allocated entries available
    if (pLineTable->dwNumAllocated > pLineTable->dwNumInUse) {

        // search table looking for available entry
        while (H323IsLineInUse(pLineTable->pLines[i]) ||
              !H323IsLineAllocated(pLineTable->pLines[i])) {

            // increment index and adjust to wrap
            i = H323GetNextIndex(i, pLineTable->dwNumSlots);
        }

        // retrieve pointer to object
        pLine = pLineTable->pLines[i];

        // mark entry as waiting for line device id
        pLine->nState = H323_LINESTATE_WAITING_FOR_ID;

        // initialize call handle with index
        pLine->hdLine = H323CreateLineHandle(i);

        // temporary device id
        pLine->dwDeviceID = PtrToUlong(pLine->hdLine);

        // increment number in use
        pLineTable->dwNumInUse++;

        // adjust next available index
        pLineTable->dwNextAvailable = 
            H323GetNextIndex(i, pLineTable->dwNumSlots);

        // transfer pointer
        *ppLine = pLine;

        // success
        return TRUE;
    } 
    
    // see if table is full and more slots need to be allocated
    if (pLineTable->dwNumAllocated == pLineTable->dwNumSlots) {

        // attempt to double table
        pLineTable = H323HeapReAlloc(
                          pLineTable, 
                          sizeof(H323_LINE_TABLE) +
                          pLineTable->dwNumSlots * 2 * sizeof(PH323_LINE)
                          );                                 

        // validate pointer
        if (pLineTable == NULL) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "could not expand channel table.\n"
                ));

            // failure
            return FALSE;
        }

        // adjust index into table
        i = pLineTable->dwNumSlots;
        
        // adjust number of slots
        pLineTable->dwNumSlots *= 2;

        // transfer pointer to caller
        *ppLineTable = pLineTable;
    } 
    
    // allocate new object 
    if (!H323AllocLine(&pLine)) {

        // failure
        return FALSE;
    }

    // search table looking for slot with no object allocated
    while (H323IsLineAllocated(pLineTable->pLines[i])) {

        // increment index and adjust to wrap
        i = H323GetNextIndex(i, pLineTable->dwNumSlots);
    }

    // store pointer to object
    pLineTable->pLines[i] = pLine;

    // mark entry as being in use
    pLine->nState = H323_LINESTATE_CLOSED;

    // initialize call handle with index
    pLine->hdLine = H323CreateLineHandle(i);

    // temporary device id
    pLine->dwDeviceID = PtrToUlong(pLine->hdLine);

    // increment number in use
    pLineTable->dwNumInUse++;

    // increment number allocated
    pLineTable->dwNumAllocated++;    

    // adjust next available index
    pLineTable->dwNextAvailable = 
        H323GetNextIndex(i, pLineTable->dwNumSlots);

    // transfer pointer
    *ppLine = pLine;

    // success
    return TRUE;
}


BOOL
H323FreeLineFromTable(
    PH323_LINE       pLine,
    PH323_LINE_TABLE pLineTable
    )
        
/*++

Routine Description:

    Deallocates line object in table.

Arguments:

    pLine - Pointer to object to deallocate.

    pLineTable - Pointer to table containing object.

Return Values:

    Returns true if successful.
    
--*/

{
    // reset line object
    H323ResetLine(pLine);

    // decrement entries in use
    pLineTable->dwNumInUse--;

    // success
    return TRUE;    
}


BOOL
H323InitializeLineTable(
    PH323_LINE_TABLE pLineTable,
    DWORD            dwLineDeviceIDBase
    )
        
/*++

Routine Description:

    Updates line devices based on changes to registry settings.  

Arguments:

    pLineTable - Pointer to line table to update.

    dwLineDeviceIDBase - Device ID specified in TSPI_providerInit.

Return Values:

    Returns true if successful.
    
--*/

{
    UINT i;

    // loop through line device structures    
    for (i = 0; i < pLineTable->dwNumSlots; i++) {

        // see if line is allocated
        if (H323IsLineAllocated(pLineTable->pLines[i])) {

            // lock line device
            H323LockLine(pLineTable->pLines[i]);

            // see if line device is in user
            if (H323IsLineInUse(pLineTable->pLines[i])) {

                // update settings
                H323InitializeLine(
                    pLineTable->pLines[i],
                    dwLineDeviceIDBase + g_dwLineDeviceUniqueID++
                    );
            }

            // unlock line device
            H323UnlockLine(pLineTable->pLines[i]);
        }
    }
    
    // success
    return TRUE;
}


BOOL
H323RemoveLine(
    PH323_LINE pLine
    )

/*++

Routine Description:

    Adds line device to line table.

Arguments:

    pLine - Pointer to line device to remove.

Return Values:

    Returns true if successful.
    
--*/

{
    // mark line as about to be removed
    pLine->fIsMarkedForDeletion = TRUE;

    // fire close event
    (*g_pfnLineEventProc)(
        (HTAPILINE)0,       // htLine
        (HTAPICALL)0,       // htCall
        LINE_REMOVE,        // dwMsg
        pLine->dwDeviceID,  // dwParam1
        0,                  // dwParam2
        0                   // dwParam3
        );

    // see if line closed
    if (H323IsLineClosed(pLine)) {

        H323DBG((
            DEBUG_LEVEL_TRACE,
            "line %d being removed.\n",
            pLine->dwDeviceID
            ));

        // remove line device from table
        H323FreeLineFromTable(pLine, g_pLineTable);
    }

    // success
    return TRUE;
}

#if defined(DBG) && defined(DEBUG_CRITICAL_SECTIONS)


VOID
H323LockLine(
    PH323_LINE pLine
    )
        
/*++

Routine Description:

    Locks line device.

Arguments:

    pLine - Pointer to line to lock.

Return Values:

    None.
    
--*/

{
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "line %d about to be locked.\n",
        pLine->dwDeviceID
        ));

    // lock line device    
    EnterCriticalSection(&pLine->Lock);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "line %d locked.\n",
        pLine->dwDeviceID
        ));
}


VOID
H323UnlockLine(
    PH323_LINE pLine
    )
        
/*++

Routine Description:

    Unlocks line device.

Arguments:

    pLine - Pointer to line to unlock.

Return Values:

    None.
    
--*/

{
    // unlock line device    
    LeaveCriticalSection(&pLine->Lock);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "line %d unlocked.\n",
        pLine->dwDeviceID
        ));
}

#endif // DBG && DEBUG_CRITICAL_SECTIONS


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI procedures                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE hdLine
    )
        
/*++

Routine Description:

    This function closes the specified open line device after completing or 
    aborting all outstanding calls and asynchronous operations on the device.

    The Service Provider has the responsibility to (eventually) report 
    completion for every operation it decides to execute asynchronously.  
    If this procedure is called for a line on which there are outstanding 
    asynchronous operations, the operations should be reported complete with an
    appropriate result or error code before this procedure returns.  Generally
    the TAPI DLL would wait for these to complete in an orderly fashion.  
    However, the Service Provider should be prepared to handle an early call to
    TSPI_lineClose in "abort" or "emergency shutdown" situtations.

    A similar requirement exists for active calls on the line.  Such calls must 
    be dropped, with outstanding operations reported complete with appropriate 
    result or error codes.
    
    After this procedure returns the Service Provider must report no further 
    events on the line or calls that were on the line.  The Service Provider's 
    opaque handles for the line and calls on the line become "invalid".

    The Service Provider must relinquish non-sharable resources it reserves 
    while the line is open.  For example, closing a line accessed through a 
    comm port and modem should result in closing the comm port, making it once 
    available for use by other applications.

    This function is presumed to complete successfully and synchronously.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line to be
        closed.  After the line has been successfully closed, this handle is 
        no longer valid.

Return Values:

    Returns zero if the function is successful, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified device handle is invalid.
        
        LINEERR_OPERATIONFAILED - The specified operation failed for unknown 
            reasons.

--*/

{
    PH323_LINE pLine = NULL;

    // retrieve line pointer from handle
    if (!H323GetLineAndLock(&pLine, hdLine)) {

        // invalid line handle 
        return LINEERR_INVALLINEHANDLE;
    }

    // attempt to close line device
    if (!H323CloseLine(pLine)) {

        // release line device
        H323UnlockLine(pLine);

        // could not close line device
        return LINEERR_OPERATIONFAILED;
    }

    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD         dwDeviceID,
    DWORD         dwTSPIVersion,
    DWORD         dwExtVersion,
    LPLINEDEVCAPS pLineDevCaps
    )
    
/*++

Routine Description:

    This function queries a specified line device to determine its telephony 
    capabilities. The returned information is valid for all addresses on the 
    line device.

    Line device ID numbering for a Service Provider is sequential from the 
    value set by the function TSPI_lineSetDeviceIDBase.

    The dwExtVersion field of pLineDevCaps has already been filled in to 
    indicate the version number of the Extension information requested.  If 
    it is zero, no Extension information is requested.  If it is non-zero it 
    holds a value that has already been negotiated for this device with the 
    function TSPI_lineNegotiateExtVersion.  The Service Provider should fill 
    in Extension information according to the Extension version specified.

    One of the fields in the LINEDEVCAPS structure returned by this function 
    contains the number of addresses assigned to the specified line device. 
    The actual address IDs used to reference individual addresses vary from 
    zero to one less than the returned number. The capabilities of each 
    address may be different. Use TSPI_lineGetAddressCaps for each available 
    <dwDeviceID, dwAddressID> combination to determine the exact capabilities 
    of each address.

Arguments:

    dwDeviceID - Specifies the line device to be queried.

    dwTSPIVersion - Specifies the negotiated TSPI version number.  This value 
        has already been negotiated for this device through the 
        TSPI_lineNegotiateTSPIVersion function.

    pLineDevCaps - Specifies a far pointer to a variable sized structure of 
        type LINEDEVCAPS. Upon successful completion of the request, this 
        structure is filled with line device capabilities information.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API 
            version or version range that is either incompatible or cannot 
            be supported by the Telephony API implementation and/or 
            corresponding service provider. 

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure 
            does not specify enough memory to contain the fixed portion of 
            the structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    DWORD dwLineNameSize;
    DWORD dwProviderInfoSize;

    PH323_LINE pLine = NULL;

    // make sure this is a version we support
    if (!H323ValidateTSPIVersion(dwTSPIVersion)) {

        // do not support tspi version
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    // make sure this is a version we support    
    if (!H323ValidateExtVersion(dwExtVersion)) {

        // do not support extensions 
        return LINEERR_INVALEXTVERSION;
    }

    // retrieve line device pointer from device id
    if (!H323GetLineFromIDAndLock(&pLine, dwDeviceID)) {

        // invalid line device id
        return LINEERR_BADDEVICEID;
    }

    // determine string lengths    
    dwProviderInfoSize  = H323SizeOfWSZ(g_pwszProviderInfo);
    dwLineNameSize      = H323SizeOfWSZ(g_pwszLineName);

    // calculate number of bytes required 
    pLineDevCaps->dwNeededSize = sizeof(LINEDEVCAPS) +
                                 dwProviderInfoSize  +
                                 dwLineNameSize     
                                 ;

    // make sure buffer is large enough for variable length data
    if (pLineDevCaps->dwTotalSize >= pLineDevCaps->dwNeededSize) {

        // record amount of memory used
        pLineDevCaps->dwUsedSize = pLineDevCaps->dwNeededSize;

        // position provider info after fixed portion
        pLineDevCaps->dwProviderInfoSize = dwProviderInfoSize;
        pLineDevCaps->dwProviderInfoOffset = sizeof(LINEDEVCAPS);

        // position line name after device class
        pLineDevCaps->dwLineNameSize = dwLineNameSize;
        pLineDevCaps->dwLineNameOffset = 
            pLineDevCaps->dwProviderInfoOffset +
            pLineDevCaps->dwProviderInfoSize
            ;

        // copy provider info after fixed portion
        memcpy((LPBYTE)pLineDevCaps + pLineDevCaps->dwProviderInfoOffset,
               (LPBYTE)g_pwszProviderInfo,
               pLineDevCaps->dwProviderInfoSize
               );
                
        // copy line name after device class
        memcpy((LPBYTE)pLineDevCaps + pLineDevCaps->dwLineNameOffset,
               (LPBYTE)g_pwszLineName,
               pLineDevCaps->dwLineNameSize
               );

    } else if (pLineDevCaps->dwTotalSize >= sizeof(LINEDEVCAPS)) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "linedevcaps structure too small for strings.\n"
            ));

        // structure only contains fixed portion
        pLineDevCaps->dwUsedSize = sizeof(LINEDEVCAPS);

    } else {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "linedevcaps structure too small.\n"
            ));

        // release line device
        H323UnlockLine(pLine);

        // structure is too small
        return LINEERR_STRUCTURETOOSMALL;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "line %d capabilities requested.\n",
        pLine->dwDeviceID
        ));
    
    // construct permanent line identifier
    pLineDevCaps->dwPermanentLineID = (DWORD)MAKELONG(
        dwDeviceID - g_dwLineDeviceIDBase,
        g_dwPermanentProviderID
        );

    // notify tapi that strings returned are in unicode
    pLineDevCaps->dwStringFormat = STRINGFORMAT_UNICODE;

    // initialize line device capabilities
    pLineDevCaps->dwNumAddresses      = H323_MAXADDRSPERLINE;
    pLineDevCaps->dwMaxNumActiveCalls = H323_MAXCALLSPERLINE;
    pLineDevCaps->dwAddressModes      = H323_LINE_ADDRESSMODES;
    pLineDevCaps->dwBearerModes       = H323_LINE_BEARERMODES;
    pLineDevCaps->dwDevCapFlags       = H323_LINE_DEVCAPFLAGS;
    pLineDevCaps->dwLineFeatures      = H323_LINE_LINEFEATURES;
    pLineDevCaps->dwMaxRate           = H323_LINE_MAXRATE;
    pLineDevCaps->dwMediaModes        = H323_LINE_MEDIAMODES;
    pLineDevCaps->dwRingModes         = 0;

    // initialize address types to include phone numbers
    pLineDevCaps->dwAddressTypes = H323_LINE_ADDRESSTYPES;

    // line guid
    memcpy(
        &pLineDevCaps->PermanentLineGuid,
        &LINE_H323,
        sizeof(GUID)
        );

    // modify GUID to be unique for each line
    pLineDevCaps->PermanentLineGuid.Data1 +=
        dwDeviceID - g_dwLineDeviceIDBase;

    // protocol guid
    memcpy(
         &pLineDevCaps->ProtocolGuid,
         &TAPIPROTOCOL_H323,
         sizeof(GUID)
         );

    // add dtmf support via H.245 user input messages
    pLineDevCaps->dwGenerateDigitModes = LINEDIGITMODE_DTMF;
    pLineDevCaps->dwMonitorDigitModes  = LINEDIGITMODE_DTMF;

    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS pLineDevStatus
    )
    
/*++

Routine Description:

    This operation enables the TAPI DLL to query the specified open line 
    device for its current status.

    The TAPI DLL uses TSPI_lineGetLineDevStatus to query the line device 
    for its current line status. This status information applies globally 
    to all addresses on the line device. Use TSPI_lineGetAddressStatus to 
    determine status information about a specific address on a line.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line 
        to be queried.

    pLineDevStatus - Specifies a far pointer to a variable sized data 
        structure of type LINEDEVSTATUS. Upon successful completion of 
        the request, this structure is filled with the line's device status.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified line device handle is invalid.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    PH323_LINE pLine = NULL;
    
    // retrieve line device pointer from handle
    if (!H323GetLineAndLock(&pLine, hdLine)) {

        // invalid line device handle
        return LINEERR_INVALLINEHANDLE;
    }

    // determine number of bytes needed
    pLineDevStatus->dwNeededSize = sizeof(LINEDEVSTATUS);
    
    // see if allocated structure is large enough
    if (pLineDevStatus->dwTotalSize < pLineDevStatus->dwNeededSize) {
        
        H323DBG((
            DEBUG_LEVEL_ERROR,
            "linedevstatus structure too small.\n"
            ));

        // release line device
        H323UnlockLine(pLine);

        // structure too small
        return LINEERR_STRUCTURETOOSMALL;
    }
    
    // record number of bytes used
    pLineDevStatus->dwUsedSize = pLineDevStatus->dwNeededSize;
    
    // initialize supported line device status fields
    pLineDevStatus->dwLineFeatures   = H323_LINE_LINEFEATURES;
    pLineDevStatus->dwDevStatusFlags = H323_LINE_DEVSTATUSFLAGS;

    // determine number of active calls on the line device
    pLineDevStatus->dwNumActiveCalls = pLine->pCallTable->dwNumInUse;

    // release line device
    H323UnlockLine(pLine);
    
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE hdLine,
    LPDWORD  pdwNumAddressIDs
    )
    
/*++

Routine Description:

    Retrieves the number of address IDs supported on the indicated line.

    This function is called by TAPI.DLL in response to an application calling
    lineSetNumRings, lineGetNumRings, or lineGetNewCalls. TAPI.DLL uses the 
    retrieved value to determine if the specified address ID is within the 
    range supported by the service provider.

Arguments:

    hdLine - Specifies the handle to the line for which the number of address 
        IDs is to be retrieved.

    pdwNumAddressIDs - Specifies a far pointer to a DWORD. The location is 
        filled with the number of address IDs supported on the indicated line. 
        The value should be one or larger.

Return Values:

    Returns zero if the function is successful, or a negative error number 
    if an error has occurred. Possible return values are as follows:

        LINEERR_INVALLINEHANDLE - The specified line device handle is invalid.

--*/

{
    PH323_LINE pLine = NULL;
    
    // retrieve line device pointer from handle
    if (!H323GetLineAndLock(&pLine, hdLine)) {

        // invalid line device handle
        return LINEERR_INVALLINEHANDLE;
    }

    // transfer number of addresses
    *pdwNumAddressIDs = H323_MAXADDRSPERLINE;

    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineOpen(
    DWORD      dwDeviceID,
    HTAPILINE  htLine,
    LPHDRVLINE phdLine,
    DWORD      dwTSPIVersion,
    LINEEVENT  pfnEventProc
    )
    
/*++

Routine Description:

    This function opens the line device whose device ID is given, returning 
    the Service Provider's opaque handle for the device and retaining the TAPI
    DLL's opaque handle for the device for use in subsequent calls to the 
    LINEEVENT procedure.

    Opening a line entitles the TAPI DLL to make further requests on the line.
    The line becomes "active" in the sense that the TAPI DLL can initiate 
    outbound calls and the Service Provider can report inbound calls.  The 
    Service Provider reserves whatever non-sharable resources are required to 
    manage the line.  For example, opening a line accessed through a comm port 
    and modem should result in opening the comm port, making it no longer 
    available for use by other applications.
    
    If the function is successful, both the TAPI DLL and the Service Provider 
    become committed to operating under the specified interface version number 
    for this open device.  Subsquent operations and events identified using 
    the exchanged opaque line handles conform to that interface version.  This 
    commitment and the validity of the handles remain in effect until the TAPI
    DLL closes the line using the TSPI_lineClose operation or the Service 
    Provider reports the LINE_CLOSE event.  If the function is not successful,
    no such commitment is made and the handles are not valid.

Arguments:

    dwDeviceID - Identifies the line device to be opened.  The value 
        LINE_MAPPER for a device ID is not permitted.

    htLine - Specifies the TAPI DLL's opaque handle for the line device to be 
        used in subsequent calls to the LINEEVENT callback procedure to 
        identify the device.

    phdLine - A far pointer to a HDRVLINE where the Service Provider fills in
        its opaque handle for the line device to be used by the TAPI DLL in 
        subsequent calls to identify the device.

    dwTSPIVersion - The TSPI version negotiated through 
        TSPI_lineNegotiateTSPIVersion under which the Service Provider is 
        willing to operate.

    pfnEventProc - A far pointer to the LINEEVENT callback procedure supplied
        by the TAPI DLL that the Service Provider will call to report 
        subsequent events on the line.

Return Values:

    Returns zero if the function is successful, or a negative error number 
    if an error has occurred. Possible return values are as follows:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_INCOMPATIBLEAPIVERSION - The passed TSPI version or version 
            range did not match an interface version definition supported by 
            the service provider.

        LINEERR_INUSE - The line device is in use and cannot currently be 
            configured, allow a party to be added, allow a call to be 
            answered, or allow a call to be placed. 

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified or 
            unknown reason. 

--*/

{
    PH323_LINE pLine = NULL;
    
    // make sure this is a version we support    
    if (!H323ValidateTSPIVersion(dwTSPIVersion)) {

        // failure 
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    // retrieve pointer to line device from device id
    if (!H323GetLineFromIDAndLock(&pLine, dwDeviceID)) {

        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // see if line device is closed
    if (!H323IsLineClosed(pLine) &&
        !pLine->fIsMarkedForDeletion) {

        // see if line device is open
        if (H323IsLineOpen(pLine)) {

            H323DBG((
                DEBUG_LEVEL_ERROR,
                "line %d already opened.\n",
                pLine->dwDeviceID
                ));

            // release line device
            H323UnlockLine(pLine);

            // line already in use
            return LINEERR_INUSE;
        }

        // release line device
        H323UnlockLine(pLine);

        // line not intialized
        return LINEERR_INVALLINESTATE;
    }

    // attempt to open line device
    if (!H323OpenLine(pLine, htLine, dwTSPIVersion)) {

        // release line device
        H323UnlockLine(pLine);

        // could not open line device
        return LINEERR_OPERATIONFAILED;
    }

    // retrurn line handle 
    *phdLine = pLine->hdLine;
    
    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineCreateMSPInstance(
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HTAPIMSPLINE    htMSPLine,
    LPHDRVMSPLINE   phdMSPLine
    )
{
    PH323_LINE pLine = NULL;

    // retrieve line pointer from handle
    if (!H323GetLineAndLock(&pLine, hdLine)) {

        // invalid line handle 
        return LINEERR_INVALLINEHANDLE;
    }
    // We are not keeping the msp handles. Just fake a handle here.
    *phdMSPLine = (HDRVMSPLINE)pLine->dwNextMSPHandle++;

    // release line device
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineCloseMSPInstance(
    HDRVMSPLINE hdMSPLine
    )
{
    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\provider.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    provider.c

Abstract:

    TAPI Service Provider functions related to provider info.

        TSPI_providerConfig
        TSPI_providerEnumDevices
        TSPI_providerFreeDialogInstance
        TSPI_providerGenericDialogData
        TSPI_providerInit
        TSPI_providerInstall
        TSPI_providerRemove
        TSPI_providerShutdown
        TSPI_providerUIIdentify

        TUISPI_providerConfig
        TUISPI_providerInstall
        TUISPI_providerRemove

Environment:

    User Mode - Win32

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "provider.h"
#include "callback.h"
#include "registry.h"
#include "termcaps.h"
#include "version.h"
#include "line.h"
#include "config.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD g_dwTSPIVersion = UNINITIALIZED;
DWORD g_dwLineDeviceIDBase = UNINITIALIZED;
DWORD g_dwPermanentProviderID = UNINITIALIZED;
ASYNC_COMPLETION g_pfnCompletionProc = NULL;
LINEEVENT g_pfnLineEventProc = NULL;
HPROVIDER g_hProvider = (HPROVIDER)NULL;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#if defined(DBG) && defined(DEBUG_CRITICAL_SECTIONS)

VOID
H323LockProvider(
    )

/*++

Routine Description:

    Locks service provider.

Arguments:

    None.

Return Values:

    None.

--*/

{
    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "provider about to be locked.\n"
        ));

    // lock service provider
    EnterCriticalSection(&g_GlobalLock);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "provider locked.\n"
        ));
}


VOID
H323UnlockProvider(
    )

/*++

Routine Description:

    Unlocks service provider.

Arguments:

    None.

Return Values:

    None.

--*/

{
    // unlock service provider
    LeaveCriticalSection(&g_GlobalLock);

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "provider unlocked.\n"
        ));
}

#endif // DBG && DEBUG_CRITICAL_SECTIONS


BOOL
H323IsTSPAlreadyInstalled(
    )

/*++

Routine Description:

    Searchs registry for previous instance of H323.TSP.

Arguments:

    None.

Return Values:

    Returns true if TSP already installed.

--*/

{
    DWORD i;
    HKEY hKey;
    LONG lStatus;
    DWORD dwNumProviders = 0;
    DWORD dwDataSize = sizeof(DWORD);
    DWORD dwDataType = REG_DWORD;
    LPSTR pszProvidersKey = TAPI_REGKEY_PROVIDERS;
    LPSTR pszNumProvidersValue = TAPI_REGVAL_NUMPROVIDERS;
    CHAR szName[H323_MAXPATHNAMELEN+1];
    CHAR szPath[H323_MAXPATHNAMELEN+1];

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszProvidersKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "error 0x%08lx opening tapi providers key.\n",
            lStatus
            ));

        // done
        return FALSE;
    }

    // see if installed bit set
    lStatus = RegQueryValueEx(
                hKey,
                pszNumProvidersValue,
                0,
                &dwDataType,
                (LPBYTE) &dwNumProviders,
                &dwDataSize
                );

    // validate status
    if (lStatus != NOERROR) {

        H323DBG((
            DEBUG_LEVEL_WARNING,
            "error 0x%08lx determining number of providers.\n",
            lStatus
            ));

        // release handle
        RegCloseKey(hKey);

        // done
        return FALSE;
    }

    // loop through each provider
    for (i = 0; i < dwNumProviders; i++) {

        // construct path to provider name
        wsprintf(szName, "ProviderFileName%d", i);

        // reinitialize size
        dwDataSize = sizeof(szPath);

        // query the next name
        lStatus = RegQueryValueEx(
                        hKey,
                        szName,
                        0,
                        &dwDataType,
                        szPath,
                        &dwDataSize
                        );

        // validate status
        if (lStatus == NOERROR) {

            // upper case
            _strupr(szPath);

            // compare path string to h323 provider
            if (strstr(szPath, H323_TSPDLL) != NULL) {

                // release handle
                RegCloseKey(hKey);

                // done
                return TRUE;
            }

        } else {

            H323DBG((
                DEBUG_LEVEL_WARNING,
                "error 0x%08lx loading %s.\n",
                lStatus,
                szName
                ));
        }
    }

    // release handle
    RegCloseKey(hKey);

    // done
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI procedures                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
TSPIAPI
TSPI_providerCreateLineDevice(
    DWORD_PTR dwTempID,
    DWORD dwDeviceID
    )

/*++

Routine Description:


    This function is called by TAPI in response to receipt of a LINE_CREATE
    message from the service provider, which allows the dynamic creation of
    a new line device.

Arguments:

    dwTempID - The temporary device identifier that the service provider
        passed to TAPI in the LINE_CREATE message.

    dwDeviceID - The device identifier that TAPI assigns to this device if
        this function succeeds.

Return Values:

    Returns zero if the request is successful or a negative error number if
    an error has occurred. Possible return values are:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    PH323_LINE pLine = NULL;

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "creating new device %d (hdLine=0x%08lx).\n",
        dwDeviceID,
        dwTempID
        ));

    // lock line device using temporary device id
    if (!H323GetLineFromIDAndLock(&pLine, (DWORD)dwTempID)) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "invalid temp device id 0x%08lx.\n",
            dwTempID
            ));

        // failure
        return LINEERR_BADDEVICEID;
    }

    // initialize new line device
    H323InitializeLine(pLine, dwDeviceID);

    // unlock line
    H323UnlockLine(pLine);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD      dwPermanentProviderID,
    PDWORD     pdwNumLines,
    PDWORD     pdwNumPhones,
    HPROVIDER  hProvider,
    LINEEVENT  pfnLineCreateProc,
    PHONEEVENT pfnPhoneCreateProc
    )

/*++

Routine Description:

    TAPI.DLL calls this function before TSPI_providerInit to determine the
    number of line and phone devices supported by the service provider.

Arguments:

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        initialized.

    pdwNumLines - Specifies a far pointer to a DWORD-sized memory location
        into which the service provider must write the number of line devices
        it is configured to support. TAPI.DLL initializes the value to zero,
        so if the service provider fails to write a different value, the
        value 0 is assumed.

    pdwNumPhones - Specifies a far pointer to a DWORD-sized memory location
        into which the service provider must write the number of phone devices
        it is configured to support. TAPI.DLL initializes the value to zero,
        so if the service provider fails to write a different value, the
        value 0 is assumed.

    hProvider - Specifies an opaque DWORD-sized value which uniquely identifies
        this instance of this service provider during this execution of the
        Windows Telephony environment.

    pfnLineCreateProc - Specifies a far pointer to the LINEEVENT callback
        procedure supplied by TAPI.DLL. The service provider will use this
        function to send LINE_CREATE messages when a new line device needs to
        be created. This function should not be called to send a LINE_CREATE
        message until after the service provider has returned from the
        TSPI_providerInit procedure.

    pfnPhoneCreateProc - Specifies a far pointer to the PHONEEVENT callback
        procedure supplied by TAPI.DLL. The service provider will use this
        function to send PHONE_CREATE messages when a new phone device needs
        to be created. This function should not be called to send a
        PHONE_CREATE message until after the service provider has returned
        from the TSPI_providerInit procedure.

Return Values:

    Returns zero if the request is successful or a negative error number if
    an error has occurred. Possible return values are:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    WSADATA wsaData;
    WORD wVersionRequested = H323_WINSOCKVERSION;

    UNREFERENCED_PARAMETER(pdwNumPhones);           // no phone support
    UNREFERENCED_PARAMETER(pfnPhoneCreateProc);     // no dynamic phones
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // legacy parameter

    // initialize winsock stack
    WSAStartup(wVersionRequested, &wsaData);

    // lock provider
    H323LockProvider();

    // save provider handle
    g_hProvider = hProvider;

    // save line create tapi callback
    g_pfnLineEventProc = pfnLineCreateProc;

    // install defaults
    H323SetDefaultConfig();

    // load registry parameters
    H323GetConfigFromRegistry();

    // initialize line table
    if (!H323AllocLineTable(&g_pLineTable)) {

        // shutdown
        WSACleanup();

        // unlock provider
        H323UnlockProvider();

        // could not create line table
        return LINEERR_OPERATIONFAILED;
    }

    H323DBG((
        DEBUG_LEVEL_VERBOSE,
        "service provider supports %d line(s).\n",
        g_pLineTable->dwNumInUse
        ));

    // report number of interfaces
    *pdwNumLines = g_pLineTable->dwNumInUse;

    // unlock provider
    H323UnlockProvider();

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerInit(
    DWORD            dwTSPIVersion,
    DWORD            dwPermanentProviderID,
    DWORD            dwLineDeviceIDBase,
    DWORD            dwPhoneDeviceIDBase,
    DWORD_PTR        dwNumLines,
    DWORD_PTR        dwNumPhones,
    ASYNC_COMPLETION pfnCompletionProc,
    LPDWORD          pdwTSPIOptions
    )

/*++

Routine Description:

    Initializes the service provider, also giving it parameters required for
    subsequent operation.

    This function is guaranteed to be called before any of the other functions
    prefixed with TSPI_line or TSPI_phone except TSPI_lineNegotiateTSPIVersion.
    It is strictly paired with a subsequent call to TSPI_providerShutdown. It
    is the caller's reponsibility to ensure proper pairing.

    Note that a service provider should perform as many consistency checks as
    is practical at the time TSPI_providerInit is called to ensure that it is
    ready to run. Some consistency or installation errors, however, may not be
    detectable until the operation is attempted. The error LINEERR_NODRIVER can
    be used to report such non-specific errors at the time they are detected.

    There is no directly corresponding function at the TAPI level. At that
    level, multiple different usage instances can be outstanding, with an
    "application handle" returned to identify the instance in subsequent
    operations. At the TSPI level, the interface architecture supports only a
    single usage instance for each distinct service provider.

    A new parameter, lpdwTSPIOptions, is added to this function. This parameter
    allows the service provider to return bits indicating optional behaviors
    desired of TAPI. TAPI sets the options DWORD to 0 before calling
    TSPI_providerInit, so if the service provider doesn't want any of these
    options, it can just leave the DWORD set to 0.

    At this time, only one bit is defined to be returned through this pointer:
    LINETSPIOPTION_NONREENTRANT. The service provider sets this bit if it is
    not designed for fully pre-emptive, multithreaded, multitasking,
    multiprocessor operation (e.g., updating of global data protected by
    mutexes). When this bit is set, TAPI will only make one call at a time to
    the service provider; it will not call any other entry point, nor that
    entry point again, until the service provider returns from the original
    function call. Without this bit set, TAPI may call into multiple service
    provider entry points, including multiple times to the same entry point,
    simultaneously (actually simultaneously in a multiprocessor system). Note:
    TAPI will not serialize access to TSPI functions that display a dialog
    (TUISPI_lineConfigDialog, TUISPI_lineConfigDialogEdit,
    TUISPI_phoneConfigDialog, TUISPI_providerConfig, TUISPI_providerInstall,
    TUISPI_providerRemove) so that they do not block other TSPI functions
    from being called; the service provider must include internal protection
    on these functions.

Arguments:

    dwTSPIVersion - Specifies the version of the TSPI definition under which
        this function must operate. The caller may use
        TSPI_lineNegotiateTSPIVersion with the special dwDeviceID
        INITIALIZE_NEGOTIATION to negotiate a version that is guaranteed to be
        acceptible to the service provider.

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        initialized.

    dwLineDeviceIDBase - Specifies the lowest device ID for the line devices
        supported by this service provider.

    dwPhoneDeviceIDBase - Specifies the lowest device ID for the phone devices
        supported by this service provider.

    dwNumLines - Specifies how many line devices this service provider
        supports.

    dwNumPhones - Specifies how many line devices this service provider
        supports.

    pfnCompletionProc - Specifies the procedure the service provider calls to
        report completion of all asynchronously operating procedures on line
        and phone devices.

    pdwTSPIOptions - A pointer to a DWORD-sized memory location, into which
        the service provider may write a value specifying LINETSPIOPTIONS_
        values.

Return Values:

    Returns zero if the function is successful, or a negative error number if
    an error has occurred. Possible return values are as follows:

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API
            version or version range that is either incompatible or cannot be
            supported by the Telephony API implementation and/or corresponding
            service provider.

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

        LINEERR_RESOURCEUNAVAIL - Insufficient resources to complete the
            operation.

--*/

{
    UNREFERENCED_PARAMETER(dwNumLines);             // legacy parameter
    UNREFERENCED_PARAMETER(dwNumPhones);            // legacy parameter
    UNREFERENCED_PARAMETER(dwPhoneDeviceIDBase);    // no phone support
    UNREFERENCED_PARAMETER(pdwTSPIOptions);         // already thread-safe

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "initializing service provider.\n"
        ));

    // make sure this is a version we support
    if (!H323ValidateTSPIVersion(dwTSPIVersion)) {

        // incompatible api version
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    // lock provider
    H323LockProvider();

    // initialize caps
    InitializeTermCaps();

    // initialize line table using device id base
    if (!H323InitializeLineTable(g_pLineTable, dwLineDeviceIDBase)) {

        // unlock provider
        H323UnlockProvider();

        // could not update lines
        return LINEERR_OPERATIONFAILED;
    }

    // start callback thread
    if (!H323StartCallbackThread()) {

        // unlock provider
        H323UnlockProvider();

        // could not start thread
        return LINEERR_OPERATIONFAILED;
    }

    // save global service provider info
    g_dwTSPIVersion         = dwTSPIVersion;
    g_pfnCompletionProc     = pfnCompletionProc;
    g_dwLineDeviceIDBase    = dwLineDeviceIDBase;
    g_dwPermanentProviderID = dwPermanentProviderID;

    // unlock provider
    H323UnlockProvider();

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD dwTSPIVersion,
    DWORD dwPermanentProviderID
    )

/*++

Routine Description:

    Shuts down the service provider. The service provider should terminate
    any activities it has in progress and release any resources it has
    allocated.

Arguments:

    dwTSPIVersion - Specifies the version of the TSPI definition under which
        this function must operate. The caller may use
        TSPI_lineNegotiateTSPIVersion or TSPI_phoneNegotiateTSPIVersion with
        the special dwDeviceID INITIALIZE_NEGOTIATION to negotiate a version
        that is guaranteed to be acceptible to the service provider.

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        shut down.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API
            version or version range that is either incompatible or cannot be
            supported by the Telephony API implementation and/or corresponding
            service provider.

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // legacy parameter

    // make sure this is a version we support
    if (!H323ValidateTSPIVersion(dwTSPIVersion)) {

        // failure
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    // lock provider
    H323LockProvider();

    // close open line devices
    if( g_pLineTable ) {
        if (!H323CloseLineTable(g_pLineTable)) {

            // unlock provider
            H323UnlockProvider();

            // failure
            return LINEERR_OPERATIONFAILED;
        }
    }

    // stop callback thread last
    if (!H323StopCallbackThread()) {

        // unlock provider
        H323UnlockProvider();

        // could not stop thread
        return LINEERR_OPERATIONFAILED;
    }

    // release memory for line devices
    if (!H323FreeLineTable(g_pLineTable)) {

        // unlock provider
        H323UnlockProvider();

        // failure
        return LINEERR_OPERATIONFAILED;
    }

    // shutdown
    WSACleanup();

    // re-initialize
    g_pLineTable = NULL;

    // unlock provider
    H323UnlockProvider();

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerInstall(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )

/*++

Routine Description:

    The TSPI_providerInstall function is obsolete. TAPI version 1.4
    or earlier service providers can implement this TSPI function.
    TAPI version 2.0 or later TSPs implement TUISPI_providerInstall.

Arguments:

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        installation.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Always returns NOERROR.

--*/

{
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerRemove(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )

/*++

Routine Description:

    The TSPI_providerRemove function is obsolete. TAPI version 1.4 or
    earlier service providers can implement this TSPI function. TAPI
    version 2.0 or later TSPs implement TUISPI_providerRemove.

Arguments:

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        installation.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Always returns NOERROR.

--*/

{
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR pwszUIDLLName
   )

/*++

Routine Description:

    The TSPI_providerUIIdentify function extracts from the service
    provider the fully qualified path to load the service provider's
    UI DLL component.

    Implementation is mandatory if the service provider implements
    any UI DLL functions.

Arguments:

    pwszUIDLLName - Pointer to a block of memory at least MAX_PATH
        in length, into which the service provider must copy a NULL-
        terminated string specifying the fully-qualified path for the
        DLL containing the service provider functions which must execute
        in the process of the calling application.

Return Values:

    Always returns NOERROR.

--*/

{
    // copy name of our dll as ui dll
    lstrcpyW(pwszUIDLLName,H323_UIDLL);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND              hwndOwner,
    DWORD             dwPermanentProviderID
    )

/*++

Routine Description:

    Implementation of the TUISPI_providerInstall function is the
    service provider's opportunity to install any additional
    "pieces" of the provider into the right directories (or at
    least verifying that they're there) and set up registry entries
    the provider needs.

Arguments:

    pfnUIDLLCallback - Pointer to a function the UI DLL can call to
        communicate with the service provider DLL to obtain information
        needed to display the dialog box.

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        installation.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_NOMULTIPLEINSTANCE - A telephony service provider which
            does not support multiple instances is listed more than once
            in the [Providers] section in the registry. The application

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    HKEY hKey;
    HKEY hKeyTSP;
    LONG lStatus;
    LPSTR pszKey;

    UNREFERENCED_PARAMETER(pfnUIDLLCallback);
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    // check for previous instance
    if (H323IsTSPAlreadyInstalled()) {

        // cannot be installed twice
        return LINEERR_NOMULTIPLEINSTANCE;
    }

    // set key to h323
    pszKey = H323_REGKEY_ROOT;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if (lStatus == NOERROR) {

        H323DBG((
            DEBUG_LEVEL_TRACE,
            "successfully installed H.323 provider.\n"
            ));

        // release handle
        RegCloseKey(hKey);

        // success
        return NOERROR;
    }

    // set key to windows
    pszKey = WINDOWS_REGKEY_ROOT;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_WRITE,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx opening windows registry key.\n",
            lStatus
            ));

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    // attempt to create key
    lStatus = RegCreateKey(
                hKey,
                H323_SUBKEY,
                &hKeyTSP
                );

    // validate status
    if (lStatus != NOERROR) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx creating tsp registry key.\n",
            lStatus
            ));

        // release handle
        RegCloseKey(hKey);

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "successfully installed H.323 provider.\n"
        ));

    // release handle
    RegCloseKey(hKeyTSP);

    // release handle
    RegCloseKey(hKey);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND hwndOwner,
    DWORD dwPermanentProviderID
    )

/*++

Routine Description:

    The TUISPI_providerRemove function asks the user to confirm
    elimination of the service provider.

    It is the responsibility of the service provider to remove any
    registry entries that the service provider added at addProvider
    time, as well as any other modules and files that are no longer
    needed.

Arguments:

    pfnUIDLLCallback - Pointer to a function the UI DLL can call to
        communicate with the service provider DLL to obtain information
        needed to display the dialog box.

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        removal.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    HKEY hKey;
    LONG lStatus;
    LPSTR pszKey;

    UNREFERENCED_PARAMETER(pfnUIDLLCallback);
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    // set key to h323
    pszKey = H323_REGKEY_ROOT;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR) {

        H323DBG((
            DEBUG_LEVEL_TRACE,
            "successfully removed H.323 provider.\n"
            ));

        // success
        return NOERROR;
    }

    // release handle
    RegCloseKey(hKey);

    // set key to windows
    pszKey = WINDOWS_REGKEY_ROOT;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_WRITE,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx opening windows registry key.\n",
            lStatus
            ));

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    // attempt to delete key
    lStatus = RegDeleteKey(
                hKey,
                H323_SUBKEY
                );

    // validate status
    if (lStatus != NOERROR) {

        H323DBG((
            DEBUG_LEVEL_ERROR,
            "error 0x%08lx deleting tsp registry key.\n",
            lStatus
            ));

        // release handle
        RegCloseKey(hKey);

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    H323DBG((
        DEBUG_LEVEL_TRACE,
        "successfully removed H.323 provider.\n"
        ));

    // release handle
    RegCloseKey(hKey);

    // success
    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\termcaps.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    termcaps.h

Abstract:

    Definitions for H.323 TAPI Service Provider terminal capabilities.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_TERMCAPS
#define _INC_TERMCAPS
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Definitions                                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define RTP_HEADER_SIZE                         12
#define RTP_PACKET_SIZE_UNKNOWN                 0

// RTP + UDP + IP
#define TOTAL_HEADER_SIZE                       40 

#define G723_RTP_PAYLOAD_TYPE                   4
#define G723_BYTES_PER_FRAME                    24
#define G723_MILLISECONDS_PER_FRAME             30
#define G723_DEFAULT_MILLISECONDS_PER_PACKET    30
#define G723_SLOWLNK_MILLISECONDS_PER_PACKET    90
#define G723_MAXIMUM_MILLISECONDS_PER_PACKET    360
#define G723_FRAMES_PER_PACKET(_MillisecondsPerPacket_) \
    ((_MillisecondsPerPacket_) / G723_MILLISECONDS_PER_FRAME)
#define G723_MAXIMUM_FRAME_SIZE                 240
#define G723_MAXIMUM_PACKET_SIZE(_FramesPerPacket_) \
    (((_FramesPerPacket_) * G723_MAXIMUM_FRAME_SIZE) + RTP_HEADER_SIZE)
#define G723_MILLISECONDS_PER_PACKET(_FramesPerPacket_) \
    ((_FramesPerPacket_) * G723_MILLISECONDS_PER_FRAME)

#define G711U_RTP_PAYLOAD_TYPE                  0
#define G711A_RTP_PAYLOAD_TYPE                  8
#define G711_SAMPLES_PER_FRAME                  8
#define G711_SAMPLES_PER_MILLISECOND            8
#define G711_FRAMES_PER_MILLISECOND \
    (G711_SAMPLES_PER_MILLISECOND / G711_SAMPLES_PER_FRAME)
#define G711_DEFAULT_MILLISECONDS_PER_PACKET    30
#define G711_MAXIMUM_MILLISECONDS_PER_PACKET    240
#define G711_FRAMES_PER_PACKET(_MillisecondsPerPacket_) \
    ((_MillisecondsPerPacket_) * G711_FRAMES_PER_MILLISECOND)
#define G711_MAXIMUM_FRAME_SIZE                 8
#define G711_MAXIMUM_PACKET_SIZE(_FramesPerPacket_) \
    (((_FramesPerPacket_) * G711_MAXIMUM_FRAME_SIZE) + RTP_HEADER_SIZE)
#define G711_MILLISECONDS_PER_PACKET(_FramesPerPacket_) \
    ((_FramesPerPacket_) / G711_FRAMES_PER_MILLISECOND)

#define H263_RTP_PAYLOAD_TYPE                   34
#define H263_QCIF_MPI                           1
#define H263_MAXIMUM_PACKET_SIZE                RTP_PACKET_SIZE_UNKNOWN

#define H261_RTP_PAYLOAD_TYPE                   31
#define H261_QCIF_MPI                           1
#define H261_MAXIMUM_PACKET_SIZE                RTP_PACKET_SIZE_UNKNOWN

#define H245_SESSIONID_AUDIO            1
#define H245_SESSIONID_VIDEO            2

#define MAXIMUM_BITRATE_14400           144     // units of 100 bps
#define MAXIMUM_BITRATE_28800           288     // units of 100 bps
#define MAXIMUM_BITRATE_35000           350     // units of 100 bps
#define MAXIMUM_BITRATE_42000           420     // units of 100 bps
#define MAXIMUM_BITRATE_49000           490     // units of 100 bps
#define MAXIMUM_BITRATE_56000           560     // units of 100 bps
#define MAXIMUM_BITRATE_63000           630     // units of 100 bps
#define MAXIMUM_BITRATE_ISDN            850     // units of 100 bps
// #define MAXIMUM_BITRATE_LAN            6217     // units of 100 bps

#define H323_UNADJ_VIDEORATE_THRESHOLD  120     // units of 100 bps
#define H323_TRUE_VIDEORATE_THRESHOLD   220     // units of 100 bps
#define H323_MINIMUM_AUDIO_BANDWIDTH    171     // units of 100 bps
#define H323_BANDWIDTH_CUSHION_PERCENT   10
#define MAXIMUM_BITRATE_H26x_QCIF       960     // units of 100 bps
#define MAXIMUM_BITRATE_H26x_CIF       1280     // units of 100 bps

#define H323IsSlowLink(_dwLinkSpeed_) \
    ((_dwLinkSpeed_) <= (MAXIMUM_BITRATE_35000 * 100))

#define H245_TERMCAPINDEX_G723          0
#define H245_TERMCAPINDEX_H263          1
#define H245_TERMCAPINDEX_G711_ULAW64   2
#define H245_TERMCAPINDEX_G711_ALAW64   3
#define H245_TERMCAPINDEX_H261          4
#define H245_TERMCAPINDEX_T120          5

#define H245_TERMCAPID_G723             (H245_TERMCAPINDEX_G723 + 1)
#define H245_TERMCAPID_H263             (H245_TERMCAPINDEX_H263 + 1)
#define H245_TERMCAPID_G711_ULAW64      (H245_TERMCAPINDEX_G711_ULAW64 + 1)
#define H245_TERMCAPID_G711_ALAW64      (H245_TERMCAPINDEX_G711_ALAW64 + 1)
#define H245_TERMCAPID_H261             (H245_TERMCAPINDEX_H261 + 1)
#define H245_TERMCAPID_T120             (H245_TERMCAPINDEX_T120 +1)

#define H323IsValidDataType(_type_) \
    (((_type_) == H245_DATA_VIDEO) || \
     ((_type_) == H245_DATA_AUDIO))

#define H323IsValidAudioClientType(_type_) \
    (((_type_) == H245_CLIENT_AUD_G711_ULAW64) || \
     ((_type_) == H245_CLIENT_AUD_G711_ALAW64) || \
     ((_type_) == H245_CLIENT_AUD_G723))

#define H323IsValidVideoClientType(_type_) \
    (((_type_) == H245_CLIENT_VID_H261) || \
     ((_type_) == H245_CLIENT_VID_H263))

#define H323IsValidClientType(_type_) \
    (H323IsValidAudioClientType(_type_) || \
     H323IsValidVideoClientType(_type_))

#define H323IsAudioDataType(_type_) \
    ((_type_) == H245_DATA_AUDIO)  

#define H323IsVideoDataType(_type_) \
    ((_type_) == H245_DATA_VIDEO)  

#define H323IsAudioPayloadType(_type_) \
    (((_type_) == G711U_RTP_PAYLOAD_TYPE) || \
     ((_type_) == G711A_RTP_PAYLOAD_TYPE) || \
     ((_type_) == G723_RTP_PAYLOAD_TYPE))

#define H323IsVideoPayloadType(_type_) \
    (((_type_) == H261_RTP_PAYLOAD_TYPE) || \
     ((_type_) == H263_RTP_PAYLOAD_TYPE))

#define H323IsReceiveCapability(_dir_) \
    (((_dir_) == H245_CAPDIR_LCLRXTX) || \
     ((_dir_) == H245_CAPDIR_RMTRXTX) || \
     ((_dir_) == H245_CAPDIR_LCLRX) || \
     ((_dir_) == H245_CAPDIR_RMTRX))

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern CC_VENDORINFO  g_VendorInfo;

extern DWORD   g_dwIPT120;

extern WORD    g_wPortT120;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEFINE_VENDORINFO(_ID_,_VERSION_) \
    { \
        H221_COUNTRY_CODE_USA, \
        H221_COUNTRY_EXT_USA, \
        H221_MFG_CODE_MICROSOFT, \
        &(_ID_), \
        &(_VERSION_) \
    }
  
#define SIZEOF_TERMCAPLIST(_TermCapArray_) \
    (sizeof(_TermCapArray_)/sizeof(PPCC_TERMCAP))

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
InitializeTermCaps(
    );

#endif // _INC_TERMCAPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\termcaps.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    termcaps.c

Abstract:

    Routines for handling terminal capabilities.

Environment:

    User Mode - Win32

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "termcaps.h"
#include "call.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

H245_TOTCAP_T  g_TermCapG723;
H245_TOTCAP_T  g_TermCapG711ULaw64;
H245_TOTCAP_T  g_TermCapG711ALaw64;
H245_TOTCAP_T  g_TermCapH261;
H245_TOTCAP_T  g_TermCapT120;

H245_TOTCAP_T  g_TermCapH263_28800;
H245_TOTCAP_T  g_TermCapH263_35000;
H245_TOTCAP_T  g_TermCapH263_42000;
H245_TOTCAP_T  g_TermCapH263_49000;
H245_TOTCAP_T  g_TermCapH263_56000;

H245_TOTCAP_T  g_TermCapH263_ISDN;
H245_TOTCAP_T  g_TermCapH263_LAN;

PCC_TERMCAP g_TermCapArray_14400[] = {
                &g_TermCapG723
                };

PCC_TERMCAP g_TermCapArray_28800[] = {
                &g_TermCapG723,
                &g_TermCapH263_28800,
                &g_TermCapT120
                };

PCC_TERMCAP g_TermCapArray_35000[] = {
                &g_TermCapG723,
                &g_TermCapH263_35000,
                &g_TermCapT120
                };

PCC_TERMCAP g_TermCapArray_42000[] = {
                &g_TermCapG723,
                &g_TermCapH263_42000,
                &g_TermCapT120
                };

PCC_TERMCAP g_TermCapArray_49000[] = {
                &g_TermCapG723,
                &g_TermCapH263_49000,
                &g_TermCapT120
                };

PCC_TERMCAP g_TermCapArray_56000[] = {
                &g_TermCapG723,
                &g_TermCapH263_56000,
                &g_TermCapT120
                };

PCC_TERMCAP g_TermCapArray_ISDN[] = {
                &g_TermCapG723,
                &g_TermCapH263_ISDN,
                &g_TermCapT120
                };

PCC_TERMCAP g_TermCapArray_LAN[] = {
                &g_TermCapG723,
                &g_TermCapH263_LAN,
                &g_TermCapG711ULaw64,
                &g_TermCapG711ALaw64,
                &g_TermCapH261,
                &g_TermCapT120
                };

// these must match the arrays above...
H245_TOTCAPDESC_T g_TermCapDescriptor_14400;
H245_TOTCAPDESC_T g_TermCapDescriptor_28800;
H245_TOTCAPDESC_T g_TermCapDescriptor_LAN;

H245_TOTCAPDESC_T * g_TermCapDArray_14400[] = {
                &g_TermCapDescriptor_14400
                };

H245_TOTCAPDESC_T * g_TermCapDArray_28800[] = {
                &g_TermCapDescriptor_28800
                };

// re-use g.723.1 and h.263 descriptors
H245_TOTCAPDESC_T * g_TermCapDArray_35000[] = {
                &g_TermCapDescriptor_28800
                };

// re-use g.723.1 and h.263 descriptors
H245_TOTCAPDESC_T * g_TermCapDArray_42000[] = {
                &g_TermCapDescriptor_28800
                };

// re-use g.723.1 and h.263 descriptors
H245_TOTCAPDESC_T * g_TermCapDArray_49000[] = {
                &g_TermCapDescriptor_28800
                };

// re-use g.723.1 and h.263 descriptors
H245_TOTCAPDESC_T * g_TermCapDArray_56000[] = {
                &g_TermCapDescriptor_28800
                };

// re-use g.723.1 and h.263 descriptors
H245_TOTCAPDESC_T * g_TermCapDArray_ISDN[] = {
                &g_TermCapDescriptor_28800
                };

H245_TOTCAPDESC_T * g_TermCapDArray_LAN[] = {
                &g_TermCapDescriptor_LAN
                };

CC_OCTETSTRING g_ProductID = {
                    H323_PRODUCT_ID,
                    sizeof(H323_PRODUCT_ID)
                    };
CC_OCTETSTRING g_ProductVersion = {
                    H323_PRODUCT_VERSION,
                    sizeof(H323_PRODUCT_VERSION)
                    };
CC_VENDORINFO  g_VendorInfo  = DEFINE_VENDORINFO(g_ProductID,g_ProductVersion);

// T.120 related data.
BOOL    g_fAdvertiseT120 = FALSE;
DWORD   g_dwIPT120 = INADDR_ANY;
WORD    g_wPortT120 = 0;

// the enum H245_CAPABILITY is used as the index into this array,
DWORD   g_CapabilityWeights[MAX_CAPS] = {100, 100, 100, 100};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
UpdateSimultaneousCapabilities(
    )
/*++

Routine Description:

    This function is called when the capabilities are changed by the app. The 
    array of caps and simcaps are updated based on the new status.

Arguments:

    None.

Return Values:

    Returns true if successful.
    
--*/
{
    unsigned short ulNumArrays;

    // initialize 14.4 descriptors
    g_TermCapDescriptor_14400.CapDescId = 0;
    ulNumArrays = 0;

    if (g_CapabilityWeights[HC_G723] > 0)
    {
        g_TermCapDescriptor_14400.CapDesc.SimCapArray[ulNumArrays].Length = 1;
        g_TermCapDescriptor_14400.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_G723;
        ulNumArrays ++;
    }

    if (g_fAdvertiseT120)
    {
        g_TermCapDescriptor_14400.CapDesc.SimCapArray[ulNumArrays].Length = 1;
        g_TermCapDescriptor_14400.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_T120;
        ulNumArrays ++;
    }

    g_TermCapDescriptor_14400.CapDesc.Length = ulNumArrays;


    // initialize 28.8 descriptors
    g_TermCapDescriptor_28800.CapDescId = 0;
    ulNumArrays = 0;

    if (g_CapabilityWeights[HC_G723] > 0)
    {
        g_TermCapDescriptor_28800.CapDesc.SimCapArray[ulNumArrays].Length = 1;
        g_TermCapDescriptor_28800.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_G723;
        ulNumArrays ++;
    }

    if (g_CapabilityWeights[HC_H263QCIF] > 0)
    {
        g_TermCapDescriptor_28800.CapDesc.SimCapArray[ulNumArrays].Length = 1;
        g_TermCapDescriptor_28800.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_H263;
        ulNumArrays ++;
    }

    if (g_fAdvertiseT120)
    {
        g_TermCapDescriptor_28800.CapDesc.SimCapArray[ulNumArrays].Length = 1;
        g_TermCapDescriptor_28800.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_T120;
        ulNumArrays ++;
    }

    g_TermCapDescriptor_28800.CapDesc.Length = ulNumArrays;


    // initialize LAN descriptors
    g_TermCapDescriptor_LAN.CapDescId = 0;
    ulNumArrays = 0;

    if ((g_CapabilityWeights[HC_G723] > 0) && (g_CapabilityWeights[HC_G711] > 0))
    {
        // both G723 and G711 are selected.
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].Length = 3;

        // decide witch one is prefered.
        if (g_CapabilityWeights[HC_G723] >= g_CapabilityWeights[HC_G711])
        {
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_G723;
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[1] = H245_TERMCAPID_G711_ULAW64;
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[2] = H245_TERMCAPID_G711_ALAW64;
        }
        else
        {
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_G711_ULAW64;
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[1] = H245_TERMCAPID_G711_ALAW64;
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[2] = H245_TERMCAPID_G723;
        }

        ulNumArrays ++;
    }
    else if (g_CapabilityWeights[HC_G723] > 0)
    {
        // only G723 is selected.
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].Length = 1;
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_G723;

        ulNumArrays ++;
    }
    else if (g_CapabilityWeights[HC_G711] > 0)
    {
        // only G711 is selected.
        g_TermCapDescriptor_LAN.CapDesc.Length ++;
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].Length = 2;
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_G711_ULAW64;
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[1] = H245_TERMCAPID_G711_ALAW64;

        ulNumArrays ++;
    }


    if ((g_CapabilityWeights[HC_H263QCIF] > 0) && (g_CapabilityWeights[HC_H261QCIF] > 0))
    {
        // both H261 and H263 are selected.
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].Length = 2;

        // decide witch one is prefered.
        if (g_CapabilityWeights[HC_H263QCIF] >= g_CapabilityWeights[HC_H261QCIF] > 0)
        {
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_H263;
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[1] = H245_TERMCAPID_H261;
        }
        else
        {
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_H261;
            g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[1] = H245_TERMCAPID_H263;
        }

        ulNumArrays ++;
    }
    else if (g_CapabilityWeights[HC_H263QCIF] > 0)
    {
        // Only H263 is selected.
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].Length = 1;
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_H263;

        ulNumArrays ++;
    }
    else if (g_CapabilityWeights[HC_H261QCIF] > 0)
    {
        // Only H263 is selected.
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].Length = 1;
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_H261;

        ulNumArrays ++;
    }

    if (g_fAdvertiseT120)
    {
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].Length = 1;
        g_TermCapDescriptor_LAN.CapDesc.SimCapArray[ulNumArrays].AltCaps[0] = H245_TERMCAPID_T120;
        ulNumArrays ++;
    }

    g_TermCapDescriptor_LAN.CapDesc.Length = ulNumArrays;

    // success
    return TRUE;

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
InitializeTermCaps(
    )
        
/*++

Routine Description:

    Initializes terminal capabilites list.

Arguments:

    None.

Return Values:

    Returns true if successful.
    
--*/

{
	g_TermCapT120.Dir = H245_CAPDIR_LCLRXTX;
	g_TermCapT120.DataType = H245_DATA_DATA;
	g_TermCapT120.ClientType = H245_CLIENT_DAT_T120;
	g_TermCapT120.CapId = H245_TERMCAPID_T120;	
	g_TermCapT120.Cap.H245Dat_T120.application.choice = 
        DACy_applctn_t120_chosen;
	g_TermCapT120.Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice =
        separateLANStack_chosen;
	g_TermCapT120.Cap.H245Dat_T120.maxBitRate = 0; // updated later.

    // initialize g723 capabilities
    g_TermCapG723.Dir = H245_CAPDIR_LCLRX;
    g_TermCapG723.DataType = H245_DATA_AUDIO;
    g_TermCapG723.ClientType = H245_CLIENT_AUD_G723;
    g_TermCapG723.CapId = H245_TERMCAPID_G723;
    g_TermCapG723.Cap.H245Aud_G723.silenceSuppression = FALSE;
    g_TermCapG723.Cap.H245Aud_G723.maxAl_sduAudioFrames =
        G723_FRAMES_PER_PACKET(
            G723_MAXIMUM_MILLISECONDS_PER_PACKET
            );

    // initialize g711 capabilities
    g_TermCapG711ULaw64.Dir = H245_CAPDIR_LCLRX;
    g_TermCapG711ULaw64.DataType = H245_DATA_AUDIO;
    g_TermCapG711ULaw64.ClientType = H245_CLIENT_AUD_G711_ULAW64;
    g_TermCapG711ULaw64.CapId = H245_TERMCAPID_G711_ULAW64;
    g_TermCapG711ULaw64.Cap.H245Aud_G711_ULAW64 =
        G711_FRAMES_PER_PACKET(
            G711_MAXIMUM_MILLISECONDS_PER_PACKET
            );

    // initialize g711 capabilities
    g_TermCapG711ALaw64.Dir = H245_CAPDIR_LCLRX;
    g_TermCapG711ALaw64.DataType = H245_DATA_AUDIO;
    g_TermCapG711ALaw64.ClientType = H245_CLIENT_AUD_G711_ALAW64;
    g_TermCapG711ALaw64.CapId = H245_TERMCAPID_G711_ALAW64;
    g_TermCapG711ALaw64.Cap.H245Aud_G711_ALAW64 =
        G711_FRAMES_PER_PACKET(
            G711_MAXIMUM_MILLISECONDS_PER_PACKET
            );

    // initialize h261 capabilities
    g_TermCapH261.Dir = H245_CAPDIR_LCLRX;
    g_TermCapH261.DataType = H245_DATA_VIDEO;
    g_TermCapH261.ClientType = H245_CLIENT_VID_H261;
    g_TermCapH261.CapId = H245_TERMCAPID_H261;
    g_TermCapH261.Cap.H245Vid_H261.bit_mask = H261VdCpblty_qcifMPI_present;
    g_TermCapH261.Cap.H245Vid_H261.H261VdCpblty_qcifMPI = H261_QCIF_MPI;
    g_TermCapH261.Cap.H245Vid_H261.maxBitRate = MAXIMUM_BITRATE_H26x_QCIF;
    g_TermCapH261.Cap.H245Vid_H261.tmprlSptlTrdOffCpblty = FALSE;
    g_TermCapH261.Cap.H245Vid_H261.stillImageTransmission = FALSE;

    // initialize h263 capabilities
    g_TermCapH263_LAN.Dir = H245_CAPDIR_LCLRX;
    g_TermCapH263_LAN.DataType = H245_DATA_VIDEO;
    g_TermCapH263_LAN.ClientType = H245_CLIENT_VID_H263;
    g_TermCapH263_LAN.CapId = H245_TERMCAPID_H263;
    g_TermCapH263_LAN.Cap.H245Vid_H263.bit_mask = H263VdCpblty_qcifMPI_present;
    g_TermCapH263_LAN.Cap.H245Vid_H263.H263VdCpblty_qcifMPI = H263_QCIF_MPI;
    g_TermCapH263_LAN.Cap.H245Vid_H263.unrestrictedVector = FALSE;
    g_TermCapH263_LAN.Cap.H245Vid_H263.arithmeticCoding = FALSE;
    g_TermCapH263_LAN.Cap.H245Vid_H263.advancedPrediction = FALSE;
    g_TermCapH263_LAN.Cap.H245Vid_H263.pbFrames = FALSE;
    g_TermCapH263_LAN.Cap.H245Vid_H263.tmprlSptlTrdOffCpblty = FALSE;

    // make copies of termcaps
    g_TermCapH263_28800 = g_TermCapH263_LAN;
    g_TermCapH263_35000 = g_TermCapH263_LAN;
    g_TermCapH263_42000 = g_TermCapH263_LAN;
    g_TermCapH263_49000 = g_TermCapH263_LAN;
    g_TermCapH263_56000 = g_TermCapH263_LAN;
    g_TermCapH263_ISDN  = g_TermCapH263_LAN;

    // modify bitrate for speed of each link
    g_TermCapH263_28800.Cap.H245Vid_H263.maxBitRate = MAXIMUM_BITRATE_28800;
    g_TermCapH263_35000.Cap.H245Vid_H263.maxBitRate = MAXIMUM_BITRATE_35000;
    g_TermCapH263_42000.Cap.H245Vid_H263.maxBitRate = MAXIMUM_BITRATE_42000;
    g_TermCapH263_49000.Cap.H245Vid_H263.maxBitRate = MAXIMUM_BITRATE_49000;
    g_TermCapH263_56000.Cap.H245Vid_H263.maxBitRate = MAXIMUM_BITRATE_56000;
    g_TermCapH263_ISDN.Cap.H245Vid_H263.maxBitRate  = MAXIMUM_BITRATE_ISDN;
    g_TermCapH263_LAN.Cap.H245Vid_H263.maxBitRate   = MAXIMUM_BITRATE_H26x_QCIF;

    UpdateSimultaneousCapabilities();

    // success
    return TRUE;
}


BOOL
H323GetTermCapList(
    PH323_CALL             pCall,
    PCC_TERMCAPLIST        pTermCapList,
    PCC_TERMCAPDESCRIPTORS pTermCapDescriptors
    )

/*++

Routine Description:

    Initializes terminal capabilities list.

Arguments:

    None.

Return Values:

    Returns true if successful.
    
--*/

{
    H323DBG((
        DEBUG_LEVEL_TRACE,
        "H323GetTermCapList, g_fAdvertiseT120:%d\n",
        g_fAdvertiseT120
        ));

    if (pCall->dwLinkSpeed < (MAXIMUM_BITRATE_28800 * 100)) {

        // determine number of elements and save pointer to array
        pTermCapList->wLength = SIZEOF_TERMCAPLIST(g_TermCapArray_14400);
        pTermCapList->pTermCapArray = g_TermCapArray_14400;

        // determine number of elements and save pointer to array
        pTermCapDescriptors->wLength = 1;
        pTermCapDescriptors->pTermCapDescriptorArray = g_TermCapDArray_14400;

    } else if (pCall->dwLinkSpeed < (MAXIMUM_BITRATE_35000 * 100)) { 

        // determine number of elements and save pointer to array
        pTermCapList->wLength = SIZEOF_TERMCAPLIST(g_TermCapArray_28800);
        pTermCapList->pTermCapArray = g_TermCapArray_28800;
 
        // do not publish the T120 cap at the end of the array.
        if (!g_fAdvertiseT120) pTermCapList->wLength --;
 
        // determine number of elements and save pointer to array
        pTermCapDescriptors->wLength = 1;
        pTermCapDescriptors->pTermCapDescriptorArray = g_TermCapDArray_28800;

    } else if (pCall->dwLinkSpeed < (MAXIMUM_BITRATE_42000 * 100)) {

        // determine number of elements and save pointer to array
        pTermCapList->wLength = SIZEOF_TERMCAPLIST(g_TermCapArray_35000);
        pTermCapList->pTermCapArray = g_TermCapArray_35000;

        // do not publish the T120 cap at the end of the array.
        if (!g_fAdvertiseT120) pTermCapList->wLength --;
 
        // determine number of elements and save pointer to array
        pTermCapDescriptors->wLength = 1;
        pTermCapDescriptors->pTermCapDescriptorArray = g_TermCapDArray_35000;

    } else if (pCall->dwLinkSpeed < (MAXIMUM_BITRATE_49000 * 100)) {

        // determine number of elements and save pointer to array
        pTermCapList->wLength = SIZEOF_TERMCAPLIST(g_TermCapArray_42000);
        pTermCapList->pTermCapArray = g_TermCapArray_42000;

        // do not publish the T120 cap at the end of the array.
        if (!g_fAdvertiseT120) pTermCapList->wLength --;
 
        // determine number of elements and save pointer to array
        pTermCapDescriptors->wLength = 1;
        pTermCapDescriptors->pTermCapDescriptorArray = g_TermCapDArray_42000;

    } else if (pCall->dwLinkSpeed < (MAXIMUM_BITRATE_56000 * 100)) {

        // determine number of elements and save pointer to array
        pTermCapList->wLength = SIZEOF_TERMCAPLIST(g_TermCapArray_49000);
        pTermCapList->pTermCapArray = g_TermCapArray_49000;

        // do not publish the T120 cap at the end of the array.
        if (!g_fAdvertiseT120) pTermCapList->wLength --;
 
        // determine number of elements and save pointer to array
        pTermCapDescriptors->wLength = 1;
        pTermCapDescriptors->pTermCapDescriptorArray = g_TermCapDArray_49000;

    } else if (pCall->dwLinkSpeed < (MAXIMUM_BITRATE_63000 * 100)) {

        // determine number of elements and save pointer to array
        pTermCapList->wLength = SIZEOF_TERMCAPLIST(g_TermCapArray_56000);
        pTermCapList->pTermCapArray = g_TermCapArray_56000;

        // do not publish the T120 cap at the end of the array.
        if (!g_fAdvertiseT120) pTermCapList->wLength --;
 
        // determine number of elements and save pointer to array
        pTermCapDescriptors->wLength = 1;
        pTermCapDescriptors->pTermCapDescriptorArray = g_TermCapDArray_56000;

    } else if (pCall->dwLinkSpeed < (MAXIMUM_BITRATE_ISDN * 100)) {

        // determine number of elements and save pointer to array
        pTermCapList->wLength = SIZEOF_TERMCAPLIST(g_TermCapArray_ISDN);
        pTermCapList->pTermCapArray = g_TermCapArray_ISDN;
    
        // do not publish the T120 cap at the end of the array.
        if (!g_fAdvertiseT120) pTermCapList->wLength --;
 
        // determine number of elements and save pointer to array
        pTermCapDescriptors->wLength = 1;
        pTermCapDescriptors->pTermCapDescriptorArray = g_TermCapDArray_ISDN;

    } else {

        // determine number of elements and save pointer to array
        pTermCapList->wLength = SIZEOF_TERMCAPLIST(g_TermCapArray_LAN);
        pTermCapList->pTermCapArray = g_TermCapArray_LAN;

        // do not publish the T120 cap at the end of the array.
        if (!g_fAdvertiseT120) pTermCapList->wLength --;
 
        // determine number of elements and save pointer to array
        pTermCapDescriptors->wLength = 1;
        pTermCapDescriptors->pTermCapDescriptorArray = g_TermCapDArray_LAN;
    }
    
    // This is a hack to put the right T120 bitrate into the PDU. 
	g_TermCapT120.Cap.H245Dat_T120.maxBitRate = pCall->dwLinkSpeed;

    // success
    return TRUE;
}

BOOL
H323ProcessConfigT120Command(
    PH323MSG_CONFIG_T120_COMMAND pCommand
    )
{
    H323DBG((
        DEBUG_LEVEL_TRACE,
        "H323ProcessConfigT120Command. IP:%x, port:%d\n",
        pCommand->dwIP, pCommand->wPort
        ));
    
    // update the T120 information.
    g_fAdvertiseT120 = pCommand->fEnable;        
    g_dwIPT120 = pCommand->dwIP;
    g_wPortT120 = pCommand->wPort;

    UpdateSimultaneousCapabilities();

    return TRUE;
}

BOOL
H323ProcessConfigCapabilityCommand(
    PH323MSG_CONFIG_CAPABILITY_COMMAND pCommand
    )
{
    DWORD dw;
    ASSERT(pCommand->dwNumCaps <= MAX_CAPS);

    // update the weight table
    for (dw = 0; dw < pCommand->dwNumCaps; dw ++)
    {
        H245_CAPABILITY cap = pCommand->pCapabilities[dw];
        g_CapabilityWeights[cap] = pCommand->pdwWeights[dw];
    }
    
    UpdateSimultaneousCapabilities();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\version.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    version.h

Abstract:

    Definitions for H.323 TAPI Service Provider version routines.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_VERSION
#define _INC_VERSION
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Version definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
                            
#define H323_VERSION_LO     0x00000000
#define H323_VERSION_HI     0x00000000

#define TSPI_VERSION_LO     TAPI_CURRENT_VERSION
#define TSPI_VERSION_HI     TAPI_CURRENT_VERSION

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private prototypes                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323ValidateTSPIVersion(
    DWORD dwTSPIVersion
    );

BOOL
H323ValidateExtVersion(
    DWORD dwExtVersion
    );

#endif // _INC_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\version.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    version.c

Abstract:

    TAPI Service Provider functions related to negotiating version.

        TSPI_lineNegotiateTSPIVersion

Environment:

    User Mode - Win32

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "provider.h"
#include "version.h"
#include "line.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323NegotiateTSPIVersion(
    DWORD  dwLowVersion,
    DWORD  dwHighVersion,
    PDWORD pdwTSPIVersion
    )

/*++

Routine Description:

    This function determines whether or not specified TSPI version is
    supported by the service provider.

Arguments:

    dwLowVersion - Specifies the lowest TSPI version number under which the
        TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    dwHighVersion - Specifies the highest TSPI version number under which
        the TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    pdwTSPIVersion - Specifies a far pointer to a DWORD. The service
        provider fills this location with the highest TSPI version number,
        within the range requested by the caller, under which the service
        provider is willing to operate. The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

Return Values:

    Returns true if successful.

--*/

{
    // validate extension version range
    if ((TSPI_VERSION_HI <= dwHighVersion) &&
        (TSPI_VERSION_HI >= dwLowVersion)) {

        // save negotiated version
        *pdwTSPIVersion = TSPI_VERSION_HI;

        // success
        return TRUE;

    } else if ((dwHighVersion <= TSPI_VERSION_HI) &&
               (dwHighVersion >= TSPI_VERSION_LO)) {

        // save negotiated version
        *pdwTSPIVersion = dwHighVersion;

        // success
        return TRUE;
    }

    H323DBG((
        DEBUG_LEVEL_ERROR,
        "failed to negotiate version.\n"
        ));

    // failure
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323ValidateTSPIVersion(
    DWORD dwTSPIVersion
    )

/*++

Routine Description:

    This function determines whether or not specified TSPI version is
    supported by the service provider.

Arguments:

    dwTSPIVersion - Specifies the TSPI version to validate.

Return Values:

    Returns true if successful.

--*/

{
    // see if specified version is supported
    if ((dwTSPIVersion >= TSPI_VERSION_LO) &&
        (dwTSPIVersion <= TSPI_VERSION_HI)) {

        // success
        return TRUE;
    }

    H323DBG((
        DEBUG_LEVEL_ERROR,
        "do not support TSPI version %d.%d.\n",
        HIWORD(dwTSPIVersion),
        LOWORD(dwTSPIVersion)
        ));

    // failure
    return FALSE;
}


BOOL
H323ValidateExtVersion(
    DWORD dwExtVersion
    )

/*++

Routine Description:

    This function determines whether or not specified extension version is
    supported by the service provider.

Arguments:

    dwExtVersion - Specifies the extension version to validate.

Return Values:

    Returns true if successful.

--*/

{
    // see if specified version is supported
    if ((dwExtVersion >= H323_VERSION_LO) &&
        (dwExtVersion <= H323_VERSION_HI)) {

        // success
        return TRUE;
    }

    H323DBG((
        DEBUG_LEVEL_ERROR,
        "do not support extension version %d.%d.\n",
        HIWORD(dwExtVersion),
        LOWORD(dwExtVersion)
        ));

    // failure
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI procedures                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD  dwDeviceID,
    DWORD  dwLowVersion,
    DWORD  dwHighVersion,
    PDWORD pdwTSPIVersion
    )

/*++

Routine Description:

    This function returns the highest SPI version the Service Provider is
    willing to operate under for this device given the range of possible
    SPI versions.

    The TAPI DLL typically calls this function early in the initialization
    sequence for each line device.  In addition, it calls this with the
    value INITIALIZE_NEGOTIATION for dwDeviceID to negotiate an interface
    version for calling early initialization functions.

    Note that when dwDeviceID is INITIALIZE_NEGOTIATION, this function must
    not return LINEERR_OPERATIONUNAVAIL, since this function (with that value)
    is mandatory for negotiating the overall interface version even if the
    service provider supports no line devices.

    Negotiation of an Extension version is done through the separate
    procedure TSPI_lineNegotiateExtVersion.

Arguments:

    dwDeviceID - Identifies the line device for which interface version
        negotiation is to be performed.  In addition to device IDs within
        the range the Service Provider supports, this may be the value:

        INITIALIZE_NEGOTIATION - This value is used to signify that an overall
            interface version is to be negotiated.  Such an interface version
            is required for functions that can be called early in the
            initialization sequence, i.e., before the device ID range has
            been set.

    dwLowVersion - Specifies the lowest TSPI version number under which the
        TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    dwHighVersion - Specifies the highest TSPI version number under which
        the TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    pdwTSPIVersion - Specifies a far pointer to a DWORD. The service
        provider fills this location with the highest TSPI version number,
        within the range requested by the caller, under which the service
        provider is willing to operate. The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number. If the requested range does not overlap the range
        supported by the service provider, the function returns
        LINEERR_INCOMPATIBLEAPIVERSION.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_BADDEVICEID - The specified device identifier or line device
            identifier (such as in a dwDeviceID parameter) is invalid or
            out of range.

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API
            version or version range that is either incompatible or cannot
            be supported by the Telephony API implementation and/or
            corresponding service provider.

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified
            or unknown reason.

--*/

{
    DWORD dwTSPIVersion = UNINITIALIZED;
    PH323_LINE pLine = NULL;

    // see if this is a init line device
    if ((DWORD_PTR)dwDeviceID == INITIALIZE_NEGOTIATION) {

        H323DBG((
            DEBUG_LEVEL_VERBOSE,
            "tapisrv supports tspi version %d.%d through %d.%d.\n",
            HIWORD(dwLowVersion),
            LOWORD(dwLowVersion),
            HIWORD(dwHighVersion),
            LOWORD(dwHighVersion)
            ));

        // perform version negotiation
        if (!H323NegotiateTSPIVersion(
                dwLowVersion,
                dwHighVersion,
                &dwTSPIVersion)) {

            // negotiated version not agreed upon
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }

    // see if this is a valid line device
    } else if (H323GetLineFromIDAndLock(&pLine, (DWORD)dwDeviceID)) {

        // perform version negotiation
        if (!H323NegotiateTSPIVersion(
                dwLowVersion,
                dwHighVersion,
                &dwTSPIVersion)) {

            // release line device
            H323UnlockLine(pLine);

            // negotiated version not agreed upon
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }

        // release line device
        H323UnlockLine(pLine);

    } else {

        // do not recognize device
        return LINEERR_BADDEVICEID;
    }

    // return negotiated version
    *pdwTSPIVersion = dwTSPIVersion;

    // success
    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\audio.h ===
//
// Copyright (c) 1999 Microsoft Corporation
//
// HIDCOM.EXE -- exploratory USB Phone Console Application
//
// audio.h -- audio magic
//

#ifndef _HIDCOM_AUDIO_H_
#define _HIDCOM_AUDIO_H_

#ifdef __cplusplus
extern "C"
{
#endif

#include <basetyps.h>
#include <setupapi.h>


//////////////////////////////////////////////////////////////////////////////
//
// DiscoverAssociatedWaveId
//
// This function searches for a wave device to match the HID device in the
// PNP tree location specified in the passed in SP_DEVICE_INTERFACE_DATA
// structure, obtained from the SetupKi API. It returns the wave id for
// the matched device.
//
// It uses the helper function FindWaveIdFromHardwareIdString() to search for
// the wave device based on a devinst DWORD and a hardware ID string. First,
// it must obtain the devinst for the device; it does this by calling a SetupDi
// function and looking up the devinst in a resulting structure. The hardware
// ID string is then retrieved from the registry and trimmed, using the helper
// function HardwareIdFromDevinst().
//
// See FindWaveIdFromHardwareIdString() for further comments on the search
// algorithm.
//
// Arguments:
//     dwDevInst     - IN  - Device Instance of the HID device
//     fRender       - IN  - TRUE for wave out, FALSE for wave in
//     pdwWaveId     - OUT - the wave id associated with this HID device
//
// Return values:
//      S_OK    - succeeded and matched wave id
//      other from helper functions FindWaveIdFromHardwareIdString() or
//            or HardwareIdFromDevinst()
//

HRESULT DiscoverAssociatedWaveId(
    IN    DWORD                      dwDevInst,
    IN    BOOL                       fRender,
    OUT   DWORD                    * pdwWaveId
    );


//////////////////////////////////////////////////////////////////////////////
//
// ExamineWaveDevices
//
// This function is for debugging purposes only. It enumerates audio devices
// using the Wave API and prints the device path string as well as the
// device instance DWORD for each render or capture device.
//
// Arguments:
//      fRender - IN - true means examine wave out devices; false = wave in
//
// Return values:
//      E_OUTOFMEMORY
//      S_OK
//

HRESULT ExamineWaveDevices(
    IN    BOOL fRender
    );


#ifdef __cplusplus
};
#endif

#endif // _HIDCOM_AUDIO_H_

//
// eof
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\h323tsp\registry.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Definitions for H.323 TAPI Service Provider registry routines.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_REGISTRY
#define _INC_REGISTRY
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Type definitions                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _H323_REGISTRY_SETTINGS {

    DWORD dwQ931AlertingTimeout;        // q931 alerting timeout
    DWORD dwQ931CallSignallingPort;     // port to listen for incoming calls
    DWORD dwG711MillisecondsPerPacket;  // milliseconds in each audio packet
    DWORD dwG723MillisecondsPerPacket;  // milliseconds in each audio packet

    BOOL fIsGatewayEnabled;             // if true, gateway enabled
    BOOL fIsProxyEnabled;               // if true, proxy enabled

    CC_ADDR ccGatewayAddr;              // H.323 gateway address
    CC_ADDR ccProxyAddr;                // H.323 proxy address

#if DBG

    DWORD dwLogType;                // debug log type
    DWORD dwLogLevel;               // debug log level
    DWORD dwH245LogLevel;           // debug log level for H.245
    DWORD dwH225LogLevel;           // debug log level for H.225
    DWORD dwQ931LogLevel;           // debug log level for Q.931
    DWORD dwLinkLogLevel;           // debug log level for link layer

    CHAR  szLogFile[H323_DEBUG_MAXPATH+1];

#endif // DBG

} H323_REGISTRY_SETTINGS, *PH323_REGISTRY_SETTINGS;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Registry key definitions                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define TAPI_REGKEY_ROOT \
    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony")

#define TAPI_REGKEY_PROVIDERS \
    TAPI_REGKEY_ROOT TEXT("\\Providers")    

#define TAPI_REGVAL_NUMPROVIDERS \
    TEXT("NumProviders")

#define WINDOWS_REGKEY_ROOT \
    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")

#define H323_SUBKEY \
    TEXT("H323TSP")

#define H323_REGKEY_ROOT \
    WINDOWS_REGKEY_ROOT TEXT("\\") H323_SUBKEY

#define H323_REGVAL_CALLSIGNALLINGPORT \
    TEXT("Q931CallSignallingPort")

#define H323_REGVAL_Q931ALERTINGTIMEOUT \
    TEXT("Q931AlertingTimeout")

#define H323_REGVAL_G711MILLISECONDSPERPACKET \
    TEXT("G711MillisecondsPerPacket")

#define H323_REGVAL_G723MILLISECONDSPERPACKET \
    TEXT("G723MillisecondsPerPacket")

#define H323_REGVAL_GATEWAYENABLED \
    TEXT("H323GatewayEnabled")

#define H323_REGVAL_PROXYENABLED \
    TEXT("H323ProxyEnabled")

#define H323_REGVAL_GATEWAYADDR \
    TEXT("H323GatewayAddress")

#define H323_REGVAL_PROXYADDR \
    TEXT("H323ProxyAddress")

#define H323_REGVAL_DEBUGLEVEL \
    TEXT("DebugLevel")

#define H245_REGVAL_DEBUGLEVEL \
    TEXT("H245DebugLevel")

#define H225_REGVAL_DEBUGLEVEL \
    TEXT("H225DebugLevel")

#define Q931_REGVAL_DEBUGLEVEL \
    TEXT("Q931DebugLevel")

#define LINK_REGVAL_DEBUGLEVEL \
    TEXT("LinkDebugLevel")

#define H323_REGVAL_DEBUGLOG \
    TEXT("LogFile")

#define H323_RTPBASEPORT 50000

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern H323_REGISTRY_SETTINGS g_RegistrySettings;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
H323SetDefaultConfig(
    );

BOOL
H323GetConfigFromRegistry(
    );

BOOL
H323ListenForRegistryChanges(
    HANDLE hEvent
    );

BOOL
H323StopListeningForRegistryChanges(
    );

#endif // _INC_REGISTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\hid.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    hid.h

Abstract:

    This module contains the declarations and definitions for use with the
    hid user mode client sample driver.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#ifndef HID_H
#define HID_H

#include "hidsdi.h"
#include "setupapi.h"

#define ASSERT(x)

//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOL        IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage;   // The usage page for which we are looking.
   ULONG       Status;      // The last status returned from the accessor function
                            // when updating this field.
   ULONG       ReportID;    // ReportID for this given data structure
   BOOL        IsDataSet;   // Variable to track whether a given data structure
                            //  has already been added to a report structure

   union {
      struct {
         ULONG       UsageMin;       // Variables to track the usage minimum and max
         ULONG       UsageMax;       // If equal, then only a single usage
         ULONG       MaxUsageLength; // Usages buffer length.
         PUSAGE      Usages;         // list of usages (buttons ``down'' on the device.

      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {
   HANDLE               HidDevice; // A file handle to the hid device.
   PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
   HIDP_CAPS            Caps; // The Capabilities of this hid device.
   HIDD_ATTRIBUTES      Attributes;

   PCHAR                InputReportBuffer;
   PHID_DATA            InputData; // array of hid data structures
   ULONG                InputDataLength; // Num elements in this array.
   PHIDP_BUTTON_CAPS    InputButtonCaps;
   PHIDP_VALUE_CAPS     InputValueCaps;

   PCHAR                OutputReportBuffer;
   PHID_DATA            OutputData;
   ULONG                OutputDataLength;
   PHIDP_BUTTON_CAPS    OutputButtonCaps;
   PHIDP_VALUE_CAPS     OutputValueCaps;

   PCHAR                FeatureReportBuffer;
   PHID_DATA            FeatureData;
   ULONG                FeatureDataLength;
   PHIDP_BUTTON_CAPS    FeatureButtonCaps;
   PHIDP_VALUE_CAPS     FeatureValueCaps;

   DWORD                dwDevInst;  // device instance
   BOOL                 bRemoved;   // this device has been removed by pnp
   BOOL                 bNew;       // this device is a new arrival by pnp

   PSP_DEVICE_INTERFACE_DETAIL_DATA  functionClassDeviceData;  // this contains the device path

   struct _HID_DEVICE   *Next;
   struct _HID_DEVICE   *Prev;

} HID_DEVICE, *PHID_DEVICE;


// These functions are implemented in PNP.c
LONG
FindKnownHidDevices (
   OUT PHID_DEVICE   *pHidDevices,
   OUT PULONG        pNumberHidDevices
   );

LONG
FillDeviceInfo (
    IN  PHID_DEVICE HidDevice
    );

VOID
CloseHidDevices ();

VOID
CloseHidDevice (
    IN OUT PHID_DEVICE   HidDevice
    );

BOOL
OpenHidFile (
    IN  PHID_DEVICE HidDevice
    );

BOOL
CloseHidFile (
    IN  PHID_DEVICE HidDevice
    );


// These functions are implemented in Report.c
BOOL
Write (
   PHID_DEVICE    HidDevice
   );


BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );


BOOL
GetFeature (
   PHID_DEVICE    HidDevice
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\audio.cpp ===
//
// Copyright (c) 1999 Microsoft Corporation
//
// HIDCOM.EXE -- exploratory USB Phone Console Application
//
// audio.cpp -- audio magic
//
// Zoltan Szilagyi, July - August, 1999
//
// Prioritized to-do list:
//
// * Convert printfs to debug tracing, and define debug tracing to
//   printfs for HidCom.Exe use.
//
// * GetInstanceFromDeviceName should look only for audio devices.
//   This should somewhat reduce the 2 sec wave enumeration time.
//   Don't forget to remove timing debug output.
//
// * Consider changing FindWaveIdFromHardwareIdString and its helpers to take a
//   devinst only and computer the hardware ids on the fly rather than storing
//   them in arrays. This would slow it down but make the code simpler.
//
// * Small one-time memory leak: The static arrays of hardware ID
//   strings are leaked. That's a few KB per process, no increase over
//   time. If we make this a class then we'll just deallocate those
//   arrays in the destructor.
//   Also, for PNP events that cause us to recompute the mapping, we will
//   need to destroy the array at some point if the wave devices change.
//   So we need to augment the interface for this.
//




#include <wtypes.h>
#include <stdio.h>

#include "audio.h" // our own prototypes

#include <cfgmgr32.h> // CM_ functions
#include <setupapi.h> // SetupDi functions
#include <mmsystem.h> // wave functions
#include <initguid.h>
#include <devguid.h> // device guids

//
// mmddkp.h -- private winmm header file
// This is in nt\private\inc, but one must ssync and build in
// nt\private\genx\windows\inc before it will show up.
//

#include <mmddkp.h>


#include <crtdbg.h>
#define ASSERT _ASSERTE

#ifdef DBG
    #define STATIC
#else
    #define STATIC static
#endif

extern "C"
{
#include "mylog.h"
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Private helper functions
//
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// MapConfigRetToWin32
//
// This routine maps some CM error return codes to Win32 return codes, and
// maps everything else to the value specied by dwDefault. This function is
// adapted almost verbatim from the SetupAPI code.
//
// Arguments:
//     CmReturnCode - IN - specifies the ConfigMgr return code to be mapped
//     dwDefault    - IN - specifies the default value to use if no explicit
//                         mapping applies
//
// Return values:
//     Setup API (Win32) error code
//

STATIC DWORD
MapConfigRetToWin32(
    IN CONFIGRET CmReturnCode,
    IN DWORD     dwDefault
    )
{
    switch(CmReturnCode) {

        case CR_SUCCESS :
            return NO_ERROR;

        case CR_CALL_NOT_IMPLEMENTED :
            return ERROR_CALL_NOT_IMPLEMENTED;

        case CR_OUT_OF_MEMORY :
            return ERROR_NOT_ENOUGH_MEMORY;

        case CR_INVALID_POINTER :
            return ERROR_INVALID_USER_BUFFER;

        case CR_INVALID_DEVINST :
            return ERROR_NO_SUCH_DEVINST;

        case CR_INVALID_DEVICE_ID :
            return ERROR_INVALID_DEVINST_NAME;

        case CR_ALREADY_SUCH_DEVINST :
            return ERROR_DEVINST_ALREADY_EXISTS;

        case CR_INVALID_REFERENCE_STRING :
            return ERROR_INVALID_REFERENCE_STRING;

        case CR_INVALID_MACHINENAME :
            return ERROR_INVALID_MACHINENAME;

        case CR_REMOTE_COMM_FAILURE :
            return ERROR_REMOTE_COMM_FAILURE;

        case CR_MACHINE_UNAVAILABLE :
            return ERROR_MACHINE_UNAVAILABLE;

        case CR_NO_CM_SERVICES :
            return ERROR_NO_CONFIGMGR_SERVICES;

        case CR_ACCESS_DENIED :
            return ERROR_ACCESS_DENIED;

        case CR_NOT_DISABLEABLE:
            return ERROR_NOT_DISABLEABLE;

        default :
            return dwDefault;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// MapConfigRetToHResult
//
// This routine maps some CM error return codes to HRESULT return codes, and
// maps everything else to the HRESULT value E_FAIL.
//
// Arguments:
//     CmReturnCode - IN - specifies the ConfigMgr return code to be mapped
//
// Return values:
//     HRESULT error code
//

STATIC HRESULT
MapConfigRetToHResult(
    IN CONFIGRET CmReturnCode
    )
{
    DWORD   dwWin32Error;
    HRESULT hr;

    //
    // Map configret --> win32
    //

    dwWin32Error = MapConfigRetToWin32(
        CmReturnCode,
        E_FAIL
        );

    //
    // Map win32 --> HRESULT
    // but don't try to map default E_FAIL, as it is not within the range for
    // a normal win32 error code.
    //

    if ( dwWin32Error == E_FAIL )
    {
        hr = E_FAIL;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( dwWin32Error );
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CheckIfAncestor
//
// This function determines if one of the specified devnodes (the "proposed
// ancestor") is an ancestor of the other specified devnode (the "proposed
// descendant").
//
// The devnodes are arranged in a tree. If node A is an ancestor of node
// B, it just means that node A is either equal to node B, or has a child
// that is an ancestor of node B. This can also be stated in reverse --
// node C is a descendant of node D if C is equal to D, or if C's parent
// is a descendant of node D.
//
// The algorithm used here to determine ancestry is a straightforward
// application of the definition, although the recursion is removed.
//
// Arguments:
//     dwDevInstProposedAncestor   - IN  - the proposed ancestor (see above)
//     dwDevInstProposedDescendant - IN  - the proposed descendant (see above)
//     pfIsAncestor                - OUT - returns bool value indicating if
//                                          the pa is an ancestor of the pd
//
// Return values:
//     S_OK   - success
//     others - from CM_Get_Parent
//

STATIC HRESULT
CheckIfAncestor(
    IN   DWORD   dwDevInstProposedAnscestor,
    IN   DWORD   dwDevInstProposedDescendant,
    OUT  BOOL  * pfIsAncestor
    )
{
    ASSERT( ! IsBadWritePtr( pfIsAncestor, sizeof( BOOL ) ) );

    DWORD   dwCurrNode;
    HRESULT hr;

    //
    // Initially, the current node is the proposed descendant.
    //

    dwCurrNode = dwDevInstProposedDescendant;

    while ( TRUE )
    {
        //
        // Check if this node is the proposed ancestor.
        // If so, the proposed ancestor is an ancestor of the
        // proposed descendant.
        //

        if ( dwCurrNode == dwDevInstProposedAnscestor )
        {
            *pfIsAncestor = TRUE;

            hr = S_OK;

            break;
        }

        //
        // Replace the current node with the current node's parent.
        //

        CONFIGRET cr;
        DWORD     dwDevInstTemp;
    
        cr = CM_Get_Parent(
            & dwDevInstTemp,   // out: parent's devinst dword
            dwCurrNode,        // in:  child's devinst dword
            0                  // in:  flags: must be zero
            );

        if ( cr == CR_NO_SUCH_DEVNODE )
        {
            //
            // This means we've fallen off the top of the PNP tree -- the
            // proposed ancestor is not found in the proposed descendant's
            // parentage chain.
            //

            * pfIsAncestor = FALSE;

            hr = S_OK;

            break;
        }
        else if ( cr != CR_SUCCESS )
        {
            //
            // Some other error occured.
            //                   

            hr = MapConfigRetToHResult( cr );
            
            break;
        }

        dwCurrNode = dwDevInstTemp;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// FindClosestCommonAncestor
//
// Given a pair of devnodes identified by devinst DWORDs, this function
// finds the devinst DWORD for the closest common ancestor of the two
// devnodes.
//
// See CheckIfAncestor for a discussion of the concepts of ancestor and
// descendant. Then, devnode C is a common ancestor of devnodes A and B if C
// is an ancestor of A -AND- C is an ancestor of B. Any pair of devnodes has
// at least one common ancestor, that being the root of the PNP tree. A pair
// of devnodes may have more than one common ancestor. The set of common
// ancestors of A and B has one UNIQUE member, called the closest common
// ancestor, such that no other member of the set is a child of that node.
//
// You can compute the closest common ancestor of two nodes A and B by
// constructing a chain of nodes going from the root of the tree to A through
// all A's ancestors, and also doing the same for B. Comparing these chains
// side by side, they must be the same in at least the first node (the root).
// The closest common ancestor for A and B is the last node that is the same
// for both chains.
//
// The algorithm used here is an alternative, relatively stateless approach
// that can take more CPU time but uses less memory, doesn't involve any
// allocations, and is much easier to write (the last being the overriding
// consideration, as the PNP tree is in always shallow). The code simply walks
// up A's chain of ancestors, checking if each node is an ancestor of B. The
// first node for which this is true is the closest common ancestor of
// A and B.
//
// Arguments:
//     dwDevInstOne     - IN  - the first node ('A' above)
//     dwDevInstTwo     - IN  - the other node ('B' above)
//     pdwDevInstResult - OUT - returns the closest common ancestor
//
// Return values:
//     S_OK   - success
//     others - from CM_Get_Parent
//

STATIC HRESULT
FindClosestCommonAncestor(
    IN   DWORD   dwDevInstOne,
    IN   DWORD   dwDevInstTwo,
    OUT  DWORD * pdwDevInstResult
    )
{
    ASSERT( ! IsBadWritePtr( pdwDevInstResult, sizeof( DWORD ) ) );

    HRESULT hr;
    BOOL    fIsAncestor;
    DWORD   dwDevInstCurr;

    //
    // For each node up the chain of #1's parents, starting from #1 itself...
    //

    dwDevInstCurr = dwDevInstOne;

    while ( TRUE )
    {
        //
        // Check if this node is also in the chain of #2's parents.
        //

        hr = CheckIfAncestor(
            dwDevInstCurr,
            dwDevInstTwo,
            & fIsAncestor
            );

        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( fIsAncestor )
        {
            *pdwDevInstResult = dwDevInstCurr;

            return S_OK;
        }

        //
        // Get the next node in the chain of #1's parents.
        //

        CONFIGRET cr;
        DWORD     dwDevInstTemp;
    
        cr = CM_Get_Parent(
            & dwDevInstTemp,   // out: parent's devinst dword
            dwDevInstCurr,     // in:  child's devinst dword
            0                  // in:  flags: must be zero
            );

        if ( cr != CR_SUCCESS )
        {
            //
            // dwDevInst has no parent, or some other error occured.
            //
            // This is always an error, because there must always
            // be a common parent somewhere up the chain -- the root of the PNP
            // tree!
            //                   

            return MapConfigRetToHResult( cr );
        }

        dwDevInstCurr = dwDevInstTemp;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// TrimHardwareIdString
//
// This function strips off extraneous parts of the hardware ID string as
// it is expected to appear for USB devices. The remaining parts of the string
// are those that identify the vendor, product, and product revision, which
// are together used to match devices as belonging to the same composite or
// compound device.
//
// (Actually, for devices A and B, it's not just A and B that are compared,
// it's A and the closest common parent of A and B. This ensures that the case
// of multiple identical phones in the same system is handled correctly. This
// logic of course lives outside of this funtion, though.)
//
// As an example:
//          "hid\Vid_04a6&Pid_00b9&Rev_0010&Mi_04&Col01"
//  becomes     "Vid_04a6&Pid_00b9&Rev_0010"
//
// Note that this function will routinely be applied to strings for non-USB
// devices that will not be in the same format; that's ok, since those strings
// will never match USB-generated strings, be they trimmed or not.
//
// Also, note that the hardware ID string as read from the registry actually
// consists of multiple concatenated null-terminated strings, all terminated
// by two consecutive null characters. This function just ignores strings
// beyond the first, as the first contains all the info we need.
//
// Arguments:
//     wszHardwareId - IN - the string to trim (in place)
//
// Return values:
//     TRUE    - the string looked like a valid USB hardware ID
//     FALSE   - the string did not look like a valid USB hardware ID
//

STATIC BOOL
TrimHardwareIdString(
    IN   WCHAR * wszHardwareId
    )
{

    ASSERT( ! IsBadStringPtrW( wszHardwareId, (DWORD) -1 ) );

    //
    // "volatile" is needed, otherwise the compiler blatantly ignores the
    // recalculation of dwSize after the first pass.
    //

    volatile DWORD   dwSize;
    DWORD            dwCurrPos;
    BOOL             fValid = FALSE;
    DWORD            dwNumSeparators = 0;

    //
    // Strip off leading characters up to and including the first \ from the
    // front. If there is no \ in the string, it is invalid.
    //

    dwSize = lstrlenW(wszHardwareId);

    for ( dwCurrPos = 0; dwCurrPos < dwSize; dwCurrPos ++ )
    {
        if ( wszHardwareId[ dwCurrPos ] == L'\\' )
        {
            MoveMemory(
                wszHardwareId,                     // dest
                wszHardwareId + dwCurrPos + 1,     // source
                sizeof(WCHAR) * dwSize - dwCurrPos // size, in bytes
                );

            fValid = TRUE;

            break;
        }
    }

    if ( ! fValid )
    {
        return FALSE;
    }

    //
    // Strip off trailing characters starting from the third &.
    // A string with less than two & is rejected.
    //
    // Examples:
    //
    //          Vid_04a6&Pid_00b9&Rev_0010&Mi_04&Col01
    //  becomes Vid_04a6&Pid_00b9&Rev_0010
    //
    //          Vid_04a6&Pid_00b9&Rev_0010&Mi_04
    //  becomes Vid_04a6&Pid_00b9&Rev_0010
    //
    //          CSC6835_DEV
    //  is rejected
    //

    //
    // Must recompute size because we changed it above.
    // (And note that dwSize is declared as 'volatile'.)
    //

    dwSize = lstrlenW(wszHardwareId);

    for ( dwCurrPos = 0; dwCurrPos < dwSize; dwCurrPos ++ )
    {
        if ( wszHardwareId[ dwCurrPos ] == L'&' )
        {
            dwNumSeparators ++;

            if ( dwNumSeparators == 3 )
            {
                wszHardwareId[ dwCurrPos ] = L'\0';

                break;
            }
        }
    }

    if ( dwNumSeparators < 2 )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// DevInstGetIdString
//
// This function retrieves an id string or string set for a particular
// devinst dword. The value is obtained from the registry, but the
// Configuration Manager API hides the detail of where in the registry this
// info lives.
//
// Arguments:
//     dwDevInst    - IN  - the devinst dword for which we want info
//     dwProperty   - IN  - the property to retrieve
//     pwszIdString - OUT - returns "new"ed Unicode string or string set.
//
// Return values:
//     S_OK          - success
//     E_OUTOFMEMORY - out of memory during string allocation
//     E_UNEXPECTED  - data type of returned ID is not string or mutli-string
//     others        - from CM_Get_DevNode_Registry_PropertyW
//

STATIC HRESULT
DevInstGetIdString(
    IN   DWORD    dwDevInst,
    IN   DWORD    dwProperty,
    OUT  WCHAR ** pwszIdString
    )
{
    const DWORD INITIAL_STRING_SIZE = 100;

    CONFIGRET   cr;
    DWORD       dwBufferSize = INITIAL_STRING_SIZE;
    DWORD       dwDataType   = 0;

    ASSERT( ! IsBadWritePtr( pwszIdString, sizeof( WCHAR * ) ) );


    do
    {
        //
        // Allocate a buffer to store the returned string.
        //

        *pwszIdString = new WCHAR[ dwBufferSize + 1 ];

        if ( *pwszIdString == NULL )
        {
            return E_OUTOFMEMORY;
        }

        //
        // Try to get the string in the registry; we may not have enough
        // buffer space.
        //

        cr = CM_Get_DevNode_Registry_PropertyW(
             dwDevInst,              // IN  DEVINST     dnDevInst,
             dwProperty,             // IN  ULONG       ulProperty,
             & dwDataType,           // OUT PULONG      pulRegDataType, OPT
             (void *) *pwszIdString, // OUT PVOID       Buffer,         OPT
             & dwBufferSize,         // IN  OUT PULONG  pulLength,
             0                       // IN  ULONG       ulFlags -- must be zero
             );

        if ( cr == CR_SUCCESS )
        {
            if ( ( dwDataType != REG_MULTI_SZ ) && ( dwDataType != REG_SZ ) )
            {
                //
                // Value available, but it is not a string ot multi-string. Ouch!
                //

                delete ( *pwszIdString );

                return E_UNEXPECTED;
            }
            else
            {
                return S_OK;
            }
        }
        else if ( cr != CR_BUFFER_SMALL )
        {
            //
            // It's supposed to fail with this error code because we didn't pass in
            // a buffer. Failed to get registry value type and length.
            //

            delete ( *pwszIdString );

            return MapConfigRetToHResult( cr );
        }
        else // cr == CR_BUFFER_SMALL
        {
            delete ( *pwszIdString );

            //
            // the call filled in dwBufferSize with the needed value
            //
        }

    }
    while ( TRUE );

}


//////////////////////////////////////////////////////////////////////////////
//
// HardwareIdFromDevInst
//
// This function retrieves a trimmed hardware ID string for a particular
// devinst dword. The value is obtained from the helper function
// DevInstGetIdString(), and then trimmed using TrimHardwareIdString.
//
// Arguments:
//     dwDevInst      - IN  - the devinst dword for which we want info
//     pwszHardwareId - OUT - returns "new"ed Unicode string set
//
// Return values:
//     S_OK          - success
//     E_FAIL        - not a valid string in USB format
//     others        - from DevInstGetIdString()
//

STATIC HRESULT
HardwareIdFromDevInst(
    IN   DWORD    dwDevInst,
    OUT  WCHAR ** pwszHardwareId
    )
{
    ASSERT( ! IsBadWritePtr(pwszHardwareId, sizeof( WCHAR * ) ) );

    HRESULT   hr;
    BOOL      fValid;

    hr = DevInstGetIdString(
        dwDevInst,
        CM_DRP_HARDWAREID,
        pwszHardwareId
        );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //    wprintf(L"*** HardwareIdFromDevInst: devinst 0x%08x, RAW hardwareID %s\n",
    //        dwDevInst, *pwszHardwareId);

    fValid = TrimHardwareIdString( *pwszHardwareId );

    if ( ! fValid )
    {
        delete ( * pwszHardwareId );

        return E_FAIL;
    }

    // wprintf(L"HardwareIdFromDevInst: devinst 0x%08x, hardwareID %s\n",
    //    dwDevInst, *pwszHardwareId);

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// MatchHardwareIdInArray
//
// This function takes the devinst and hardware ID for a HID device and
// looks in an array of devinsts and hardware IDs for wave devices to find
// the correct wave id to use with the HID device. The correct wave id is
// the one whose hardware ID matches the HID device's hardware ID, and whose
// hardware ID matches the hardware ID for the closest common ancestor of
// itself and the HID device.
//
// Arguments:
//     dwHidDevInst     - IN  - the devinst dword for the HID device
//     wszHidHardwareId - IN  - the trimmed hardware ID string for the
//                              HID device
//     dwNumDevices     - IN  - the size of the arrays -- the number of
//                              wave ids on the system
//     pwszHardwareIds  - IN  - array of trimmed hardware id strings for
//                              the wave devices, indexed by wave ids.
//                              Some entries may be NULL to mark them as
//                              invalid.
//     pdwDevInsts      - IN  - array of devinsts for wave devices,
//                              indexed by wave ids. Some entries may be
//                              (DWORD) -1 to mark them as invalid.
//     pdwMatchedWaveId - OUT - the wave id that matches the hid device
//
// Return values:
//     S_OK   - the devinst was matched
//     E_FAIL - the devinst was not matched
//

STATIC HRESULT
MatchHardwareIdInArray(
    IN   DWORD    dwHidDevInst,
    IN   WCHAR  * wszHidHardwareId,
    IN   DWORD    dwNumDevices,
    IN   WCHAR ** pwszHardwareIds,
    IN   DWORD  * pdwDevInsts,
    OUT  DWORD  * pdwMatchedWaveId
    )
{
    ASSERT( ! IsBadStringPtrW( wszHidHardwareId, (DWORD) -1 ) );

    ASSERT( ! IsBadReadPtr( pwszHardwareIds,
                            sizeof( WCHAR * ) * dwNumDevices ) );

    ASSERT( ! IsBadReadPtr( pdwDevInsts,
                            sizeof( DWORD ) * dwNumDevices ) );

    ASSERT( ! IsBadWritePtr( pdwMatchedWaveId, sizeof(DWORD) ) );

    //
    // For each available wave id...
    //

    DWORD dwCurrWaveId;

    for ( dwCurrWaveId = 0; dwCurrWaveId < dwNumDevices; dwCurrWaveId++ )
    {
        //
        // If this particular wave device has the same stripped hardware
        // ID string as what we are searching for, then we have a match.
        // But non-USB devices have non-parsable hardware ID strings, so
        // they are stored in the array as NULLs.
        //

        if ( pwszHardwareIds[ dwCurrWaveId ] != NULL )
        {
            ASSERT( ! IsBadStringPtrW( pwszHardwareIds[ dwCurrWaveId ], (DWORD) -1 ) );

            if ( ! lstrcmpW( pwszHardwareIds[ dwCurrWaveId ], wszHidHardwareId ) )
            {
                //
                // We have a match, but we must still verify if we're on the same
                // device, not some other device that has the same hardwareID. This
                // is to differentiate between multiple identical phones on the same
                // system.
                //
                // Note: we could make the code more complex, but avoid some work in
                // most cases, by only doing this if there is more than one match based
                // on hardwareIDs alone.
                //

                DWORD     dwCommonAncestor;
                WCHAR   * wszAncestorHardwareId;
                HRESULT   hr;

                hr = FindClosestCommonAncestor(
                    dwHidDevInst,
                    pdwDevInsts[ dwCurrWaveId ],
                    & dwCommonAncestor
                    );
  
                if ( SUCCEEDED(hr) )
                {
                    //
                    // Get the hardware ID for the closest common ancestor.
                    //

                    hr = HardwareIdFromDevInst(
                        dwCommonAncestor,
                        & wszAncestorHardwareId
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Check if they are the same. The closest common ancestor
                        // will be some sort of hub if the audio device is from
                        // some other identical phone other than the one whose HID
                        // device we are looking at.
                        //

                        BOOL fSame;

                        fSame = ! lstrcmpW( wszAncestorHardwareId,
                                            wszHidHardwareId );

                        delete wszAncestorHardwareId;

                        if ( fSame )
                        {
                            *pdwMatchedWaveId = dwCurrWaveId;

                            return S_OK;
                        }
                    }
                }
            }
        }
    }

    //
    // No match.
    //

    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
//
// GetInstanceFromDeviceName
//
// This function retrieves a device instance identifier based on a device
// name string. This works for any device.
//
// Arguments:
//      wszName      - IN  - the device name string
//      pdwInstance  - OUT - returns instance identifier
//
// Return values:
//      S_OK
//      various win32 errors from SetupDi fucntions
//

STATIC HRESULT
GetInstanceFromDeviceName(
    IN   WCHAR *   wszName,
    OUT  DWORD *   pdwInstance,
    IN   HDEVINFO  hDevInfo
    )
{
    ASSERT( ! IsBadStringPtrW( wszName, (DWORD) -1 ) );

    ASSERT( ! IsBadWritePtr( pdwInstance, sizeof(DWORD) ) );

    //
    // Get the interface data for this specific device
    // (based on wszName).
    //

    BOOL     fSuccess;
    DWORD    dwError;

    SP_DEVICE_INTERFACE_DATA interfaceData;
    interfaceData.cbSize = sizeof( SP_DEVICE_INTERFACE_DATA ); // required

    fSuccess = SetupDiOpenDeviceInterfaceW(
        hDevInfo,                          // device info set handle
        wszName,                           // name of the device
        0,                                 // flags, reserved
        & interfaceData                    // OUT: interface data
        );

    if ( ! fSuccess )
    {
        LOG((PHONESP_TRACE, "GetInstanceFromDeviceName - SetupDiOpenDeviceInterfaceW failed: %08x", GetLastError()));

        //
        // Need to clean up, but save the error code first, because
        // the cleanup function calls SetLastError().
        //

        dwError = GetLastError();        

        return HRESULT_FROM_WIN32( dwError );
    }

    //
    // Get the interface detail data from this interface data. This provides
    // more detailed information,including the device instance DWORD that
    // we seek.
    //

    SP_DEVINFO_DATA devinfoData;
    devinfoData.cbSize = sizeof( SP_DEVINFO_DATA ); // required

    fSuccess = SetupDiGetDeviceInterfaceDetail(
        hDevInfo,                           // device info set handle
        & interfaceData,                    // device interface data structure
        NULL,                               // OPT ptr to dev name struct
        0,                                  // OPT avail size of dev name st
        NULL,                               // OPT actual size of devname st
        & devinfoData
        );

    if ( ! fSuccess )
    {
        //
        // It is normal for the above function to fail with
        // ERROR_INSUFFICIENT_BUFFER because we passed in NULL for the
        // device interface detail data (device name) structure.
        //

        dwError = GetLastError();

        if ( dwError != ERROR_INSUFFICIENT_BUFFER )
        {
            LOG((PHONESP_TRACE, "GetInstanceFromDeviceName - SetupDiGetDeviceInterfaceDetail failed: %08x", GetLastError()));
            
            //
            // Can't clean this up earlier, because it does SetLastError().
            //

            return HRESULT_FROM_WIN32( dwError );
        }
    }

    *pdwInstance = devinfoData.DevInst;
    
    //
    // Can't clean this up earlier, because it does SetLastError().
    //

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// 
//
// This function constructs an array of devinst DWORDs and an array of
// hardware ID strigs, both indexed by wave id, for either wave in or wave
// out devices. The devinsts are retrieved by (1) using undocumented calls
// to winmm to retrieve device name strings for each wave device, and (2)
// using SetupDi calls to retrieve a DevInst DWORD for each device name
// string (helper function GetInstanceFromDeviceName).
//
// The values are saved in an array because this process takes the bulk of the
// time in the HID --> audio mapping process, and therefore finding the mapping
// for several HID devices can be done in not much more time than for one HID
// device, just by reusing the array.
//
// Arguments:
//     fRender          - IN  - if TRUE, look for wave out devices
//     pdwNumDevices    - OUT - returns number of wave devices found
//     ppwszHardwareIds - OUT - returns "new"ed array of trimmed hardware id
//                              strings. The array is indexed by wave id. If
//                              a hardware id string cannot be determined for
//                              a particular wave id, then the string pointer
//                              in that position is set to NULL. Each string
//                              is "new"ed separately.
//     ppdwDevInsts     - OUT - returns "new"ed array of devinst DWORDs. The
//                              array is indexed by wave id. If a devinst
//                              cannot be determined for a particular wave id,
//                              then the DWORD in that position is set to
//                              (DWORD) -1.
//
// Return values:
//     S_OK          - success
//     E_OUTOFMEMORY - not enough memory to allocate a device name string or
//                     the return array
//

STATIC HRESULT
ConstructWaveHardwareIdCache(
    IN   BOOL      fRender,
    OUT  DWORD *   pdwNumDevices,
    OUT  WCHAR *** ppwszHardwareIds,
    OUT  DWORD **  ppdwDevInsts
    )
{
    ASSERT( ( fRender == TRUE ) || ( fRender == FALSE ) );

    ASSERT( ! IsBadWritePtr( pdwNumDevices, sizeof( DWORD ) ) );

    ASSERT( ! IsBadWritePtr( ppwszHardwareIds, sizeof( WCHAR ** ) ) );

    ASSERT( ! IsBadWritePtr( ppdwDevInsts, sizeof( DWORD * ) ) );

    //
    // Get a device info list
    //

    HDEVINFO hDevInfo;
   
    /*
    hDevInfo = SetupDiGetClassDevs(
        &GUID_DEVCLASS_MEDIA,            // class GUID (which device classes?)
        NULL,                            // optional enumerator to filter
        NULL,                            // HWND (we have none)
        ( DIGCF_PRESENT    |             // only devices that are present
          DIGCF_PROFILE )                // only devices in this hw profile
        );
        */

    hDevInfo = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_MEDIA, NULL);

    if ( hDevInfo == NULL )
    {
        LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - SetupDiCreateDeviceInfoList failed: %08x", GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Find the number of available wave devices.
    //

    DWORD     dwNumDevices;
    DWORD     dwCurrDevice;

    if ( fRender )
    {
        dwNumDevices = waveOutGetNumDevs();
    }
    else
    {
        dwNumDevices = waveInGetNumDevs();
    }
    
    //
    // Allocate space for the return arrays.
    //

    *pdwNumDevices    = dwNumDevices;

    *ppwszHardwareIds = new LPWSTR [ dwNumDevices ];

    if ( (*ppwszHardwareIds) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    *ppdwDevInsts = new DWORD [ dwNumDevices ];

    if ( (*ppdwDevInsts) == NULL )
    {
        delete *ppwszHardwareIds;
        *ppwszHardwareIds = NULL;

        return E_OUTOFMEMORY;
    }

    //
    // Loop over the available wave devices.
    //

    for ( dwCurrDevice = 0; dwCurrDevice < dwNumDevices; dwCurrDevice++ )
    {
        //
        // For failure cases, we will return NULL string and -1 devinst
        // for that wave id. Callers should compare against the NULL, not
        // the -1.
        //

        (*ppwszHardwareIds) [ dwCurrDevice ] = NULL;
        (*ppdwDevInsts)     [ dwCurrDevice ] = -1;

        //
        // Get the size of the device path string.
        //
        
        MMRESULT  mmresult;
        ULONG     ulSize;

        if ( fRender )
        {
            mmresult = waveOutMessage( (HWAVEOUT) IntToPtr(dwCurrDevice),
                                       DRV_QUERYDEVICEINTERFACESIZE,
                                       (DWORD_PTR) & ulSize,
                                       0
                                     );
        }
        else
        {
            mmresult = waveInMessage( (HWAVEIN) IntToPtr(dwCurrDevice),
                                      DRV_QUERYDEVICEINTERFACESIZE,
                                      (DWORD_PTR) & ulSize,
                                      0
                                    );
        }

        if ( mmresult != MMSYSERR_NOERROR )
        {
            LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - Could not get device string size for device %d; "
                "error = %d", dwCurrDevice, mmresult));
        }
        else if ( ulSize == 0 )
        {
            LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - Got zero device string size for device %d",
                dwCurrDevice));
        }
        else
        {
            //
            // Allocate space for the device path string.
            //

            WCHAR * wszDeviceName;

            wszDeviceName = new WCHAR[ (ulSize / 2) + 1 ];

            if ( wszDeviceName == NULL )
            {
                LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - Out of memory in device string alloc for device %d;"
                    " requested size is %d\n", dwCurrDevice, ulSize));

                delete *ppwszHardwareIds;
                *ppwszHardwareIds = NULL;

                delete *ppdwDevInsts;
                *ppdwDevInsts = NULL;

                return E_OUTOFMEMORY;
            }

            //
            // Get the device path string from winmm.
            //

            if ( fRender )
            {
                mmresult = waveOutMessage( (HWAVEOUT) IntToPtr(dwCurrDevice),
                                           DRV_QUERYDEVICEINTERFACE,
                                           (DWORD_PTR) wszDeviceName,
                                           (DWORD_PTR) ulSize
                                         );
            }
            else
            {
                mmresult = waveInMessage( (HWAVEIN) IntToPtr(dwCurrDevice),
                                          DRV_QUERYDEVICEINTERFACE,
                                          (DWORD_PTR) wszDeviceName,
                                          (DWORD_PTR) ulSize
                                        );
            }

            if ( mmresult == MMSYSERR_NOERROR )
            {
                //
                // Got the string. Now retrieve a devinst dword based on the
                // string.
                //

                // wprintf(L"\tDevice name string for device %d is:\n"
                //         L"\t\t%ws\n",
                //         dwCurrDevice, wszDeviceName);

                HRESULT hr;
                DWORD   dwInstance;
                
                hr = GetInstanceFromDeviceName(
                    wszDeviceName,
                    & dwInstance,
                    hDevInfo
                    );

                delete wszDeviceName;

                if ( FAILED(hr) )
                {
                    LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - Can't get instance DWORD for device %d; "
                        "error 0x%08x\n",
                        dwCurrDevice, hr));
                }
                else
                {
                    //
                    // Based on the devinst dword, retrieve a trimmed
                    // hardware id string.
                    //

                    // printf("\tInstance DWORD for device %d is "
                    //        "0x%08x\n",
                    //        dwCurrDevice, dwInstance);

                    WCHAR * wszHardwareId;

                    hr = HardwareIdFromDevInst(
                        dwInstance,
                        & wszHardwareId
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        (*ppwszHardwareIds) [ dwCurrDevice ] = wszHardwareId;
                        (*ppdwDevInsts)     [ dwCurrDevice ] = dwInstance;
                    }
                }
            }
        }
    }

    SetupDiDestroyDeviceInfoList( hDevInfo );
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// FindWaveIdFromHardwareIdString
//
// This function finds the wave id for a device whose devinst and hardware id
// string are known.
//
// Constructing the mapping from waveid to devinst and hardwave id string
// takes some time, so the mapping is only constructed once for each
// direction (render/capture), via the helper function
// ConstructWaveHardwareIdCache().
//
// Thereafter, the helper function MatchHardwareIdInArray() is used to run
// the matching algorithm based on the already-computed arrays. See that
// function for a description of how the matching is done.
//
// Arguments:
//     dwHidDevInst     - IN  - the devinst dword to match to a wave id
//     wszHardwareId    - IN  - the hardware id string for the devinst
//     fRender          - IN  - TRUE for wave out, FALSE for wave in
//     pdwMatchedWaveId - OUT - the wave id associated with the devinst
//
// Return values:
//      S_OK - success
//      various errors from ConstructWaveHardwareIdCache() and
//         MatchHardwareIdInArray() helper functions
//

STATIC HRESULT
FindWaveIdFromHardwareIdString(
    IN   DWORD   dwHidDevInst,
    IN   WCHAR * wszHardwareId,
    IN   BOOL    fRender,
    OUT  DWORD * pdwMatchedWaveId
    )
{
    ASSERT( ! IsBadStringPtrW( wszHardwareId, (DWORD) -1 ) );

    ASSERT( ( fRender == TRUE ) || ( fRender == FALSE ) );

    ASSERT( ! IsBadWritePtr(pdwMatchedWaveId, sizeof(DWORD) ) );

    DWORD    dwNumDevices = 0;
    WCHAR ** pwszHardwareIds = NULL;
    DWORD  * pdwDevInsts = NULL;

    HRESULT hr;

    //
    // Need to construct cache of render device hardware IDs.
    //

    hr = ConstructWaveHardwareIdCache(
        fRender,
        & dwNumDevices,
        & pwszHardwareIds,
        & pdwDevInsts
        );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // The cache is ready; use it to perform the rest of the matching
    // algorithm.
    //

    hr = MatchHardwareIdInArray(
        dwHidDevInst,
        wszHardwareId,
        dwNumDevices,
        pwszHardwareIds,
        pdwDevInsts,
        pdwMatchedWaveId
        );

    delete pwszHardwareIds;
    delete pdwDevInsts;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// OutputDeviceInfo
//
// This function is for diagnostic purposes only.
//
// Given a devinst DWORD, this function prints the DeviceDesc string as well
// as the entire (untrimmed) hardware ID string set for the device. Example:
//
//
//
// Arguments:
//     dwDesiredDevInst - IN  - the devinst dword for which we want info
//
// Return values:
//     none
//

STATIC void
OutputDeviceInfo(
    DWORD dwDesiredDevInst
    )
{
    //
    // Get and print the device description string.
    //

    HRESULT   hr;
    WCHAR   * wszDeviceDesc;
    WCHAR   * wszHardwareId;

    hr = DevInstGetIdString(
        dwDesiredDevInst,
        CM_DRP_DEVICEDESC,
        & wszDeviceDesc
        );

    if ( FAILED(hr) )
    {
        LOG((PHONESP_TRACE, "OutputDeviceInfo - [can't get device description string - 0x%08x]", hr));
    }
    else
    {
        LOG((PHONESP_TRACE, "OutputDeviceInfo - [DeviceDesc: %ws]", wszDeviceDesc));

        delete wszDeviceDesc;
    }

    //
    // Get and print hardware ID string set.
    //

    hr = DevInstGetIdString(
        dwDesiredDevInst,
        CM_DRP_HARDWAREID,
        & wszHardwareId
        );

    if ( FAILED(hr) )
    {
        LOG((PHONESP_TRACE, "OutputDeviceInfo - [can't get hardware id - 0x%08x]", hr));
    }
    else
    {
        //
        // Print out all the values in the mutli-string.
        //

        WCHAR * wszCurr = wszHardwareId;

        while ( wszCurr[0] != L'\0' )
        {
            LOG((PHONESP_TRACE, "OutputDeviceInfo - [HardwareId: %ws]", wszCurr));

            wszCurr += lstrlenW(wszCurr) + 1;
        }

        delete wszHardwareId;
    }

}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Externally-callable functions
//
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// ExamineWaveDevices
//
// This function is for debugging purposes only. It enumerates audio devices
// using the Wave API and prints the device path string as well as the
// device instance DWORD for each render or capture device.
//
// Arguments:
//      fRender - IN - true means examine wave out devices; false = wave in
//
// Return values:
//      E_OUTOFMEMORY
//      S_OK
//

HRESULT
ExamineWaveDevices(
    IN    BOOL fRender
    )
{
    ASSERT( ( fRender == TRUE ) || ( fRender == FALSE ) );

    DWORD     dwNumDevices;
    DWORD     dwCurrDevice;

    //
    // Get a device info list
    //

    HDEVINFO hDevInfo;
   
    /*
    hDevInfo = SetupDiGetClassDevs(
        &GUID_DEVCLASS_MEDIA,            // class GUID (which device classes?)
        NULL,                            // optional enumerator to filter
        NULL,                            // HWND (we have none)
        ( DIGCF_PRESENT    |             // only devices that are present
          DIGCF_PROFILE )                // only devices in this hw profile
        );
        */

    hDevInfo = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_MEDIA, NULL);

    if ( hDevInfo == NULL )
    {
        LOG((PHONESP_TRACE, "ExamineWaveDevices - SetupDiCreateDeviceInfoList failed: %08x", GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Loop over the available wave devices.
    //

    if ( fRender )
    {
        dwNumDevices = waveOutGetNumDevs();
    }
    else
    {
        dwNumDevices = waveInGetNumDevs();
    }

    LOG((PHONESP_TRACE, "ExamineWaveDevices - Found %d audio %s devices.",
        dwNumDevices,
        fRender ? "render" : "capture"));

    for ( dwCurrDevice = 0; dwCurrDevice < dwNumDevices; dwCurrDevice++ )
    {
        MMRESULT  mmresult;
        ULONG     ulSize;

        //
        // Get the size of the device path string.
        //

        if ( fRender )
        {
            mmresult = waveOutMessage( (HWAVEOUT) IntToPtr(dwCurrDevice),
                                       DRV_QUERYDEVICEINTERFACESIZE,
                                       (DWORD_PTR) & ulSize,
                                       0
                                     );
        }
        else
        {
            mmresult = waveInMessage( (HWAVEIN) IntToPtr(dwCurrDevice),
                                      DRV_QUERYDEVICEINTERFACESIZE,
                                      (DWORD_PTR) & ulSize,
                                      0
                                    );
        }

        if ( mmresult != MMSYSERR_NOERROR )
        {
            LOG((PHONESP_TRACE, "ExamineWaveDevices - Could not get device string size for device %d; "
                "error = %d\n", dwCurrDevice, mmresult));
        }
        else if ( ulSize == 0 )
        {
            LOG((PHONESP_TRACE, "ExamineWaveDevices - Got zero device string size for device %d\n",
                dwCurrDevice));
        }
        else
        {
            //
            // Allocate space for the device path string.
            //

            WCHAR * wszDeviceName;

            wszDeviceName = new WCHAR[ (ulSize / 2) + 1 ];

            if ( wszDeviceName == NULL )
            {
                LOG((PHONESP_TRACE, "ExamineWaveDevices - Out of memory in device string alloc for device %d;"
                    " requested size is %d\n", dwCurrDevice, ulSize));

                return E_OUTOFMEMORY;
            }

            //
            // Get the device path string from winmm.
            //

            if ( fRender )
            {
                mmresult = waveOutMessage( (HWAVEOUT) IntToPtr(dwCurrDevice),
                                           DRV_QUERYDEVICEINTERFACE,
                                           (DWORD_PTR) wszDeviceName,
                                           ulSize
                                         );
            }
            else
            {
                mmresult = waveInMessage( (HWAVEIN) IntToPtr(dwCurrDevice),
                                          DRV_QUERYDEVICEINTERFACE,
                                          (DWORD_PTR) wszDeviceName,
                                          ulSize
                                        );
            }

            if ( mmresult == MMSYSERR_NOERROR )
            {
                //
                // Got the string; print it and convert it to a
                // devinst DWORD.
                //

                LOG((PHONESP_TRACE, "ExamineWaveDevices - Device name string for device %d is: %ws",
                    dwCurrDevice, wszDeviceName));

                HRESULT hr;
                DWORD   dwInstance;
                
                hr = GetInstanceFromDeviceName(
                    wszDeviceName,
                    & dwInstance,
                    hDevInfo
                    );

                if ( FAILED(hr) )
                {
                    LOG((PHONESP_TRACE, "ExamineWaveDevices - Can't get instance DWORD for device %d; "
                        "error 0x%08x",
                        dwCurrDevice, hr));
                }
                else
                {
                    LOG((PHONESP_TRACE, "ExamineWaveDevices - Instance DWORD for device %d is "
                        "0x%08x",
                        dwCurrDevice, dwInstance));

                    //
                    // Print various other info about this device.
                    //

                    OutputDeviceInfo( dwInstance );

                    WCHAR * wszHardwareId;

                    hr = HardwareIdFromDevInst(
                        dwInstance,
                        & wszHardwareId
                        );

                    if ( FAILED(hr) )
                    {
                        LOG((PHONESP_TRACE, "ExamineWaveDevices - Can't get hardware id string for device %d; "
                            "error 0x%08x",
                            dwCurrDevice, hr));
                    }
                    else
                    {
                        LOG((PHONESP_TRACE, "ExamineWaveDevices - Hardware ID for device %d is %ws\n",
                            dwCurrDevice, wszHardwareId));

                        delete wszHardwareId;
                    }
                }

                delete wszDeviceName;
            }
        }
    }

    SetupDiDestroyDeviceInfoList( hDevInfo );
    
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
//
// DiscoverAssociatedWaveId
//
// This function searches for a wave device to match the HID device in the
// PNP tree location specified in the passed in SP_DEVICE_INTERFACE_DATA
// structure, obtained from the SetupKi API. It returns the wave id for
// the matched device.
//
// It uses the helper function FindWaveIdFromHardwareIdString() to search for
// the wave device based on a devinst DWORD and a hardware ID string. First,
// it must obtain the devinst for the device; it does this by calling a SetupDi
// function and looking up the devinst in a resulting structure. The hardware
// ID string is then retrieved from the registry and trimmed, using the helper
// function HardwareIdFromDevinst().
//
// See FindWaveIdFromHardwareIdString() for further comments on the search
// algorithm.
//
// Arguments:
//     dwDevInst     - IN  - Device Instance of the HID device
//     fRender       - IN  - TRUE for wave out, FALSE for wave in
//     pdwWaveId     - OUT - the wave id associated with this HID device
//
// Return values:
//      S_OK    - succeeded and matched wave id
//      other from helper functions FindWaveIdFromHardwareIdString() or
//            or HardwareIdFromDevinst()
//

HRESULT
DiscoverAssociatedWaveId(
    IN    DWORD                      dwDevInst,
    IN    BOOL                       fRender,
    OUT   DWORD                    * pdwWaveId
    )
{
    ASSERT( ! IsBadWritePtr(pdwWaveId, sizeof(DWORD) ) );

    ASSERT( ( fRender == TRUE ) || ( fRender == FALSE ) );

    //
    // We've got the device instance DWORD for the HID device.
    // Use it to get the trimmed hardware ID string, which tells
    // us the vendor, product, and revision numbers.
    //

    HRESULT   hr;
    WCHAR   * wszHardwareId;

    hr = HardwareIdFromDevInst(
        dwDevInst,
        & wszHardwareId
        );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Finally, use this information to choose a wave id.
    //

    hr = FindWaveIdFromHardwareIdString(
        dwDevInst,
        wszHardwareId,
        fRender,
        pdwWaveId
        );

    delete wszHardwareId;

    if ( FAILED(hr) )
    {
        return hr;
    }

    return S_OK;
}

//
// eof
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\mymem.h ===
/* Copyright (c) 1999  Microsoft Corporation */

#ifndef _MYMEM_H
#define _MYMEM_H

#include <windows.h>
#include <winbase.h>
#include <setupapi.h>
#include <TCHAR.h>

typedef struct _PHONESP_MEMINFO
{
    struct _PHONESP_MEMINFO * pNext;
    struct _PHONESP_MEMINFO * pPrev;
    DWORD               dwSize;
    DWORD               dwLine;
    PSTR                pszFile;
    DWORD               dwAlign;
} PHONESP_MEMINFO, *PPHONESP_MEMINFO;

#if DBG

    #define MemAlloc( __size__ ) MemAllocReal( __size__, __LINE__, __FILE__ )

    LPVOID
    WINAPI
    MemAllocReal(
             DWORD   dwSize,
             DWORD   dwLine,
             PSTR    pszFile
            );

    VOID
    DumpMemoryList();

#else

    #define MemAlloc( __size__ ) MemAllocReal( __size__ )

    LPVOID
    WINAPI
    MemAllocReal(
            DWORD   dwSize
            );

#endif

VOID
WINAPI
MemFree(
     LPVOID  p
     );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\mymem.c ===
/* Copyright (c) 1999  Microsoft Corporation */

#include "mymem.h"
#include "mylog.h"

extern PPHONESP_MEMINFO      gpMemFirst, gpMemLast;
extern CRITICAL_SECTION      csMemoryList;
extern BOOL                  gbBreakOnLeak;
extern HANDLE                ghHeap;

#if DBG

LPVOID
WINAPI
MemAllocReal(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
{
    //
    // Alloc 16 extra bytes so we can make sure the pointer we pass back
    // is 64-bit aligned & have space to store the original pointer
    //
    PPHONESP_MEMINFO       pHold;
    PDWORD_PTR       pAligned;
    PBYTE            p;


    p = (LPBYTE)HeapAlloc(ghHeap, HEAP_ZERO_MEMORY, dwSize + sizeof(PHONESP_MEMINFO) + 16);

    if (p == NULL)
    {
        return NULL;
    }

    // note note note - this only works because mymeminfo is
    // a 16 bit multiple in size.  if it wasn't, this
    // align stuff would cause problems.
    pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
    
    *pAligned = (DWORD_PTR) p;
    pHold = (PPHONESP_MEMINFO)((DWORD_PTR)pAligned + 8);
    
    
    pHold->dwSize = dwSize;
    pHold->dwLine = dwLine;
    pHold->pszFile = pszFile;

    EnterCriticalSection(&csMemoryList);

    if (gpMemLast != NULL)
    {
        gpMemLast->pNext = pHold;
        pHold->pPrev = gpMemLast;
        gpMemLast = pHold;
    }
    else
    {
        gpMemFirst = gpMemLast = pHold;
    }

    LeaveCriticalSection(&csMemoryList);
    

    return (LPVOID)(pHold + 1);
}

#else

LPVOID
WINAPI
MemAllocReal(
    DWORD   dwSize
    )
{
    PDWORD_PTR       pAligned;
    PBYTE            p;

    if (p = (LPBYTE)HeapAlloc(ghHeap, HEAP_ZERO_MEMORY, dwSize + 16))
    {
        pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
        *pAligned = (DWORD_PTR) p;
        pAligned = (PDWORD_PTR)((DWORD_PTR)pAligned + 8);
    }
    else
    {
        pAligned = NULL;
    }

    return ((LPVOID) pAligned);
}

#endif

VOID
WINAPI
MemFree(
    LPVOID  p
    )
{       
    LPVOID  pOrig;

    if (p == NULL)
    {
        return;
    }

#if DBG

    {
        PPHONESP_MEMINFO    pHold;

        pHold = (PPHONESP_MEMINFO)(((LPBYTE)p) - sizeof(PHONESP_MEMINFO));

        EnterCriticalSection(&csMemoryList);

        if (pHold->pPrev)
        {
            pHold->pPrev->pNext = pHold->pNext;
        }
        else
        {
            gpMemFirst = pHold->pNext;
        }

        if (pHold->pNext)
        {
            pHold->pNext->pPrev = pHold->pPrev;
        }
        else
        {
            gpMemLast = pHold->pPrev;
        }

        LeaveCriticalSection(&csMemoryList);

        pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)pHold - 8));
    }

#else
    
    pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)p - 8));

#endif

    HeapFree(ghHeap,0, pOrig);

    return;
}

#if DBG

void
DumpMemoryList()
{

    PPHONESP_MEMINFO       pHold;

    if (gpMemFirst == NULL)
    {
        LOG((PHONESP_TRACE, "DumpMemoryList: All memory deallocated"));
        return;
    }

    pHold = gpMemFirst;

    while (pHold)
    {
       LOG((PHONESP_ERROR, "DumpMemoryList: %lx not freed - LINE %d FILE %s!", pHold+1, pHold->dwLine, pHold->pszFile));
       pHold = pHold->pNext;
    }

    if (gbBreakOnLeak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\pnp.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the code
    for finding, adding, removing, and identifying hid devices.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <basetyps.h>
#include <stdlib.h>
#include <wtypes.h>
#include <setupapi.h>
#include "hidsdi.h"
#include "hid.h"
#include "mylog.h"
#include "mymem.h"

PHID_DEVICE     gpHidDevices = NULL; 

LONG
OpenHidDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInterfaceData,
    IN OUT   PHID_DEVICE                 HidDevice
    );

VOID
CloseHidDevice (
    IN OUT   PHID_DEVICE                 HidDevice
    );

VOID
AddHidDevice (
              IN PHID_DEVICE HidDevice
             );

VOID
RemoveHidDevice (
                 IN PHID_DEVICE HidDevice
                );

PHID_DEVICE
FindHidDeviceByDevInst (
                        IN DWORD DevInst
                       );

LONG
FindKnownHidDevices (
   OUT PHID_DEVICE   *pHidDevices,
   OUT PULONG        pNumberHidDevices
   )
/*++
Routine Description:
   Do the required PnP things in order to find all the HID devices in
   the system at this time.
--*/
{
    HDEVINFO                  hardwareDeviceInfo;
    SP_DEVICE_INTERFACE_DATA  hidDeviceInterfaceData;
    SP_DEVINFO_DATA hidDeviceInfoData;
    ULONG                     i;
    PHID_DEVICE               hidDevice;
    GUID                      hidGuid;
    LONG                      lResult;

    LOG((PHONESP_TRACE, "FindKnownHidDevices - enter"));

    HidD_GetHidGuid (&hidGuid);

    *pHidDevices = NULL;
    *pNumberHidDevices = 0;

    //
    // Open a handle to the dev info list
    //
    hardwareDeviceInfo = SetupDiGetClassDevs (
                                               &hidGuid,
                                               NULL, // Define no enumerator (global)
                                               NULL, // Define no
                                               (DIGCF_PRESENT | // Only Devices present
                                                DIGCF_INTERFACEDEVICE)); // Function class devices.
  
    if(hardwareDeviceInfo == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    //
    // Mark all existing hid devices as removed. Any of these that are still present
    // will have this mark removed during enumeration below.
    //
    hidDevice = gpHidDevices;

    while (hidDevice != NULL)
    {
        //
        // Include existing devices in out count of hid devices
        //
        (*pNumberHidDevices)++;

        hidDevice->bRemoved = TRUE;
        hidDevice = hidDevice->Next;
    }

    i = 0;

    hidDeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    while (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                        0, // No care about specific PDOs
                                        &hidGuid,
                                        i++,
                                        &hidDeviceInterfaceData)) 
    {
        //
        // We enumerated a hid device, first lets get the device instance
        //      

        hidDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (SetupDiGetDeviceInterfaceDetail(hardwareDeviceInfo,
                                           &hidDeviceInterfaceData,
                                           NULL,
                                           0,
                                           NULL,
                                           &hidDeviceInfoData)
             // ERROR_INSUFFICIENT_BUFFER is alright because we passed in NULL
             // for the device interface detail data structure.
             || (GetLastError() == ERROR_INSUFFICIENT_BUFFER) )  
        {  
            LOG((PHONESP_TRACE, "FindKnownHidDevices - device instance %08x", hidDeviceInfoData.DevInst )); 
          
            //
            // Check that the hid device is not already in our list
            //

            if ((hidDevice = FindHidDeviceByDevInst(hidDeviceInfoData.DevInst)) == NULL)
            {
                //
                // This is a new hid device
                //
                // Allocate a HID_DEVICE structure
                //

                hidDevice = (PHID_DEVICE) MemAlloc(sizeof(HID_DEVICE));

                if(hidDevice == NULL)
                {
                    LOG((PHONESP_TRACE, "FindKnownHidDevices - unable to allocate hid device"));
                    SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
                    return ERROR_OUTOFMEMORY;
                }

                ZeroMemory(hidDevice, sizeof(HID_DEVICE));

                //
                // Mark this as new, so we can create a new phone for it later
                //
                hidDevice->bNew = TRUE;
                hidDevice->dwDevInst = hidDeviceInfoData.DevInst;

                //
                // Open the hid device
                //
                lResult = OpenHidDevice (hardwareDeviceInfo, &hidDeviceInterfaceData, hidDevice);

                if(lResult == ERROR_SUCCESS)
                {
                    //
                    // This is a good hid device
                    //
                    (*pNumberHidDevices)++;

                    //
                    // So add it to our hid list
                    //
                    AddHidDevice(hidDevice);

                    LOG((PHONESP_TRACE, "FindKnownHidDevices - new hid devive added"));
                }
                else
                {
                    LOG((PHONESP_TRACE, "FindKnownHidDevices - OpenHidDevice failed %08x", lResult )); 
                    MemFree(hidDevice);
                }
            }
            else
            {
                LOG((PHONESP_TRACE, "FindKnownHidDevices - hid device already enumerated"));

                //
                // Clear the removed mark on this device, so we don't remove its phone later
                //
                hidDevice->bRemoved = FALSE;
            }
        }
        else
        {
            LOG((PHONESP_TRACE, "FindKnownHidDevices - SetupDiGetDeviceInterfaceDetail failed %08x", GetLastError() ));          
        }
    }

    lResult = GetLastError();

    if (ERROR_NO_MORE_ITEMS != lResult) 
    {
        LOG((PHONESP_TRACE, "FindKnownHidDevices - SetupDiEnumDeviceInterfaces failed %08x", lResult )); 
        SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
        return lResult;
    }

    LOG((PHONESP_TRACE, "FindKnownHidDevices - exit"));

    *pHidDevices = gpHidDevices;

    SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
    return ERROR_SUCCESS;
}

LONG
OpenHidDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInterfaceData,
    IN OUT   PHID_DEVICE                 HidDevice
    )
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
    LONG                                 lResult;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //

    LOG((PHONESP_TRACE,"OpenHidDevice - enter"));

    SetupDiGetDeviceInterfaceDetail(
                                    HardwareDeviceInfo,
                                    DeviceInterfaceData,
                                    NULL, // probing so no output buffer yet
                                    0, // probing so output buffer length of zero
                                    &requiredLength,
                                    NULL    // not interested in the specific dev-node
                                   );
   
    predictedLength = requiredLength;

    HidDevice->functionClassDeviceData = MemAlloc (predictedLength);

    if (HidDevice->functionClassDeviceData == NULL)
    {
        LOG((PHONESP_TRACE,"OpenHidDevice - out of memory"));
        return ERROR_OUTOFMEMORY;
    }

    HidDevice->functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
                                           HardwareDeviceInfo,
                                           DeviceInterfaceData,
                                           HidDevice->functionClassDeviceData,
                                           predictedLength,
                                           &requiredLength,
                                           NULL)) 
    {
        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;
        LOG((PHONESP_TRACE,"OpenHidDevice - SetupDiGetDeviceInterfaceDetail 2"
                           " Failed: %d", GetLastError()));
        return GetLastError();
    }

    HidDevice->HidDevice = CreateFile (
                              HidDevice->functionClassDeviceData->DevicePath,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL, // no SECURITY_ATTRIBUTES structure
                              OPEN_EXISTING, // No special create flags
                              FILE_FLAG_OVERLAPPED, // No special attributes
                              NULL); // No template file

    if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) 
    {
        LOG((PHONESP_TRACE,"OpenHidDevice - CreateFile Failed: %d", GetLastError()));

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        return GetLastError();
    }

    if (!HidD_GetPreparsedData (HidDevice->HidDevice, &HidDevice->Ppd)) 
    {
        LOG((PHONESP_ERROR, "OpenHidDevice - HidD_GetPreparsedData failed"));

        CloseHandle(HidDevice->HidDevice);
        HidDevice->HidDevice = NULL;

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        return ERROR_INVALID_DATA;
    }

    if (!HidD_GetAttributes (HidDevice->HidDevice, &HidDevice->Attributes)) 
    {
        LOG((PHONESP_ERROR, "OpenHidDevice - HidD_GetAttributes failed"));

        CloseHandle(HidDevice->HidDevice);
        HidDevice->HidDevice = NULL;

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        HidD_FreePreparsedData (HidDevice->Ppd);

        return ERROR_INVALID_DATA;
    }

    if ((!HidP_GetCaps (HidDevice->Ppd, &HidDevice->Caps)) || 
        (HidDevice->Caps.UsagePage != HID_USAGE_PAGE_TELEPHONY) || 
        (HidDevice->Caps.Usage != HID_USAGE_TELEPHONY_PHONE) ) 
    {
        LOG((PHONESP_TRACE, " HID USAGE PAGE NOT TELEPHONY " ));

        CloseHandle(HidDevice->HidDevice);
        HidDevice->HidDevice = NULL;

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        HidD_FreePreparsedData (HidDevice->Ppd);

        return ERROR_INVALID_DATA;
    }
    else 
    {
        LOG((PHONESP_TRACE, " HID USAGE PAGE TELEPHONY " ));
    }
    //
    // At this point the client has a choice.  It may chose to look at the
    // Usage and Page of the top level collection found in the HIDP_CAPS
    // structure.  In this way it could just use the usages it knows about.
    // If either HidP_GetUsages or HidP_GetUsageValue return an error then
    // that particular usage does not exist in the report.
    // This is most likely the preferred method as the application can only
    // use usages of which it already knows.
    // In this case the app need not even call GetButtonCaps or GetValueCaps.
    //
    // In this example, however, we will call FillDeviceInfo to look for all
    //    of the usages in the device.
    //

    lResult = FillDeviceInfo(HidDevice);
    
    if(lResult != ERROR_SUCCESS)
    {
        LOG((PHONESP_ERROR, "OpenHidDevice - FillDeviceInfo failed"));

        CloseHandle(HidDevice->HidDevice);
        HidDevice->HidDevice = NULL;

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        HidD_FreePreparsedData (HidDevice->Ppd);

        return lResult;
    }

    LOG((PHONESP_TRACE,"OpenHidDevice - exit"));

    return ERROR_SUCCESS;
}



LONG
FillDeviceInfo(
               IN  PHID_DEVICE HidDevice
              )
{
    USHORT                               numValues;
    USHORT                               numCaps;
    PHIDP_BUTTON_CAPS                    buttonCaps;
    PHIDP_VALUE_CAPS                     valueCaps;
    PHID_DATA                            data;
    ULONG                                i;
    USAGE                                usage;

    //
    // setup Input Data buffers.
    //

    //
    // Allocate memory to hold on input report
    //
    
    LOG((PHONESP_TRACE,"FillDeviceInfo - enter"));


    if ( ! ( HidDevice->InputReportBuffer = (PCHAR)
           MemAlloc (HidDevice->Caps.InputReportByteLength * sizeof (CHAR)) ) )
    {
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberInputButtonCaps %d", HidDevice->Caps.NumberInputButtonCaps));

    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    HidDevice->InputButtonCaps = 
    buttonCaps                 = (PHIDP_BUTTON_CAPS)
                                MemAlloc (HidDevice->Caps.NumberInputButtonCaps
                                          * sizeof (HIDP_BUTTON_CAPS));

    if ( ! buttonCaps)
    {
        MemFree(HidDevice->InputReportBuffer);
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberInputValueCaps %d", HidDevice->Caps.NumberInputValueCaps));

    HidDevice->InputValueCaps = 
    valueCaps = (PHIDP_VALUE_CAPS)
                 MemAlloc (HidDevice->Caps.NumberInputValueCaps *
                           sizeof (HIDP_VALUE_CAPS));

    if ( ! valueCaps)
    {
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        return ERROR_OUTOFMEMORY;
    }
 
    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //
    numCaps = HidDevice->Caps.NumberInputButtonCaps;
    HidP_GetButtonCaps (HidP_Input,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberInputValueCaps;
    HidP_GetValueCaps (HidP_Input,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    //
    // Depending on the device, some value caps structures may represent more
    // than one value.  (A range).  In the interest of being verbose, over
    // efficient, we will expand these so that we have one and only one
    // struct _HID_DATA for each value.
    //
    // To do this we need to count up the total number of values are listed
    // in the value caps structure.  For each element in the array we test
    // for range if it is a range then UsageMax and UsageMin describe the
    // usages for this range INCLUSIVE.
    //
    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberInputValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax - 
                          valueCaps->Range.UsageMin + 1;
        } 
        else 
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->InputValueCaps;


    //
    // Allocate a buffer to hold the struct _HID_DATA structures.
    // One element for each set of buttons, and one element for each value
    // found.
    //
    HidDevice->InputDataLength = HidDevice->Caps.NumberInputButtonCaps + 
                                 numValues;

    HidDevice->InputData = 
    data =  (PHID_DATA) MemAlloc (HidDevice->InputDataLength *
                                  sizeof (HID_DATA));

    if( ! data )
    {
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);
        return ERROR_OUTOFMEMORY;
    }

    //
    // Fill in the button data
    //
    for (i = 0; i < HidDevice->Caps.NumberInputButtonCaps; 
                i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange) 
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else 
        {
            data->ButtonData.UsageMin = 
            data->ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Input,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);

        data->ButtonData.Usages = (PUSAGE)
                                  MemAlloc (data->ButtonData.MaxUsageLength *
                                            sizeof (USAGE));

        // if MemAlloc fails release all previous allocated memory and return 
        // error
        if ( data->ButtonData.Usages == NULL)
        {
            DWORD dwCnt;
            
            for(dwCnt = 0; dwCnt < i; dwCnt++)
            {
                MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->InputData);
            MemFree(HidDevice->InputReportBuffer);
            MemFree(HidDevice->InputButtonCaps);
            MemFree(HidDevice->InputValueCaps);
            
            return ERROR_OUTOFMEMORY;
        }

        data->ReportID = buttonCaps->ReportID;
    }

    //
    // Fill in the value data
    //
    for (i = 0; i < numValues; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) 
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps->ReportID;
                data++;
            }
        } 
        else 
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps->ReportID;
            data++;
        }
    }

    //
    // setup Output Data buffers.
    //
    if ( ! ( HidDevice->OutputReportBuffer = (PCHAR)
                           MemAlloc (HidDevice->Caps.OutputReportByteLength * 
                                     sizeof (CHAR)) ) )
    {  
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberOutputButtonCaps %d", HidDevice->Caps.NumberOutputButtonCaps));

    HidDevice->OutputButtonCaps = 
    buttonCaps = (PHIDP_BUTTON_CAPS) 
                  MemAlloc(HidDevice->Caps.NumberOutputButtonCaps * 
                           sizeof (HIDP_BUTTON_CAPS));
    if ( ! buttonCaps )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);
        MemFree(HidDevice->OutputReportBuffer);
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberOutputValueCaps %d", HidDevice->Caps.NumberOutputValueCaps));

    HidDevice->OutputValueCaps = 
    valueCaps = (PHIDP_VALUE_CAPS)
                 MemAlloc (HidDevice->Caps.NumberOutputValueCaps * 
                 sizeof (HIDP_VALUE_CAPS));
    if ( ! valueCaps )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);

        return ERROR_OUTOFMEMORY;
    }


    numCaps = HidDevice->Caps.NumberOutputButtonCaps;

    HidP_GetButtonCaps (HidP_Output,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);


    numCaps = HidDevice->Caps.NumberOutputValueCaps;

    HidP_GetValueCaps (HidP_Output,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberOutputValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax - 
                          valueCaps->Range.UsageMin + 1;
        } 
        else 
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->OutputValueCaps;

    HidDevice->OutputDataLength = HidDevice->Caps.NumberOutputButtonCaps
                                  + numValues;

    HidDevice->OutputData = 
    data = (PHID_DATA) MemAlloc (HidDevice->OutputDataLength * 
                                 sizeof (HID_DATA));

    if ( ! data )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);
        return ERROR_OUTOFMEMORY;
    }

    for (i = 0; i < HidDevice->Caps.NumberOutputButtonCaps;
                i++, data++, buttonCaps++) 
    {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange) 
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else 
        {
            data->ButtonData.UsageMin = 
            data->ButtonData.UsageMax = buttonCaps->NotRange.Usage;
        }

        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                   HidP_Output,
                                                   buttonCaps->UsagePage,
                                                   HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
                                   MemAlloc (data->ButtonData.MaxUsageLength *
                                             sizeof (USAGE));
        
        if( ! data)
        {
            DWORD dwCnt;
            
            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->InputData);
            MemFree(HidDevice->InputReportBuffer);
            MemFree(HidDevice->InputButtonCaps);
            MemFree(HidDevice->InputValueCaps);

            for(dwCnt = 0; dwCnt < i; dwCnt++)
            {
                MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->OutputData);
            MemFree(HidDevice->OutputReportBuffer);
            MemFree(HidDevice->OutputButtonCaps);
            MemFree(HidDevice->OutputValueCaps);
            
            return ERROR_OUTOFMEMORY;
        }

        data->ReportID = buttonCaps->ReportID;
    }


    for (i = 0; i < numValues; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax; usage++) 
            {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        } 
        else 
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    //
    // setup Feature Data buffers.
    //

    if ( ! ( HidDevice->FeatureReportBuffer = (PCHAR)
                     MemAlloc (HidDevice->Caps.FeatureReportByteLength *
                               sizeof (CHAR)) ) )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->OutputData);
        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);
            
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberFeatureButtonCaps %d", HidDevice->Caps.NumberFeatureButtonCaps));

    if ( ! ( HidDevice->FeatureButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
                        MemAlloc (HidDevice->Caps.NumberFeatureButtonCaps *
                                  sizeof (HIDP_BUTTON_CAPS)) ) )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->OutputData);
        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);
            
        MemFree(HidDevice->FeatureReportBuffer);

        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberFeatureValueCaps %d", HidDevice->Caps.NumberFeatureValueCaps));

    HidDevice->FeatureValueCaps = 
    valueCaps = (PHIDP_VALUE_CAPS)
                MemAlloc (HidDevice->Caps.NumberFeatureValueCaps *
                          sizeof (HIDP_VALUE_CAPS));

    if ( ! valueCaps)
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->OutputData);
        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);

        MemFree(HidDevice->FeatureReportBuffer);
        MemFree(HidDevice->FeatureButtonCaps);
            
        return ERROR_OUTOFMEMORY;
    }



    numCaps = HidDevice->Caps.NumberFeatureButtonCaps;
    HidP_GetButtonCaps (HidP_Feature,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberFeatureValueCaps;
    HidP_GetValueCaps (HidP_Feature,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberFeatureValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } 
        else 
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->FeatureValueCaps;

    HidDevice->FeatureDataLength = HidDevice->Caps.NumberFeatureButtonCaps
                                      + numValues;

    HidDevice->FeatureData = 
    data = (PHID_DATA)
            MemAlloc (HidDevice->FeatureDataLength * sizeof (HID_DATA));
    
    if ( ! data )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->OutputData);
        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);
        
        MemFree(HidDevice->FeatureReportBuffer);
        MemFree(HidDevice->FeatureButtonCaps);
        MemFree(HidDevice->FeatureValueCaps);
            
        return ERROR_OUTOFMEMORY;
    }


    for ( i = 0; i < HidDevice->Caps.NumberFeatureButtonCaps;
          i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange) 
        {
            data->ButtonData.UsageMin = buttonCaps->Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps->Range.UsageMax;
        }
        else 
        {
            data->ButtonData.UsageMin = 
            data->ButtonData.UsageMax = buttonCaps->NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Feature,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
                                  MemAlloc (data->ButtonData.MaxUsageLength *
                                            sizeof (USAGE));

        if ( ! data->ButtonData.Usages )
        {
            DWORD dwCnt;
            
            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->InputData);
            MemFree(HidDevice->InputReportBuffer);
            MemFree(HidDevice->InputButtonCaps);
            MemFree(HidDevice->InputValueCaps);

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->OutputData);
            MemFree(HidDevice->OutputReportBuffer);
            MemFree(HidDevice->OutputButtonCaps);
            MemFree(HidDevice->OutputValueCaps);

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberFeatureButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->FeatureData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->FeatureData);
            MemFree(HidDevice->FeatureReportBuffer);
            MemFree(HidDevice->FeatureButtonCaps);
            MemFree(HidDevice->FeatureValueCaps);
            
            return ERROR_OUTOFMEMORY;  
        }

        data->ReportID = buttonCaps->ReportID;
    }

    for (i = 0; i < numValues; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) 
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps->ReportID;
                data++;
            }
        } 
        else 
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - exit"));

    return ERROR_SUCCESS;
}

VOID
CloseHidDevices()
{
    LOG((PHONESP_TRACE, "CloseHidDevices - enter"));

    while (gpHidDevices != NULL)
    {
        CloseHidDevice(gpHidDevices);
    }

    LOG((PHONESP_TRACE, "CloseHidDevices - exit"));

    return;
}

BOOL
OpenHidFile (
    IN  PHID_DEVICE HidDevice
    )
{
    LOG((PHONESP_TRACE, "OpenHidFile - enter"));

    if (HidDevice != NULL)
    {
        if (HidDevice->functionClassDeviceData != NULL)
        {
            HidDevice->HidDevice = CreateFile (
                                      HidDevice->functionClassDeviceData->DevicePath,
                                      GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL, // no SECURITY_ATTRIBUTES structure
                                      OPEN_EXISTING, // No special create flags
                                      FILE_FLAG_OVERLAPPED, // No special attributes
                                      NULL); // No template file

            if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) 
            {
                LOG((PHONESP_ERROR,"OpenHidFile - CreateFile failed: %d", GetLastError()));
                return FALSE;
            }

            LOG((PHONESP_TRACE, "OpenHidFile - exit"));
            return TRUE;
        }
    }

    LOG((PHONESP_WARN, "OpenHidFile - no device"));

    return FALSE;
}

BOOL
CloseHidFile (
    IN  PHID_DEVICE HidDevice
    )
{
    LOG((PHONESP_TRACE, "CloseHidFile - enter"));

    if (HidDevice != NULL)
    {
        if ((NULL != HidDevice->HidDevice) &&
            (INVALID_HANDLE_VALUE != HidDevice->HidDevice))
        {
            CloseHandle(HidDevice->HidDevice);
            HidDevice->HidDevice = NULL;

            LOG((PHONESP_TRACE, "CloseHidFile - exit"));
            return TRUE;
        }
    }

    LOG((PHONESP_WARN, "CloseHidFile - no device"));
    return FALSE;
}

VOID
CloseHidDevice (
                IN PHID_DEVICE HidDevice
               )
{
    LOG((PHONESP_TRACE, "CloseHidDevice - enter"));

    if (HidDevice != NULL)
    {
        if (NULL != HidDevice->functionClassDeviceData)
        {
            MemFree(HidDevice->functionClassDeviceData);
        }

        if ((NULL != HidDevice -> HidDevice) &&
            (INVALID_HANDLE_VALUE != HidDevice -> HidDevice))
        {
            CloseHandle(HidDevice->HidDevice);
            HidDevice->HidDevice = NULL;
        }

        if (NULL != HidDevice->Ppd) 
        {
            HidD_FreePreparsedData(HidDevice->Ppd);
            HidDevice->Ppd = NULL;
        }

        if (NULL != HidDevice->InputReportBuffer) 
        {
            MemFree(HidDevice->InputReportBuffer);
            HidDevice->InputReportBuffer = NULL;
        }

        if (NULL != HidDevice->InputData) 
        {
            DWORD dwCnt;

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
                HidDevice->InputData[dwCnt].ButtonData.Usages = NULL;
            }

            MemFree(HidDevice->InputData);
            HidDevice->InputData = NULL;
        }

        if (NULL != HidDevice->InputButtonCaps) 
        {
            MemFree(HidDevice->InputButtonCaps);
            HidDevice->InputButtonCaps = NULL;
        }

        if (NULL != HidDevice->InputValueCaps) 
        {
            MemFree(HidDevice->InputValueCaps);
            HidDevice->InputValueCaps = NULL;
        }

        if (NULL != HidDevice->OutputReportBuffer) 
        {
            MemFree(HidDevice->OutputReportBuffer);
            HidDevice->OutputReportBuffer = NULL;
        }

        if (NULL != HidDevice->OutputData) 
        {
            DWORD dwCnt;

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
                HidDevice->OutputData[dwCnt].ButtonData.Usages = NULL;
            }

            MemFree(HidDevice->OutputData);
            HidDevice->OutputData = NULL;
        }

        if (NULL != HidDevice->OutputButtonCaps) 
        {
            MemFree(HidDevice->OutputButtonCaps);
            HidDevice->OutputButtonCaps = NULL;
        }

        if (NULL != HidDevice->OutputValueCaps) 
        {
            MemFree(HidDevice->OutputValueCaps);
            HidDevice->OutputValueCaps = NULL;
        }

        if (NULL != HidDevice->FeatureReportBuffer) 
        {
            MemFree(HidDevice->FeatureReportBuffer);
            HidDevice->FeatureReportBuffer = NULL;
        }

        if (NULL != HidDevice->FeatureData) 
        {
            DWORD dwCnt;

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberFeatureButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->FeatureData[dwCnt].ButtonData.Usages);
                HidDevice->FeatureData[dwCnt].ButtonData.Usages = NULL;
            }

            MemFree(HidDevice->FeatureData);
            HidDevice->FeatureData = NULL;
        }

        if (NULL != HidDevice->FeatureButtonCaps) 
        {
            MemFree(HidDevice->FeatureButtonCaps);
            HidDevice->FeatureButtonCaps = NULL;
        }

        if (NULL != HidDevice->FeatureValueCaps) 
        {
            MemFree(HidDevice->FeatureValueCaps);
            HidDevice->FeatureValueCaps = NULL;
        }

        RemoveHidDevice(HidDevice);
        MemFree(HidDevice);
    }

    LOG((PHONESP_TRACE, "CloseHidDevice - exit"));
    return;
}
    
VOID
AddHidDevice (
              IN PHID_DEVICE HidDevice
             )
{
    LOG((PHONESP_TRACE, "AddHidDevice - enter"));

    HidDevice->Next = gpHidDevices;
    HidDevice->Prev = NULL;

    if (gpHidDevices)
    {
        gpHidDevices->Prev = HidDevice;
    }

    gpHidDevices = HidDevice;

    LOG((PHONESP_TRACE, "AddHidDevice - exit"));
}

VOID
RemoveHidDevice (
                 IN PHID_DEVICE HidDevice
                )
{
    LOG((PHONESP_TRACE, "RemoveHidDevice - enter"));

    if (HidDevice->Prev)
    {
        HidDevice->Prev->Next = HidDevice->Next;
    }
    else
    {
        // first in list
        gpHidDevices = HidDevice->Next;
    }

    if (HidDevice->Next)
    {
        HidDevice->Next->Prev = HidDevice->Prev;
    }

    HidDevice->Next = NULL;
    HidDevice->Prev = NULL;

    LOG((PHONESP_TRACE, "RemoveHidDevice - exit"));
}

PHID_DEVICE
FindHidDeviceByDevInst (
                        IN DWORD DevInst
                       )
{
    PHID_DEVICE HidDevice = gpHidDevices;

    LOG((PHONESP_TRACE, "FindHidDeviceByDevInst - enter"));

    while (HidDevice != NULL)
    {
        if (HidDevice->dwDevInst == DevInst)
        {
            LOG((PHONESP_TRACE, "FindHidDeviceByDevInst - exit"));
            return HidDevice;
        }

        HidDevice = HidDevice->Next;
    }

    LOG((PHONESP_WARN, "FindHidDeviceByDevInst - not found"));
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\mylog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    myLOG.h

Abstract:

    Definitions for logging support.

Author:
    
    Mu Han (muhan) 1-April-1997

--*/

#ifndef _PHONESPLOG_H_
    #define _PHONESPLOG_H_

    #ifdef PHONESPLOG

        #include <rtutils.h>

        #define PHONESP_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
        #define PHONESP_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
        #define PHONESP_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
        #define PHONESP_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
        #define PHONESP_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

        BOOL NTAPI LogRegisterDebugger(LPCTSTR szName);
        BOOL NTAPI LogRegisterTracing(LPCTSTR szName);
        void NTAPI LogDeRegisterDebugger();
        void NTAPI LogDeRegisterTracing();
        void NTAPI LogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);

        #define LOGREGISTERDEBUGGER(arg) LogRegisterDebugger(arg)
        #define LOGREGISTERTRACING(arg) LogRegisterTracing(arg)
        #define LOGDEREGISTERDEBUGGER() LogDeRegisterDebugger()
        #define LOGDEREGISTERTRACING() LogDeRegisterTracing()
        #define LOG(arg) LogPrint arg

    #else // PHONESPLOG

        #define LOGREGISTERDEBUGGER(arg)
        #define LOGREGISTERTRACING(arg)
        #define LOGDEREGISTERDEBUGGER() 
        #define LOGDEREGISTERTRACING() 
        #define LOG(arg)

    #endif // PHONESPLOG

    
    #define DECLARE_LOG_ADDREF_RELEASE(x)
    #define CMSPComObject CComObject

#endif // _PHONESPLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\mylog.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mylog.c

Abstract:

    This module contains the debugging support.

Author:
    
    Mu Han (muhan)   26-March-1997

--*/

#ifdef PHONESPLOG

#include <windows.h>

#include <stdio.h>
#include "mylog.h"

#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwTracingToConsole  = 0;
static DWORD   sg_dwTracingToFile     = 0;
static DWORD   sg_dwDebuggerMask      = 0;

/*++

Routine Description:

    Registers for tracing on a debugger if it is enabled in the registry.
    This may be called from DllMain().

Arguments:

    szName   - Component name for use in the tracing

Return Value:

    BOOL

--*/
BOOL NTAPI LogRegisterDebugger(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    return TRUE;
}

/*++

Routine Description:

    Registers for tracing using the Tracing API.
    This is NOT safe to be called from DllMain().

Arguments:

    szName   - Component name for use in the tracing

Return Value:

    BOOL

--*/
BOOL NTAPI LogRegisterTracing(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szConsoleTracingEnableValue[] = "EnableConsoleTracing";
    const char szFileTracingEnableValue[] = "EnableFileTracing";

    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szConsoleTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToConsole,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szFileTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToFile,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

/*++

Routine Description:

    DeRegisters for tracing on a debugger.
    This may be called from DllMain().

--*/
void NTAPI LogDeRegisterDebugger()
{
    sg_dwTracingToDebugger = 0;
}

/*++

Routine Description:

    DeRegisters for tracing using the Tracing API.
    This is NOT safe to be called from DllMain().

--*/
void NTAPI LogDeRegisterTracing()
{
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}

/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
void NTAPI LogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{

    static char * message[24] = 
    {
        "ERROR", 
        "WARNING", 
        "INFO", 
        "TRACE", 
        "EVENT",
        "INVALID TRACE LEVEL"
    };

    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex;

    SYSTEMTIME SystemTime;
    va_list ap;
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {
        switch(dwDbgLevel)
        {
        case PHONESP_ERROR: dwIndex = 0; break;
        case PHONESP_WARN:  dwIndex = 1; break;
        case PHONESP_INFO:  dwIndex = 2; break;
        case PHONESP_TRACE: dwIndex = 3; break;
        case PHONESP_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        // retrieve local time
     
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  message[dwIndex]);

       
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        if ( ( sg_dwTracingToConsole > 0 ) || ( sg_dwTracingToFile > 0 ) )
        {
            switch(dwDbgLevel)
            {
            case PHONESP_ERROR: dwIndex = 0; break;
            case PHONESP_WARN:  dwIndex = 1; break;
            case PHONESP_INFO:  dwIndex = 2; break;
            case PHONESP_TRACE: dwIndex = 3; break;
            case PHONESP_EVENT: dwIndex = 4; break;
            default:        dwIndex = 5; break;
            }

            wsprintfA(szTraceBuf, "[%s] %s", message[dwIndex], lpszFormat);

        
            va_start(arglist, lpszFormat);
            TraceVprintfExA(sg_dwTraceID, dwDbgLevel, szTraceBuf, arglist);
            va_end(arglist);
        }
    }
}

#endif // PHONESPLOG

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\hidphone.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

     hidphone.h

Abstract:

    This module contains the definitions of all the data structures being used 
    in hidphone.c

Author: Shivani Aggarwal

--*/

#ifndef _HIDPHONE_H_
#define _HIDPHONE_H_

#include <windows.h>
#include <tspi.h>
#include <tapi.h>

#include <winbase.h>
#include <setupapi.h>
#include <TCHAR.h>
#include <mmsystem.h>

// * NOTE - initguid.h must always be defined before devguid.h 
#include <initguid.h>  
#include <hidclass.h>
#include <dbt.h>

#include "hidsdi.h"
#include "hid.h"
#include "resource.h"
#include "audio.h"
#include "mymem.h"

#define LOW_VERSION   0x00020000
#define HIGH_VERSION  0x00030001

//
// MAX_CHARS is used as an upper limit on the number of chars required
// to store the phone id as a string. The phone ids begin from 0
// to gdwNumPhones which a DWORD, hence 32-bit. Therefore the largest number
// possible is 4294967296. Hence 20 chars are enough to store the largest string 
//
#define MAX_CHARS               20

// In order to distinguish between value and button usages
#define PHONESP_BUTTON          1
#define PHONESP_VALUE           0                

// Registry strings
#define	REGSTR_PATH_WINDOWS_CURRENTVERSION		TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define TAPI_REGKEY_ROOT						REGSTR_PATH_WINDOWS_CURRENTVERSION TEXT("\\Telephony")
#define TAPI_REGKEY_PROVIDERS					TAPI_REGKEY_ROOT TEXT("\\Providers")
#define TAPI_REGVAL_NUMPROVIDERS				TEXT("NumProviders")

#define HIDPHONE_TSPDLL                         TEXT("HIDPHONE.TSP")

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Telephony HID definitions
// These are usages already defined in the Hid Telephony page. 
// Just defining the usages with User-friendly names

//
// Definitions of relevant usages on the telephony page.

#define HID_USAGE_TELEPHONY_HANDSET           ((USAGE) 0x04)
#define HID_USAGE_TELEPHONY_HEADSET           ((USAGE) 0x05)
#define HID_USAGE_TELEPHONY_HOOKSWITCH        ((USAGE) 0x20)
#define HID_USAGE_TELEPHONY_FLASH             ((USAGE) 0x21)
#define HID_USAGE_TELEPHONY_HOLD              ((USAGE) 0x23)
#define HID_USAGE_TELEPHONY_REDIAL            ((USAGE) 0x24)
#define HID_USAGE_TELEPHONY_TRANSFER          ((USAGE) 0x25)
#define HID_USAGE_TELEPHONY_DROP              ((USAGE) 0x26)
#define HID_USAGE_TELEPHONY_PARK              ((USAGE) 0x27)
#define HID_USAGE_TELEPHONY_FORWARD_CALLS     ((USAGE) 0x28)
#define HID_USAGE_TELEPHONY_LINE              ((USAGE) 0x2A)
#define HID_USAGE_TELEPHONY_SPEAKER_PHONE     ((USAGE) 0x2B)
#define HID_USAGE_TELEPHONY_CONFERENCE        ((USAGE) 0x2C)
#define HID_USAGE_TELEPHONY_RING_SELECT       ((USAGE) 0x2E)
#define HID_USAGE_TELEPHONY_PHONE_MUTE        ((USAGE) 0x2F)
#define HID_USAGE_TELEPHONY_CALLERID          ((USAGE) 0x30)
#define HID_USAGE_TELEPHONY_SEND              ((USAGE) 0x31)
#define HID_USAGE_TELEPHONY_DONOTDISTURB      ((USAGE) 0x72)
#define HID_USAGE_TELEPHONY_RINGER            ((USAGE) 0x9E)
#define HID_USAGE_TELEPHONY_PHONE_KEY_0       ((USAGE) 0xB0)
#define HID_USAGE_TELEPHONY_PHONE_KEY_1       ((USAGE) 0xB1)
#define HID_USAGE_TELEPHONY_PHONE_KEY_2       ((USAGE) 0xB2)
#define HID_USAGE_TELEPHONY_PHONE_KEY_3       ((USAGE) 0xB3)
#define HID_USAGE_TELEPHONY_PHONE_KEY_4       ((USAGE) 0xB4)
#define HID_USAGE_TELEPHONY_PHONE_KEY_5       ((USAGE) 0xB5)
#define HID_USAGE_TELEPHONY_PHONE_KEY_6       ((USAGE) 0xB6)
#define HID_USAGE_TELEPHONY_PHONE_KEY_7       ((USAGE) 0xB7)
#define HID_USAGE_TELEPHONY_PHONE_KEY_8       ((USAGE) 0xB8)
#define HID_USAGE_TELEPHONY_PHONE_KEY_9       ((USAGE) 0xB9)
#define HID_USAGE_TELEPHONY_PHONE_KEY_STAR    ((USAGE) 0xBA)
#define HID_USAGE_TELEPHONY_PHONE_KEY_POUND   ((USAGE) 0xBB)
#define HID_USAGE_TELEPHONY_PHONE_KEY_A       ((USAGE) 0xBC)
#define HID_USAGE_TELEPHONY_PHONE_KEY_B       ((USAGE) 0xBD)
#define HID_USAGE_TELEPHONY_PHONE_KEY_C       ((USAGE) 0xBE)
#define HID_USAGE_TELEPHONY_PHONE_KEY_D       ((USAGE) 0xBF)

#define HID_USAGE_CONSUMER_VOLUME             ((USAGE) 0xE0)

#define PHONESP_ALLBUTTONMODES                   \
        (   PHONEBUTTONMODE_CALL               | \
            PHONEBUTTONMODE_FEATURE            | \
            PHONEBUTTONMODE_KEYPAD             | \
            PHONEBUTTONMODE_LOCAL              | \
            PHONEBUTTONMODE_DISPLAY )

#define PHONESP_ALLBUTTONSTATES              \
        (PHONEBUTTONSTATE_UP               | \
         PHONEBUTTONSTATE_DOWN)     


// These act like bit masks which specify which reports are valid for a usage
#define INPUT_REPORT                   1
#define OUTPUT_REPORT                  2
#define FEATURE_REPORT                 4


/*****************************************************************************/
//
// This structure holds the information for the button
//
typedef struct _PHONESP_BUTTON_INFO
{
    // The ID for this button 
    DWORD dwButtonID;

   // The ButtonMode (whether it is a PHONEBUTTONMODE_FEATURE or _KEYPAD, etc)
    DWORD dwButtonMode;

    // the Function (PHONEBUTTONFUNCTION_NONE or _FLASH, etc),
    DWORD dwButtonFunction;

    //
    // This data is relevant for only on-off control buttons. The current state
    // of the button is stored here
    //
    DWORD dwButtonState;

    // the Button Text associated for the button - these are present in the 
    // string table 
    LPWSTR szButtonText;

} PHONESP_BUTTONINFO, *PPHONESP_BUTTONINFO;

/*****************************************************************************/
// 
//
// User friendly names for the indexes into the capabilities of the phone structure
//
#define PHONESP_PHONE_KEY_0             0
#define PHONESP_PHONE_KEY_1             1
#define PHONESP_PHONE_KEY_2             2
#define PHONESP_PHONE_KEY_3             3
#define PHONESP_PHONE_KEY_4             4
#define PHONESP_PHONE_KEY_5             5
#define PHONESP_PHONE_KEY_6             6
#define PHONESP_PHONE_KEY_7             7
#define PHONESP_PHONE_KEY_8             8
#define PHONESP_PHONE_KEY_9             9
#define PHONESP_PHONE_KEY_STAR          10
#define PHONESP_PHONE_KEY_POUND         11
#define PHONESP_PHONE_KEY_A             12
#define PHONESP_PHONE_KEY_B             13
#define PHONESP_PHONE_KEY_C             14
#define PHONESP_PHONE_KEY_D             15

// The number of dial buttons supported by this tsp
#define PHONESP_NUMBER_PHONE_KEYS       16

// Feature Button indices
#define PHONESP_FEATURE_FLASH                   16
#define PHONESP_FEATURE_HOLD                    17
#define PHONESP_FEATURE_REDIAL                  18
#define PHONESP_FEATURE_TRANSFER                19
#define PHONESP_FEATURE_DROP                    20
#define PHONESP_FEATURE_PARK                    21
#define PHONESP_FEATURE_FORWARD                 22
#define PHONESP_FEATURE_LINE                    23
#define PHONESP_FEATURE_CONFERENCE              24
#define PHONESP_FEATURE_RING_SELECT             25
#define PHONESP_FEATURE_PHONE_MUTE              26
#define PHONESP_FEATURE_CALLERID                27
#define PHONESP_FEATURE_DONOTDISTURB            28
#define PHONESP_FEATURE_SEND                    29
#define PHONESP_FEATURE_VOLUMEUP                30
#define PHONESP_FEATURE_VOLUMEDOWN              31

// The number of Feature buttons supported by this tsp
#define PHONESP_NUMBER_FEATURE_BUTTONS               16
#define PHONESP_NUMBER_BUTTONS              ( PHONESP_NUMBER_PHONE_KEYS +     \
                                              PHONESP_NUMBER_FEATURE_BUTTONS )

//
// The functions associated with the feature buttons 
//
DWORD gdwButtonFunction[] = 
{
    PHONEBUTTONFUNCTION_FLASH,
    PHONEBUTTONFUNCTION_HOLD,
    PHONEBUTTONFUNCTION_LASTNUM,
    PHONEBUTTONFUNCTION_TRANSFER,
    PHONEBUTTONFUNCTION_DROP,
    PHONEBUTTONFUNCTION_PARK,
    PHONEBUTTONFUNCTION_FORWARD,
    PHONEBUTTONFUNCTION_CALLAPP,
    PHONEBUTTONFUNCTION_CONFERENCE,
    PHONEBUTTONFUNCTION_SELECTRING,
    PHONEBUTTONFUNCTION_MUTE,
    PHONEBUTTONFUNCTION_CALLID,
    PHONEBUTTONFUNCTION_DONOTDISTURB,
    PHONEBUTTONFUNCTION_SEND,
    PHONEBUTTONFUNCTION_VOLUMEUP,
    PHONEBUTTONFUNCTION_VOLUMEDOWN
};

// 
// The associated string table ID for the text of the phone buttons
// 
DWORD gdwButtonText[] =
{
    IDS_PHONE_KEY_0,
    IDS_PHONE_KEY_1,
    IDS_PHONE_KEY_2,
    IDS_PHONE_KEY_3,
    IDS_PHONE_KEY_4,
    IDS_PHONE_KEY_5,
    IDS_PHONE_KEY_6,
    IDS_PHONE_KEY_7,
    IDS_PHONE_KEY_8,
    IDS_PHONE_KEY_9,
    IDS_PHONE_KEY_STAR,
    IDS_PHONE_KEY_POUND,
    IDS_PHONE_KEY_A,
    IDS_PHONE_KEY_B,
    IDS_PHONE_KEY_C,
    IDS_PHONE_KEY_D,
    IDS_BUTTON_FLASH,
    IDS_BUTTON_HOLD,
    IDS_BUTTON_REDIAL,
    IDS_BUTTON_TRANSFER,
    IDS_BUTTON_DROP,
    IDS_BUTTON_PARK,
    IDS_BUTTON_FORWARD,
    IDS_BUTTON_LINE,    
    IDS_BUTTON_CONFERENCE,
    IDS_BUTTON_RING_SELECT,
    IDS_BUTTON_MUTE,
    IDS_BUTTON_CALLERID,
    IDS_BUTTON_DONOTDISTURB,
    IDS_BUTTON_SEND,
    IDS_BUTTON_VOLUMEUP,
    IDS_BUTTON_VOLUMEDOWN
};



typedef struct _PHONESP_LOOKUP_USAGEINDEX
{
    USAGE Usage;
    DWORD Index;
}PHONESP_LOOKUPUSAGEINDEX, *PPHONESP_LOOKUPUSAGEINDEX;

// inorder to look up the index for the feature button usages
// The 1st value in this 2-D array are the feature usages supported
// The 2nd value is the respective index

PHONESP_LOOKUPUSAGEINDEX gdwLookupFeatureIndex [] =   
{
    { HID_USAGE_TELEPHONY_FLASH,         PHONESP_FEATURE_FLASH        },
    { HID_USAGE_TELEPHONY_HOLD,          PHONESP_FEATURE_HOLD         },
    { HID_USAGE_TELEPHONY_REDIAL,        PHONESP_FEATURE_REDIAL       },
    { HID_USAGE_TELEPHONY_TRANSFER,      PHONESP_FEATURE_TRANSFER     },
    { HID_USAGE_TELEPHONY_DROP,          PHONESP_FEATURE_DROP         },
    { HID_USAGE_TELEPHONY_PARK,          PHONESP_FEATURE_PARK         },
    { HID_USAGE_TELEPHONY_FORWARD_CALLS, PHONESP_FEATURE_FORWARD      },
    { HID_USAGE_TELEPHONY_LINE,          PHONESP_FEATURE_LINE         },
    { HID_USAGE_TELEPHONY_CONFERENCE,    PHONESP_FEATURE_CONFERENCE   },
    { HID_USAGE_TELEPHONY_RING_SELECT,   PHONESP_FEATURE_RING_SELECT  },
    { HID_USAGE_TELEPHONY_PHONE_MUTE,    PHONESP_FEATURE_PHONE_MUTE   },
    { HID_USAGE_TELEPHONY_CALLERID,      PHONESP_FEATURE_CALLERID     },
    { HID_USAGE_TELEPHONY_DONOTDISTURB,  PHONESP_FEATURE_DONOTDISTURB },
    { HID_USAGE_TELEPHONY_SEND,          PHONESP_FEATURE_SEND         }
};

/****************************************************************************/
//
// This structure maintains the information available about the phone. Every
// phone that has been enumerated has this structure associated with it
//
typedef struct _PHONESP_PHONE_INFO
{
    // The deviceID for the phone. The Device ID for the phone is initialized
    // in TSPI_providerInit 
    DWORD                   dwDeviceID;
    
    //
    // The version negotiated with TAPI using TSPI_phoneNegotiateTSPIVersion 
    // function that returns the highest SPI version the TSP can operate under 
    // for this device.
    //
    DWORD                   dwVersion;

    //
    // if this is true then it means that the
    // phone is open and phone close on the device hasn't been called yet
    //
    BOOL                    bPhoneOpen;

    //
    // if this is false it means that this entry in the phone array is
    // unused and can be filled in with a new phone
    //
    BOOL                    bAllocated;

    //
    // if this is true it means that a PHONE_CREATE message was sent for this
    // phone, but we are waiting for a TSPI_providerCreatePhoneDevice
    //
    BOOL                    bCreatePending;

    //
    // if this is true it means that a PHONE_REMOVE message was sent for this
    // phone, but we are waiting for a TSPI_phoneClose
    //
    BOOL                    bRemovePending;
    
    //
    // This variable keeps a count of the number of requests queued for this 
    // phone in the async queue
    //
    DWORD                   dwNumPendingReqInQueue;

    //
    // A handle to an event object which is set when there are no requests
    // pending in the queue for this phone. Phone Close waits on this event 
    // to ensure that all asynchronous operations on the phone has been
    // completed
    //
    HANDLE                  hNoPendingReqInQueueEvent;


    //
    // The handle for the phone received from TAPI and used by the phone
    // to notify TAPI about the events occuring on this phone
    //
    HTAPIPHONE              htPhone;

    //
    //Pointer to the Hid Device structure associated with this device
    //
    PHID_DEVICE                pHidDevice;

    //
    // Whether the phone device has a render device associated with it
    //
    BOOL                    bRender;
    
    //
    // if the render device exists for this phone, this data contains the 
    // render device id
    //
    DWORD                   dwRenderWaveId;

    //
    // Whether the phone device has a capture device associated with it
    //
    BOOL                    bCapture;

    //
    // if the capture device exists for this phone, this data contains the 
    // capture device id
    //
    DWORD                   dwCaptureWaveId;

 
    // This event is signalled when a input report is recieved from the device
    HANDLE                  hInputReportEvent;

    // This event is signalled when the phone is closed
    HANDLE                  hCloseEvent;

    // A handle to the read thread
    HANDLE                  hReadThread;
    
    // The structure to be passed to the ReadFile function - This struct will
    // pass the hInputReportEvent which will be triggered when ReadFile returns 
    LPOVERLAPPED            lpOverlapped;

    // The Critical Section for this phone
    CRITICAL_SECTION        csThisPhone;

    // lpfnPhoneEventProc is a callback function implemented by TAPI and 
    // supplied to the TSP as a parameter to TSPI_phoneOpen The TSP calls this
    // function to report events that occur on the phone.
    //
    PHONEEVENT              lpfnPhoneEventProc;  

    // The phone states messages for which TAPI can receive notification
    DWORD                   dwPhoneStates;

    //
    // The phone state messages TAPI is interested in receiving
    //
    DWORD                    dwPhoneStateMsgs;   
                                                 
    // 
    // The last three bits of this data signify which reports are valid for the
    // handset/speaker. If zero, the handset does not exist, if bit 0 is set - 
    // input report can be received, if bit 1 is set - output report can be 
    // sent, if bit 2 is set - feature report supported
    //
    DWORD                   dwHandset;
    DWORD                   dwSpeaker;


    //
    // The mode of the handset/ speaker at the moment whether _ONHOOK, _MIC, 
    // _SPEAKER, _MICSPEAKER. These modes are defined by TAPI
    //
    DWORD                   dwHandsetHookSwitchMode;
    DWORD                   dwSpeakerHookSwitchMode;

    BOOL                    bSpeakerHookSwitchButton;

    //
    // The hookswitch supported on this phone - handset and/or speaker
    //
    DWORD                   dwHookSwitchDevs; 

    // To determine whether the phone has a keypad
    BOOL                    bKeyPad;

    // 
    // The last three bits of this data signify which reports are valid for the
    // ringer. If zero, the handset does not exist, if bit 0 is set - input 
    // report can be received, if bit 1 is set - output report can be sent, if 
    // bit 2 is set - feature report supported
    //
    DWORD                    dwRing;

    // 
    // The last three bits of this data signify which reports are valid for the
    // volume control. If zero, the handset does not exist, if bit 0 is set - input 
    // report can be received, if bit 1 is set - output report can be sent, if 
    // bit 2 is set - feature report supported
    //
    DWORD                    dwVolume;

    //
    // The mode of the handset/ speaker at the moment whether ringing or not
    // if zero the phone is not ringing 
    //
    DWORD                   dwRingMode;

    // The buttonmodes for which the phone will send phone events
    DWORD                   dwButtonModesMsgs;

    // The button states for which the phone will send phone events
    DWORD                   dwButtonStateMsgs; 

    // Number of usable buttons on this phone 
    DWORD                    dwNumButtons;
    PPHONESP_BUTTONINFO     pButtonInfo;

    //
    // The Phone Name and other Info on this Phone which will be displayed 
    //
    LPWSTR                  wszPhoneName, wszPhoneInfo;

    //
    // The buttons valid for this phone - the entry for the 
    // corresponding button contains 0 if the button associated with the index 
    // does not exist else it specifies the report types valid for this button
    // using the last 3 bits. 
    //
    DWORD                   dwReportTypes[PHONESP_NUMBER_BUTTONS];

    //
    // After the button is created this contains the 
    // report Id assigned to the button
    //
    DWORD                   dwButtonIds[PHONESP_NUMBER_BUTTONS];

} PHONESP_PHONE_INFO, *PPHONESP_PHONE_INFO;
/*****************************************************************************/

typedef void (CALLBACK *ASYNCPROC)(PPHONESP_ASYNCREQINFO, BOOL);



/*****************************************************************************/
typedef struct _PHONESP_FUNC_INFO
{
    // number of parameters in this array - don't actually use it, can be removed
    DWORD                   dwNumParams;  

    // The pointer to the phone 
    ULONG_PTR               dwParam1;

    //
    // The rest of the parameters are dependent on the function 
    // to which this parameter list is passed
    //
    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;
    ULONG_PTR               dwParam4;
    ULONG_PTR               dwParam5;
    ULONG_PTR               dwParam6;
    ULONG_PTR               dwParam7;
    ULONG_PTR               dwParam8;

} PHONESP_FUNC_INFO, far *PPHONESP_FUNC_INFO;
/*****************************************************************************/

typedef struct _PHONESP_ASYNC_REQUEST_INFO
{
    // The function to be executed
    ASYNCPROC               pfnAsyncProc;

    // Parameters to be passed to the async function
    PPHONESP_FUNC_INFO            pFuncInfo;

} PHONESP_ASYNC_REQ_INFO, *PPHONESP_ASYNC_REQ_INFO;
/*****************************************************************************/

typedef struct _PHONESP_ASYNC_QUEUE
{

    //
    //The handle to the thread which services the queue
    //
    HANDLE                  hAsyncEventQueueServiceThread;
    
    //
    // The event if set signifies pending entries in the queue
    // else the thread waits on this thread
    //
    HANDLE                  hAsyncEventsPendingEvent;
    
    CRITICAL_SECTION        AsyncEventQueueCritSec;

    DWORD                   dwNumTotalQueueEntries;
    DWORD                   dwNumUsedQueueEntries;

    //Pointer to the queue
    PPHONESP_ASYNC_REQ_INFO           *pAsyncRequestQueue;
  
    //Pointer to the next entry in the queue where the request can be added
    PPHONESP_ASYNC_REQ_INFO           *pAsyncRequestQueueIn;
  
    //Pointer to the next request to be serviced in the queue
    PPHONESP_ASYNC_REQ_INFO           *pAsyncRequestQueueOut;
    
} PHONESP_ASYNCQUEUE, *PPHONESP_ASYNCQUEUE;
/*****************************************************************************/


//
// All these might be combined in a global structure
//
DWORD                       gdwNumPhones;
HINSTANCE                   ghInst;
DWORD                       gdwPermanentProviderID;
DWORD                       gdwPhoneDeviceIDBase;
HPROVIDER                   ghProvider;

// The memory for this queue is allocated in providerInit and will be used to 
// store requests on the phone. These requests will be processed asynchronously
// by a separate Thread created on this queue
PHONESP_ASYNCQUEUE          gAsyncQueue, gInputReportQueue;

// 256 is just a random number taken for the initial number of entries that the 
// can have.. the queue can be expanded later as required
#define MAX_QUEUE_ENTRIES   256


//
// glpfnCompletionProc is a callback function implemented by TAPI and supplied 
// to the TSP as a parameter to TSPI_providerInit.The TSP calls this function 
// to report the completion of a line or phone procedure that it executes 
// asynchronously.
//
ASYNC_COMPLETION            glpfnCompletionProc;

//
// glpfnPhoneCreateProc is a callback function implemented by TAPI and supplied
// to the TSP as a parameter to TSPI_providerInit The TSP calls this function 
// to report the creation of a new device.
//
PHONEEVENT                  glpfnPhoneCreateProc;

// gpPhone maintains an array of the phones enumerated - each of these phones 
// have a corresponding HidDevice value in the gpHidDevices. 
PPHONESP_PHONE_INFO         *gpPhone;      
            

// This the global heap from which all the memory allocations are carried out
HANDLE                      ghHeap;


// This two handles are required for registering for PNP events
HANDLE                      ghDevNotify;
HWND                        ghWndNotify;



const LPCWSTR               gpcstrServiceName = _T("TapiSrv");

LPCWSTR                     gszProviderInfo;

// This is to notify the thread that services the queue to exit
// maybe this could be changed to an event based termination of thread
BOOL gbProviderShutdown = FALSE;

CRITICAL_SECTION            csAllPhones;
CRITICAL_SECTION            csHidList;

PPHONESP_MEMINFO            gpMemFirst = NULL, gpMemLast = NULL;
CRITICAL_SECTION            csMemoryList;
BOOL                        gbBreakOnLeak = FALSE;



/**********************PRIVATE FUNCTIONS**************************************/
BOOL
AsyncRequestQueueIn (
                     PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo
                    );


LONG
CreateButtonsAndAssignID(
                         PPHONESP_PHONE_INFO pPhone
                         );

PPHONESP_BUTTONINFO
GetButtonFromID (
                 PPHONESP_PHONE_INFO pPhone,
                 DWORD dwButtonID
                );

VOID
GetButtonUsages(
                PPHONESP_PHONE_INFO pPhone,
                PHIDP_BUTTON_CAPS pButtonCaps,
                DWORD dwNumberButtonCaps,
                DWORD ReportType
                );

PPHONESP_PHONE_INFO
GetPhoneFromID(
               DWORD   dwDeviceID,
               DWORD * pdwPhoneID
               );

PPHONESP_PHONE_INFO
GetPhoneFromHid (
                PHID_DEVICE HidDevice
               );

VOID
GetValueUsages(
                PPHONESP_PHONE_INFO pPhone,
                PHIDP_VALUE_CAPS pValueCaps,
                DWORD dwNumberCaps,
                DWORD ReportType
               );


VOID 
InitPhoneAttribFromUsage (
                          DWORD ReportType,
                          USAGE UsagePage,
                          USAGE Usage,
                          PPHONESP_PHONE_INFO pPhone,
                          LONG Min,
                          LONG Max
                          );

LONG
LookupIndexForUsage(
                    IN  DWORD  Usage,
                    OUT DWORD *Index
                    );
DWORD 
WINAPI 
PNPServiceHandler(
                  DWORD dwControl,
                  DWORD dwEventType,
                  LPVOID lpEventData,
                  LPVOID lpContext
                 );

VOID
ReportUsage (
              PPHONESP_PHONE_INFO pPhone,
              USAGE     UsagePage,
              USAGE     Usage,
              ULONG     Value
            );

VOID
SendPhoneEvent(
    PPHONESP_PHONE_INFO    pPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

LONG
SendOutputReport(
                 PHID_DEVICE pHidDevice,
                 USAGE      Usage,
                 BOOL       bSet
                );


VOID
CALLBACK
ShowData(
         PPHONESP_FUNC_INFO pAsyncFuncInfo 
        );

LPWSTR
PHONESP_LoadString(
             IN UINT ResourceID,
             PLONG lResult
             );

BOOL
ReadInputReport (
                    PPHONESP_PHONE_INFO    pPhone
                );

VOID
InitUsage (
           PPHONESP_PHONE_INFO pPhone,
           USAGE     Usage,
           BOOL      bON
          );

VOID
ReenumDevices ();

VOID
FreePhone (
           PPHONESP_PHONE_INFO pPhone
          );

LONG
CreatePhone (
            PPHONESP_PHONE_INFO pPhone,
            PHID_DEVICE pHidDevice,
            DWORD dwPhoneCnt
          );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\hidphone.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

     hidphone.c

Abstract:

    This module contains implements the phone tsp functions is called by
    tapi in order to access the HID compliant USB phone device.
    This module communicates with the phone device using the HID interface.

Author: Shivani Aggarwal

Comments:
     Locking Mechanism:
        There are two critical section objects being used inorder to protect
        the phone structure from simultaneous access - csAllPhones and 
        csThisPhone. Every phone has one csThisPhone, the critical section 
        object, associated with it. csThisPhone ensures that the Phone Info
        is accessed in a thread-safe manner. csAllPhones is a global Critical
        Section Object that ensures that a thread acquires the csThisPhone 
        Critical Section Object in a thread safe manner. In other words, it 
        ensures that, the thread waits on csThisPhone while the Critical 
        Section Object is still valid. 
        The csAllPhones should always be acquired before csThisPhone. 
        A phone can be closed only after the thread has acquired both 
        csAllPhones and csThisPhone for the specific phone to be closed. Both
        these objects are released only after the function is completed. For 
        all other functions, the csAllPhones critical section is released as 
        soon as the thread acquires csThisPhone object.

------------------------------------------------------------------------------*/


#include "hidphone.h"     //** NOTE - hidphone.h must be defined before mylog.h
#include "mylog.h"

BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            // inorder to enable logging for this tsp              
            LOGREGISTERDEBUGGER(_T("hidphone"));

            LOG((PHONESP_TRACE, "DllMain - DLL_PROCESS_ATTACH"));

            ghInst = hDLL;                   

            // if the heap cannot be created, use the heap from the process
           
            if (!(ghHeap = HeapCreate(
                                      0,    // NULL on failure,serialize access
                                      0x1000, // initial heap size
                                      0       // max heap size (0 == growable)
                                     )))
            {
                LOG((PHONESP_ERROR, "DllMain - HeapCreate failed %d", GetLastError()));

                ghHeap = GetProcessHeap();

                if (ghHeap == NULL)
                {
                    LOG((PHONESP_ERROR, "DllMain - GetProcessHeap failed %d", GetLastError()));

                    return GetLastError();
                }
            }
            
            
            // Inorder to diasble notifications of thread attach and detach in 
            // multi-threaded apps it can be a very useful optimization

            DisableThreadLibraryCalls( hDLL );    
                    
            break;
        }
    
        case DLL_PROCESS_DETACH:
        {
            LOG((PHONESP_TRACE, "DllMain - DLL_PROCESS_DETACH"));

            LOGDEREGISTERDEBUGGER();
            
            // if ghHeap is NULL, then there is no heap to destroy
            if ( ( ghHeap != NULL) && ( ghHeap != GetProcessHeap() ) )
            {   
                    HeapDestroy (ghHeap);
            }
            break;
        }
     
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;
    
    } // switch
    return TRUE;
}
/*************************DLLMAIN - END***************************************/


/******************************************************************************
    IsTSPAlreadyInstalled:

    Searchs registry for previous instance of HidPhone TSP.

    Arguments:
        none

    Returns BOOL:
        Returns true if TSP already installed

    Comments:

******************************************************************************/
BOOL
IsTSPAlreadyInstalled()
{
    DWORD i;
    HKEY hKey;
    LONG lStatus;
    DWORD dwNumProviders = 0;
    DWORD dwDataSize = sizeof(DWORD);
    DWORD dwDataType = REG_DWORD;
    LPTSTR pszProvidersKey = TAPI_REGKEY_PROVIDERS;
    LPTSTR pszNumProvidersValue = TAPI_REGVAL_NUMPROVIDERS;
    TCHAR szName[MAX_PATH];
    TCHAR szPath[MAX_PATH];

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszProvidersKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if (lStatus != ERROR_SUCCESS)
    {
        LOG((PHONESP_ERROR, "IsTSPAlreadyInstalled - "
            "error opening tapi providers key - %lx", lStatus));

        // done
        return FALSE;
    }

    // see if installed bit set
    lStatus = RegQueryValueEx(
                hKey,
                pszNumProvidersValue,
                0,
                &dwDataType,
                (LPBYTE) &dwNumProviders,
                &dwDataSize
                );

    // validate status
    if( lStatus != ERROR_SUCCESS )
    {
        LOG((PHONESP_ERROR, "IsTSPAlreadyInstalled - "
            "error determining number of providers - %lx", lStatus));

        // release handle
        RegCloseKey(hKey);

        // done
        return FALSE;
    }

    // loop through each provider
    for (i = 0; i < dwNumProviders; i++)
    {
        // construct path to provider name
        wsprintf(szName, _T("ProviderFileName%d"), i);

        // reinitialize size
        dwDataSize = sizeof(szPath);

        // query the next name
        lStatus = RegQueryValueEx(
                        hKey,
                        szName,
                        0,
                        &dwDataType,
                        (unsigned char*)szPath,
                        &dwDataSize
                        );

        // validate status
        if (lStatus == ERROR_SUCCESS)
        {
            // upper case
            _tcsupr(szPath);

            // compare path string to hidphone provider
            if (_tcsstr(szPath, HIDPHONE_TSPDLL) != NULL)
            {
                // release handle
                RegCloseKey(hKey);

                // done
                return TRUE;
            }

        }
        else 
        {
            LOG((PHONESP_ERROR, "IsTSPAlreadyInstalled - "
            "error querying %s - %lx", szName, lStatus));
        }
    }

    // release handle
    RegCloseKey(hKey);

    // done
    return FALSE;
}

/******************************************************************************
    ReenumDevices:

    This function reenumerated hid devices after a pnp event. It will
    create phone devices for new hid arrivals and remove phone devices
    (provided they are closed) for hid removals. It will also notify
    TAPI of these events.

    Arguments:
        none

    Returns VOID:

    Comments:

******************************************************************************/

VOID
ReenumDevices ()
{
    PHID_DEVICE           pHidDevices;
    PHID_DEVICE           pHidDevice;
    PHID_DEVICE           pNextHidDevice;
    ULONG                 NumHidDevices;
    DWORD                 dwNewCount;
    DWORD                 dwRemovedCount;
    DWORD                 dwPhone;
    LONG                  lResult;
    PPHONESP_PHONE_INFO   pPhone;
    
    LOG((PHONESP_TRACE, "ReenumDevices - enter"));

    EnterCriticalSection(&csHidList);

    // Find Telephony hid Devices 
    lResult = FindKnownHidDevices (&pHidDevices, 
                                   &NumHidDevices);

    LOG((PHONESP_TRACE, "ReenumDevices - number of Hid Devices : %d ", NumHidDevices));

    dwNewCount = 0;
    dwRemovedCount = 0;

    EnterCriticalSection(&csAllPhones);

    for (pHidDevice = pHidDevices; pHidDevice != NULL; pHidDevice = pNextHidDevice)
    {
        //
        // Get pointer to the next Hid device now, so we can remove the current
        // device if necessary without messing up our search
        //
        pNextHidDevice = pHidDevice->Next;

        if (pHidDevice->bRemoved)
        {
            //
            // This device has been removed
            //

            dwRemovedCount++;

            pPhone = GetPhoneFromHid(pHidDevice);

            // Check whether the phone handle is still valid
            if ( !IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ))
            {

                EnterCriticalSection(&pPhone->csThisPhone);

                //
                // First lets get rid of the Hid device since it has already
                // physically left the system
                //

                pPhone->pHidDevice = NULL;
                CloseHidDevice(pHidDevice);

                //
                // Send a phone remove to TAPI
                //
                SendPhoneEvent(
                        pPhone,
                        PHONE_REMOVE,
                        pPhone->dwDeviceID,
                        0,
                        0
                        );

                if (pPhone->bPhoneOpen)
                {
                    //
                    // The phone is open, we can't remove it right away so
                    // mark it remove pending
                    //

                    pPhone->bRemovePending = TRUE;

                    LOG((PHONESP_TRACE, "ReenumDevices - phone remove pending [dwDeviceID %d] ", pPhone->dwDeviceID));
                }
                else
                {
                    //
                    // The phone is closed, we can remove it now
                    //

                    FreePhone(pPhone);

                    LOG((PHONESP_TRACE, "ReenumDevices - phone remove complete [dwDeviceID %d] ", pPhone->dwDeviceID));
                }

                LeaveCriticalSection(&pPhone->csThisPhone);
            }
            else
            {
                LOG((PHONESP_ERROR, "ReenumDevices - GetPhoneFromHid returned an invalid phone pointer"));
            }
        }
        else if (pHidDevice->bNew)
        {
            BOOL bFound = FALSE;

            //
            // This device is new
            //

            dwNewCount++;

            pHidDevice->bNew = FALSE;

            //
            // We need to create a new phone device, find a spot
            //

            for (dwPhone = 0; dwPhone < gdwNumPhones; dwPhone++)
            {
                pPhone = (PPHONESP_PHONE_INFO) gpPhone[ dwPhone ];

                EnterCriticalSection(&pPhone->csThisPhone);

                if ( !pPhone->bAllocated && !pPhone->bCreatePending )
                {
                    //
                    // We have an open slot for this phone
                    //
                    LOG((PHONESP_TRACE, "ReenumDevices - slot %d open", dwPhone));

                    bFound = TRUE;

                    LeaveCriticalSection(&pPhone->csThisPhone);
                    break;
                }

                LeaveCriticalSection(&pPhone->csThisPhone);
            }


            if (!bFound)
            {
                //
                // We don't have a slot open, so we will have to realloc the
                // array to create a new one
                //                

                PPHONESP_PHONE_INFO *pNewPhones;

                LOG((PHONESP_TRACE, "ReenumDevices - creating a new slot"));

                if ( ! ( pNewPhones = MemAlloc((gdwNumPhones + 1) * sizeof(PPHONESP_PHONE_INFO)) ) )
                {           
                    LOG((PHONESP_ERROR,"ReenumDevices - out of memory "));
                }
                else
                {
                    CopyMemory(
                            pNewPhones,
                            gpPhone,
                            sizeof(PPHONESP_PHONE_INFO) * gdwNumPhones
                           );

                    // Allocate memory for this phone 
                    if ( pNewPhones[gdwNumPhones] = (PPHONESP_PHONE_INFO)MemAlloc(sizeof(PHONESP_PHONE_INFO)) )
                    { 
                        LOG((PHONESP_TRACE, "ReenumDevices - initializing device: %d",gdwNumPhones+1));

                        ZeroMemory( pNewPhones[gdwNumPhones], sizeof(PHONESP_PHONE_INFO));

                        //
                        // Initialize the critical section object for this phone. only the 
                        // thread that owns this object can access the structure for this phone
                        //
                        __try
                        {
                            InitializeCriticalSection( &pNewPhones[gdwNumPhones]->csThisPhone );
                        }
                        __except(1)
                        {
                            MemFree(pNewPhones[gdwNumPhones]);
                            MemFree(pNewPhones);
                            pNewPhones = NULL;

                            LOG((PHONESP_ERROR,"ReenumDevices - Initialize Critical Section"
                                  " Failed for Phone %d", gdwNumPhones+1));
                        }
                        
                        if ( pNewPhones != NULL )
                        {
                            //
                            // Success
                            //

                            LOG((PHONESP_TRACE, "ReenumDevices - slot %d created", gdwNumPhones));

                            dwPhone = gdwNumPhones;
                            pPhone = pNewPhones[dwPhone];
                            bFound = TRUE;

                            MemFree(gpPhone);
                            gpPhone = pNewPhones;
                            gdwNumPhones++;   
                        }
                    }
                    else
                    { 
                        MemFree(pNewPhones);

                        LOG((PHONESP_ERROR,"ReenumDevices - out of memory "));
                    }                 
                }
            }

            if (bFound)
            {
                //
                // Now actually create the phone
                //

                EnterCriticalSection(&pPhone->csThisPhone);

                lResult = CreatePhone( pPhone, pHidDevice, dwPhone );

                if ( lResult != ERROR_SUCCESS )
                {
                    LOG((PHONESP_ERROR,"ReenumDevices - CreatePhone"
                          " Failed for Phone %d: error: %d", dwPhone, lResult));
                }
                else
                {
                    // Phone created successfully, send a PHONE_CREATE message

                    pPhone->bCreatePending = TRUE;

                    SendPhoneEvent(
                                    pPhone,
                                    PHONE_CREATE,
                                    (DWORD_PTR)ghProvider,
                                    dwPhone,
                                    0
                                   );

                    LOG((PHONESP_TRACE, "ReenumDevices - phone create pending [dwTempID %d] ", dwPhone));
                }

                LeaveCriticalSection(&pPhone->csThisPhone);
            }
            else
            {
                LOG((PHONESP_ERROR, "ReenunDevices - unable to create new phone"));
            }
        }
    }

    LeaveCriticalSection(&csAllPhones);

    LeaveCriticalSection(&csHidList);

    LOG((PHONESP_TRACE, "ReenumDevices - new : %d ", dwNewCount));
    LOG((PHONESP_TRACE, "ReenumDevices - removed : %d ", dwRemovedCount));

    LOG((PHONESP_TRACE, "ReenumDevices - exit"));
}

/******************************************************************************
    FreePhone:
        
    This function frees all of a phones data structures

    Arguments:
        PPHONESP_PHONE_INFO pPhone

    Returns VOID:

    Comments:

******************************************************************************/
VOID
FreePhone (
            PPHONESP_PHONE_INFO pPhone
          )
{
    DWORD dwButtonCnt;

    LOG((PHONESP_TRACE, "FreePhone - enter"));

    // Check whether the phone handle is still valid
    if ( IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ))
    {
        LOG((PHONESP_ERROR, "FreePhone - phone handle invalid"));
        return;
    }

    if ( !pPhone->bAllocated )
    {
        LOG((PHONESP_ERROR, "FreePhone - phone not allocated"));
        return;
    }
    
    for (dwButtonCnt = 0; 
        dwButtonCnt < pPhone->dwNumButtons; dwButtonCnt++)
    {
        if (pPhone->pButtonInfo[dwButtonCnt].szButtonText != NULL)
        {
            MemFree(pPhone->pButtonInfo[dwButtonCnt].szButtonText);
            pPhone->pButtonInfo[dwButtonCnt].szButtonText = NULL;
        }
    }

    if (pPhone->pButtonInfo != NULL)
    {
        MemFree(pPhone->pButtonInfo);
        pPhone->pButtonInfo = NULL;
    }

    if (pPhone->wszPhoneInfo != NULL)
    {
        MemFree((LPVOID) pPhone->wszPhoneInfo);
        pPhone->wszPhoneInfo = NULL;
    }

    if (pPhone->wszPhoneName != NULL)
    {
        MemFree((LPVOID) pPhone->wszPhoneName);
        pPhone->wszPhoneName = NULL;
    }  
    
    pPhone->bAllocated = FALSE;

    LOG((PHONESP_TRACE, "FreePhone - exit"));
}

/******************************************************************************
    UpdatePhoneFeatures:
        
    This function reads feature values from the phone.

    Arguments:
        PPHONESP_PHONE_INFO pPhone

    Returns VOID:

    Comments:

******************************************************************************/
VOID UpdatePhoneFeatures(
                         PPHONESP_PHONE_INFO pPhone
                        )
{
   LOG((PHONESP_TRACE, "UpdatePhoneFeatures - enter"));

   if( pPhone->pHidDevice->Caps.NumberFeatureValueCaps || 
       pPhone->pHidDevice->Caps.NumberFeatureButtonCaps  )
    {    
        USAGE UsagePage;
        USAGE Usage;

        if (GetFeature(pPhone->pHidDevice))
        {   
            DWORD       dwDataCnt;
            PHID_DATA   pHidData;            
            
            pHidData = pPhone->pHidDevice->FeatureData;
            for ( dwDataCnt = 0, pHidData = pPhone->pHidDevice->FeatureData; 
                  dwDataCnt < pPhone->pHidDevice->FeatureDataLength; 
                  dwDataCnt++, pHidData++ )
            {
                UsagePage = pHidData->UsagePage;

                if (UsagePage == HID_USAGE_PAGE_TELEPHONY)
                {
                    if(pHidData->IsButtonData)
                    {
                        for ( Usage = (USAGE)pHidData->ButtonData.UsageMin; 
                              Usage <= (USAGE)pHidData->ButtonData.UsageMax; 
                              Usage++ )
                        {
                            DWORD i;

                            for (i = 0; 
                                 i < pHidData->ButtonData.MaxUsageLength;
                                 i++)
                            {
                                if(Usage == pHidData->ButtonData.Usages[i])
                                {
                                    LOG((PHONESP_TRACE,"Button for Usage "
                                                       "0x%04x ON",Usage));

                                    InitUsage(pPhone, Usage, TRUE); 
                                    break;
                                }
                            }

                            if ( i == pHidData->ButtonData.MaxUsageLength)
                            {
                                InitUsage(pPhone, Usage, FALSE);
                            }
                        }
                    }
                    else
                    {
                        InitUsage(pPhone, pHidData->ValueData.Usage,
                                  pHidData->ValueData.Value);
                    }
                }
            }
        }
        else
        {
            LOG((PHONESP_ERROR, "UpdatePhoneFeatures - GetFeature failed"));
        }
    }
    else
    {
        LOG((PHONESP_TRACE, "UpdatePhoneFeatures - NO FEATURE"));
    }

    LOG((PHONESP_TRACE, "UpdatePhoneFeatures - exit"));
}

/******************************************************************************
    CreatePhone:
        
    This function creates all of a phones data structures

    Arguments:
        PPHONESP_PHONE_INFO pPhone
        PHID_DEVICE pHidDevice

    Returns LONG:

    Comments:

******************************************************************************/
LONG
CreatePhone (
            PPHONESP_PHONE_INFO pPhone,
            PHID_DEVICE pHidDevice,
            DWORD dwPhoneCnt
            )
{
    LONG                lResult;
    LPWSTR              wszPhoneName, wszPhoneInfo;
    WCHAR               wszPhoneID[MAX_CHARS];
    PHIDP_BUTTON_CAPS   pButtonCaps;
    PHIDP_VALUE_CAPS    pValueCaps;
    HRESULT hr;

    LOG((PHONESP_TRACE, "CreatePhone - enter"));

    // Check whether the phone handle is still valid
    if ( IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ))
    {
        LOG((PHONESP_ERROR, "CreatePhone - phone handle invalid"));
        return PHONEERR_INVALPHONEHANDLE;
    }

    if ( IsBadReadPtr(pHidDevice,sizeof(PHID_DEVICE) ))
    {
        LOG((PHONESP_ERROR, "CreatePhone - hid device pointer invalid"));
        return PHONEERR_OPERATIONFAILED;
    }

    if ( pPhone->bAllocated )
    {
        LOG((PHONESP_ERROR, "CreatePhone - phone already allocated"));
        return PHONEERR_OPERATIONFAILED;
    }
    
    // Load Phone Info From String Table
    wszPhoneInfo = PHONESP_LoadString( 
                                       IDS_PHONE_INFO,
                                       &lResult
                                      );
    
    if ( lResult != ERROR_SUCCESS )
    {
        if ( lResult == ERROR_OUTOFMEMORY )
        {
            LOG((PHONESP_ERROR, "CreatePhone - "
                    "PHONESP_LoadString out of memory"));

            return PHONEERR_NOMEM;
        }
        else
        {
            LOG((PHONESP_ERROR, "CreatePhone - "
                    "PHONESP_LoadString failed %d", lResult));

            return lResult;
        }
    }
 
    // Load Phone Name From String Table
    wszPhoneName = PHONESP_LoadString( 
                                      IDS_PHONE_NAME, 
                                      &lResult 
                                     );
    
    if ( lResult != ERROR_SUCCESS )
    {
        MemFree((LPVOID)wszPhoneInfo);
        
        if ( lResult == ERROR_OUTOFMEMORY )
        {
            LOG((PHONESP_ERROR, "CreatePhone - "
                    "PHONESP_LoadString out of memory"));

            return PHONEERR_NOMEM;
        }
        else
        {
            LOG((PHONESP_ERROR, "CreatePhone - "
                    "PHONESP_LoadString failed %d", lResult));

            return lResult;
        }
    }
    
    //
    // Associate phone with the hid and wave devices
    // 

    pPhone->bAllocated = TRUE;
    pPhone->pHidDevice = pHidDevice;

    // Discover Render Wave ID 

    hr = DiscoverAssociatedWaveId(pHidDevice->dwDevInst, 
                                  TRUE, 
                                  &pPhone->dwRenderWaveId);

    
    if (hr != S_OK)
    {
        pPhone->bRender = FALSE;
        LOG((PHONESP_ERROR, "CreatePhone - DiscoverAssociatedWaveID:"
                       " Render Failed for Phone %d: %0x", dwPhoneCnt, hr));
    }
    else
    {
        pPhone->bRender = TRUE;
        LOG((PHONESP_TRACE,"CreatePhone - DiscoverAssociatedWaveId for Render: %d", 
                        pPhone->dwRenderWaveId));
    }

    // Discover Capture Wave ID
    hr = DiscoverAssociatedWaveId(pHidDevice->dwDevInst, 
                                  FALSE, 
                                  &pPhone->dwCaptureWaveId);
    
    if (hr != S_OK)
    {
        pPhone->bCapture = FALSE;
        LOG((PHONESP_ERROR, "CreatePhone - DiscoverAssociatedWaveID:"
                      " Capture Failed for Phone %d: %0x", dwPhoneCnt, hr));
    }
    else
    {
        pPhone->bCapture = TRUE;
        LOG((PHONESP_TRACE,"CreatePhone - DiscoverAssociatedWaveId for Capture: %d", 
                        pPhone->dwCaptureWaveId));
    }

    pPhone->dwButtonModesMsgs = PHONESP_ALLBUTTONMODES;
    pPhone->dwButtonStateMsgs = PHONESP_ALLBUTTONSTATES;

    //
    // Extract Usages and Initialize the phone structure 
    //

    // Get the usages from the HID structure 

    // Parse input button caps structure
    LOG((PHONESP_TRACE, "CreatePhone - INPUT BUTTON CAPS"));
    pButtonCaps = pHidDevice->InputButtonCaps;

    
    GetButtonUsages(
                    pPhone,
                    pButtonCaps, 
                    pHidDevice->Caps.NumberInputButtonCaps,
                    INPUT_REPORT
                   );


    // Parse output button caps structure
    LOG((PHONESP_TRACE, "CreatePhone - OUTPUT BUTTON CAPS" ));
    pButtonCaps = pHidDevice->OutputButtonCaps;
    GetButtonUsages(
                    pPhone,
                    pButtonCaps, 
                    pHidDevice->Caps.NumberOutputButtonCaps,
                    OUTPUT_REPORT
                   );


    // Parse feature button caps structure
    LOG((PHONESP_TRACE, "CreatePhone - FEATURE BUTTON CAPS" ));
    pButtonCaps = pHidDevice->FeatureButtonCaps;
    GetButtonUsages(
                    pPhone,
                    pButtonCaps, 
                    pHidDevice->Caps.NumberFeatureButtonCaps,
                    FEATURE_REPORT
                   );



    // Parse input value caps structure
    LOG((PHONESP_TRACE, "CreatePhone - INPUT VALUE CAPS"));
    pValueCaps = pHidDevice->InputValueCaps;
    GetValueUsages(
                    pPhone,
                    pValueCaps, 
                    pHidDevice->Caps.NumberInputValueCaps,
                    INPUT_REPORT
                   );

    // Parse output value caps structure
    LOG((PHONESP_TRACE, "CreatePhone - OUTPUT VALUE CAPS" ));
    pValueCaps = pHidDevice->OutputValueCaps;

    GetValueUsages(
                    pPhone,
                    pValueCaps, 
                    pHidDevice->Caps.NumberOutputValueCaps,
                    OUTPUT_REPORT
                   );
    
    // Parse feature value caps structure
    LOG((PHONESP_TRACE, "CreatePhone - FEATURE VALUE CAPS" ));

    pValueCaps = pHidDevice->FeatureValueCaps;
    GetValueUsages(
                    pPhone,
                    pValueCaps, 
                    pHidDevice->Caps.NumberFeatureValueCaps,
                    FEATURE_REPORT
                   );

    //
    // The Phone should have a handset with input and feature 
    // reports supported. If it does not the phone will not be supported
    // by this TSP. If this part of the code is uncommented, then the nokia
    // box will be the unsupported phone device since it does not contain
    // a feature report for the handset
    //
   if ( !( pPhone->dwHandset & INPUT_REPORT ) )
                                                                
    {
        LOG((PHONESP_ERROR,"CreatePhone - This Phone not Supported")); 

        MemFree((LPVOID) wszPhoneInfo);
        MemFree((LPVOID) wszPhoneName);

        FreePhone(pPhone);

        return PHONEERR_OPERATIONFAILED;
    }   

    //
    // Store the Phone ID as a string Value
    //

    wsprintf(wszPhoneID, TEXT(": %d"), dwPhoneCnt);

    //
    // Allocate space for storing the Phone Info
    //
    pPhone->wszPhoneInfo = (LPWSTR) MemAlloc ( (lstrlen(wszPhoneInfo) +
                                               lstrlen(wszPhoneID) + 1 ) *
                                               sizeof(WCHAR) );

    if( NULL == pPhone->wszPhoneInfo)
    {
        LOG((PHONESP_ERROR,"CreatePhone - unable to allocate wszPhoneInfo")); 

        MemFree((LPVOID) wszPhoneInfo);
        MemFree((LPVOID) wszPhoneName);

        FreePhone(pPhone);

        return PHONEERR_NOMEM;
    }

    //
    // Copy the Phone Info in the phone structure and append it with
    // the Phone ID
    //
    lstrcpy(pPhone->wszPhoneInfo,wszPhoneInfo);
    lstrcat(pPhone->wszPhoneInfo,wszPhoneID);


    pPhone->wszPhoneName = (LPWSTR)MemAlloc ( ( lstrlen(wszPhoneName) +
                                                lstrlen(wszPhoneID) + 
                                                1 ) * sizeof(WCHAR) );

    if( NULL == pPhone->wszPhoneName)
    {
        LOG((PHONESP_ERROR,"CreatePhone - unable to allocate wszPhoneName")); 
        MemFree((LPVOID) wszPhoneInfo);
        MemFree((LPVOID) wszPhoneName);

        FreePhone(pPhone);

        return PHONEERR_NOMEM;
    }

    //
    // Copy the Phone Name in the phone structure and append it with
    // the Phone ID
    //
    lstrcpy(pPhone->wszPhoneName,wszPhoneName);
    lstrcat(pPhone->wszPhoneName,wszPhoneID);

    //
    // Create Buttons for the ones discovered by tracking the usages
    //
    if ( CreateButtonsAndAssignID(pPhone) != ERROR_SUCCESS)
    {
        LOG((PHONESP_ERROR,"CreatePhone - CreateButtonsAndAssignID failed")); 
        MemFree((LPVOID) wszPhoneInfo);
        MemFree((LPVOID) wszPhoneName);

        FreePhone(pPhone);

        return PHONEERR_NOMEM;
    }
    
    //
    // Get initial values for phone features (such as hookswitch state)
    //
    UpdatePhoneFeatures( pPhone );

    //
    // Close the file handle
    //
    if ( !CloseHidFile(pPhone->pHidDevice) )
    {
        LOG((PHONESP_ERROR, "CreatePhone - CloseHidFile failed"));
    }

    MemFree((LPVOID) wszPhoneInfo);
    MemFree((LPVOID) wszPhoneName);  

    LOG((PHONESP_TRACE, "CreatePhone - exit"));

    return ERROR_SUCCESS;
}

/******************************************************************************
    NotifWndProc:
        
    This function handles the pnp events for which this tsp has registered for

    Arguments:
        HWND hwnd
        UINT uMsg
        WPARAM wParam
        LPARAM lParam

    Returns LRESULT:

    Comments:

******************************************************************************/

LRESULT CALLBACK NotifWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{ 
    switch (uMsg) 
    { 
        case WM_DEVICECHANGE: 
            switch(wParam)
            {
            case DBT_DEVICEARRIVAL:
                LOG((PHONESP_TRACE, "NotifWndProc - DBT_DEVICEARRIVAL"));
                ReenumDevices();
                break;

            case DBT_DEVICEREMOVECOMPLETE:
                LOG((PHONESP_TRACE, "NotifWndProc - DBT_DEVICEREMOVECOMPLETE"));
                ReenumDevices();
                break;
            }
            break;

        case WM_CREATE:
            LOG((PHONESP_TRACE, "NotifWndProc - WM_CREATE"));
            break;

        case WM_DESTROY: 
            LOG((PHONESP_TRACE, "NotifWndProc - WM_DESTROY"));
            break;

        default: 
            return DefWindowProc(hwnd, uMsg, wParam, lParam); 
    } 

    return 0; 
} 
/********************************NotifWndProc - end***************************/


/******************************************************************************
    AsyncEventQueueServiceThread:
    
    This routine services, in a serialized manner, the requests present in the 
    Async Queue. If no requests are currently outstanding, it waits for an 
    Event which happens when the queue has currently no requests and a new 
    request comes in.
    
    Arguments:
        LPVOID pParams: Any Information that needs to be passed to the thread
                        when startup. Currently no information is being passed.
                        
    Return Parameter: Void
    
******************************************************************************/
VOID 
AsyncEventQueueServiceThread(
                             LPVOID  pParams
                            )
{
    WNDCLASS wc;
    ATOM atom;

    LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - enter"));

    //
    // Create a window to receive PNP device notifications
    //

    ZeroMemory(&wc, sizeof(wc));
    wc.lpfnWndProc = NotifWndProc;
    wc.lpszClassName = TEXT("HidPhoneNotifClass");

    if (!(atom = RegisterClass(&wc)))
    {
        LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - can't register window class %08x", GetLastError()));
    }
    else
    {    
        ghWndNotify = CreateWindow((LPCTSTR)atom, TEXT(""), 0,
                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, NULL, NULL);

        if (ghWndNotify == NULL)
        {
            LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - can't create notification window"));
        }
        else
        {
            DEV_BROADCAST_DEVICEINTERFACE NotificationFilter;

            LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - created notification window"));

            //
            // Register to receive PNP device notifications
            //        

            ZeroMemory( &NotificationFilter, sizeof(NotificationFilter) );
            NotificationFilter.dbcc_size = 
                sizeof(DEV_BROADCAST_DEVICEINTERFACE);
            NotificationFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
            NotificationFilter.dbcc_classguid = GUID_CLASS_INPUT;

            if ((ghDevNotify = RegisterDeviceNotification( ghWndNotify, 
                &NotificationFilter,
                DEVICE_NOTIFY_WINDOW_HANDLE
                )) == NULL)
            {
                LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - can't register for input device notification"));
            }
            else
            {
                LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - registered for PNP device notifications"));
            }
        }
    }

    while (!gbProviderShutdown)
    {
        // Waiting for a new request to arrive since the queue is currently 
        // empty

        DWORD dwResult;
        MSG msg;
        
        dwResult = MsgWaitForMultipleObjectsEx(
            1,                                      // wait for one event
            &gAsyncQueue.hAsyncEventsPendingEvent,  // array of events to wait for
            INFINITE,                               // wait forever
            QS_ALLINPUT,                            // get all window messages
            0                                       // return when an event is signaled
            );

        if ( ( dwResult == WAIT_OBJECT_0 ) || ( dwResult == WAIT_OBJECT_0 + 1 ) )
        {
            LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - thread is signaled"));

            while (1)
            {
                PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo;
                PPHONESP_PHONE_INFO     pPhone;

                EnterCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);

                // No requests in the queue present - wait for a new request
                if (gAsyncQueue.dwNumUsedQueueEntries == 0)
                {
                    ResetEvent (gAsyncQueue.hAsyncEventsPendingEvent);
                    LeaveCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);
                    break;
                }

                pAsyncReqInfo = *gAsyncQueue.pAsyncRequestQueueOut;

                // Increment the next-request-to-be-serviced counter 
                gAsyncQueue.pAsyncRequestQueueOut++;


                //
                // The queue is maintained a circular queue. If the bottom of the 
                // circular queue is reached, go back to the top and process the 
                // requests if any.
                //
                if (gAsyncQueue.pAsyncRequestQueueOut == 
                        (gAsyncQueue.pAsyncRequestQueue +
                            gAsyncQueue.dwNumTotalQueueEntries))
                {
                    gAsyncQueue.pAsyncRequestQueueOut = 
                                                    gAsyncQueue.pAsyncRequestQueue;
                }

                // Decrement the number of outstanding requests present in queue
                gAsyncQueue.dwNumUsedQueueEntries--;

                LeaveCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);


                // If async function for the request exists - call the function
                               
                if (pAsyncReqInfo->pfnAsyncProc)
                {
                    (*(pAsyncReqInfo->pfnAsyncProc))(
                                                     pAsyncReqInfo->pFuncInfo
                                                    );
                }

                pPhone = (PPHONESP_PHONE_INFO) pAsyncReqInfo->pFuncInfo->dwParam1;
            
                // Decrement the counter of pending requests for this phone
            
                if ( pPhone )
                {
                    EnterCriticalSection(&pPhone->csThisPhone);

                    pPhone->dwNumPendingReqInQueue--;

                    // if there are no requests pending for this phone
                    // Set no requests pending event on this phone
                    if (pPhone->dwNumPendingReqInQueue == 0 )
                    {
                        SetEvent(pPhone->hNoPendingReqInQueueEvent);
                    }

                    LeaveCriticalSection(&pPhone->csThisPhone);
                }

                // The memory allocated for the processed request is freed.
                MemFree(pAsyncReqInfo->pFuncInfo);
                MemFree(pAsyncReqInfo);
            }

            //
            // We have processed all commands and unblocked everyone
            // who is waiting for us. Now check for window messages.
            //

            while ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - shutdown"));

    //
    // Unregister for PNP device notifications and destroy window
    //

    if ( NULL != ghDevNotify )
    {
        if (!UnregisterDeviceNotification(ghDevNotify))
        {
            LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - "
                    "can't unregister device notification %d", GetLastError()));

        }

        ghDevNotify = NULL;
    }

    if ( NULL != ghWndNotify )
    {
        if (!DestroyWindow(ghWndNotify))
        {
            LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - "
                    "can't destroy notification window %d", GetLastError()));
        }

        ghWndNotify = NULL;
    }

    if (!UnregisterClass((LPCTSTR)atom, GetModuleHandle(NULL)))
    {
        LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - "
                "can't unregister window class %d", GetLastError()));
    }   

    LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - exit"));

    // Since the Provider Shutdown is called .. we terminate the thread
    ExitThread (0);
}
/*************************AsyncEventQueueServiceThread - end******************/


/******************************************************************************
    ReadThread:

    Arguments:
        
        PVOID lpParameter - The parameter passed to the function when this 
                            function is called. In this case - the parameter is
                            the pointer to the phone structure (PMYPHONE) that 
                            has just been opened

    Returns VOID
******************************************************************************/ 
VOID
ReadThread(
           PVOID lpParameter
          )
{
    PPHONESP_PHONE_INFO         pPhone;
    PHID_DEVICE                 pHidDevice; 
    DWORD                       dwInputDataCnt;
    PHID_DATA                   pHidData;
    DWORD                       dwResult;
    HANDLE                      hWaitHandles[2];
    DWORD                       dwWaitResult;

    LOG((PHONESP_TRACE, "ReadThread - enter"));

    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) lpParameter;
    
    // Check whether the phone handle is still valid
    if ( IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ))
    {
        LOG((PHONESP_ERROR, "ReadThread - phone handle invalid"));

        LeaveCriticalSection(&csAllPhones);        
        ExitThread(0);
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);
   
    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LOG((PHONESP_ERROR, "ReadThread - phone not allocated"));

        LeaveCriticalSection(&pPhone->csThisPhone);        
        ExitThread(0);
    }

    // verify whether the phone is open
    if( !pPhone->bPhoneOpen )
    {
        LOG((PHONESP_ERROR, "ReadThread - Phone not open"));

        LeaveCriticalSection(&pPhone->csThisPhone);
        ExitThread(0);
    }
    
    pHidDevice = pPhone->pHidDevice;

    // Check whether hid device is present
    if ( pHidDevice == NULL )
    {
        LOG((PHONESP_ERROR, "ReadThread - invalid hid device pointer"));

        LeaveCriticalSection(&pPhone->csThisPhone);
        ExitThread(0);
    }    

    hWaitHandles[0] = pPhone->hCloseEvent;
    hWaitHandles[1] = pPhone->hInputReportEvent;

    while (TRUE)
    {
        if (! ReadInputReport(pPhone))
        {   
            LOG((PHONESP_ERROR, "ReadThread - ReadInputReport failed - exiting"));

            LeaveCriticalSection(&pPhone->csThisPhone);            
            ExitThread(0);
        }

        LeaveCriticalSection(&pPhone->csThisPhone);

        //
        // Wait for the read to complete, or the phone to be closed
        //

        dwWaitResult = WaitForMultipleObjects( 2, hWaitHandles, FALSE, INFINITE );

        LOG((PHONESP_TRACE, "ReadThread - activated"));

        if ( dwWaitResult == WAIT_OBJECT_0 )
        {
            LOG((PHONESP_TRACE, "ReadThread - CloseEvent fired - exiting"));

            //
            // Cancel the pending IO operation
            //

            CancelIo( pHidDevice->HidDevice );
            ExitThread(0);
        }

        EnterCriticalSection(&pPhone->csThisPhone);

        // This function is implemented in report.c 
        // The report received from the device is unmarshalled here
        if ( UnpackReport(
                          pHidDevice->InputReportBuffer,
                          pHidDevice->Caps.InputReportByteLength,
                          HidP_Input,
                          pHidDevice->InputData,
                          pHidDevice->InputDataLength,
                          pHidDevice->Ppd
                         ) )
        {
 
            for (dwInputDataCnt = 0, pHidData = pHidDevice->InputData;
                 dwInputDataCnt < pHidDevice->InputDataLength; 
                 pHidData++, dwInputDataCnt++)
            {
    
                // Since pHidData->IsDataSet in all the input HidData structures 
                // initialized to false before reading the input report .. if the
                // pHidData->IsDataSet is set for the HidData structure, that 
                // HidData structure contains the new input report
                // Also we are interested in only telephony usage page usages only
        
                if ( pHidData->IsDataSet &&
                     ( (pHidData->UsagePage == HID_USAGE_PAGE_TELEPHONY) ||
                       (pHidData->UsagePage == HID_USAGE_PAGE_CONSUMER) ) )
                {
                    PPHONESP_FUNC_INFO pFuncInfo;
                    PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo;
    
                    if( ! (pFuncInfo = (PPHONESP_FUNC_INFO) 
                                        MemAlloc(sizeof (PHONESP_FUNC_INFO)) ) )
                    {
                        LOG((PHONESP_ERROR, "ReadThread - "
                                "MemAlloc pFuncInfo - out of memory"));

                        continue;     
                    }

                    ZeroMemory(pFuncInfo, sizeof(PHONESP_FUNC_INFO));

                    pFuncInfo->dwParam1 = (ULONG_PTR) pPhone;

                    if ( ! ( pAsyncReqInfo = (PPHONESP_ASYNC_REQ_INFO) 
                                        MemAlloc(sizeof(PHONESP_ASYNC_REQ_INFO))))
                    {
                        LOG((PHONESP_ERROR, "ReadThread - "
                                "MemAlloc pAsyncReqInfo - out of memory"));

                        MemFree(pFuncInfo);

                        continue;
                    }    
    
                    pAsyncReqInfo->pfnAsyncProc = ShowData; 
                    pAsyncReqInfo->pFuncInfo = pFuncInfo;

                    // if the usage is associated with a Button
                    if( pHidData->IsButtonData )
                    {
                        PUSAGE Usages;

                        // fill the structure to be put on the async queue
                        if ( ! ( Usages = (PUSAGE) 
                                           MemAlloc(sizeof(USAGE) * 
                                           pHidData->ButtonData.MaxUsageLength) ) )
                        {
                            LOG((PHONESP_ERROR, "ReadIOCompletionRoutine - "
                                    "MemAlloc Usages - out of memory"));

                            MemFree(pFuncInfo);
                            MemFree(pAsyncReqInfo);

                            continue;                                    
                        }

                        pFuncInfo->dwNumParams = 7;
                        pFuncInfo->dwParam2    = PHONESP_BUTTON;  
                        pFuncInfo->dwParam3    = pHidData->UsagePage;
                        pFuncInfo->dwParam4    = pHidData->ButtonData.UsageMin;
                        pFuncInfo->dwParam5    = pHidData->ButtonData.UsageMax;
                        pFuncInfo->dwParam6    = pHidData->ButtonData.MaxUsageLength;

                        CopyMemory(Usages,
                                   pHidData->ButtonData.Usages,
                                   sizeof(USAGE) * 
                                   pHidData->ButtonData.MaxUsageLength
                                  ); 

                        pFuncInfo->dwParam7    = (ULONG_PTR) Usages;
                    }   
                    else
                    {   
                        // the usage is associated with a Value
                        pFuncInfo->dwNumParams = 5;
                        pFuncInfo->dwParam2 = PHONESP_VALUE;
                        pFuncInfo->dwParam3 = pHidData->UsagePage;
                        pFuncInfo->dwParam4 = pHidData->ValueData.Usage;
                        pFuncInfo->dwParam5 = pHidData->ValueData.Value;
                    }

                    if ( AsyncRequestQueueIn(pAsyncReqInfo) )
                    {  
                        // Reset the event for number of pending requests in 
                        // queue for this phone and increment the counter
                        if (pPhone->dwNumPendingReqInQueue == 0)
                        {
                            ResetEvent(pPhone->hNoPendingReqInQueueEvent);
                        }
                        pPhone->dwNumPendingReqInQueue++;
                    }
                    else
                    {
                        if ( pFuncInfo->dwParam2 == PHONESP_BUTTON )
                        {
                            MemFree((LPVOID)pFuncInfo->dwParam7);
                        }

                        MemFree(pFuncInfo);
                        MemFree(pAsyncReqInfo);

                        LOG((PHONESP_ERROR,"ReadIOCompletionRoutine - "
                                "AsyncRequestQueueIn failed"));
                        
                        continue;
                    }

                    //ShowData(pFuncInfo);            
                }
            }
        } 
    }
}
/******************** ReadThread - end****************************/


/******************************************************************************
    ReadInputReport

    This function reads the phone device asynchronously. When an input report
    is received from the device, the Event specified in the lpOverlapped  
    structure which is part of the PHONESP_PHONE_INFO structure is set. This 
    event results in ReadIOcompletionRoutine being called

    Arguments:
        PPHONESP_PHONE_INFO pPhone - the pointer to the phone to be read

    Return BOOL: 
    TRUE if the function succeeds 
    FALSE if the function fails

******************************************************************************/
BOOL
ReadInputReport (
                 PPHONESP_PHONE_INFO   pPhone
                )
{
    DWORD       i, dwResult;
    PHID_DEVICE pHidDevice;
    PHID_DATA   pData;
    BOOL        bResult;

    LOG((PHONESP_TRACE, "ReadInputReport - enter"));

    pHidDevice = pPhone->pHidDevice;    

    // Check whether hid device is present
    if ( pHidDevice == NULL )
    {
        LOG((PHONESP_ERROR, "ReadInputReport - invalid hid device pointer"));
        return FALSE;
    }

    pData = pHidDevice->InputData;
 
    //
    // Set all the input hid data structures to False so we can identify the 
    // new reports from the device
    for ( i = 0; i < pHidDevice->InputDataLength; i++, pData++)
    {
        pData->IsDataSet = FALSE;
    }
    
    bResult = ReadFile(
                       pHidDevice->HidDevice,
                       pHidDevice->InputReportBuffer,
                       pHidDevice->Caps.InputReportByteLength,
                       NULL,
                       pPhone->lpOverlapped
                      );
     
    if ( !bResult )
    {
        // if the Readfile succeeds then GetLastError returns ERROR_IO_PENDING since 
        // this is an asynchronous read

        dwResult = GetLastError();

        if (  dwResult && ( dwResult != ERROR_IO_PENDING ) )
        {
            LOG((PHONESP_ERROR, "ReadInputReport - ReadFile Failed, error: %d", 
                                 GetLastError()));

            if (dwResult == ERROR_DEVICE_NOT_CONNECTED)
            {
                //
                // The hid device has most likely gone away. Lets close the file
                // handle so we can get proper pnp notifications.
                //
                if ( CloseHidFile(pHidDevice) )
                {
                    LOG((PHONESP_TRACE, "ReadInputReport - "
                            "closed hid device file handle"));
                }
                else
                {
                    LOG((PHONESP_ERROR, "ReadInputReport - "
                            "CloseHidFile failed" ));
                }
            }
            return FALSE;
        }
    }

    LOG((PHONESP_TRACE, "ReadInputReport - exit"));
    return TRUE;
}
/************************ReadInputReport - end *******************************/

// --------------------------- TAPI_lineXxx funcs -----------------------------
//


// The TSPI_lineNegotiateTSPIVersion function returns the highest SPI version the  
// service provider can operate under for this device, given the range of possible 
// SPI versions.


LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    LOG((PHONESP_TRACE, "TSPI_lineNegotiateTSPIVersion - enter"));
    
   
    if (dwHighVersion >= HIGH_VERSION)
    {
        // If the high version of the app is greater than the high version 
        // supported by this TSP and the low version of the app is less than
        // the High version of the TSP - The TSP high version will be negotiated
        // else the tsp cannot support this app
        if (dwLowVersion <= HIGH_VERSION)
        {
            *lpdwTSPIVersion = (DWORD) HIGH_VERSION;
        }
        else
        {   // the app is too new for us
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    else
    {
        if(dwHighVersion >= LOW_VERSION)
        {
            *lpdwTSPIVersion = dwHighVersion;
        }
        else
        {
            //we are too new for the app
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    LOG((PHONESP_TRACE, "TSPI_lineNegotiateTSPIVersion - exit"));
    return 0;
}


//
// -------------------------- TSPI_phoneXxx funcs -----------------------------
//

/******************************************************************************
    TSPI_phoneClose:
    
    This function closes the specified open phone device after completing all 
    the asynchronous operations pending on the device
        
    Arguments:
        HDRVPHONE hdPhone - the handle to the phone to be closed

    Returns LONG:
    Zero if the function succeeds
    Error code if an error occurs - Possible values are
    PHONEERR_INVALPHONEHANDLE

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneClose(
    HDRVPHONE   hdPhone
    )
{
    PPHONESP_PHONE_INFO pPhone; 
    LOG((PHONESP_TRACE, "TSPI_phoneClose - enter"));

    // We need a critical section in order to ensure that the critical section
    // of the phone is obtained while the phone handle is still valid.
    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // Check whether the phone handle is valid
    if ( IsBadReadPtr( pPhone,sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_phoneClose - Phone handle invalid"));
        return PHONEERR_INVALPHONEHANDLE;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        
        LOG((PHONESP_ERROR, "TSPI_phoneClose - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // Check if the phone to be closed is still open 
    if( pPhone->bPhoneOpen )
    {
        // Inorder to ensure that there no other activities happen on the phone
                
        pPhone->bPhoneOpen = FALSE;

        //
        // wait for the read thread to exit
        //
        SetEvent(pPhone->hCloseEvent);

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_TRACE,"TSPI_phoneClose - waiting for read thread"));

        WaitForSingleObject(pPhone->hReadThread, INFINITE);

        LOG((PHONESP_TRACE,"TSPI_phoneClose - read thread complete"));

        EnterCriticalSection(&pPhone->csThisPhone);
        
        //
        // if there are still pending requests on the phone in the queue, wait
        // till all the pending asynchronous operations are completed 
        //
        if (pPhone->dwNumPendingReqInQueue)
        {
            LOG((PHONESP_TRACE,"TSPI_phoneClose - requests pending"));

            LeaveCriticalSection(&pPhone->csThisPhone);

            WaitForSingleObject(&pPhone->hNoPendingReqInQueueEvent, INFINITE);

            EnterCriticalSection(&pPhone->csThisPhone);

            LOG((PHONESP_TRACE,"TSPI_phoneClose - requests completed"));
        }        

        CloseHandle(pPhone->hReadThread);
        CloseHandle(pPhone->hCloseEvent);
        CloseHandle(pPhone->hInputReportEvent);

        MemFree(pPhone->lpOverlapped);
        pPhone->htPhone = NULL;

        //
        // Close HID file handle
        //
        if ( !CloseHidFile(pPhone->pHidDevice) )
        {
            LOG((PHONESP_WARN, "TSPI_phoneClose - CloseHidFile failed"));
        }

        if (pPhone->bRemovePending)
        {
            //
            // This phone is gone, lets get rid of it
            //

            pPhone->bRemovePending = FALSE;

            FreePhone(pPhone);

            LOG((PHONESP_TRACE, "TSPI_phoneClose - phone remove complete [dwDeviceID %d] ", pPhone->dwDeviceID));
        }

        LeaveCriticalSection(&pPhone->csThisPhone);
    }
    else
    {
        LOG((PHONESP_ERROR,"TSPI_phoneClose - Phone Not Open"));

        LeaveCriticalSection(&pPhone->csThisPhone);
        
        return PHONEERR_INVALPHONEHANDLE;
    }

    LOG((PHONESP_TRACE, "TSPI_phoneClose - exit"));

    return 0;
}


/******************************************************************************
    The TSPI_phoneDevSpecific:
    
    This function is used as a general extension mechanism to enable a Telephony
    API implementation to provide features not described in the other operations.
    The meanings of these extensions are device specific.


    Comments: To be implemented in Tier 2
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneDevSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneDevSpecific - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneDevSpecific - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}

/***************************TSPI_phoneDevSpecific -End ***********************/


/******************************************************************************
    TSPI_phoneGetButtonInfo:
    This function returns information about a specified button.

    Arguments:
        IN HDRVPHONE hdPhone  - The handle to the phone to be queried.           
        IN DWORD dwButtonLampID - A button on the phone device. 
        IN OUT LPPHONEBUTTONINFO lpButtonInfo  - A pointer to memory into which
             the TSP writes a variably sized structure of type PHONEBUTTONINFO. 
             This data structure describes the mode and function, and provides
             additional descriptive text corresponding to the button. 

  Return Values
    Returns zero if the function succeeds, or 
    An error number if an error occurs. Possible return values are as follows: 
    PHONEERR_INVALPHONEHANDLE, _INVALBUTTONLAMPID,_INVALPHONESTATE 

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetButtonInfo(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{

    PPHONESP_PHONE_INFO pPhone;
    PPHONESP_BUTTONINFO pButtonInfo;
    DWORD dwNeededSize;

    LOG((PHONESP_TRACE, "TSPI_phoneGetButtonInfo - enter"));
    
    if (lpButtonInfo->dwTotalSize < sizeof(PHONEBUTTONINFO))
    {
        LOG((PHONESP_ERROR, "TSPI_phoneGetButtonInfo - structure too small"));
        return PHONEERR_STRUCTURETOOSMALL;
    }

    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // Check if pPhone points to a valid memory location - if not handle is 
    // invalid 
    if ( IsBadReadPtr( pPhone,sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_phoneGetButtonInfo - Phone handle invalid"));
        return PHONEERR_INVALPHONEHANDLE;
    }


    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_GetButtonInfo - phone not allocated"));
        return PHONEERR_NODEVICE;
    }
    
    // verify whether the phone is open
    if ( ! (pPhone->bPhoneOpen) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR,"TSPI_GetButtonInfo - Phone not open"));
        return PHONEERR_INVALPHONESTATE;
    }
     

    // Get the Button structure for the queried button id if it exists
    // else pButtonInfo  will be NULL
    if (  ! ( pButtonInfo  = GetButtonFromID(pPhone, dwButtonLampID) ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_TRACE, "TSPI_phoneGetButtonInfo - Invalid Button ID"));
        return PHONEERR_INVALBUTTONLAMPID;
    }
    
    // The needed size to store all the available information on the button
    lpButtonInfo->dwNeededSize = sizeof(PHONEBUTTONINFO) +                
                                 (lstrlen(pButtonInfo->szButtonText) + 1) *   
                                  sizeof (WCHAR); // size of the Button Text

    // Whether the button is a Feature Button, Keypad, etc
    lpButtonInfo->dwButtonMode = pButtonInfo->dwButtonMode;

    // The function associated with this button - will be _NONE for keypad
    // buttons and _FLASH, _HOLD, etc for feature buttons
    lpButtonInfo->dwButtonFunction = pButtonInfo->dwButtonFunction;

    // The current button state
    lpButtonInfo->dwButtonState = pButtonInfo->dwButtonState;
    
    if (lpButtonInfo->dwTotalSize >= lpButtonInfo->dwNeededSize)
    {
        lpButtonInfo->dwUsedSize = lpButtonInfo->dwNeededSize;

        // ButtonTextSize is the memory required to copy the string stored in
        // szButtonText field of the PHONESP_BUTTON_INFO structure for this 
        // Button   
        lpButtonInfo->dwButtonTextSize = (lstrlen(pButtonInfo->szButtonText)+1)
                                                  * sizeof (WCHAR);

        // Offset of the button text from the PHONEBUTTONINFO structure
        lpButtonInfo->dwButtonTextOffset = sizeof(PHONEBUTTONINFO);

        // Copy the button text at the lpButtonInfo->dwButtonTextOffset offset
        // from the ButtonText stored in the PHONESP_BUTTON_INFO structure for
        // this Button.   
        CopyMemory(
                   (LPBYTE)lpButtonInfo + lpButtonInfo->dwButtonTextOffset,
                    pButtonInfo->szButtonText,
                    lpButtonInfo->dwButtonTextSize
                   );
    }
    else
    {
        // no space to the store the button text info
        lpButtonInfo->dwUsedSize = sizeof(PHONEBUTTONINFO);
        lpButtonInfo->dwButtonTextSize = 0;
        lpButtonInfo->dwButtonTextOffset = 0;
    }

    LeaveCriticalSection(&pPhone->csThisPhone);
    
    LOG((PHONESP_TRACE, "TSPI_phoneGetButtonInfo - exit"));
    return 0;
}
/********************TSPI_phoneGetButtonInfo - end****************************/


/******************************************************************************
    TSPI_phoneGetDevCaps:
    
    This function queries a specified phone device to determine its telephony 
    capabilities.

    Arguments:
        DWORD dwDeviceID    - The phone device to be queried. 
        DWORD dwTSPIVersion - The negotiated TSPI version number. This value is
                              negotiated for this device through the 
                              TSPI_phoneNegotiateTSPIVersion function. 
        DWORD dwExtVersion  - The negotiated extension version number. This 
                              value is negotiated for this device through the 
                              TSPI_phoneNegotiateExtVersion function. 
        PHONECAPS lpPhoneCaps - A pointer to memory into which the TSP writes a 
                                variably sized structure of type PHONECAPS. 
                                Upon successful completion of the request, this
                                structure is filled with phone device capability
                                information. 

    Returns LONG:
    Zero if success 
    PHONEERR_ constants if an error occurs. Possible return values are:
    _BADDEVICEID,

    
******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetDevCaps(
    DWORD       dwDeviceID,
    DWORD       dwTSPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    PPHONESP_PHONE_INFO pPhone;
    PPHONESP_BUTTONINFO pButtonInfo;

    LOG((PHONESP_TRACE, "TSPI_phoneGetDevCaps - enter"));

    if (lpPhoneCaps->dwTotalSize < sizeof(PHONECAPS))
    {
        LOG((PHONESP_ERROR, "TSPI_phoneGetDevCaps - structure too small"));
        return PHONEERR_STRUCTURETOOSMALL;
    }
    
    EnterCriticalSection(&csAllPhones);

    // Given the deviceID retrieve the structure that contains the information
    // for this device
    pPhone = GetPhoneFromID(dwDeviceID, NULL); 

    if ( ! pPhone)
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_phoneGetDevCaps - Bad Device ID"));
        return PHONEERR_BADDEVICEID;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);
       
    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetDevCaps - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    //
    // The size in bytes for this data structure that is needed to hold all the 
    // returned information. The returned includes the providerInfo string, 
    // PhoneInfo string and Phone Name string and Buttons Info - Button Function
    // and Button Mode.
    //
    lpPhoneCaps->dwNeededSize = sizeof (PHONECAPS) +
                                sizeof (WCHAR) *    
                                ( (lstrlenW(gszProviderInfo) + 1) +
                                  (lstrlenW(pPhone->wszPhoneInfo) + 1)    +
                                  (lstrlenW(pPhone->wszPhoneName) + 1)  ) +
                                (sizeof(DWORD) * pPhone->dwNumButtons * 2);

    lpPhoneCaps->dwUsedSize = sizeof(PHONECAPS);

    // lpPhoneCaps->dwPermanentPhoneID = ;

    //The string format to be used with this phone device
    lpPhoneCaps->dwStringFormat = STRINGFORMAT_UNICODE;

    // The state changes for this phone device for which the application can be
    // notified in a PHONE_STATE message. The Phone Info structure for each 
    // maintains this information
    lpPhoneCaps->dwPhoneStates = pPhone->dwPhoneStates;

    // Specifies the phone's hookswitch devices. Again the Phone Info structure 
    // maintains this information
    lpPhoneCaps->dwHookSwitchDevs = pPhone->dwHookSwitchDevs;
        
    // Specifies that we are a generic phone device. This means that in TAPI 3.1
    // we will be able to function on a variety of addresses.
    lpPhoneCaps->dwPhoneFeatures = PHONEFEATURE_GENERICPHONE;
                                  
    if(pPhone->dwHandset)
    {   // Specifies the phone's hookswitch mode capabilities of the handset.
        // The member is only meaningful if the hookswitch device is listed in
        // dwHookSwitchDevs. 
        lpPhoneCaps->dwHandsetHookSwitchModes = PHONEHOOKSWITCHMODE_ONHOOK | PHONEHOOKSWITCHMODE_MICSPEAKER;

        lpPhoneCaps->dwPhoneFeatures |= PHONEFEATURE_GETHOOKSWITCHHANDSET;
    }

    if(pPhone->dwSpeaker)
    {
        // Specifies the phone's hookswitch mode capabilities of the speaker.
        // The member is only meaningful if the hookswitch device is listed in
        // dwHookSwitchDevs.
        lpPhoneCaps->dwSpeakerHookSwitchModes = PHONEHOOKSWITCHMODE_ONHOOK | PHONEHOOKSWITCHMODE_MICSPEAKER;

        lpPhoneCaps->dwPhoneFeatures |= PHONEFEATURE_GETHOOKSWITCHSPEAKER |
                                        PHONEFEATURE_SETHOOKSWITCHSPEAKER;
    }

    // The ring capabilities of the phone device. The phone is able to ring
    // with dwNumRingModes different ring patterns, identified as 1, 2, through
    // dwNumRingModes minus one. If the value of this member is 0, applications
    // have no control over the ring mode of the phone. If the value of this 
    // member is greater than 0, it indicates the number of ring modes in 
    // addition to silence that are supported by the TSP. In this case, only one 
    // mode is supported.  
    if(pPhone->dwRing)
    {
        lpPhoneCaps->dwNumRingModes = 1;

        lpPhoneCaps->dwPhoneFeatures |= PHONEFEATURE_GETRING |
                                        PHONEFEATURE_SETRING;
    }

    if(pPhone->dwNumButtons)
    {
        // Specifies the number of button/lamps on the phone device that are 
        // detectable in TAPI. Button/lamps are identified by their identifier.     
        lpPhoneCaps->dwNumButtonLamps = pPhone->dwNumButtons;

        lpPhoneCaps->dwPhoneFeatures |= PHONEFEATURE_GETBUTTONINFO;
    }
    
    if(lpPhoneCaps->dwTotalSize >= lpPhoneCaps->dwNeededSize)
    {
        DWORD dwAlignedSize;
        DWORD dwRealSize; 


        ///////////////////
        // Provider Info
        ///////////////////

        // Size of the Provider Info string in bytes
        lpPhoneCaps->dwProviderInfoSize = ( lstrlen(gszProviderInfo) + 1) * 
                                            sizeof (WCHAR);
        dwRealSize = lpPhoneCaps->dwProviderInfoSize;

        // Offset of the Provider Info String from the PHONECAPS structure
        lpPhoneCaps->dwProviderInfoOffset = lpPhoneCaps->dwUsedSize;
    
        
        // Align it across DWORD boundary
        if (dwRealSize % sizeof(DWORD))
        {
            dwAlignedSize = dwRealSize - (dwRealSize % sizeof(DWORD)) + 
                            sizeof(DWORD);
        }
        else
        {
            dwAlignedSize = dwRealSize;
        }

        // Copy the provider Info string at the offset specified by 
        // lpPhoneCaps->dwProviderInfoOffset 
        CopyMemory(
                   ((LPBYTE)lpPhoneCaps) + lpPhoneCaps->dwProviderInfoOffset,
                   gszProviderInfo,
                   lpPhoneCaps->dwProviderInfoSize
                  );

        lpPhoneCaps->dwNeededSize += dwAlignedSize - dwRealSize;

        ///////////////////
        // Phone Info
        ///////////////////

        // Size of the Phone Info string in bytes
        lpPhoneCaps->dwPhoneInfoSize = (lstrlen(pPhone->wszPhoneInfo) + 1) * 
                                        sizeof(WCHAR);
        dwRealSize = lpPhoneCaps->dwPhoneInfoSize;

        // Offset of the Phone Info String from the PHONECAPS structure
        lpPhoneCaps->dwPhoneInfoOffset = lpPhoneCaps->dwProviderInfoOffset + 
                                         dwAlignedSize;

        // Align it across DWORD boundary
        if (dwRealSize % sizeof(DWORD))
        {
            dwAlignedSize = dwRealSize - (dwRealSize % sizeof(DWORD)) + 
                                          sizeof(DWORD);
        }
        else
        {
            dwAlignedSize = dwRealSize;
        }

        // Copy the Phone Info string at the offset specified by 
        // lpPhoneCaps->dwPhoneInfoOffset 
        CopyMemory(
                   ((LPBYTE)lpPhoneCaps) + lpPhoneCaps->dwPhoneInfoOffset,
                   pPhone->wszPhoneInfo,
                   lpPhoneCaps->dwPhoneInfoSize
                  );

        lpPhoneCaps->dwNeededSize += dwAlignedSize - dwRealSize;

        ///////////////////
        // Phone Name
        ///////////////////
    
        // Size of the Phone Name string in bytes
        lpPhoneCaps->dwPhoneNameSize = (lstrlen(pPhone->wszPhoneName)+ 1) * 
                                         sizeof (WCHAR);

        dwRealSize = lpPhoneCaps->dwPhoneNameSize;

        // Offset of the Phone Name String from the PHONECAPS structure
        lpPhoneCaps->dwPhoneNameOffset = lpPhoneCaps->dwPhoneInfoOffset +
                                         dwAlignedSize;

        // Align it across DWORD boundary
        if (dwRealSize % sizeof(DWORD))
        {
            dwAlignedSize = dwRealSize - (dwRealSize % sizeof(DWORD)) +
                                         sizeof(DWORD);
        }
        else
        {
            dwAlignedSize = dwRealSize;
        }

        // Copy the phone name string at the offset specified by 
        // lpPhoneCaps->dwPhoneNameOffset 
        CopyMemory(
                   ((LPBYTE)lpPhoneCaps) + lpPhoneCaps->dwPhoneNameOffset,
                   pPhone->wszPhoneName,
                   lpPhoneCaps->dwPhoneNameSize
                  );

        lpPhoneCaps->dwNeededSize += dwAlignedSize - dwRealSize;

        ////////////////////////////
        // Button Modes & Functions
        ////////////////////////////

        // If the phone has buttons, dial, feature, etc
        if(pPhone->dwNumButtons)
        {    
            DWORD i;

            // The size in bytes of the variably sized field containing the 
            // button modes of the phone's buttons, and the offset in bytes 
            // from the beginning of this data structure. This member uses the 
            // values specified by the PHONEBUTTONMODE_ constants. The 
            // array is indexed by button/lamp identifier. 
            lpPhoneCaps->dwButtonModesSize = (pPhone->dwNumButtons) * 
                                                sizeof (DWORD);
            lpPhoneCaps->dwButtonModesOffset = lpPhoneCaps->dwPhoneNameOffset +
                                               dwAlignedSize;
            
            //
            // The size in bytes of the variably sized field containing the 
            // button modes of the phone's buttons, and the offset in bytes 
            // from the beginning of this data structure. This member uses the 
            // values specified by the PHONEBUTTONFUNCTION_ constants. The 
            // array is indexed by button/lamp identifier. 
            //
            lpPhoneCaps->dwButtonFunctionsSize = pPhone->dwNumButtons * 
                                                    sizeof (DWORD);
            lpPhoneCaps->dwButtonFunctionsOffset  = 
                                            lpPhoneCaps->dwButtonModesOffset +
                                            lpPhoneCaps->dwButtonModesSize;

            pButtonInfo = pPhone->pButtonInfo;

            //
            // For each button on the phone copy the Button Function and Mode 
            // at the appropriate position
            //
            for ( i = 0; i < pPhone->dwNumButtons; i++, pButtonInfo++)
            {
                
                CopyMemory(
                           ((LPBYTE)lpPhoneCaps) + 
                           lpPhoneCaps->dwButtonModesOffset + i*sizeof(DWORD),
                            &pButtonInfo->dwButtonMode,
                           sizeof (DWORD)
                          );

                CopyMemory(
                           ((LPBYTE)lpPhoneCaps) + 
                           lpPhoneCaps->dwButtonFunctionsOffset + i*sizeof(DWORD),
                           &pButtonInfo->dwButtonFunction,
                           sizeof (DWORD)
                          );
            }

        }
        LeaveCriticalSection(&pPhone->csThisPhone);

        lpPhoneCaps->dwNumGetData = 0;
        lpPhoneCaps->dwNumSetData = 0;
        lpPhoneCaps->dwDevSpecificSize = 0;

        lpPhoneCaps->dwUsedSize = lpPhoneCaps->dwNeededSize;
    }
    else
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetDevCaps - "
                            "Not enough memory for Phonecaps [needed %d] [total %d]",
                            lpPhoneCaps->dwNeededSize, lpPhoneCaps->dwTotalSize));
    }

    LOG((PHONESP_TRACE, "TSPI_phoneGetDevCaps - exit"));
    return 0;
}
/**************************TSPI_phoneGetDevCaps - end*************************/




/******************************************************************************
    TSPI_phoneGetDisplay:
    
    This function returns the current contents of the specified phone display.

    Comments: To be implemented in Tier 2
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneGetDisplay(
    HDRVPHONE   hdPhone,
    LPVARSTRING lpDisplay
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneGetDisplay - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneGetDisplay - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}
/***********************TSPI_phoneGetDisplay - end****************************/


/******************************************************************************
    TSPI_phoneGetExtensionID:
    
    This function retrieves the extension identifier that the TSP supports for
    the indicated phone device.

    Comments: To be implemented in Tier 2
******************************************************************************/

    
LONG
TSPIAPI
TSPI_phoneGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneGetExtensionID - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneGetExtensionID - exit"));
    return 0;
}

/**********************TSPI_phoneGetExtensionID - end*************************/


/******************************************************************************
    TSPI_phoneGetHookSwitch:
    
    This function returns the current hookswitch mode of the specified open 
    phone device.

    Arguments:
        HDRVPHONE hdPhone - The handle to the phone
        LPDWORD lpdwHookSwitchDevs - The TSP writes the mode of the phone's 
                    hookswitch devices. This parameter uses the 
                    PHONEHOOKSWITCHDEV_ constants. If a bit position is False,
                    the corresponding hookswitch device is onhook.

    Returns LONG:
    Zero is the function succeeded
    else PHONEERR_ constants for error conditions


*******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetHookSwitch(
    HDRVPHONE   hdPhone,
    LPDWORD     lpdwHookSwitchDevs
    )
{
    PPHONESP_PHONE_INFO pPhone;
    LOG((PHONESP_TRACE, "TSPI_phoneGetHookSwitch - enter"));
    
    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // check whether the phone handle is valid
    if ( IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_phoneGetHookSwitch - Invalid Phone Handle"));
        return PHONEERR_INVALPHONEHANDLE;
    }


    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetHookSwitch - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // Check whether the phone is open
    if (! (pPhone->bPhoneOpen) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetHookSwitch - Phone Not Open"));
        return PHONEERR_INVALPHONESTATE;
    }

       *lpdwHookSwitchDevs = 0;

    // We are interested in only handset and speaker hookswitch - headset is not
    // supported
    if (pPhone->dwHandset)
    {
        if ( (pPhone->dwHandsetHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK) )
        {
            *lpdwHookSwitchDevs = PHONEHOOKSWITCHDEV_HANDSET;
        }
    }

    if (pPhone->dwSpeaker)
    {
        if( pPhone->dwSpeakerHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK) 
        {
            *lpdwHookSwitchDevs |= PHONEHOOKSWITCHDEV_SPEAKER;
        } 
    }
    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_phoneGetHookSwitch - exit"));
    return 0;
}
/************************TSPI_phoneGetHookSwitch - end************************/


/******************************************************************************
    TSPI_phoneGetID:

    This function returns a device identifier for the given device class 
    associated with the specified phone device.

    Arguments:
        HDRVPHONE   hdPhone    - The handle to the phone to be queried.
        LPVARSTRING lpDeviceID - Pointer to the data structure of type VARSTRING 
                                 where the device idnetifier is returned.
        LPCWSTR lpszDeviceClass - Specifies the device class of the device whose
                                  identiifer is requested
        HANDLE hTargetProcess  - The process handle of the application on behalf 
                                 of which this function is being invoked.
    
    Returns LONG:
    Zero if the function succeeds
    PHONEERR_ constants if an error occurs.

    Comments: Currently supporting wave/in and wave/out only. 

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetID(
    HDRVPHONE   hdPhone,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
    PPHONESP_PHONE_INFO pPhone; 
    HRESULT hr;
    
    LOG((PHONESP_TRACE, "TSPI_phoneGetID - enter"));

    if (lpDeviceID->dwTotalSize < sizeof(VARSTRING))
    {
        LOG((PHONESP_ERROR, "TSPI_phoneGetID - structure too small"));
        return PHONEERR_STRUCTURETOOSMALL;
    }

    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // Verify whether the phone handle is valid
    if ( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_phoneGetID - Invalid Phone Handle"));
        return PHONEERR_INVALPHONEHANDLE;
    } 
    
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetID - phone not allocated"));
        return PHONEERR_NODEVICE;
    }
        
    // verify whether the phone is open
    if ( ! pPhone->bPhoneOpen )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR,"TSPI_phoneGetID - Phone not open"));
        return PHONEERR_INVALPHONESTATE;
    }
        
    lpDeviceID->dwNeededSize = sizeof(VARSTRING) + sizeof (DWORD);

    lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;

    if ( lpDeviceID->dwTotalSize >= lpDeviceID->dwNeededSize )
    {                   
        // whether the requested ID is capture class
        if ( ! lstrcmpi(lpszDeviceClass, _T("wave/in") ) )
        {
            LOG((PHONESP_TRACE,"TSPI_phoneGetID - 'wave/in'"));

            if(pPhone->bCapture == TRUE)
            {
                // Discover Capture Wave ID 

                hr = DiscoverAssociatedWaveId(pPhone->pHidDevice->dwDevInst, 
                                              FALSE, 
                                              &pPhone->dwCaptureWaveId);

                if (hr != S_OK)
                {
                    LOG((PHONESP_ERROR, "TSPI_phoneGetID - "
                        "DiscoverAssociatedWaveID failed %0x", hr));
                }

                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                lpDeviceID->dwStringSize   = sizeof(DWORD);

                CopyMemory (
                       (LPBYTE) lpDeviceID + lpDeviceID->dwStringOffset,
                        &pPhone->dwCaptureWaveId,
                        sizeof(DWORD)
                       );
            }
            else
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                LOG((PHONESP_ERROR,"TSPI_phoneGetID - No Capture Device"));
                return PHONEERR_NODEVICE;
            }
       
        }
        else
        { 
            // the wave ID is render class
            if ( ! lstrcmpi(lpszDeviceClass, _T("wave/out") ) )
            {
                LOG((PHONESP_TRACE,"TSPI_phoneGetID - 'wave/out'"));

                if(pPhone->bRender == TRUE)
                {
                    // Discover Render Wave ID 

                    hr = DiscoverAssociatedWaveId(pPhone->pHidDevice->dwDevInst, 
                                                  TRUE, 
                                                  &pPhone->dwRenderWaveId);

                    if (hr != S_OK)
                    {
                        LOG((PHONESP_ERROR, "TSPI_phoneGetID - "
                            "DiscoverAssociatedWaveID failed %0x", hr));
                    }

                    lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                    lpDeviceID->dwStringSize   = sizeof(DWORD);

                    CopyMemory (
                            (LPBYTE) lpDeviceID + lpDeviceID->dwStringOffset,
                            &pPhone->dwRenderWaveId,
                            sizeof(DWORD)
                           );
                }
                else
                {
                    LeaveCriticalSection(&pPhone->csThisPhone);
                    LOG((PHONESP_ERROR,"TSPI_phoneGetID - No Render Device"));
                    return PHONEERR_NODEVICE;
                }
                    
            }
            else
            {   // the other classes are not supported or the phone does not have the 
                // specified device
                LeaveCriticalSection(&pPhone->csThisPhone);
                LOG((PHONESP_TRACE,"TSPI_phoneGetID - unsupported device class '%ws'", lpszDeviceClass));

                return PHONEERR_INVALDEVICECLASS;
            }     
        }
        lpDeviceID->dwUsedSize = lpDeviceID->dwNeededSize;
            
    }
    else
    {
        LOG((PHONESP_ERROR,"TSPI_phoneGetID : not enough total size"));
        lpDeviceID->dwUsedSize = sizeof(VARSTRING);
    }
 
    LeaveCriticalSection(&pPhone->csThisPhone);
  
  
    LOG((PHONESP_TRACE, "TSPI_phoneGetID - exit"));
    return 0;
}
/************************TSPI_phoneGetID  - end*******************************/


/******************************************************************************
    TSPI_phoneGetLamp:
    
    This function returns the current lamp mode of the specified lamp.

    Comments: To be implememted in Tier 2

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetLamp(
    HDRVPHONE   hdPhone,
    DWORD       dwButtonLampID,
    LPDWORD     lpdwLampMode
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneGetLamp - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneGetLamp - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}

/********************TSPI_phoneGetLamp - end**********************************/


/******************************************************************************
    TSPI_phoneGetRing:
    
    This function enables an application to query the specified open phone 
    device as to its current ring mode.

    Arguments:
        HDRVPHONE hdPhone - The handle to the phone whose ring mode is to be 
                            queried. 
        LPDWORD lpdwRingMode - The ringing pattern with which the phone is 
                         ringing. Zero indicates that the phone is not ringing.
        LPDWORD lpdwVolume - The volume level with which the phone is ringing. 
                        This is a number in the range from 0x00000000 (silence)
                        through 0x0000FFFF (maximum volume). 

    Returns LONG:
        Zero on Success
        PHONEERR_ constants on error

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetRing(
    HDRVPHONE   hdPhone,
    LPDWORD     lpdwRingMode,
    LPDWORD     lpdwVolume
    )
{
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_phoneGetRing - enter"));
    
    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];
    // if the phone handle is valid
    if ( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_phoneGetRing - Invalid Phone Handle"));
        return PHONEERR_INVALPHONEHANDLE;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetRing - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // whether the phone is open
    if ( ! pPhone->bPhoneOpen )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetRing - Phone Not Open"));
        return PHONEERR_INVALPHONESTATE;    
    }

    // if the phone has a ringer attached to it
    if( ! pPhone->dwRing)
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetRing - "
                            "Phone does not have a ringer"));
        return PHONEERR_RESOURCEUNAVAIL;
    }
    
    *lpdwRingMode = pPhone->dwRingMode;
    
    // if ringmode is 0, it indicates that the phone is not ringing
    if(pPhone->dwRingMode) 
    {
         // The ring volume is maximum if the phone is ringing 
         *lpdwVolume = 0x0000FFFF;
    }
    else
    {
        // If the phone is not ringing the ring volume is 0
        *lpdwVolume = 0;
    }
    LeaveCriticalSection(&pPhone->csThisPhone); 
    
    LOG((PHONESP_TRACE, "TSPI_phoneGetRing - exit"));
    return 0;
}

/******************************TSPI_phoneGetRing - end************************/



/******************************************************************************
    TSPI_phoneGetStatus:

    This function queries the specified open phone device for its overall 
    status.

    Arguments:
    
        hdPhone         - The handle to the phone to be queried. 
        lpPhoneStatus   - A pointer to a variably sized data structure of type 
                PHONESTATUS, into which the TSP writes information about the 
                phone's status. Prior to calling TSPI_phoneGetStatus, the 
                application sets the dwTotalSize member of this structure to 
                indicate the amount of memory available to TAPI for returning
                information. 

    Returns LONG:
     
    Zero if the function succeeds, or 
    An error number if an error occurs. Possible return values are as follows: 
    PHONEERR_INVALPHONEHANDLE.
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneGetStatus(
    HDRVPHONE       hdPhone,
    LPPHONESTATUS   lpPhoneStatus
    )
{
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_phoneGetStatus - enter"));

    if (lpPhoneStatus->dwTotalSize < sizeof(PHONESTATUS))
    {
        LOG((PHONESP_ERROR, "TSPI_phoneGetStatus - structure too small"));
        return PHONEERR_STRUCTURETOOSMALL;
    }
    
    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];
    
    // check whether the phone handle is valid
    if ( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) ) 
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_TRACE,"TSPI_phoneGetStatus - INVALID PHONE HANDLE"));
        return PHONEERR_INVALPHONEHANDLE;
    }
  
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetStatus - phone not allocated"));
        return PHONEERR_NODEVICE;
    }
    
    if( ! pPhone->bPhoneOpen)
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_TRACE,"TSPI_phoneGetStatus - PHONE not Open"));
        return PHONEERR_INVALPHONEHANDLE;
    }

    lpPhoneStatus->dwNeededSize = sizeof(PHONESTATUS);

    if(lpPhoneStatus->dwTotalSize >= lpPhoneStatus->dwNeededSize)
    {
        lpPhoneStatus->dwUsedSize = sizeof (PHONESTATUS);
        lpPhoneStatus->dwStatusFlags = PHONESTATUSFLAGS_CONNECTED;

        // If the phone has a ringer 
        if(pPhone->dwRing)
        {
            lpPhoneStatus->dwRingMode = pPhone->dwRingMode;
            // If the Ring Mode is 0, the phone is not ringing
            if (pPhone->dwRingMode)
            {
                // by default the phone volume is 0xffff if it is ringing
                lpPhoneStatus->dwRingVolume = 0xffff;
            }
            else
            {
                // the phone volume is 0 if not ringing
                lpPhoneStatus->dwRingVolume = 0;
            }
        }
            
        lpPhoneStatus->dwHandsetHookSwitchMode = pPhone->dwHandsetHookSwitchMode;
        lpPhoneStatus->dwHandsetVolume = 0;
        lpPhoneStatus->dwHandsetGain = 0;
        
        if (pPhone->dwSpeaker)
        {
            lpPhoneStatus->dwSpeakerHookSwitchMode = pPhone->dwSpeakerHookSwitchMode;
            lpPhoneStatus->dwSpeakerVolume = 0;
            lpPhoneStatus->dwSpeakerGain = 0;
        }
    }

    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_phoneGetStatus - exit"));
    return 0;
}
/****************************TSPI_phoneGetStatus - end************************/

/******************************************************************************
    TSPI_phoneNegotiateTSPIVersion:
    
    This function returns the highest SPI version the TSP can operate under for 
    this device, given the range of possible SPI versions.

    Arguments:

    Return LONG:

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_phoneNegotiateTSPIVersion - enter"));
    
    if (dwHighVersion >= HIGH_VERSION)
    {
        if (dwLowVersion <= HIGH_VERSION)
        {
            *lpdwTSPIVersion = (DWORD) HIGH_VERSION;
        }
        else
        {   // the app is too new for us
            return PHONEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    else
    {
        if(dwHighVersion >= LOW_VERSION)
        {
            *lpdwTSPIVersion = dwHighVersion;
        }
        else
        {
            //we are too new for the app
            return PHONEERR_INCOMPATIBLEAPIVERSION;
        }
    }
   
    EnterCriticalSection(&csAllPhones);
    
    // Given the deviceID retrieve the structure that contains the information
    // for this device
    pPhone = GetPhoneFromID(dwDeviceID, NULL); 

    if ( ! pPhone)
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_phoneNegotiateTSPIVersion - Bad Device ID"));
        return PHONEERR_BADDEVICEID;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneNegotiateTSPIVersion - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // Store the version negotiated for this phone 
    pPhone->dwVersion = *lpdwTSPIVersion;

    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_phoneNegotiateTSPIVersion - exit"));
    return 0;
}
/**********************TSPI_phoneNegotiateTSPIVersion - end*******************/


/******************************************************************************
    TSPI_phoneOpen:
    
    This function opens the phone device whose device identifier is given, 
    returning the TSP's opaque handle for the device and retaining TAPI's 
    opaque handle for the device for use in subsequent calls to the PHONEEVENT
    procedure.

    Arguments:

    Returns:
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneOpen(
    DWORD       dwDeviceID,
    HTAPIPHONE  htPhone,
    LPHDRVPHONE lphdPhone,
    DWORD       dwTSPIVersion,
    PHONEEVENT  lpfnEventProc
    )
{
    LPPHONEBUTTONINFO lpButtonInfo;
    DWORD dwPhoneID;
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_phoneOpen - enter"));
       
    EnterCriticalSection(&csAllPhones);
    
    // if the device id is not valid return error condition
    if ( ! ( pPhone = GetPhoneFromID(dwDeviceID, &dwPhoneID) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Invalid Phone Handle"));
        return PHONEERR_BADDEVICEID;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneOpen - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // if the phone is already open then return error condition
    if (pPhone->bPhoneOpen)
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Phone is open"));
        return PHONEERR_INUSE;
    }

    // Create an event that signals the receipt of an input report from
    // the phone device
    if ( ! ( pPhone->hInputReportEvent = 
                                CreateEvent ((LPSECURITY_ATTRIBUTES) NULL,
                                               FALSE,   // manual reset
                                              FALSE,  // non-signaled
                                              NULL    // unnamed
                                             ) ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Create Event: hInputReportEvent"
                           " Failed: %d", GetLastError()));
        return PHONEERR_NOMEM;
    }

    // Create an event that we will signal when we close the phone to
    // allow the read thread to exit
    if ( ! ( pPhone->hCloseEvent = 
                                CreateEvent ((LPSECURITY_ATTRIBUTES) NULL,
                                               FALSE,   // manual reset
                                              FALSE,  // non-signaled
                                              NULL    // unnamed
                                             ) ) )
    {
        CloseHandle(pPhone->hInputReportEvent);

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Create Event: hWaitCompletionEvent"
                           " Failed: %d", GetLastError()));
        return PHONEERR_NOMEM;
    }

    //
    // The overlapped structure contains the event to be set when an input 
    // report is received. The event to be set is the hInputReportEvent 
    // which is part of the PHONESP_PHONE_INFO structure. This overlapped
    // structure is passed to the ReadFile function call. 
    //
    if( ! ( pPhone->lpOverlapped = (LPOVERLAPPED) 
                                               MemAlloc (sizeof(OVERLAPPED)) ))
    {
        CloseHandle(pPhone->hCloseEvent);
        CloseHandle(pPhone->hInputReportEvent);

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Not enough memory for"
                            " lpOverlapped structure "));

        return PHONEERR_NOMEM;
    }
    pPhone->lpOverlapped->Offset = 0;
    pPhone->lpOverlapped->OffsetHigh = 0;
    pPhone->lpOverlapped->hEvent = pPhone->hInputReportEvent;

    //
    // Open the HID file handle
    //
    if ( ! OpenHidFile(pPhone->pHidDevice) )
    {
		MemFree(pPhone->lpOverlapped);
        CloseHandle(pPhone->hCloseEvent);
        CloseHandle(pPhone->hInputReportEvent);        

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - HidOpenFile failed"));

        return PHONEERR_OPERATIONFAILED;
    }
    

    // Increase the number of packets that the HID class driver ring buffer
    // holds for the device
    if ( ! HidD_SetNumInputBuffers(pPhone->pHidDevice->HidDevice, 
                                   20) )
    {
		CloseHidFile(pPhone->pHidDevice);
		MemFree(pPhone->lpOverlapped);
        CloseHandle(pPhone->hCloseEvent);
		CloseHandle(pPhone->hInputReportEvent);        

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - HidD_SetNumInputBuffers"
                           " Failed: %d", GetLastError()));

		return PHONEERR_OPERATIONFAILED;
    }

    //
    // Start a thread for waiting for input reports from the device. We
    // cannot use the thread pool for this because we will need to cancel
    // pending reads if we want to close the device.
    //
    if ( ! ( pPhone->hReadThread = 
                                CreateThread ((LPSECURITY_ATTRIBUTES) NULL,
                                              0,
                                              (LPTHREAD_START_ROUTINE) ReadThread,
                                              pPhone,
                                              0,
                                              NULL
                                             ) ) )
    {
		CloseHidFile(pPhone->pHidDevice);
		MemFree(pPhone->lpOverlapped);
        CloseHandle(pPhone->hCloseEvent);
		CloseHandle(pPhone->hInputReportEvent);        

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Create Thread: hReadThread"
                           " Failed: %d", GetLastError()));
        return PHONEERR_NOMEM;
    }

	//
	// Set phone open
	//
	pPhone->bPhoneOpen = TRUE;
    pPhone->htPhone = htPhone;
	pPhone->lpfnPhoneEventProc = lpfnEventProc;

    *lphdPhone = (HDRVPHONE)IntToPtr(dwPhoneID);

    //
    // Update values for phone features (such as hookswitch state)
    //
    UpdatePhoneFeatures( pPhone );

    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_phoneOpen - exit"));
    return 0;
}
/********************TSPI_phoneOpen - end*************************************/


/******************************************************************************
    TSPI_phoneSelectExtVersion:
    
    This function selects the indicated extension version for the indicated 
    phone device. Subsequent requests operate according to that extension 
    version.

    Comments: To be implemented in Tier 2

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSelectExtVersion(
    HDRVPHONE   hdPhone,
    DWORD       dwExtVersion
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneSelectExtVersion- enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneSelectExtVersion - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}
/****************************TSPI_phoneSelectExtVersion - end*****************/


/******************************************************************************

    TSPI_phoneSetDisplay:
    
    This function causes the specified string to be displayed on the specified 
    open phone device.

    Comments: To be implemented in Tier 2
******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSetDisplay(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwRow,
    DWORD           dwColumn,
    LPCWSTR         lpsDisplay,
    DWORD           dwSize
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneSetDisplay - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneSetDisplay - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}

/****************************TSPI_phoneSetDisplay - end***********************/

/******************************************************************************
    TSPI_phoneSetHookSwitch_AsyncProc:
    
    This function sets the hook state of the specified open phone's hookswitch 
    devices to the specified mode. Only the hookswitch state of the hookswitch 
    devices listed is affected. 

    Arguments:
        PMYFUNC_INFO pAsyncFuncInfo - The parameters passed to this function
                     Param1  - Pointer to the phone structure
                     Param2  - dwRequestID which is needed while calling
                               ASYNC_COMPLETION to inform TAPI about the result 
                               of the operation. This was passed by tapi when 
                               calling TSPI_phoneSetHookSwitch
                     Param3  - PHONEHOOKSWITCHDEV_ constant. Currently only
                               _SPEAKER is supported.
                     Param4  - The HookSwitchMode that has to be set for 
                               the HookSwitch. This again is supplied by TAPI
                               Currently only PHONEHOOKSWITCHMODE_ONHOOK and
                               _MICSPEAKER is supported. 
    RETURNS VOID:

******************************************************************************/

VOID
CALLBACK
TSPI_phoneSetHookSwitch_AsyncProc(
                                  PPHONESP_FUNC_INFO pAsyncFuncInfo 
                                 )
{
    PPHONESP_PHONE_INFO pPhone;
    LONG                lResult = 0;
    
    LOG((PHONESP_TRACE, "TSPI_phoneSetHookSwitch_AsyncProc - enter"));

    EnterCriticalSection(&csAllPhones);
    
    pPhone = (PPHONESP_PHONE_INFO)pAsyncFuncInfo->dwParam1;
    
    // if the phone is not open
    if( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO)) || 
        ( ! pPhone->bAllocated) ||
        ( ! pPhone->bPhoneOpen) ||
        ( ! pPhone->pHidDevice) )
    {
        // This case may never arise since phone close waits for all 
        // asynchornous opreations on the phone to complete before closing the 
        // phone
        LONG lResult = PHONEERR_INVALPHONEHANDLE; 

        LeaveCriticalSection(&csAllPhones);
        // Notify TAPISRV about the error condition
        (*(glpfnCompletionProc))(
                                (DRV_REQUESTID) pAsyncFuncInfo->dwParam2,
                                lResult
                                );
        LOG((PHONESP_ERROR, "TSPI_phoneSetHookSwitch_AsyncProc - Invalid Phone"
                            " Handle"));
    }
    else
    {
        EnterCriticalSection(&pPhone->csThisPhone);
        LeaveCriticalSection(&csAllPhones);
        
        switch (pAsyncFuncInfo->dwParam4)
        {
        case PHONEHOOKSWITCHMODE_ONHOOK:
            if ( pPhone->dwSpeakerHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK )
            {
                //Inform tapi about the change in state of the hookswitch
                SendPhoneEvent(
                        pPhone,
                        PHONE_STATE, 
                        PHONESTATE_SPEAKERHOOKSWITCH, 
                        PHONEHOOKSWITCHMODE_ONHOOK,
                        (DWORD) 0
                      );

                pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;
            }           
            lResult = ERROR_SUCCESS;
            break;

        case PHONEHOOKSWITCHMODE_MICSPEAKER:
            if ( pPhone->dwSpeakerHookSwitchMode != PHONEHOOKSWITCHMODE_MICSPEAKER )
            {
                //Inform tapi about the change in state of the hookswitch
                SendPhoneEvent(
                        pPhone,
                        PHONE_STATE, 
                        PHONESTATE_SPEAKERHOOKSWITCH, 
                        PHONEHOOKSWITCHMODE_MICSPEAKER,
                        (DWORD) 0
                      );

                pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_MICSPEAKER;
            }            
            lResult = ERROR_SUCCESS;
            break;

        default:
           lResult = PHONEERR_RESOURCEUNAVAIL;    
           break;
        }
         
        // Send the result of the operation to TAPI
        (*(glpfnCompletionProc))(
                                (DRV_REQUESTID) pAsyncFuncInfo->dwParam2,
                                lResult    // Result of the operation
                               );
       

        LeaveCriticalSection(&pPhone->csThisPhone);
    }

    LOG((PHONESP_TRACE, "TSPI_phoneSetHookSwitch_AsyncProc - exit"));
}

/******************************************************************************
    TSPI_phoneSetHookSwitch:

    This function sets the hook state of the specified open phone's hookswitch 
    devices to the specified mode. Only the hookswitch state of the hookswitch 
    devices listed is affected.

    Arguments:
        dwRequestID       - The identifier of the asynchronous request. 
        hdPhone           - The handle to the phone containing the hookswitch 
                            devices whose modes are to be set. 
        dwHookSwitchDevs  - The device(s) whose hookswitch mode is to be set. 
                         This parameter uses the following PHONEHOOKSWITCHDEV_ 
                         constants: PHONEHOOKSWITCHDEV_HANDSET, 
                         PHONEHOOKSWITCHDEV_SPEAKER, PHONEHOOKSWITCHDEV_HEADSET 
        dwHookSwitchMode  - The hookswitch mode to set. This parameter can have
                            only one of the following PHONEHOOKSWITCHMODE_ bits 
                            set: PHONEHOOKSWITCHMODE_ONHOOK, _MIC, _SPEAKER, 
                            _MICSPEAKER 

    Return LONG:
        Returns dwRequestID or an error number if an error occurs. 
        The lResult actual parameter of the corresponding ASYNC_COMPLETION is 
        zero if the function succeeds or it is an error number if an error 
        occurs. Possible return values are as follows: 
        PHONEERR_INVALPHONEHANDLE, PHONEERR_RESOURCEUNAVAIL, 
        PHONEERR_INVALHOOKSWITCHMODE, 

    Remarks
        A PHONE_STATE message is sent to the application after the hookswitch
        state has changed.

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSetHookSwitch(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwHookSwitchDevs,
    DWORD           dwHookSwitchMode
    )
{
    PPHONESP_PHONE_INFO pPhone;
    
    // 
    // Since only mode should be selected. We are making sure that only one 
    // mode is selected at a time.. 
    //
    BOOL ONHOOK = ~(dwHookSwitchMode ^ PHONEHOOKSWITCHMODE_ONHOOK),
         MIC     = ~(dwHookSwitchMode ^ PHONEHOOKSWITCHMODE_MIC), 
         SPEAKER = ~(dwHookSwitchMode ^ PHONEHOOKSWITCHMODE_SPEAKER), 
         MICSPEAKER = ~(dwHookSwitchMode ^ PHONEHOOKSWITCHMODE_MICSPEAKER);

    PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo;
    PPHONESP_FUNC_INFO pFuncInfo;

    LOG((PHONESP_TRACE, "TSPI_phoneSetHookSwitch - enter"));

    EnterCriticalSection(&csAllPhones);
    
    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // if the phone handle is valid and the phone is open
    if( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) || 
        (! pPhone->bPhoneOpen) )
    {
        LeaveCriticalSection(&csAllPhones);
        return PHONEERR_INVALPHONEHANDLE;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneSetHookSwitch - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    //
    // Only the speaker phone can be set, the other hookswitch types are error
    // conditions
    //
    if( ! (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_SPEAKER) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneSetHookSwitch - only speaker hookswitch is supported"));
        return PHONEERR_RESOURCEUNAVAIL;
    }
   
    LOG((PHONESP_TRACE, "PHONEHOOKSWITCHDEV_SPEAKER"));

    //
    // Make sure the phone supports a speakerphone
    //
    if ( ! ( pPhone->dwSpeaker ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "No speaker"));
        return PHONEERR_RESOURCEUNAVAIL;
    }
   
    // Inorder to confirm that one mode is set 
    if( ! ( ONHOOK | MIC | SPEAKER| MICSPEAKER ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "Mulitple modes set for the speaker"));
        return PHONEERR_INVALHOOKSWITCHMODE;                    
    }
    
    // Build the structure for queueing the request in the Async queue
    if( ! (pFuncInfo = (PPHONESP_FUNC_INFO) 
                       MemAlloc( sizeof (PHONESP_FUNC_INFO)) ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        return PHONEERR_NOMEM;
    }

    pFuncInfo->dwParam1    = (ULONG_PTR) pPhone; 

    pFuncInfo->dwParam2    = dwRequestID;

    pFuncInfo->dwParam3    = (ULONG_PTR) PHONEHOOKSWITCHDEV_SPEAKER;
    pFuncInfo->dwParam4    = (ULONG_PTR) dwHookSwitchMode;
    pFuncInfo->dwNumParams = 4;
    
    if ( ! ( pAsyncReqInfo = (PPHONESP_ASYNC_REQ_INFO) 
                              MemAlloc(sizeof (PHONESP_ASYNC_REQ_INFO)) ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        MemFree(pFuncInfo);
        return PHONEERR_NOMEM;
    }

    pAsyncReqInfo->pfnAsyncProc = TSPI_phoneSetHookSwitch_AsyncProc;
    pAsyncReqInfo->pFuncInfo = pFuncInfo;
    
    //
    // if Queue the request to perform asynchronously fails then we need to 
    // decrement the counter of number of pending requests on the phone
    //
    if( AsyncRequestQueueIn(pAsyncReqInfo) )
    {  
        // Reset the event for number of pending requests in the queue for this
        // phone and increment the counter
        if (pPhone->dwNumPendingReqInQueue == 0)
        {
          ResetEvent(pPhone->hNoPendingReqInQueueEvent);
        }
        pPhone->dwNumPendingReqInQueue++;
        LeaveCriticalSection(&pPhone->csThisPhone);
    }
    else
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        MemFree(pAsyncReqInfo);
        MemFree(pFuncInfo);
        // maybe need to free the request memory
        return PHONEERR_NOMEM;
    } 
    
 
    LOG((PHONESP_TRACE, "TSPI_phoneSetHookSwitch - exit"));
    return dwRequestID;
}
/*******************TSPI_phoneSetHookSwitch - end****************************/


/*****************************************************************************
    TSPI_phoneSetLamp:
    
    This function causes the specified lamp to be set on the specified open 
    phone device in the specified lamp mode.

    Comments: To be implemented in Tier 2
******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSetLamp(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwButtonLampID,
    DWORD           dwLampMode
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneSetLamp - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneSetLamp - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}
/****************************TSPI_phoneSetLamp - end**************************/

/******************************************************************************
    TSPI_phoneSetRing_AsyncProc:

    Arguments:

    Returns:

    Comments: To be implemented. currently there is no corresponding usage in 
               Hid hence no output report is sent. 
******************************************************************************/
VOID
CALLBACK
TSPI_phoneSetRing_AsyncProc(
                            PPHONESP_FUNC_INFO pAsyncFuncInfo 
                           )
{
    PPHONESP_PHONE_INFO pPhone;
    LONG                lResult = 0;

    LOG((PHONESP_TRACE,"TSPI_phoneSetRing_AsyncProc - enter"));

    EnterCriticalSection(&csAllPhones);
    
    pPhone = (PPHONESP_PHONE_INFO)pAsyncFuncInfo->dwParam1;
    
    // if the phone is not open
    if( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO)) || 
        ( ! pPhone->bPhoneOpen) ||
        ( ! pPhone->bAllocated) ||
        ( ! pPhone->pHidDevice) )
    {
        // This case may never arise since phone close waits for all 
        // asynchornous opreations on the phone to complete before closing the 
        // phone
        LONG lResult = PHONEERR_INVALPHONEHANDLE; 

        LeaveCriticalSection(&csAllPhones);
        // Notify TAPISRV about the error condition
        (*(glpfnCompletionProc))(
                                (DRV_REQUESTID) pAsyncFuncInfo->dwParam2,
                                lResult
                                );
        LOG((PHONESP_ERROR, "TSPI_phoneSetRing_AsyncProc - Invalid Phone"
                            " Handle"));
    }
    else
    {
        EnterCriticalSection(&pPhone->csThisPhone);
        LeaveCriticalSection(&csAllPhones);
    
        
        lResult = SendOutputReport(
                                   pPhone->pHidDevice, 
                                   HID_USAGE_TELEPHONY_RINGER,
                                   ((pAsyncFuncInfo->dwParam3 == 0) ? FALSE : TRUE)
                                  );

        if(lResult == ERROR_SUCCESS)
        {
            lResult = 0;

            pPhone->dwRingMode = (DWORD)pAsyncFuncInfo->dwParam3;

            //Inform tapi about the change in state of the hookswitch
            SendPhoneEvent(
                            pPhone,
                            PHONE_STATE, 
                            PHONESTATE_RINGMODE, 
                            (DWORD) pAsyncFuncInfo->dwParam3,
                            (DWORD) pAsyncFuncInfo->dwParam4
                      );
        }
        else
        {
            LOG((PHONESP_ERROR, "TSPI_phoneSetHookSwitch_AsyncProc - "
                                "SendOutputReport Failed"));
            lResult = PHONEERR_RESOURCEUNAVAIL;
        }
         
        // Send the result of the operation to TAPI
        (*(glpfnCompletionProc))(
                                (DRV_REQUESTID) pAsyncFuncInfo->dwParam2,
                                lResult    // Result of the operation
                               );
       

        LeaveCriticalSection(&pPhone->csThisPhone);
    }
        

    LOG((PHONESP_TRACE,"TSPI_phoneSetRing_AsyncProc - exit"));
}
/*******************TSPI_phoneSetRing_AsyncProc - end*************************/

/******************************************************************************
    TSPI_phoneSetRing:
    
    This function rings the specified open phone device using the specified 
    ring mode and volume.

    Arguments:
        DRV_REQUESTID dwRequestID - Identifier of the asynchronous request. 
        HDRVPHONE hdPhone - Handle to the phone to be rung. 
        DWORD dwRingMode - The ringing pattern with which to ring the phone.
                         This parameter must be within the range from zero 
                         through the value of the dwNumRingModes member in the
                         PHONECAPS structure. If dwNumRingModes is zero, the 
                         ring mode of the phone cannot be controlled; if 
                         dwNumRingModes is 1, a value of 0 for dwRingMode 
                         indicates that the phone should not be rung (silence),
                         and other values from 1 through dwNumRingModes are 
                         valid ring modes for the phone device. 
        DWORD dwVolume - The volume level with which the phone is to be rung.
                         This is a number in the range from 0x00000000 
                         (silence) through 0x0000FFFF (maximum volume). 

    Returns LONG:
    Zero if success
    PHONEERR_ constants if an error occurs
    
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneSetRing(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwRingMode,
    DWORD           dwVolume
    )
{
    PPHONESP_PHONE_INFO pPhone = (PPHONESP_PHONE_INFO)gpPhone[ (DWORD_PTR) hdPhone ];
    
    LOG((PHONESP_TRACE, "TSPI_phoneSetRing - enter"));
    
    EnterCriticalSection(&csAllPhones);
    
    // to confirm that the phone is open
    if( ! (pPhone && pPhone->htPhone) )
    {
        LeaveCriticalSection(&csAllPhones);
        return PHONEERR_INVALPHONEHANDLE;
    }
    
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneSetRing - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // The ringer can only be set if the phone has an output feature for this
    // usage
    if( ! (pPhone->dwRing & OUTPUT_REPORT) )
    {
        // The phone has a ringer but no output feature
        if(pPhone->dwRing)
        {
            LeaveCriticalSection(&pPhone->csThisPhone);
            return PHONEERR_OPERATIONUNAVAIL;
        }
        // The phone does not have a ringer
        else
        {
            LeaveCriticalSection(&pPhone->csThisPhone);
            return PHONEERR_RESOURCEUNAVAIL;
        }
    }
 
    if ( (dwRingMode == 0) || (dwRingMode == 1) )
    {
        // Check whether the volume is within range
        if(dwVolume <= 0x0000FFFF)
        {
            PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo;
            PPHONESP_FUNC_INFO pFuncInfo;

            // Build the structure for the queueing the request in Async queue
            if ( ! (pFuncInfo = (PPHONESP_FUNC_INFO) 
                                MemAlloc(sizeof (PHONESP_FUNC_INFO)) ) )
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                return PHONEERR_NOMEM;
            }
            
            pFuncInfo->dwNumParams = 4;
            pFuncInfo->dwParam1 = (ULONG_PTR) pPhone;
            pFuncInfo->dwParam2 = dwRequestID;
            pFuncInfo->dwParam3 = (ULONG_PTR) dwRingMode;
            pFuncInfo->dwParam4 = (ULONG_PTR) dwVolume;

            if ( ! ( pAsyncReqInfo = (PPHONESP_ASYNC_REQ_INFO) 
                                     MemAlloc(sizeof(PHONESP_ASYNC_REQ_INFO))))
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                MemFree(pFuncInfo);
                return PHONEERR_NOMEM;
            }
            pAsyncReqInfo->pfnAsyncProc = TSPI_phoneSetRing_AsyncProc;
            pAsyncReqInfo->pFuncInfo = pFuncInfo;

            // Queue the request to perform the operation asynchronously
            if( AsyncRequestQueueIn(pAsyncReqInfo) )
            {  
                // Reset the event for number of pending requests in the queue 
                // for this phone and increment the counter
                if (pPhone->dwNumPendingReqInQueue == 0)
                {
                    ResetEvent(pPhone->hNoPendingReqInQueueEvent);
                }
                pPhone->dwNumPendingReqInQueue++;
                LeaveCriticalSection(&pPhone->csThisPhone);
            }
            else
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                MemFree(pFuncInfo);
                MemFree(pAsyncReqInfo);
                return PHONEERR_NOMEM;
            }  
        }
        else
        {
            LeaveCriticalSection(&pPhone->csThisPhone);
            return PHONEERR_INVALPARAM;
        }
    }
    else
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        return PHONEERR_INVALRINGMODE;
    }

    LOG((PHONESP_TRACE, "TSPI_phoneSetRing - exit"));
    return 0;
}
/********************TSPI_phoneSetRing - end**********************************/


/******************************************************************************
    TSPI_phoneSetStatusMessages:
    
    This function causes the TSP to filter status messages that are not 
    currently of interest to any application.

    Arguments:

    Returns:

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSetStatusMessages(
    HDRVPHONE   hdPhone,
    DWORD       dwPhoneStates,
    DWORD       dwButtonModes,
    DWORD       dwButtonStates
    )
{
    PPHONESP_PHONE_INFO pPhone = (PPHONESP_PHONE_INFO)gpPhone[ (DWORD_PTR) hdPhone ];

    LOG((PHONESP_TRACE, "TSPI_phoneSetStatusMessages - enter"));
    
    EnterCriticalSection(&csAllPhones);
    if( ! (pPhone && pPhone->htPhone) )
    {
        LeaveCriticalSection(&csAllPhones);
        return PHONEERR_INVALPHONEHANDLE;
    }
  
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneSetStatusMessages - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    pPhone->dwPhoneStateMsgs = dwPhoneStates;
    if (dwButtonModes)
    {
        if(dwButtonStates)
        {
            pPhone->dwButtonModesMsgs = dwButtonModes;
            pPhone->dwButtonStateMsgs = dwButtonStates;
        }
    }
  
    LeaveCriticalSection(&pPhone->csThisPhone);
    LOG((PHONESP_TRACE, "TSPI_phoneSetStatusMessages - exit"));
    return 0;
}

/********************TSPI_phoneSetStatusMessages - end************************/

//
// ------------------------- TSPI_providerXxx funcs ---------------------------

/******************************************************************************
    TSPI_providerCreatePhoneDevice

    The TSP will use this function to implement PNP support. TapiSrv will call
    the TSP back with this function when the TSP sends the PHONE_CREATE message
    to Tapisrv, which allows the dynamic creation of a new phone device. 

    Arguments:
        dwTempID   - The temporary device identifier that the TSP passed to 
                     TAPI in the PHONE_CREATE message. 
        dwDeviceID - The device identifier that TAPI assigns to this device if 
                     this function succeeds. 

    Returns LONG:
        Zero if the request succeeds 
        An error number if an error occurs. 

    Comments: 

******************************************************************************/
LONG
TSPIAPI
TSPI_providerCreatePhoneDevice(
    DWORD_PTR   dwTempID,
    DWORD       dwDeviceID
    )
{
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_providerCreatePhoneDevice - enter"));

    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO)gpPhone[ (DWORD_PTR) dwTempID ];
    
    // check whether the phone handle is valid
    if ( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) ) 
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_providerCreatePhoneDevice - invalid temp id"));
        return PHONEERR_INVALPHONEHANDLE;
    }
  
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    if (pPhone->bCreatePending)
    {
        //
        // Set the device ID and mark create complete
        //
        pPhone->dwDeviceID = dwDeviceID;
        pPhone->bCreatePending = FALSE;
    }
    else
    {
        LOG((PHONESP_ERROR, "TSPI_providerCreatePhoneDevice - phone is not marked create pending"));
    }

    LOG((PHONESP_TRACE, "TSPI_providerCreatePhoneDevice - phone create complete [dwTempID %d] [dwDeviceID %d] ", dwTempID, dwDeviceID));
    
    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_providerCreatePhoneDevice - exit"));
    return 0;
}

/*****************TSPI_providerCreatePhoneDevice - end************************/

/******************************************************************************
    TSPI_providerEnumDevices:

    TAPI calls the this function before TSPI_providerInit to determine the 
    number of line and phone devices supported by the TSP.
   
    Arguments:
        dwPermanentProviderID - The permanent identifier,unique within the TSPs
                                on this system, of the TSP being initialized. 
        lpdwNumLines(ignored) - TAPI initializes the value to 0.
        lpdwNumPhones         - A pointer to a DWORD-sized memory location into
                                which the TSP must write the number of phone 
                                devices it is configured to support. TAPI 
                                initializes the value to 0.         
        hProvider             - An opaque DWORD-sized value that uniquely 
                               identifies this instance of this TSP during this 
                               execution of the Win32 Telephony environment. 
        lpfnLineCreateProc(ignored)- A pointer to the LINEEVENT callback 
                                procedure supplied by TAPI. Ignored by this TSP
        lpfnPhoneCreateProc   - A pointer to the PHONEEVENT callback procedure 
                                supplied by TAPI. The TSP uses this function to 
                                send PHONE_CREATE messages when a new phone 
                                device needs to be created. 

    Returns LONG:
        Zero if the request succeeds or 
        An error number if an error occurs. 

    Comments:Gets a pointer to the Hid Devices belonging to the telephony page.

******************************************************************************/

LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
    )
{
    PPHONESP_PHONE_INFO   *pPhone;

    DWORD                 dwPhoneCnt, dwNumChars, dwCount;
    
    LONG                  lResult = 0;

    PHID_DEVICE           pHidDevice;
    PHID_DEVICE           pHidDevices;
    ULONG                 NumHidDevices;

    HRESULT               hr;

    LOG((PHONESP_TRACE, "TSPI_providerEnumDevices - enter"));

    //
    // Initialise critical section for all phones which is the global object.
    // Before accessing the phone structure, the thread must grab this object
    // 
    __try
    {
        InitializeCriticalSection(&csAllPhones);        
    }
    __except(1)
    {
        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - Initialize Critical Section"
                            " Failed for csAllPhones"));
        return PHONEERR_NOMEM;
    }

    //
    // Initialise critical section for all hid devices which is the global object.
    // Before accessing the hid list, the thread must grab this object
    // 
    __try
    {
        InitializeCriticalSection(&csHidList);        
    }
    __except(1)
    {
        DeleteCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - Initialize Critical Section"
                            " Failed for csHidList"));
        return PHONEERR_NOMEM;
    }

#if DBG
    //Initialize critical section for memory tracing
    __try
    {
        InitializeCriticalSection(&csMemoryList);
    }
    __except(1)
    {
        DeleteCriticalSection(&csAllPhones);
        DeleteCriticalSection(&csHidList);

        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - Initialize Critical Section"
                            " Failed for csMemoryList"));
        return PHONEERR_NOMEM;
    }
#endif

    EnterCriticalSection(&csHidList);

    // Find Telephony hid Devices 
    lResult = FindKnownHidDevices (&pHidDevices, 
                                   &NumHidDevices);

    if (lResult != ERROR_SUCCESS)  
    {     
        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - FindKnownHidDevices failed %d", lResult));

        LeaveCriticalSection(&csHidList);
        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        if (lResult == ERROR_OUTOFMEMORY)
        {          
            return PHONEERR_NOMEM;
        }
        else
        {
            return PHONEERR_OPERATIONFAILED;
        }
    }


    LOG((PHONESP_TRACE, "TSPI_providerEnumDevices - number of Hid Devices : %d ", NumHidDevices));

    // Allocate memory for the array of pointers where each pointer points to
    // one of the phone discovered
    
    pPhone = MemAlloc(NumHidDevices * sizeof(PPHONESP_PHONE_INFO));

    if ( pPhone == NULL )
    {
        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - OUT OF MEMORY allocating pPhone"));

        CloseHidDevices();
        LeaveCriticalSection(&csHidList);
        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        return PHONEERR_NOMEM;
    }

    //
    // for each phone discovered, gather the capabilities of the phone and 
    // initialize the phone structure
    //
    dwPhoneCnt = 0;

    for (pHidDevice = pHidDevices; pHidDevice != NULL; pHidDevice = pHidDevice->Next)
    {
        pHidDevice->bNew = FALSE;

        // Allocate memory for this phone 
        pPhone[dwPhoneCnt] = (PPHONESP_PHONE_INFO)MemAlloc(sizeof(PHONESP_PHONE_INFO));

        if ( pPhone[dwPhoneCnt] == NULL )
        { 
            LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - OUT OF MEMORY allocating PPHONESP_PHONE_INFO"
                " for Phone %d", dwPhoneCnt));

            // Release memory allocated to other phones
            for(dwCount = 0; dwCount < dwPhoneCnt ; dwCount++)
            {
                FreePhone(pPhone[dwCount]);
                MemFree((LPVOID)pPhone[dwCount]);
                DeleteCriticalSection(&pPhone[dwCount]->csThisPhone);
            }
            MemFree((LPVOID)pPhone);

            CloseHidDevices();

            LeaveCriticalSection(&csHidList);
            DeleteCriticalSection(&csHidList);
            DeleteCriticalSection(&csAllPhones);
#if DBG
            DeleteCriticalSection(&csMemoryList);
#endif

            return PHONEERR_NOMEM;
        }

        LOG((PHONESP_TRACE, "TSPI_ProviderEnumDevices: Initializing Device: %d",dwPhoneCnt+1));

        ZeroMemory( pPhone[dwPhoneCnt], sizeof(PHONESP_PHONE_INFO));

        //
        // Initialize the critical section object for this phone. only the 
        // thread that owns this object can access the structure for this phone
        //
        __try 
        {
            InitializeCriticalSection(&pPhone[dwPhoneCnt]->csThisPhone);
        }
        __except(1)
        {
            // Release memory allocated to the phones
            for(dwCount = 0; dwCount < dwPhoneCnt; dwCount++)
            {
                FreePhone(pPhone[dwCount]);
                MemFree((LPVOID)pPhone[dwCount]);
                DeleteCriticalSection(&pPhone[dwCount]->csThisPhone);
            }
            MemFree((LPVOID)pPhone[dwPhoneCnt]);
            MemFree((LPVOID)pPhone);

            CloseHidDevices();

            LeaveCriticalSection(&csHidList);
            DeleteCriticalSection(&csHidList);
            DeleteCriticalSection(&csAllPhones);
#if DBG
            DeleteCriticalSection(&csMemoryList);
#endif

            LOG((PHONESP_ERROR,"TSPI_providerEnumDevices - Initialize Critical Section"
                  " Failed for Phone %d", dwPhoneCnt));

            return PHONEERR_NOMEM;
        }

        lResult = CreatePhone( pPhone[dwPhoneCnt], pHidDevice, dwPhoneCnt );

        if ( lResult != ERROR_SUCCESS )
        {
            LOG((PHONESP_ERROR,"TSPI_providerEnumDevices - CreatePhone"
                  " Failed for Phone %d: error: %d", dwPhoneCnt, lResult));
        }
        else
        {
            // Phone created successfully, increase phone count
            dwPhoneCnt++; 
        }
    }

    LeaveCriticalSection(&csHidList);   

    *lpdwNumPhones = gdwNumPhones = dwPhoneCnt;

    //
    // If the space allocated previously was greater than the actual number of
    // supported phones
    //
    if(NumHidDevices != gdwNumPhones)
    {
        gpPhone = MemAlloc(gdwNumPhones * sizeof(PPHONESP_PHONE_INFO));

        if ( gpPhone == NULL )
        {           
            for(dwCount = 0; dwCount < dwPhoneCnt ; dwCount++)
            {
                FreePhone(pPhone[dwCount]);
                MemFree((LPVOID)pPhone[dwCount]);
                DeleteCriticalSection(&pPhone[dwCount]->csThisPhone);
            }
            MemFree(pPhone);

            CloseHidDevices();

            DeleteCriticalSection(&csAllPhones);
#if DBG
            DeleteCriticalSection(&csMemoryList);
#endif
            DeleteCriticalSection(&csHidList);

            LOG((PHONESP_ERROR,"TSPI_providerEnumDevices - OUT OF MEMORY allocating gpPhone"));

            return PHONEERR_NOMEM;
        }

        CopyMemory(
                gpPhone,
                pPhone,
                sizeof(PPHONESP_PHONE_INFO) * gdwNumPhones
               );

        MemFree(pPhone);
    }
    else
    {
        gpPhone = pPhone;
    }
     
    glpfnPhoneCreateProc = lpfnPhoneCreateProc;
    ghProvider = hProvider;
 
    LOG((PHONESP_TRACE, "TSPI_providerEnumDevices - exit"));

    return 0;
}
/*************************TSPI_providerEnumDevices - end*********************/



/******************************************************************************
    TSPI_providerInit:

    The TSPI_providerInit function initializes the service provider and gives 
    it parameters required for subsequent operation.
    
    Arguments:

        dwTSPIVersion         - The version of the TSPI definition under which 
                                this function must operate. 
        dwPermanentProviderID - The permanent identifier, unique within the TSP
                                on this system, of the TSP being initialized. 
        dwLineDeviceIDBase      - Ignored by this TSP 
        dwPhoneDeviceIDBase      - The lowest device identifier for the phone 
                                devices supported by this service provider. 
        dwNumLines(Ignored)      - The number of line devices this TSP supports. 
        dwNumPhones              - The number of phone devices this TSP supports. 
                                The value returned is the number of phone 
                                devices reported in TSPI_providerEnumDevices. 
        lpfnCompletionProc    - The procedure the TSP calls to report 
                                completion of all asynchronously operating 
                                procedures on line and phone devices. 
        lpdwTSPIOptions          - A pointer to a DWORD-sized memory location,into
                                which the TSP can write a value specifying 
                                LINETSPIOPTIONS_ values. This parameter allows 
                                the TSP to return bits indicating optional 
                                behaviors desired of TAPI. TAPI sets the 
                                options DWORD to 0. 

    Returns LONG:
        Zero if the request succeeds or 
        An error number if an error occurs. 

    Comments:

******************************************************************************/

LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD_PTR           dwNumLines,
    DWORD_PTR           dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
    )
{
    DWORD             dwThreadID;
    LONG              lResult = 0;
    
    LOGREGISTERTRACING(_T("hidphone"));

    LOG((PHONESP_TRACE, "TSPI_providerInit - enter"));
   
    
    // Load Provider Info From String Table
    gszProviderInfo = PHONESP_LoadString( 
                                         IDS_PROVIDER_INFO, 
                                         &lResult
                                        );

    if(lResult != ERROR_SUCCESS)
    {  
        DWORD dwPhoneCnt;

        LOG((PHONESP_ERROR,"TSPI_providerEnumDevices - PHONESP_LoadString failed %d", lResult));     
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);     

            MemFree(gpPhone[dwPhoneCnt]);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);
        
        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        if(lResult == ERROR_OUTOFMEMORY)
        {
            return PHONEERR_NOMEM;
        }
        else
        {
            return lResult;
        }
    }
  

    glpfnCompletionProc = lpfnCompletionProc;
    gdwPhoneDeviceIDBase = dwPhoneDeviceIDBase;
    gdwPermanentProviderID = dwPermanentProviderID;
 
    //
    // Assign device IDs to the phones
    //
    {
        DWORD dwPhoneCnt;
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            gpPhone[dwPhoneCnt]->dwDeviceID = gdwPhoneDeviceIDBase + dwPhoneCnt;
        }
    }          

    //
    // Alloc a queue for storing async requests for async completion,
    // and start a thread to service that queue
    //

    //Initialize critical section for the async queue
    __try
    {
        InitializeCriticalSection(&gAsyncQueue.AsyncEventQueueCritSec);
    }
    __except(1)
    {
        DWORD dwPhoneCnt;

        LOG((PHONESP_ERROR, "TSPI_providerInit - Initialize Critical Section"
                            " Failed for gAsyncQueue.AsyncEventQueueCritSec"));
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            MemFree(gpPhone[dwPhoneCnt]);
            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);

        MemFree((LPVOID) gszProviderInfo);

        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        return PHONEERR_NOMEM;
    }

    gAsyncQueue.dwNumTotalQueueEntries = MAX_QUEUE_ENTRIES;
    gAsyncQueue.dwNumUsedQueueEntries = 0;

    //
    // Alloc memory for the queue to accomodate dwNumTotalQueueEntries ot begin
    // with. The size of the queue can later be increased as required
    //

    gAsyncQueue.pAsyncRequestQueue =
        MemAlloc(gAsyncQueue.dwNumTotalQueueEntries * sizeof(PPHONESP_ASYNC_REQ_INFO));

    if ( gAsyncQueue.pAsyncRequestQueue == NULL )
    {
        DWORD dwPhoneCnt;   
        
        LOG((PHONESP_ERROR, "TSPI_providerInit - OUT OF MEMORY allocating"
                            " gAsyncQueue.pAsyncRequestQueue"));
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            MemFree(gpPhone[dwPhoneCnt]);
            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);        

        MemFree((LPVOID) gszProviderInfo);

        DeleteCriticalSection(&gAsyncQueue.AsyncEventQueueCritSec);

        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        return PHONEERR_NOMEM;
    }

    
    gAsyncQueue.pAsyncRequestQueueIn =
    gAsyncQueue.pAsyncRequestQueueOut = gAsyncQueue.pAsyncRequestQueue;

    //
    // the thread associated waits on this event when there are no requests 
    // pending in the queue. This event informs the thread when a request is 
    // entered in an empty queue so the thread can exit the wait state and 
    // process the request
    //

    gAsyncQueue.hAsyncEventsPendingEvent = CreateEvent (
                                               (LPSECURITY_ATTRIBUTES) NULL,
                                               TRUE,   // manual reset
                                               FALSE,  // non-signaled
                                               NULL    // unnamed
                                               );

    if ( gAsyncQueue.hAsyncEventsPendingEvent == NULL )
    {
        DWORD dwPhoneCnt;

        LOG((PHONESP_ERROR, "TSPI_providerInit - CreateEvent failed"
                            " for gAsyncQueue.hAsyncEventsPendingEvent"));
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            MemFree(gpPhone[dwPhoneCnt]);
            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);

        MemFree((LPVOID) gszProviderInfo);

        DeleteCriticalSection(&gAsyncQueue.AsyncEventQueueCritSec);
        MemFree((LPVOID)gAsyncQueue.pAsyncRequestQueue); 

        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        return PHONEERR_NOMEM;
    }


    //
    // Create the thread to service the requests in the queue
    //

    gAsyncQueue.hAsyncEventQueueServiceThread =
                 CreateThread (
                        (LPSECURITY_ATTRIBUTES) NULL,
                        0,      // default stack size
                        (LPTHREAD_START_ROUTINE) AsyncEventQueueServiceThread,
                        NULL,   // thread param
                        0,      // creation flags
                        &dwThreadID      // &dwThreadID
                      );

    if ( gAsyncQueue.hAsyncEventQueueServiceThread == NULL )
    {
        DWORD dwPhoneCnt; 
        
        LOG((PHONESP_ERROR, "TSPI_providerInit - CreateThread failed"
                            " for gAsyncQueue.hAsyncEventQueueServiceThread"));
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            MemFree(gpPhone[dwPhoneCnt]);
            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);

        MemFree((LPVOID) gszProviderInfo);

        DeleteCriticalSection(&gAsyncQueue.AsyncEventQueueCritSec);
        CloseHandle(gAsyncQueue.hAsyncEventsPendingEvent);
        MemFree((LPVOID)gAsyncQueue.pAsyncRequestQueue); 

        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif
    
        return PHONEERR_NOMEM;
    }

    LOG((PHONESP_TRACE, "TSPI_providerInit - exit"));
    return 0;
}
/***************************TSPI_providerInit - end***************************/


/******************************************************************************
    TSPI_providerInstall:

    This function is obsolete. However due to a bug in TAPI, the TSP must 
    provide a do-nothing implementation of this function and export it (along 
    with the superseding function TUISPI_providerInstall)
  
*******************************************************************************/
LONG
TSPIAPI
TSPI_providerInstall(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    LOG((PHONESP_TRACE, "TSPI_providerInstall - enter"));
    LOG((PHONESP_TRACE, "TSPI_providerInstall - exit"));
    return 0;
}
/*********************TSPI_providerInstall - end******************************/


/******************************************************************************
    TSPI_providerRemove:

    This function is obsolete. However due to a bug in TAPI, the TSP must 
    provide a do-nothing implementation of this function and export it (along 
    with the superseding function TUISPI_providerRemove)
  
*******************************************************************************/

LONG
TSPIAPI
TSPI_providerRemove (
                     HWND hwndOwner,
                     DWORD dwPermanentProviderId
                    )
{
    LOG((PHONESP_TRACE, "TSPI_providerRemove - enter"));
    LOG((PHONESP_TRACE, "TSPI_providerRemove - exit"));
    return 0;
}

/*********************TSPI_providerRemove - end******************************/



/******************************************************************************
    TSPI_providerShutdown:

    This function shuts down the TSP. The TSP terminates any activities it has 
    in progress and releases any resources it has allocated.

    Arguments:
        dwTSPIVersion          -    The version of the TSPI definition under which 
                                this function must operate.  
        dwPermanentProviderID - This parameter allows the TSP to determine which 
                                among multiple possible instances of the TSP is 
                                being shut down. The value of the parameter is 
                                identical to that passed in    the parameter of 
                                the same name in TSPI_providerInit. 

    Returns LONG:
        Zero if the request succeeds or 
        An error number if an error occurs. Possible return values are as follows: 
            LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM. 

    Comments: Whenever TAPI API call PhoneShutdown is called , it first shuts
              down all the phones that are currently open using TSPI_phoneClose
              and then calls TSPI_providerShutdown 
              

******************************************************************************/


LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
    )
{
    DWORD dwPhoneCnt = 0;
  
    LOG((PHONESP_TRACE, "TSPI_providerShutdown - enter"));


    // this will terminate the queue service thread once all the operations 
    // pending in the queue are serviced
    gbProviderShutdown = TRUE;

    // the queue service waits for this event when the queue. By setting 
    // this event,the thread wakes up and realises that the queue is empty and
    // hence exists since gbProviderShutdown is true
    SetEvent(gAsyncQueue.hAsyncEventsPendingEvent);

    // Wait for the queue thread to terminate.
    WaitForSingleObject(gAsyncQueue.hAsyncEventQueueServiceThread, INFINITE);


    // Free all the associated memory with the providerinfo
    MemFree((LPVOID) gszProviderInfo);

    EnterCriticalSection(&csAllPhones);

    // Free all memory associated with the phones
    for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
    {   
        EnterCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        FreePhone(gpPhone[dwPhoneCnt]);
        LeaveCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);

        DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        
        MemFree(gpPhone[dwPhoneCnt]);
    }

    gdwNumPhones = 0;

    LeaveCriticalSection(&csAllPhones);
    
    CloseHandle (gAsyncQueue.hAsyncEventQueueServiceThread);
    CloseHandle (gAsyncQueue.hAsyncEventsPendingEvent);

    EnterCriticalSection(&csHidList);
    CloseHidDevices();
    LeaveCriticalSection(&csHidList);
    
    LOG((PHONESP_TRACE, "Free Heap taken by phone"));
    MemFree (gpPhone);

    LOG((PHONESP_TRACE, "Free Heap taken by queue"));
    MemFree (gAsyncQueue.pAsyncRequestQueue);

#if DBG
    LOG((PHONESP_TRACE, "Dumping Memory Trace"));
    DumpMemoryList();

    DeleteCriticalSection (&csMemoryList);
#endif

    DeleteCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);
    DeleteCriticalSection (&csHidList);
    DeleteCriticalSection (&csAllPhones);

    LOG((PHONESP_TRACE, "TSPI_providerShutdown - exit"));

    LOGDEREGISTERTRACING();

    return 0;
}
/***************TSPI_providerShutdown*****************************************/



/******************************************************************************
    TSPI_providerUIIdentify:
    
    This function extracts from the TSP, the fully qualified path to load 
    the TSP's UI DLL component.

    Arguments:
        lpszUIDLLName - Pointer to a block of memory at least MAX_PATH in length, 
                        into which the TSP must copy a NULL-terminated string 
                        specifying the fully-qualified path for the DLL 
                        containing the TSP functions which must execute in the 
                        process of the calling application. 

    Return LONG:
        Returns zero if successful. 
        Shouldn't ever fail, but if it does returns one of these negative 
        error values: LINEERR_NOMEM, LINEERR_OPERATIONFAILED. 

******************************************************************************/
LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR   lpszUIDLLName
    )
{
    LOG((PHONESP_TRACE, "TSPI_providerUIIdentify - enter"));

    //
    // If we ever want to specify some other dll to handle ui, we
    // would do it here.
    //
    GetModuleFileName(ghInst,
                      lpszUIDLLName,
                      MAX_PATH);

    LOG((PHONESP_TRACE, "TSPI_providerUIIdentify - exit"));

    return 0;
}
/***********************TSPI_providerUIIdentify - end ************************/

/******************************************************************************
    TUISPI_providerInstall:

    The TSP exports this function and provides a do-nothing implementation.
    The Advanced tab of the Phone and Modem Options control panel will call
    this function when the provider is to be installed, to give the TSP a
    chance to do custom UI. There is no requirement for custom configuration
    UI. The only requirement is that the control panel be able to
    automatically install the TSP.
  
*******************************************************************************/
LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    LOG((PHONESP_TRACE, "TUISPI_providerInstall - enter"));

    // check for previous instance
    if (IsTSPAlreadyInstalled())
    {
        // cannot be installed twice
        LOG((PHONESP_TRACE, "TUISPI_providerInstall - cannot be installed twice"));
        return LINEERR_NOMULTIPLEINSTANCE;
    }

    LOG((PHONESP_TRACE, "TUISPI_providerInstall - exit"));
    return 0;
}
/***********************TUISPI_providerInstall - end ************************/

/******************************************************************************
    TUISPI_providerRemove:

    The TSP exports this function and provides a do-nothing implementation.
    The Advanced tab of the Phone and Modem Options control panel will call
    this function when the provider is to be removed, to give the TSP a
    chance to do custom UI. There is no requirement for custom configuration
    UI. The only requirement is that the control panel be able to
    automatically remove the TSP.
  
*******************************************************************************/
LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    LOG((PHONESP_TRACE, "TUISPI_providerRemove - enter"));
    LOG((PHONESP_TRACE, "TUISPI_providerRemove - exit"));    
    return 0;
}
/***********************TUISPI_providerRemove - end ************************/

//----------------------------PRIVATE FUNCTIONS-------------------------------


/******************************************************************************
    AsyncRequestQueueIn:
    
    This function adds the new incoming request from the tapisrv to the async 
    queue.

    Arguments:
       IN PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo - Pointer to the request info.

    Returns BOOL:
        TRUE if the function is successful 
        FALSE if it is not

******************************************************************************/
BOOL
AsyncRequestQueueIn (
                     PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo
                     )
{

    //LOG((PHONESP_TRACE, "AsyncRequestQueueIn - enter "));

    EnterCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);

    if (gAsyncQueue.dwNumUsedQueueEntries == gAsyncQueue.dwNumTotalQueueEntries)
    {
        
        //
        // We've max'd out our ring buffer, so try to grow it
        //

        DWORD                       dwMoveSize;
        PPHONESP_ASYNC_REQ_INFO     *pNewAsyncRequestQueue;

        if ( ! ( pNewAsyncRequestQueue = 
                 MemAlloc(2 * gAsyncQueue.dwNumTotalQueueEntries 
                            * sizeof (PPHONESP_ASYNC_REQ_INFO)) ) )
        {
            LeaveCriticalSection( &gAsyncQueue.AsyncEventQueueCritSec);
            LOG((PHONESP_ERROR,"AsyncRequestQueueIn - Not enough memory to"
                               " queue request"));
            return FALSE;
        }

        dwMoveSize = (DWORD) ((gAsyncQueue.pAsyncRequestQueue +
                               gAsyncQueue.dwNumTotalQueueEntries) -
                               gAsyncQueue.pAsyncRequestQueueOut) * 
                               sizeof (PPHONESP_ASYNC_REQ_INFO);

        CopyMemory(
                   pNewAsyncRequestQueue,
                   gAsyncQueue.pAsyncRequestQueueOut,
                   dwMoveSize
                  );

        CopyMemory(
                   ((LPBYTE) pNewAsyncRequestQueue) + dwMoveSize,
                   gAsyncQueue.pAsyncRequestQueue,
                   (gAsyncQueue.pAsyncRequestQueueOut -
                   gAsyncQueue.pAsyncRequestQueue) * 
                    sizeof (PPHONESP_ASYNC_REQ_INFO)
                  );

        MemFree (gAsyncQueue.pAsyncRequestQueue);

        gAsyncQueue.pAsyncRequestQueue    =
        gAsyncQueue.pAsyncRequestQueueOut = pNewAsyncRequestQueue;
        gAsyncQueue.pAsyncRequestQueueIn = pNewAsyncRequestQueue +
                                           gAsyncQueue.dwNumTotalQueueEntries;
        gAsyncQueue.dwNumTotalQueueEntries *= 2;
    } 

    *(gAsyncQueue.pAsyncRequestQueueIn) = pAsyncReqInfo;

    gAsyncQueue.pAsyncRequestQueueIn++;

    // The queue is maintained as a circular list - if the queue in pointer
    // has reached the bottom of the queue, reset it to point it to the top
    // of the queue
    if (gAsyncQueue.pAsyncRequestQueueIn == (gAsyncQueue.pAsyncRequestQueue +
                                           gAsyncQueue.dwNumTotalQueueEntries))
    {
        gAsyncQueue.pAsyncRequestQueueIn = gAsyncQueue.pAsyncRequestQueue;
    }

    // Increment the number of outstanding requests in the queue
    gAsyncQueue.dwNumUsedQueueEntries++;

    // If this is the first request in the queue - set event to resume the 
    // thread to process the queue
    
    if (gAsyncQueue.dwNumUsedQueueEntries == 1)
    {
        SetEvent (gAsyncQueue.hAsyncEventsPendingEvent);
    }

    LeaveCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);

    //LOG((PHONESP_TRACE, "AsyncRequestQueueIn - exit"));
    return TRUE;
}
/********************AsyncRequestQueueIn - end********************************/

/******************************************************************************
    CreateButtonsAndAssignID
        
    This function creates button structures for the phone from the capability
    array. It also determines whether the phone has a keypad. It assigns IDs to
    the buttons discovered.

    Arguments:
        PPHONESP_PHONE_INFO pPhone

    Returns LONG:
    ERROR_SUCCESS if the function succeeds
    ERROR_OUTOFMEMORY if error occurs while allocating memory

******************************************************************************/

LONG
CreateButtonsAndAssignID (
                          PPHONESP_PHONE_INFO pPhone
                         )
{
    DWORD i,j, dwNextFreeID = 0;
    BOOL KEYPAD = TRUE;
    BOOL KEYPAD_ABCD = TRUE;
    PPHONESP_BUTTONINFO pButtonInfo;
    DWORD lResult = 0;

    LOG((PHONESP_TRACE, "CreateButtonsAndAssignID - enter"));

    // First determine the number of buttons available on this phone
    
    // If all the 12 basic key pad buttons are present
    // then phone has a Keypad, else all the key pad buttons are ignored
    for(i = PHONESP_PHONE_KEY_0; i <= PHONESP_PHONE_KEY_POUND; i++)
    {
        if(!pPhone->dwReportTypes[i])
        {
            KEYPAD = FALSE;
            break;
        }
    }
    
    // Also determine if phone had ABCD buttons on its keypad
    for(i = PHONESP_PHONE_KEY_A; i <= PHONESP_PHONE_KEY_D; i++)
    {
        if(!pPhone->dwReportTypes[i])
        {
            KEYPAD_ABCD = FALSE;
            break;
        }
    }
    
    if (KEYPAD)
    {   
        if (KEYPAD_ABCD)
        {
            // keypad with ABCD
            pPhone->dwNumButtons = PHONESP_NUMBER_PHONE_KEYS;
        }
        else
        {
            // basic keypad
            pPhone->dwNumButtons = 12;
        }
    }
    else
    {
        pPhone->dwNumButtons = 0;
    }

    for(i = PHONESP_NUMBER_PHONE_KEYS; i < PHONESP_NUMBER_BUTTONS; i++)
    { 
        if(pPhone->dwReportTypes[i])
        {
            pPhone->dwNumButtons++;
        }
    }

    // Allocate memory for all the buttons
  
    if ( ! (pPhone->pButtonInfo = (PPHONESP_BUTTONINFO) 
                                  MemAlloc( pPhone->dwNumButtons * 
                                            sizeof(PHONESP_BUTTONINFO)
                                           ) ) )
    {
        return ERROR_OUTOFMEMORY;
    }

    pButtonInfo = pPhone->pButtonInfo;

    // if the phone has a keypad with all the 16 buttons
    if (KEYPAD)
    { 
        LOG((PHONESP_TRACE, "Phone Has a Keypad"));

        for( i = PHONESP_PHONE_KEY_0; i <= (DWORD)(KEYPAD_ABCD ? PHONESP_PHONE_KEY_D : PHONESP_PHONE_KEY_POUND) ; i++, pButtonInfo++)
        {

            pButtonInfo->dwButtonID = i;
            pButtonInfo->dwButtonMode = PHONEBUTTONMODE_KEYPAD;
            pButtonInfo->dwButtonFunction = PHONEBUTTONFUNCTION_NONE;
            pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;
            pPhone->dwButtonIds[i] = pButtonInfo->dwButtonID;

            pButtonInfo->szButtonText = PHONESP_LoadString( 
                                                     gdwButtonText[i], 
                                                     &lResult                
                                                    );

            if(lResult != ERROR_SUCCESS)
            {
                DWORD dwCount;
    
                for(dwCount =0; dwCount < i; dwCount++)
                {
                    MemFree(pPhone->pButtonInfo->szButtonText);
                    pPhone->pButtonInfo++;
                }
                
                MemFree(pPhone->pButtonInfo);
                return lResult;
            }

            LOG((PHONESP_TRACE,"Button Found '%ws' at %d", pButtonInfo->szButtonText, i));
        }
        
        dwNextFreeID = i;
        pPhone->bKeyPad = TRUE;
    }
    else
    {
        // If phone has no keypad - the button ID for the feature buttons start
        // from 0 else they start from 16
        dwNextFreeID = 0;
    }

    // assign appropriate button ids for the feature buttons if they exist
    for (i = PHONESP_NUMBER_PHONE_KEYS, j = 0; i < PHONESP_NUMBER_BUTTONS; i++, j++)
    {
        if(pPhone->dwReportTypes[i])
        {
            pButtonInfo->dwButtonID = dwNextFreeID;
            pButtonInfo->dwButtonMode = PHONEBUTTONMODE_FEATURE;
            pButtonInfo->dwButtonFunction = gdwButtonFunction[j];
            pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;
            pPhone->dwButtonIds[i] = pButtonInfo->dwButtonID;

            pButtonInfo->szButtonText = PHONESP_LoadString( 
                                                     gdwButtonText[i], 
                                                     &lResult
                                                    );

            if(lResult != ERROR_SUCCESS)
            {
                DWORD dwCount;
                DWORD dwStartID = 0;
                
                if(KEYPAD)
                {
                    for(dwCount = PHONESP_PHONE_KEY_0; 
                        dwCount <= (DWORD)(KEYPAD_ABCD ? PHONESP_PHONE_KEY_D : PHONESP_PHONE_KEY_POUND); dwCount++)
                    {
                        MemFree(pPhone->pButtonInfo->szButtonText);
                        pPhone->pButtonInfo++;
                    }
                    dwStartID = dwCount;
                }

                for(dwCount = dwStartID; dwCount < dwNextFreeID; dwCount++)
                {
                    MemFree(pPhone->pButtonInfo->szButtonText);
                    pPhone->pButtonInfo++;
                }
                
                MemFree(pPhone->pButtonInfo);
                
                return lResult;
            }

            LOG((PHONESP_TRACE,"Button Found '%ws' at %d", pButtonInfo->szButtonText, dwNextFreeID));

            dwNextFreeID++;
            pButtonInfo++;
        }
    }

    LOG((PHONESP_TRACE, "CreateButtonsAndAssignID - exit"));
    return ERROR_SUCCESS;  
}
/********************CreateButtonsAndAssignID - end****************************/

/*****************************************************************************
    GetButtonFromID
    
    This function will retrieve the structure for the Button from it's ID

    Arguments:
        IN PPHONESP_PHONE_INFO pPhone - Pointer to the phone whose button 
                              structure has to be retrieved.
        IN DWORD dwButtonID - The Button ID


    Returns: 
        PBUTTONINFO - Pointer to the button structure if successful
        NULL        - If Button not found
******************************************************************************/
PPHONESP_BUTTONINFO
GetButtonFromID (
                 PPHONESP_PHONE_INFO pPhone,
                 DWORD               dwButtonID
                )
{
    PPHONESP_BUTTONINFO pButtonInfo; 
    DWORD i;

    // if the phone has any buttons
    if (pPhone->pButtonInfo)
    {
        pButtonInfo = pPhone->pButtonInfo;
        
        // search the list of buttons to find the button corresponding to the
        // button id provided
        for( i = 0; i < pPhone->dwNumButtons; i++)
        {
            if (pButtonInfo->dwButtonID == dwButtonID)
            {
                return pButtonInfo;
            }
            pButtonInfo++;
        }
    }

    return (PPHONESP_BUTTONINFO) NULL;
}
/*************************GetButtonFromID - end*******************************/


/******************************************************************************
    GetPhoneFromID:
    
    This function returns the structure that contains the information on the
    phone whose device ID is passed to this function.

    Arguments:
        dwDeviceID - The device ID of the phone to be retrieved
        pdwPhoneID - The to a DWORD to store the index into gpPhone,
                     this parameter can be NULL
    
    Returns PPHONESP_PHONE_INFO
        Pointer to the phone structure if successful
        NULL if phone not found

******************************************************************************/
PPHONESP_PHONE_INFO
GetPhoneFromID(
    DWORD   dwDeviceID,
    DWORD * pdwPhoneID
    )
{
    DWORD                 dwPhone;
    PPHONESP_PHONE_INFO   pPhone;

    LOG((PHONESP_TRACE, " GetPhoneFromID - enter"));

    for (dwPhone = 0; dwPhone < gdwNumPhones; dwPhone++)
    {
        pPhone = (PPHONESP_PHONE_INFO) gpPhone[ dwPhone ];

        EnterCriticalSection(&pPhone->csThisPhone);

        if ( pPhone->bAllocated )
        {
            if ( pPhone->dwDeviceID == dwDeviceID )
            {
                // check pdwPhoneID, NULL is valid if the caller doesn't
                // want us to return the phone index
                if (pdwPhoneID != NULL)
                {
                    *pdwPhoneID = dwPhone;
                }

                LeaveCriticalSection(&pPhone->csThisPhone);
                return pPhone;
            }
        }

        LeaveCriticalSection(&pPhone->csThisPhone);
    }
 
    LOG((PHONESP_TRACE, " GetPhoneFromID - exit"));

    return NULL;
}
/*****************************GetPhoneFromID - end****************************/

/******************************************************************************
    GetPhoneFromHid:
    
    This function returns the structure that contains the information on the
    phone whose HidDevice is passed to this function.

    Arguments:
        HidDevice - Pointer to a hid device

    
    Returns PPHONESP_PHONE_INFO
        Pointer to the phone structure if successful
        NULL if phone not found

******************************************************************************/
PPHONESP_PHONE_INFO
GetPhoneFromHid (
                PHID_DEVICE HidDevice
               )
{
    DWORD                 dwPhone;
    PPHONESP_PHONE_INFO   pPhone;

    LOG((PHONESP_TRACE, " GetPhoneFromHid - enter"));

    for (dwPhone = 0; dwPhone < gdwNumPhones; dwPhone++)
    {
        pPhone = (PPHONESP_PHONE_INFO) gpPhone[ dwPhone ];

        EnterCriticalSection(&pPhone->csThisPhone);

        if ( pPhone->bAllocated )
        {
            if ( pPhone->pHidDevice == HidDevice )
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                return pPhone;
            }
        }

        LeaveCriticalSection(&pPhone->csThisPhone);
    }
 
    LOG((PHONESP_TRACE, " GetPhoneFromHid - exit"));

    return NULL;
}

/******************************************************************************
    GetButtonUsages:

    This function parses the PHIDP_BUTTON_CAPS structure to retrieve the usages
    present for the phone and records them in the capabilities array of the 
    phone structure.

    Arguments:
       PPHONESP_PHONE_INFO pPhone - The phone structure to be updated
       PHIDP_BUTTON_CAPS pButtonCaps - The Button Caps structure to be parsed
       DWORD dwNumberCaps - The number of Button Caps structure of the Report
                            Type 
       DWORD ReportType - Whether the usage within the Button Caps structure is
                          associated with an INPUT, OUTPUT or FEATURE Report.

    Returns VOID.

******************************************************************************/
VOID
GetButtonUsages(
                PPHONESP_PHONE_INFO pPhone,
                PHIDP_BUTTON_CAPS pButtonCaps,
                DWORD dwNumberCaps,
                DWORD ReportType
                )
{
    DWORD cNumCaps;
    USAGE Usage;

    for (cNumCaps = 0; cNumCaps < dwNumberCaps; pButtonCaps++,cNumCaps++)
    {   // if the button caps structure has a list of usages
        if(pButtonCaps->IsRange)
        {
            for(Usage = (USAGE) pButtonCaps->Range.UsageMin;
                Usage <= (USAGE) pButtonCaps->Range.UsageMax; Usage++)
            {
                InitPhoneAttribFromUsage(
                                         ReportType,
                                         pButtonCaps->UsagePage,
                                         Usage,
                                         pPhone,
                                         0,
                                         0
                                        );
            }
        }
        else // if the button caps structure has a single usage
        {
            InitPhoneAttribFromUsage(
                                     ReportType, 
                                     pButtonCaps->UsagePage,
                                     pButtonCaps->NotRange.Usage, 
                                     pPhone,
                                     0,
                                     0
                                    );
        }
    }
}
/*****************************GetUsages - end********************************/

/******************************************************************************
    GetReportID

    This function returns the HidData structure that contains the usage 
    provided. The HidData structure contains the report ID for this usage

    Arguments:
        IN PHID_DEVICE  pHidDevice - the device whose usage is provided
        IN USAGE        Usage      - The usage whose report Id is to be discovered
        OUT PHID_DATA   pHidData   - If the function succeeds, this structure
                                     contains the report id for the usage, else
                                     it is NULL
    
    Returns LONG:
        ERROR_SUCCESS - if the functions succeeds
        MY_RESOURCENOTFOUND - if the usage was not found in the pHidDevice 
                              structure provided
******************************************************************************/    
LONG
GetReportID (
             IN PHID_DEVICE pHidDevice,
             IN USAGE Usage,
             OUT PHID_DATA pHidData
             )
{
    PHID_DATA pData;
    USAGE ButtonUsage;

    pData = pHidDevice->OutputData;

    while (pData)
    {
        // if the hid data structure has button data
        if (pData->IsButtonData)
        {
            for(ButtonUsage = (USAGE) pData->ButtonData.UsageMin;
                ButtonUsage <= (USAGE) pData->ButtonData.UsageMax; ButtonUsage++)
            {
                if (Usage == ButtonUsage)
                {
                    pHidData = pData;
                    return ERROR_SUCCESS;
                }
            }

        }
        else
        {   // if the hid data structure has value data
            if (Usage == pData->ValueData.Usage)
            {
                pHidData = pData;
                return ERROR_SUCCESS;
            }
        }
        pData++;
    }

    pHidData = NULL;

    return ERROR_INVALID_DATA;
}
/*************************GetReportID - end **********************************/


/******************************************************************************
    GetValueUsages:

    This function parses the PHIDP_VALUE_CAPS structure to retrieve the usages
    present for the phone and records them in the capabilities array of the 
    phone structure.

    Arguments:
       PPHONESP_PHONE_INFO pPhone  - The phone structure to be updated
       PHIDP_VALUE_CAPS pValueCaps - The Value Caps structure to be parsed
       DWORD dwNumberCaps - The number of Button Caps structure of the Report
                            Type 
       DWORD ReportType - Whether the usage within the Button Caps structure is
                          associated with an INPUT, OUTPUT or FEATURE Report.

    Returns VOID.

******************************************************************************/

VOID
GetValueUsages(
                PPHONESP_PHONE_INFO pPhone,
                PHIDP_VALUE_CAPS pValueCaps,
                DWORD dwNumberCaps,
                DWORD ReportType
               )
{
    DWORD cNumCaps;
    USAGE Usage;

    for (cNumCaps=0; cNumCaps < dwNumberCaps; pValueCaps++, cNumCaps++)
    {
        if(pValueCaps->IsRange)
        {
            for(Usage = (USAGE) pValueCaps->Range.UsageMin;
                Usage <= (USAGE) pValueCaps->Range.UsageMax; Usage++)
            {
                InitPhoneAttribFromUsage(
                                         ReportType,
                                         pValueCaps->UsagePage,
                                         Usage,
                                         pPhone,
                                         pValueCaps->LogicalMin,
                                         pValueCaps->LogicalMax
                                        );
            }
        }
        else
        {    
            InitPhoneAttribFromUsage(
                                     ReportType, 
                                     pValueCaps->UsagePage,
                                     pValueCaps->NotRange.Usage, 
                                     pPhone,
                                     pValueCaps->LogicalMin,
                                     pValueCaps->LogicalMax
                                    );
        }
    
    }
}
/**********************GetValueUsages - end***********************************/

/******************************************************************************
    InitPhoneAttribFromUsages:

    This function is called by providerInit to determine the capabilities of 
    the device 
   
    Arguments:
        IN DWORD ReportType - Whether the usage is a input/feature/output
        IN USAGE Usage      - A Usage of the device  
        IN OUT PPHONESP_PHONE_INFO pPhone - The pointer to the phone whose 
                                  capabilities are being determined.

    Returns VOID
 
******************************************************************************/
VOID 
InitPhoneAttribFromUsage (
                          DWORD ReportType,
                          USAGE UsagePage,
                          USAGE Usage,
                          PPHONESP_PHONE_INFO pPhone,
                          LONG Min,
                          LONG Max
                          )
{

    PPHONESP_BUTTONINFO pButtonInfo;

    //LOG((PHONESP_TRACE, "InitPhoneAttribFromUsage - enter"));

    switch (UsagePage)
    {
    case HID_USAGE_PAGE_TELEPHONY:
        {
            switch (Usage)
            {        
            case HID_USAGE_TELEPHONY_HOOKSWITCH:
                pPhone->dwHandset |= ReportType;
                pPhone->dwHookSwitchDevs |= PHONEHOOKSWITCHDEV_HANDSET;                 
                pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;  //Assume handset is on hook

                LOG((PHONESP_TRACE,"HOOKSWITCH USAGE, ReportType 0x%04x", ReportType));
                break;

            case HID_USAGE_TELEPHONY_RINGER:
                pPhone->dwRing |= ReportType;
                pPhone->dwRingMode = 0;  //Assume the phone is not ringing 

                LOG((PHONESP_TRACE,"RINGER USAGE, ReportType: %d", ReportType));
                break;

            case HID_USAGE_TELEPHONY_SPEAKER_PHONE:
                pPhone->dwSpeaker |= ReportType;
                pPhone->dwHookSwitchDevs |= PHONEHOOKSWITCHDEV_SPEAKER;  
                pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK; //Assume speaker is on hook
                LOG((PHONESP_TRACE,"SPEAKERPHONE USAGE, ReportType 0x%04x", ReportType));
                break;


            default:
                // Key Pad buttons
                if ( (Usage >= HID_USAGE_TELEPHONY_PHONE_KEY_0) && 
                     (Usage <= HID_USAGE_TELEPHONY_PHONE_KEY_D) )
                {
                    pPhone->dwReportTypes[Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0] |= ReportType;
                    LOG((PHONESP_TRACE,"PHONE_KEY_%d USAGE, ReportType 0x%04x",
                                Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0, ReportType));
                }
                else
                {  // Feature Buttons
                    DWORD Index;
                    if (LookupIndexForUsage(Usage, &Index) == ERROR_SUCCESS)
                    {
                        pPhone->dwReportTypes[Index] |= ReportType;
                        LOG((PHONESP_TRACE,"PHONE USAGE: 0x%04x, ReportType 0x%04x", 
                                            Usage, ReportType));
                    }
                    else
                    {
                        LOG((PHONESP_TRACE, "Unsupported PHONE USAGE: 0x%04x", Usage ));
                    } 

                }
                break;
            }
        }
        
    case HID_USAGE_PAGE_CONSUMER:
        {
            switch (Usage)
            {
            case HID_USAGE_CONSUMER_VOLUME:
                if ((Min == -1) && (Max == 1))
                {
                    // Phone has volume controls
                    pPhone->dwReportTypes[PHONESP_FEATURE_VOLUMEUP] |= ReportType;
                    pPhone->dwReportTypes[PHONESP_FEATURE_VOLUMEDOWN] |= ReportType;
                    pPhone->dwVolume |= ReportType;
                    LOG((PHONESP_TRACE,"VOLUME USAGE, ReportType 0x%04x", ReportType));
                }
                break;          
            }
        }
    }

    //LOG((PHONESP_TRACE, "InitPhoneAttribFromUsage - exit"));
}

/**************************InitPhoneAttribFromUsage - end ********************/

/******************************************************************************
    InitUsage

    This function takes the usage retrieved in the input report and updates the
    device status and sends an appropriate Phone event

    Arguments:
        PPHONESP_PHONE_INFO pPhone - Pointer to phone whose input report is 
                                     received
        USAGE               Usage  - The usage whose value is recieved
        BOOL                bON    - The status of the usage Received

    Returns VOID
******************************************************************************/

VOID
InitUsage (
           PPHONESP_PHONE_INFO pPhone,
           USAGE     Usage,
           BOOL      bON
          )
{
   
    DWORD Index;
    DWORD dwMode;

    LOG((PHONESP_TRACE, "InitUsage - enter"));

    switch (Usage)
    {
       case HID_USAGE_TELEPHONY_HOOKSWITCH:
        if (bON)
        {
            LOG((PHONESP_TRACE, "HANDSET OFFHOOK"));
            pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_MICSPEAKER;
        }
        else
        {
            LOG((PHONESP_TRACE, "HANDSET ONHOOK"));
            pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;
        }
        break;

    case HID_USAGE_TELEPHONY_SPEAKER_PHONE:
        if (bON == TRUE)
        {
            pPhone->bSpeakerHookSwitchButton = TRUE;
        }
        else
        {
            pPhone->bSpeakerHookSwitchButton = FALSE;
        }
        break;
   
    default:
        // Feature & Phone Key Buttons

        // Find the index of the usage
        if (LookupIndexForUsage(Usage, &Index) == ERROR_SUCCESS)
        {
            PPHONESP_BUTTONINFO pButtonInfo;

            //
            // The index retrieved when indexed in the dwButtonIds array of the 
            // phone structure gives the Button ID. With this ID get the Button 
            // Info for that button id
            //
            pButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[Index]);
        
            if(pButtonInfo != NULL)
            {
                if(bON == TRUE)
                {
                    // This feature button is currently on
                    LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pButtonInfo->szButtonText ));
                    pButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;
                }
                else
                {
                    // This feature button is currently off
                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pButtonInfo->szButtonText ));
                    pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;
                }
            }                    

        }
        break;
    }

    LOG((PHONESP_TRACE, "InitUsage - exit"));

}
/*************************InitUsage - end*************************************/

/******************************************************************************
    LookupIndexForUsage

    This function retrieves the index of the usage provided. Only the Feature 
    Button usages are present in this Lookup Table. Therefore only the index
    for the feature buttons can be retrieved.

    Arguments:
        DWORD   Usage - THe usage whose index is to be retrieved
        DWORD  *Index - The Index of the Usage retrieved

    Returns LONG:
        ERROR_SUCCESS - if the usage was found in the table
        ERROR_INVALID_DATA - if the usage was not found in the Lookup Table

******************************************************************************/
LONG
LookupIndexForUsage(
                    IN  DWORD  Usage,
                    OUT DWORD  *Index
                    )
{ 
    DWORD cnt;

    for(cnt = 0; cnt < PHONESP_NUMBER_FEATURE_BUTTONS; cnt++)
    {
        if(gdwLookupFeatureIndex[cnt].Usage == Usage)
        {
           *Index = gdwLookupFeatureIndex[cnt].Index;
           return ERROR_SUCCESS;
        }
    }
    return ERROR_INVALID_DATA;
}
/***************LookupIndexForUsage - end*************************************/

/******************************************************************************
    PHONESP_LoadString:
       
    This function loads the string from the String Table.


    Arguments:
        IN UINT ResourceID - Specifies the integer identifier of the string to 
                             be loaded from the resource table
        OUT WCHAR *szBuffer- The pointer to the Buffer that contains the string

    Returns LONG
    ERROR_SUCCESS if operation successful else 
    MY_NOMEM if operation failed because of not enough memory. 
    MY_RESOURCENOTFOUND - if the resource was not found in the string table
******************************************************************************/

LPWSTR
PHONESP_LoadString(
             IN UINT ResourceID,
             PLONG lResult
            )

{
    DWORD dwNumBytes;
    DWORD dwNumChars;
    DWORD dwBufferChars = 100;

    WCHAR *wszBuffer; 
    WCHAR *szBuffer;   

    while (1)
    {
        if (! ( wszBuffer = (WCHAR *) MemAlloc(dwBufferChars * sizeof(WCHAR))))
        {
            LOG((PHONESP_ERROR,"PHONESP_LoadString - Not enough Memory"));
            *lResult = ERROR_OUTOFMEMORY;
            return (LPWSTR) NULL;
        }
        
        // load string into buffer
        dwNumChars = LoadString(
                            ghInst,
                            ResourceID,
                            wszBuffer,
                            dwBufferChars
                           );

        if( dwNumChars < dwBufferChars)
        {
            break;
        }

        // LoadString returns 0 in the dwNumChars if string resource does not exist
        if (dwNumChars == 0)
        { 
            MemFree(wszBuffer);
            *lResult = ERROR_INVALID_DATA;
            return (LPWSTR) NULL;
        }
        
        dwBufferChars *= 2;
        MemFree(wszBuffer);
    }
              
    // determine memory needed
    dwNumBytes = (dwNumChars + 1) * sizeof(WCHAR);

    // allocate memory for unicode string
    if ( ! ( szBuffer = (WCHAR *) MemAlloc(dwNumBytes) ) )
    {
        MemFree(wszBuffer);
        LOG((PHONESP_ERROR,"PHONESP_LoadString - Not enough Memory"));
        *lResult = ERROR_OUTOFMEMORY;
        return (LPWSTR) NULL;
    }
   
    // copy loaded string into buffer
    CopyMemory (
                szBuffer,
                wszBuffer,
                dwNumBytes
               );
  
    MemFree(wszBuffer);
    *lResult = ERROR_SUCCESS;

    return (LPWSTR) szBuffer;
}
/*******************MyLoadString - end ***************************************/



/******************************************************************************
    ReportUsage

    This function takes the usage retrieved in the input report and updates the
    device status and sends an appropriate Phone event

    Arguments:
        PPHONESP_PHONE_INFO pPhone - Pointer to phone whose input report is 
                                     received
        USAGE               Usage  - The usage whose value is recieved
        BOOL                bON    - The status of the usage Received

    Returns VOID
******************************************************************************/

VOID
ReportUsage (
              PPHONESP_PHONE_INFO pPhone,
              USAGE     UsagePage,
              USAGE     Usage,
              ULONG     Value
            )
{
   
    DWORD Index;

    //LOG((PHONESP_TRACE, "ReportUsage - enter"));

    EnterCriticalSection(&csAllPhones);
    
    if ( ! ( pPhone && pPhone->htPhone ) )
    { 
        LeaveCriticalSection(&csAllPhones);
        return; // exception handling
    }
    
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    switch (UsagePage)
    {
    case HID_USAGE_PAGE_TELEPHONY:
        {
            switch (Usage)
            {
            case HID_USAGE_TELEPHONY_HOOKSWITCH:
                if (Value == TRUE)
                {
                    if (pPhone->dwHandsetHookSwitchMode != PHONEHOOKSWITCHMODE_MICSPEAKER)
                    {
                        LOG((PHONESP_TRACE, "HANDSET OFFHOOK "));
                        pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_MICSPEAKER;

                        SendPhoneEvent(
                               pPhone, 
                               PHONE_STATE, 
                               PHONESTATE_HANDSETHOOKSWITCH, 
                               PHONEHOOKSWITCHMODE_MICSPEAKER,
                               0
                              );
                    }
                }
                else
                {
                    if (pPhone->dwHandsetHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK)
                    {
                        LOG((PHONESP_TRACE, "HANDSET ONHOOK"));
                        pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;

                        SendPhoneEvent(
                               pPhone, 
                               PHONE_STATE, 
                               PHONESTATE_HANDSETHOOKSWITCH, 
                               PHONEHOOKSWITCHMODE_ONHOOK,
                               0
                              );
                    }
                }
                break;

            case HID_USAGE_TELEPHONY_SPEAKER_PHONE:
                if (Value == TRUE)
                {
                    if (pPhone->bSpeakerHookSwitchButton == FALSE)
                    {
                        pPhone->bSpeakerHookSwitchButton = TRUE;

                        if (pPhone->dwSpeakerHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK)
                        {
                            LOG((PHONESP_TRACE, "SPEAKER ONHOOK"));
                            pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;

                            SendPhoneEvent(
                                       pPhone, 
                                       PHONE_STATE, 
                                       PHONESTATE_SPEAKERHOOKSWITCH, 
                                       PHONEHOOKSWITCHMODE_ONHOOK,
                                       0
                                      );
                        }
                        else
                        {
                            LOG((PHONESP_TRACE, "SPEAKER OFFHOOK "));
                            pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_MICSPEAKER;

                            SendPhoneEvent(
                                       pPhone, 
                                       PHONE_STATE, 
                                       PHONESTATE_SPEAKERHOOKSWITCH, 
                                       PHONEHOOKSWITCHMODE_MICSPEAKER,
                                       0
                                      );
                        }
                    }
                }
                else
                {
                    pPhone->bSpeakerHookSwitchButton = FALSE;
                }        
                break;
   
                // Feature Buttons with on-off control
            case HID_USAGE_TELEPHONY_HOLD:
            case HID_USAGE_TELEPHONY_PARK:
            case HID_USAGE_TELEPHONY_FORWARD_CALLS:
            case HID_USAGE_TELEPHONY_CONFERENCE:
            case HID_USAGE_TELEPHONY_PHONE_MUTE:
            case HID_USAGE_TELEPHONY_DONOTDISTURB:
            case HID_USAGE_TELEPHONY_SEND:
        
                if (LookupIndexForUsage(Usage, &Index) == ERROR_SUCCESS)
                {
                    PPHONESP_BUTTONINFO pButtonInfo;

                    pButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[Index]);

                    if (pButtonInfo != NULL)
                    {
                        if (Value == TRUE)
                        {
                            if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                            {
                                LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pButtonInfo->szButtonText));
                                pButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;

                                SendPhoneEvent(
                                               pPhone, 
                                               PHONE_BUTTON, 
                                               pPhone->dwButtonIds[Index], 
                                               PHONEBUTTONMODE_FEATURE,
                                               PHONEBUTTONSTATE_DOWN
                                              );
                            }
                        }
                        else
                        {
                            if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                            {
                                LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pButtonInfo->szButtonText));
                                pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                SendPhoneEvent(
                                               pPhone, 
                                               PHONE_BUTTON, 
                                               pPhone->dwButtonIds[Index], 
                                               PHONEBUTTONMODE_FEATURE,
                                               PHONEBUTTONSTATE_UP
                                              );
                            }
                        }
                    }                                           
                }
                break;

            default:
        
                // Key Pad buttons
                if ( (pPhone->bKeyPad) &&
                     (Usage >= HID_USAGE_TELEPHONY_PHONE_KEY_0) &&
                     (Usage <= HID_USAGE_TELEPHONY_PHONE_KEY_D) )
                {
                    PPHONESP_BUTTONINFO pButtonInfo;
        
                    pButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0]);

                    if (pButtonInfo != NULL)
                    {
                        if (Value == TRUE)
                        {
                            if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                            {
                                if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pButtonInfo->szButtonText));
                                    pButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0, 
                                                   PHONEBUTTONMODE_KEYPAD,
                                                   PHONEBUTTONSTATE_DOWN
                                                  );
                                }
                            }
                        }
                        else
                        {
                            if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                            {
                                LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pButtonInfo->szButtonText));
                                pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                SendPhoneEvent(
                                               pPhone, 
                                               PHONE_BUTTON, 
                                               Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0,
                                               PHONEBUTTONMODE_KEYPAD,
                                               PHONEBUTTONSTATE_UP
                                              );
                            }
                        }
                    }
                }
                else
                {   // Feature Buttons - with one-shot control
                    if (LookupIndexForUsage(Usage, &Index) == ERROR_SUCCESS)
                    {
                        if (Value == TRUE)
                        {
                            PPHONESP_BUTTONINFO pButtonInfo;
        
                            pButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[Index]);

                            if ( pButtonInfo != NULL )
                            {
                                LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pButtonInfo->szButtonText));

                                SendPhoneEvent(
                                       pPhone, 
                                       PHONE_BUTTON, 
                                       pPhone->dwButtonIds[Index], 
                                       PHONEBUTTONMODE_FEATURE,
                                       PHONEBUTTONSTATE_DOWN
                                      );

                                LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pButtonInfo->szButtonText));

                                SendPhoneEvent(
                                       pPhone, 
                                       PHONE_BUTTON, 
                                       pPhone->dwButtonIds[Index], 
                                       PHONEBUTTONMODE_FEATURE,
                                       PHONEBUTTONSTATE_UP
                                      );
                            }
                        }
                    }
                    else
                    {
                        LOG((PHONESP_TRACE, "Unsupported PHONE USAGE: 0x%04x",Usage));
                    }
                }
                break;
            }
        }
        break;

    case HID_USAGE_PAGE_CONSUMER:
        {
            switch (Usage)
            {
            case HID_USAGE_CONSUMER_VOLUME:
                {
                    if (pPhone->dwVolume)
                    {
                        PPHONESP_BUTTONINFO pUpButtonInfo;
                        PPHONESP_BUTTONINFO pDownButtonInfo;

                        pUpButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEUP]);
                        pDownButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEDOWN]);

                        if ((pUpButtonInfo != NULL) && (pDownButtonInfo != NULL))
                        {
                            switch (Value) // 2-bit signed
                            {
                            case 0x0:
                                if (pUpButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pUpButtonInfo->szButtonText));
                                    pUpButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEUP],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_UP
                                                  );
                                }

                                if (pDownButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pDownButtonInfo->szButtonText));
                                    pDownButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEDOWN],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_UP
                                                  );
                                }
                                break;
                            case 0x1:
                                if (pUpButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pUpButtonInfo->szButtonText));
                                    pUpButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEUP],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_DOWN
                                                  );
                                }

                                if (pDownButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pDownButtonInfo->szButtonText));
                                    pDownButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEDOWN],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_UP
                                                  );
                                }
                                break;
                            case 0x3:
                                if (pUpButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pUpButtonInfo->szButtonText));
                                    pUpButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEUP],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_UP
                                                  );
                                }

                                if (pDownButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pDownButtonInfo->szButtonText));
                                    pDownButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEDOWN],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_DOWN
                                                  );
                                }
                                break;
                            }                        
                        }
                        break;
                    }
                }
            }
        }
        break;
    }

    LeaveCriticalSection(&pPhone->csThisPhone);

    //LOG((PHONESP_TRACE, "ReportUsage - exit"));

}
/**********************ReportUsage - end**************************************/


/******************************************************************************
    SendPhoneEvent:

    This function determines whether TAPI had requested the receipt of this 
    message and if requested, then sends the phone device message .

    Arguments:
        PMYPHONE pPhone  -  The pointer to the phone 
        DWORD     dwMsg   -  Type of Phone Event such as PHONE_BUTTON, etc
        ULONG_PTR Param1  -  Details relating to the Phone Event 
        ULONG_PTR Param2  -         "
        ULONG_PTR Param3  -         "

    Returns VOID

******************************************************************************/
VOID
SendPhoneEvent(
               PPHONESP_PHONE_INFO   pPhone,
               DWORD                 dwMsg,
               ULONG_PTR             Param1,
               ULONG_PTR             Param2,
               ULONG_PTR             Param3
              )
{
    LOG((PHONESP_TRACE, "SendPhoneEvent - enter"));

    switch (dwMsg)
    {
    case PHONE_BUTTON:
        
        if ( ((Param2) & pPhone->dwButtonModesMsgs ) && 
             ((Param3) & pPhone->dwButtonStateMsgs) )
        {
            (*(pPhone->lpfnPhoneEventProc))(
                                     pPhone->htPhone,
                                     dwMsg,
                                     Param1,
                                     Param2,
                                     Param3
                                    );
        }
        break;

    case PHONE_REMOVE:
        (*(glpfnPhoneCreateProc))(
                                 0,
                                 dwMsg,
                                 Param1,
                                 Param2,
                                 Param3
                                );
        break;

    case PHONE_CREATE:
        (*(glpfnPhoneCreateProc))(
                                 0,
                                 dwMsg,
                                 Param1,
                                 Param2,
                                 Param3
                                );
    
        break;

    case PHONE_STATE:
        if (Param1 & pPhone->dwPhoneStateMsgs)
        {
            (*(pPhone->lpfnPhoneEventProc))(
                                     pPhone->htPhone,
                                     dwMsg,
                                     Param1,
                                     Param2,
                                     Param3
                                    );
        }
        break;

    default:
        break;
    }

    LOG((PHONESP_TRACE, "SendPhoneEvent - exit"));
}
/****************************SendPhoneEvent - end*****************************/

/******************************************************************************
    SendOutputReport

    This function forms an output report for the usage provided and sends it to
    the device

    Arguments:
        PHID_DEVICE pHidDevice - The hid device to which the output report is 
                                 be sent
        USAGE       Usage      - The Usage for which the output report is to be
                                 sent
        BOOL        bSet       - Whether the usage has to be set or reset

    Returns LONG:
        ERROR_SUCCESS if the function succeeded
        ERROR_INVALID_DATA on error       

******************************************************************************/

LONG
SendOutputReport(
                 PHID_DEVICE pHidDevice,
                 USAGE       Usage,
                 BOOL        bSet
                )
{
    HID_DATA  HidData;
    PUSAGE UsageList = &Usage;
    LONG NumUsages = 1;
    
    if ( GetReportID(pHidDevice, Usage, &HidData) == ERROR_SUCCESS)
    {
        NTSTATUS Result;

        memset ( pHidDevice->OutputReportBuffer, 
                (UCHAR) 0, 
                pHidDevice->Caps.OutputReportByteLength
                );

        if (HidData.IsButtonData)
        {
            if (bSet)
            {
                Result = HidP_SetUsages (
                                         HidP_Output,
                                         HidData.UsagePage,
                                         0,
                                         UsageList,
                                         &NumUsages,
                                         pHidDevice->Ppd,
                                         pHidDevice->OutputReportBuffer,
                                         pHidDevice->Caps.OutputReportByteLength
                                        );
                
                if(Result != HIDP_STATUS_SUCCESS)
                {
                    return ERROR_INVALID_DATA;
                }
            }
            else
            {               
                Result = HidP_UnsetUsages (
                                HidP_Output,
                                HidData.UsagePage,
                                0,
                                UsageList,
                                &NumUsages,
                                pHidDevice->Ppd,
                                pHidDevice->OutputReportBuffer,
                                pHidDevice->Caps.OutputReportByteLength
                                );
                if(Result != HIDP_STATUS_SUCCESS)
                {
                    return ERROR_INVALID_DATA;
                }

            }
       }
       else
       {
            Result = HidP_SetUsageValue (
                                HidP_Output,
                                HidData.UsagePage,
                                0,
                                Usage,
                                HidData.ValueData.Value,
                                pHidDevice->Ppd,
                                pHidDevice->OutputReportBuffer,
                                pHidDevice->Caps.OutputReportByteLength
                            );
            if(Result != HIDP_STATUS_SUCCESS)
            {
                return ERROR_INVALID_DATA;
            }
            
        }
       
        Write(pHidDevice);
    }
    else
    {
        return ERROR_INVALID_DATA;
    }

    return ERROR_SUCCESS;
}
/************************SendOutputReport - end*******************************/


/******************************************************************************
    ShowData

    This function is called by the queue service thread when the request queued
    is an input report. This function retrieves the Usages present in this 
    structure and passes them on to ReportUsage which performs appropriate 
    actions.

******************************************************************************/
VOID 
CALLBACK
ShowData(
         PPHONESP_FUNC_INFO pAsyncFuncInfo 
        )
{

    PPHONESP_PHONE_INFO pPhone = (PPHONESP_PHONE_INFO) pAsyncFuncInfo->dwParam1;    
    BOOL bButton;

    if( (DWORD) pAsyncFuncInfo->dwParam2 == PHONESP_BUTTON)
    {
        USAGE  UsagePage = (USAGE) pAsyncFuncInfo->dwParam3;
        USAGE  UsageMin = (USAGE) pAsyncFuncInfo->dwParam4;
        USAGE  UsageMax = (USAGE) pAsyncFuncInfo->dwParam5;
        DWORD  MaxUsageLength = (DWORD) pAsyncFuncInfo->dwParam6;
        PUSAGE Usages = (PUSAGE) pAsyncFuncInfo->dwParam7;
        USAGE  Usage;

        for ( Usage = UsageMin; Usage <= UsageMax; Usage++ )
        {
            DWORD i;

            for ( i = 0; i < MaxUsageLength; i++ )
            {
                 if ( Usage == Usages[i] )
                 {
                     //LOG((PHONESP_TRACE,"ShowData - UsagePage 0x%04x Usage 0x%04x BUTTON DOWN", UsagePage, Usage));
                     ReportUsage(pPhone, UsagePage, Usage, TRUE); 
                     break;
                 }
            }

            if ( i == MaxUsageLength )
            {
                //LOG((PHONESP_TRACE,"ShowData - UsagePage 0x%04x Usage 0x%04x BUTTON UP", UsagePage, Usage));
                ReportUsage(pPhone, UsagePage, Usage, FALSE);
            }
        }
        MemFree(Usages);
    }
    else
    {
        USAGE UsagePage = (USAGE) pAsyncFuncInfo->dwParam3;
        USAGE Usage = (USAGE) pAsyncFuncInfo->dwParam4;
        ULONG Value = (ULONG) pAsyncFuncInfo->dwParam5;

        //LOG((PHONESP_TRACE,"ShowData - UsagePage 0x%04x Usage 0x%04x VALUE %d", UsagePage, Usage, Value));
        ReportUsage(pPhone, UsagePage, Usage, Value);
    }
}
/*******************ShowData - end********************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\resource.h ===
/* Copyright (c) 1999  Microsoft Corporation */

#define IDS_PROVIDER_INFO       201
#define IDS_PHONE_INFO          202
#define IDS_PHONE_NAME          203

#define IDS_BUTTON_FLASH           116
#define IDS_BUTTON_HOLD            117
#define IDS_BUTTON_REDIAL          118
#define IDS_BUTTON_TRANSFER        119
#define IDS_BUTTON_DROP           120
#define IDS_BUTTON_PARK            121
#define IDS_BUTTON_FORWARD         122
#define IDS_BUTTON_LINE              123    
#define IDS_BUTTON_CONFERENCE    124
#define IDS_BUTTON_RING_SELECT    125
#define IDS_BUTTON_MUTE            126
#define IDS_BUTTON_CALLERID        127
#define IDS_BUTTON_DONOTDISTURB    128
#define IDS_BUTTON_SEND            129
#define IDS_BUTTON_VOLUMEUP        130
#define IDS_BUTTON_VOLUMEDOWN      131

#define IDS_PHONE_KEY_0            100     
#define IDS_PHONE_KEY_1           101
#define IDS_PHONE_KEY_2           102    
#define IDS_PHONE_KEY_3           103
#define IDS_PHONE_KEY_4           104
#define IDS_PHONE_KEY_5           105
#define IDS_PHONE_KEY_6           106
#define IDS_PHONE_KEY_7           107
#define IDS_PHONE_KEY_8           108
#define IDS_PHONE_KEY_9           109    
#define IDS_PHONE_KEY_STAR         110
#define IDS_PHONE_KEY_POUND        111
#define IDS_PHONE_KEY_A            112
#define IDS_PHONE_KEY_B            113
#define IDS_PHONE_KEY_C            114
#define IDS_PHONE_KEY_D            115
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\report.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    report.c

Abstract:

    This module contains the code for translating HID reports to something
    useful.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <stdlib.h>
#include <wtypes.h>
#include "hidsdi.h"
#include "hid.h"
#include "mylog.h"
#include "mymem.h"


BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

// Haven't used this with Write .. let's see whether i need this with set/get feature
BOOL
PackReport (
   OUT      PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );



VOID CALLBACK 
WriteIOCompletionRoutine (
                         DWORD dwErrorCode,
                         DWORD dwNumberofBytesTransferrred,
                         LPOVERLAPPED lpOverlapped
                         )
{
    PHID_DEVICE pHidDevice = (PHID_DEVICE) lpOverlapped->hEvent;

    LOG((PHONESP_TRACE, "WriteIOCompletionRoutine - enter"));

    if(dwErrorCode)
    {
        LOG((PHONESP_ERROR, "Error occured while writing" ));
    }

    MemFree(lpOverlapped);
    LOG((PHONESP_TRACE, "WriteIOCompletionRoutine - exit"));
}



BOOL
Write (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, take the information in the HID_DATA array
   pack it into multiple write reports and send each report to the HID device
--*/
{
    DWORD        bytesWritten;
    PHID_DATA    pData;
    ULONG        Index;
    BOOL         Status;
    BOOL         WriteStatus;
    LPOVERLAPPED lpOverlapped;

    LOG((PHONESP_TRACE, "Write - enter"));

    lpOverlapped = (LPOVERLAPPED) MemAlloc (sizeof(OVERLAPPED));

    if (lpOverlapped == NULL)
    {
        LOG((PHONESP_ERROR,"Write - out of memory"));
        return FALSE;
    }

    lpOverlapped->Offset = 0;
    lpOverlapped->OffsetHigh = 0;
    lpOverlapped->hEvent = (HANDLE) HidDevice;

    LOG((PHONESP_TRACE,"Write - Report Packed"));
    WriteStatus = WriteFileEx (HidDevice->HidDevice,
                                  HidDevice->OutputReportBuffer,
                                  HidDevice->Caps.OutputReportByteLength,
                                  lpOverlapped,
                                  &WriteIOCompletionRoutine); 

    SleepEx(INFINITE, TRUE);
    LOG((PHONESP_TRACE, "Write - Report sent"));

    LOG((PHONESP_TRACE, "Write - exit"));

    return TRUE;
}

BOOL
SetFeature (
    PHID_DEVICE    HidDevice
    )
/*++
RoutineDescription:
Given a struct _HID_DEVICE, take the information in the HID_DATA array
pack it into multiple reports and send it to the hid device via HidD_SetFeature()
--*/
{
    PHID_DATA pData;
    ULONG     Index;
    BOOL      Status;
    BOOL      FeatureStatus;
    DWORD     ErrorCode;
    /*
    // Begin by looping through the HID_DEVICE's HID_DATA structure and setting
    //   the IsDataSet field to FALSE to indicate that each structure has
    //   not yet been set for this SetFeature() call.
    */

    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {
        pData -> IsDataSet = FALSE;
    }

    /*
    // In setting all the data in the reports, we need to pack a report buffer
    //   and call WriteFile for each report ID that is represented by the 
    //   device structure.  To do so, the IsDataSet field will be used to 
    //   determine if a given report field has already been set.
    */

    Status = TRUE;

    pData = HidDevice -> FeatureData;
    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {

        if (!pData -> IsDataSet) {

            /*
            // Package the report for this data structure.  PackReport will
            //    set the IsDataSet fields of this structure and any other 
            //    structures that it includes in the report with this structure
            */

            PackReport (HidDevice->FeatureReportBuffer,
                     HidDevice->Caps.FeatureReportByteLength,
                     HidP_Feature,
                     pData,
                     HidDevice->FeatureDataLength - Index,
                     HidDevice->Ppd);

            /*
            // Now a report has been packaged up...Send it down to the device
            */

            FeatureStatus =(HidD_SetFeature (HidDevice->HidDevice,
                                          HidDevice->FeatureReportBuffer,
                                          HidDevice->Caps.FeatureReportByteLength));

            ErrorCode = GetLastError();

            Status = Status && FeatureStatus;
        }
    }
    return (Status);
}

BOOL
GetFeature (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, fill in the feature data structures with
   all features on the device.  May issue multiple HidD_GetFeature() calls to
   deal with multiple report IDs.
--*/
{
    ULONG     Index;
    PHID_DATA pData;
    BOOL      FeatureStatus;
    BOOL      Status;

    /*
    // As with writing data, the IsDataSet value in all the structures should be
    //    set to FALSE to indicate that the value has yet to have been set
    */

    LOG((PHONESP_TRACE,"GetFeature - enter"));
    pData = HidDevice->FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        pData -> IsDataSet = FALSE;
    }

    /*
    // Next, each structure in the HID_DATA buffer is filled in with a value
    //   that is retrieved from one or more calls to HidD_GetFeature.  The 
    //   number of calls is equal to the number of reportIDs on the device
    */

    Status = TRUE; 
    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {
       
        /*
        // If a value has yet to have been set for this structure, build a report
        //    buffer with its report ID as the first byte of the buffer and pass
        //    it in the HidD_GetFeature call.  Specifying the report ID in the
        //    first specifies which report is actually retrieved from the device.
        //    The rest of the buffer should be zeroed before the call
        */
        if (!pData -> IsDataSet) {

            memset(HidDevice -> FeatureReportBuffer, 0x00, HidDevice->Caps.FeatureReportByteLength);

            HidDevice -> FeatureReportBuffer[0] = (UCHAR) pData -> ReportID;

            FeatureStatus = HidD_GetFeature ( HidDevice->HidDevice,
                                              HidDevice->FeatureReportBuffer,
                                              HidDevice->Caps.FeatureReportByteLength);

            /*
            // If the return value is TRUE, scan through the rest of the HID_DATA
            //    structures and fill whatever values we can from this report
            */


            if (FeatureStatus)
            {
                FeatureStatus = UnpackReport ( HidDevice->FeatureReportBuffer,
                                           HidDevice->Caps.FeatureReportByteLength,
                                           HidP_Feature,
                                           HidDevice->FeatureData,
                                           HidDevice->FeatureDataLength,
                                           HidDevice->Ppd
                                         );
            }
            else
            {
                LOG((PHONESP_ERROR, "GetFeature - HidD_GetFeature failed %d", GetLastError()));
            }

            Status = Status && FeatureStatus;
        }
   }

   LOG((PHONESP_TRACE, "GetFeature - exit"));
   
   return Status;
}


BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:
   Given ReportBuffer representing a report from a HID device where the first
   byte of the buffer is the report ID for the report, extract all the HID_DATA
   in the Data list from the given report.
--*/
{
    ULONG       numUsages; // Number of usages returned from GetUsages.
    ULONG       i;
    UCHAR       reportID;
    ULONG       Index;
    ULONG       nextUsage;

    reportID = ReportBuffer[0];

    for (i = 0; i < DataLength; i++, Data++) {

        if (reportID == Data->ReportID) {

            if (Data->IsButtonData) {
                numUsages = Data->ButtonData.MaxUsageLength;
                Data->Status = HidP_GetUsages (
                                               ReportType,
                                               Data->UsagePage,
                                               0, // All collections
                                               Data->ButtonData.Usages,
                                               &numUsages,
                                               Ppd,
                                               ReportBuffer,
                                               ReportBufferLength);


                //
                // Get usages writes the list of usages into the buffer
                // Data->ButtonData.Usages newUsage is set to the number of usages
                // written into this array.
                // A usage cannot not be defined as zero, so we'll mark a zero
                // following the list of usages to indicate the end of the list of
                // usages
                //
                // NOTE: One anomaly of the GetUsages function is the lack of ability
                //        to distinguish the data for one ButtonCaps from another
                //        if two different caps structures have the same UsagePage
                //        For instance:
                //          Caps1 has UsagePage 07 and UsageRange of 0x00 - 0x167
                //          Caps2 has UsagePage 07 and UsageRange of 0xe0 - 0xe7
                //
                //        However, calling GetUsages for each of the data structs
                //          will return the same list of usages.  It is the 
                //          responsibility of the caller to set in the HID_DEVICE
                //          structure which usages actually are valid for the
                //          that structure. 
                //      

                /*
                // Search through the usage list and remove those that 
                //    correspond to usages outside the define ranged for this
                //    data structure.
                */
                
                for (Index = 0, nextUsage = 0; Index < numUsages; Index++) {

                    if (Data -> ButtonData.UsageMin <= Data -> ButtonData.Usages[Index] && 
                            Data -> ButtonData.Usages[Index] <= Data -> ButtonData.UsageMax) {

                        Data -> ButtonData.Usages[nextUsage++] = Data -> ButtonData.Usages[Index];
                        
                    }
                }

                if (nextUsage < Data -> ButtonData.MaxUsageLength) {
                    Data->ButtonData.Usages[nextUsage] = 0;
                }
            }
            else {
                Data->Status = HidP_GetUsageValue (
                                                ReportType,
                                                Data->UsagePage,
                                                0,               // All Collections.
                                                Data->ValueData.Usage,
                                                &Data->ValueData.Value,
                                                Ppd,
                                                ReportBuffer,
                                                ReportBufferLength);

                Data->Status = HidP_GetScaledUsageValue (
                                                       ReportType,
                                                       Data->UsagePage,
                                                       0, // All Collections.
                                                       Data->ValueData.Usage,
                                                       &Data->ValueData.ScaledValue,
                                                       Ppd,
                                                       ReportBuffer,
                                                       ReportBufferLength);
            } 
            Data -> IsDataSet = TRUE;
        }
    }
    return (TRUE);
}


BOOL
PackReport (
   OUT      PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:
   This routine takes in a list of HID_DATA structures (DATA) and builds 
      in ReportBuffer the given report for all data values in the list that 
      correspond to the report ID of the first item in the list.  

   For every data structure in the list that has the same report ID as the first
      item in the list will be set in the report.  Every data item that is 
      set will also have it's IsDataSet field marked with TRUE.

   A return value of FALSE indicates an unexpected error occurred when setting
      a given data value.  The caller should expect that assume that no values
      within the given data structure were set.

   A return value of TRUE indicates that all data values for the given report
      ID were set without error.
--*/
{
    ULONG       numUsages; // Number of usages to set for a given report.
    ULONG       i;
    ULONG       CurrReportID;

    /*
    // All report buffers that are initially sent need to be zero'd out
    */

    memset (ReportBuffer, (UCHAR) 0, ReportBufferLength);

    /*
    // Go through the data structures and set all the values that correspond to
    //   the CurrReportID which is obtained from the first data structure 
    //   in the list
    */

    CurrReportID = Data -> ReportID;

    for (i = 0; i < DataLength; i++, Data++) {

        /*
        // There are two different ways to determine if we set the current data
        //    structure: 
        //    1) Store the report ID were using and only attempt to set those
        //        data structures that correspond to the given report ID.  This
        //        example shows this implementation.
        //
        //    2) Attempt to set all of the data structures and look for the 
        //        returned status value of HIDP_STATUS_INVALID_REPORT_ID.  This 
        //        error code indicates that the given usage exists but has a 
        //        different report ID than the report ID in the current report 
        //        buffer
        */

        if (Data -> ReportID == CurrReportID) {

            if (Data->IsButtonData) {
             numUsages = Data->ButtonData.MaxUsageLength;
             Data->Status = HidP_SetUsages (
                              ReportType,
                              Data->UsagePage,
                              0, // All collections
                              Data->ButtonData.Usages,
                              &numUsages,
                              Ppd,
                              ReportBuffer,
                              ReportBufferLength);
            } else {
             Data->Status = HidP_SetUsageValue (
                                 ReportType,
                                 Data->UsagePage,
                                 0, // All Collections.
                                 Data->ValueData.Usage,
                                 Data->ValueData.Value,
                                 Ppd,
                                 ReportBuffer,
                                 ReportBufferLength);
            }

            if (HIDP_STATUS_SUCCESS != Data->Status)
            {
              return FALSE;
            }
        }
    }   

    /*
    // At this point, all data structures that have the same ReportID as the
    //    first one will have been set in the given report.  Time to loop 
    //    through the structure again and mark all of those data structures as
    //    having been set.
    */

    for (i = 0; i < DataLength; i++, Data++) {

        if (CurrReportID == Data -> ReportID) {

            Data -> IsDataSet = TRUE;

        }
   }
   return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\phonemgr\resource.h ===
/* Copyright (c) 1999  Microsoft Corporation */

#define IDD_MAINDLG                     101
#define IDC_STATUS                      102
#define IDC_DESTADDRESS			103
#define IDC_MAKECALL			104

#define IDC_STATIC1                     201
#define IDC_STATIC2                     202
#define IDC_STATIC3                     203
#define IDC_STATIC4                     204

#define IDI_ICON1			301
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\phonemgr\phonemgr.h ===
/* Copyright (c) 1999  Microsoft Corporation */

#include <windows.h>
#include <winuser.h>
#include <strmif.h>
#include <control.h>

#include <TCHAR.h>
#include <tapi3.h>
#include <mmsystem.h>
#include <string.h>

#include "resource.h"
#include "tones.h"
 
typedef struct _MYPHONE
{
    HPHONE             hPhone;

    DWORD              dwDevID;

    DWORD              dwPrivilege;

    DWORD              dwAPIVersion;

    HPHONEAPP          hPhoneApp;

    LONG               lRenderID;
    
    LONG               lCaptureID;

    DWORD              dwHandsetMode;

    LPWSTR             wszDialStr;

    CRITICAL_SECTION   csdial;

    CTonePlayer      * pTonePlayer;

} MYPHONE, *PMYPHONE;

static BYTE             pbData[WAVE_FILE_SIZE];

PMYPHONE                gpPhone;
DWORD                   gdwNumPhoneDevs;
HPHONEAPP               ghPhoneApp;
DWORD                   gdwAPIVersion = 0x00030000;

LPWSTR                  g_wszMsg, g_wszDest,g_szDialStr;
const WCHAR             *gszTapi30  = L"TAPI 3.0 Outgoing Call Demo Using Phone TSP";

HINSTANCE               ghInst;
HWND                    ghDlg = NULL;
ITTAPI *                gpTapi;
ITAddress *             gpAddress = NULL;
ITBasicCallControl *    gpCall;

///////////////////////////////////////////////////////////////////////////////

INT_PTR
CALLBACK
MainWndProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              );

VOID
CALLBACK
tapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    ULONG_PTR   CallbackInstance,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

void
SetStatusMessage(
                 LPWSTR pszMessage
                );

void
CreatePhone(
            PMYPHONE pPhone,
            DWORD dwDevID
            );

void
FreePhone(
            PMYPHONE pPhone
         );

PMYPHONE
GetPhone(
         HPHONE hPhone 
        );

PMYPHONE
GetPhoneByID (
              DWORD dwDevID
              );

void
RemovePhone (PMYPHONE pPhone);

PMYPHONE
AddPhone ();

void
DoMessage(
          LPWSTR pszMessage
         );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\phonemgr\phonemgr.cpp ===
/* Copyright (c) 1999  Microsoft Corporation */

#include "phonemgr.h"

#include <stdlib.h>
#include <stdio.h>
#include <wxdebug.h>

#ifdef _DBG
#define DEBUG(_x_) OutputDebugString(_x_)
#else
#define DEBUG(_x_)
#endif

ITRequest * g_pITRequest = NULL;


HRESULT InitAssistedTelephony(void)
{
    HRESULT     hr;

    //
    // Initialize COM.
    //

    printf("Initializing COM...\n");

    hr = CoInitializeEx(
                        NULL,
                        COINIT_MULTITHREADED
                       );

    if ( FAILED(hr) )
    {
        printf("CoInitialize failed - 0x%08x\n", hr);

        return hr;
    }

    //
    // Cocreate the assisted telephony object.
    //

    printf("Creating RequestMakeCall object...\n");

    hr = CoCreateInstance(
                          CLSID_RequestMakeCall,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITRequest,
                          (void **) & g_pITRequest
                         );

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance failed - 0x%08x\n", hr);

        return hr;
    }

    return S_OK;
}



HRESULT MakeAssistedTelephonyCall(WCHAR * wszDestAddress)
{
    HRESULT     hr;
    BSTR        bstrDestAddress = NULL;
    BSTR        bstrAppName     = NULL;
    BSTR        bstrCalledParty = NULL;
    BSTR        bstrComment     = NULL;

    bstrDestAddress = SysAllocString(
                                     wszDestAddress
                                    );

    if ( bstrDestAddress == NULL )
    {
        printf("SysAllocString failed");

        return E_OUTOFMEMORY;
    }


    //
    // Make a call.
    //

    printf("Calling ITRequest::MakeCall...\n");

    hr = g_pITRequest->MakeCall(
                                bstrDestAddress,
                                bstrAppName,
                                bstrCalledParty,
                                bstrComment
                               );

    SysFreeString(
              bstrDestAddress
             );
                                 
    if ( FAILED(hr) )
    {
        printf("ITRequest::MakeCall failed - 0x%08x\n", hr);

        return hr;
    }

    return S_OK;
}



int
WINAPI
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
    )
{
    MSG     msg;
    HWND    hwnd, hwndEdit;

    ghInst = hInstance;
   
    DialogBox(
              ghInst,
              MAKEINTRESOURCE(IDD_MAINDLG),
              NULL,
              MainWndProc
            );

    return 0;
}




INT_PTR
CALLBACK
MainWndProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              )
{

    LPCTSTR                 lszAppName = _T("Generate DialTone");
    DWORD                   dwNumDevs, i; 
    LONG                    lResult;
    PHONEINITIALIZEEXPARAMS initExParams;
    PMYPHONE pNextPhone;
    PWCHAR szAddressToCall;
    
    ghDlg = hDlg;

    switch (uMsg)
    {
    case WM_INITDIALOG:
    
        initExParams.dwTotalSize = sizeof (PHONEINITIALIZEEXPARAMS);
        initExParams.dwOptions = (DWORD) PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW;

        lResult = phoneInitializeEx(
                (LPHPHONEAPP)               &ghPhoneApp,
                (HINSTANCE)                 ghInst,
                (PHONECALLBACK)             tapiCallback,
                                            lszAppName,
                (LPDWORD)                   &dwNumDevs,
                (LPDWORD)                   &gdwAPIVersion,
                (LPPHONEINITIALIZEEXPARAMS) &initExParams
                );

        if (lResult == 0)
        {
            gdwNumPhoneDevs = dwNumDevs;
        }

        gpPhone = (PMYPHONE) LocalAlloc(LPTR,gdwNumPhoneDevs * sizeof(MYPHONE));

        g_wszMsg = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR) * 100 );
        g_wszDest = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR) * 100 );

        // Opening all the phones 
        for(i = 0, pNextPhone = gpPhone; i < gdwNumPhoneDevs; i++, pNextPhone++)
        {
            CreatePhone(pNextPhone, i);
        }

        SetStatusMessage(TEXT("Waiting for input from Phones"));

        g_szDialStr   = (LPWSTR) LocalAlloc(LPTR, 20 * sizeof(WCHAR));
        lstrcpy(g_szDialStr, TEXT("Dial Number: "));
        
        break;

    case WM_COMMAND:
        if ( LOWORD(wParam) == IDCANCEL )
        {
            //
            // The close box or Exit button was pressed.
            //
        
            SetStatusMessage(TEXT("End Application"));

            if(ghPhoneApp)
            {
                phoneShutdown(ghPhoneApp);
            }
            EndDialog( hDlg, 0 );

            LocalFree(g_szDialStr);
            LocalFree(g_wszMsg);
            LocalFree(g_wszDest);

            for( i=0; i<gdwNumPhoneDevs; i++ )
            {
                FreePhone(&gpPhone[i]);
            }
            LocalFree(gpPhone);

        }
        else if ( LOWORD(wParam) == IDC_MAKECALL )
        {
            //
            // The Make Call button was pressed.
            //


            //
            // Stop dialtone.
            // this only works for one phone.
            // Should be fine as we don't have
            // the window visible unless you have the phone off hook.
            //

            gpPhone[0].pTonePlayer->StopDialtone();

            //
            // Dial the dest address in the edit box.
            //
            
            const int ciMaxPhoneNumberSize = 400;
            WCHAR     wszPhoneNumber[ciMaxPhoneNumberSize];
            UINT      uiResult;
    
            uiResult = GetDlgItemText(
                ghDlg,                // handle to dialog box
                IDC_DESTADDRESS,      // identifier of control
                wszPhoneNumber,       // pointer to buffer for text (unicode)
                ciMaxPhoneNumberSize  // maximum size of string (in our buffer)
                );

            if ( uiResult == 0 )
            {
                DoMessage(L"Could not get dialog item text; not making call");
            }
            else
            {
                MakeAssistedTelephonyCall(wszPhoneNumber);
            }
        }

        break;

    default:
        break;
    }

    return 0;
}


VOID
CALLBACK
tapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    ULONG_PTR   CallbackInstance,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    PMYPHONE pPhone;
    DWORD    i;
    BOOL     bDialtone = FALSE;

    if (hDevice != NULL)
    {
        pPhone = GetPhone((HPHONE) hDevice);

        if (pPhone == NULL)
        {
            DEBUG(L"tapiCallback - phone not found\n");
            return;
        }        
    }

    switch (dwMsg)
    {
    case PHONE_STATE:
        DEBUG(L"PHONE_STATE\n");
        if (pPhone != NULL)
        {
            EnterCriticalSection(&pPhone->csdial);
            if ( Param1 == PHONESTATE_HANDSETHOOKSWITCH ) 
            {
                if ( Param2 != PHONEHOOKSWITCHMODE_ONHOOK ) // if off hook
                {
                    if ( FAILED(pPhone->pTonePlayer->StartDialtone()) )
                    {
                        DoMessage(L"StartDialTone Failed");
                    }


                    // ZoltanS: show the window now
                    ShowWindow(ghDlg, SW_SHOWNORMAL);


                    pPhone->dwHandsetMode = PHONEHOOKSWITCHMODE_MICSPEAKER;

                    lstrcpy(pPhone->wszDialStr,TEXT(""));
                    lstrcpy(g_wszMsg,TEXT("Generating Dialtone for phones: "));

                    for( i=0 ; i < gdwNumPhoneDevs; i++)
                    {
                        if ( gpPhone[i].pTonePlayer->IsInUse() )
                        {
                            wsprintf(g_wszDest,TEXT("%d"),i);
                            lstrcat(g_wszMsg,g_wszDest);
                        }
                    }
                
                    SetStatusMessage(g_wszMsg);
  
                }
                else // on hook
                {
                
                    pPhone->dwHandsetMode = PHONEHOOKSWITCHMODE_ONHOOK;
                    lstrcpy(pPhone->wszDialStr,TEXT(""));

                    if ( pPhone->pTonePlayer->IsInUse() )
                    {
                        pPhone->pTonePlayer->StopDialtone();
                    }

                    // ZoltanS: hide the window now
                    ShowWindow(ghDlg, SW_HIDE);


                    bDialtone = FALSE;
                    lstrcpy(g_wszMsg,TEXT("Generating Dialtone for phones: "));
                    for( i = 0 ; i < gdwNumPhoneDevs; i++ )
                    {
                        if ( gpPhone[i].pTonePlayer->DialtonePlaying() )
                        {
                            wsprintf(g_wszDest,TEXT("%d"),i);
                            lstrcat(g_wszMsg,g_wszDest);
                            bDialtone = TRUE;
                        }
                    }
                
                    if(!bDialtone)
                    {
                        SetStatusMessage(TEXT("Waiting for input from Phones"));
                    }
                    else
                    {
                        SetStatusMessage(g_wszMsg);
                    } 
                }
            }
            LeaveCriticalSection(&pPhone->csdial);
        }
        break;

    case PHONE_BUTTON:
        DEBUG(L"PHONE_BUTTON\n");
        if (pPhone != NULL)
        {
            EnterCriticalSection(&pPhone->csdial);
            if ( Param2 == PHONEBUTTONMODE_KEYPAD )
            {
                if (pPhone->dwHandsetMode != PHONEHOOKSWITCHMODE_ONHOOK)
                {
                    if ( Param3 == PHONEBUTTONSTATE_DOWN )
                    {
                        if ( pPhone->pTonePlayer->IsInUse() )
                        {
                            if ( ( (int)Param1 >= 0 ) && ( (int)Param1 <= 9 ) )
                            {   
                                //
                                // We have a dialed digit. Append it to the phone
                                // number we have so far.
                                //

                                wsprintf(g_wszDest, TEXT("%d"), Param1);

                                lstrcat(pPhone->wszDialStr, g_wszDest);

                                //
                                // Append the phone number so far to a standard prefix
                                // ("Phone number: ") and update the UI.
                                //

                                lstrcpy(g_wszMsg, g_szDialStr);

                                lstrcat(g_wszMsg,pPhone->wszDialStr);

                                SetStatusMessage(g_wszMsg);

                                //
                                // Generate a DTMF tone for this digit.
                                //

                                pPhone->pTonePlayer->GenerateDTMF( (long)Param1 );                    
                            }
                            else if ( Param1 == 10 )
                            {
                                //
                                // Generate a DTMF tone for "*". This will not count
                                // as part of the dialed number.
                                //

                                pPhone->pTonePlayer->GenerateDTMF( (long)Param1 );
                            }
                            else if ( Param1 == 11 )
                            {
                                //
                                // Generate a DTMF tone for "#". This will not count
                                // as part of the dialed number but it will tell us
                                // to make the call immediately.
                                //

                                pPhone->pTonePlayer->GenerateDTMF( (long)Param1 );

                                //
                                // Make the call.
                                //
                        
                                if ( S_OK == MakeAssistedTelephonyCall(pPhone->wszDialStr) )
                                {
                                    SetStatusMessage(L"Call created");
                                }
                                else
                                {
                                    SetStatusMessage(L"Failed to create the call");
                                }

                            }
                        } // if in use
                    } // if button down
                } // if off hook
            } // if keypad
            LeaveCriticalSection(&pPhone->csdial);
        }
        break; // case phone_button

    case PHONE_CLOSE:
        DEBUG(L"PHONE_CLOSE\n");
        if (pPhone != NULL)
        {
            EnterCriticalSection(&pPhone->csdial);

            phoneClose(pPhone->hPhone);   

            LeaveCriticalSection(&pPhone->csdial);
        }
        break;

    case PHONE_REMOVE:
        DEBUG(L"PHONE_REMOVE\n");
        pPhone = GetPhoneByID( (DWORD)Param1);

        if (pPhone != NULL)
        {
            FreePhone(pPhone);
            RemovePhone(pPhone);
        }
        break;

    case PHONE_CREATE:
        DEBUG(L"PHONE_CREATE\n");

        pPhone = AddPhone();
        CreatePhone(pPhone, (DWORD)Param1);
        break;

    default:
        break;
    }   
}

//////////////////////////////////////////////////////////////////
// SetStatusMessage
//////////////////////////////////////////////////////////////////

void
SetStatusMessage(
                 LPWSTR pszMessage
                )  
{
    SetDlgItemText(
                   ghDlg,
                   IDC_STATUS,
                   pszMessage
                  );
}

//////////////////////////////////////////////////////////////////
// CreatePhone
//////////////////////////////////////////////////////////////////

void
CreatePhone(
            PMYPHONE pPhone,
            DWORD dwDevID
            )
{
    LRESULT lResult;

    pPhone->hPhoneApp = ghPhoneApp;
    InitializeCriticalSection(&pPhone->csdial);

    // won't detect overrun if dialing more than 100 digits
    pPhone->wszDialStr   = (LPWSTR) LocalAlloc(LPTR, 100 * sizeof(WCHAR));
    pPhone->dwHandsetMode = PHONEHOOKSWITCHMODE_ONHOOK;

    lResult = phoneOpen(
                        ghPhoneApp,
                        dwDevID,
                        &pPhone->hPhone,
                        gdwAPIVersion,
                        0,
                        (DWORD_PTR) NULL,
                        PHONEPRIVILEGE_OWNER
                        );

    //
    // Save info about this phone that we can display later
    //
    
    pPhone->dwDevID      = dwDevID;
    pPhone->dwAPIVersion = gdwAPIVersion;
    pPhone->dwPrivilege  = PHONEPRIVILEGE_OWNER;

    DWORD dwBigBuffSize = sizeof(VARSTRING) + 
                          sizeof(DWORD) * 5;

    LPVOID pBuffer = LocalAlloc(LPTR,dwBigBuffSize);

    LPVARSTRING lpDeviceID = (LPVARSTRING) pBuffer;

    lpDeviceID->dwTotalSize = dwBigBuffSize;

    LPWSTR lpszDeviceClass;

    lpszDeviceClass = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR) * 20);
  
    lstrcpy(lpszDeviceClass, TEXT("wave/in"));

    lResult = phoneGetID(
                         pPhone->hPhone,          
                         lpDeviceID,  
                         lpszDeviceClass  
                        );

    if(lResult != 0)
    {
        pPhone->lCaptureID = WAVE_MAPPER;
    }
    else
    {
        CopyMemory(
                    &pPhone->lCaptureID,
                    (LPBYTE) lpDeviceID + lpDeviceID->dwStringOffset,
                    lpDeviceID->dwStringSize
                   );
    }

   
    lstrcpy(lpszDeviceClass, TEXT("wave/out"));
    lResult = phoneGetID(
                         pPhone->hPhone,          
                         lpDeviceID,  
                         lpszDeviceClass  
                        );

    if(lResult != 0)
    {
        pPhone->lRenderID = WAVE_MAPPER;
    }
    else
    {
        CopyMemory(
                    &pPhone->lRenderID,
                    (LPBYTE) lpDeviceID + lpDeviceID->dwStringOffset,
                    lpDeviceID->dwStringSize
                   );
    }

    LocalFree(lpszDeviceClass);
    LocalFree(pBuffer);

    lResult = phoneSetStatusMessages(
                                     pPhone->hPhone,
                                     PHONESTATE_HANDSETHOOKSWITCH,
                                     PHONEBUTTONMODE_FEATURE | PHONEBUTTONMODE_KEYPAD,
                                     PHONEBUTTONSTATE_UP | PHONEBUTTONSTATE_DOWN
                                     );

    pPhone->pTonePlayer = new CTonePlayer;

    if ( (pPhone->pTonePlayer == NULL) ||
         FAILED(pPhone->pTonePlayer->Initialize()) )
    {
        DoMessage(L"Tone Player Initialization Failed");
    }
    else if ( FAILED(pPhone->pTonePlayer->OpenWaveDevice( pPhone->lRenderID )) )
    {
        DoMessage(L"OpenWaveDevice Failed");
    }

    if ( FAILED( InitAssistedTelephony() ) )
    {
        DoMessage(L"InitAssistedTelephony Failed");                
    }
}

//////////////////////////////////////////////////////////////////
// FreePhone
//////////////////////////////////////////////////////////////////

void
FreePhone(
            PMYPHONE pPhone
         )
{
    EnterCriticalSection(&pPhone->csdial);

    if ( pPhone->pTonePlayer->IsInUse() )
    {
        pPhone->pTonePlayer->StopDialtone();
        pPhone->pTonePlayer->CloseWaveDevice();
    }
    
    LocalFree(pPhone->wszDialStr);

    LeaveCriticalSection(&pPhone->csdial);

    DeleteCriticalSection(&pPhone->csdial);
}

///////////////////////////////////////////////////////////////////
// GetPhone
///////////////////////////////////////////////////////////////////

PMYPHONE
GetPhone (HPHONE hPhone )
{

    DWORD i;
    
    for(i = 0; i < gdwNumPhoneDevs; i++)
    {
        if(gpPhone[i].hPhone == hPhone)
        {
            return &gpPhone[i];
        }
    }
    
    return (PMYPHONE) NULL;    
}

///////////////////////////////////////////////////////////////////
// GetPhoneByID
///////////////////////////////////////////////////////////////////

PMYPHONE
GetPhoneByID (DWORD dwDevID )
{

    DWORD i;
    
    for(i = 0; i < gdwNumPhoneDevs; i++)
    {
        if(gpPhone[i].dwDevID == dwDevID)
        {
            return &gpPhone[i];
        }
    }
    
    return (PMYPHONE) NULL;    
}

///////////////////////////////////////////////////////////////////
// RemovePhone
///////////////////////////////////////////////////////////////////

void
RemovePhone (PMYPHONE pPhone)
{
    DWORD i,j;
    PMYPHONE pNewPhones;

    pNewPhones = (PMYPHONE) LocalAlloc(LPTR,(gdwNumPhoneDevs-1) * sizeof(MYPHONE));
    
    for(i = 0, j = 0; i < gdwNumPhoneDevs; i++)
    {
        if(&gpPhone[i] != pPhone)
        {
            CopyMemory( &pNewPhones[j], &gpPhone[i], sizeof(MYPHONE));
            j++;
        }
    }

    LocalFree(gpPhone);
    gpPhone = pNewPhones;
    gdwNumPhoneDevs--;
}

///////////////////////////////////////////////////////////////////
// AddPhone
///////////////////////////////////////////////////////////////////

PMYPHONE
AddPhone ()
{
    PMYPHONE pNewPhones;

    pNewPhones = (PMYPHONE) LocalAlloc(LPTR,(gdwNumPhoneDevs+1) * sizeof(MYPHONE));
    
    CopyMemory( pNewPhones, gpPhone, gdwNumPhoneDevs * sizeof(MYPHONE));

    LocalFree(gpPhone);
    gpPhone = pNewPhones;
    gdwNumPhoneDevs++;

    return &gpPhone[gdwNumPhoneDevs-1];
}
    
///////////////////////////////////////////////////////////////////
// DoMessage
///////////////////////////////////////////////////////////////////
void
DoMessage(
          LPWSTR pszMessage
         )
{
    MessageBox(
               ghDlg,
               pszMessage,
               gszTapi30,
               MB_OK
              );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\phonemgr\tones.cpp ===
#include "tones.h"

//////////////////////////////////////////////////////////////////////////////
//
// Helper function used to read a wave file's data into an in-memory buffer.
//

HRESULT ReadWaveFile(char * szFileName, DWORD dwFileSize, BYTE * pbData)
{
    const int   WAVE_HEADER_SIZE = 44;
    FILE      * fp;
    size_t      result;


    //
    // Check arguments.
    //
    // Assumption: we are reading at least WAVE_HEADER_SIZE bytes from the file.
    // Note: this is data in addition to the header.
    //

    // _ASSERTE( ! IsBadWritePtr( pbData, dwFileSize ) );

    // _ASSERTE( ! IsBadStringPtr( szFileName, (UINT) -1 ) );

    if ( dwFileSize < WAVE_HEADER_SIZE )
    {
        return E_INVALIDARG;
    }


    //
    // Open the file for reading.
    //

    fp = fopen(szFileName, "rb");

    if ( fp == NULL )
    {
        return E_FAIL;
    }


    //
    // Skip the wave header.
    //
    
    result = fread(pbData, sizeof(BYTE), WAVE_HEADER_SIZE, fp);

    if ( result != WAVE_HEADER_SIZE )
    {
        fclose(fp);

        return E_FAIL;
    }


    //
    // Read the waveform from the file and close the file.
    //

    result = fread(pbData, sizeof(BYTE), dwFileSize, fp);


    fclose(fp);

    if ( result != dwFileSize )
    {
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

CTonePlayer::CTonePlayer()
{
    m_hWaveOut = NULL;
    m_fInitialized = FALSE;
    m_fDialtonePlaying = FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//

CTonePlayer::~CTonePlayer()
{
    //
    // We should have closed the wave device by now.
    //

    if ( m_fInitialized == TRUE )
    {
        ASSERT( m_hWaveOut == NULL );
    }
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CTonePlayer::Initialize(void)
{
    int i;

    //
    // It's wasteful to initialize twice, but it won't break anything.
    //

    ASSERT( m_fInitialized == FALSE );

    //
    // Read all the files.
    //

    HRESULT hr = ReadWaveFile(
        "dialtone.wav",
        WAVE_FILE_SIZE,
        (BYTE * ) & m_abDialtoneWaveform
        );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // For each digit
    //

    for ( i = 0; i < NUM_DIGITS; i ++ )
    {
        //
        // Construct the filename for this digit.
        //
    
        char szFilename[20];

        if ( i < 10 )
        {
            sprintf(szFilename,"dtmf%d.wav", i);
        }
        else if ( i == 10 )
        {
            sprintf(szFilename,"dtmfstar.wav", i);
        }
        else if ( i == 11 )
        {
            sprintf(szFilename,"dtmfpound.wav", i);
        }
        else
        {
            ASSERT( FALSE );
        }

        //
        // Read the wave file for this digit.
        //

        HRESULT hr = ReadWaveFile(
            szFilename,
            WAVE_FILE_SIZE,
            (BYTE * ) ( & m_abDigitWaveforms ) + ( i * WAVE_FILE_SIZE )
            );

        if ( FAILED(hr) )
        { 
            return hr;
        }
    }

    //
    // We can now go ahead with the other methods.
    //

    m_fInitialized = TRUE;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CTonePlayer::StartDialtone(
    void
    )
{
    MMRESULT mmresult;

    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    //
    // Reset the wave device to flush out any pending buffers.
    //

    waveOutReset( m_hWaveOut );

    //
    // Construct a wave header structure that will indicate what to play
    // in waveOutWrite, and read in the data from the file. This can also
    // be done ahead of time.
    //

    ZeroMemory( & m_WaveHeader, sizeof( m_WaveHeader ) );

    m_WaveHeader.lpData          = (LPSTR) & m_abDialtoneWaveform;
    m_WaveHeader.dwBufferLength  = WAVE_FILE_SIZE;
    m_WaveHeader.dwFlags         = WHDR_BEGINLOOP | WHDR_ENDLOOP;
    m_WaveHeader.dwLoops         = (DWORD) -1;

    //
    // Submit the data to the wave device. The wave header indicated that
    // we want to loop. Need to prepare the header first, but it can
    // only be prepared after the device has been opened.
    //

    mmresult = waveOutPrepareHeader(m_hWaveOut,
                                    & m_WaveHeader,
                                    sizeof(WAVEHDR)
                                    );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    mmresult = waveOutWrite(m_hWaveOut,
                            & m_WaveHeader,
                            sizeof(WAVEHDR)
                            );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    m_fDialtonePlaying = TRUE;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// Reset the device to stop playing.
//

HRESULT CTonePlayer::StopDialtone( void )
{
    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    waveOutReset( m_hWaveOut );

    m_fDialtonePlaying = FALSE;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CTonePlayer::GenerateDTMF(
    long lDigit
    )
{
    MMRESULT mmresult;

    if ( lDigit < 0 )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( lDigit > NUM_DIGITS )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
     
    //
    // Reset the wave device to flush out any pending buffers.
    //

    waveOutReset( m_hWaveOut );

    m_fDialtonePlaying = FALSE;

    //
    // Construct a wave header structure that will indicate what to play
    // in waveOutWrite, and read in the data from the file. This can also
    // be done ahead of time.
    //
 
    ZeroMemory( & m_WaveHeader, sizeof( m_WaveHeader ) );

    m_WaveHeader.lpData          = (LPSTR) & m_abDigitWaveforms + lDigit * WAVE_FILE_SIZE;
    m_WaveHeader.dwBufferLength  = WAVE_FILE_SIZE;
    m_WaveHeader.dwFlags         = 0;
    m_WaveHeader.dwLoops         = (DWORD) 0;

    //
    // Submit the data to the wave device. The wave header indicated that
    // we want to loop. Need to prepare the header first, but it can
    // only be prepared after the device has been opened.
    //

    mmresult = waveOutPrepareHeader(m_hWaveOut,
                                    & m_WaveHeader,
                                    sizeof(WAVEHDR)
                                    );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    mmresult = waveOutWrite(m_hWaveOut,
                            & m_WaveHeader,
                            sizeof(WAVEHDR)
                            );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CTonePlayer::OpenWaveDevice(
    long lWaveID
    )
{
    MMRESULT mmresult; 

    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    //
    // We expect that the wave device will not be opened twice. This is
    // dependent on the calling code.
    //

    ASSERT( m_hWaveOut == NULL );

    //
    // Open the wave device. Here we specify a hard-coded audio format.
    //

    WAVEFORMATEX waveFormat;

    waveFormat.wFormatTag      = WAVE_FORMAT_PCM; // linear PCM
    waveFormat.nChannels       = 1;               // mono
    waveFormat.nSamplesPerSec  = 8000;            // 8 KHz
    waveFormat.wBitsPerSample  = 16;              // 16-bit samples
    waveFormat.nBlockAlign     = waveFormat.nChannels * waveFormat.wBitsPerSample / 8;
    waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec *  waveFormat.nBlockAlign;
    waveFormat.cbSize          = 0;               // no extra format info

    mmresult = waveOutOpen(& m_hWaveOut,        // returned handle
                           lWaveID,             // which device to use
                           &waveFormat,         // wave format to use
                           0,                   // callback function pointer
                           0,                   // callback instance data
                           WAVE_FORMAT_DIRECT   // we don't want ACM
                           );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

void CTonePlayer::CloseWaveDevice(void)
{
    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
    }

    ASSERT( m_hWaveOut != NULL );

    if ( m_hWaveOut != NULL )
    {
        waveOutClose( m_hWaveOut );

        m_hWaveOut = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\phonemgr\tones.h ===
//
// tones.h
//

#ifndef _TONES_H_
#define _TONES_H_

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <wxdebug.h>

#define  WAVE_FILE_SIZE     1600
#define  NUM_DIGITS         12

//////////////////////////////////////////////////////////////////////////////
//
// class CTonePlayer
//
// Implements tone player for a single phone device.
//

class CTonePlayer
{
public:
    CTonePlayer();
    ~CTonePlayer();

    HRESULT Initialize(void);

    HRESULT OpenWaveDevice(long lWaveId);
    void    CloseWaveDevice(void);
    BOOL    IsInUse(void) { return (m_hWaveOut != NULL); }

    HRESULT StartDialtone(void);
    HRESULT StopDialtone(void);
    BOOL    DialtonePlaying(void) { return m_fDialtonePlaying; }

    HRESULT GenerateDTMF(long lDigit);

private:
    // TRUE if Initialize has succeeded.
    BOOL     m_fInitialized;

    BOOL     m_fDialtonePlaying;

    // Handle to the wave out device. NULL when the device is not open.
    HWAVEOUT m_hWaveOut;

    // Header structure that we submit to the wave device.
    WAVEHDR  m_WaveHeader;

    // buffer containing dialtone waveform
    BYTE     m_abDialtoneWaveform[ WAVE_FILE_SIZE ];

    // buffer containing all dtmf waveforms, concatenated in order, 0-9,*,#
    BYTE     m_abDigitWaveforms  [ NUM_DIGITS * WAVE_FILE_SIZE ];
};

#endif // _TONES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\blberr.h ===
#ifndef __SDPBLB_ERROR_CODES__
#define __SDPBLB_ERROR_CODES__

#include <sdperr.h>

// First four bits - SEVERITY(11), CUSTOMER FLAG(1), RESERVED(0)
#define SDPBLB_CONF_BLOB_DESTROYED                  0xe0000300



#endif // __SDPBLB_ERROR_CODES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\av_asn1.h ===
#ifndef _MS_AV_ASN1_H_
#define _MS_AV_ASN1_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

// lonchanc: copied from ossdll.h
#define DLL_ENTRY       WINAPI
#define DLL_ENTRY_FDEF  WINAPI
#define DLL_ENTRY_FPTR  WINAPI


extern ASN1module_t     Q931ASN_Module;

#define q931asn         Q931ASN_Module
#define ObjectID_       ASN1objectidentifier_s

typedef ASN1bool_t      ASN1_BOOL;


typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;
}
    ASN1_CODER_INFO;

typedef struct
{
    ULONG           length;
    PBYTE           value;
}
    ASN1_BUF;

int Q931_InitModule(void);
int Q931_TermModule(void);
int Q931_InitWorld(ASN1_CODER_INFO *pWorld);
int Q931_TermWorld(ASN1_CODER_INFO *pWorld);
int Q931_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, BYTE **ppEncoded, DWORD *pcbEncodedSize);
int Q931_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, BYTE *pEncoded, DWORD cbEncodedSize);

int H245_InitModule(void);
int H245_TermModule(void);
int H245_InitWorld(ASN1_CODER_INFO *pWorld);
int H245_TermWorld(ASN1_CODER_INFO *pWorld);
int H245_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int H245_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);




__inline freePDU(ASN1_CODER_INFO *pWorld, int nPDU, void *pDecoded, ASN1module_t pModule)
{
    ASN1_FreeDecoded(pWorld->pDecInfo, pDecoded, nPDU);
    return ASN1_SUCCESS;
}


#ifdef __cplusplus
}
#endif

#endif // _MS_AV_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\callcont.h ===
/****************************************************************************
 *
 *      $Archive:   S:/sturgeon/src/include/vcs/callcont.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.102.1.0  $
 *      $Date:   20 Jun 1997 14:10:24  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CALLCONT_H
#define CALLCONT_H

#ifdef __cplusplus
extern "C" {
#endif

#if defined(REMOVE_FROM_TSP)

#if defined(CALL_CONTROL_EXPORT)
#define CC_API __declspec (dllexport)
#else // CALL_CONTROL_IMPORT
#define CC_API __declspec (dllimport)
#endif

#else  // REMOVE_FROM_TSP

#define CC_API

#endif // REMOVE_FROM_TSP

#pragma pack(push,8)

#ifndef H245API_H
#include "h245api.h"
#endif H245API_H

#ifndef CCERROR_H
#include "ccerror.h"
#endif  CCERROR_H

// Indication codes
#define CC_RINGING_INDICATION						1
#define CC_CONNECT_INDICATION						2
#define CC_TX_CHANNEL_OPEN_INDICATION				3
#define CC_RX_CHANNEL_REQUEST_INDICATION			4
#define CC_RX_CHANNEL_CLOSE_INDICATION				5
#define CC_MUTE_INDICATION							6
#define CC_UNMUTE_INDICATION						7
#define CC_PEER_ADD_INDICATION						8
#define CC_PEER_DROP_INDICATION						9
#define CC_PEER_CHANGE_CAP_INDICATION				10
#define CC_CONFERENCE_TERMINATION_INDICATION		11
#define CC_HANGUP_INDICATION						12
#define CC_RX_NONSTANDARD_MESSAGE_INDICATION		13
#define CC_MULTIPOINT_INDICATION					14
#define CC_PEER_UPDATE_INDICATION					15
#define CC_H245_MISCELLANEOUS_COMMAND_INDICATION	16
#define CC_H245_MISCELLANEOUS_INDICATION_INDICATION	17
#define CC_H245_CONFERENCE_REQUEST_INDICATION		18
#define CC_H245_CONFERENCE_RESPONSE_INDICATION		19
#define CC_H245_CONFERENCE_COMMAND_INDICATION		20
#define CC_H245_CONFERENCE_INDICATION_INDICATION	21
#define CC_FLOW_CONTROL_INDICATION					22
#define CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION		23
#define CC_REQUEST_MODE_INDICATION					24
#define CC_REQUEST_MODE_RESPONSE_INDICATION			25
#define CC_VENDOR_ID_INDICATION						26
#define CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION		27
#define CC_T120_CHANNEL_REQUEST_INDICATION			28
#define CC_T120_CHANNEL_OPEN_INDICATION				29
#define CC_BANDWIDTH_CHANGED_INDICATION             30
#define CC_ACCEPT_CHANNEL_INDICATION                31
#define CC_TERMINAL_ID_REQUEST_INDICATION           32
#define CC_PING_RESPONSE_INDICATION					33
#define CC_USER_INPUT_INDICATION					34

// Conference configuration values; these are bit mask values
#define CC_CONFIGURE_MULTIPOINT_CAPABLE				0x0001
#define CC_CONFIGURE_FORCE_MC						0x0002

// Timeout type codes
#define CC_Q931_ALERTING_TIMEOUT					1
#define CC_H245_RETRY_COUNT							2
#define CC_H245_TIMEOUT								3

// Conference termination reasons
#define CC_PEER_HANGUP								0
#define CC_GATEKEEPER_HANGUP						1

typedef enum {
	CC_WILL_TRANSMIT_PREFERRED_MODE,
	CC_WILL_TRANSMIT_LESS_PREFERRED_MODE,
	CC_MODE_UNAVAILABLE,
	CC_MULTIPOINT_CONSTRAINT,
	CC_REQUEST_DENIED
} CC_REQUEST_MODE_RESPONSE;

typedef H245_TOTCAP_T   CC_TERMCAP, *PCC_TERMCAP, **PPCC_TERMCAP;

typedef struct {
	WORD					wLength;
	PPCC_TERMCAP			pTermCapArray;
} CC_TERMCAPLIST, *PCC_TERMCAPLIST;

typedef struct {
	WORD					wLength;
	H245_TOTCAPDESC_T		**pTermCapDescriptorArray;
} CC_TERMCAPDESCRIPTORS, *PCC_TERMCAPDESCRIPTORS;

typedef struct {
	BYTE					bMCUNumber;
	BYTE					bTerminalNumber;
} CC_TERMINAL_LABEL, *PCC_TERMINAL_LABEL;

typedef struct {
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_OCTETSTRING			TerminalID;
} CC_PARTICIPANTINFO, *PCC_PARTICIPANTINFO;

typedef struct {
	WORD					wLength;
	PCC_PARTICIPANTINFO		ParticipantInfoArray;
} CC_PARTICIPANTLIST, *PCC_PARTICIPANTLIST;

typedef struct 
{
	BOOL					bMaster;
	BOOL					bMultipointController;
	BOOL					bMultipointConference;
	CC_CONFERENCEID			ConferenceID;
	CC_TERMINAL_LABEL		LocalTerminalLabel;
	WORD					wNumCalls;
	PCC_PARTICIPANTLIST		pParticipantList;
	DWORD					dwConferenceToken;
    DWORD                   dwBandwidthAllocated;
    DWORD                   dwBandwidthUsed;
} CC_CONFERENCEATTRIBUTES, *PCC_CONFERENCEATTRIBUTES;

typedef struct {
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	CC_OCTETSTRING			SessionDescription;
	PCC_TERMCAP				pTermCap;
	PCC_ADDR				pRTPAddr;
	PCC_ADDR				pRTCPAddr;
} CC_SESSIONINFO, *PCC_SESSIONINFO;

typedef struct {
	WORD					wLength;
	PCC_SESSIONINFO			SessionInfoArray;
} CC_SESSIONTABLE, *PCC_SESSIONTABLE;

typedef struct 
{
	CC_HCALL				hCall;
	PCC_ALIASNAMES			pCallerAliasNames;
	PCC_ALIASNAMES			pCalleeAliasNames;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszDisplay;
	PCC_VENDORINFO			pVendorInfo;
	WORD					wGoal;
	CC_CONFERENCEID			ConferenceID;
	PCC_ADDR				pCallerAddr;
	PCC_ADDR				pCalleeAddr;
	DWORD					dwListenToken;
} CC_LISTEN_CALLBACK_PARAMS, *PCC_LISTEN_CALLBACK_PARAMS;

typedef void *  PCC_CONFERENCE_CALLBACK_PARAMS;


// CC_RINGING_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	DWORD					dwUserToken;
} CC_RINGING_CALLBACK_PARAMS, *PCC_RINGING_CALLBACK_PARAMS;

// CC_CONNECT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszPeerDisplay;
	BYTE					bRejectReason;
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
	PCC_ADDR				pLocalAddr;
	PCC_ADDR				pPeerAddr;
	PCC_VENDORINFO			pVendorInfo;
	BOOL					bMultipointConference;
	PCC_CONFERENCEID		pConferenceID;
	PCC_ADDR				pMCAddress;
	PCC_ADDR				pAlternateAddress;
	DWORD					dwUserToken;
} CC_CONNECT_CALLBACK_PARAMS, *PCC_CONNECT_CALLBACK_PARAMS;

// CC_TX_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
	PCC_ADDR				pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	DWORD					dwRejectReason;
	DWORD					dwUserToken;
} CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_RX_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
	PCC_TERMCAP				pChannelCapability;
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	PCC_ADDR	            pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	BYTE					bRTPPayloadType;
	BOOL					bSilenceSuppression;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS;

// CC_RX_CHANNEL_CLOSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS, *PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS;

// CC_MUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_MUTE_CALLBACK_PARAMS, *PCC_MUTE_CALLBACK_PARAMS;

// CC_UNMUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_UNMUTE_CALLBACK_PARAMS, *PCC_UNMUTE_CALLBACK_PARAMS;

// CC_PEER_ADD_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_ADD_CALLBACK_PARAMS, *PCC_PEER_ADD_CALLBACK_PARAMS;

// CC_PEER_DROP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_DROP_CALLBACK_PARAMS, *PCC_PEER_DROP_CALLBACK_PARAMS;

// CC_PEER_CHANGE_CAP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
} CC_PEER_CHANGE_CAP_CALLBACK_PARAMS, *PCC_PEER_CHANGE_CAP_CALLBACK_PARAMS;

// CC_CONFERENCE_TERMINATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	DWORD					dwReason;
} CC_CONFERENCE_TERMINATION_CALLBACK_PARAMS, *PCC_CONFERENCE_TERMINATION_CALLBACK_PARAMS;

// CC_HANGUP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	DWORD					dwUserToken;
} CC_HANGUP_CALLBACK_PARAMS, *PCC_HANGUP_CALLBACK_PARAMS;

// CC_RX_NONSTANDARD_MESSAGE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	BYTE					bH245MessageType;
	CC_NONSTANDARDDATA		NonStandardData;
} CC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS, *PCC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS;

// CC_MULTIPOINT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	PCC_PARTICIPANTINFO		pTerminalInfo;
	PCC_SESSIONTABLE		pSessionTable;
} CC_MULTIPOINT_CALLBACK_PARAMS, *PCC_MULTIPOINT_CALLBACK_PARAMS;

// CC_PEER_UPDATE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_UPDATE_CALLBACK_PARAMS, *PCC_PEER_UPDATE_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	BOOL					bH323ActionRequired;
	MiscellaneousCommand	*pMiscellaneousCommand;
} CC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	MiscellaneousIndication	*pMiscellaneousIndication;
} CC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_REQ_ENUM_T	RequestType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_RSP_ENUM_T	ResponseType;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pOctetString;
	CC_TERMINAL_LABEL		*pTerminalList;
	WORD					wTerminalListCount;
} CC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	H245_CONFER_CMD_ENUM_T	CommandType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_IND_ENUM_T	IndicationType;
	BYTE					bSBENumber;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS;

// CC_FLOW_CONTROL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	DWORD					dwRate;
} CC_FLOW_CONTROL_CALLBACK_PARAMS, *PCC_FLOW_CONTROL_CALLBACK_PARAMS;

// CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
} CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS, *PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS;

// CC_REQUEST_MODE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	RequestedModesLink		pRequestedModes;
} CC_REQUEST_MODE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_CALLBACK_PARAMS;

// CC_REQUEST_MODE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_REQUEST_MODE_RESPONSE RequestModeResponse;
} CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS;

// CC_VENDOR_ID_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PCC_OCTETSTRING			pProductNumber;
	PCC_OCTETSTRING			pVersionNumber;
} CC_VENDOR_ID_CALLBACK_PARAMS, *PCC_VENDOR_ID_CALLBACK_PARAMS;

// CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel1;
	CC_HCHANNEL				hChannel2;
	WORD					wMaximumSkew;
} CC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS, *PCC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS;

// CC_T120_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	CC_HCALL				hCall;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	DWORD					dwRejectReason;
	DWORD					dwUserToken;
} CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_T120_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	BOOL					bMultipointController;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS;

typedef struct {
	CC_HCALL	            hCall;
	DWORD		            dwBandwidthTotal;
    long                    lBandwidthChange;
} CC_BANDWIDTH_CALLBACK_PARAMS, *PCC_BANDWIDTH_CALLBACK_PARAMS;

// CC_ACCEPT_CHANNEL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCHANNEL             hChannel;
} CC_ACCEPT_CHANNEL_CALLBACK_PARAMS, *PCC_ACCEPT_CHANNEL_CALLBACK_PARAMS;

// CC_PING_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	BOOL					bResponse;
} CC_PING_RESPONSE_CALLBACK_PARAMS, *PCC_PING_RESPONSE_CALLBACK_PARAMS;

// CC_USER_INPUT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct 
{
	CC_HCALL				hCall;
	WCHAR * 				pUserInput;
} CC_USER_INPUT_CALLBACK_PARAMS, *PCC_USER_INPUT_CALLBACK_PARAMS;

#ifndef NO_APIS

typedef void (*CC_LISTEN_CALLBACK)(		HRESULT							hStatus,
										PCC_LISTEN_CALLBACK_PARAMS		ListenCallbackParams);

typedef HRESULT (*CC_CONFERENCE_CALLBACK)(
										BYTE							bIndication,
										HRESULT							hStatus,
										CC_HCONFERENCE					hConference,
										DWORD							dwConferenceToken,
										PCC_CONFERENCE_CALLBACK_PARAMS	pConferenceCallbackParams);

typedef HRESULT (*CC_SESSIONTABLE_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD							dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbSessionTableChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors[],
										PCC_SESSIONTABLE				*ppSessionTable);

typedef HRESULT (*CC_TERMCAP_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD							dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbTermCapsChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pInTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
										PCC_TERMCAPLIST					*ppOutTermCapList,
										PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors);

CC_API
HRESULT CC_AcceptCall(					CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
										DWORD                           dwBandwidth,
										DWORD							dwUserToken);

typedef HRESULT (*CC_ACCEPTCALL)(		CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
                                        DWORD                           dwBandwidth,
										DWORD							dwUserToken);

CC_API
HRESULT CC_AcceptChannel(				CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwBandwidth);
									
typedef HRESULT (*CC_ACCEPTCHANNEL) (	CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwBandwidth);

CC_API
HRESULT CC_AcceptT120Channel(			CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
typedef HRESULT (*CC_ACCEPTT120CHANNEL)(CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
CC_API
HRESULT CC_CallListen(					PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD							dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);

typedef HRESULT (*CC_CALLLISTEN)(		PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD							dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);


CC_API
HRESULT CC_CancelCall(					CC_HCALL						hCall);

typedef HRESULT (*CC_CANCELCALL)(		CC_HCALL						hCall);


CC_API
HRESULT CC_CancelListen(				CC_HLISTEN						hListen);

typedef HRESULT (*CC_CANCELLISTEN)(		CC_HLISTEN						hListen);

CC_API
HRESULT CC_ChangeConferenceCapabilities(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

typedef HRESULT (*CC_CHANGECONFERENCECAPABILITIES)(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

CC_API
HRESULT CC_CloseChannel(				CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_CLOSECHANNEL)(		CC_HCHANNEL						hChannel);


CC_API
HRESULT CC_CloseChannelResponse(		CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

typedef HRESULT (*CC_CLOSECHANNELRESPONSE)(
										CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

CC_API
HRESULT CC_CreateConference(			PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD							dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

typedef HRESULT	(*CC_CREATECONFERENCE) (PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD							dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

CC_API
HRESULT CC_DestroyConference(			CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

typedef HRESULT (*CC_DESTROYCONFERENCE)(CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

CC_API
HRESULT CC_EnumerateConferences(		PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

typedef HRESULT (*CC_ENUMERATECONFERENCES)(
										PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

CC_API
HRESULT CC_FlowControl(					CC_HCHANNEL						hChannel,
										DWORD							dwRate);

typedef HRESULT (*CC_FLOWCONTROL)(		CC_HCHANNEL						hChannel,
										DWORD							dwRate);

CC_API
HRESULT CC_GetCallControlVersion(		WORD							wArraySize,
										PWSTR							pszVersion);

typedef HRESULT (*CC_GETCALLCONTROLVERSION)
									   (WORD							wArraySize,
										PWSTR							pszVersion);

CC_API
HRESULT CC_GetConferenceAttributes(		CC_HCONFERENCE					hConference,
										PCC_CONFERENCEATTRIBUTES		pConferenceAttributes);

typedef HRESULT (*CC_GETCONFERENCEATTRIBUTES) 
									   (CC_HCONFERENCE                  hConference,
									    PCC_CONFERENCEATTRIBUTES        pConferenceAttributes);

CC_API
HRESULT CC_H245ConferenceRequest(		CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEREQUEST)(
										CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceResponse(		CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

typedef HRESULT (*CC_H245CONFERENCERESPONSE)(
										CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

CC_API
HRESULT CC_H245ConferenceCommand(		CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCECOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceIndication(	CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEINDICATION)(
										CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245MiscellaneousCommand(	CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

typedef HRESULT (*CC_H245MISCELLANEOUSCOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

CC_API
HRESULT CC_H245MiscellaneousIndication(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

typedef HRESULT (*CC_H245MISCELLANEOUSINDICATION)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

CC_API
HRESULT CC_Hangup(						CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD							dwUserToken);

typedef HRESULT (*CC_HANGUP)(			CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD							dwUserToken);

CC_API
HRESULT CC_MaximumAudioVideoSkew(		CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

typedef HRESULT (*CC_MAXIMUMAUDIOVIDEOSKEW)(
										CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

CC_API
HRESULT CC_Mute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_MUTE)(				CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_OpenChannel(					CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwBandwidth,
										DWORD							dwUserToken);

typedef HRESULT (*CC_OPENCHANNEL)(		CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwBandwidth,
										DWORD							dwUserToken);

CC_API
HRESULT CC_OpenT120Channel(				CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwBandwidth,
										DWORD							dwUserToken);

typedef HRESULT (*CC_OPENT120CHANNEL)(	CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwBandwidth,
										DWORD							dwUserToken);

CC_API
HRESULT CC_Ping(						CC_HCALL						hCall,
										DWORD							dwTimeout);

typedef HRESULT (*CC_PING)(				CC_HCALL						hCall,
										DWORD							dwTimeout);

CC_API
HRESULT CC_PlaceCall(					CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD							dwUserToken);

typedef HRESULT (*CC_PLACECALL)(		CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD							dwUserToken);

CC_API
HRESULT CC_RejectCall(					BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

typedef HRESULT (*CC_REJECTCALL)(		BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

CC_API
HRESULT CC_RejectChannel(				CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

typedef HRESULT (*CC_REJECTCHANNEL)(	CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

CC_API
HRESULT CC_RequestMode(					CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

typedef HRESULT (*CC_REQUESTMODE)(		CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

CC_API
HRESULT CC_RequestModeResponse(			CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

typedef HRESULT (*CC_REQUESTMODERESPONSE)(
										CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

CC_API
HRESULT CC_SendNonStandardMessage(		CC_HCALL						hCall,
										BYTE							bMessageType,
										PCC_NONSTANDARDDATA				pNonStandardData);

typedef HRESULT (*CC_SENDNONSTANDARDMESSAGE)(
										CC_HCALL						hCall,
										BYTE							bMessageType,
										PCC_NONSTANDARDDATA				pNonStandardData);

CC_API
HRESULT CC_SendVendorID(				CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);

typedef HRESULT (*CC_SENDVENDORID)(		CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);
CC_API
HRESULT CC_SetCallControlTimeout(		WORD							wType,
										DWORD							dwDuration);

typedef HRESULT (*CC_SETCALLCONTROLTIMEOUT)
									   (WORD							wType,
										DWORD							dwDuration);

CC_API
HRESULT CC_SetTerminalID(				CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

typedef HRESULT (*CC_SETTERMINALID)(	CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

CC_API
HRESULT CC_Shutdown();

typedef HRESULT (*CC_SHUTDOWN)();

CC_API
HRESULT CC_UnMute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_UNMUTE)(			CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_UpdatePeerList(				CC_HCONFERENCE					hConference);

typedef HRESULT (*CC_UPDATEPEERLIST)(	CC_HCONFERENCE					hConference);

CC_API
HRESULT CC_UserInput(					CC_HCALL						hCall,
										PWSTR							pszUserInput);

typedef HRESULT (*CC_USERINPUT)(		CC_HCALL						hCall,
										PWSTR							pszUserInput);


// structure used for holding the entry points to the CallControl module
typedef struct _CALLCONTROLAPI
{
	CC_ACCEPTCALL							CC_AcceptCall;
	CC_ACCEPTCHANNEL						CC_AcceptChannel;
	CC_ACCEPTT120CHANNEL					CC_AcceptT120Channel;
	CC_CALLLISTEN                           CC_CallListen;
	CC_CANCELCALL                           CC_CancelCall;
	CC_CANCELLISTEN                         CC_CancelListen;
	CC_CLOSECHANNEL                         CC_CloseChannel;
	CC_CLOSECHANNELRESPONSE					CC_CloseChannelResponse;
	CC_CHANGECONFERENCECAPABILITIES			CC_ChangeConferenceCapabilities;
	CC_CREATECONFERENCE                     CC_CreateConference;
	CC_DESTROYCONFERENCE					CC_DestroyConference;
	CC_ENUMERATECONFERENCES					CC_EnumerateConferences;
	CC_FLOWCONTROL							CC_FlowControl;
	CC_GETCALLCONTROLVERSION				CC_GetCallControlVersion;
	CC_GETCONFERENCEATTRIBUTES				CC_GetConferenceAttributes;
	CC_H245CONFERENCEREQUEST				CC_H245ConferenceRequest;
	CC_H245CONFERENCERESPONSE				CC_H245ConferenceResponse;
	CC_H245CONFERENCECOMMAND				CC_H245ConferenceCommand;
	CC_H245CONFERENCEINDICATION				CC_H245ConferenceIndication;
	CC_H245MISCELLANEOUSCOMMAND				CC_H245MiscellaneousCommand;
	CC_H245MISCELLANEOUSINDICATION			CC_H245MiscellaneousIndication;
	CC_HANGUP                               CC_Hangup;
	CC_MAXIMUMAUDIOVIDEOSKEW				CC_MaximumAudioVideoSkew;
	CC_MUTE                                 CC_Mute;
	CC_OPENCHANNEL                          CC_OpenChannel;
	CC_OPENT120CHANNEL						CC_OpenT120Channel;
	CC_PING									CC_Ping;
	CC_PLACECALL                            CC_PlaceCall;
	CC_REJECTCALL							CC_RejectCall;
	CC_REJECTCHANNEL						CC_RejectChannel;
	CC_REQUESTMODE							CC_RequestMode;
	CC_REQUESTMODERESPONSE					CC_RequestModeResponse;
	CC_SENDNONSTANDARDMESSAGE				CC_SendNonStandardMessage;
	CC_SENDVENDORID							CC_SendVendorID;
	CC_SETCALLCONTROLTIMEOUT				CC_SetCallControlTimeout;
	CC_SETTERMINALID						CC_SetTerminalID;
	CC_SHUTDOWN								CC_Shutdown;
	CC_UNMUTE                               CC_UnMute;
	CC_UPDATEPEERLIST						CC_UpdatePeerList;
	CC_USERINPUT							CC_UserInput;
} CALLCONTROLAPI, *LPCALLCONTROLAPI; 

#endif


#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif CALLCONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\phonemgr\wxutil.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// helper classes for building multimedia filters
//

#include <streams.h>

//
//  Declare function from largeint.h we need so that PPC can build
//

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

#ifndef _X86_

#define LLtoU64(x) (*(unsigned __int64*)(void*)(&(x)))

__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
        // return remainder if necessary
        if (Remainder != NULL)
                *Remainder = (ULONG)(LLtoU64(Dividend) % Divisor);
        return (ULONG)(LLtoU64(Dividend) / Divisor);
}

#else
__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
    ULONG ulResult;
    _asm {
        mov eax,Dividend.LowPart
        mov edx,Dividend.HighPart
        mov ecx,Remainder
        div Divisor
        or  ecx,ecx
        jz  short label
        mov [ecx],edx
label:
        mov ulResult,eax
    }
    return ulResult;
}
#endif

// --- CAMEvent -----------------------
CAMEvent::CAMEvent(BOOL fManualReset)
{
    m_hEvent = CreateEvent(NULL, fManualReset, FALSE, NULL);
    ASSERT(m_hEvent);
}

CAMEvent::~CAMEvent()
{
    if (m_hEvent) {
    EXECUTE_ASSERT(CloseHandle(m_hEvent));
    }
}


// --- CAMMsgEvent -----------------------
// One routine.  The rest is handled in CAMEvent

BOOL CAMMsgEvent::WaitMsg(DWORD dwTimeout)
{
    // wait for the event to be signalled, or for the
    // timeout (in MS) to expire.  allow SENT messages
    // to be processed while we wait
    DWORD dwWait;
    DWORD dwStartTime;

    // set the waiting period.
    DWORD dwWaitTime = dwTimeout;

    // the timeout will eventually run down as we iterate
    // processing messages.  grab the start time so that
    // we can calculate elapsed times.
    if (dwWaitTime != INFINITE) {
        dwStartTime = timeGetTime();
    }

    do {
        dwWait = MsgWaitForMultipleObjects(1,&m_hEvent,FALSE, dwWaitTime, QS_SENDMESSAGE);
        if (dwWait == WAIT_OBJECT_0 + 1) {
        MSG Message;
            PeekMessage(&Message,NULL,0,0,PM_NOREMOVE);

        // If we have an explicit length of time to wait calculate
        // the next wake up point - which might be now.
        // If dwTimeout is INFINITE, it stays INFINITE
        if (dwWaitTime != INFINITE) {

        DWORD dwElapsed = timeGetTime()-dwStartTime;

        dwWaitTime =
            (dwElapsed >= dwTimeout)
            ? 0  // wake up with WAIT_TIMEOUT
            : dwTimeout-dwElapsed;
        }
        }
    } while (dwWait == WAIT_OBJECT_0 + 1);

    // return TRUE if we woke on the event handle,
    //        FALSE if we timed out.
    return (dwWait == WAIT_OBJECT_0);
}

// --- CAMThread ----------------------


CAMThread::CAMThread()
    : m_EventSend(TRUE)     // must be manual-reset for CheckRequest()
{
    m_hThread = NULL;
}

CAMThread::~CAMThread() {
    Close();
}


// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CAMThread::InitialThreadProc(LPVOID pv)
{
    CAMThread * pThread = (CAMThread *) pv;

    return pThread->ThreadProc();
}

BOOL
CAMThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
    return FALSE;
    }

    m_hThread = CreateThread(
            NULL,
            0,
            CAMThread::InitialThreadProc,
            this,
            0,
            &threadid);

    if (!m_hThread) {
    return FALSE;
    }

    return TRUE;
}

DWORD
CAMThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
    return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled
    m_EventComplete.Wait();

    // done - this is the thread's return value
    return m_dwReturnVal;
}

// Wait for a request from the client
DWORD
CAMThread::GetRequest()
{
    m_EventSend.Wait();
    return m_dwParam;
}

// is there a request?
BOOL
CAMThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
    return FALSE;
    } else {
    if (pParam) {
        *pParam = m_dwParam;
    }
    return TRUE;
    }
}

// reply to the request
void
CAMThread::Reply(DWORD dw)
{
    m_dwReturnVal = dw;

    // The request is now complete so CheckRequest should fail from
    // now on
    //
    // This event should be reset BEFORE we signal the client or
    // the client may Set it before we reset it and we'll then
    // reset it (!)

    m_EventSend.Reset();

    // Tell the client we're finished

    m_EventComplete.Set();
}

HRESULT CAMThread::CoInitializeHelper()
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(0, COINIT_DISABLE_OLE1DDE );
        }
    }
    else
    {
        // caller must load ole32.dll
        DbgBreak("couldn't locate ole32.dll");
    }

    return hr;
}


// destructor for CMsgThread  - cleans up any messages left in the
// queue when the thread exited
CMsgThread::~CMsgThread()
{
    if (m_hThread != NULL) {
        WaitForSingleObject(m_hThread, INFINITE);
        EXECUTE_ASSERT(CloseHandle(m_hThread));
    }

    POSITION pos = m_ThreadQueue.GetHeadPosition();
    while (pos) {
        CMsg * pMsg = m_ThreadQueue.GetNext(pos);
        delete pMsg;
    }
    m_ThreadQueue.RemoveAll();

    if (m_hSem != NULL) {
        EXECUTE_ASSERT(CloseHandle(m_hSem));
    }
}

BOOL
CMsgThread::CreateThread(
    )
{
    m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL);
    if (m_hSem == NULL) {
        return FALSE;
    }

    m_hThread = ::CreateThread(NULL, 0, DefaultThreadProc,
                   (LPVOID)this, 0, &m_ThreadId);
    return m_hThread != NULL;
}


// This is the threads message pump.  Here we get and dispatch messages to
// clients thread proc until the client refuses to process a message.
// The client returns a non-zero value to stop the message pump, this
// value becomes the threads exit code.

DWORD WINAPI
CMsgThread::DefaultThreadProc(
    LPVOID lpParam
    )
{
    CMsgThread *lpThis = (CMsgThread *)lpParam;
    CMsg msg;
    LRESULT lResult;

    // !!!
    CoInitialize(NULL);

    // allow a derived class to handle thread startup
    lpThis->OnThreadInit();

    do {
    lpThis->GetThreadMsg(&msg);
    lResult = lpThis->ThreadMessageProc(msg.uMsg,msg.dwFlags,
                        msg.lpParam, msg.pEvent);
    } while (lResult == 0L);

    // !!!
    CoUninitialize();

    return (DWORD)lResult;
}


// Block until the next message is placed on the list m_ThreadQueue.
// copies the message to the message pointed to by *pmsg
void
CMsgThread::GetThreadMsg(CMsg *msg)
{
    CMsg * pmsg = NULL;

    // keep trying until a message appears
    while (TRUE) {
        {
            CAutoLock lck(&m_Lock);
            pmsg = m_ThreadQueue.RemoveHead();
            if (pmsg == NULL) {
                m_lWaiting++;
            } else {
                break;
            }
        }
        // the semaphore will be signalled when it is non-empty
        WaitForSingleObject(m_hSem, INFINITE);
    }
    // copy fields to caller's CMsg
    *msg = *pmsg;

    // this CMsg was allocated by the 'new' in PutThreadMsg
    delete pmsg;

}


// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

#ifndef UNICODE
// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR  lpReturn = lpString1;
    while (*lpString1++ = *lpString2++);

    return lpReturn;
}

// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    )
{
    ASSERT(iMaxLength);
    LPWSTR  lpReturn = lpString1;
    if (iMaxLength) {
        while (--iMaxLength && (*lpString1++ = *lpString2++));

        // If we ran out of room (which will be the case if
        // iMaxLength is now 0) we still need to terminate the
        // string.
        if (!iMaxLength) *lpString1 = L'\0';
    }
    return lpReturn;
}

int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
    WCHAR c1 = *lpString1;
    WCHAR c2 = *lpString2;
    if (c1 != c2)
        return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);
    return 0;
}


int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
    WCHAR c1 = *lpString1;
    WCHAR c2 = *lpString2;
    if (c1 >= L'A' && c1 <= L'Z')
        c1 -= (WCHAR) (L'A' - L'a');
    if (c2 >= L'A' && c2 <= L'Z')
        c2 -= (WCHAR) (L'A' - L'a');
    
    if (c1 != c2)
        return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);

    return 0;
}


int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    )
{
    int i = -1;
    while (*(lpString+(++i)))
        ;
    return i;
}


int WINAPIV wsprintfWInternal(LPWSTR wszOut, LPCWSTR pszFmt, ...)
{
    char fmt[256]; // !!!
    char ach[256]; // !!!
    int i;

    va_list va;
    va_start(va, pszFmt);
    WideCharToMultiByte(GetACP(), 0, pszFmt, -1, fmt, 256, NULL, NULL);
    i = wvsprintfA(ach, fmt, va);
    va_end(va);

    MultiByteToWideChar(CP_ACP, 0, ach, -1, wszOut, i+1);

    return i;
}
#else

// need to provide the implementations in unicode for non-unicode
// builds linking with the unicode strmbase.lib
LPWSTR WINAPI lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return lstrcpyW(lpString1, lpString2);
}

LPWSTR WINAPI lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    )
{
    return lstrcpynW(lpString1, lpString2, iMaxLength);
}

int WINAPI lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return lstrcmpW(lpString1, lpString2);
}


int WINAPI lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return lstrcmpiW(lpString1, lpString2);
}


int WINAPI lstrlenWInternal(
    LPCWSTR lpString
    )
{
    return lstrlenW(lpString);
}


int WINAPIV wsprintfWInternal(
    LPWSTR wszOut, LPCWSTR pszFmt, ...)
{
    va_list va;
    va_start(va, pszFmt);
    int i = wvsprintfW(wszOut, pszFmt, va);
    va_end(va);
    return i;
}
#endif


// Helper function - convert int to WSTR
void WINAPI IntToWstr(int i, LPWSTR wstr)
{
#ifdef UNICODE
    wsprintf(wstr, L"%d", i);
#else
    TCHAR temp[32];
    wsprintf(temp, "%d", i);
    MultiByteToWideChar(CP_ACP, 0, temp, -1, wstr, 32);
#endif
} // IntToWstr


#if 0
void * memchrInternal(const void *pv, int c, size_t sz)
{
    BYTE *pb = (BYTE *) pv;
    while (sz--) {
    if (*pb == c)
        return (void *) pb;
    pb++;
    }
    return NULL;
}
#endif


#define MEMORY_ALIGNMENT        4
#define MEMORY_ALIGNMENT_LOG2   2
#define MEMORY_ALIGNMENT_MASK   MEMORY_ALIGNMENT - 1

void * __stdcall memmoveInternal(void * dst, const void * src, size_t count)
{
    void * ret = dst;

#ifdef _X86_
    if (dst <= src || (char *)dst >= ((char *)src + count)) {

        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            cld
            mov     edx,ecx
            and     edx,MEMORY_ALIGNMENT_MASK
            shr     ecx,MEMORY_ALIGNMENT_LOG2
            rep     movsd
            or      ecx,edx
            jz      memmove_done
            rep     movsb
memmove_done:
        }
    }
    else {

        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            std
            add     esi,ecx
            add     edi,ecx
            dec     esi
            dec     edi
            rep     movsb
            cld
        }
    }
#else
    MoveMemory(dst, src, count);
#endif

    return ret;
}

/*  Arithmetic functions to help with time format conversions
*/

/*   Compute (a * b + d) / c */
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d)
{
    /*  Compute the absolute values to avoid signed arithmetic problems */
    ULARGE_INTEGER ua, ub;
    DWORDLONG uc;

    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub.QuadPart = (DWORDLONG)(b >= 0 ? b : -b);
    uc          = (DWORDLONG)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p[2];
    p[0].QuadPart  = UInt32x32To64(ua.LowPart, ub.LowPart);

    /*  This next computation cannot overflow into p[1].HighPart because
        the max number we can compute here is:

                 (2 ** 32 - 1) * (2 ** 32 - 1) +  // ua.LowPart * ub.LowPart
    (2 ** 32) *  (2 ** 31) * (2 ** 32 - 1) * 2    // x.LowPart * y.HighPart * 2

    == 2 ** 96 - 2 ** 64 + (2 ** 64 - 2 ** 33 + 1)
    == 2 ** 96 - 2 ** 33 + 1
    < 2 ** 96
    */

    ULARGE_INTEGER x;
    x.QuadPart     = UInt32x32To64(ua.LowPart, ub.HighPart) +
                     UInt32x32To64(ua.HighPart, ub.LowPart) +
                     p[0].HighPart;
    p[0].HighPart  = x.LowPart;
    p[1].QuadPart  = UInt32x32To64(ua.HighPart, ub.HighPart) + x.HighPart;

    if (d != 0) {
        ULARGE_INTEGER ud[2];
        if (bSign) {
            ud[0].QuadPart = (DWORDLONG)(-d);
            if (d > 0) {
                /*  -d < 0 */
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        } else {
            ud[0].QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud[0].LowPart + p[0].LowPart;
        p[0].LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud[0].HighPart + p[0].HighPart;
        p[0].HighPart      = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add MS DWORDLONGs - no carry expected */
        p[1].QuadPart     += ud[1].QuadPart + uliTotal.QuadPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p[1].HighPart < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p[0].QuadPart  = ~p[0].QuadPart;
            p[1].QuadPart  = ~p[1].QuadPart;
            p[0].QuadPart += 1;
            p[1].QuadPart += (p[0].QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p[1].QuadPart) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    DWORDLONG ullResult;

    /*  Do the division */
    /*  If the dividend is a DWORD_LONG use the compiler */
    if (p[1].QuadPart == 0) {
        ullResult = p[0].QuadPart / uc;
        return bSign ? -(LONGLONG)ullResult : (LONGLONG)ullResult;
    }

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER ulic;
    ulic.QuadPart = uc;
    if (ulic.HighPart == 0) {
        ULARGE_INTEGER uliDividend;
        ULARGE_INTEGER uliResult;
        DWORD dwDivisor = (DWORD)uc;
        // ASSERT(p[1].HighPart == 0 && p[1].LowPart < dwDivisor);
        uliDividend.HighPart = p[1].LowPart;
        uliDividend.LowPart = p[0].HighPart;
#ifndef USE_LARGEINT
        uliResult.HighPart = (DWORD)(uliDividend.QuadPart / dwDivisor);
        p[0].HighPart = (DWORD)(uliDividend.QuadPart % dwDivisor);
        uliResult.LowPart = 0;
        uliResult.QuadPart = p[0].QuadPart / dwDivisor + uliResult.QuadPart;
#else
        /*  NOTE - this routine will take exceptions if
            the result does not fit in a DWORD
        */
        if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
            uliResult.HighPart = EnlargedUnsignedDivide(
                                     uliDividend,
                                     dwDivisor,
                                     &p[0].HighPart);
        } else {
            uliResult.HighPart = 0;
        }
        uliResult.LowPart = EnlargedUnsignedDivide(
                                 p[0],
                                 dwDivisor,
                                 NULL);
#endif
        return bSign ? -(LONGLONG)uliResult.QuadPart :
                        (LONGLONG)uliResult.QuadPart;
    }


    ullResult = 0;

    /*  OK - do long division */
    for (int i = 0; i < 64; i++) {
        ullResult <<= 1;

        /*  Shift 128 bit p left 1 */
        p[1].QuadPart <<= 1;
        if ((p[0].HighPart & 0x80000000) != 0) {
            p[1].LowPart++;
        }
        p[0].QuadPart <<= 1;

        /*  Compare */
        if (uc <= p[1].QuadPart) {
            p[1].QuadPart -= uc;
            ullResult += 1;
        }
    }

    return bSign ? - (LONGLONG)ullResult : (LONGLONG)ullResult;
}


LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG d)
{
    ULARGE_INTEGER ua;
    DWORD ub;
    DWORD uc;

    /*  Compute the absolute values to avoid signed arithmetic problems */
    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub = (DWORD)(b >= 0 ? b : -b);
    uc = (DWORD)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p0;
    DWORD p1;
    p0.QuadPart  = UInt32x32To64(ua.LowPart, ub);

    if (ua.HighPart != 0) {
        ULARGE_INTEGER x;
        x.QuadPart     = UInt32x32To64(ua.HighPart, ub) + p0.HighPart;
        p0.HighPart  = x.LowPart;
        p1   = x.HighPart;
    } else {
        p1 = 0;
    }

    if (d != 0) {
        ULARGE_INTEGER ud0;
        DWORD ud1;

        if (bSign) {
            //
            //  Cast d to LONGLONG first otherwise -0x80000000 sign extends
            //  incorrectly
            //
            ud0.QuadPart = (DWORDLONG)(-(LONGLONG)d);
            if (d > 0) {
                /*  -d < 0 */
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        } else {
            ud0.QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud0.LowPart + p0.LowPart;
        p0.LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud0.HighPart + p0.HighPart;
        p0.HighPart      = uliTotal.LowPart;

        /*  Add MS DWORDLONGs - no carry expected */
        p1 += ud1 + uliTotal.HighPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p1 < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p0.QuadPart  = ~p0.QuadPart;
            p1 = ~p1;
            p0.QuadPart += 1;
            p1 += (p0.QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p1) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    /*  Do the division */

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER uliDividend;
    ULARGE_INTEGER uliResult;
    DWORD dwDivisor = uc;
    uliDividend.HighPart = p1;
    uliDividend.LowPart = p0.HighPart;
    /*  NOTE - this routine will take exceptions if
        the result does not fit in a DWORD
    */
    if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
        uliResult.HighPart = EnlargedUnsignedDivide(
                                 uliDividend,
                                 dwDivisor,
                                 &p0.HighPart);
    } else {
        uliResult.HighPart = 0;
    }
    uliResult.LowPart = EnlargedUnsignedDivide(
                             p0,
                             dwDivisor,
                             NULL);
    return bSign ? -(LONGLONG)uliResult.QuadPart :
                    (LONGLONG)uliResult.QuadPart;
}

#ifdef DEBUG
/******************************Public*Routine******************************\
* Debug CCritSec helpers
*
* We provide debug versions of the Constructor, destructor, Lock and Unlock
* routines.  The debug code tracks who owns each critical section by
* maintaining a depth count.
*
* History:
*
\**************************************************************************/

CCritSec::CCritSec()
{
    InitializeCriticalSection(&m_CritSec);
    m_currentOwner = m_lockCount = 0;
    m_fTrace = FALSE;
}

CCritSec::~CCritSec()
{
    DeleteCriticalSection(&m_CritSec);
}

void CCritSec::Lock()
{
    UINT tracelevel=3;
    DWORD us = GetCurrentThreadId();
    DWORD currentOwner = m_currentOwner;
    if (currentOwner && (currentOwner != us)) {
        // already owned, but not by us
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 2, TEXT("Thread %d about to wait for lock %x owned by %d"),
                GetCurrentThreadId(), &m_CritSec, currentOwner));
            tracelevel=2;
        // if we saw the message about waiting for the critical
        // section we ensure we see the message when we get the
        // critical section
        }
    }
    EnterCriticalSection(&m_CritSec);
    if (0 == m_lockCount++) {
        // we now own it for the first time.  Set owner information
        m_currentOwner = us;
    //ASSERT(((PRTL_CRITICAL_SECTION)&m_CritSec)->OwningThread == (HANDLE)m_currentOwner);
    // only valid on NT
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, tracelevel, TEXT("Thread %d now owns lock %x"), m_currentOwner, &m_CritSec));
        }
    }
}

void CCritSec::Unlock() {
    if (0 == --m_lockCount) {
        // about to be unowned
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 3, TEXT("Thread %d releasing lock %x"), m_currentOwner, &m_CritSec));
        //ASSERT(((PRTL_CRITICAL_SECTION)&m_CritSec)->OwningThread == (HANDLE)m_currentOwner);
        // only valid on NT
        }
        m_currentOwner = 0;
    }
    LeaveCriticalSection(&m_CritSec);
}

void WINAPI DbgLockTrace(CCritSec * pcCrit, BOOL fTrace)
{
    pcCrit->m_fTrace = fTrace;
}

BOOL WINAPI CritCheckIn(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() == pcCrit->m_currentOwner);
}

BOOL WINAPI CritCheckOut(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() != pcCrit->m_currentOwner);
}
#endif


typedef BSTR (STDAPICALLTYPE *LPSYSALLOCSTRING)(const OLECHAR FAR *);

// Dyna-link to SysAllocString to copy BSTR strings

STDAPI WriteBSTR(BSTR *pstrDest, LPCWSTR szSrc)
{
    LPSYSALLOCSTRING    lpfnSysAllocString;
    HINSTANCE        hInst;
    static const char    szSysAllocString[]      = "SysAllocString";

    //
    // Try to get the Ole32Aut.dll module handle.
    //

    hInst = LoadOLEAut32();
    if (hInst == NULL) {
    DWORD dwError = GetLastError();
    return HRESULT_FROM_WIN32(dwError);
    }
    lpfnSysAllocString = (LPSYSALLOCSTRING)GetProcAddress(hInst,
                              szSysAllocString);
    if (lpfnSysAllocString == NULL) {
    DWORD dwError = GetLastError();
    return HRESULT_FROM_WIN32(dwError);
    }

    *pstrDest = (*lpfnSysAllocString)(szSrc);

    return S_OK;
}


// Free an OLE BSTR through the task allocator

STDAPI FreeBSTR(BSTR* pstr)
{
    if (*pstr != NULL) {
        // get pointer to string
        DWORD* p = (DWORD*) (*pstr);

        // back up to point at DWORD length
        p--;

        // set pointer to null
        *pstr = NULL;

        // and free this
        CoTaskMemFree(p);

        return S_OK;
    } else {
        return S_FALSE;
    }
}


// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR psz, LPWSTR *ppszReturn)
{
    CheckPointer(ppszReturn, E_POINTER);
    ValidateReadWritePtr(ppszReturn, sizeof(LPWSTR));
    DWORD nameLen = sizeof(WCHAR) * (lstrlenW(psz)+1);
    *ppszReturn = (LPWSTR)CoTaskMemAlloc(nameLen);
    if (*ppszReturn == NULL) {
       return E_OUTOFMEMORY;
    }
    CopyMemory(*ppszReturn, psz, nameLen);
    return NOERROR;
}

// Waits for the HANDLE hObject.  While waiting messages sent
// to windows on our thread by SendMessage will be processed.
// Using this function to do waits and mutual exclusion
// avoids some deadlocks in objects with windows.
// Return codes are the same as for WaitForSingleObject
DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd, UINT uMsg)
{
    BOOL bPeeked = FALSE;
    DWORD dwResult;
    DWORD dwStart;
    DWORD dwThreadPriority;

    static UINT uMsgId = 0;

    if (dwWait != INFINITE && dwWait != 0) {
        dwStart = GetTickCount();
    }
    for (; ; ) {
        DWORD dwTimeOut = dwWait;
        if (dwTimeOut > 10) {
            dwTimeOut = 10;
        }
        dwResult = MsgWaitForMultipleObjects(
                             1,
                             &hObject,
                             FALSE,
                             dwTimeOut,
                             hwnd == NULL ? QS_SENDMESSAGE :
                                            QS_SENDMESSAGE + QS_POSTMESSAGE);
        if (dwResult == WAIT_OBJECT_0 + 1 ||
            dwResult == WAIT_TIMEOUT && dwTimeOut != dwWait) {
            MSG msg;
            if (hwnd != NULL) {
                while (PeekMessage(&msg, hwnd, uMsg, uMsg, PM_REMOVE)) {
                    DispatchMessage(&msg);
                }
            }
            // Do this anyway - the previous peek doesn't flush out the
            // messages
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            if (dwWait != INFINITE && dwWait != 0) {
                DWORD dwNow = GetTickCount();

                // Working with differences handles wrap-around
                DWORD dwDiff = dwNow - dwStart;
                if (dwDiff > dwWait) {
                    dwWait = 0;
                } else {
                    dwWait -= dwDiff;
                }
                dwStart = dwNow;
            }
            if (!bPeeked) {
                //  Raise our priority to prevent our message queue
                //  building up
                dwThreadPriority = GetThreadPriority(GetCurrentThread());
                if (dwThreadPriority < THREAD_PRIORITY_HIGHEST) {
                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
                }
                bPeeked = TRUE;
            }
        } else {
            break;
        }
    }
    if (bPeeked) {
        SetThreadPriority(GetCurrentThread(), dwThreadPriority);
        if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) & QS_POSTMESSAGE) {
            if (uMsgId == 0) {
                uMsgId = RegisterWindowMessage(TEXT("AMUnblock"));
            }
            if (uMsgId != 0) {
                MSG msg;
                //  Remove old ones
                while (PeekMessage(&msg, (HWND)-1, uMsgId, uMsgId, PM_REMOVE)) {
                }
            }
            PostThreadMessage(GetCurrentThreadId(), uMsgId, 0, 0);
        }
    }
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\apierror.h ===
/****************************************************************************
 *
 *	$Archive:   S:\sturgeon\src\include\vcs\apierror.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the tERROR of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.30  $
 *	$Date:   26 Feb 1997 15:35:04  $
 *	$Author:   CHULME  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		Media Service Manager "public" header file. This file contains
 *		#defines, typedefs, struct definitions and prototypes used by
 *		and in conjunction with MSM. Any EXE or DLL which interacts with
 *		MSM will include this header file.
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef APIERROR_H
#define APIERROR_H

#include <objbase.h>

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus


#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport


// Prototype for function that converts HRESULT into a string.  The function
// and string resources are contained in NETMMERR.DLL.
//
typedef WORD	(*NETMMERR_ERRORTOSTRING)	(HRESULT, LPSTR, int);


extern DllExport BOOL GetResultUserString(HRESULT hResult, LPSTR lpBuffer, int iBufferSize);
extern DllExport BOOL GetResultSubStrings(HRESULT hResult, LPSTR lpBuffer, int iBufferSize);


// This description was extracted from winerror.h.  It appears here only for
// the purpose of convenience.

//
// OLE error definitions and values
//
// The return value of OLE APIs and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value.  The parts of an
// HRESULT are shown below.
//
// Many of the macros and functions below were orginally defined to
// operate on SCODEs.  SCODEs are no longer used.  The macros are
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//


// Macro to create a custom HRESULT
//
#define MAKE_CUSTOM_HRESULT(sev,cus,fac,code) \
((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(cus)<<29) | ((unsigned long)(fac)<<16) | ((unsigned long)(code) & 0xffff)) )


// Macro to test for custom HRESULT
//
#define HRESULT_CUSTOM(hr)  (((hr) >> 29) & 0x1)



// Custom facility codes
//
#define FACILITY_BASE                          0x080
#define FACILITY_MSM                           (FACILITY_BASE +  1)
#define FACILITY_AUDIOMSP                      (FACILITY_BASE +  2)
#define FACILITY_VIDEOMSP                      (FACILITY_BASE +  3)
#define FACILITY_FILEIOMSP                     (FACILITY_BASE +  4)
#define FACILITY_CALLCONTROL                   (FACILITY_BASE +  5)
#define FACILITY_SESSIONMANAGER                (FACILITY_BASE +  6)
#define FACILITY_RTPCHANMAN                    (FACILITY_BASE +  7)
#define FACILITY_RTPMSP                        (FACILITY_BASE +  8)
#define FACILITY_RTPRTCPCONTROL                (FACILITY_BASE +  9)
#define FACILITY_WINSOCK                       (FACILITY_BASE + 10)
#define FACILITY_TESTMSP                       (FACILITY_BASE + 11)
#define FACILITY_MSM_SESSION_CLASSES           (FACILITY_BASE + 12)
#define FACILITY_SCRIPTING                     (FACILITY_BASE + 13)
#define FACILITY_Q931                          (FACILITY_BASE + 14)
#define FACILITY_WSCB                          (FACILITY_BASE + 15)
#define FACILITY_DRWS                          (FACILITY_BASE + 16)
#define FACILITY_ISDM                          (FACILITY_BASE + 17)
#define FACILITY_AUTOREG                       (FACILITY_BASE + 18)
#define FACILITY_CAPREG                        (FACILITY_BASE + 19)
#define FACILITY_H245WS                        (FACILITY_BASE + 20)
#define FACILITY_H245                          (FACILITY_BASE + 21)
#define FACILITY_ARSCLIENT                     (FACILITY_BASE + 22)
#define FACILITY_PPM                           (FACILITY_BASE + 23)
#define FACILITY_STRMSP                        (FACILITY_BASE + 24)
#define FACILITY_STRMAN                        (FACILITY_BASE + 25) 
#define FACILITY_MIXERMSP                      (FACILITY_BASE + 26) 
#define FACILITY_GKI                           (FACILITY_BASE + 27)
#define FACILITY_CCLOCK                        (FACILITY_BASE + 28)

#define FACILITY_WINSOCK2                      FACILITY_WINSOCK

// Macros to support custom error reporting
//
#define MAKE_MSM_ERROR(error)                  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MSM, (error))
#define MAKE_AUDIOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUDIOMSP, (error))
#define MAKE_AUDIOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUDIOMSP, (error))
#define MAKE_VIDEOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_VIDEOMSP, (error))
#define MAKE_FILEIOMSP_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_FILEIOMSP,(error))
#define MAKE_RTPCHANMAN_ERROR(error)           MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_RTPCHANNELMANAGER, (error))
#define MAKE_RTPMSP_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_RTPMSP, (error))
#define MAKE_WINSOCK_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_WINSOCK, (error))
#define MAKE_TESTMSP_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_TESTMSP, (error))
#define MAKE_MSM_SESSION_CLASSES_ERROR(error)  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MSM_SESSION_CLASSES, (error))
#define MAKE_SCRIPTING_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_SCRIPTING,(error))
#define MAKE_Q931_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_Q931, (error))
#define MAKE_WSCB_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_WSCB, (error))
#define MAKE_DRWS_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_DRWS, (error))
#define MAKE_ISDM_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_ISDM, (error))
#define MAKE_AUTOREG_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUTOREG, (error))
#define MAKE_CAPREG_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_CAPREG, (error))
#define MAKE_H245WS_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245WS, (error))
#define MAKE_H245_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245, (error))
#define MAKE_ARSCLIENT_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_ARSCLIENT, (error))
#define MAKE_PPM_ERROR(error)                  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_PPM, (error))
#define MAKE_STRMSP_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_STRMSP, (error))
#define MAKE_STRMAN_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_STRMAN, (error))
#define MAKE_MIXERMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MIXERMSP, (error))


// Error defines for MSM
//
//
#define ERROR_BASE_ID                          0x8000
#define ERROR_LOCAL_BASE_ID                    0xA000

//
// MessageId: ERROR_UNKNOWN
//
// MessageText:
//
//  An unkown error has occured in the system
//
#define ERROR_UNKNOWN					(ERROR_BASE_ID +  0)


//
// MessageId: ERROR_INVALID_BUFFER
//
// MessageText:
//
//  An invalid buffer handle was encountered.
//
#define ERROR_INVALID_BUFFER			(ERROR_BASE_ID +  1)


//
// MessageId: ERROR_INVALID_BUFFER_SIZE
//
// MessageText:
//
//  An invalid buffer size was encountered.
//
#define ERROR_INVALID_BUFFER_SIZE		(ERROR_BASE_ID +  2)


//
// MessageId: ERROR_INVALID_CALL_ORDER
//
// MessageText:
//
//  A bad call sequence was encountered.
//
#define ERROR_INVALID_CALL_ORDER		(ERROR_BASE_ID +  3)


//
// MessageId: ERROR_INVALID_CONFIG_SETTING
//
// MessageText:
//
//  A specified configuration parameter was invalid
//
#define ERROR_INVALID_CONFIG_SETTING	(ERROR_BASE_ID +  4)


//
// MessageId: ERROR_INVALID_LINK
//
// MessageText:
//
//  An invalid link handle was encountered.
//
#define ERROR_INVALID_LINK				(ERROR_BASE_ID +  5)


//
// MessageId: ERROR_INVALID_PORT
//
// MessageText:
//
//  An invalid port handle was encountered.
//
#define ERROR_INVALID_PORT				(ERROR_BASE_ID +  6)


//
// MessageId: ERROR_INVALID_SERVICE
//
// MessageText:
//
//  An invalid service handle was encountered.
//
#define ERROR_INVALID_SERVICE			(ERROR_BASE_ID +  7)


//
// MessageId: ERROR_INVALID_SERVICE_DLL
//
// MessageText:
//
//  The specified service DLL does not support required interface
//
#define ERROR_INVALID_SERVICE_DLL		(ERROR_BASE_ID +  8)


//
// MessageId: ERROR_INVALID_SERIVCE_ID
//
// MessageText:
//
//  The specified service was not located in the registry
//
#define ERROR_INVALID_SERVICE_ID		(ERROR_BASE_ID +  9)


//
// MessageId: ERROR_INVALID_SESSION
//
// MessageText:
//
//  An invalid session handle was encountered.
//
#define ERROR_INVALID_SESSION			(ERROR_BASE_ID + 10)


//
// MessageId: ERROR_INVALID_SYNC
//
// MessageText:
//
//  An invalid sync handle was encountered.
//
#define ERROR_INVALID_SYNC				(ERROR_BASE_ID + 11)

//
// MessageId: ERROR_INVALID_VERSION
//
// MessageText:
//
//  An invalid version of an object or structure was detected.
//
#define ERROR_INVALID_VERSION			(ERROR_BASE_ID + 12)

//
// MessageId: ERROR_BUFFER_LIMIT
//
// MessageText:
//
//  No buffers are available for performing this operation.
//
#define ERROR_BUFFER_LIMIT				(ERROR_BASE_ID + 13)

//
// MessageId: ERROR_INVALID_SKEY
//
// MessageText:
//
//  An invalid status key was encountered.
//
#define ERROR_INVALID_SKEY				(ERROR_BASE_ID + 14)

//
// MessageId: ERROR_INVALID_SVALUE
//
// MessageText:
//
//  An invalid status value was encountered.
//
#define ERROR_INVALID_SVALUE			(ERROR_BASE_ID + 15)



#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // APIMSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\hidtsp\phonemgr\wxutil.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// helper classes and functions for building multimedia filters
//

#ifndef __WXUTIL__
#define __WXUTIL__

// eliminate spurious "statement has no effect" warnings.
#pragma warning(disable: 4705)

// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

#ifdef DEBUG
public:
    DWORD   m_currentOwner;
    DWORD   m_lockCount;
    BOOL    m_fTrace;        // Trace this one
public:
    CCritSec();
    ~CCritSec();
    void Lock();
    void Unlock();
#else

public:
    CCritSec() {
    InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
    DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
    EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
    LeaveCriticalSection(&m_CritSec);
    };
#endif
};

//
// To make deadlocks easier to track it is useful to insert in the
// code an assertion that says whether we own a critical section or
// not.  We make the routines that do the checking globals to avoid
// having different numbers of member functions in the debug and
// retail class implementations of CCritSec.  In addition we provide
// a routine that allows usage of specific critical sections to be
// traced.  This is NOT on by default - there are far too many.
//

#ifdef DEBUG
    BOOL WINAPI CritCheckIn(CCritSec * pcCrit);
    BOOL WINAPI CritCheckOut(CCritSec * pcCrit);
    void WINAPI DbgLockTrace(BOOL fTrace);
#else
    #define CritCheckIn(x) TRUE
    #define CritCheckOut(x) TRUE
    #define DbgLockTrace(pc, fT)
#endif


// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};



// wrapper for event objects
class CAMEvent
{

    // make copy constructor and assignment operator inaccessible

    CAMEvent(const CAMEvent &refEvent);
    CAMEvent &operator=(const CAMEvent &refEvent);

protected:
    HANDLE m_hEvent;
public:
    CAMEvent(BOOL fManualReset = FALSE);
    ~CAMEvent();

    // Cast to HANDLE - we don't support this as an lvalue
    operator HANDLE () const { return m_hEvent; };

    void Set() {EXECUTE_ASSERT(SetEvent(m_hEvent));};
    BOOL Wait(DWORD dwTimeout = INFINITE) {
    return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0);
    };
    void Reset() { ResetEvent(m_hEvent); };
    BOOL Check() { return Wait(0); };
};


// wrapper for event objects that do message processing
// This adds ONE method to the CAMEvent object to allow sent
// messages to be processed while waiting

class CAMMsgEvent : public CAMEvent
{

public:

    // Allow SEND messages to be processed while waiting
    BOOL WaitMsg(DWORD dwTimeout = INFINITE);
};

// old name supported for the time being
#define CTimeoutEvent CAMEvent

// support for a worker thread

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class AM_NOVTABLE CAMThread {

    // make copy constructor and assignment operator inaccessible

    CAMThread(const CAMThread &refThread);
    CAMThread &operator=(const CAMThread &refThread);

    CAMEvent m_EventSend;
    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;

protected:
    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CAMThread();
    ~CAMThread();

    CCritSec m_AccessLock;    // locks access by client threads
    CCritSec m_WorkerLock;    // locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    // wait for the next request
    DWORD GetRequest();

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper();
};


// CQueue
//
// Implements a simple Queue ADT.  The queue contains a finite number of
// objects, access to which is controlled by a semaphore.  The semaphore
// is created with an initial count (N).  Each time an object is added
// a call to WaitForSingleObject is made on the semaphore's handle.  When
// this function returns a slot has been reserved in the queue for the new
// object.  If no slots are available the function blocks until one becomes
// available.  Each time an object is removed from the queue ReleaseSemaphore
// is called on the semaphore's handle, thus freeing a slot in the queue.
// If no objects are present in the queue the function blocks until an
// object has been added.

#define DEFAULT_QUEUESIZE   2

template <class T> class CQueue {
private:
    HANDLE          hSemPut;        // Semaphore controlling queue "putting"
    HANDLE          hSemGet;        // Semaphore controlling queue "getting"
    CRITICAL_SECTION CritSect;      // Thread seriallization
    int             nMax;           // Max objects allowed in queue
    int             iNextPut;       // Array index of next "PutMsg"
    int             iNextGet;       // Array index of next "GetMsg"
    T              *QueueObjects;   // Array of objects (ptr's to void)

    void Initialize(int n) {
        iNextPut = iNextGet = 0;
        nMax = n;
        InitializeCriticalSection(&CritSect);
        hSemPut = CreateSemaphore(NULL, n, n, NULL);
        hSemGet = CreateSemaphore(NULL, 0, n, NULL);
        QueueObjects = new T[n];
    }


public:
    CQueue(int n) {
        Initialize(n);
    }

    CQueue() {
        Initialize(DEFAULT_QUEUESIZE);
    }

    ~CQueue() {
        delete [] QueueObjects;
        DeleteCriticalSection(&CritSect);
        CloseHandle(hSemPut);
        CloseHandle(hSemGet);
    }

    T GetQueueObject() {
        int iSlot;
        T Object;
        LONG lPrevious;

        // Wait for someone to put something on our queue, returns straight
        // away is there is already an object on the queue.
        //
        WaitForSingleObject(hSemGet, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextGet++ % nMax;
        Object = QueueObjects[iSlot];
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to put an object onto our queue as there
        // is now space available in the queue.
        //
        ReleaseSemaphore(hSemPut, 1L, &lPrevious);
        return Object;
    }

    void PutQueueObject(T Object) {
        int iSlot;
        LONG lPrevious;

        // Wait for someone to get something from our queue, returns straight
        // away is there is already an empty slot on the queue.
        //
        WaitForSingleObject(hSemPut, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextPut++ % nMax;
        QueueObjects[iSlot] = Object;
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to remove an object from our queue as there
        // is now an object available to be removed.
        //
        ReleaseSemaphore(hSemGet, 1L, &lPrevious);
    }
};

// miscellaneous string conversion functions
// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

int WINAPIV wsprintfWInternal(LPWSTR, LPCWSTR, ...);

LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    );
int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    );

#ifndef UNICODE
#define wsprintfW wsprintfWInternal
#define lstrcpyW lstrcpyWInternal
#define lstrcpynW lstrcpynWInternal
#define lstrcmpW lstrcmpWInternal
#define lstrcmpiW lstrcmpiWInternal
#define lstrlenW lstrlenWInternal
#endif

extern "C"
void * __stdcall memmoveInternal(void *, const void *, size_t);

inline void * __cdecl memchrInternal(const void *buf, int chr, size_t cnt)
{
#ifdef _X86_
    void *pRet = NULL;

    _asm {
        cld                 // make sure we get the direction right
        mov     ecx, cnt    // num of bytes to scan
        mov     edi, buf    // pointer byte stream
        mov     eax, chr    // byte to scan for
        repne   scasb       // look for the byte in the byte stream
        jnz     exit_memchr // Z flag set if byte found
        dec     edi         // scasb always increments edi even when it
                            // finds the required byte
        mov     pRet, edi
exit_memchr:
    }
    return pRet;

#else
    while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {
        buf = (unsigned char *)buf + 1;
        cnt--;
    }

    return(cnt ? (void *)buf : NULL);
#endif
}

void WINAPI IntToWstr(int i, LPWSTR wstr);

#define WstrToInt(sz) atoiW(sz)

inline int atoiW(const WCHAR *sz)
{
    int i = 0;

    while (*sz && *sz >= L'0' && *sz <= L'9')
        i = i*10 + *sz++ - L'0';
        
    return i;        
}

inline int WINAPI atoiA(const CHAR *sz)
{
    int i = 0;

    while (*sz && *sz >= '0' && *sz <= '9')
        i = i*10 + *sz++ - '0';
        
    return i;        
}

#ifdef UNICODE
#define atoi    atoiW
#else
#define atoi    atoiA
#endif



// These are available to help managing bitmap VIDEOINFOHEADER media structures

extern const DWORD bits555[3];
extern const DWORD bits565[3];
extern const DWORD bits888[3];

// These help convert between VIDEOINFOHEADER and BITMAPINFO structures

STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(WORD) GetBitCount(const GUID *pSubtype);

// strmbase.lib implements this for compatibility with people who
// managed to link to this directly.  we don't want to advertise it.
//
// STDAPI_(/* T */ CHAR *) GetSubtypeName(const GUID *pSubtype);

STDAPI_(CHAR *) GetSubtypeNameA(const GUID *pSubtype);
STDAPI_(WCHAR *) GetSubtypeNameW(const GUID *pSubtype);

#ifdef UNICODE
#define GetSubtypeName GetSubtypeNameW
#else
#define GetSubtypeName GetSubtypeNameA
#endif

STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo);
STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo);


// Compares two interfaces and returns TRUE if they are on the same object
BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond);

// This is for comparing pins
#define EqualPins(pPin1, pPin2) IsEqualObject(pPin1, pPin2)


// Arithmetic helper functions

// Compute (a * b + rnd) / c
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG rnd);
LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG rnd);


// Avoids us dyna-linking to SysAllocString to copy BSTR strings
STDAPI WriteBSTR(BSTR * pstrDest, LPCWSTR szSrc);
STDAPI FreeBSTR(BSTR* pstr);

// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR pszString, LPWSTR *ppszReturn);

// Special wait for objects owning windows
DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd = NULL, UINT uMsg = 0);
#endif /* __WXUTIL__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\filerecordingterminal.h ===
// FileRecordingTerminal.h: interface for the CFileRecordingTerminal class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILERECORDINGTERMINAL_H__A8DDD920_08D7_4CE8_AB7F_9AD202D4E6B0__INCLUDED_)
#define AFX_FILERECORDINGTERMINAL_H__A8DDD920_08D7_4CE8_AB7F_9AD202D4E6B0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "MultiTrackTerminal.h"
#include "..\terminals\Storage\RecordUnit.h"

#include "..\termmgr\resource.h"

#define MAX_MEDIA_TRACKS       (16)

extern const CLSID CLSID_FileRecordingTerminalCOMClass;


/////////////////////////////////////////////////////////////////
// Intermediate classes  used for DISPID encoding
template <class T>
class  ITMediaRecordVtbl : public ITMediaRecord
{
};

template <class T>
class  ITTerminalVtblFR : public ITTerminal
{
};
                                                                           
template <class T>
class  ITMediaControlVtblFR : public ITMediaControl
{
};


class CFileRecordingTerminal  : 
    public CComCoClass<CFileRecordingTerminal, &CLSID_FileRecordingTerminal>,
    public IDispatchImpl<ITMediaRecordVtbl<CFileRecordingTerminal>, &IID_ITMediaRecord, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITMediaControlVtblFR<CFileRecordingTerminal>, &IID_ITMediaControl, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITTerminalVtblFR<CFileRecordingTerminal>, &IID_ITTerminal, &LIBID_TAPI3Lib>,
    public ITPluggableTerminalInitialization,
    public CMSPObjectSafetyImpl,
    public CMultiTrackTerminal
{

public:

    DECLARE_REGISTRY_RESOURCEID(IDR_FILE_RECORDING)

    BEGIN_COM_MAP(CFileRecordingTerminal)
        COM_INTERFACE_ENTRY2(IDispatch, ITTerminal)
        COM_INTERFACE_ENTRY(ITMediaRecord)
        COM_INTERFACE_ENTRY(ITMediaControl)
        COM_INTERFACE_ENTRY(ITTerminal)
        COM_INTERFACE_ENTRY(ITPluggableTerminalInitialization)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_CHAIN(CMultiTrackTerminal)
    END_COM_MAP()


    //
    // ITTerminal methods
    //

    STDMETHOD(get_TerminalClass)(OUT  BSTR *pbstrTerminalClass);
    STDMETHOD(get_TerminalType) (OUT  TERMINAL_TYPE *pTerminalType);
    STDMETHOD(get_State)        (OUT  TERMINAL_STATE *pTerminalState);
    STDMETHOD(get_Name)         (OUT  BSTR *pVal);
    STDMETHOD(get_MediaType)    (OUT  long * plMediaType);
    STDMETHOD(get_Direction)    (OUT  TERMINAL_DIRECTION *pDirection);


    //
    // ITMediaRecord methods
    //

    virtual HRESULT STDMETHODCALLTYPE put_FileName( 
        IN BSTR bstrFileName
        );

    virtual HRESULT STDMETHODCALLTYPE get_FileName( 
         OUT BSTR *pbstrFileName);

    // 
    // ITPluggableTerminalInitialization methods
    //

    virtual HRESULT STDMETHODCALLTYPE InitializeDynamic (
	        IN IID                   iidTerminalClass,
	        IN DWORD                 dwMediaType,
	        IN TERMINAL_DIRECTION    Direction,
            IN MSP_HANDLE            htAddress
            );


    // 
    // ITMultiTrackTerminal methods
    //

    virtual HRESULT STDMETHODCALLTYPE CreateTrackTerminal(
            IN  long                  MediaType,
            IN  TERMINAL_DIRECTION    TerminalDirection,
            OUT ITTerminal         ** ppTerminal
            );

    virtual HRESULT STDMETHODCALLTYPE RemoveTrackTerminal(
            IN ITTerminal           * pTrackTerminalToRemove
            );

    //
    // ITMediaControl methods
    //

    virtual HRESULT STDMETHODCALLTYPE Start( void);
    
    virtual HRESULT STDMETHODCALLTYPE Stop( void);
    
    virtual HRESULT STDMETHODCALLTYPE Pause( void);
        
    virtual  HRESULT STDMETHODCALLTYPE get_MediaState( 
        OUT TERMINAL_MEDIA_STATE *pFileTerminalState);

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );


public:

    //
    // overriding IObjectSafety methods. we are only safe if properly 
    // initialized by terminal manager, so these methods will fail if this
    // is not the case.
    //

    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions);

    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions, 
                                         DWORD *pdwEnabledOptions);


public:

	CFileRecordingTerminal();

	virtual ~CFileRecordingTerminal();


    //
    // cleanup before destructor to make sure cleanup is done by the time the 
    // derived ccomobject is going away.
    //

    void FinalRelease();


    //
    // the derived class, CComObject, implements these. Here declare as pure 
    // virtual so we can refer to these methods from ChildRelease and 
    // ChildAddRef()
    // 
    
    virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
    virtual ULONG STDMETHODCALLTYPE Release() = 0;


    //
    // these methods are called by the track terminals when they need to notify
    // us when their refcount changes. the implementation is in the Multitrack class
    // but we also need this here, so we can prevent calling base class if
    // destructor are being executed. otherwise, CComObject's addref and release
    // might be called from ~CRecordingTerminal, at which point CComObject is 
    // already gone, which is not good.
    //

    virtual void ChildAddRef();
    virtual void ChildRelease();


    //
    // each track calls this method after it has been selected
    //

    HRESULT OnFilterConnected(CBRenderFilter *pRenderingFilter);

    
    //
    // this function is called whevever there is an event from the recording filter graph
    //

    HRESULT HandleFilterGraphEvent(long lEventCode, ULONG_PTR lParam1, ULONG_PTR lParam2);


private:


    //
    // a helper method that removes all the tracks. not thread safe.
    //

    HRESULT ShutdownTracks();


    //
    // a helper method that fires events on one of the tracks
    //

    HRESULT FireEvent(
            TERMINAL_MEDIA_STATE tmsState,
            FT_STATE_EVENT_CAUSE ftecEventCause,
            HRESULT hrErrorCode
            );



    //
    // a helper method that causes a state transition
    //

    HRESULT DoStateTransition(TERMINAL_MEDIA_STATE tmsDesiredState);

private:

    //
    // storage used for recording
    //

    CRecordingUnit *m_pRecordingUnit;


    //
    // the name of the file that is currently playing
    //

    BSTR m_bstrFileName;


    //
    // current terminal state
    //

    TERMINAL_MEDIA_STATE m_enState;


    //
    // current terminal state (selected?)
    //

    BOOL  m_TerminalInUse;


    //
    // address handle
    //

    MSP_HANDLE  m_mspHAddress;


    //
    // this terminal should only be instantiated in the context of terminal 
    // manager. the object will only be safe for scripting if it has been 
    // InitializeDynamic'ed. 
    //
    // this flag will be set when InitializeDynamic succeeds
    //

    BOOL m_bKnownSafeContext;


    //
    // this flag is set when the object is going away to prevent problems with 
    // tracks notifying the parent of addref/release after CComObject's 
    // desctructor completed
    //

    BOOL m_bInDestructor;

};

#endif // !defined(AFX_FILERECORDINGTERMINAL_H__A8DDD920_08D7_4CE8_AB7F_9AD202D4E6B0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\fpbridge.h ===
//
// FPPriv.h
//

#ifndef __FP_BRIDGE__
#define __FP_BRIDGE__

#include <OBJBASE.h>
#include <INITGUID.H>


// {7CFF69E2-FF93-4f48-BD94-F73D28589613}
DEFINE_GUID(IID_IFPBridge, 
0x7cff69e2, 0xff93, 0x4f48, 0xbd, 0x94, 0xf7, 0x3d, 0x28, 0x58, 0x96, 0x13);

//
// IFPBridge
//
DECLARE_INTERFACE_(
    IFPBridge, IUnknown)
{
    STDMETHOD (Deliver) (
        IN  long            nMediaType,
        IN  IMediaSample*   pSample
        ) = 0;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\ccerror.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/ccerror.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.0  $
 *      $Date:   16 Dec 1996 18:59:34  $
 *      $Author:   EHOWARDX  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CCERROR_H
#define CCERROR_H

#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

// Status codes
#define CC_OK							NOERROR
#define CC_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_OUTOFMEMORY)
#define CC_PEER_REJECT					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 1)
#define CC_BAD_PARAM					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 2)
#define CC_BAD_SIZE						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 3)
#define CC_ACTIVE_CONNECTIONS			MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 4)
#define CC_INTERNAL_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 5)
#define CC_NOT_IMPLEMENTED				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 6)
#define CC_DUPLICATE_CONFERENCE_ID		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 7)
#define CC_ILLEGAL_IN_MULTIPOINT		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 8)
#define CC_NOT_MULTIPOINT_CAPABLE		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 9)
#define CC_PEER_CANCEL					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 10)
#define CC_GKI_STATE                    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 21)
#define CC_GKI_CALL_STATE               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 22)
#define CC_GKI_LISTEN_NOT_FOUND         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 23)
#define CC_GATEKEEPER_REFUSED           MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 24)
#define CC_INVALID_WITHOUT_GATEKEEPER   MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 25)
#define CC_GKI_IP_ADDRESS               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 26)
#define CC_GKI_LOAD                     MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 27)


#ifdef __cplusplus
}
#endif

#endif CCERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\formats.h ===
//
// FORMATS.H
//

#ifndef __STREAM_FORMATS__
#define __STREAM_FORMATS__

#include <amvideo.h>

class CTAudioFormat :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ITScriptableAudioFormat, &IID_ITScriptableAudioFormat, &LIBID_TAPI3Lib>,
    public CMSPObjectSafetyImpl
{
public:
    CTAudioFormat();
    ~CTAudioFormat();

DECLARE_GET_CONTROLLING_UNKNOWN()

virtual HRESULT FinalConstruct(void);

public:

    BEGIN_COM_MAP(CTAudioFormat)
        COM_INTERFACE_ENTRY(ITScriptableAudioFormat)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_COM_MAP()

public:
    STDMETHOD(get_Channels)(
        OUT long* pVal
        );

    STDMETHOD(put_Channels)(
        IN    const long nNewVal
        );

    STDMETHOD(get_SamplesPerSec)(
        OUT long* pVal
        );

    STDMETHOD(put_SamplesPerSec)(
        IN    const long nNewVal
        );

    STDMETHOD(get_AvgBytesPerSec)(
        OUT long* pVal
        );

    STDMETHOD(put_AvgBytesPerSec)(
        IN    const long nNewVal
        );

    STDMETHOD(get_BlockAlign)(
        OUT long* pVal
        );

    STDMETHOD(put_BlockAlign)(
        IN    const long nNewVal
        );

    STDMETHOD(get_BitsPerSample)(
        OUT long* pVal
        );

    STDMETHOD(put_BitsPerSample)(
        IN    const long nNewVal
        );

    STDMETHOD(get_FormatTag)(
        OUT long* pVal
        );

    STDMETHOD(put_FormatTag)(
        IN const long nNewVal
        );

private:
    WAVEFORMATEX        m_wfx;        // Waveformat structure
    CMSPCritSection     m_Lock;     // Critical section
    IUnknown*            m_pFTM;     // pointer to the free threaded marshaler

public:
    HRESULT Initialize(
        IN const WAVEFORMATEX* pwfx
        )
    {
        //
        // Don't care right now for the buffer
        // 
 
        m_wfx = *pwfx;
        m_wfx.cbSize = 0;
        return S_OK;
    }
};


/*

class CTVideoFormat :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ITScriptableVideoFormat, &IID_ITScriptableVideoFormat, &LIBID_TAPI3Lib>,
    public CMSPObjectSafetyImpl
{
public:
    CTVideoFormat();
    ~CTVideoFormat();

DECLARE_GET_CONTROLLING_UNKNOWN()

virtual HRESULT FinalConstruct(void);

public:
    BEGIN_COM_MAP(CTVideoFormat)
        COM_INTERFACE_ENTRY(ITScriptableVideoFormat)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_COM_MAP()
public:
    STDMETHOD(get_BitRate)(
        OUT long* pVal
        );

    STDMETHOD(put_BitRate)(
        IN const long nNewVal
        );

    STDMETHOD(get_BitErrorRate)(
        OUT long* pVal
        );

    STDMETHOD(put_BitErrorRate)(
        IN const long nNewVal
        );

    STDMETHOD(get_AvgTimePerFrame)(
        OUT double* pVal
        );

    STDMETHOD(put_AvgTimePerFrame)(
        IN const double nNewVal
        );

    STDMETHOD(get_Width)(
        OUT long* pVal
        );

    STDMETHOD(put_Width)(
        IN const long nNewVal
        );

    STDMETHOD(get_Height)(
        OUT long* pVal
        );

    STDMETHOD(put_Height)(
        IN const long nNewVal
        );

    STDMETHOD(get_BitCount)(
        OUT long* pVal
        );

    STDMETHOD(put_BitCount)(
        IN const long nNewVal
        );

    STDMETHOD(get_Compression)(
        OUT long* pVal
        );

    STDMETHOD(put_Compression)(
        IN const long nNewVal
        );

    STDMETHOD(get_SizeImage)(
        OUT long* pVal
        );

    STDMETHOD(put_SizeImage)(
        IN const long nNewVal
        );

private:
    VIDEOINFOHEADER m_vih;            // Video structure
    CMSPCritSection     m_Lock;     // Critical section
    IUnknown*            m_pFTM;     // pointer to the free threaded marshaler

public:
    HRESULT Initialize(
        IN const VIDEOINFOHEADER* pvih
        )
    {
        m_vih = *pvih;
        return S_OK;
    }
};

*/

#endif

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\fpterm.h ===
//
// FPTerm.h
//

#ifndef __FPTERMINAL__
#define __FPTERMINAL__

#include "MultiTrackTerminal.h"

#include "..\terminals\Storage\FPUnit.h"
#include "fpbridge.h"

extern const CLSID CLSID_FilePlaybackTerminalCOMClass;

typedef enum
{
    TCS_NONE = 0,
    TCS_TOBECREATED,
    TCS_CREATED
} TRACK_CREATIONSTATE;

typedef struct
{
    TRACK_CREATIONSTATE CreationState;
    AM_MEDIA_TYPE*      pMediaType;
} TRACK_INFO;

typedef enum
{
    TRACK_AUDIO = 0,
    TRACK_VIDEO
} TRACK_MEDIATYPE;

//
// FilePlayback Terminal
// This is the class that implements the multitrack termnal
//

/////////////////////////////////////////////////////////////////
// Intermediate classes  used for DISPID encoding
template <class T>
class  ITMediaPlaybackVtbl : public ITMediaPlayback
{
};

template <class T>
class  ITTerminalVtbl : public ITTerminal
{
};
                                                                           
template <class T>
class  ITMediaControlVtbl : public ITMediaControl
{
};
                                                                           

//
// FilePlayback Terminal
// This is the class that implements the multitrack termnal
//

class CFPTerminal :
    public CComCoClass<CFPTerminal, &CLSID_FilePlaybackTerminal>,
    public IDispatchImpl<ITMediaPlaybackVtbl<CFPTerminal>, &IID_ITMediaPlayback, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITTerminalVtbl<CFPTerminal>, &IID_ITTerminal, &LIBID_TAPI3Lib>,
    public ITPluggableTerminalInitialization,
    public ITPluggableTerminalEventSinkRegistration,
    public IFPBridge,
    public IDispatchImpl<ITMediaControlVtbl<CFPTerminal>, &IID_ITMediaControl, &LIBID_TAPI3Lib>,
    public CMSPObjectSafetyImpl,
    public CMultiTrackTerminal
{
public:
    //
    // Constructor / Destructor
    //
    CFPTerminal();
    ~CFPTerminal();

    DECLARE_NOT_AGGREGATABLE(CFPTerminal) 
    DECLARE_GET_CONTROLLING_UNKNOWN()

    virtual HRESULT FinalConstruct(void);

public:

    DECLARE_REGISTRY_RESOURCEID(IDR_FILE_PLAYBACK)

    BEGIN_COM_MAP(CFPTerminal)
        COM_INTERFACE_ENTRY2(IDispatch, ITTerminal)
        COM_INTERFACE_ENTRY(ITMediaPlayback)
        COM_INTERFACE_ENTRY(ITTerminal)
        COM_INTERFACE_ENTRY(ITPluggableTerminalInitialization)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(ITMediaControl)
        COM_INTERFACE_ENTRY(ITPluggableTerminalEventSinkRegistration)
        COM_INTERFACE_ENTRY(IFPBridge)
        COM_INTERFACE_ENTRY_CHAIN(CMultiTrackTerminal)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    // --- ITTeminal ---

    STDMETHOD(get_TerminalClass)(
        OUT  BSTR *pVal);

    STDMETHOD(get_TerminalType)(
        OUT  TERMINAL_TYPE *pVal);

    STDMETHOD(get_State)(
        OUT  TERMINAL_STATE *pVal);

    STDMETHOD(get_Name)(
        OUT  BSTR *pVal);

    STDMETHOD(get_MediaType)(
        OUT  long * plMediaType);

    STDMETHOD(get_Direction)(
        OUT  TERMINAL_DIRECTION *pDirection);

    // --- ITMediaPlayback ---

    virtual HRESULT STDMETHODCALLTYPE put_PlayList(
        IN  VARIANTARG  PlayListVariant 
        );

    virtual HRESULT STDMETHODCALLTYPE get_PlayList(
        OUT  VARIANTARG*  pPlayListVariant 
        );

    // --- ITPluggableTerminalInitialization ---

    virtual HRESULT STDMETHODCALLTYPE InitializeDynamic (
            IN IID                   iidTerminalClass,
            IN DWORD                 dwMediaType,
            IN TERMINAL_DIRECTION    Direction,
            IN MSP_HANDLE            htAddress);

    // --- ITMediaControl ---

    virtual HRESULT STDMETHODCALLTYPE Start( void);
    
    virtual HRESULT STDMETHODCALLTYPE Stop( void);
    
    virtual HRESULT STDMETHODCALLTYPE Pause( void);
        
    virtual  HRESULT STDMETHODCALLTYPE get_MediaState( 
        OUT TERMINAL_MEDIA_STATE *pTerminalMediaState);
    
    // --- CMultiTrackTerminal ---
    virtual HRESULT STDMETHODCALLTYPE CreateTrackTerminal(
                IN long MediaType,
                IN TERMINAL_DIRECTION TerminalDirection,
                OUT ITTerminal **ppTerminal
                );

    // this function is not accessible on the playback terminal
    // so override it to retutn E_NOTSUPPORTED
    virtual HRESULT STDMETHODCALLTYPE RemoveTrackTerminal(
            IN ITTerminal           * pTrackTerminalToRemove
            );


    // --- ITPluggableTerminalEventSinkRegistration ---
    STDMETHOD(RegisterSink)(
        IN  ITPluggableTerminalEventSink *pSink
        );

    STDMETHOD(UnregisterSink)();

    // --- IFPBridge ---
    STDMETHOD(Deliver)(
        IN  long            nMediaType,
        IN  IMediaSample*   pSample
        );

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );


public:

    //
    // overriding IObjectSafety methods. we are only safe if properly 
    // initialized by terminal manager, so these methods will fail if this
    // is not the case.
    //

    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions);

    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions, 
                                         DWORD *pdwEnabledOptions);


private:
    // --- Memebers --
    TERMINAL_MEDIA_STATE  m_State;              // Terminal current state
    CMSPCritSection     m_Lock;                 // Critical section
    ITPluggableTerminalEventSink* m_pEventSink; // Fire events to client

    // --- Terminal attributes ---
    MSP_HANDLE          m_htAddress;            // MSP address handle
    IID                 m_TerminalClassID;      // TerminalClass
    TERMINAL_DIRECTION  m_Direction;            // Direction
    TERMINAL_STATE      m_TerminalState;        // Terminal State
    DWORD               m_dwMediaTypes;         // Media types supported
    TCHAR               m_szName[MAX_PATH+1];   // Terminal friendly name

    int                 m_nPlayIndex;           // Index of playing storage
    VARIANT             m_varPlayList;          // The playlist

    IUnknown*            m_pFTM;                // pointer to the free threaded marshaler

    CPlaybackUnit*      m_pPlaybackUnit;        // The playback graph


    HRESULT ValidatePlayList(
        IN  VARIANTARG  varPlayList,
        OUT long*       pnLeftBound,
        OUT long*       pnRightBound
        );

    HRESULT RollbackTrackInfo();

    //
    // uninitialize all tracks and remove them from the list of managed tracks
    //

    HRESULT ShutdownTracks();


    //
    // uninitialize a given track and remove it from the list of managed tracks
    //

    HRESULT InternalRemoveTrackTerminal(
                      IN ITTerminal *pTrackTerminalToRemove
                      );


    //
    // a helper method that fires events on one of the tracks
    //

    HRESULT FireEvent(
        TERMINAL_MEDIA_STATE tmsState,
        FT_STATE_EVENT_CAUSE ftecEventCause,
        HRESULT hrErrorCode
        );


    //
    // a helper method that attempts to stop all tracks
    //
    
    HRESULT StopAllTracks();

    BSTR    GetFileNameFromPlayList(
        IN  VARIANTARG  varPlayList,
        IN  long        nIndex
        );

    //
    // Create the playback graph
    //
    HRESULT CreatePlaybackUnit(
        IN  BSTR    bstrFileName
        );

	//
	// Play a file from the list
	//
	HRESULT ConfigurePlaybackUnit(
		IN	BSTR    bstrFileName
		);

    //
    // Helper method that causes a state transition
    //

    HRESULT DoStateTransition(
        IN  TERMINAL_MEDIA_STATE tmsDesiredState
        );

    //
    // Create a track for a specific media
    //

    HRESULT CreateMediaTracks(
        IN  long            nMediaType
        );

    HRESULT NextPlayIndex(
        );

public:

    //
    // Returns a track for a media type
    //
    int TracksCreated(
        IN  long    lMediaType
        );

    //
    // a helper method called by tracks when they decide to make a state change.
    //

    HRESULT TrackStateChange(TERMINAL_MEDIA_STATE tmsState,
                             FT_STATE_EVENT_CAUSE ftecEventCause,
                             HRESULT hrErrorCode);

    HRESULT PlayItem(
        IN  int nItem
        );

private:

    //
    // this terminal should only be instantiated in the context of terminal 
    // manager. the object will only be safe for scripting if it has been 
    // InitializeDynamic'ed. 
    //
    // this flag will be set when InitializeDynamic succeeds
    //

    BOOL m_bKnownSafeContext;

};


#endif

//eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\h245.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#ifndef _H245_Module_H_
#define _H245_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct TerminalCapabilitySet_capabilityTable * PTerminalCapabilitySet_capabilityTable;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define noMultiplex_chosen 1
#   define transportStream_chosen 2
#   define programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
    } u;
} MiscellaneousIndication_type;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
    } u;
} MiscellaneousCommand_type;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct H223AnnexAReconfiguration_headerCRC {
    ASN1choice_t choice;
#   define H223AnnexAReconfiguration_headerCRC_nil_chosen 1
#   define threebits_chosen 2
#   define H223AnnexAReconfiguration_headerCRC_eightbits_chosen 3
} H223AnnexAReconfiguration_headerCRC;

typedef struct H223AnnexAReconfiguration_headerFEC {
    ASN1choice_t choice;
#   define rate5by15_chosen 1
#   define rate6by31_chosen 2
#   define rate7by63_chosen 3
#   define rate7by15_chosen 4
#   define rate10by63_chosen 5
#   define rate11by31_chosen 6
#   define rate11by15_chosen 7
#   define rate16by63_chosen 8
#   define rate16by31_chosen 9
#   define rate18by63_chosen 10
} H223AnnexAReconfiguration_headerFEC;

typedef struct H223AnnexAReconfiguration_headerInterleaving {
    ASN1choice_t choice;
#   define bitInterleaving_chosen 1
#   define byteInterleaving_chosen 2
#   define noInterleaving_chosen 3
} H223AnnexAReconfiguration_headerInterleaving;

typedef struct H223AnnexAReconfiguration_synchFlagLength {
    ASN1choice_t choice;
#   define length15_chosen 1
#   define length31_chosen 2
} H223AnnexAReconfiguration_synchFlagLength;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct AL3MParameters_arqType {
    ASN1choice_t choice;
#   define AL3MParameters_arqType_noArq_chosen 1
#   define AL3MParameters_arqType_typeIArq_chosen 2
#   define AL3MParameters_arqType_typeIIArq_chosen 3
} AL3MParameters_arqType;

typedef struct AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define AL3MParameters_crcLength_nil_chosen 1
#   define AL3MParameters_crcLength_eightbits_chosen 2
#   define AL3MParameters_crcLength_sixteenbits_chosen 3
#   define AL3MParameters_crcLength_thirtytwobits_chosen 4
} AL3MParameters_crcLength;

typedef struct AL1MParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define AL1MParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} AL1MParameters_numberOfRetransmissions;

typedef struct AL1MParameters_arqType {
    ASN1choice_t choice;
#   define AL1MParameters_arqType_noArq_chosen 1
#   define AL1MParameters_arqType_typeIArq_chosen 2
#   define AL1MParameters_arqType_typeIIArq_chosen 3
} AL1MParameters_arqType;

typedef struct AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define AL1MParameters_crcLength_nil_chosen 1
#   define AL1MParameters_crcLength_eightbits_chosen 2
#   define AL1MParameters_crcLength_sixteenbits_chosen 3
#   define AL1MParameters_crcLength_thirtytwobits_chosen 4
} AL1MParameters_crcLength;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
#   define h261aVideoPacketization_chosen 1
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define wAddress_chosen 1
#   define woAddress_chosen 2
} V76LogicalChannelParameters_suspendResume;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct H223AnnexACapability_h223AnnexAMultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define H223AnnexACapability_h223AnnexAMultiplexTableCapability_basic_chosen 1
#	define H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced_chosen 2
	H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced enhanced;
    } u;
} H223AnnexACapability_h223AnnexAMultiplexTableCapability;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define H223Capability_h223MultiplexTableCapability_basic_chosen 1
#	define H223Capability_h223MultiplexTableCapability_enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223Capability {
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct MediaPacketizationCapability {
    ASN1bool_t h261aVideoPacketization;
} MediaPacketizationCapability;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H223AnnexACapability {
    ASN1bool_t transferWithI_frames;
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
    ASN1uint16_t maximumDelayJitter;
    ASN1bool_t reconfigurationCapability;
    H223AnnexACapability_h223AnnexAMultiplexTableCapability h223AnnexAMultiplexTableCapability;
} H223AnnexACapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
} H263VideoCapability;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelClose {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelClose;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct AL1MParameters {
    AL1MParameters_crcLength crcLength;
    ASN1uint16_t targetCodeRate;
    AL1MParameters_arqType arqType;
    AL1MParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} AL1MParameters;

typedef struct AL3MParameters {
    AL3MParameters_crcLength crcLength;
    ASN1uint16_t targetCodeRate;
    AL3MParameters_arqType arqType;
    ASN1uint16_t numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} AL3MParameters;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define suspendResumewAddress_chosen 1
#   define suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
} H263VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct H223AnnexAReconfiguration {
    H223AnnexAReconfiguration_synchFlagLength synchFlagLength;
    ASN1uint16_t informationFieldSize;
    H223AnnexAReconfiguration_headerInterleaving headerInterleaving;
    H223AnnexAReconfiguration_headerFEC headerFEC;
    H223AnnexAReconfiguration_headerCRC headerCRC;
    ASN1uint16_t headerCounterForward;
} H223AnnexAReconfiguration;

typedef struct H223AnnexAReconfigurationAck {
    char placeholder;
} H223AnnexAReconfigurationAck;

typedef struct H223AnnexAReconfigurationReject {
    char placeholder;
} H223AnnexAReconfigurationReject;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
    } u;
} ConferenceCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
    } u;
} ConferenceIndication;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
} NewATMVCIndication;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H2250Capability {
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
} H2250Capability;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define AudioCapability_g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define AudioCapability_g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define AudioCapability_g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729AnnexAwSilenceSuppression_chosen 15
	ASN1uint16_t g729AnnexAwSilenceSuppression;
    } u;
} AudioCapability;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
    } u;
} DataProtocolCapability;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define AudioMode_g722_64k_chosen 6
#	define AudioMode_g722_56k_chosen 7
#	define AudioMode_g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729AnnexAwSilenceSuppression_chosen 15
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
    } u;
} ConferenceRequest;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
    } u;
} EndSessionCommand;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataMode_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
    } u;
} DataMode_application;

typedef struct H223AnnexAModeParameters_adaptationLayertype {
    ASN1choice_t choice;
    union {
#	define H223AnnexAModeParameters_adaptationLayertype_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223AnnexAModeParameters_adaptationLayertype_al1M_chosen 2
	AL1MParameters al1M;
#	define H223AnnexAModeParameters_adaptationLayertype_al2M_chosen 3
#	define H223AnnexAModeParameters_adaptationLayertype_al3M_chosen 4
	AL3MParameters al3M;
    } u;
} H223AnnexAModeParameters_adaptationLayertype;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct H223AnnexALogicalChannelParameters_adaptationLayertype {
    ASN1choice_t choice;
    union {
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al1M_chosen 2
	AL1MParameters al1M;
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al2M_chosen 3
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al3M_chosen 4
	AL3MParameters al3M;
    } u;
} H223AnnexALogicalChannelParameters_adaptationLayertype;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataApplicationCapability_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
    } u;
} DataApplicationCapability_application;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
#	define h223AnnexACapability_chosen 6
	H223AnnexACapability h223AnnexACapability;
    } u;
} MultiplexCapability;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
    } u;
} DataType;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} TransportAddress;

typedef struct H223AnnexALogicalChannelParameters {
    H223AnnexALogicalChannelParameters_adaptationLayertype adaptationLayertype;
    ASN1bool_t segmentableFlag;
} H223AnnexALogicalChannelParameters;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct H223AnnexAModeParameters {
    H223AnnexAModeParameters_adaptationLayertype adaptationLayertype;
    ASN1bool_t segmentableFlag;
} H223AnnexAModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MCLocationIndication {
    TransportAddress signalAddress;
} MCLocationIndication;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define videoMode_chosen 2
	VideoMode videoMode;
#	define audioMode_chosen 3
	AudioMode audioMode;
#	define dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
    } u;
} ModeElement_type;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
    } u;
} CommandMessage;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    PTerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
    } u;
} Capability;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
} NetworkAccessParameters;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
} H2250LogicalChannelParameters;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h223AnnexAModeParameters_present 0x4000
    H223AnnexAModeParameters h223AnnexAModeParameters;
} ModeElement;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
} CommunicationModeTableEntry;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen 5
	H223AnnexALogicalChannelParameters h223AnnexALogicalChannelParameters;
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen 4
	H223AnnexALogicalChannelParameters h223AnnexALogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
} OpenLogicalChannelAck;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    PTerminalCapabilitySet_capabilityTable next;
    CapabilityTableEntry value;
} TerminalCapabilitySet_capabilityTable_Element;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
#	define h223AnnexAReconfiguration_chosen 14
	H223AnnexAReconfiguration h223AnnexAReconfiguration;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
#	define h223AnnexAReconfigurationAck_chosen 22
	H223AnnexAReconfigurationAck h223AnnexAReconfigurationAck;
#	define h223AnnexAReconfigurationReject_chosen 23
	H223AnnexAReconfigurationReject h223AnnexAReconfigurationReject;
    } u;
} ResponseMessage;

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 0
#define SIZE_H245_Module_PDU_0 sizeof(MultimediaSystemControlMessage)


extern ASN1module_t H245_Module;
extern void ASN1CALL H245_Module_Startup(void);
extern void ASN1CALL H245_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
	extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
	extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
	extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
	extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
	extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
	extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
	extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
	extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
	extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val);
	extern void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\h26xinc.h ===
/****************************************************************************
 *  @doc INTERNAL H26XINC
 *
 *  @module H26XInc.h | Header file for the common H.26X video codec defines.
 ***************************************************************************/

#ifndef _H26XINC_H_
#define _H26XINC_H_

enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5};

// MSH26X Configuration Information
typedef struct tagMSH26XCONF{
        BOOL    bInitialized;               // Whether custom msgs can be rcv'd.
        BOOL    bCompressBegin;                         // Whether the CompressBegin msg was rcv'd.
        BOOL    bRTPHeader;                 // Whether to generate RTP header info
        /* used if bRTPHeader */
        UINT    unPacketSize;               // Maximum packet size
        BOOL    bEncoderResiliency;         // Whether to use resiliency restrictions
        /* used if bEncoderResiliency */
        UINT    unPacketLoss;
        BOOL    bBitRateState;
        /* used if bBitRateState */
        UINT    unBytesPerSecond;
        /* The following information is determined from the packet loss value.   */
        /*  These values are calculated each time we receive a resiliency msg or */
        /*  the value is changed through the dialog box.  They are not stored in */
        /*  the registry.  Only the above elements are stored in the registry.   */
        BOOL    bDisallowPosVerMVs;             // if true, disallow positive vertical MVs
        BOOL    bDisallowAllVerMVs;             // if true, disallow all vertical MVs
        UINT    unPercentForcedUpdate;      // Percent Forced Update per Frame
        UINT    unDefaultIntraQuant;        // Default Intra Quant
        UINT    unDefaultInterQuant;        // Default Inter Quant
} MSH26XCONF;

// MSH26X Compressor Instance information
typedef struct tagMSH26XCOMPINSTINFO{
        BOOL            Initialized;
        WORD            xres, yres;
        FrameSize       FrameSz;                // Which of the supported frame sizes.
        float           FrameRate;
        DWORD           DataRate;               // Data rate in bytes per second.
        HGLOBAL         hEncoderInst;   // Instance data private to encoder.
        LPVOID          EncoderInst;
        WORD            CompressedSize;
        BOOL            Is160x120;
        BOOL            Is240x180;
        BOOL            Is320x240;
        MSH26XCONF      Configuration;
} MSH26XCOMPINSTINFO, *PMSH26XCOMPINSTINFO;

// MSH26X BitStream Info Trailer structure
typedef struct tagH26X_RTP_BSINFO_TRAILER {
        DWORD dwVersion;
        DWORD dwFlags;
        DWORD dwUniqueCode;
        DWORD dwCompressedSize;
        DWORD dwNumOfPackets;
        BYTE  bySrc;
        BYTE  byTR;
        BYTE  byTRB;
        BYTE  byDBQ;
} H26X_RTP_BSINFO_TRAILER, *PH26X_RTP_BSINFO_TRAILER;

// MSH263 BitStream Info structure
typedef struct tagRTP_H263_BSINFO {
        DWORD dwFlags;
        DWORD dwBitOffset;
        BYTE  byMode;
        BYTE  byMBA;
        BYTE  byQuant;
        BYTE  byGOBN;
        char  cHMV1;
        char  cVMV1;
        char  cHMV2;
        char  cVMV2;
} RTP_H263_BSINFO, *PRTP_H263_BSINFO;

// MSH261 BitStream Info structure
typedef struct tagRTP_H261_BSINFO {
        DWORD dwFlags;
        DWORD dwBitOffset;
        BYTE  byMBA;
        BYTE  byQuant;
        BYTE  byGOBN;
        char  cHMV;
        char  cVMV;
        BYTE  byPadding0;
        WORD  wPadding1;
} RTP_H261_BSINFO, *PRTP_H261_BSINFO;

// Constants
#define H263_RTP_BS_START_CODE          MakeFOURCC('H','2','6','3')
#define H261_RTP_BS_START_CODE          MakeFOURCC('H','2','6','1')
#define RTP_H26X_INTRA_CODED            0x00000001
#define RTP_H263_PB                                     0x00000002
#define RTP_H263_AP                                     0x00000004
#define RTP_H263_SAC                            0x00000008
#define RTP_H263_UMV                            0x00000010
#define RTP_H263_MODE_A                         0x00
#define RTP_H263_MODE_B                         0x01
#define RTP_H263_MODE_C                         0x02
#define H26X_RTP_PAYLOAD_VERSION    0x00000000
#define RTP_H26X_PACKET_LOST            0x00000001

// Decompressor Instance information
typedef struct
{
        BOOL            Initialized;
        BOOL            bProposedCorrectAspectRatio;// proposed
        BOOL            bCorrectAspectRatio;            // whether to correct the aspect ratio
        WORD            xres, yres;                                     // size of image within movie
        FrameSize       FrameSz;                                        // Which of the supported frame sizes.
//      int                     pXScale, pYScale;                       // proposed scaling (Query)
//      int                     XScale, YScale;                         // current scaling (Begin)
        UINT            uColorConvertor;                        // Current Color Convertor
        WORD            outputDepth;                            // and bit depth
        LPVOID          pDecoderInst;
        BOOL            UseActivePalette;                       // decompress to active palette == 1
        BOOL            InitActivePalette;                      // active palette initialized == 1
        BOOL            bUseBlockEdgeFilter;            // switch for block edge filter
        RGBQUAD         ActivePalette[256];                     // stored active palette
} DECINSTINFO, FAR *LPDECINST;

// Configuration Information
typedef struct
{
        BOOL    bInitialized;                   // Whether custom msgs can be rcv'd.
        BOOL    bCompressBegin;                 // Whether the CompressBegin msg was rcv'd.
        BOOL    bRTPHeader;                             // Whether to generate RTP header info
        // Used if bRTPHeader
        UINT    unPacketSize;                   // Maximum packet size
        BOOL    bEncoderResiliency;             // Whether to use resiliency restrictions
        // Used if bEncoderResiliency
        UINT    unPacketLoss;
        BOOL    bBitRateState;
        // Used if bBitRateState
        UINT    unBytesPerSecond;
        /* The following information is determined from the packet loss value.   */
        /*  These values are calculated each time we receive a resiliency msg or */
        /*  the value is changed through the dialog box.  They are not stored in */
        /*  the registry.  Only the above elements are stored in the registry.   */
        BOOL    bDisallowPosVerMVs;             // if true, disallow positive vertical MVs
        BOOL    bDisallowAllVerMVs;             // if true, disallow all vertical MVs
        UINT    unPercentForcedUpdate;  // Percent Forced Update per Frame
        UINT    unDefaultIntraQuant;    // Default Intra Quant
        UINT    unDefaultInterQuant;    // Default Inter Quant
} T_CONFIGURATION;

// Compressor Instance information
typedef struct
{
        BOOL                    Initialized;
        WORD                    xres, yres;
        FrameSize               FrameSz;                // Which of the supported frame sizes.
        float                   FrameRate;
        DWORD                   DataRate;               // Data rate in bytes per second.
        HGLOBAL                 hEncoderInst;   // Instance data private to encoder.
        LPVOID                  EncoderInst;
        WORD                    CompressedSize;
        BOOL                    Is160x120;
        BOOL                    Is240x180;
        BOOL                    Is320x240;
        T_CONFIGURATION Configuration;
} COMPINSTINFO, FAR *LPCODINST;

// Instance information
// @todo Remove useless fields of this structure
typedef struct tagINSTINFO
{
        DWORD           dwFlags;
        DWORD           fccHandler;     // So we know what codec has been opened.
        BOOL            enabled;
        LPCODINST       CompPtr;        // ICM
        LPDECINST       DecompPtr;      // ICM
} INSTINFO, FAR *LPINST;

// For GetProcAddresss on DriverProc
typedef LRESULT (WINAPI *LPFNDRIVERPROC)(IN DWORD dwDriverID, IN HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);

// FourCC codes for DDraw and codecs
#define FOURCC_YUY2     mmioFOURCC('Y', 'U', 'Y', '2')
#define FOURCC_UYVY     mmioFOURCC('U', 'Y', 'V', 'Y')
#define FOURCC_I420     mmioFOURCC('I', '4', '2', '0')
#define FOURCC_IYUV     mmioFOURCC('I', 'Y', 'U', 'V')
#define FOURCC_YV12     mmioFOURCC('Y', 'V', '1', '2')
#define FOURCC_M263     mmioFOURCC('M', '2', '6', '3')
#define FOURCC_M261     mmioFOURCC('M', '2', '6', '1')
#define FOURCC_R263     mmioFOURCC('R', '2', '6', '3')
#define FOURCC_R261     mmioFOURCC('R', '2', '6', '1')

#endif // _H26XINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\h245api.h ===
#ifndef H245API_H
#define H245API_H

/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245api.h  $
 *  $Revision:   1.64  $
 *  $Modtime:   04 Mar 1997 16:51:38  $
 *  $Log:   S:/sturgeon/src/include/vcs/h245api.h_v  $
 * 
 *    Rev 1.64   04 Mar 1997 17:32:36   MANDREWS
 * H245CopyCap() and H245CopyCapDescriptor() now return HRESULTs.
 * 
 *    Rev 1.63   26 Feb 1997 10:56:20   MANDREWS
 * Added H245_MAX_CAPID.
 * 
 *    Rev 1.62   Feb 24 1997 18:28:26   tomitowx
 * multiple modedescriptor support
 * 
 *    Rev 1.61   19 Dec 1996 17:16:10   EHOWARDX
 * Now using ASN.1 compiler C++ flag.
 * 
 *    Rev 1.60   17 Dec 1996 17:14:12   EHOWARDX
 * Added pSeparateStack to IND_OPEN_T.
 * 
 *    Rev 1.59   12 Dec 1996 11:24:38   EHOWARDX
 * Backed out H245_CONF_H323_OLD change.
 * 
 *    Rev 1.57   11 Dec 1996 13:46:46   SBELL1
 * Changed H245Init to return linkLayer Physical ID
 * 
 *    Rev 1.56   24 Oct 1996 15:57:54   MANDREWS
 * Fixed typo in last update.
 * 
 *    Rev 1.55   Oct 21 1996 17:11:00   mandrews
 * Fixed type in last check-in.
 * 
 *    Rev 1.54   Oct 21 1996 16:41:20   mandrews
 * Added H245_MASTER_SLAVE_CONFLICT as an additional openChannelReject
 * reason code.
 * 
 *    Rev 1.53   17 Oct 1996 18:17:54   EHOWARDX
 * Changed general string to always be Unicode.
 * 
 *    Rev 1.52   14 Oct 1996 14:00:28   EHOWARDX
 * 
 * Unicode changes.
 * 
 *    Rev 1.51   03 Sep 1996 18:09:54   EHOWARDX
 * 
 * Changed some parameters to const.
 * Changed H245_REQ_ENTRY_H243_CONFERENCE_ID to H245_REQ_ENTER_H243_CONFERENCE
 * 
 *    Rev 1.50   15 Aug 1996 14:33:48   EHOWARDX
 * Changed definition of H245_COMM_MODE_ENTRY_T as per Mike Andrews' request.
 * 
 *    Rev 1.49   24 Jul 1996 15:18:16   EHOWARDX
 * Backed out change of IndNonstandardRequest to IndNonstandardReq,
 * IndNonstandardResponse to IndNonStandardRsp, and IndNonstandardCommand to
 * IndNonstandardCmd to make less work for upper layers (CCTEST).
 * 
 *    Rev 1.48   19 Jul 1996 14:12:20   EHOWARDX
 * 
 * Added indication callback structure for CommunicationModeResponse and
 * CommunicationModeCommand.
 * 
 *    Rev 1.47   19 Jul 1996 12:50:30   EHOWARDX
 * 
 * Multipoint clean-up.
 * 
 *    Rev 1.46   16 Jul 1996 17:53:48   unknown
 * Added FNS indication.
 * 
 *    Rev 1.45   16 Jul 1996 11:51:58   EHOWARDX
 * 
 * Changed ERROR_LOCAL_BASE_ID to ERROR_BASE_ID.
 * 
 *    Rev 1.44   16 Jul 1996 11:46:10   EHOWARDX
 * 
 * Eliminated H245_ERROR_MUX_CAPS_ALREADY_SET (changing the existing
 * mux cap should not be an error).
 * 
 *    Rev 1.43   11 Jul 1996 18:42:14   rodellx
 * 
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 * 
 *    Rev 1.42   10 Jul 1996 11:33:42   unknown
 * Changed error base.
 * 
 *    Rev 1.41   01 Jul 1996 22:07:24   EHOWARDX
 * Added Conference and CommunicationMode structures and API functions.
 * 
 *    Rev 1.40   18 Jun 1996 14:48:54   EHOWARDX
 * 
 * Bumped version number to 2 and modified H245MaintenanceLoopRelease()
 * and associated Confirms.
 * 
 *    Rev 1.39   14 Jun 1996 18:59:38   EHOWARDX
 * Geneva update.
 * 
 *    Rev 1.38   31 May 1996 18:19:46   EHOWARDX
 * Brought error codes in line with STURERR.DOC guidelines.
 * 
 *    Rev 1.37   30 May 1996 23:37:26   EHOWARDX
 * Clean up.
 * 
 *    Rev 1.36   30 May 1996 13:55:02   EHOWARDX
 * Changed H245EndConnection to H245EndSession.
 * Removed H245_CONF_ENDCONNECTION.
 * 
 *    Rev 1.35   29 May 1996 14:23:58   EHOWARDX
 * Changed definition of H245_ERROR_OK back to 0 (NOERROR == S_OK == 0).
 * 
 *    Rev 1.34   29 May 1996 13:19:50   EHOWARDX
 * RESULT to HRESULT conversion.
 * 
 *    Rev 1.33   24 May 1996 23:12:56   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.32   21 May 1996 18:23:58   EHOWARDX
 * 
 * Added dwTransId parameter to H245RequestMultiplexEntry,
 * H245RequestMode, and H245MaintenanceLoopRequest.
 * 
 *    Rev 1.31   20 May 1996 14:14:42   EHOWARDX
 * Fixed typo.
 * 
 *    Rev 1.30   20 May 1996 14:05:20   EHOWARDX
 * Removed dwTransId formal parameter from H245EndConnection().
 * 
 *    Rev 1.29   16 May 1996 15:51:56   EHOWARDX
 * Fixed typo in H245_INVALID_CAPDESCID.
 * 
 *    Rev 1.28   16 May 1996 10:57:46   unknown
 * Added H245_INVALID_CAPDESCID.
 * 
 *    Rev 1.27   14 May 1996 20:20:14   EHOWARDX
 * Removed H245_IND_SYS.
 * 
 *    Rev 1.26   14 May 1996 19:00:58   EHOWARDX
 * Deleted unused H245_SYSCON_xxx values.
 * 
 *    Rev 1.25   14 May 1996 16:58:48   EHOWARDX
 * Changed H245_IND_CAPDESC_T To H245_TOTCAPDESC_T.
 * H245EnumCaps() cap desc callback now takes single pointer to
 * H245_TOTCAPDESC_T instead of separate H245_CAPDESCID_T and
 * H245_CAPDESC_T pointer.
 * 
 *    Rev 1.24   13 May 1996 23:13:46   EHOWARDX
 * Everything ready for Micrsoft drop on the 17th.
 * 
 *    Rev 1.23   13 May 1996 15:43:16   EHOWARDX
 * Changed return type of H245CopyCapDescriptor from H245_CAPDESC_T pointer
 * to H245_TOTCAPDESC_T pointer.
 * 
 *    Rev 1.22   13 May 1996 14:05:16   EHOWARDX
 * Added H245CopyCapDescriptor() and H245FreeCapDescriptor().
 * 
 *    Rev 1.21   11 May 1996 20:00:34   EHOWARDX
 * Changed IS1381 to IS13818 (correct name for capability).
 * Changed H245SystemControl() - eliminated dwTransId and added
 * H245_SYSCON_GET_XXX requests.
 * 
 *    Rev 1.20   10 May 1996 17:38:28   unknown
 * Changed H245GetCaps and H245EnumCaps to also return Cap Descriptors.
 * 
 *    Rev 1.19   09 May 1996 20:22:58   EHOWARDX
 * Latest and greatest...
 * 
 *    Rev 1.35   09 May 1996 19:38:14   EHOWARDX
 * Redesigned locking logic and added new functionality.
 * 
 *    Rev 1.34   06 May 1996 13:19:44   EHOWARDX
 * Moved enums out of structures.
 * Added H245NonStandardH221() and H245NonStandardObject().
 * 
 *    Rev 1.33   01 May 1996 19:29:16   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address to H245_xxx.
 * 
 *    Rev 1.32   27 Apr 1996 21:04:26   EHOWARDX
 * Changed channel numbers to words, added new open/open ack fields.
 * 
 *    Rev 1.31   26 Apr 1996 15:57:14   EHOWARDX
 * Added new Terminal Capabilities.
 * 
 *    Rev 1.27.1.6   25 Apr 1996 17:53:06   EHOWARDX
 * Added H245_INVALID_ID, currently set to zero, should be 0xFFFFFFFF later.
 * 
 *    Rev 1.27.1.5   25 Apr 1996 16:50:04   EHOWARDX
 * Added new functions as per API Changes spec.
 * 
 *    Rev 1.27.1.4   24 Apr 1996 20:57:30   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 * 
 *    Rev 1.27.1.3   18 Apr 1996 15:56:42   EHOWARDX
 * Updated to 1.30.
 * 
 *    Rev 1.27.1.2   16 Apr 1996 20:09:52   EHOWARDX
 * Added new H2250LogicalChannelParameter fields.
 * 
 *    Rev 1.27.1.1   16 Apr 1996 18:45:24   EHOWARDX
 * Added silenceSupression to H.225.0 Logical Channel Parameters.
 * 
 *    Rev 1.27.1.0   03 Apr 1996 15:56:14   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.27   02 Apr 1996 08:29:44   cjutzi
 * - Changed CapDescriptor API
 * 
 *    Rev 1.26   01 Apr 1996 16:46:50   cjutzi
 * 
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 * 
 *    Rev 1.25   29 Mar 1996 14:55:52   cjutzi
 * 
 * - added USERINPUT stuff
 * - Added hooks for stats in SYSCON H245SystemControl
 * 
 *    Rev 1.24   27 Mar 1996 10:55:40   cjutzi
 * - added c++ wrapper for API calls..
 *
 *    Rev 1.23   20 Mar 1996 14:42:46   cjutzi
 * - added ERROR NO_CAPDESC
 *
 *    Rev 1.22   18 Mar 1996 15:14:56   cjutzi
 *
 * - added RxPort and TEST_TIMER
 *
 *    Rev 1.21   12 Mar 1996 15:49:24   cjutzi
 *
 * - implemented locking
 * - added EndSession
 * - added Shutdown
 *
 *
 *    Rev 1.20   08 Mar 1996 14:06:04   cjutzi
 *
 * - Removed Simultanious capability api
 * - added CapabilityDescriptor api.. (very similar.. made more sence)
 * - compeleted Mux Table upcall information..
 *
 *    Rev 1.19   06 Mar 1996 08:45:58   cjutzi
 *
 * - added ERROR ASN1
 *
 *    Rev 1.18   05 Mar 1996 17:32:24   cjutzi
 *
 * - master slave indication message from Hani.. implemented..
 *   added H245_IND_MSTSLV ..
 *
 *    Rev 1.17   05 Mar 1996 16:36:46   cjutzi
 *
 * - removed MUX_ENTRY_DESC_T .. cleaned it up.. don't need it..
 *
 *    Rev 1.16   05 Mar 1996 10:06:30   cjutzi
 *
 * - added mux table entry stuff
 * - changed errors to map to 10000
 *
 *    Rev 1.15   01 Mar 1996 13:46:20   cjutzi
 * - added more error messages
 *
 *    Rev 1.14   29 Feb 1996 17:27:38   cjutzi
 *
 * - bi-directional channel working
 *
 *    Rev 1.13   29 Feb 1996 11:33:50   cjutzi
 * - fixed bug w/ H245_CONF_IND_T .. as global union.. fixed to be
 *   struct
 *
 *    Rev 1.12   29 Feb 1996 08:26:48   cjutzi
 *
 * - added 2 error messages (SIMCAPID and DATA_FORMAT)
 *
 *    Rev 1.11   27 Feb 1996 13:28:50   cjutzi
 * - added global protocol id H245_PROTOID
 *
 *    Rev 1.10   26 Feb 1996 17:24:10   cjutzi
 *
 * -  added MiscCommand.. had to add channel to H245_IND_MISC_T..
 *
 *    Rev 1.9   26 Feb 1996 11:07:24   cjutzi
 *
 * - added simultanoius caps..
 *
 *    Rev 1.8   16 Feb 1996 12:59:26   cjutzi
 * - added tracing and debug..
 * - got close to work.. Added structure to H245_IND_T.. new CLOSE indication
 *
 *    Rev 1.7   15 Feb 1996 14:13:08   cjutzi
 *
 * - re-arranged the AL_T entries for more clairity..
 *
 *    Rev 1.6   15 Feb 1996 10:48:30   cjutzi
 *
 * - major changes..
 * - added MUX_T
 * - changed H245_IND_T
 * - changed IND_OPEN/IND_OPEN_NEEDSRSP etc..
 *
 *    Rev 1.5   09 Feb 1996 16:14:04   cjutzi
 *
 * - removed init_success
 * - removed shutdown success
 * - added masterslave type for callback/confirm
 * - added SYSCON TraceLvl
 *
 *****************************************************************************/

//
// H.245 return codes
//
#if defined(OIL)

#include "common.x"
#define HRESULT RESULT
#define ERROR_BASE_ID             0x8000
#define MAKE_H245_ERROR(error)          (error)
#define H245_ERROR_OK                   0
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_BASE_ID+0x01) /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_BASE_ID+0x02) /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_BASE_ID+0x03) /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_BASE_ID+0x04) /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_BASE_ID+0x05) /* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_BASE_ID+0x06) /* system is not in the connected state             */

#else

#pragma warning( disable : 4115 4201 4214 4514 )
#include "apierror.h"
#define H245_ERROR_OK                   NOERROR
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_INVALID_DATA)       /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_OUTOFMEMORY)        /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_NOT_SUPPORTED)      /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_INVALID_PARAMETER)  /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_ALREADY_INITIALIZED)/* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_NOT_CONNECTED)      /* system is not in the connected state             */

#endif

#define H245_ERROR_NORESOURCE           MAKE_H245_ERROR(ERROR_BASE_ID+0x10) /* No resources left for this call                  */
#define H245_ERROR_NOTIMP               MAKE_H245_ERROR(ERROR_BASE_ID+0x11) /* H245 feature should be implemented.. but is not  */
#define H245_ERROR_SUBSYS               MAKE_H245_ERROR(ERROR_BASE_ID+0x12) /* subsystem failure.. error unknown                */
#define H245_ERROR_FATAL                MAKE_H245_ERROR(ERROR_BASE_ID+0x13) /* fatal error.. system will be coming down..       */
#define H245_ERROR_MAXTBL               MAKE_H245_ERROR(ERROR_BASE_ID+0x14) /* you have reached the maxium number of tbl entries*/
#define H245_ERROR_CHANNEL_INUSE        MAKE_H245_ERROR(ERROR_BASE_ID+0x15) /* channel is currently in use                      */
#define H245_ERROR_INVALID_CAPID        MAKE_H245_ERROR(ERROR_BASE_ID+0x16) /* Invalid Cap ID.. can not be found                */
#define H245_ERROR_INVALID_OP           MAKE_H245_ERROR(ERROR_BASE_ID+0x17) /* Invalid operation at this time..                 */
#define H245_ERROR_UNKNOWN              MAKE_H245_ERROR(ERROR_BASE_ID+0x18) /* unknown error                                    */
#define H245_ERROR_NOBANDWIDTH          MAKE_H245_ERROR(ERROR_BASE_ID+0x19) /* Bandwidth will not allow this                    */
#define H245_ERROR_LOSTCON              MAKE_H245_ERROR(ERROR_BASE_ID+0x1A) /* System connection .. channel 0 was lost          */
#define H245_ERROR_INVALID_MUXTBLENTRY  MAKE_H245_ERROR(ERROR_BASE_ID+0x1B) /* Invalid Multiplex Table Entry                    */
#define H245_ERROR_INVALID_INST         MAKE_H245_ERROR(ERROR_BASE_ID+0x1C) /* instance is either no longer valid or is invalid */
#define H245_ERROR_INPROCESS            MAKE_H245_ERROR(ERROR_BASE_ID+0x1D) /* request is denied.. action already in process    */
#define H245_ERROR_INVALID_STATE        MAKE_H245_ERROR(ERROR_BASE_ID+0x1E) /* Not proper state to process request              */
#define H245_ERROR_TIMEOUT              MAKE_H245_ERROR(ERROR_BASE_ID+0x1F) /* Timeout occured                                  */
#define H245_ERROR_INVALID_CHANNEL      MAKE_H245_ERROR(ERROR_BASE_ID+0x20) /* Invalid channel                                  */
#define H245_ERROR_INVALID_CAPDESCID    MAKE_H245_ERROR(ERROR_BASE_ID+0x21) /* Invalid Capbility Descriptor ID                  */
#define H245_ERROR_CANCELED             MAKE_H245_ERROR(ERROR_BASE_ID+0x22) /* operation you are responding to has been canceled*/
#define H245_ERROR_MUXELEMENT_DEPTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x23) /* Mux Table Entry is too complex.. MAX recursion   */
#define H245_ERROR_MUXELEMENT_WIDTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x24) /* Mux Table Entry has reached max subelement width */
#define H245_ERROR_ASN1                 MAKE_H245_ERROR(ERROR_BASE_ID+0x25) /* ASN1 PDU compiler error - see PDU log            */
#define H245_ERROR_NO_MUX_CAPS          MAKE_H245_ERROR(ERROR_BASE_ID+0x26) /* Mux Capabilities have not been loaded            */
#define H245_ERROR_NO_CAPDESC           MAKE_H245_ERROR(ERROR_BASE_ID+0x27) /* No Capability Descriptors set                    */

#if defined(REMOVE_FROM_TSP)

// declare exported functions
#if defined(H245DLL_EXPORT)
#define H245DLL __declspec (dllexport)
#else   // (H245DLL_EXPORT)
#define H245DLL __declspec (dllimport)
#endif  // (H245DLL_EXPORT)

#else  // REMOVE_FROM_TSP

#define H245DLL

#endif // REMOVE_FROM_TSP


/************************************/
/* ASN.1 DATASTRUCTURES ABSTRACTION */
/************************************/

#include "h245asn1.h"

typedef struct NonStandardIdentifier    H245_NONSTANDID_T;

typedef struct NonStandardParameter     H245_NONSTANDARD_PARAMETER_T;

typedef H245_NONSTANDARD_PARAMETER_T    H245_CAP_NONSTANDARD_T;

typedef struct H261VideoCapability      H245_CAP_H261_T;

typedef struct H262VideoCapability      H245_CAP_H262_T;

typedef struct H263VideoCapability      H245_CAP_H263_T;

typedef struct IS11172VideoCapability   H245_CAP_VIS11172_T;

typedef struct IS11172AudioCapability   H245_CAP_AIS11172_T;

typedef struct IS13818AudioCapability   H245_CAP_IS13818_T;

typedef struct DataApplicationCapability H245_CAP_DATAAPPLICATION_T;

typedef struct H222Capability           H245_CAP_H222_T;

typedef struct H223Capability           H245_CAP_H223_T;

typedef struct V76Capability            H245_CAP_VGMUX_T;

typedef struct H2250Capability          H245_CAP_H2250_T;

typedef struct ConferenceCapability     H245_CAP_CONFERENCE_T;

typedef struct TerminalLabel            H245_TERMINAL_LABEL_T;

#define PDU_T           MltmdSystmCntrlMssg
#define H245_ACCESS_T   NetworkAccessParameters
typedef unsigned long  H245_INST_T;
typedef unsigned short H245_CHANNEL_T;
typedef unsigned long  H245_PORT_T;
#define H245_INVALID_ID          ((H245_INST_T)0)
#define H245_INVALID_CHANNEL     ((H245_CHANNEL_T)0)
#define H245_INVALID_PORT_NUMBER ((H245_PORT_T)-1)

typedef struct
{
  unsigned int    length;
  unsigned char  *value;
} H245_OCTET_STRING_T;



/************************/
/* H245 ABSTRACTION     */
/************************/

/* H245_CAPDIR_T */
typedef enum
{
  H245_CAPDIR_DONTCARE = 0,
  H245_CAPDIR_RMTRX,
  H245_CAPDIR_RMTTX,
  H245_CAPDIR_RMTRXTX,
  H245_CAPDIR_LCLRX,
  H245_CAPDIR_LCLTX,
  H245_CAPDIR_LCLRXTX
} H245_CAPDIR_T;

/* H245_DATA_T */
typedef enum
{
  H245_DATA_DONTCARE = 0,
  H245_DATA_NONSTD,
  H245_DATA_NULL,
  H245_DATA_VIDEO,
  H245_DATA_AUDIO,
  H245_DATA_DATA,
  H245_DATA_ENCRYPT_D,
  H245_DATA_CONFERENCE,
  H245_DATA_MUX         /* mux parameters */
} H245_DATA_T;

/* H245_CLIENT_T */
typedef enum
{
  H245_CLIENT_DONTCARE = 0,     // For H245EnumCap/H245GetCap
  H245_CLIENT_NONSTD,

  H245_CLIENT_VID_NONSTD,
  H245_CLIENT_VID_H261,
  H245_CLIENT_VID_H262,
  H245_CLIENT_VID_H263,
  H245_CLIENT_VID_IS11172,

  H245_CLIENT_AUD_NONSTD,
  H245_CLIENT_AUD_G711_ALAW64,
  H245_CLIENT_AUD_G711_ALAW56,
  H245_CLIENT_AUD_G711_ULAW64,
  H245_CLIENT_AUD_G711_ULAW56,
  H245_CLIENT_AUD_G722_64,
  H245_CLIENT_AUD_G722_56,
  H245_CLIENT_AUD_G722_48,
  H245_CLIENT_AUD_G723,
  H245_CLIENT_AUD_G728,
  H245_CLIENT_AUD_G729,
  H245_CLIENT_AUD_GDSVD,
  H245_CLIENT_AUD_IS11172,
  H245_CLIENT_AUD_IS13818,

  H245_CLIENT_DAT_NONSTD,
  H245_CLIENT_DAT_T120,
  H245_CLIENT_DAT_DSMCC,
  H245_CLIENT_DAT_USERDATA,
  H245_CLIENT_DAT_T84,
  H245_CLIENT_DAT_T434,
  H245_CLIENT_DAT_H224,
  H245_CLIENT_DAT_NLPID,
  H245_CLIENT_DAT_DSVD,
  H245_CLIENT_DAT_H222,

  H245_CLIENT_ENCRYPTION_TX,
  H245_CLIENT_ENCRYPTION_RX,
  H245_CLIENT_CONFERENCE,

  // Multiplex capabilities
  H245_CLIENT_MUX_NONSTD,
  H245_CLIENT_MUX_H222,
  H245_CLIENT_MUX_H223,
  H245_CLIENT_MUX_VGMUX,
  H245_CLIENT_MUX_H2250,
  H245_CLIENT_MUX_H223_ANNEX_A

} H245_CLIENT_T;


/* H245_CAP_T */
typedef union
{
  H245_CAP_NONSTANDARD_T        H245_NonStd;            /* not implemented */

  H245_CAP_NONSTANDARD_T        H245Vid_NONSTD;
  H245_CAP_H261_T               H245Vid_H261;
  H245_CAP_H262_T               H245Vid_H262;
  H245_CAP_H263_T               H245Vid_H263;
  H245_CAP_VIS11172_T           H245Vid_IS11172;

  H245_CAP_NONSTANDARD_T        H245Aud_NONSTD;
  unsigned short                H245Aud_G711_ALAW64;
  unsigned short                H245Aud_G711_ALAW56;
  unsigned short                H245Aud_G711_ULAW64;
  unsigned short                H245Aud_G711_ULAW56;
  unsigned short                H245Aud_G722_64;
  unsigned short                H245Aud_G722_56;
  unsigned short                H245Aud_G722_48;
  H245_CAP_G723_T               H245Aud_G723;
  unsigned short                H245Aud_G728;
  unsigned short                H245Aud_G729;
  unsigned short                H245Aud_GDSVD;
  H245_CAP_AIS11172_T           H245Aud_IS11172;
  H245_CAP_IS13818_T            H245Aud_IS13818;

  H245_CAP_DATAAPPLICATION_T    H245Dat_NONSTD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T120;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSMCC;
  H245_CAP_DATAAPPLICATION_T    H245Dat_USERDATA;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T84;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T434;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H224;
  H245_CAP_DATAAPPLICATION_T    H245Dat_NLPID;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSVD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H222;

  ASN1_BOOL                     H245Encryption_TX;
  unsigned char                 H245Encryption_RX;
  H245_CAP_CONFERENCE_T         H245Conference;

  // Multiplex capabilities
  H245_CAP_NONSTANDARD_T        H245Mux_NONSTD;
  H245_CAP_H222_T               H245Mux_H222;
  H245_CAP_H223_T               H245Mux_H223;
  H245_CAP_VGMUX_T              H245Mux_VGMUX;
  H245_CAP_H2250_T              H245Mux_H2250;

} H245_CAP_T;

/* H245_CAPID_T */
typedef unsigned short H245_CAPID_T;
#define H245_INVALID_CAPID      ((H245_CAPID_T)-1)
#define H245_MAX_CAPID			(((H245_CAPID_T)-1) / 2)

/* H245_CAPDESCID_T */
typedef unsigned short H245_CAPDESCID_T;
#define H245_INVALID_CAPDESCID  ((H245_CAPDESCID_T)-1)

/* H245_SIMCAP_T */
#define H245_MAX_ALTCAPS        16
typedef struct
{
  unsigned short Length;                     /* number of CapId's in Array   */
  H245_CAPID_T AltCaps[H245_MAX_ALTCAPS];   /* list of alternatives CapId's */

} H245_SIMCAP_T;

#define H245_MAX_SIMCAPS        16
/* H245_CAPDESC_T */
typedef struct
{
  unsigned short Length;
  H245_SIMCAP_T SimCapArray[H245_MAX_SIMCAPS];

} H245_CAPDESC_T;

/* H245_TOTCAPDESC_T */
typedef struct
{
  H245_CAPDESCID_T      CapDescId;
  H245_CAPDESC_T        CapDesc;

} H245_TOTCAPDESC_T;

/* H245_TOTCAP_T */
typedef struct
{
  H245_CAPDIR_T   Dir;
  H245_DATA_T     DataType;
  H245_CLIENT_T   ClientType;
  H245_CAPID_T    CapId;
  H245_CAP_T      Cap;

} H245_TOTCAP_T;



/* H245_CONFIG_T */
typedef enum
{
  H245_CONF_H324 = 1,
  H245_CONF_H323,
  H245_CONF_H310,
  H245_CONF_GVD

} H245_CONFIG_T;




/* H245_ACC_REJ_T */

typedef unsigned long H245_ACC_REJ_T;

#define H245_ACC                        0
#define H245_REJ                        1 // unspecified

// Master Slave Determination reject causes
#define H245_REJ_MSD_IDENTICAL          identicalNumbers_chosen

// Terminal Capability Set reject causes
#define H245_REJ_UNDEF_TBL_ENTRY        undefinedTableEntryUsed_chosen
#define H245_REJ_DIS_CAP_EXCEED         dscrptrCpctyExcdd_chosen
#define H245_REJ_TBLENTRY_CAP_EXCEED    tblEntryCpctyExcdd_chosen

// Open Logical Channel reject causes
#define H245_REJ_REV_PARAM              unstblRvrsPrmtrs_chosen
#define H245_REJ_TYPE_NOTSUPPORT        dataTypeNotSupported_chosen
#define H245_REJ_TYPE_NOTAVAIL          dataTypeNotAvailable_chosen
#define H245_REJ_TYPE_UNKNOWN           unknownDataType_chosen
#define H245_REJ_AL_COMB                dtTypALCmbntnNtSpprtd_chosen
#define H245_REJ_MULTICAST              mltcstChnnlNtAllwd_chosen
#define H245_REJ_BANDWIDTH              insufficientBandwidth_chosen
#define H245_REJ_STACK                  sprtStckEstblshmntFld_chosen
#define H245_REJ_SESSION_ID             invalidSessionID_chosen
#define H245_REJ_MASTER_SLAVE_CONFLICT  masterSlaveConflict_chosen

// Request Channel Close reject causes - use H245_REJ

// Multiplex Table Entry Send reject causes
#define H245_REJ_MUX_COMPLICATED        descriptorTooComplex_chosen

// Request Mode reject causes
#define H245_REJ_UNAVAILABLE            modeUnavailable_chosen
#define H245_REJ_MULTIPOINT             multipointConstraint_chosen
#define H245_REJ_DENIED                 requestDenied_chosen




/* H245_ACC_REJ_MUX_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_ACC_REJ_MUX_T[15];

/* H245_H222_LOGICAL_PARAM_T */
typedef struct
{
  unsigned short        resourceID;
  unsigned short        subChannelID;
  ASN1_BOOL             pcr_pidPresent;
  unsigned short        pcr_pid;                // optional
  H245_OCTET_STRING_T   programDescriptors;     // optional
  H245_OCTET_STRING_T   streamDescriptors;      // optional
} H245_H222_LOGICAL_PARAM_T;

/* H245_H223_LOGICAL_PARAM_T */
typedef enum
{
  H245_H223_AL_NONSTD        = H223LCPs_aLTp_nnStndrd_chosen,
  H245_H223_AL_AL1FRAMED     = H223LCPs_aLTp_al1Frmd_chosen,
  H245_H223_AL_AL1NOTFRAMED  = H223LCPs_aLTp_al1NtFrmd_chosen,
  H245_H223_AL_AL2NOSEQ      = H223LCPs_aLTp_a2WSNs_1_chosen,
  H245_H223_AL_AL2SEQ        = H223LCPs_aLTp_a2WSNs_2_chosen,
  H245_H223_AL_AL3           = H223LCPs_aLTp_al3_chosen

} H245_H223_AL_T;

typedef struct
{
  H245_H223_AL_T                AlType;
  unsigned int                  SndBufSize;   // 0..16777215
  unsigned char                 CtlFldOctet;  // 0..2
  ASN1_BOOL                     SegmentFlag;
  H245_NONSTANDARD_PARAMETER_T  H223_NONSTD;

} H245_H223_LOGICAL_PARAM_T;

/* H245_VGMUX_LOGICAL_PARAM_T */
typedef enum
{
  H245_V76_CRC8BIT  = crc8bit_chosen,
  H245_V76_CRC16BIT = crc16bit_chosen,
  H245_V76_CRC32BIT = crc32bit_chosen
} H245_V76_CRC_LENGTH_T;

typedef enum
{
  H245_V76_WITH_ADDRESS    = wAddress_chosen,
  H245_V76_WITHOUT_ADDRESS = woAddress_chosen
} H245_V76_SUSPEND_RESUME_T;

typedef enum
{
  H245_V76_ERM   = eRM_chosen,
  H245_V76_UNERM = uNERM_chosen
} H245_V76_MODE_T;

typedef enum
{
  H245_V76_REJ   = rej_chosen,
  H245_V76_SREJ  = sREJ_chosen,
  H245_V76_MSREJ = mSREJ_chosen
} H245_V76_RECOVERY_T;

typedef struct
{
  H245_V76_CRC_LENGTH_T       crcLength;
  unsigned short              n401;
  ASN1_BOOL                   loopbackTestProcedure;
  H245_V76_SUSPEND_RESUME_T   suspendResume;
  ASN1_BOOL                   uIH;
  H245_V76_MODE_T             mode;
  unsigned short              windowSize;       // Only valid if mode = ERM
  H245_V76_RECOVERY_T         recovery;         // Only valid if mode = ERM
  ASN1_BOOL                   audioHeaderPresent;
} H245_VGMUX_LOGICAL_PARAM_T;


typedef struct
{
  unsigned char               type;
  /* Note: All unicast types should be odd */
#define H245_IP_UNICAST       1
#define H245_IP_MULTICAST     2
#define H245_IP6_UNICAST      3
#define H245_IP6_MULTICAST    4
#define H245_IPSSR_UNICAST    5  // IP Strict Source Route
#define H245_IPLSR_UNICAST    6  // IP Loose  Source Route
#define H245_IPX_UNICAST      9
#define H245_NETBIOS_UNICAST 11
  union
  {
    // type == H245_IP_UNICAST or H245_IP_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
    } ip;

    // type == H245_IP6_UNICAST or H245_IP6_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[16];
    } ip6;

    // type == H245_IPSSR_UNICAST or H245_IPLSR_UNICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
       unsigned char *        route;            // Routing info
       unsigned long          dwCount;          // Number of addresses in above
    } ipSourceRoute;

    // type == H245_IPX_UNICAST
    struct
    {
       unsigned char          node[6];
       unsigned char          netnum[4];
       unsigned char          tsapIdentifier[2];
    } ipx;

    // type == H245_NETBIOS_UNICAST
    unsigned char             netBios[16];
  } u;
} H245_TRANSPORT_ADDRESS_T;

/* H245_H2250_LOGICAL_PARAM_T */
typedef struct
{
  // Note: first 8 fields MUST be same as H245_H2250ACK_LOGICAL_PARAM_T
  H2250LCPs_nnStndrdLink      nonStandardList;              // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;        // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent; // TRUE if previous field used
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
  ASN1_BOOL                   silenceSuppression;           // TRUE if using silence suppression
  ASN1_BOOL                   silenceSuppressionPresent;    // TRUE if previous field used
  H245_TERMINAL_LABEL_T       destination;                  // Terminal label for destination
  ASN1_BOOL                   destinationPresent;           // TRUE if previous field used
  ASN1_BOOL                   h261aVideoPacketization;
} H245_H2250_LOGICAL_PARAM_T;

/* H245_H2250ACK_LOGICAL_PARAM_T */
typedef struct
{
  H2250LCAPs_nnStndrdLink     nonStandardList;             // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                // Transport address
  ASN1_BOOL                   mediaChannelPresent;         // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;         // Forward RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;  // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;       // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent;// TRUE if previous field used
  unsigned char               sessionID;                   // 1..255
  ASN1_BOOL                   sessionIDPresent;            // TRUE if previous field used
} H245_H2250ACK_LOGICAL_PARAM_T;


// Comments from MikeV.
// 07/17/98, mikev comments: this enum is hacky - it's using the ASN.1 choice 
// integers to tag internal structures.   The internal structures don't always 
// have a 1:1 relationship with the ASN.1. For example, H245_H2250ACK_LOGICAL_PARAM_T
// is tagged H245_H2250ACK, and there is no real "choice" for that

/* H245_MUX_T */
typedef enum
{
  H245_H222     = fLCPs_mPs_h222LCPs_chosen,
  H245_H223     = fLCPs_mPs_h223LCPs_chosen,
  H245_VGMUX    = fLCPs_mPs_v76LCPs_chosen,
  H245_H2250    = fLCPs_mPs_h2250LCPs_chosen,
  H245_H2250ACK = H245_H2250 + 1
} H245_MUX_KIND_T;

typedef struct
{
  H245_MUX_KIND_T Kind;
  union
  {
    H245_H222_LOGICAL_PARAM_T     H222;
    H245_H223_LOGICAL_PARAM_T     H223;
    H245_VGMUX_LOGICAL_PARAM_T    VGMUX;
    H245_H2250_LOGICAL_PARAM_T    H2250;
    H245_H2250ACK_LOGICAL_PARAM_T H2250ACK;
  } u;
} H245_MUX_T;


/*
   H245_MUX_ENTRY_ELEMENT_T

   This structure defines the multiplex pattern
   which will be used to decode bit patterns in
   a given mux table entry.  the Kind defines
   whether this is a recursive structure (i.e.
   pointing to yet another Mux Entry Element) or
   whether it is a terminating leaf in the recursive
   mux tree.

   RepeatCount indicates how many bits should be
   used for this channel.  If bit count == 0 this
   indicates repeat sequence until close flag
*/

typedef enum
{
  H245_MUX_LOGICAL_CHANNEL = 1,     /* logical channel number (Terminate list) */
  H245_MUX_ENTRY_ELEMENT            /* recursive.. yet another one             */
} H245_MUX_ENTRY_KIND_T;

typedef struct H245_MUX_ENTRY_ELEMENT_T
{
  struct H245_MUX_ENTRY_ELEMENT_T      *pNext;
  H245_MUX_ENTRY_KIND_T                 Kind;
  union
  {
      H245_CHANNEL_T                    Channel;
      struct H245_MUX_ENTRY_ELEMENT_T  *pMuxTblEntryElem;
  } u;

  /* RepeatCount                                */
  /* RepeatCount == 0 -> repeat until close     */
  /* RepeatCount != 0 -> repeate count          */
  unsigned long                         RepeatCount;

} H245_MUX_ENTRY_ELEMENT_T;


/*
   H245_MUX_TABLE_T

   an H245 Mux Table is defined as a linked list of
   Mux Entry Descriptors.  Each descriptor has an
   associated entry number.  These entry numbers
   range from 1-15 and must be unique within the table.
   The end of the list is designated by a pNext == NULL
*/

typedef  struct H245_MUX_TABLE_T
{
  struct H245_MUX_TABLE_T       *pNext;
  unsigned long                  MuxEntryId;
  H245_MUX_ENTRY_ELEMENT_T      *pMuxTblEntryElem;      /* NULL indicates delete entry */

} H245_MUX_TABLE_T;

/********************/
/********************/
/*  Indicator Code  */
/********************/
/********************/

#define H245_IND_MSTSLV                 0x01
#define H245_IND_CAP                    0x02
#define H245_IND_CESE_RELEASE           0x30
#define H245_IND_OPEN                   0x03
#define H245_IND_OPEN_CONF              0x04
#define H245_IND_CLOSE                  0x05
#define H245_IND_REQ_CLOSE              0x06
#define H245_IND_CLCSE_RELEASE          0x31
#define H245_IND_MUX_TBL                0x07
#define H245_IND_MTSE_RELEASE           0x08
#define H245_IND_RMESE                  0x09
#define H245_IND_RMESE_RELEASE          0x0A
#define H245_IND_MRSE                   0x0B
#define H245_IND_MRSE_RELEASE           0x0C
#define H245_IND_MLSE                   0x0D
#define H245_IND_MLSE_RELEASE           0x0E
#define H245_IND_NONSTANDARD_REQUEST    0x0F
#define H245_IND_NONSTANDARD_RESPONSE   0x10
#define H245_IND_NONSTANDARD_COMMAND    0x11
#define H245_IND_NONSTANDARD            0x12
#define H245_IND_MISC_COMMAND           0x13
#define H245_IND_MISC                   0x14
#define H245_IND_COMM_MODE_REQUEST      0x15
#define H245_IND_COMM_MODE_RESPONSE     0x16
#define H245_IND_COMM_MODE_COMMAND      0x17
#define H245_IND_CONFERENCE_REQUEST     0x18
#define H245_IND_CONFERENCE_RESPONSE    0x19
#define H245_IND_CONFERENCE_COMMAND     0x1A
#define H245_IND_CONFERENCE             0x1B
#define H245_IND_SEND_TERMCAP           0x1C
#define H245_IND_ENCRYPTION             0x1D
#define H245_IND_FLOW_CONTROL           0x1E
#define H245_IND_ENDSESSION             0x1F
#define H245_IND_FUNCTION_NOT_UNDERSTOOD 0x20
#define H245_IND_JITTER                 0x21
#define H245_IND_H223_SKEW              0x22
#define H245_IND_NEW_ATM_VC             0x23
#define H245_IND_USERINPUT              0x24
#define H245_IND_H2250_MAX_SKEW         0x25
#define H245_IND_MC_LOCATION            0x26
#define H245_IND_VENDOR_ID              0x27
#define H245_IND_FUNCTION_NOT_SUPPORTED 0x28
#define H245_IND_H223_RECONFIG          0x29
#define H245_IND_H223_RECONFIG_ACK      0x2A
#define H245_IND_H223_RECONFIG_REJECT   0x2B

/* H245_MSTSLV_T */
typedef enum
{
  H245_INDETERMINATE = 0,       // Master/Slave Determination failed
  H245_MASTER = master_chosen,  // Local terminal is Master
  H245_SLAVE  = slave_chosen    // Local terminal is Slave

} H245_MSTSLV_T;

/* H245_IND_OPEN_T */
typedef struct
{
  /* for receive */
  H245_CHANNEL_T RxChannel;
  H245_PORT_T    RxPort;        // optional
  H245_DATA_T    RxDataType;
  H245_CLIENT_T  RxClientType;
  H245_CAP_T    *pRxCap;
  H245_MUX_T    *pRxMux;

  /* for bi-directional channel */
  /* requested transmit stuff   */

  H245_DATA_T    TxDataType;
  H245_CLIENT_T  TxClientType;
  H245_CAP_T    *pTxCap;
  H245_MUX_T    *pTxMux;

  H245_ACCESS_T *pSeparateStack; // optional

} H245_IND_OPEN_T;

/* H245_IND_OPEN_CONF_T */
typedef struct
{
  /* receive channel              */
  /* remote requested channel #   */
  H245_CHANNEL_T          RxChannel;

  /* transmit channel                     */
  /* locally opened transmit channel #    */
  H245_CHANNEL_T          TxChannel;

} H245_IND_OPEN_CONF_T;

/* H245_IND_CLOSE_T */
typedef enum
{
  H245_USER = user_chosen,
  H245_LCSE = lcse_chosen

} H245_IND_CLOSE_REASON_T;

typedef struct
{
  H245_CHANNEL_T          Channel;
  H245_IND_CLOSE_REASON_T Reason;

} H245_IND_CLOSE_T;

/* H245_IND_MUX_TBL */
typedef struct
{
  H245_MUX_TABLE_T      *pMuxTbl;
  unsigned long          Count;

} H245_IND_MUXTBL_T;

/* H245_RMESE_T */
typedef struct
{
  unsigned short        awMultiplexTableEntryNumbers[15];
  unsigned long         dwCount;

} H245_RMESE_T;

/* H245_IND_MRSE_T */
typedef struct
{
  RequestedModesLink pRequestedModes;

} H245_IND_MRSE_T;

/* H245_MLSE_T */
typedef enum
{
  H245_SYSTEM_LOOP  = systemLoop_chosen,
  H245_MEDIA_LOOP   = mediaLoop_chosen,
  H245_CHANNEL_LOOP = logicalChannelLoop_chosen

} H245_LOOP_TYPE_T;

typedef struct
{
  H245_LOOP_TYPE_T      LoopType;
  H245_CHANNEL_T        Channel;

} H245_MLSE_T;

/* H245_IND_ENDSESSION_T */
typedef enum
{
  H245_ENDSESSION_NONSTD     = EndSssnCmmnd_nonStandard_chosen,
  H245_ENDSESSION_DISCONNECT = disconnect_chosen,
  H245_ENDSESSION_TELEPHONY,
  H245_ENDSESSION_V8BIS,
  H245_ENDSESSION_V34DSVD,
  H245_ENDSESSION_V34DUPFAX,
  H245_ENDSESSION_V34H324

} H245_ENDSESSION_T;

typedef struct
{
  H245_ENDSESSION_T             SessionMode;
  /* if non standard chosen */
  H245_NONSTANDARD_PARAMETER_T  SessionNonStd;

} H245_IND_ENDSESSION_T;

/* H245_IND_NONSTANDARD_T */
typedef struct
{
  unsigned char *        pData;
  unsigned long          dwDataLength;
  unsigned short *       pwObjectId;
  unsigned long          dwObjectIdLength;
  unsigned char          byCountryCode;
  unsigned char          byExtension;
  unsigned short         wManufacturerCode;
} H245_IND_NONSTANDARD_T;

typedef struct
{
  CMTEy_nnStndrdLink          pNonStandard;                 // NULL if not present
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  H245_TERMINAL_LABEL_T       terminalLabel;
  ASN1_BOOL                   terminalLabelPresent;
  unsigned short *            pSessionDescription;
  unsigned short              wSessionDescriptionLength;
  H245_TOTCAP_T               dataType;
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
} H245_COMM_MODE_ENTRY_T;

typedef struct
{
  H245_COMM_MODE_ENTRY_T *pTable;
  unsigned char          byTableCount;
} H245_IND_COMM_MODE_T;

typedef enum
{
  H245_REQ_TERMINAL_LIST            = terminalListRequest_chosen,
  H245_REQ_MAKE_ME_CHAIR            = makeMeChair_chosen,
  H245_REQ_CANCEL_MAKE_ME_CHAIR     = cancelMakeMeChair_chosen,
  H245_REQ_DROP_TERMINAL            = dropTerminal_chosen,
  H245_REQ_TERMINAL_ID              = requestTerminalID_chosen,
  H245_REQ_ENTER_H243_PASSWORD      = enterH243Password_chosen,
  H245_REQ_ENTER_H243_TERMINAL_ID   = enterH243TerminalID_chosen,
  H245_REQ_ENTER_H243_CONFERENCE_ID = enterH243ConferenceID_chosen
} H245_CONFER_REQ_ENUM_T;

typedef struct
{
  H245_CONFER_REQ_ENUM_T  RequestType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_REQ_T;

typedef enum
{
  H245_RSP_MC_TERMINAL_ID           = mCTerminalIDResponse_chosen,
  H245_RSP_TERMINAL_ID              = terminalIDResponse_chosen,
  H245_RSP_CONFERENCE_ID            = conferenceIDResponse_chosen,
  H245_RSP_PASSWORD                 = passwordResponse_chosen,
  H245_RSP_TERMINAL_LIST            = terminalListResponse_chosen,
  H245_RSP_VIDEO_COMMAND_REJECT     = videoCommandReject_chosen,
  H245_RSP_TERMINAL_DROP_REJECT     = terminalDropReject_chosen,
  H245_RSP_DENIED_CHAIR_TOKEN,
  H245_RSP_GRANTED_CHAIR_TOKEN
} H245_CONFER_RSP_ENUM_T;

typedef struct
{
  H245_CONFER_RSP_ENUM_T  ResponseType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
  unsigned char          *pOctetString;
  unsigned char           byOctetStringLength;
  TerminalLabel          *pTerminalList;
  unsigned short          wTerminalListCount;
} H245_CONFER_RSP_T;

typedef enum
{
  H245_CMD_BROADCAST_CHANNEL        = brdcstMyLgclChnnl_chosen,
  H245_CMD_CANCEL_BROADCAST_CHANNEL = cnclBrdcstMyLgclChnnl_chosen,
  H245_CMD_BROADCASTER              = makeTerminalBroadcaster_chosen,
  H245_CMD_CANCEL_BROADCASTER       = cnclMkTrmnlBrdcstr_chosen,
  H245_CMD_SEND_THIS_SOURCE         = sendThisSource_chosen,
  H245_CMD_CANCEL_SEND_THIS_SOURCE  = cancelSendThisSource_chosen,
  H245_CMD_DROP_CONFERENCE          = dropConference_chosen
} H245_CONFER_CMD_ENUM_T;

typedef struct
{
  H245_CONFER_CMD_ENUM_T  CommandType;
  H245_CHANNEL_T          Channel;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_CMD_T;

typedef enum
{
  H245_IND_SBE_NUMBER               = sbeNumber_chosen,
  H245_IND_TERMINAL_NUMBER_ASSIGN   = terminalNumberAssign_chosen,
  H245_IND_TERMINAL_JOINED          = terminalJoinedConference_chosen,
  H245_IND_TERMINAL_LEFT            = terminalLeftConference_chosen,
  H245_IND_SEEN_BY_ONE_OTHER        = seenByAtLeastOneOther_chosen,
  H245_IND_CANCEL_SEEN_BY_ONE_OTHER = cnclSnByAtLstOnOthr_chosen,
  H245_IND_SEEN_BY_ALL              = seenByAll_chosen,
  H245_IND_CANCEL_SEEN_BY_ALL       = cancelSeenByAll_chosen,
  H245_IND_TERMINAL_YOU_ARE_SEEING  = terminalYouAreSeeing_chosen,
  H245_IND_REQUEST_FOR_FLOOR        = requestForFloor_chosen
} H245_CONFER_IND_ENUM_T;

typedef struct
{
  H245_CONFER_IND_ENUM_T  IndicationType;
  unsigned char           bySbeNumber;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_IND_T;

typedef enum
{
  H245_SCOPE_CHANNEL_NUMBER   = FCCd_scp_lgclChnnlNmbr_chosen,
  H245_SCOPE_RESOURCE_ID      = FlwCntrlCmmnd_scp_rsrcID_chosen,
  H245_SCOPE_WHOLE_MULTIPLEX  = FCCd_scp_whlMltplx_chosen
} H245_SCOPE_T;

#define H245_NO_RESTRICTION 0xFFFFFFFFL

typedef struct
{
  H245_SCOPE_T           Scope;
  H245_CHANNEL_T         Channel;       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
  unsigned short         wResourceID;   // only used if Scope is H245_SCOPE_RESOURCE_ID
  unsigned long          dwRestriction; // H245_NO_RESTRICTION if no restriction
} H245_IND_FLOW_CONTROL_T;

/* H245_USERINPUT_T */
typedef enum
{
  H245_USERINPUT_NONSTD = UsrInptIndctn_nnStndrd_chosen,
  H245_USERINPUT_STRING = alphanumeric_chosen
} H245_USERINPUT_KIND_T;

typedef struct
{
  H245_USERINPUT_KIND_T     Kind;
  union
  {
    WCHAR *                           pGenString;
    H245_NONSTANDARD_PARAMETER_T      NonStd;
  } u;
} H245_IND_USERINPUT_T;

typedef struct
{
  H245_CHANNEL_T        LogicalChannelNumber1;
  H245_CHANNEL_T        LogicalChannelNumber2;
  unsigned short        wSkew;
} H245_IND_SKEW_T;

typedef struct
{
  H245_NONSTANDID_T      Identifier;
  unsigned char         *pProductNumber;
  unsigned char          byProductNumberLength;
  unsigned char         *pVersionNumber;
  unsigned char          byVersionNumberLength;
} H245_IND_VENDOR_ID_T;

typedef enum
{
  UNKNOWN,
  REQ_NONSTANDARD,
  REQ_MASTER_SLAVE,
  REQ_TERMCAP_SET,
  REQ_OPEN_LOGICAL_CHANNEL,
  REQ_CLOSE_LOGICAL_CHANNEL,
  REQ_REQUEST_CHANNEL_CLOSE,
  REQ_MULTIPLEX_ENTRY_SEND,
  REQ_REQUEST_MULTIPLEX_ENTRY,
  REQ_REQUEST_MODE,
  REQ_ROUND_TRIP_DELAY,
  REQ_MAINTENANCE_LOOP,
  REQ_COMMUNICATION_MODE,
  REQ_CONFERENCE,
  REQ_H223_ANNEX_A_RECONFIG,
  RSP_NONSTANDARD,
  RSP_MASTER_SLAVE_ACK,
  RSP_MASTER_SLAVE_REJECT,
  RSP_TERMCAP_SET_ACK,
  RSP_TERMCAP_SET_REJECT,
  RSP_OPEN_LOGICAL_CHANNEL_ACK,
  RSP_OPEN_LOGICAL_CHANNEL_REJECT,
  RSP_CLOSE_LOGICAL_CHANNEL_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_REJECT,
  RSP_MULTIPLEX_ENTRY_SEND_ACK,
  RSP_MULTIPLEX_ENTRY_SEND_REJECT,
  RSP_REQUEST_MULTIPLEX_ENTRY_ACK,
  RSP_REQUEST_MULTIPLEX_ENTRY_REJECT,
  RSP_REQUEST_MODE_ACK,
  RSP_REQUEST_MODE_REJECT,
  RSP_ROUND_TRIP_DELAY,
  RSP_MAINTENANCE_LOOP_ACK,
  RSP_MAINTENANCE_LOOP_REJECT,
  RSP_COMMUNICATION_MODE,
  RSP_CONFERENCE,
  RSP_H223_ANNEX_A_RECONFIG_ACK,
  RSP_H223_ANNEX_A_RECONFIG_REJECT,
  CMD_NONSTANDARD,
  CMD_MAINTENANCE_LOOP_OFF,
  CMD_SEND_TERMCAP,
  CMD_ENCRYPTION,
  CMD_FLOW_CONTROL,
  CMD_END_SESSION,
  CMD_MISCELLANEOUS,
  CMD_COMMUNICATION_MODE,
  CMD_CONFERENCE,
  IND_NONSTANDARD,
  IND_FUNCTION_NOT_UNDERSTOOD,
  IND_MASTER_SLAVE_RELEASE,
  IND_TERMCAP_SET_RELEASE,
  IND_OPEN_LOGICAL_CHANNEL_CONFIRM,
  IND_REQUEST_CHANNEL_CLOSE_RELEASE,
  IND_MULTIPLEX_ENTRY_SEND_RELEASE,
  IND_REQUEST_MULTIPLEX_ENTRY_RELEASE,
  IND_REQUEST_MODE_RELEASE,
  IND_MISCELLANEOUS,
  IND_JITTER,
  IND_H223_SKEW,
  IND_NEW_ATM_VC,
  IND_USER_INPUT,
  IND_H2250_MAX_SKEW,
  IND_MC_LOCATION,
  IND_CONFERENCE_INDICATION,
  IND_VENDOR_IDENTIFICATION,
  IND_FUNCTION_NOT_SUPPORTED,
} H245_SUBMESSAGE_T;

typedef enum
{
  H245_SYNTAX_ERROR     = syntaxError_chosen,
  H245_SEMANTIC_ERROR   = semanticError_chosen,
  H245_UNKNOWN_FUNCTION = unknownFunction_chosen
} H245_FNS_CAUSE_T;

typedef struct
{
  H245_FNS_CAUSE_T      Cause;
  H245_SUBMESSAGE_T     Type;
} H245_IND_FNS_T;

/**************/
/* H245_IND_T */
/**************/

typedef struct
{
  unsigned long         Indicator;              // Type
  unsigned long         dwPreserved;            // User supplied dwPreserved from H245Init()
  union
  {
    H245_MSTSLV_T            IndMstSlv;         // H245_IND_MSTSLV
                                                // H245_IND_CAP
                                                // H245_IND_CESE_RELEASE
    H245_IND_OPEN_T          IndOpen;           // H245_IND_OPEN
    H245_IND_OPEN_CONF_T     IndOpenConf;       // H245_IND_OPEN_CONF
    H245_IND_CLOSE_T         IndClose;          // H245_IND_CLOSE
    H245_CHANNEL_T           IndReqClose;       // H245_IND_REQ_CLOSE
                                                // H245_IND_CLCSE_RELEASE
    H245_IND_MUXTBL_T        IndMuxTbl;         // H245_IND_MUX_TBL
                                                // H245_IND_MTSE_RELEASE
    H245_RMESE_T             IndRmese;          // H245_IND_RMESE
                                                // H245_IND_RMESE_RELEASE
    H245_IND_MRSE_T          IndMrse;           // H245_IND_MRSE
                                                // H245_IND_MRSE_RELEASE
    H245_MLSE_T              IndMlse;           // H245_IND_MLSE
                                                // H245_IND_MLSE_RELEASE
    H245_IND_NONSTANDARD_T   IndNonstandardRequest; // H245_IND_NONSTANDARD_REQUEST
    H245_IND_NONSTANDARD_T   IndNonstandardResponse; // H245_IND_NONSTANDARD_RESPONSE
    H245_IND_NONSTANDARD_T   IndNonstandardCommand; // H245_IND_NONSTANDARD_COMMAND
    H245_IND_NONSTANDARD_T   IndNonstandard;    // H245_IND_NONSTANDARD
                                                // H245_IND_MISC_COMMAND
                                                // H245_IND_MISC
                                                // H245_IND_COMM_MODE_REQUEST
    H245_IND_COMM_MODE_T     IndCommRsp;        // H245_IND_COMM_MODE_RESPONSE
    H245_IND_COMM_MODE_T     IndCommCmd;        // H245_IND_COMM_MODE_COMMAND
    H245_CONFER_REQ_T        IndConferReq;      // H245_IND_CONFERENCE_REQUEST
    H245_CONFER_RSP_T        IndConferRsp;      // H245_IND_CONFERENCE_RESPONSE
    H245_CONFER_CMD_T        IndConferCmd;      // H245_IND_CONFERENCE_COMMAND
    H245_CONFER_IND_T        IndConfer;         // H245_IND_CONFERENCE
                                                // H245_IND_SEND_TERMCAP
                                                // H245_IND_ENCRYPTION
    H245_IND_FLOW_CONTROL_T  IndFlowControl;    // H245_IND_FLOW_CONTROL
    H245_IND_ENDSESSION_T    IndEndSession;     // H245_IND_ENDSESSION
                                                // H245_IND_FUNCTION_NOT_UNDERSTOOD
                                                // H245_IND_JITTER
    H245_IND_SKEW_T          IndH223Skew;       // H245_IND_H223_SKEW
                                                // H245_IND_NEW_ATM_VC
    H245_IND_USERINPUT_T     IndUserInput;      // H245_IND_USERINPUT
    H245_IND_SKEW_T          IndH2250MaxSkew;   // H245_IND_H2250_MAX_SKEW
    H245_TRANSPORT_ADDRESS_T IndMcLocation;     // H245_IND_MC_LOCATION
    H245_IND_VENDOR_ID_T     IndVendorId;       // H245_IND_VENDOR_ID
    H245_IND_FNS_T           IndFns;            // H245_IND_FUNCTION_NOT_SUPPORTED
                                                // H245_IND_H223_RECONFIG
                                                // H245_IND_H223_RECONFIG_ACK
                                                // H245_IND_H223_RECONFIG_REJECT
  } u;
} H245_IND_T;


/********************/
/********************/
/*  Confirm   Code  */
/********************/
/********************/

#define H245_CONF_INIT_MSTSLV    0x101
#define H245_CONF_SEND_TERMCAP   0x102
#define H245_CONF_OPEN           0x103
#define H245_CONF_NEEDRSP_OPEN   0x104
#define H245_CONF_CLOSE          0x105
#define H245_CONF_REQ_CLOSE      0x106
#define H245_CONF_MUXTBL_SND     0x107

#define H245_CONF_RMESE          0x109
#define H245_CONF_RMESE_REJECT   0x10A
#define H245_CONF_RMESE_EXPIRED  0x10B
#define H245_CONF_MRSE           0x10C
#define H245_CONF_MRSE_REJECT    0x10D
#define H245_CONF_MRSE_EXPIRED   0x10E
#define H245_CONF_MLSE           0x10F
#define H245_CONF_MLSE_REJECT    0x110
#define H245_CONF_MLSE_EXPIRED   0x111
#define H245_CONF_RTDSE          0x112
#define H245_CONF_RTDSE_EXPIRED  0x113

/* H245_CONF_SEND_TERMCAP_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;

} H245_CONF_SEND_TERMCAP_T;

/* H245_CONF_OPEN_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        TxChannel;
  H245_MUX_T *          pTxMux;         // optional
  H245_CHANNEL_T        RxChannel;      // bi-dir only
  H245_MUX_T *          pRxMux;         // bi-dir only
  H245_PORT_T           RxPort;         // bi-dir only
  H245_ACCESS_T *       pSeparateStack; // optional

} H245_CONF_OPEN_T;

typedef H245_CONF_OPEN_T H245_CONF_NEEDRSP_OPEN_T;

/* H245_CONF_CLOSE_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        Channel;

} H245_CONF_CLOSE_T;

/* H245_CONF_REQ_CLOSE_T */
typedef H245_CONF_CLOSE_T H245_CONF_REQ_CLOSE_T;

/* H245_CONF_MUXTBL_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_CONF_MUXTBL_T;



/***************/
/* H245_CONF_T */
/***************/

typedef struct
{
  unsigned long         Confirm;                // Type
  unsigned long         dwPreserved;            // User supplied dwPreserved from H245Init()
  unsigned long         dwTransId;              // User supplied dwTransId from originating call
  HRESULT               Error;                  // Error code
  union                                         // Data for specific indications:
  {
    H245_MSTSLV_T             ConfMstSlv;       // H245_CONF_INIT_MSTSLV
    H245_CONF_SEND_TERMCAP_T  ConfSndTcap;      // H245_CONF_SEND_TERMCAP
    H245_CONF_OPEN_T          ConfOpen;         // H245_CONF_OPEN
    H245_CONF_NEEDRSP_OPEN_T  ConfOpenNeedRsp;  // H245_CONF_NEEDRSP_OPEN
    H245_CONF_CLOSE_T         ConfClose;        // H245_CONF_CLOSE
    H245_CONF_REQ_CLOSE_T     ConfReqClose;     // H245_CONF_REQ_CLOSE
    H245_CONF_MUXTBL_T        ConfMuxSnd;       // H245_CONF_MUXTBL_SND
    H245_RMESE_T              ConfRmese;        // H245_CONF_RMESE
    H245_RMESE_T              ConfRmeseReject;  // H245_CONF_RMESE_REJECT
                                                // H245_CONF_RMESE_EXPIRED
    unsigned short            ConfMrse;         // H245_CONF_MRSE
    unsigned short            ConfMrseReject;   // H245_CONF_MRSE_REJECT
                                                // H245_CONF_MRSE_EXPIRED
    H245_MLSE_T               ConfMlse;         // H245_CONF_MLSE
    H245_MLSE_T               ConfMlseReject;   // H245_CONF_MLSE_REJECT
                                                // H245_CONF_MLSE_EXPIRED
                                                // H245_CONF_RTDSE
                                                // H245_CONF_RTDSE_EXPIRED
  } u;
} H245_CONF_T;



typedef enum
{
  H245_MESSAGE_REQUEST     = MltmdSystmCntrlMssg_rqst_chosen,
  H245_MESSAGE_RESPONSE    = MSCMg_rspns_chosen,
  H245_MESSAGE_COMMAND     = MSCMg_cmmnd_chosen,
  H245_MESSAGE_INDICATION  = indication_chosen
} H245_MESSAGE_TYPE_T;



/*******************/
/* H245_CONF_IND_T */
/*******************/
typedef enum
{
  H245_CONF = 1,
  H245_IND
} H245_CONF_IND_KIND_T;

typedef struct
{
  H245_CONF_IND_KIND_T  Kind;
  union
  {
    H245_CONF_T         Confirm;
    H245_IND_T          Indication;
  } u;

} H245_CONF_IND_T;



/***************************/
/* SYSTEM CONTROL MESSAGES */
/***************************/

typedef struct
{
  unsigned long NumPduTx;       /* number of tranmitted pdu's    */
  unsigned long NumPduRx;       /* number of received pdu's      */
  unsigned long NumCRCErrors;   /* number of crc errors          */
  unsigned long NumPduReTx;     /* number of pdu's retransmitted */

} H245_SYSCON_STATS_T;

#define H245_SYSCON_TRACE_LVL           0x0100  /* pData = &dwTraceLevel   */
#define H245_SYSCON_DUMP_TRACKER        0x0200  /* pData = NULL (debug)    */
#define H245_SYSCON_GET_STATS           0x0300  /* pData = &H245_SYSCON_STATS_T */
#define H245_SYSCON_RESET_STATS         0x0400  /* pData = NULL            */

#define H245_SYSCON_SET_FSM_N100        0x1000  /* pData = &dwRetryCount   */
#define H245_SYSCON_SET_FSM_T101        0x1100  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T102        0x1200  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T103        0x1300  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T104        0x1400  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T105        0x1500  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T106        0x1600  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T107        0x1700  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T108        0x1800  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T109        0x1900  /* pData = &dwMilliseconds */

#define H245_SYSCON_GET_FSM_N100        0x2000  /* pData = &dwRetryCount   */
#define H245_SYSCON_GET_FSM_T101        0x2100  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T102        0x2200  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T103        0x2300  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T104        0x2400  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T105        0x2500  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T106        0x2600  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T107        0x2700  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T108        0x2800  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T109        0x2900  /* pData = &dwMilliseconds */



/************************/
/* PROTOCOL ID FOR H245 */
/************************/

#define H245_PROTOID                    "0.0.8.245.0.2"



/**************************************************/
/* API Procedure Call Typedefs and API Prototypes */
/**************************************************/

typedef unsigned long H245_INST_T;
typedef HRESULT (*H245_CONF_IND_CALLBACK_T)(H245_CONF_IND_T *, void *);
typedef int (*H245_CAP_CALLBACK_T)(unsigned long, H245_TOTCAP_T *);
typedef int (*H245_CAPDESC_CALLBACK_T)(unsigned long, H245_TOTCAPDESC_T *);

#ifdef __cplusplus
extern "C" {
#endif

H245DLL H245_INST_T
H245Init                (
                         H245_CONFIG_T            Configuration,
                         unsigned long            dwPhysId,
                         unsigned long            *pdwLinkLayerPhysId,
                         unsigned long            dwPreserved,
                         H245_CONF_IND_CALLBACK_T CallBack,
                         unsigned char            byTerminalType
                        );

H245DLL H245_INST_T
H245GetInstanceId       (unsigned long          dwPhysicalId);

H245DLL HRESULT
H245EndSession          (
                         H245_INST_T                    dwInst,
                         H245_ENDSESSION_T              Mode,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245ShutDown            (H245_INST_T            dwInst);

H245DLL HRESULT
H245InitMasterSlave     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245SetLocalCap         (
                         H245_INST_T            dwInst,
                         H245_TOTCAP_T *        pTotCap,
                         H245_CAPID_T  *        pCapId
                        );

H245DLL HRESULT
H245DelLocalCap         (
                         H245_INST_T            dwInst,
                         H245_CAPID_T           CapId
                        );

H245DLL HRESULT
H245SetCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESC_T        *pCapDesc,
                         H245_CAPDESCID_T      *pCapDescId
                        );

H245DLL HRESULT
H245DelCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESCID_T       CapDescId
                        );

H245DLL HRESULT
H245SendTermCaps        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245EnumCaps            (
                         H245_INST_T              dwInst,
                         unsigned long            dwTransId,
                         H245_CAPDIR_T            Direction,
                         H245_DATA_T              DataType,
                         H245_CLIENT_T            ClientType,
                         H245_CAP_CALLBACK_T      pfCapCallback,
                         H245_CAPDESC_CALLBACK_T  pfCapDescCallback
                        );

H245DLL HRESULT
H245GetCaps             (
                         H245_INST_T            dwInst,
                         H245_CAPDIR_T          Direction,
                         H245_DATA_T            DataType,
                         H245_CLIENT_T          ClientType,
                         H245_TOTCAP_T      * * ppTotCap,
                         unsigned long *        pdwTotCapLen,
                         H245_TOTCAPDESC_T  * * ppCapDesc,
                         unsigned long *        pdwCapDescLen
                        );

H245DLL HRESULT
H245CopyCap             (H245_TOTCAP_T		   **ppDestTotCap,
						 const H245_TOTCAP_T   *pTotCap);

H245DLL HRESULT
H245FreeCap             (H245_TOTCAP_T          *pTotCap);

H245DLL HRESULT
H245CopyCapDescriptor   (H245_TOTCAPDESC_T		 **ppDestCapDesc,
						 const H245_TOTCAPDESC_T *pCapDesc);

H245DLL HRESULT
H245FreeCapDescriptor   (H245_TOTCAPDESC_T     *pCapDesc);

H245DLL H245_MUX_T *
H245CopyMux             (const H245_MUX_T *     pMux);

H245DLL HRESULT
H245FreeMux             (H245_MUX_T *           pMux);

H245DLL HRESULT
H245OpenChannel         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel,
                         const H245_TOTCAP_T *  pTxMode,
                         const H245_MUX_T    *  pTxMux,
                         H245_PORT_T            dwTxPort,       // optional
                         const H245_TOTCAP_T *  pRxMode,        // bi-dir only
                         const H245_MUX_T    *  pRxMux,         // bi-dir only
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelAccept   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel,     // RxChannel from IND_OPEN
                         const H245_MUX_T *     pRxMux,         // optional H2250LogicalChannelAckParameters
                         H245_CHANNEL_T         wTxChannel,     // bi-dir only
                         const H245_MUX_T *     pTxMux,         // bi-dir only optional H2250LogicalChannelParameters
                         H245_PORT_T            dwTxPort,       // bi-dir only optional
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelReject   (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wRxChannel, // RxChannel from IND_OPEN
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245CloseChannel        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel
                        );

H245DLL HRESULT
H245CloseChannelReq     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel
                        );

H245DLL HRESULT
H245CloseChannelReqResp (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_T         AccRej,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245SendLocalMuxTable   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_MUX_TABLE_T      *pMuxTable
                        );

H245DLL HRESULT
H245MuxTableIndResp     (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_MUX_T     AccRejMux,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntry (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryAck (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryReject (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

/*
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         const ModeElement *    pModeElements,
                         unsigned long          dwCount
                        );
*/
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
//                         const ModeElement *    pModeElements,
//tomitowoju@intel.com
						 ModeDescription 		ModeDescriptions[],
//tomitowoju@intel.com
                         unsigned long          dwCount
                        ) ;



H245DLL HRESULT
H245RequestModeAck      (
                         H245_INST_T            dwInst,
                         unsigned short         wResponse
                        );

H245DLL HRESULT
H245RequestModeReject   (
                         H245_INST_T            dwInst,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245RoundTripDelayRequest (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245MaintenanceLoop     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_LOOP_TYPE_T       dwLoopType,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopRelease (H245_INST_T         dwInst);

H245DLL HRESULT
H245MaintenanceLoopAccept (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopReject (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245NonStandardObject   (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         const unsigned short * pwObjectId,
                         unsigned long          dwObjectIdLength
                        );

H245DLL HRESULT
H245NonStandardH221     (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         unsigned char          byCountryCode,
                         unsigned char          byExtension,
                         unsigned short         wManufacturerCode
                        );

H245DLL HRESULT
H245CommunicationModeRequest(H245_INST_T            dwInst);

H245DLL HRESULT
H245CommunicationModeResponse(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245CommunicationModeCommand(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245ConferenceRequest   (
                         H245_INST_T            dwInst,
                         H245_CONFER_REQ_ENUM_T RequestType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceResponse  (
                         H245_INST_T            dwInst,
                         H245_CONFER_RSP_ENUM_T ResponseType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber,
                         const unsigned char   *pOctetString,
                         unsigned char          byOctetStringLength,
                         const TerminalLabel   *pTerminalList,
                         unsigned short         wTerminalListCount
                        );

H245DLL HRESULT
H245ConferenceCommand   (
                         H245_INST_T            dwInst,
                         H245_CONFER_CMD_ENUM_T CommandType,
                         H245_CHANNEL_T         Channel,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceIndication(
                         H245_INST_T            dwInst,
                         H245_CONFER_IND_ENUM_T IndicationType,
                         unsigned char          bySbeNumber,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245UserInput           (
                         H245_INST_T                    dwInst,
                         const WCHAR *                  pGenString,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245FlowControl         (
                         H245_INST_T            dwInst,
                         H245_SCOPE_T           Scope,
                         H245_CHANNEL_T         Channel,       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
                         unsigned short         wResourceID,   // only used if Scope is H245_SCOPE_RESOURCE_ID
                         unsigned long          dwRestriction  // H245_NO_RESTRICTION if no restriction
                        );

H245DLL HRESULT
H245H223SkewIndication  (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wSkew
                        );

H245DLL HRESULT
H245H2250MaximumSkewIndication(
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wMaximumSkew
                        );

H245DLL HRESULT
H245MCLocationIndication(
                         H245_INST_T                dwInst,
                         const H245_TRANSPORT_ADDRESS_T * pSignalAddress
                        );

H245DLL HRESULT
H245VendorIdentification(
                         H245_INST_T            dwInst,
                         const H245_NONSTANDID_T *pIdentifier,
                         const unsigned char   *pProductNumber,       // optional
                         unsigned char          byProductNumberLength,// optional
                         const unsigned char   *pVersionNumber,       // optional
                         unsigned char          byVersionNumberLength // optional
                        );

H245DLL HRESULT
H245SendPDU             (
                         H245_INST_T            dwInst,
                         PDU_T *                pPdu
                        );

H245DLL HRESULT
H245SystemControl       (
                         H245_INST_T            dwInst,
                         unsigned long          dwRequest,
                         void   *               pData
                        );

#ifdef __cplusplus
        }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\h323pdu.h ===
/*++

Copyright (c) 1992-1998  Microsoft Corporation

Module Name:

    H323pdu.h

Abstract:

    Describes interface between H323TSP and H323MSP.

Environment:

    User Mode - Win32

--*/

#ifndef __H323_PDU_H_
#define __H323_PDU_H_

typedef enum {

    //
    // H323TSP_NEW_CALL_INDICATION - sent only from the TSP
    //  to the MSP in order to initiate communication once
    //  a call has been created.
    //

    H323TSP_NEW_CALL_INDICATION,

    //
    // H323TSP_CLOSE_CALL_COMMAND - sent only from the TSP
    //  to the MSP in order to stop all the streaming for a call.
    //

    H323TSP_CLOSE_CALL_COMMAND,

    //
    // H323TSP_OPEN_CHANNEL_RESPONSE - sent only from the TSP
    // to the MSP in response to H323MSP_OPEN_CHANNEL_REQUEST.
    //

    H323TSP_OPEN_CHANNEL_RESPONSE,

    //
    // H323TSP_ACCEPT_CHANNEL_REQUEST - sent only from the TSP
    // to the MSP in order to request the acceptance of an
    // incoming logical channel.
    //

    H323TSP_ACCEPT_CHANNEL_REQUEST,

    //
    // H323TSP_CLOSE_CHANNEL_COMMAND - sent only from the TSP
    // to the MSP in order to demand the immediate closure of
    // an incoming or outgoing logical channel.
    //

    H323TSP_CLOSE_CHANNEL_COMMAND,

	//
	// H323TSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND - sent only from the TSP 
	// to the MSP in order to request an I-frame transmittal
	//

	H323TSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND,

	//
	// H323TSP_FLOW_CONTROL_COMMAND - sent only from the TSP 
	// to the MSP in order to request media stream bit rate 
	// change 

	H323TSP_FLOW_CONTROL_COMMAND

} H323TSP_MESSAGE_TYPE;

typedef enum {

    //
    // H323MSP_OPEN_CHANNEL_REQUEST - sent only from the MSP
    // to the TSP in order to request the negotiation on an
    // outgoing logical channel.
    //

    H323MSP_OPEN_CHANNEL_REQUEST,

    //
    // H323MSP_ACCEPT_CHANNEL_RESPONSE - sent only from the MSP
    // to the TSP in reponse to H323TSP_ACCEPT_CHANNEL_REQUEST.
    //

    H323MSP_ACCEPT_CHANNEL_RESPONSE,

    //
    // H323MSP_CLOSE_CHANNEL_COMMAND - sent only from the MSP
    // to the TSP in order to demand the immediate closure of
    // an incoming or outgoing logical channel.
    //

    H323MSP_CLOSE_CHANNEL_COMMAND,

    //
    // H323MSP_QOS_EVENT - sent only from the MSP to the TSP for 
    // QOS events. In the future, we might move the event to MSP space.
    //

    H323MSP_QOS_Evnet, 

	// 
	// H323MSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND - sent only from the
	// MSP to the TSP in order to request an I-frame transmittal from
	// the remote entity
	//

	H323MSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND,

	// 
	// H323MSP_FLOW_CONTROL_COMMAND - sent only from the MSP to the TSP
	// in order to ask the remote entity to change media stream bit rate
	//

	H323MSP_FLOW_CONTROL_COMMAND,

	// 
	// H323MSP_CONFIG_T120_COMMAND - sent only from the MSP to the TSP
	// in order to set an external T120 address to the TSP.
	//

	H323MSP_CONFIG_T120_COMMAND,

	// 
	// H323MSP_CONFIG_CAPABILITY_COMMAND - sent only from the MSP to the TSP
	// in order to configure the capability array of the TSP.
	//

	H323MSP_CONFIG_CAPABILITY_COMMAND,

    //
    // H323MSP_SET_ALIAS_COMMAND - sent only from the MSP to the TSP
    // to setup an alias name for the address
    //

    H323MSP_SET_ALIAS_COMMAND

} H323MSP_MESSAGE_TYPE;

typedef enum {

    MEDIA_AUDIO,
    MEDIA_VIDEO

} MEDIATYPE;

#ifndef H245_CAPABILITY_DEFINED
typedef enum H245_CAPABILITY
{
    HC_G711,
    HC_G723,
    HC_H263QCIF,
    HC_H261QCIF

} H245_CAPABILITY;
#endif

#define MAX_CAPS (HC_H261QCIF - HC_G711 + 1)

typedef struct _VIDEOSETTINGS
{
    BOOL  bCIF;
    DWORD dwMaxBitRate;      // the encoder should never exceed this value.
    DWORD dwStartUpBitRate;  // the encoder uses this value to start

} VIDEOSETTINGS, *PVIDEOSETTINGS;

typedef struct _G723SETTINGS
{
	BOOL  bG723LowSpeed;
} G723SETTINGS, *PG723SETTINGS;

typedef struct  _G729SETTINGS
{
	BOOL bDummy;	// I.K. 03-23-1999.
					// A dummy field for now.
} G729SETTINGS, *PG729SETTINGS;

typedef struct _AUDIOSETTINGS
{
    DWORD dwMillisecondsPerPacket;
	
    union {
        G723SETTINGS G723Settings;
        G729SETTINGS G729Settings;
    };

} AUDIOSETTINGS, *PAUDIOSETTINGS;

typedef struct _STREAMSETTINGS
{
    MEDIATYPE MediaType;

    DWORD     dwPayloadType;    // RTP payload type
    DWORD     dwDynamicType;    // RTP dynamic payload type

    DWORD     dwIPLocal;        // local IP address in host byte order.
    WORD      wRTPPortLocal;    // local port number in host byte order.
    WORD      wRTCPPortLocal;

    DWORD     dwIPRemote;       // remote IP address in host byte order.
    WORD      wRTPPortRemote;   // remote port number in host byte order.
    WORD      wRTCPPortRemote;

    union {
        VIDEOSETTINGS Video;
        AUDIOSETTINGS Audio;
    };

} STREAMSETTINGS, *PSTREAMSETTINGS;

typedef struct _H323MSG_OPEN_CHANNEL_REQUEST {

    HANDLE          hmChannel;  // msp channel handle
    STREAMSETTINGS  Settings;   // local address and requested settings

} H323MSG_OPEN_CHANNEL_REQUEST, *PH323MSG_OPEN_CHANNEL_REQUEST;

typedef struct _H323MSG_OPEN_CHANNEL_RESPONSE {

    HANDLE          hmChannel;  // handle from OPEN_CHANNEL_REQUEST
    HANDLE          htChannel;  // tsp channel channel
    STREAMSETTINGS  Settings;   // remote address and agreed upon settings

} H323MSG_OPEN_CHANNEL_RESPONSE, *PH323MSG_OPEN_CHANNEL_RESPONSE;

typedef struct _H323MSG_ACCEPT_CHANNEL_REQUEST {

    HANDLE          htChannel;  // tsp channel handle
    STREAMSETTINGS  Settings;   // remote address and requested settings

} H323MSG_ACCEPT_CHANNEL_REQUEST, *PH323MSG_ACCEPT_CHANNEL_REQUEST;

typedef struct _H323MSG_ACCEPT_CHANNEL_RESPONSE {

    HANDLE          htChannel;  // handle from ACCEPT_CHANNEL_REQUEST
    HANDLE          hmChannel;  // msp channel handle
    STREAMSETTINGS  Settings;   // local address and agreed upon settings

} H323MSG_ACCEPT_CHANNEL_RESPONSE, *PH323MSG_ACCEPT_CHANNEL_RESPONSE;

typedef struct _H323MSG_CLOSE_CHANNEL_COMMAND {

    DWORD           dwReason;   // normal case is zero
    HANDLE          hChannel;    // channel handle

} H323MSG_CLOSE_CHANNEL_COMMAND, *PH323MSG_CLOSE_CHANNEL_COMMAND;

typedef struct _H323MSG_FLOW_CONTROL_COMMAND {

    DWORD           dwBitRate;  // requested bit rate (units of bps)
    HANDLE          hChannel;   // MSP or TSP channel handle

} H323MSG_FLOW_CONTROL_COMMAND, *PH323MSG_FLOW_CONTROL_COMMAND;

typedef struct _H323MSG_CONFIG_T120_COMMAND {

    BOOL            fEnable;    // Enable or disable T120. 
    DWORD           dwIP;       // The IP address of the external T120 service.
    WORD            wPort;      // The port number of the external T120 service.

} H323MSG_CONFIG_T120_COMMAND, *PH323MSG_CONFIG_T120_COMMAND;

typedef struct _H323MSG_CONFIG_CAPABILITY_COMMAND {

    DWORD           dwNumCaps;
    DWORD           pCapabilities[MAX_CAPS];  // The list of capabilities.
    DWORD           pdwWeights[MAX_CAPS];       // MSP or TSP channel handle

} H323MSG_CONFIG_CAPABILITY_COMMAND, *PH323MSG_CONFIG_CAPABILITY_COMMAND;

#define MAX_ALIAS_LENGTH 64

typedef struct _H323MSG_SET_ALIAS_COMMAND {

    WCHAR           strAlias[MAX_ALIAS_LENGTH]; // alias name
    DWORD           dwLength; // length of the alias

} H323MSG_SET_ALIAS_COMMAND, *PH323MSG_SET_ALIAS_COMMAND;

typedef struct _H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND {

    HANDLE          hChannel;   // MSP or TSP channel handle

} H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND,
 *PH323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND;

typedef struct _H323MSG_QOS_EVENT {

    DWORD           dwEvent;      // the QOS event as defined in TSPI.h
    HANDLE          htChannel;    // channel handle

} H323MSG_QOS_EVENT, *PH323MSG_QOS_EVENT;

typedef struct _H323TSP_MESSAGE {

    H323TSP_MESSAGE_TYPE Type;

    union {
        H323MSG_OPEN_CHANNEL_RESPONSE             OpenChannelResponse;
        H323MSG_ACCEPT_CHANNEL_REQUEST            AcceptChannelRequest;
        H323MSG_CLOSE_CHANNEL_COMMAND             CloseChannelCommand;
		H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND VideoFastUpdatePictureCommand;
		H323MSG_FLOW_CONTROL_COMMAND              FlowControlCommand;
    };

} H323TSP_MESSAGE, *PH323TSP_MESSAGE;

typedef struct _H323MSP_MESSAGE {

    H323MSP_MESSAGE_TYPE Type;

    union {
        H323MSG_OPEN_CHANNEL_REQUEST              OpenChannelRequest;
        H323MSG_ACCEPT_CHANNEL_RESPONSE           AcceptChannelResponse;
        H323MSG_CLOSE_CHANNEL_COMMAND             CloseChannelCommand;
        H323MSG_QOS_EVENT                         QOSEvent;
		H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND VideoFastUpdatePictureCommand;
		H323MSG_FLOW_CONTROL_COMMAND              FlowControlCommand;
        H323MSG_CONFIG_T120_COMMAND               ConfigT120Command;
        H323MSG_CONFIG_CAPABILITY_COMMAND         ConfigCapabilityCommand;
        H323MSG_SET_ALIAS_COMMAND                 SetAliasCommand;
    };

} H323MSP_MESSAGE, *PH323MSP_MESSAGE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\incommon.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/incommon.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1996 Intel Corporation.
 *
 *      $Revision:   1.41  $
 *      $Date:   12 Feb 1997 09:34:42  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:    INCOMMON.H
 *
 *      Abstract:        commonly used structures
 *              
 *
 *      Notes:
 *
 ***************************************************************************/
#ifndef INCOMMON_H
#define INCOMMON_H

#pragma pack(push,8)

#define CC_INVALID_HANDLE                    0

// CCRC_CALL_REJECTED reason codes (includes cause values)
#define CC_REJECT_NO_BANDWIDTH              1
#define CC_REJECT_GATEKEEPER_RESOURCES      2
#define CC_REJECT_UNREACHABLE_DESTINATION   3
#define CC_REJECT_DESTINATION_REJECTION     4
#define CC_REJECT_INVALID_REVISION          5
#define CC_REJECT_NO_PERMISSION             6
#define CC_REJECT_UNREACHABLE_GATEKEEPER    7
#define CC_REJECT_GATEWAY_RESOURCES         8
#define CC_REJECT_BAD_FORMAT_ADDRESS        9
#define CC_REJECT_ADAPTIVE_BUSY             10
#define CC_REJECT_IN_CONF                   11
#define CC_REJECT_ROUTE_TO_GATEKEEPER       12
#define CC_REJECT_CALL_FORWARDED            13
#define CC_REJECT_ROUTE_TO_MC               14
#define CC_REJECT_UNDEFINED_REASON          15
#define CC_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
#define CC_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
#define CC_REJECT_USER_BUSY                 18    // User is busy with another call
#define CC_REJECT_NO_ANSWER                 19    // Callee does not answer
#define CC_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
#define CC_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
#define CC_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
#define CC_REJECT_TIMER_EXPIRED             23    // Own timer expired
#define CC_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
#define CC_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call

// Q931 call types
#define CC_CALLTYPE_UNKNOWN                 0
#define CC_CALLTYPE_PT_PT                   1
#define CC_CALLTYPE_1_N                     2
#define CC_CALLTYPE_N_1                     3
#define CC_CALLTYPE_N_N                     4

// alias contants
#define CC_ALIAS_MAX_H323_ID                256
#define CC_ALIAS_MAX_H323_PHONE             128

// unicode character mask contants
#define CC_ALIAS_H323_PHONE_CHARS           L"0123456789#*,"
#define CC_ODOTTO_CHARS                     L".0123456789"


// alias type codes
#define CC_ALIAS_H323_ID                    1    // Return call information.
#define CC_ALIAS_H323_PHONE                 2    // H323 Phone Number.

// default port id's
#define CC_H323_GATE_DISC    1718 // Gatekeeper IP Discovery Port
#define CC_H323_GATE_STAT    1719 // Gatekeeper UDP Reg. and Status Port
#define CC_H323_HOST_CALL    1720 // Endpoint TCP Call Signalling Por

// Call creation goals
#define CC_GOAL_UNKNOWN                     0
#define CC_GOAL_CREATE                      1
#define CC_GOAL_JOIN                        2
#define CC_GOAL_INVITE                      3
    
// H245 non-standard message types
#define CC_H245_MESSAGE_REQUEST             0
#define CC_H245_MESSAGE_RESPONSE            1
#define CC_H245_MESSAGE_COMMAND             2
#define CC_H245_MESSAGE_INDICATION          3

// Call Control handle typedefs
typedef DWORD        CC_HLISTEN, *PCC_HLISTEN;
typedef DWORD        CC_HCONFERENCE, *PCC_HCONFERENCE;
typedef DWORD        CC_HCALL, *PCC_HCALL;
typedef DWORD        CC_HCHANNEL, *PCC_HCHANNEL;

// IP address in domain name format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[255];     // UNICODE zstring
} CC_IP_DomainName_t;

// IP address in conventional dot notation
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[16];      // UNICODE zstring
} CC_IP_Dot_t;

// IP address in binary format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    DWORD        dwAddr;         // binary address (host byte order)
} CC_IP_Binary_t;

typedef enum
{
    CC_IP_DOMAIN_NAME,
    CC_IP_DOT,
    CC_IP_BINARY
} CC_ADDRTYPE;

typedef struct _ADDR
{
    CC_ADDRTYPE nAddrType;
    BOOL        bMulticast;
    union 
    {
        CC_IP_DomainName_t   IP_DomainName;
        CC_IP_Dot_t          IP_Dot;
        CC_IP_Binary_t       IP_Binary;
    } Addr;
} CC_ADDR, *PCC_ADDR;

typedef struct
{
    BYTE *pOctetString;
    WORD wOctetStringLength;
} CC_OCTETSTRING, *PCC_OCTETSTRING;

typedef struct
{
    CC_OCTETSTRING          sData;            // pointer to Octet data.
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
} CC_NONSTANDARDDATA, *PCC_NONSTANDARDDATA;

#define CC_MAX_PRODUCT_LENGTH 256
#define CC_MAX_VERSION_LENGTH 256
#define CC_MAX_DISPLAY_LENGTH 82

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    PCC_OCTETSTRING         pProductNumber;
    PCC_OCTETSTRING         pVersionNumber;
} CC_VENDORINFO, *PCC_VENDORINFO;

typedef struct
{
    PCC_VENDORINFO          pVendorInfo;
    BOOL                    bIsTerminal;
    BOOL                    bIsGateway;    // for now, the H323 capability will be hard-coded.
} CC_ENDPOINTTYPE, *PCC_ENDPOINTTYPE;

typedef struct
{
    WORD                    wType;
    WORD                    wPrefixLength;
    LPWSTR                  pPrefix;
    WORD                    wDataLength;   // UNICODE character count
    LPWSTR                  pData;         // UNICODE data.
} CC_ALIASITEM, *PCC_ALIASITEM;

typedef struct
{
    WORD                    wCount;
    PCC_ALIASITEM           pItems;
} CC_ALIASNAMES, *PCC_ALIASNAMES;

typedef struct _CONFERENCE_ID
{
    BYTE                    buffer[16];  // This is OCTET data, not ASCII.
} CC_CONFERENCEID, *PCC_CONFERENCEID;

#pragma pack(pop)

#endif    INCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\multitrackterminal.h ===
// MultiTrackTerminal.h: interface for the CMultiTrackTerminal class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(_MULTITRACKTERMINAL_DOT_H_INCLUDED_)
#define _MULTITRACKTERMINAL_DOT_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template <class T>
class  ITMultiTrackTerminalVtbl : public ITMultiTrackTerminal
{
};

class CMultiTrackTerminal;

typedef IDispatchImpl<ITMultiTrackTerminalVtbl<CMultiTrackTerminal>, &IID_ITMultiTrackTerminal, &LIBID_TAPI3Lib> CTMultiTrack;

class CMultiTrackTerminal :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CTMultiTrack
{

public:

BEGIN_COM_MAP(CMultiTrackTerminal)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITMultiTrackTerminal)
END_COM_MAP()


    //
    // the logic for creating a track terminal needs to be implemented by the
    // specific terminals, so this is a pure virtual method
    //

	virtual HRESULT STDMETHODCALLTYPE CreateTrackTerminal(
			    IN long MediaType,
			    IN TERMINAL_DIRECTION TerminalDirection,
			    OUT ITTerminal **ppTerminal
			    ) = 0;


public:

    virtual HRESULT STDMETHODCALLTYPE get_TrackTerminals(
			    OUT VARIANT *pVariant
			    );

	virtual HRESULT STDMETHODCALLTYPE EnumerateTrackTerminals(
			    IEnumTerminal **ppEnumTerminal
			    );

	virtual HRESULT STDMETHODCALLTYPE get_MediaTypesInUse(
			    OUT long *plMediaTypesInUse
			    );

	virtual HRESULT STDMETHODCALLTYPE get_DirectionsInUse(
			    OUT TERMINAL_DIRECTION *plDirectionsInUsed
			    );

    virtual HRESULT STDMETHODCALLTYPE RemoveTrackTerminal(
                IN ITTerminal *pTrackTerminalToRemove
                );


public:

    CMultiTrackTerminal();

	virtual ~CMultiTrackTerminal();


protected:

    HRESULT AddTrackTerminal(ITTerminal *pTrackTerminalToAdd);

    HRESULT ReleaseAllTracks();

    
    //
    // a helper method that returns true if the terminal is in the list of managed tracks
    //

    BOOL DoIManageThisTrack(ITTerminal *pTrackInQuestion)
    {
        CLock lock(m_lock);

        int nIndex = m_TrackTerminals.Find(pTrackInQuestion);

        return (nIndex >= 0);
    }


    //
    // returns the number of tracks managed by this terminal
    //

    int CountTracks();


public:

    //
    // the derived class, CComObject, implements these. Here declare as pure 
    // virtual so we can refer to these methods from ChildRelease and 
    // ChildAddRef()
    // 
    
    virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
    virtual ULONG STDMETHODCALLTYPE Release() = 0;


    //
    // called by a track terminals when they are addref'ed or released
    //
    
    virtual void ChildAddRef();
    virtual void ChildRelease();


protected:

    //
    // we have to adjust refcount with the information on the number of tracks that we are managing
    //

    ULONG InternalAddRef();
    ULONG InternalRelease();


protected:

    //
    // collection of track terminals
    //

    CMSPArray<ITTerminal*>  m_TrackTerminals;


protected:
    

    //
    // critical section. 
    //

    CMSPCritSection         m_lock;


private:
    

    //
    // this data member is used to keep the count of the tracks managed by this
    // terminal
    //

    int m_nNumberOfTracks;

};

#endif // !defined(_MULTITRACKTERMINAL_DOT_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\h245asn1.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef H245ASN1_H
#define H245ASN1_H

#include "h245.h"
#include "av_asn1.h"
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif


// LONCHANC: ORIGINAL MAPPING WITH NEW STRUCTURE NAMES

#define VCCapabilityLink                PH222Capability_vcCapability
#define SmltnsCpbltsLink                PCapabilityDescriptor_simultaneousCapabilities
#define CapabilityTableLink             PTerminalCapabilitySet_capabilityTable
#define MultiplexEntryDescriptorLink    PMultiplexEntrySend_multiplexEntryDescriptors
#define CommunicationModeTableLink      PCommunicationModeResponse_communicationModeTable
#define TerminalListResponseLink        PConferenceResponse_terminalListResponse
#define CpbltyTblEntryNmbrsLink         PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers
#define CommunicationModeCommandLink    PCommunicationModeCommand_communicationModeTable
#define CentralizedDataLink             PMediaDistributionCapability_centralizedData
#define DistributedDataLink             PMediaDistributionCapability_distributedData
#define MediaDistributionCapabilityLink PMultipointCapability_mediaDistributionCapability
#define NonStandardDataLink             PConferenceCapability_nonStandardData
#define RouteLink                       PUnicastAddress_iPSourceRouteAddress_route
#define H2250LCPs_nnStndrdLink          PH2250LogicalChannelParameters_nonStandard
#define MultiplexElementLink            PMultiplexElement_type_subElementList
#define RequestedModesLink              PRequestMode_requestedModes
#define H2250LCAPs_nnStndrdLink         PH2250LogicalChannelAckParameters_nonStandard
#define CMTEy_nnStndrdLink              PCommunicationModeTableEntry_nonStandard
#define OBJECTID                        struct ObjectID_
#define POBJECTID                       struct ObjectID_ *
typedef DataApplicationCapability_application_t84       H245_CAP_T84_T;
typedef DataApplicationCapability_application_nlpid     H245_CAP_NLPID_T;
typedef AudioCapability_g7231                           H245_CAP_G723_T;


// LONCHANC: NEW MAPPING FOR FIELDS AND DEFINITIONS

// _choice2 vs H223Capability_h223MultiplexTableCapability
#define h223MltplxTblCpblty_bsc_chosen  H223Capability_h223MultiplexTableCapability_basic_chosen
#define h223MTCy_enhncd_chosen          H223Capability_h223MultiplexTableCapability_enhanced_chosen
#define h223MTCy_enhncd                 enhanced

// V76Capability
#define sspndRsmCpbltywAddrss           suspendResumeCapabilitywoAddress

// DataProtocolCapability
#define DtPrtclCpblty_nnStndrd_chosen   DataProtocolCapability_nonStandard_chosen
#define sgmnttnAndRssmbly_chosen        segmentationAndReassembly_chosen          
#define DtPrtclCpblty_nnStndrd          nonStandard

// _choice3 vs DataApplicationCapability_application
#define DACy_applctn_nnStndrd_chosen    DataApplicationCapability_application_nonStandard_chosen
#define DACy_applctn_t120_chosen        DataApplicationCapability_application_t120_chosen
#define DACy_applctn_dsm_cc_chosen      DataApplicationCapability_application_dsm_cc_chosen
#define DACy_applctn_usrDt_chosen       DataApplicationCapability_application_userData_chosen
#define DACy_applctn_t84_chosen         DataApplicationCapability_application_t84_chosen
#define DACy_applctn_t434_chosen        DataApplicationCapability_application_t434_chosen
#define DACy_applctn_h224_chosen        DataApplicationCapability_application_h224_chosen
#define DACy_applctn_nlpd_chosen        DataApplicationCapability_application_nlpid_chosen
#define DACy_applctn_dsvdCntrl_chosen   DataApplicationCapability_application_dsvdControl_chosen
#define DACy_an_h222DtPrttnng_chosen    DataApplicationCapability_application_h222DataPartitioning_chosen
#define DACy_applctn_nnStndrd           nonStandard
#define DACy_applctn_t120               t120
#define DACy_applctn_dsm_cc             dsm_cc
#define DACy_applctn_usrDt              userData
#define DACy_applctn_t84                t84
#define DACy_applctn_t434               t434
#define DACy_applctn_h224               h224
#define DACy_applctn_nlpd               nlpid
#define DACy_an_h222DtPrttnng           h222DataPartitioning

// H2250Capability
#define rcvAndTrnsmtMltpntCpblty        receiveAndTransmitMultipointCapability

// _choice4 vs H223AnnexACapability_h223AnnexAMultiplexTableCapability
#define h223AAMTCy_bsc_chosen           H223AnnexACapability_h223AnnexAMultiplexTableCapability_basic_chosen
#define h223AAMTCy_enhncd_chosen        H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced_chosen
#define h223AAMTCy_enhncd               enhanced

// MultiplexCapability
#define MltplxCpblty_nonStandard_chosen MultiplexCapability_nonStandard_chosen
#define MltplxCpblty_nonStandard        nonStandard

// H261VideoCapability
#define H261VdCpblty_qcifMPI_present    H261VideoCapability_qcifMPI_present
#define H261VdCpblty_cifMPI_present     H261VideoCapability_cifMPI_present
#define H261VdCpblty_qcifMPI            qcifMPI
#define H261VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability

// H262VideoCapability
#define H262VdCpblty_vdBtRt_present     H262VideoCapability_videoBitRate_present
#define H262VdCpblty_vbvBffrSz_present  H262VideoCapability_vbvBufferSize_present
#define H262VdCpblty_smplsPrLn_present  H262VideoCapability_samplesPerLine_present
#define H262VdCpblty_lnsPrFrm_present   H262VideoCapability_linesPerFrame_present
#define H262VdCpblty_frmsPrScnd_present H262VideoCapability_framesPerSecond_present
#define H262VCy_lmnncSmplRt_present     H262VideoCapability_luminanceSampleRate_present
#define H262VdCpblty_vdBtRt             videoBitRate
#define H262VdCpblty_vbvBffrSz          vbvBufferSize
#define H262VdCpblty_smplsPrLn          samplesPerLine
#define H262VdCpblty_lnsPrFrm           linesPerFrame
#define H262VdCpblty_frmsPrScnd         framesPerSecond
#define H262VCy_lmnncSmplRt             luminanceSampleRate

// H263VideoCapability
#define H263VdCpblty_qcifMPI_present    H263VideoCapability_qcifMPI_present
#define H263VdCpblty_cifMPI_present     H263VideoCapability_cifMPI_present
#define H263VCy_errrCmpnstn_present     H263VideoCapability_errorCompensation_present
#define H263VdCpblty_qcifMPI            qcifMPI
#define H263VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability
#define H263VCy_errrCmpnstn             errorCompensation

// IS11172VideoCapability
#define IS11172VdCpblty_vdBtRt_present  IS11172VideoCapability_videoBitRate_present
#define IS11172VCy_vbvBffrSz_present    IS11172VideoCapability_vbvBufferSize_present
#define IS11172VCy_smplsPrLn_present    IS11172VideoCapability_samplesPerLine_present
#define IS11172VCy_lnsPrFrm_present     IS11172VideoCapability_linesPerFrame_present
#define IS11172VdCpblty_pctrRt_present  IS11172VideoCapability_pictureRate_present
#define IS11172VCy_lmnncSmplRt_present  IS11172VideoCapability_luminanceSampleRate_present
#define IS11172VdCpblty_vdBtRt          videoBitRate
#define IS11172VCy_vbvBffrSz            vbvBufferSize
#define IS11172VCy_smplsPrLn            samplesPerLine
#define IS11172VCy_lnsPrFrm             linesPerFrame
#define IS11172VdCpblty_pctrRt          pictureRate
#define IS11172VCy_lmnncSmplRt          luminanceSampleRate

// VideoCapability
#define VdCpblty_nonStandard_chosen     VideoCapability_nonStandard_chosen
#define VdCpblty_nonStandard            nonStandard

// AudioCapability
#define AdCpblty_nonStandard_chosen     AudioCapability_nonStandard_chosen
#define AdCpblty_g711Alaw64k_chosen     AudioCapability_g711Alaw64k_chosen
#define AdCpblty_g711Alaw56k_chosen     AudioCapability_g711Alaw56k_chosen
#define AdCpblty_g711Ulaw64k_chosen     AudioCapability_g711Ulaw64k_chosen
#define AdCpblty_g711Ulaw56k_chosen     AudioCapability_g711Ulaw56k_chosen
// #define AudioCapability_g722_64k_chosen g722_64k_chosen
// #define AudioCapability_g722_56k_chosen g722_56k_chosen
// #define AudioCapability_g722_48k_chosen g722_48k_chosen
#define AdCpblty_g729AnnexA_chosen      AudioCapability_g729AnnexA_chosen
#define ACy_g729AASSn_chosen            AudioCapability_g729AnnexAwSilenceSuppression_chosen
#define AdCpblty_nonStandard            nonStandard
#define AdCpblty_g711Alaw64k            g711Alaw64k
#define AdCpblty_g711Alaw56k            g711Alaw56k
#define AdCpblty_g711Ulaw64k            g711Ulaw64k
#define AdCpblty_g711Ulaw56k            g711Ulaw56k
#define AudioCapability_g722_64k        g722_64k
#define AudioCapability_g722_56k        g722_56k
#define AudioCapability_g722_48k        g722_48k
#define AudioCapability_g7231           g7231
#define AudioCapability_g728            g728
#define AudioCapability_g729            g729
#define AdCpblty_g729AnnexA             g729AnnexA
#define ACy_g729AASSn                   g729AnnexAwSilenceSuppression

// Capability
#define rcvAndTrnsmtVdCpblty_chosen     receiveAndTransmitVideoCapability_chosen
#define rcvAndTrnsmtAdCpblty_chosen     receiveAndTransmitAudioCapability_chosen
#define rcvDtApplctnCpblty_chosen       receiveDataApplicationCapability_chosen
#define trnsmtDtApplctnCpblty_chosen    transmitDataApplicationCapability_chosen
#define rATDACy_chosen                  receiveAndTransmitDataApplicationCapability_chosen
#define h233EncryptnTrnsmtCpblty_chosen h233EncryptionTransmitCapability_chosen
#define h233EncryptnRcvCpblty_chosen    h233EncryptionReceiveCapability_chosen
#define Capability_nonStandard          nonStandard
#define rcvAndTrnsmtVdCpblty            receiveAndTransmitVideoCapability
#define rcvAndTrnsmtAdCpblty            receiveAndTransmitAudioCapability
#define rcvDtApplctnCpblty              receiveDataApplicationCapability
#define trnsmtDtApplctnCpblty           transmitDataApplicationCapability
#define rATDACy                         receiveAndTransmitDataApplicationCapability
#define h233EncryptnTrnsmtCpblty        h233EncryptionTransmitCapability
#define h233EncryptnRcvCpblty           h233EncryptionReceiveCapability

// CapabilityDescriptor
#define smltnsCpblts_present            simultaneousCapabilities_present
#define smltnsCpblts                    simultaneousCapabilities

// EncryptionMode
#define EncryptnMd_nonStandard_chosen   EncryptionMode_nonStandard_chosen
#define EncryptnMd_nonStandard          nonStandard

// DataType
#define DataType_nonStandard            nonStandard
#define DataType_videoData              videoData
#define DataType_audioData              audioData
#define DataType_data                   data

// _choice5 vs H223LogicalChannelParameters_adaptationLayerType
#define H223LCPs_aLTp_nnStndrd_chosen   H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen
#define H223LCPs_aLTp_al1Frmd_chosen    H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen
#define H223LCPs_aLTp_al1NtFrmd_chosen  H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen
#define H223LCPs_aLTp_a2WSNs_1_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223LCPs_aLTp_a2WSNs_2_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223LCPs_aLTp_al3_chosen        H223LogicalChannelParameters_adaptationLayerType_al3_chosen
#define H223LCPs_aLTp_nnStndrd          nonStandard
#define H223LCPs_aLTp_al3               al3

// UnicastAddress
#define UncstAddrss_iP6Address_chosen   UnicastAddress_iP6Address_chosen
#define UAs_nnStndrdAddrss_chosen       UnicastAddress_nonStandardAddress_chosen
#define UnicastAddress_iPAddress        iPAddress
#define UncstAddrss_iP6Address          iP6Address
#define UnicastAddress_nsap             nsap
#define UAs_nnStndrdAddrss              nonStandardAddress

// MulticastAddress
#define MltcstAddrss_iPAddress_chosen   MulticastAddress_iPAddress_chosen
#define MltcstAddrss_iP6Address_chosen  MulticastAddress_iP6Address_chosen
#define MAs_nnStndrdAddrss_chosen       MulticastAddress_nonStandardAddress_chosen
#define MltcstAddrss_iPAddress          iPAddress
#define MltcstAddrss_iP6Address         iP6Address
#define MulticastAddress_nsap           nsap
#define MAs_nnStndrdAddrss              nonStandardAddress

// H2250LogicalChannelParameters
#define H2250LCPs_nnStndrd_present      H2250LogicalChannelParameters_nonStandard_present
#define H2250LCPs_assctdSssnID_present  H2250LogicalChannelParameters_associatedSessionID_present
#define H2250LCPs_mdChnnl_present       H2250LogicalChannelParameters_mediaChannel_present
#define H2250LCPs_mdGrntdDlvry_present  H2250LogicalChannelParameters_mediaGuaranteedDelivery_present
#define H2250LCPs_mdCntrlChnnl_present  H2250LogicalChannelParameters_mediaControlChannel_present
#define H2250LCPs_mCGDy_present         H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present
#define H2250LCPs_dRTPPTp_present       H2250LogicalChannelParameters_dynamicRTPPayloadType_present
#define H2250LCPs_nnStndrd              nonStandard
#define H2250LCPs_assctdSssnID          associatedSessionID
#define H2250LCPs_mdChnnl               mediaChannel
#define H2250LCPs_mdGrntdDlvry          mediaGuaranteedDelivery
#define H2250LCPs_mdCntrlChnnl          mediaControlChannel
#define H2250LCPs_mCGDy                 mediaControlGuaranteedDelivery
#define H2250LCPs_dRTPPTp               dynamicRTPPayloadType

// _choice20 vs OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
#define fLCPs_mPs_h222LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define fLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define fLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define fLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define fLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define fLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define fLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define fLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define fLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define fLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// _choice21 vs OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define rLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define rLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define rLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define rLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define rLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define rLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// OpenLogicalChannel
#define OLCl_rLCPs_present              OpenLogicalChannel_reverseLogicalChannelParameters_present
#define OpnLgclChnnl_sprtStck_present   OpenLogicalChannel_separateStack_present
#define fLCPs_prtNmbr_present           OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present
#define fLCPs_prtNmbr                   portNumber
#define OLCl_rLCPs_mltplxPrmtrs_present OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present
#define OLCl_rLCPs_mltplxPrmtrs         multiplexParameters
#define OLCl_rLCPs                      reverseLogicalChannelParameters
#define OpnLgclChnnl_sprtStck           separateStack

// _choice23 vs MultiplexElement_type
#define typ_logicalChannelNumber_chosen MultiplexElement_type_logicalChannelNumber_chosen
#define typ_logicalChannelNumber        logicalChannelNumber

// _choice24 vs MultiplexElement_repeatCount
#define repeatCount_finite_chosen       MultiplexElement_repeatCount_finite_chosen
#define repeatCount_finite              finite

// _choice25 vs H261VideoMode_resolution
#define H261VdMd_resolution_qcif_chosen H261VideoMode_resolution_qcif_chosen
#define H261VdMd_resolution_cif_chosen  H261VideoMode_resolution_cif_chosen

// _choice26 vs H262VideoMode_profileAndLevel
#define prflAndLvl_SpatialatH_14_chosen profileAndLevel_SpatialatH_14_chosen

// H262VideoMode
#define H262VdMd_videoBitRate_present   H262VideoMode_videoBitRate_present
#define H262VdMd_vbvBufferSize_present  H262VideoMode_vbvBufferSize_present
#define H262VdMd_samplesPerLine_present H262VideoMode_samplesPerLine_present
#define H262VdMd_linesPerFrame_present  H262VideoMode_linesPerFrame_present
#define H262VdMd_frmsPrScnd_present     H262VideoMode_framesPerSecond_present
#define H262VdMd_lmnncSmplRt_present    H262VideoMode_luminanceSampleRate_present
#define H262VdMd_videoBitRate           videoBitRate
#define H262VdMd_vbvBufferSize          vbvBufferSize
#define H262VdMd_samplesPerLine         samplesPerLine
#define H262VdMd_linesPerFrame          linesPerFrame
#define H262VdMd_frmsPrScnd             framesPerSecond
#define H262VdMd_lmnncSmplRt            luminanceSampleRate

// _choice27 vs H263VideoMode_resolution
#define H263VdMd_resolution_qcif_chosen H263VideoMode_resolution_qcif_chosen
#define H263VdMd_resolution_cif_chosen  H263VideoMode_resolution_cif_chosen

// H263VideoMode
#define H263VdMd_errrCmpnstn_present    H263VideoMode_errorCompensation_present
#define H263VdMd_errrCmpnstn            errorCompensation

// IS11172VideoMode
#define IS11172VdMd_vdBtRt_present      IS11172VideoMode_videoBitRate_present
#define IS11172VdMd_vbvBffrSz_present   IS11172VideoMode_vbvBufferSize_present
#define IS11172VdMd_smplsPrLn_present   IS11172VideoMode_samplesPerLine_present
#define IS11172VdMd_lnsPrFrm_present    IS11172VideoMode_linesPerFrame_present
#define IS11172VdMd_pictureRate_present IS11172VideoMode_pictureRate_present
#define IS11172VdMd_lmnncSmplRt_present IS11172VideoMode_luminanceSampleRate_present
#define IS11172VdMd_vdBtRt              videoBitRate
#define IS11172VdMd_vbvBffrSz           vbvBufferSize
#define IS11172VdMd_smplsPrLn           samplesPerLine
#define IS11172VdMd_lnsPrFrm            linesPerFrame
#define IS11172VdMd_pictureRate         pictureRate
#define IS11172VdMd_lmnncSmplRt         luminanceSampleRate

// VideoMode
#define VideoMode_nonStandard           nonStandard

// _choice28 vs IS11172AudioMode_audioLayer
#define audioLayer1_chosen      IS11172AudioMode_audioLayer_audioLayer1_chosen
#define audioLayer2_chosen      IS11172AudioMode_audioLayer_audioLayer2_chosen
#define audioLayer3_chosen      IS11172AudioMode_audioLayer_audioLayer3_chosen

// _choice29 vs IS11172AudioMode_audioSampling
#define IS11172AMd_aSg_aS32k_chosen     IS11172AudioMode_audioSampling_audioSampling32k_chosen
#define IS11172AMd_aSg_aS441_chosen     IS11172AudioMode_audioSampling_audioSampling44k1_chosen
#define IS11172AMd_aSg_aS48k_chosen     IS11172AudioMode_audioSampling_audioSampling48k_chosen

// _choice30 vs IS11172AudioMode_multichannelType
#define IS11172AMd_mTp_snglChnnl_chosen IS11172AudioMode_multichannelType_singleChannel_chosen
#define IS11172AMd_mTp_tCSr_chosen      IS11172AudioMode_multichannelType_twoChannelStereo_chosen
#define IS11172AMd_mTp_twChnnlDl_chosen IS11172AudioMode_multichannelType_twoChannelDual_chosen

// _choice32 vs IS13818AudioMode_audioSampling
#define IS13818AMd_aSg_aS32k_chosen     IS13818AudioMode_audioSampling_audioSampling32k_chosen
#define IS13818AMd_aSg_aS441_chosen     IS13818AudioMode_audioSampling_audioSampling44k1_chosen
#define IS13818AMd_aSg_aS48k_chosen     IS13818AudioMode_audioSampling_audioSampling48k_chosen

// _choice33 vs IS13818AudioMode_multichannelType
#define IS13818AMd_mTp_snglChnnl_chosen IS13818AudioMode_multichannelType_singleChannel_chosen
#define IS13818AMd_mTp_tCSr_chosen      IS13818AudioMode_multichannelType_twoChannelStereo_chosen
#define IS13818AMd_mTp_twChnnlDl_chosen IS13818AudioMode_multichannelType_twoChannelDual_chosen

// _choice34 vs AudioMode_g7231
#define nSlncSpprssnLwRt_chosen         noSilenceSuppressionLowRate_chosen
#define nSlncSpprssnHghRt_chosen        noSilenceSuppressionHighRate_chosen
#define slncSpprssnLwRt_chosen          silenceSuppressionLowRate_chosen
#define slncSpprssnHghRt_chosen         silenceSuppressionHighRate_chosen

// AudioMode
#define AMd_g729AASSn_chosen            AudioMode_g729AnnexAwSilenceSuppression_chosen
#define AudioMode_nonStandard           nonStandard
#define AudioMode_g7231                 g7231

// _choice35 vs DataMode_application
#define DtMd_applctn_nonStandard_chosen DataMode_application_nonStandard_chosen
#define DtMd_application_t120_chosen    DataMode_application_t120_chosen
#define DtMd_application_dsm_cc_chosen  dsm_cc_chosen
#define DtMd_applctn_userData_chosen    DataMode_application_userData_chosen
#define DtMd_application_t434_chosen    DataMode_application_t434_chosen
#define DtMd_application_h224_chosen    DataMode_application_h224_chosen
#define DtMd_application_nlpid_chosen   DataMode_application_nlpid_chosen
#define DtMd_applctn_dsvdControl_chosen DataMode_application_dsvdControl_chosen
#define DMd_an_h222DtPrttnng_chosen     DataMode_application_h222DataPartitioning_chosen
#define DtMd_applctn_nonStandard        nonStandard
#define DtMd_application_t120           t120
#define DtMd_application_dsm_cc         dsm_cc
#define DtMd_applctn_userData           userData
#define DataMode_application_t84        t84
#define DtMd_application_t434           t434
#define DtMd_application_h224           h224
#define DtMd_application_nlpid          nlpid
#define DMd_an_h222DtPrttnng            h222DataPartitioning

// _choice36 vs H223ModeParameters_adaptationLayerType
#define H223MPs_aLTp_nnStndrd_chosen    H223ModeParameters_adaptationLayerType_nonStandard_chosen
#define H223MPs_aLTp_al1Frmd_chosen     H223ModeParameters_adaptationLayerType_al1Framed_chosen
#define H223MPs_aLTp_al1NtFrmd_chosen   H223ModeParameters_adaptationLayerType_al1NotFramed_chosen
#define H223MPs_aLTp_a2WSNs_1_chosen    H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223MPs_aLTp_a2WSNs_2_chosen    H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223MPs_adpttnLyrTyp_al3_chosen H223ModeParameters_adaptationLayerType_al3_chosen
#define H223MPs_aLTp_nnStndrd           nonStandard
#define H223MPs_adpttnLyrTyp_al3        al3

// ModeElement
#define h223AnnxAMdPrmtrs_present       h223AnnexAModeParameters_present
#define h223AnnxAMdPrmtrs               h223AnnexAModeParameters

// _choice38 vs MaintenanceLoopRequest_type
#define systemLoop_chosen               MaintenanceLoopRequest_type_systemLoop_chosen // MaintenanceLoopReject_type_systemLoop_chosen
#define mediaLoop_chosen                MaintenanceLoopRequest_type_mediaLoop_chosen // MaintenanceLoopReject_type_mediaLoop_chosen
#define logicalChannelLoop_chosen       MaintenanceLoopRequest_type_logicalChannelLoop_chosen // MaintenanceLoopReject_type_logicalChannelLoop_chosen

// RequestMessage
#define RqstMssg_nonStandard_chosen     RequestMessage_nonStandard_chosen
#define h223AnnxARcnfgrtn_chosen        h223AnnexAReconfiguration_chosen
#define RqstMssg_nonStandard            nonStandard
#define h223AnnxARcnfgrtn               h223AnnexAReconfiguration

// _choice45 vs TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
#define hghstEntryNmbrPrcssd_chosen     highestEntryNumberProcessed_chosen
#define hghstEntryNmbrPrcssd            highestEntryNumberProcessed

// _choice46 vs TerminalCapabilitySetReject_cause
#define TCSRt_cs_unspcfd_chosen         TerminalCapabilitySetReject_cause_unspecified_chosen
#define dscrptrCpctyExcdd_chosen        descriptorCapacityExceeded_chosen
#define tblEntryCpctyExcdd_chosen       tableEntryCapacityExceeded_chosen
#define tblEntryCpctyExcdd              tableEntryCapacityExceeded

// H2250LgclChnnlAckPrmtrs vs H2250LogicalChannelAckParameters
#define H2250LgclChnnlAckPrmtrs         H2250LogicalChannelAckParameters
#define H2250LCAPs_nnStndrd_present     H2250LogicalChannelAckParameters_nonStandard_present
#define H2250LCAPs_mdChnnl_present      H2250LogicalChannelAckParameters_mediaChannel_present
#define H2250LCAPs_mdCntrlChnnl_present H2250LogicalChannelAckParameters_mediaControlChannel_present
#define H2250LCAPs_dRTPPTp_present      H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present
#define H2250LCAPs_nnStndrd             nonStandard
#define H2250LCAPs_mdChnnl              mediaChannel
#define H2250LCAPs_mdCntrlChnnl         mediaControlChannel
#define H2250LCAPs_dRTPPTp              dynamicRTPPayloadType

// _choice47 vs OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h222LCPs_chosen       OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define mPs_h2250LgclChnnlPrmtrs_chosen OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define mPs_h2250LgclChnnlPrmtrs        h2250LogicalChannelParameters

// _choice48 vs OpenLogicalChannelAck_forwardMultiplexAckParameters
#define h2250LgclChnnlAckPrmtrs_chosen  h2250LogicalChannelAckParameters_chosen
#define h2250LgclChnnlAckPrmtrs         h2250LogicalChannelAckParameters

// OpenLogicalChannelAck
#define OLCAk_rLCPs_present             OpenLogicalChannelAck_reverseLogicalChannelParameters_present
#define OLCAk_sprtStck_present          OpenLogicalChannelAck_separateStack_present
#define frwrdMltplxAckPrmtrs_present    forwardMultiplexAckParameters_present
#define rLCPs_prtNmbr_present           OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present
#define OLCAk_rLCPs_mPs_present         OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present
#define rLCPs_prtNmbr                   portNumber
#define OLCAk_rLCPs_mPs                 multiplexParameters
#define OLCAk_rLCPs                     reverseLogicalChannelParameters
#define OLCAk_sprtStck                  separateStack
#define frwrdMltplxAckPrmtrs            forwardMultiplexAckParameters

// _choice49 vs OpenLogicalChannelReject_cause
#define OLCRt_cs_unspcfd_chosen         OpenLogicalChannelReject_cause_unspecified_chosen
#define unstblRvrsPrmtrs_chosen         unsuitableReverseParameters_chosen
#define dtTypALCmbntnNtSpprtd_chosen    dataTypeALCombinationNotSupported_chosen
#define mltcstChnnlNtAllwd_chosen       multicastChannelNotAllowed_chosen
#define sprtStckEstblshmntFld_chosen    separateStackEstablishmentFailed_chosen

// _choice51 vs MultiplexEntryRejectionDescriptions_cause
#define MERDs_cs_unspcfdCs_chosen       MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// MltplxEntryRjctnDscrptns vs MultiplexEntryRejectionDescriptions
#define MltplxEntryRjctnDscrptns        MultiplexEntryRejectionDescriptions

// _choice52 vs RequestMultiplexEntryRejectionDescriptions_cause
#define RMERDs_cs_unspcfdCs_chosen      RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// RqstMltplxEntryRjctnDscrptns vs RequestMultiplexEntryRejectionDescriptions
#define RqstMltplxEntryRjctnDscrptns    RequestMultiplexEntryRejectionDescriptions

// _choice53 vs RequestModeAck_response
#define wllTrnsmtMstPrfrrdMd_chosen     willTransmitMostPreferredMode_chosen
#define wllTrnsmtLssPrfrrdMd_chosen     willTransmitLessPreferredMode_chosen

// _choice57 vs CommunicationModeTableEntry_dataType
#define dataType_videoData_chosen       CommunicationModeTableEntry_dataType_videoData_chosen
#define dataType_audioData_chosen       CommunicationModeTableEntry_dataType_audioData_chosen
#define dataType_data_chosen            CommunicationModeTableEntry_dataType_data_chosen
#define dataType_videoData              videoData
#define dataType_audioData              audioData
#define dataType_data                   data

// CommunicationModeTableEntry
#define CMTEy_nnStndrd_present          CommunicationModeTableEntry_nonStandard_present
#define CMTEy_assctdSssnID_present      CommunicationModeTableEntry_associatedSessionID_present
#define CMTEy_mdChnnl_present           CommunicationModeTableEntry_mediaChannel_present
#define CMTEy_mdGrntdDlvry_present      CommunicationModeTableEntry_mediaGuaranteedDelivery_present
#define CMTEy_mdCntrlChnnl_present      CommunicationModeTableEntry_mediaControlChannel_present
#define CMTEy_mdCntrlGrntdDlvry_present CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present
#define CMTEy_nnStndrd                  nonStandard
#define CMTEy_assctdSssnID              associatedSessionID
#define CMTEy_mdChnnl                   mediaChannel
#define CMTEy_mdGrntdDlvry              mediaGuaranteedDelivery
#define CMTEy_mdCntrlChnnl              mediaControlChannel
#define CMTEy_mdCntrlGrntdDlvry         mediaControlGuaranteedDelivery

// ResponseMessage
#define RspnsMssg_nonStandard_chosen    ResponseMessage_nonStandard_chosen
#define mstrSlvDtrmntnAck_chosen        masterSlaveDeterminationAck_chosen
#define mstrSlvDtrmntnRjct_chosen       masterSlaveDeterminationReject_chosen
#define trmnlCpbltyStRjct_chosen        terminalCapabilitySetReject_chosen
#define rqstChnnlClsRjct_chosen         requestChannelCloseReject_chosen
#define rqstMltplxEntryRjct_chosen      requestMultiplexEntryReject_chosen
#define cmmnctnMdRspns_chosen           communicationModeResponse_chosen
#define h223AnnxARcnfgrtnAck_chosen     h223AnnexAReconfigurationAck_chosen
#define h223AnnxARcnfgrtnRjct_chosen    h223AnnexAReconfigurationReject_chosen
#define RspnsMssg_nonStandard           nonStandard
#define mstrSlvDtrmntnAck               masterSlaveDeterminationAck
#define mstrSlvDtrmntnRjct              masterSlaveDeterminationReject
#define trmnlCpbltyStRjct               terminalCapabilitySetReject
#define rqstChnnlClsRjct                requestChannelCloseReject
#define rqstMltplxEntryRjct             requestMultiplexEntryReject
#define cmmnctnMdRspns                  communicationModeResponse
#define h223AnnxARcnfgrtnAck            h223AnnexAReconfigurationAck
#define h223AnnxARcnfgrtnRjct           h223AnnexAReconfigurationReject

// SendTerminalCapabilitySet
#define cpbltyTblEntryNmbrs_present     capabilityTableEntryNumbers_present
#define cpbltyDscrptrNmbrs_present      capabilityDescriptorNumbers_present
#define cpbltyTblEntryNmbrs             capabilityTableEntryNumbers
#define cpbltyDscrptrNmbrs              capabilityDescriptorNumbers

// _choice59 vs FlowControlCommand_scope
#define FCCd_scp_lgclChnnlNmbr_chosen   FlowControlCommand_scope_logicalChannelNumber_chosen
#define FlwCntrlCmmnd_scp_rsrcID_chosen FlowControlCommand_scope_resourceID_chosen
#define FCCd_scp_whlMltplx_chosen       FlowControlCommand_scope_wholeMultiplex_chosen
#define FCCd_scp_lgclChnnlNmbr          logicalChannelNumber
#define FlwCntrlCmmnd_scp_rsrcID        resourceID

// EndSessionCommand
#define EndSssnCmmnd_nonStandard_chosen EndSessionCommand_nonStandard_chosen
#define EndSssnCmmnd_nonStandard        nonStandard

// _choice62 vs MiscellaneousCommand_type
#define cnclMltpntMdCmmnd_chosen        cancelMultipointModeCommand_chosen
#define MCd_tp_vdTmprlSptlTrdOff_chosen MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen
#define vdSndSyncEvryGOBCncl_chosen     videoSendSyncEveryGOBCancel_chosen
#define MCd_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// ConferenceCommand
#define brdcstMyLgclChnnl_chosen        broadcastMyLogicalChannel_chosen
#define cnclBrdcstMyLgclChnnl_chosen    cancelBroadcastMyLogicalChannel_chosen
#define cnclMkTrmnlBrdcstr_chosen       cancelMakeTerminalBroadcaster_chosen
#define brdcstMyLgclChnnl               broadcastMyLogicalChannel
#define cnclBrdcstMyLgclChnnl           cancelBroadcastMyLogicalChannel
             
// CommandMessage
#define CmmndMssg_nonStandard_chosen    CommandMessage_nonStandard_chosen
#define mntnncLpOffCmmnd_chosen         maintenanceLoopOffCommand_chosen
#define sndTrmnlCpbltySt_chosen         sendTerminalCapabilitySet_chosen
#define CmmndMssg_nonStandard           nonStandard
#define mntnncLpOffCmmnd                maintenanceLoopOffCommand
#define sndTrmnlCpbltySt                sendTerminalCapabilitySet

// FunctionNotUnderstood
#define FnctnNtUndrstd_request_chosen   FunctionNotUnderstood_request_chosen
#define FnctnNtUndrstd_response_chosen  FunctionNotUnderstood_response_chosen
#define FnctnNtUndrstd_command_chosen   FunctionNotUnderstood_command_chosen
#define FnctnNtUndrstd_request          request
#define FnctnNtUndrstd_response         response
#define FnctnNtUndrstd_command          command

// _choice63 vs MiscellaneousIndication_type
#define cnclMltpntCnfrnc_chosen         cancelMultipointConference_chosen
#define mltpntScndryStts_chosen         multipointSecondaryStatus_chosen
#define cnclMltpntScndryStts_chosen     cancelMultipointSecondaryStatus_chosen
#define vdIndctRdyTActvt_chosen         videoIndicateReadyToActivate_chosen
#define MIn_tp_vdTmprlSptlTrdOff_chosen MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen
#define MIn_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// _choice64 vs JitterIndication_scope
#define JIn_scp_lgclChnnlNmbr_chosen    JitterIndication_scope_logicalChannelNumber_chosen
#define JttrIndctn_scp_rsrcID_chosen    JitterIndication_scope_resourceID_chosen
#define JttrIndctn_scp_whlMltplx_chosen JitterIndication_scope_wholeMultiplex_chosen
#define JIn_scp_lgclChnnlNmbr           logicalChannelNumber
#define JttrIndctn_scp_rsrcID           resourceID

// UserInputIndication
#define UsrInptIndctn_nnStndrd_chosen   UserInputIndication_nonStandard_chosen
#define UsrInptIndctn_nnStndrd          nonStandard

// ConferenceIndication
#define cnclSnByAtLstOnOthr_chosen      cancelSeenByAtLeastOneOther_chosen

// IndicationMessage
#define IndctnMssg_nonStandard_chosen   IndicationMessage_nonStandard_chosen
#define mstrSlvDtrmntnRls_chosen        masterSlaveDeterminationRelease_chosen
#define trmnlCpbltyStRls_chosen         terminalCapabilitySetRelease_chosen
#define opnLgclChnnlCnfrm_chosen        openLogicalChannelConfirm_chosen
#define rqstChnnlClsRls_chosen          requestChannelCloseRelease_chosen
#define mltplxEntrySndRls_chosen        multiplexEntrySendRelease_chosen
#define rqstMltplxEntryRls_chosen       requestMultiplexEntryRelease_chosen
#define h2250MxmmSkwIndctn_chosen       h2250MaximumSkewIndication_chosen
#define IndctnMssg_nonStandard          nonStandard
#define mstrSlvDtrmntnRls               masterSlaveDeterminationRelease
#define trmnlCpbltyStRls                terminalCapabilitySetRelease
#define opnLgclChnnlCnfrm               openLogicalChannelConfirm
#define rqstChnnlClsRls                 requestChannelCloseRelease
#define mltplxEntrySndRls               multiplexEntrySendRelease
#define rqstMltplxEntryRls              requestMultiplexEntryRelease
#define h2250MxmmSkwIndctn              h2250MaximumSkewIndication

// MltmdSystmCntrlMssg vs MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg             MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg_PDU         MultimediaSystemControlMessage_PDU
#define MltmdSystmCntrlMssg_rqst_chosen MultimediaSystemControlMessage_request_chosen
#define MSCMg_rspns_chosen              MultimediaSystemControlMessage_response_chosen
#define MSCMg_cmmnd_chosen              MultimediaSystemControlMessage_command_chosen
#define MltmdSystmCntrlMssg_rqst        request
#define MSCMg_rspns                     response
#define MSCMg_cmmnd                     command


#ifdef __cplusplus
}
#endif

#endif // H245ASN1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\objectsafeimpl.h ===
#ifndef _OBJECT_SAFE_IMPL_H_
#define _OBJECT_SAFE_IMPL_H_

#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>


/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectSafeImpl.h

Abstract:

  base class for object safety. basic implementation for IObjectSafety

  derive your control from this class if the control is safe for scripting 
  on all the interfaces it exposes

  if you want to delegate IObjectSafety requests to the IObjectSafety
  interface of the aggrefate that supports the interface requested, 
  have your derived class implement QIOnAggregate() 

--*/


class CObjectSafeImpl : public IObjectSafety
{

public:
    
    CObjectSafeImpl()
        :m_dwSafety(0)
    {}


    //
    // we support INTERFACESAFE_FOR_UNTRUSTED_CALLER and INTERFACESAFE_FOR_UNTRUSTED_DATA
    //

    enum { SUPPORTED_SAFETY_OPTIONS = 
        INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA };


    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
    {

       
        IUnknown *pNonDelegatingUnknown = NULL;

        //
        // any options requested that we do not support?
        //
        
        if ( (~SUPPORTED_SAFETY_OPTIONS & dwOptionSetMask) != 0 )
        {
            return E_FAIL;
        }

        
        //
        //  Is the interface exposed by one of the aggregated objects?
        //
                
        HRESULT hr = QIOnAggregates(riid, &pNonDelegatingUnknown);

        if (SUCCEEDED(hr))
        {

            //
            // get IObjectSafety on non delegating unknown of the aggregated object
            //

            IObjectSafety *pAggrObjectSafety = NULL;

            hr = pNonDelegatingUnknown->QueryInterface(IID_IObjectSafety, (void**)&pAggrObjectSafety);

            pNonDelegatingUnknown->Release();
            pNonDelegatingUnknown = NULL;
            
            if (SUCCEEDED(hr))
            {

                // 
                // the aggregate exposes IObjectSafety. use it to set the new 
                // safety options
                //

                hr = pAggrObjectSafety->SetInterfaceSafetyOptions(riid,
                                                                  dwOptionSetMask,
                                                                  dwEnabledOptions);

                pAggrObjectSafety->Release();
                pAggrObjectSafety = NULL;

            }

        }
        else 
        {
            //
            // the interface requested is not requested by the object's 
            // aggregates. see if the interface is supported at all
            //

            hr = InterfaceSupported(riid);

            if (SUCCEEDED(hr))
            {

                //
                // the object supports the interface. Set safety options.
                // 

                s_CritSection.Lock();

                //
                // set the bits specified by the mask to the values specified by the values
                //

                m_dwSafety = (dwEnabledOptions & dwOptionSetMask) |
                             (m_dwSafety & ~dwOptionSetMask);

                s_CritSection.Unlock();

            }

        }

        return hr;
    }





    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
    {
        
        //
        // check caller's pointers
        //

        if ( IsBadWritePtr(pdwSupportedOptions, sizeof(DWORD)) ||
             IsBadWritePtr(pdwEnabledOptions, sizeof(DWORD)) )
        {
             return E_POINTER;
        }

        //
        //  if we fail, at least return something meaningful.
        //

        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;


        IUnknown *pNonDelegatingUnknown = NULL;
       
        //
        //  Is the interface exposed by one of the aggregated objects?
        //
        
        HRESULT hr = QIOnAggregates(riid, &pNonDelegatingUnknown);

        if (SUCCEEDED(hr))
        {

            //
            // get IObjectSafety on non delegating unknown of the aggregated object
            //

            IObjectSafety *pAggrObjectSafety = NULL;

            hr = pNonDelegatingUnknown->QueryInterface(IID_IObjectSafety, (void**)&pAggrObjectSafety);

            pNonDelegatingUnknown->Release();
            pNonDelegatingUnknown = NULL;
            
            if (SUCCEEDED(hr))
            {

                // 
                // the aggregate exposes IObjectSafety. use it to get the new 
                // safety options
                //

                hr = pAggrObjectSafety->GetInterfaceSafetyOptions(riid,
                                                                  pdwSupportedOptions,
                                                                  pdwEnabledOptions);

                pAggrObjectSafety->Release();
                pAggrObjectSafety = NULL;

            }

        }
        else 
        {
            //
            // the interface requested is not requested by the object's 
            // aggregates. see if the interface is supported at all
            //

            hr = InterfaceSupported(riid);

            if (SUCCEEDED(hr))
            {

                //
                // the object supports the interface. get options
                // 

                *pdwSupportedOptions = SUPPORTED_SAFETY_OPTIONS;

                s_CritSection.Lock();

                *pdwEnabledOptions = m_dwSafety;

                s_CritSection.Unlock();

            }

        }

        return hr;
    }


private:

    DWORD m_dwSafety;

    // 
    // thread safety
    //
    // this interface is not likely to be a performance bottleneck, 
    // at the same time, having one critical section per object
    // is wasteful. so have a static critical section
    //

    static CComAutoCriticalSection s_CritSection;


protected:

    //
    // return S_OK if the interface requested is exposed 
    // by the object
    //
    
    HRESULT InterfaceSupported(REFIID riid)
    {

        void *pVoid = NULL;

    
        HRESULT hr = E_FAIL;
     
        // 
        // does the object support requested interface
        //

        hr = QueryInterface(riid, &pVoid);


        if (SUCCEEDED(hr))
        {

            //
            // don't need the interface itself, just wanted to see if
            // it is supported
            //

            ((IUnknown*)pVoid)->Release();

        }
        

        return hr;
    }


    //
    // Implement in the derived class if you have any aggregates
    //
    // returns the non delegating IUnknown of the first (in the order of COMMAP)
    // aggregate that supports the iid requested
    //
    
    virtual HRESULT QIOnAggregates(REFIID riid, IUnknown **ppNonDelegatingUnknown)
    {
        return E_NOINTERFACE;
    }

};

#endif // _OBJECT_SAFE_IMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\objectwithsite.h ===
#ifndef _TAPI_OBJECT_WITH_SITE_H_
#define _TAPI_OBJECT_WITH_SITE_H_


/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectWithSite.h

Abstract:

    The implementation of IObjectWithSite interface that allows 
    for per-page persistent data to be stored in registry or as
    a cookie.

--*/


#include <Mshtml.h>
#include <Wininet.h>


//
// this url is used to construct the URL for cookies -- a security measure 
// so a script applet cannot drop a cookie with the same name and data
// and fool us into thinking it is our cookie
//

static const TCHAR gszHardCodedURL[] = _T("http://www.microsoft.com/");

//
// the expiration date is needed to make the cookie persistent
//

static const TCHAR  gszCookieData[] = 
                        _T("6; expires = Sat, 12-Sep-2099 00:00:00 GMT");



//
// dummy suffix to be appended to the url string
//

static const TCHAR  gszURLSuffix[] = 
                        _T("/url");

class CObjectWithSite : public  IObjectWithSite
{

public:

    //
    // current validation level. used to determine whether the page is safe, 
    // unsafe, or whether information from the user is needed
    //
    
    enum EnValidation { VALIDATED_SAFE, VALIDATED_SAFE_PERMANENT, VALIDATED_UNSAFE, UNVALIDATED };


public:

    
    //
    // store type
    // 

    enum EnMechanism { COOKIES, REGISTRY };


    CObjectWithSite(TCHAR const *pszStorageName)
        :m_pszURL(NULL),
        m_dwSecurityZone(URLZONE_UNTRUSTED),
        m_pUnkSite(NULL),
        m_pszStorageName(NULL)
    {
        SetStorageName(pszStorageName);
    }


    ~CObjectWithSite()
    {
    
        if (m_pszURL)
        {
            delete m_pszURL;
        
            m_pszURL = NULL;
        }

        
        if (m_pUnkSite)
        {
            m_pUnkSite->Release();

            m_pUnkSite = NULL;
        }


        if (m_pszStorageName)
        {

            delete m_pszStorageName;

            m_pszStorageName = NULL;

        }
    }

    ////////////////////////////
    //
   	// IObjectWithSite methods


    STDMETHOD(SetSite)(IUnknown *pUnkSite)
    {


        if ((NULL != pUnkSite) && IsBadCodePtr((FARPROC)pUnkSite))
        {
            return E_POINTER;
        }


        s_ObjectWithSiteCritSection.Lock();

        //
        // we are moving away from a page. this is the new page, as far as
        // validation logic is concerned, so invalidate the current page
        //

        if (NULL == pUnkSite)
        {
            Validate(UNVALIDATED);
        }

        // 
        // Get URL and zone information for this site
        //

        //
        // Note: we could delay this until we are actually asked for
        // zone or URL, but this should not be a performance bottlneck 
        // in our case, so do this now to keep the code simple.

        StoreURLAndZone(pUnkSite);


        //
        // replace the current site pointer with the new one
        //

        if (m_pUnkSite)
        {
            m_pUnkSite->Release();
        }


        m_pUnkSite = pUnkSite;

        if (m_pUnkSite)
        {
            m_pUnkSite->AddRef();
        }

        s_ObjectWithSiteCritSection.Unlock();

        return S_OK;
    }


    STDMETHOD(GetSite)(REFIID riid, void **ppSite)
    {

        HRESULT hr = E_POINTER;

        if (!IsBadWritePtr(ppSite, sizeof(void*)))
        {
    
            s_ObjectWithSiteCritSection.Lock();

            *ppSite = NULL;

            if (m_pUnkSite)
            {
                hr = m_pUnkSite->QueryInterface(riid, ppSite);
            }
            else
            {
                hr = E_FAIL;
            }

            s_ObjectWithSiteCritSection.Unlock();

        }

        return hr;
    }


    //
    // has this page been validated?
    //

    EnValidation GetValidation() 
    {

        //
        // if the page has not been validated, see if it is marked as safe
        //

        s_ObjectWithSiteCritSection.Lock();


        if (UNVALIDATED == s_enValidation)
        {
            if (IsPageSafe())
            {
                s_enValidation = VALIDATED_SAFE;
            }
        }

        EnValidation enValidation = s_enValidation;

        s_ObjectWithSiteCritSection.Unlock();

        return enValidation;
    }


    //
    // validate page as safe, unsafe, or reset validation
    //
    
    EnValidation Validate(EnValidation enNewValidation)
    {

        s_ObjectWithSiteCritSection.Lock();


        //
        // keep the validation before the change
        //
        
        EnValidation enOldValidation = s_enValidation;


        //
        // safe permanent is a special case:
        //

        if (VALIDATED_SAFE_PERMANENT == enNewValidation)
        {

            //
            // set persistent safety flag and 
            // validate page as safe
            //

            MarkPageAsSafe();
            enNewValidation = VALIDATED_SAFE;
        }


        //
        // change our validation level for this page
        //

        s_enValidation = enNewValidation;

        s_ObjectWithSiteCritSection.Unlock();

        return enOldValidation;
    }



    BOOL IsIntranet()
    {
        
        //
        //  if anything other that intranet assume internet -- a less secure zone
        //

        s_ObjectWithSiteCritSection.Lock();

        BOOL bIntranet = ( m_dwSecurityZone == URLZONE_INTRANET );

        s_ObjectWithSiteCritSection.Unlock();

        return bIntranet;

    }


    ////////////////////
    //
    // HaveSite()
    //
    // return true if we have a site pointer
    //

    BOOL HaveSite()
    {

        s_ObjectWithSiteCritSection.Lock();


        BOOL bHaveSite = FALSE;

        if (NULL != m_pUnkSite)
        {
            bHaveSite = TRUE;
        }


        s_ObjectWithSiteCritSection.Unlock();

        return bHaveSite;
    }



private:

    ////////////////////////////
    //
    //  store the current url in the "safe" list
    //
    //
    // not thread safe, called from inside a lock
    //

    HRESULT MarkPageAsSafe(EnMechanism enMechanism = COOKIES)
    {

        //
        // if storage is invalid, the object has not been properly initialized
        //

        if (IsBadStringPtr(m_pszStorageName, -1))
        {
            return E_UNEXPECTED;
        }


        //
        // is we don't have the url, can't do what we are asked
        //

        if (NULL == m_pszURL)
        {
            return S_FALSE;
        }


        //
        // if url is garbage, we have a problem
        //

        if ( IsBadStringPtr(m_pszURL, -1) )
        {
            return E_FAIL;
        }


        HRESULT hr = E_FAIL;

        switch (enMechanism)
        {

            case REGISTRY:

                hr = MarkPageSafeInRegistry(m_pszStorageName);
                break;

            case COOKIES:

                hr = MarkPageSafeCookie(m_pszStorageName);
                break;

            default:

                break;

        }

        return hr;
    }


    //
    //  Returns TRUE if the current page is in the safe list
    //

    //
    // not thread safe, called from inside a lock
    //

    BOOL IsPageSafe( EnMechanism enMechanism = COOKIES )
    {

        //
        // if we cannot get safety marking for whatever reason,
        // return false
        //
        
        _ASSERTE(NULL != m_pszStorageName);

        if ( IsBadStringPtr(m_pszURL, -1) || 
             IsBadStringPtr(m_pszStorageName, -1))
        {
            return FALSE;
        }

        BOOL bSafe = FALSE;

        switch (enMechanism)
        {

        case REGISTRY:
 
            bSafe = IsPageSafeRegistry(m_pszStorageName);
            break;

        case COOKIES:
 
            bSafe = IsPageSafeCookie(m_pszStorageName);
            break;

        default:
 
            break;
        }

        return bSafe;
    }



private:

    //
    // this method is only called from the constructor. not thread safe.
    //

    HRESULT SetStorageName(TCHAR const *pszStorageName)
    {
        //
        // calling this method invalidates the old storage name
        // so deallocate it before doing anything else
        //

        if (NULL != m_pszStorageName) 
        {
            delete m_pszStorageName;
            m_pszStorageName = NULL;
        }

        //
        // argument must be valid
        //

        if (IsBadStringPtr(pszStorageName, -1))
        {
            return E_POINTER;
        }

        // 
        // allocate buffer for the new storage name
        // 

        size_t nSize = _tcsclen(pszStorageName) + 1;

        m_pszStorageName = new TCHAR[nSize];

        if (NULL == m_pszStorageName)
        {
            return E_OUTOFMEMORY;
        }

        _tcscpy(m_pszStorageName, pszStorageName);

        return S_OK;
    }



    //
    // cache the url string and security zone id
    // not thread safe must be called from inside a lock
    //
    
    HRESULT StoreURLAndZone(IUnknown *pUnkSite)
    {

        //
        // reset zone and deallocate URL, if it exists
        //

        m_dwSecurityZone = URLZONE_UNTRUSTED;

        if (m_pszURL)
        {
            delete m_pszURL;
            m_pszURL = NULL;
        }
		    
        if (pUnkSite == NULL)
        {
            return S_OK;
        }

        // 
        // use pUnkSite to get to IHTMLDocument2, which will give us the URL
        // 

        //
        // these interfaces need to be released on exit.
        // smart pointers will do exactly what we need
        //

        HRESULT hr = E_FAIL;
                
        CComPtr<IOleClientSite> pSite;

	    if (FAILED(hr = pUnkSite->QueryInterface(IID_IOleClientSite, (LPVOID *) &pSite)))
        {
		    return hr;
        }

        
        CComPtr<IOleContainer>  pOleCtr;

	    if (FAILED(hr = pSite->GetContainer(&pOleCtr)))
        {
		    return hr;
        }


        CComPtr<IHTMLDocument2> pDoc;

        if (FAILED(hr = pOleCtr->QueryInterface(IID_IHTMLDocument2, (LPVOID *) &pDoc)))
        {
		    return hr;
        }

    
        // 
        //  get and keep the url
        //

        BSTR bstrURL;
        
        if (FAILED(hr = pDoc->get_URL(&bstrURL)))
        {
		    return hr;
        }

        UINT nURLLength = SysStringLen(bstrURL) + 1;

        _ASSERTE(NULL == m_pszURL);

        m_pszURL = new TCHAR[nURLLength];

        if (NULL == m_pszURL)
        {
            SysFreeString(bstrURL);
            return E_OUTOFMEMORY;
        }



#ifdef _UNICODE

        _tcscpy(m_pszURL, bstrURL);

#else
        int r = WideCharToMultiByte(
                                  CP_ACP,
                                  0,
                                  bstrURL,
                                  nURLLength,
                                  m_pszURL,
                                  nURLLength,
                                  NULL,
                                  NULL );

        if (0 == r)
        {
            SysFreeString(bstrURL);

            delete m_pszURL;
            m_pszURL = NULL;
            
            return E_FAIL;
        }


#endif

        //
        // whatever follows '#' and '?' is "extra info" and is not considered 
        // to be a part of the actual URL by Internet(Set/Get)Coookie. Extra 
        // Info has no value for us -- so throw it out
        //
        
        TCHAR *psDelimiter = _tcsstr(m_pszURL, _T("#"));
        
        if (NULL != psDelimiter)
        {
            *psDelimiter = _T('\0');
        }


        psDelimiter = _tcsstr(m_pszURL, _T("?"));

        if (NULL != psDelimiter)
        {
            *psDelimiter = _T('\0');
        }


        //
        // at this point we cached the URL
        // now attempt to get the security zone. if we fail getting zone
        // information still keep the url.
        //

        //
        //  Get security zone
        //
        
        CComPtr<IInternetSecurityManager> pSecMgr;
	           

        hr = CoCreateInstance(CLSID_InternetSecurityManager,
		                 NULL,
		                 CLSCTX_INPROC_SERVER,
		                 IID_IInternetSecurityManager,
		                 (LPVOID *) &pSecMgr);

	    if (pSecMgr == NULL)
        {
            SysFreeString(bstrURL);
		    return hr;
        }

	    hr = pSecMgr->MapUrlToZone(bstrURL, &m_dwSecurityZone, 0);
        
        
        //
        // if failed, reset url to untrusted, just in case
        //

        if ( FAILED(hr) )
        {
            m_dwSecurityZone = URLZONE_UNTRUSTED;
        }


        SysFreeString(bstrURL);

        //
        // we should have at least the URL at this point
        //

        return S_OK;
    }

    
    // 
    //  drop a cookie for this page as an indicator that this page is safe
    //

    HRESULT MarkPageSafeCookie(TCHAR const *pszCookieName)
    {

        TCHAR *pszURL = NULL;

        //
        // generate the url for the cookie
        // remember to delete the returned string
        //

        GenerateURLString(&pszURL);

        if (NULL == pszURL)
            return E_OUTOFMEMORY;

        BOOL bReturn = InternetSetCookie(pszURL, pszCookieName, gszCookieData);

        delete pszURL;

        return (bReturn)?S_OK:E_FAIL;
    }



    //
    //  presence of a cookie for this page is an indicator that it's safe
    //  returns TRUE if the cookie exists. FALSE otherwise
    // 
    
    BOOL IsPageSafeCookie(TCHAR const *pszCookieName)
    {
        
        //
        // m_pszURL was checked by the calling function and the object
        // is protected. m_pszURL should never be null here.
        //
        
        _ASSERTE(m_pszURL);

        // 
        // same goes for pszCookieName
        //

        _ASSERTE(pszCookieName);


        BOOL bReturn = FALSE;

        BOOL bFinalReturn = FALSE;


        TCHAR *pszURL = NULL;

        // remember to delete the returned string

        GenerateURLString(&pszURL);

        if (NULL == pszURL)
        {
            return FALSE;
        }
        
        //
        // see how much data the cookie contains
        //
        
        DWORD dwCookieDataSize = 0;
        
        // 
        // assuming the return code is TRUE if the method succeeds in getting
        // get the buffer size. the current documentation is not 100% clear
        //

        bReturn = InternetGetCookie(pszURL, pszCookieName, NULL, &dwCookieDataSize);


        //
        // dwCookieDataSize has the length of cookie data
        //
        
        if ( bReturn && dwCookieDataSize )
        {

            // 
            //  allocate the buffer for cookie data
            //

            TCHAR *pCookieDataBuffer = new TCHAR[dwCookieDataSize];

            if (NULL != pCookieDataBuffer)
            {
                //
                // all cookies for this page are returned in cookie data,
                // the name argument is ignored
                //
            
                bReturn = InternetGetCookie(pszURL,
                                            pszCookieName,
                                            pCookieDataBuffer,
                                            &dwCookieDataSize);
            

                // 
                // is succeeded, parse cookie data buffer to see if the 
                // cookie we are looking for is there
                //
                                
                if ( bReturn && ( NULL != _tcsstr(pCookieDataBuffer, pszCookieName) ) )
                {

                    bFinalReturn = TRUE;
                }


                delete pCookieDataBuffer;
                pCookieDataBuffer = NULL;
            }
        }


        delete pszURL;
        pszURL = NULL;

        return bFinalReturn;
    }

    

    //
    // add a registry entry for this page as an indicator that the page is safe
    // returns TRUE if the registry entry exists
    //

    HRESULT MarkPageSafeInRegistry(TCHAR const *szRegistryKeyName)
    {
       
        _ASSERTE(m_pszURL);

        //
        // open the registry key. create if not there
        //

        DWORD dwDisposition = 0;
        HKEY hKey = 0;

        LONG rc = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szRegistryKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisposition);

        if ( rc == ERROR_SUCCESS )
        {
            DWORD dwData = 0;

            //
            //  add the current URL to the registry
            //

            rc = RegSetValueEx(hKey,
                               m_pszURL,
                               0,
                               REG_DWORD,
                               (BYTE*)&dwData, 
                               sizeof(DWORD));
 
        }

        if (hKey)
        {
            RegCloseKey(hKey);
        }

        hKey = NULL;

        if (rc == ERROR_SUCCESS )
        {
            return S_OK;
        }
        else 
        {
            return E_FAIL;
        }
    }


    // 
    // presence of a registry entry for this page indicates that the 
    // page is safe
    //
    
    BOOL IsPageSafeRegistry(TCHAR const *szRegistryKeyName)
    {
        
        DWORD dwDisposition = 0;
        HKEY hKey = 0;

        //
        // the default is not safe
        //

        if (NULL == m_pszURL)
        {
            return FALSE;
        }

        //
        // open the registry key where the page information is kept.
        // create if not there
        //

        LONG rc = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szRegistryKeyName, 
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_CREATE_SUB_KEY | KEY_READ,
                            NULL,
                            &hKey,
                            &dwDisposition);

        if ( rc == ERROR_SUCCESS )
        {


            DWORD dwDataType = 0;
            DWORD dwDataSize = 0;
            
            // 
            // read the setting for the current page.
            // Note: we don't need the actual data, we just
            // want to see if the value exists
            // 

            rc = RegQueryValueEx(hKey,
                            m_pszURL,
                            0,
                            &dwDataType,
                            NULL,
                            &dwDataSize
                           );
        }
        
        if (hKey)
        {
            RegCloseKey(hKey);
        }

        hKey = NULL;

        return (rc == ERROR_SUCCESS);
    }


    // 
    // build the URL string based on the hardcoded URL and 
    // the actual URL for this page.
    // we are hoping that the striing will be unique (per page) and no
    // mischevious scripting app can drop a cookie corresponding to 
    // this URL
    // 
    // Note: if the implementation of of Internet(Set/Get)Cookie changes
    // to have stricter validation for the URL string, this technique will
    // not work
    // 

    void GenerateURLString(TCHAR **ppszURL)
    {
        
        //
        // the precondition is that m_pszURL exists
        //

        _ASSERT(NULL != m_pszURL);

        *ppszURL = NULL;

        //
        // alias the char pointer pointer to by *pszURL.
        // so it is easier to refer to.
        //

        TCHAR* &pszURL = *ppszURL;
        
        //
        // allocate memory for concatenated string
        //

        pszURL = new TCHAR[_tcslen(gszHardCodedURL) + 
                           _tcslen(m_pszURL) + 
                           _tcslen(gszURLSuffix) + 1];

        // concatenate 

        if (pszURL)
        {
            *pszURL = _T('\0');
        
            _tcscat(pszURL, gszHardCodedURL);
            _tcscat(pszURL, m_pszURL);
            _tcscat(pszURL, gszURLSuffix);
        }

    }



private:
    
    //
    // cached URL string
    //

    TCHAR *m_pszURL;


    //
    // cached security zone
    //
    
    DWORD m_dwSecurityZone;


    //
    // site for IObjectWithSite
    //

    IUnknown *m_pUnkSite;

    // 
    // thread safety
    //

    static CComAutoCriticalSection s_ObjectWithSiteCritSection;

    //
    // the status of the current page
    //

    static EnValidation s_enValidation;

    //
    // name of the persistent cookie or registry key
    //
    
    TCHAR *m_pszStorageName;

};

#endif // _TAPI_OBJECT_WITH_SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\promptedobjectsafety.h ===
#ifndef _TAPI_PROMPTED_OBJECT_SAFETY_H_
#define _TAPI_PROMPTED_OBJECT_SAFETY_H_

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    PromptedObjectSafety.h

Abstract:

  abstract base class for secure object safety mechanism

  calls the derived class's Ask() method to determine 
  whether safe for scripting request should be rejected

--*/


#include "ObjectSafeImpl.h"


class CPromptedObjectSafety : public CObjectSafeImpl
{

public:
   
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions)
    {
        if ( SUCCEEDED(InterfaceSupported(riid)) && Ask() )
        {
            return CObjectSafeImpl::SetInterfaceSafetyOptions(riid, 
                                                        dwOptionSetMask,
                                                        dwEnabledOptions);
        }
        else
        {
            return E_FAIL;
        }
    }


    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions,
                                         DWORD *pdwEnabledOptions)
    {
        if (SUCCEEDED(InterfaceSupported(riid)) && Ask())
        {
            return CObjectSafeImpl::GetInterfaceSafetyOptions(riid, 
                                                          pdwSupportedOptions,
                                                          pdwEnabledOptions);
        }
        else
        {
            return E_FAIL;
        }
    }

    //
    // implement Ask() in the derived class. Should contain the logic to make 
    // the decision on whether the control should be allowed to run
    //
    // return FALSE if you want to mark your control as not safe for scripting
    // return TRUE otherwise
    //

    virtual BOOL Ask() = 0;

};

#endif // _TAPI_PROMPTED_OBJECT_SAFETY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\rtppktd.h ===
/****************************************************************************
 *  @doc INTERNAL RTPPKTD
 *
 *  @module RtpPktD.h | Header file for the RTP packetization descriptor
 *    structures.
 ***************************************************************************/

#ifndef _RTPPKTD_H_
#define _RTPPKTD_H_

/*****************************************************************************
 *  @doc INTERNAL CRTPPKTDSTRUCTENUM
 *
 *  @struct RTP_PD | The <t RTP_PD> structure is used to specify the details
 *    of the RTP Pd format.
 *
 *  @field DWORD | dwThisHeaderLength | Specifies the length, in bytes, of
 *    this structure. This field is the offset to the next <t RTP_PD>
 *    structure, if there is one, or the start of the payload headers.
 *
 *  @field DWORD | dwPayloadHeaderOffset | Specifies the offset from the start
 *    of the RTP packetization descriptor data to the first byte of the payload
 *    header.
 *
 *  @field DWORD | dwPayloadHeaderLength | Specifies the length, in bytes, of
 *    the payload header.
 *
 *  @field DWORD | dwPayloadStartBitOffset | Specifies the offset from the
 *    start of the corresponding compressed video buffer to the first bit of
 *    the payload data associated with this <t RTP_PD> structure.
 *
 *  @field DWORD | dwPayloadEndBitOffset | Specifies the offset from the start
 *    of the corresponding compressed video buffer to the last bit of the
 *    payload data associated with this <t RTP_PD> structure.
 *
 *  @field DWORD | fEndMarkerBit | If set to TRUE, this flag signals that
 *    this structure applies to the last chunk of a video frame. Typically,
 *    only the last packet descriptor in a series of descriptors would have
 *    this flag turned on. However, this may not be the case for devices
 *    that do not respect frame boundaries and fill video capture buffers
 *    with truncated or multiple video frames.
 *
 *  @field DWORD | dwLayerId | Specifies the ID of the encoding layer this
 *    descriptor applies to. For standard video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc.
 *
 *  @field DWORD | dwTimestamp | Specifies the value of the timestamp field
 *    to be set by the downstream filter when creating the RTP header for
 *    this packet. The units and ranges for this field shall adhere to the
 *    definition of timestamp given in section 5.1 of RFC 1889.
 *
 *  @field DWORD | dwAudioAttributes | Specifies some bitfield attributes
 *    used to characterize the sample in the audio stream associated to this
 *    RTP packetization descriptor. This field shall always be set to 0,
 *    unless the audio sample described by this RTP packetization descriptor
 *    structure is a silent frame, in which case, this field shall be set
 *    to AUDIO_SILENT (defined as 1).
 *
 *  @field DWORD | dwVideoAttributes | Specifies some bitfield attributes
 *    used to characterize the sample in the video stream associated to this
 *    RTP packetization descriptor. There are no video attributes defined at
 *    this time. Therefore, this field shall always be set to 0.
 *
 *  @field DWORD | dwReserved | Reserved. Shall all be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD
{
    DWORD dwThisHeaderLength;
    DWORD dwPayloadHeaderOffset;
    DWORD dwPayloadHeaderLength;
    DWORD dwPayloadStartBitOffset;
    DWORD dwPayloadEndBitOffset;
	BOOL  fEndMarkerBit;
    DWORD dwLayerId;
    DWORD dwTimestamp;
	union {
	DWORD dwAudioAttributes;
	DWORD dwVideoAttributes;
	};
    DWORD dwReserved;
} RTP_PD, *PRTP_PD;

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD_HEADER | The <t RTP_PD_HEADER> structure is used to specify
 *    the details of the RTP Pd format.
 *
 *  @field DWORD | dwThisHeaderLength | Specifies the length, in bytes, of
 *    this structure. This field is the offset to the first <t RTP_PD>
 *    structure.
 *
 *  @field DWORD | dwTotalByteLength | Specifies the length, in bytes, of the
 *    entire data. This includes this structure, the <t RTP_PD> structures,
 *    and the payload information.
 *
 *  @field DWORD | dwNumHeaders | Specifies the number of <t RTP_PD>
 *    structures.
 *
 *  @field DWORD | dwReserved | Reserved. Shall be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD_HEADER
{
    DWORD dwThisHeaderLength;
    DWORD dwTotalByteLength;
    DWORD dwNumHeaders;
    DWORD dwReserved;
} RTP_PD_HEADER, *PRTP_PD_HEADER;

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD_INFO | The <t RTP_PD_INFO> structure is used to specify the
 *    details of the RTP Pd format.
 *
 *  @field REFERENCE_TIME | AvgTimePerSample | Specifies the average time per
 *    list of RTP packet descriptor, in 100ns units. This value shall be
 *    identical to the value of the <p AvgTimePerFrame> field of the video
 *    info header of the related compressed video stream format.
 *
 *  @field DWORD | dwMaxRTPPacketizationDescriptorBufferSize | Specifies the
 *    maximum size in bytes of the entire RTP packetization descriptor buffer.
 *    The format of this buffer is described in the following section. The
 *    maximum size of the entire RTP packetization descriptor buffer rarely
 *    needs to exceed a few hundred bytes.
 *
 *  @field DWORD | dwMaxRTPPayloadHeaderSize | Specifies the maximum size in
 *    bytes of the payload header data for one RTP packet. For example, the
 *    maximum size of a payload header for H.263 version 1 is 12 bytes (Mode
 *    C header).
 *
 *  @field DWORD | dwMaxRTPPacketSize | Specifies the maximum RTP packet
 *    size in bytes to be described by the list of packetization descriptor.
 *    Typically, this number is just below the MTU size of the network.
 *
 *  @field DWORD | dwNumLayers | Specifies the number of encoding layers to
 *    be described by the list of packetization descriptor. Typically, this
 *    number is equal to 1. Only in the case of multi-layered encoders would
 *    this number be higher than 1.
 *
 *  @field DWORD | dwPayloadType | Specifies the static payload type the
 *    stream describes. If the RTP packetization descriptors do not apply to
 *    an existing static payload type but a dynamic payload type, this field
 *    shall be set to DYNAMIC_PAYLOAD_TYPE (defined as MAXDWORD).
 *
 *  @field DWORD | dwDescriptorVersion | Specifies a version identifier
 *    qualifying the format of packetization descriptors. This field shall
 *    be set to VERSION_1 (defined as 1UL) to identify the packetization
 *    descriptor structures described in the next section.
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD_INFO {
	REFERENCE_TIME	AvgTimePerSample;
	DWORD			dwMaxRTPPacketizationDescriptorBufferSize;
	DWORD			dwMaxRTPPayloadHeaderSize;
	DWORD			dwMaxRTPPacketSize;
	DWORD			dwNumLayers;
	DWORD			dwPayloadType;
	DWORD			dwDescriptorVersion;
    DWORD			dwReserved[4];
} RTP_PD_INFO, *PRTP_PD_INFO;

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD_CONFIG_CAPS | The <t RTP_PD_CONFIG_CAPS> structure is used
 *    to store the RTP packetization descriptor configuration capabilities.
 *
 *  @field DWORD | dwSmallestRTPPacketSize | Specifies the size in bytes of the
 *    smallest RTP packet the stream can describe (typically, 512 bytes on Modem).
 *
 *  @field DWORD | dwLargestRTPPacketSize | Specifies the size in bytes of the
 *    largest packet the stream can describe (typically, 1350 bytes on LAN).
 *
 *  @field DWORD | dwRTPPacketSizeGranularity | Specifies the granularity of
 *    the increments between the smallest and largest packet size the stream
 *    supports (ex. 1).
 *
 *  @field DWORD | dwSmallestNumLayers | Specifies the smallest number of
 *    encoding layers the stream can describe (typically 1).
 *
 *  @field DWORD | dwLargestNumLayers | Specifies the largest number of
 *    encoding layers the stream can describe (typically 1).
 *
 *  @field DWORD | dwNumLayersGranularity | Specifies the granularity of the
 *    increments between the smallest and largest number of encoding layers
 *    the stream supports (ex. 0).
 *
 *  @field DWORD | dwNumStaticPayloadTypes | Specifies the number of static
 *    payload types the stream supports. This value is valid between 0 and
 *    4  (ex. 2 if it supports RFC 2190 and 2429 with H.263, but typically
 *    only 1).
 *
 *  @field DWORD | dwStaticPayloadTypes[4] | Specifies an array of static
 *    payload types the stream supports. A stream can support at most 4
 *    static payload types. The number of valid entries in this array is
 *    indicated by the <p dwNumStaticPayloadTypes> field (ex. 34 for H.263).
 *
 *  @field DWORD | dwNumDescriptorVersions | Specifies the number of
 *    packetization descriptor versions the stream supports. This value is
 *    valid between 1 and 4 (typically 1).
 *
 *  @field DWORD | dwDescriptorVersions[4] | Specifies an array of version
 *    identifiers qualifying the format of packetization descriptors. A
 *    stream can support at most 4 packetization descriptor versions. The
 *    number of valid entries in this array is indicated by the
 *    <p dwNumDescriptorVersions> field (ex. VERION_1).
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD_CONFIG_CAPS  {
	DWORD dwSmallestRTPPacketSize;
	DWORD dwLargestRTPPacketSize;
    DWORD dwRTPPacketSizeGranularity;
	DWORD dwSmallestNumLayers;
	DWORD dwLargestNumLayers;
    DWORD dwNumLayersGranularity;
	DWORD dwNumStaticPayloadTypes;
	DWORD dwStaticPayloadTypes[4];
	DWORD dwNumDescriptorVersions;
	DWORD dwDescriptorVersions[4];
    DWORD dwReserved[4];
} RTP_PD_CONFIG_CAPS, *PRTP_PD_CONFIG_CAPS;

#endif // _RTPPKTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\rendp.h ===
///////////////////////////////////////////////////////////////////////////////
//
// rendp.h
//
// Description: Private rend includes
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __REND_PRIVATE_INCLUDES
#define __REND_PRIVATE_INCLUDES

typedef enum OBJECT_ATTRIBUTE
{
    MEETING_ATTRIBUTES_BEGIN,
    MA_ADVERTISING_SCOPE,
    MA_CONFERENCE_BLOB,
    MA_DESCRIPTION,  
    MA_ISENCRYPTED,
    MA_MEETINGNAME,
    MA_ORIGINATOR,  
    MA_PROTOCOL,
    MA_START_TIME,
    MA_STOP_TIME,
    MA_TYPE,
    MA_URL,
    MEETING_ATTRIBUTES_END,

    USER_ATTRIBUTES_BEGIN,
    UA_USERNAME,
    UA_TELEPHONE_NUMBER,
    UA_IPPHONE_PRIMARY,
    UA_TAPIUID,
    USER_ATTRIBUTES_END

} OBJECT_ATTRIBUTE;
    
// {B6B6BCC0-8E1D-11d1-B011-00C04FC31FEE}
DEFINE_GUID(IID_ITConfBlobPrivate, 
0xb6b6bcc0, 0x8e1d, 0x11d1, 0xb0, 0x11, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xee);

interface ITConfBlobPrivate : IUnknown
{
public:

    STDMETHOD (GetName)(OUT BSTR *pVal) = 0;
    STDMETHOD (SetName)(IN BSTR newVal) = 0;

    STDMETHOD (GetOriginator)(OUT BSTR *pVal) = 0;
    STDMETHOD (SetOriginator)(IN BSTR newVal) = 0;

    STDMETHOD (GetUrl)(OUT BSTR *pVal) = 0;
    STDMETHOD (SetUrl)(IN BSTR newVal) = 0;

    STDMETHOD (GetDescription)(OUT BSTR *pVal) = 0;
    STDMETHOD (SetDescription)(IN BSTR newVal) = 0;

    STDMETHOD (GetAdvertisingScope)(OUT RND_ADVERTISING_SCOPE *pVal) = 0;
    STDMETHOD (SetAdvertisingScope)(IN RND_ADVERTISING_SCOPE newVal) = 0;

    STDMETHOD (GetStartTime)(OUT DWORD *pVal) = 0;
    STDMETHOD (SetStartTime)(IN DWORD newVal) = 0;

    STDMETHOD (GetStopTime)(OUT DWORD *pVal) = 0;
    STDMETHOD (SetStopTime)(IN DWORD newVal) = 0;

    STDMETHOD (get_IsModified)(VARIANT_BOOL *pfIsModified) = 0;
};

// {B6B6BCC1-8E1D-11d1-B011-00C04FC31FEE}
DEFINE_GUID(IID_ITDirectoryObjectPrivate, 
0xb6b6bcc1, 0x8e1d, 0x11d1, 0xb0, 0x11, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xee);

interface ITDirectoryObjectPrivate : IUnknown
{
public:
    STDMETHOD (GetAttribute)(
        IN    OBJECT_ATTRIBUTE    Attribute,
        OUT   BSTR *              ppAttributeValue
        ) = 0;

    STDMETHOD (SetAttribute)(
        IN    OBJECT_ATTRIBUTE    Attribute,
        IN    BSTR                pAttributeValue
        ) = 0;

    STDMETHOD (GetTTL)(
        OUT   DWORD *             pdwTTL
        ) = 0;


    STDMETHOD (get_SecurityDescriptorIsModified)(
        OUT   VARIANT_BOOL *      pfIsModified
        ) = 0;

    STDMETHOD (put_SecurityDescriptorIsModified)(
        IN   VARIANT_BOOL         fIsModified
        ) = 0;

    STDMETHOD (PutConvertedSecurityDescriptor) (
        IN char *                 pSD,
        IN DWORD                  dwSize
        ) = 0;

    STDMETHOD (GetConvertedSecurityDescriptor) (
        OUT char **                 ppSD,
        OUT DWORD *                 pdwSize
        ) = 0;
};

// {B6B6BCC2-8E1D-11d1-B011-00C04FC31FEE}
DEFINE_GUID(IID_ITDynamicDirectory, 
0xb6b6bcc2, 0x8e1d, 0x11d1, 0xb0, 0x11, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xee);

interface ITDynamicDirectory : IUnknown
{
public:
    STDMETHOD (Update)(DWORD dwSecondsPassed) = 0;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\scrpscrtdlg.h ===
// DlgAddr.h : Declaration of the CScriptSecurityDialog

#ifndef __SCRIPTSECURITYDIALOG_H_
#define __SCRIPTSECURITYDIALOG_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CScriptSecurityDialog


//
// this class is not thread safe
//

class CScriptSecurityDialog : 
	public CDialogImpl<CScriptSecurityDialog>
{

public:

    CScriptSecurityDialog ()
        :m_hModule(NULL),
        m_psMessageText(NULL)

    {
        //
        // the resource module is used to load the string and the dialog itself
        // so keep it around as a data member
        //

        m_hModule = ::LoadLibrary(_T("tapiui.dll"));
        
    }


    ~CScriptSecurityDialog ()
    {
        if (m_hModule)
        {
            FreeLibrary(m_hModule);
            m_hModule = NULL;
        }
    }


    INT_PTR DoModalWithText(UINT uResourceID, HWND hWndParent = ::GetActiveWindow())
    {

        //
        // this assertion could fail is if the class is used from 
        // a multithreaded app, and domodalX is called on two different threads
        // the class is not thread safe and this should be caught during 
        // testing.
        // another way this assert could fire is if the class itself is
        // broken. this, too, is a test-time error. 
        //
                
        _ASSERTE(NULL == m_psMessageText);

        //
        // load string from resource module
        //

        m_psMessageText = SafeLoadString(uResourceID);


        // 
        // if failed, bail out now
        //

        if (NULL == m_psMessageText)
        {

            return -1;
        }

        
        //
        // attempt to display the dialog box
        // the string is used in OnInitDialog to set the dialog's text
        //
        
        INT_PTR rc = _DoModal(hWndParent);

        //
        // deallocate string
        //

        delete m_psMessageText;
        m_psMessageText = NULL;

        return rc;
    }



    INT_PTR DoModalWithText(LPTSTR psMessageText, HWND hWndParent = ::GetActiveWindow())
    {
        //
        // this assertion could fail is if the class is used from 
        // a multithreaded app, and domodalX is called on two different threads
        // the class is not thread safe and this should be caught during 
        // testing.
        // another way this assert could fire is if the class itself is
        // broken. this, too, is a test-time error. 
        //

        _ASSERTE(NULL == m_psMessageText);

        //
        // the dialog is modal, so the lifetime of psMessageText is guaranteed 
        // to exceed the lifetime of the dialog.
        //

        m_psMessageText = psMessageText;

        
        //
        // attempt to display the dialog. the string will be used to set 
        // the message text in OnInitDialog
        // 

        INT_PTR rc = _DoModal(hWndParent);

        //
        // no longer need the string + the string cannot be assumed 
        // valid after we return
        //
        
        m_psMessageText = NULL;

        return rc;
    }

	enum { IDD = IDD_TAPI_SECURITY_DIALOG };


public:

BEGIN_MSG_MAP(CScriptSecurityDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(ID_YES, OnYes)
	COMMAND_ID_HANDLER(ID_NO, OnNo)
END_MSG_MAP()



//
// Attributes
//

private:

    //
    // the module where the resource is contained
    // needed for the prompt string and for the dialog itself
    // 

    HINSTANCE m_hModule;

    //
    // the prompt text
    //

    LPTSTR m_psMessageText;
    

protected:

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {   
        //
        // m_psMessageText must be set before _DoModal is called
        // if m_psMessageText is null here, the error is in the class itself
        // and this should be detected during testing
        //

        _ASSERTE(NULL != m_psMessageText);


        //
        // display the text that was passed into DoModalWithText as a string 
        // or a resources
        //

        SetDlgItemText(IDC_SECURITY_WARNING_TEXT, m_psMessageText);

	    return TRUE;
    }

	LRESULT OnYes(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        //
        // see if do not ask in the future is set
        // 
        
        if (IsDlgButtonChecked(IDC_DONOT_PROMPT_IN_THE_FUTURE))
            wID = ID_YES_DONT_ASK_AGAIN;

        EndDialog(wID);
       
        return FALSE;
    }


    LRESULT OnNo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        
        EndDialog(wID);
        
        return FALSE;
    }

	
private:

    INT_PTR _DoModal(HWND hWndParent)
    {
        
        // 
        // if the resource dll failed to load, bail out
        //
        
        if (NULL == m_hModule)
        {
            return -1;
        }
        
        //
        // otherwise, attempt to display the dialog box
        //

        _ASSERTE(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
        INT_PTR nRet = ::DialogBoxParam(m_hModule,
                        MAKEINTRESOURCE(CScriptSecurityDialog::IDD),
                        hWndParent,
                        (DLGPROC)CScriptSecurityDialog::StartDialogProc,
                        NULL);

 
        m_hWnd = NULL;
        return nRet;
    }


private:

    //
    // Load string for this resource. Safe with respect to string size
    //
    
    TCHAR *SafeLoadString( UINT uResourceID )
    {

        TCHAR *pszTempString = NULL;

        int nCurrentSizeInChars = 128;
        
        int nCharsCopied = 0;
        
        do
        {

            if ( NULL != pszTempString )
            {
                delete  pszTempString;
                pszTempString = NULL;
            }

            nCurrentSizeInChars *= 2;

            pszTempString = new TCHAR[ nCurrentSizeInChars ];

            if (NULL == pszTempString)
            {
                return NULL;
            }

            nCharsCopied = ::LoadString( m_hModule,
                                         uResourceID,
                                         pszTempString,
                                         nCurrentSizeInChars
                                        );

            if ( 0 == nCharsCopied )
            {
                delete pszTempString;
                return NULL;
            }

            //
            // nCharsCopied does not include the null terminator
            // so compare it to the size of the buffer - 1
            // if the buffer was filled completely, retry with a bigger buffer
            //

        } while ( (nCharsCopied >= (nCurrentSizeInChars - 1) ) );

        return pszTempString;
    }


    //
    // private, not to be called. the dialog must be created with DoModalWithText
    //

    HWND Create(HWND hWndParent, LPCTSTR psMessageText = NULL)
    {
        // this dialog must be created as modal

        _ASSERTE(FALSE);

        return NULL;
    }

    //
    // private, not to be called. the dialog must be created with DoModalWithText
    //

    INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
    {
        _ASSERTE(FALSE);

        return -1;
    }


};

#endif //__SCRIPTSECURITYDIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdp.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdp.h

Abstract:


Author:

*/

#ifndef __SDP__
#define __SDP__

#include "sdpcommo.h"
#include "sdpcset.h"
#include "sdpgen.h"
#include "sdpver.h"
#include "sdporigi.h"
#include "sdpconn.h"
#include "sdpbw.h"
#include "sdpatt.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"
#include "sdptime.h"
#include "sdpadtex.h"
#include "sdpenc.h"
#include "sdpmedia.h"


enum PARSE_STATE
{
    STATE_START,
    STATE_VERSION,
    STATE_ORIGIN,
    STATE_SESSION_NAME,
    STATE_TITLE,
    STATE_URI,
    STATE_EMAIL,
    STATE_PHONE,
    STATE_CONNECTION,
    STATE_BANDWIDTH,
    STATE_TIME,
    STATE_REPEAT,
    STATE_ADJUSTMENT,
    STATE_KEY,
    STATE_ATTRIBUTE,
    STATE_MEDIA,
    STATE_MEDIA_TITLE,
    STATE_MEDIA_CONNECTION,
    STATE_MEDIA_BANDWIDTH,
    STATE_MEDIA_KEY,
    STATE_MEDIA_ATTRIBUTE,
    STATE_NUM_STATES           // not a valid state, merely to count the number of states
};




class _DllDecl SDP
{
public:

    inline SDP();

    BOOL    Init();

    BOOL    IsValid();

	void	Reset();

    BOOL    IsModified();

    BOOL    ParseSdpPacket(
                IN      CHAR    *SdpPacket,
                IN      SDP_CHARACTER_SET CharacterSet = CS_IMPLICIT
                );

    // clears the modified state for each member field/value
    // this is used in sdpblb.dll to clear the modified state (when an sdp 
    // is parsed in, the state of all parsed in fields/values is modified) and 
    // the m_WasModified dirty flag
    void    ClearModifiedState();

    CHAR    *GenerateSdpPacket();

    inline BOOL                     GetWasModified();

    inline SDP_CHARACTER_SET        GetCharacterSet();

    inline SDP_VERSION              &GetProtocolVersion();

    inline SDP_ORIGIN               &GetOrigin();

    inline SDP_REQD_BSTRING_LINE    &GetSessionName();

    inline SDP_REQD_BSTRING_LINE    &GetSessionTitle();

    inline SDP_CHAR_STRING_LINE     &GetUri();

    inline SDP_EMAIL_LIST           &GetEmailList();
    
    inline SDP_PHONE_LIST           &GetPhoneList();

    inline SDP_CONNECTION           &GetConnection();

    inline SDP_BANDWIDTH            &GetBandwidth();

    inline void                     ClearDestroyTimeListFlag();

    inline SDP_TIME_LIST            &GetTimeList();

    inline SDP_ENCRYPTION_KEY       &GetEncryptionKey();

    inline SDP_ATTRIBUTE_LIST       &GetAttributeList();

    inline void                     ClearDestroyMediaListFlag();

    inline SDP_MEDIA_LIST           &GetMediaList();

    virtual ~SDP();

protected:

    // tracks if the last attempt to generate an sdp packet failed (starts with FALSE)
    BOOL                    m_LastGenFailed;
    CHAR                    *m_SdpPacket;
    DWORD                   m_BytesAllocated;
    DWORD                   m_SdpPacketLength;

    // dirty flag - is initially false and is set to TRUE when an sdp is generated because it had
    // been modified since the last time the sdp was generated.
    // (as IsModified() becomes FALSE after that)
    BOOL                    m_WasModified;

    CHAR                    *m_Current;
    PARSE_STATE             m_ParseState;

    BOOL                    m_DestroyMediaList;
    BOOL                    m_DestroyTimeList;

    SDP_CHARACTER_SET       m_CharacterSet;
    SDP_VERSION             m_ProtocolVersion;
    SDP_ORIGIN              m_Origin;
    SDP_REQD_BSTRING_LINE   m_SessionName;
    SDP_REQD_BSTRING_LINE   m_SessionTitle;     // optional
    SDP_CHAR_STRING_LINE    m_Uri;              // optional
    SDP_EMAIL_LIST          m_EmailList;        // optional
    SDP_PHONE_LIST          m_PhoneList;        // optional
    SDP_CONNECTION          m_Connection;
    SDP_BANDWIDTH           m_Bandwidth;        // optional
    SDP_TIME_LIST           *m_TimeList;         // optional
    SDP_ENCRYPTION_KEY      m_EncryptionKey;    // optional
    SDP_ATTRIBUTE_LIST      m_AttributeList;    // optional
    SDP_MEDIA_LIST          *m_MediaList;

    BOOL    DetermineCharacterSet(
                IN      CHAR                *SdpPacket,
                    OUT SDP_CHARACTER_SET   &CharacterSet
                );

private:


    BOOL    GetType(
                    OUT CHAR    &Type,
                    OUT BOOL    &EndOfPacket
                );

    
    BOOL    CheckTransition(
                IN      CHAR        Type,
                IN      PARSE_STATE CurrentParseState,
                    OUT PARSE_STATE &NewParseState
                );

    BOOL    GetValue(IN CHAR    Type);

    BOOL    IsValidEndState()   const;

};




inline 
SDP::SDP(
    )
    : m_SessionName(SDP_INVALID_SESSION_NAME, SESSION_NAME_STRING),
      m_SessionTitle(SDP_INVALID_SESSION_TITLE, TITLE_STRING),
      m_Uri(SDP_INVALID_URI, URI_STRING),
      m_AttributeList(ATTRIBUTE_STRING),
      m_DestroyMediaList(FALSE),
      m_MediaList(NULL),
      m_DestroyTimeList(FALSE),
      m_TimeList(NULL),
      m_SdpPacket(NULL),
      m_Current(NULL),
	  m_ParseState(STATE_START),
      m_LastGenFailed(FALSE),
      m_WasModified(FALSE),
      m_BytesAllocated(0),
      m_SdpPacketLength(0)
{
}


inline BOOL                     
SDP::GetWasModified(
    )
{
    return m_WasModified;
}


inline SDP_CHARACTER_SET              
SDP::GetCharacterSet(
    )
{
    return m_CharacterSet;
}



inline SDP_VERSION          &
SDP::GetProtocolVersion(
    )
{
    return m_ProtocolVersion;
}

inline SDP_ORIGIN           &
SDP::GetOrigin(
    )
{
    return m_Origin;
}

inline SDP_REQD_BSTRING_LINE     &
SDP::GetSessionName(
    )
{
    return m_SessionName;
}

inline SDP_REQD_BSTRING_LINE     &
SDP::GetSessionTitle(
    )
{
    return m_SessionTitle;
}


inline SDP_CHAR_STRING_LINE     &
SDP::GetUri(
    )
{
    return m_Uri;
}


inline SDP_EMAIL_LIST       &
SDP::GetEmailList(
    )
{
    return m_EmailList;
}
    
inline SDP_PHONE_LIST       &
SDP::GetPhoneList(
    )
{
    return m_PhoneList;
}

inline SDP_CONNECTION       &
SDP::GetConnection(
    )
{
    return m_Connection;
}

inline SDP_BANDWIDTH        &
SDP::GetBandwidth(
    )
{
    return m_Bandwidth;
}


inline void                     
SDP::ClearDestroyTimeListFlag(
    )
{
    m_DestroyTimeList = FALSE;
}


inline SDP_TIME_LIST        &
SDP::GetTimeList(
    )
{
    ASSERT(NULL != m_TimeList);
    return *m_TimeList;
}

inline SDP_ENCRYPTION_KEY   &
SDP::GetEncryptionKey(
    )
{
    return m_EncryptionKey;
}

inline SDP_ATTRIBUTE_LIST &
SDP::GetAttributeList(
    )
{
    return m_AttributeList;
}


inline void                     
SDP::ClearDestroyMediaListFlag(
    )
{
    m_DestroyMediaList = FALSE;
}


inline SDP_MEDIA_LIST       &
SDP::GetMediaList(
    )
{
    ASSERT(NULL != m_MediaList);
    return *m_MediaList;
}




#endif // __SDP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpadtex.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpadtex.h

Abstract:


Author:

*/

#ifndef __SDP_ADDRESS_TEXT__
#define __SDP_ADDRESS_TEXT__

#include "sdpcommo.h"
#include "sdpgen.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"

#include "sdpsadt.h"


class _DllDecl SDP_ADDRESS_TEXT : public SDP_VALUE
{
public:

    inline  SDP_ADDRESS_TEXT(
        IN              DWORD                   ErrorCode,
        IN      const   CHAR                    *TypeString,
        IN      const   SDP_LINE_TRANSITION     *SdpLineTransition = NULL
        );

    inline  SDP_OPTIONAL_BSTRING    &GetAddress();

    inline  SDP_BSTRING             &GetText();

    inline  BOOL                    SetCharacterSet(
        IN      SDP_CHARACTER_SET   CharacterSet
        );

    HRESULT SetAddressTextValues(
        IN		BSTR    AddressBstr,
        IN		BSTR    TextBstr
        );

protected:

    SDP_OPTIONAL_BSTRING    m_Address;
    SDP_BSTRING             m_Text;

    
    virtual BOOL    GetField(
			OUT SDP_FIELD   *&Field,
			OUT BOOL        &AddToArray
    ) = 0;

    virtual void	InternalReset();
};
 


inline 
SDP_ADDRESS_TEXT::SDP_ADDRESS_TEXT(
    IN              DWORD                   ErrorCode,
    IN      const   CHAR                    *TypeString,
    IN      const   SDP_LINE_TRANSITION     *SdpLineTransition
    )
    : SDP_VALUE(ErrorCode, TypeString, SdpLineTransition)
{
}



inline  SDP_OPTIONAL_BSTRING    &
SDP_ADDRESS_TEXT::GetAddress(
    )
{
    return m_Address;
}


inline  SDP_BSTRING             &
SDP_ADDRESS_TEXT::GetText(
    )
{
    return m_Text;
}


inline  BOOL
SDP_ADDRESS_TEXT::SetCharacterSet(
    IN      SDP_CHARACTER_SET   CharacterSet
    )
{
    return m_Text.SetCharacterSet(CharacterSet);
}


class _DllDecl SDP_ADDRESS_TEXT_LIST: 
    public SDP_VALUE_LIST,
    public SDP_ADDRESS_TEXT_SAFEARRAY
{
public:

    inline SDP_ADDRESS_TEXT_LIST();

    inline void SetCharacterSet(
        IN      SDP_CHARACTER_SET   CharacterSet
        );

protected:

    SDP_CHARACTER_SET   m_CharacterSet;
};



inline 
SDP_ADDRESS_TEXT_LIST::SDP_ADDRESS_TEXT_LIST(
    )
    : SDP_ADDRESS_TEXT_SAFEARRAY(*this)
{
}


// no need to check if the character set value is acceptable
// the check is performed in the list member
inline void 
SDP_ADDRESS_TEXT_LIST::SetCharacterSet(
    IN SDP_CHARACTER_SET CharacterSet
    )
{
    m_CharacterSet = CharacterSet;
}




class _DllDecl SDP_PHONE: public SDP_ADDRESS_TEXT
{
public:

    SDP_PHONE();

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );
};



class _DllDecl  SDP_PHONE_LIST : public SDP_ADDRESS_TEXT_LIST
{
protected:

    virtual SDP_VALUE   *CreateElement();
};



class _DllDecl  SDP_EMAIL: public SDP_ADDRESS_TEXT
{
public:

    SDP_EMAIL();

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );
};


class _DllDecl  SDP_EMAIL_LIST : public SDP_ADDRESS_TEXT_LIST
{
protected:

    virtual SDP_VALUE   *CreateElement();
};


#endif // __SDP_ADDRESS_TEXT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpatt.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpatt.h

Abstract:


Author:

*/
#ifndef __SDP_ATTRIBUTE__
#define __SDP_ATTRIBUTE__


#include "sdpcommo.h"
#include "sdpval.h"

#include "sdpsatt.h"


class _DllDecl SDP_ATTRIBUTE_LIST : 
    public SDP_VALUE_LIST,
    public SDP_ATTRIBUTE_SAFEARRAY
{
public:

    inline SDP_ATTRIBUTE_LIST(
        IN      const   CHAR    *TypeString
        );

    virtual SDP_VALUE   *CreateElement();

protected:

    const   CHAR    * const m_TypeString;
};



inline 
SDP_ATTRIBUTE_LIST::SDP_ATTRIBUTE_LIST(
    IN      const   CHAR    *TypeString
    )
    : SDP_ATTRIBUTE_SAFEARRAY(*this),
      m_TypeString(TypeString)
{
}


#endif // __SDP_ATTRIBUTE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpbstrl.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpbstrl.h

Abstract:


Author:

*/
#ifndef __SDP_BSTRING_LINE__
#define __SDP_BSTRING_LINE__

#include "sdpcommo.h"

#include <wtypes.h>
#include "sdpdef.h"
#include "sdpgen.h"
#include "sdpcstrl.h"
#include "sdpcset.h"




class _DllDecl SDP_ARRAY_BSTR : public CArray<BSTR, BSTR>
{
public:

    virtual ~SDP_ARRAY_BSTR();
};


class _DllDecl SDP_BSTRING : public SDP_CHAR_STRING
{
public:

    inline                      SDP_BSTRING();

	virtual void				Reset();

    inline SDP_CHARACTER_SET    GetCharacterSet() const;

    inline BOOL                 SetCharacterSet(IN SDP_CHARACTER_SET CharacterSet);

    inline BSTR                 &GetBstr();

	HRESULT						GetBstrCopy(IN BSTR *Bstr);

    virtual HRESULT             GetBstr(IN BSTR *Bstr);

    virtual HRESULT             SetBstr(IN BSTR Bstr);

    virtual                     ~SDP_BSTRING();

protected:

    SDP_CHARACTER_SET   m_CharacterSet;
    UINT                m_CodePage;
    BSTR                m_Bstr;

    virtual BOOL        InternalSetCharStrByRef(
        IN			CHAR    *CharacterStringByReference,
		IN			DWORD	Length
        );

    virtual BOOL        InternalSetCharStrByCopy(
        IN	const	CHAR    *CharacterStringByCopy,
		IN			DWORD	Length
        );

    virtual BOOL        InternalParseToken(
        IN			CHAR    *Token
        );
    
    BOOL ConvertToBstr(
        );
};



inline 
SDP_BSTRING::SDP_BSTRING(
    )
    : m_Bstr(NULL),
      m_CharacterSet(CS_UTF8),
      m_CodePage(CP_UTF8)
{
}


inline SDP_CHARACTER_SET   
SDP_BSTRING::GetCharacterSet(
    ) const
{
    return m_CharacterSet;
}


inline BOOL 
SDP_BSTRING::SetCharacterSet(
    IN SDP_CHARACTER_SET CharacterSet
    )
{
    // check if the character set value is acceptable
    if ( !IsLegalCharacterSet(CharacterSet, &m_CodePage) )
    {
        SetLastError(SDP_INTERNAL_ERROR);
        return FALSE;
    }

    m_CharacterSet = CharacterSet;
    return TRUE;
}


inline BSTR                 &
SDP_BSTRING::GetBstr(
    )
{
    return m_Bstr;
}



// its initially created with the ascii character set and
// it doesn't allow for changing the character set
class _DllDecl SDP_OPTIONAL_BSTRING : public SDP_BSTRING
{
public:

    inline SDP_OPTIONAL_BSTRING();

	virtual void Reset();
    
    // returns the bstr for the character string
    // creates a bstr if required
    virtual HRESULT     GetBstr(IN BSTR *Bstr);

    virtual HRESULT     SetBstr(IN BSTR Bstr);

protected:

    BOOL    m_IsBstrCreated;

    virtual BOOL        InternalSetCharStrByRef(
        IN			CHAR    *CharacterStringByReference,
		IN			DWORD	Length
        );

    virtual BOOL        InternalSetCharStrByCopy(
        IN	const	CHAR    *CharacterStringByCopy,
		IN			DWORD	Length
        );

private:

    // since the bstr must only be created on demand, parsing must
    // be over-ridden such that the bstr is not created during parsing
    virtual BOOL    InternalParseToken(
        IN      CHAR    *Token
        );

    // ZoltanS win64 fix: This bogus code was causing warnings.
    // Removed these methods so that the compiler will make sure that they
    // are never called. (Why it was ever done this way is a real mystery.)
    // 
    // inline BOOL     SetCharacterSet(IN SDP_CHARACTER_SET CharacterSet)
    // {
    //     // this is never called
    //     ASSERT(FALSE);
    //     return FALSE;
    // }
    //
    // inline BSTR     &GetBstr()
    // {
    //     BSTR    ReturnValue;
    //     // this is never called
    //     ASSERT(FALSE);
    //     return ReturnValue;
    // }
};


inline 
SDP_OPTIONAL_BSTRING::SDP_OPTIONAL_BSTRING(
    )
    : m_IsBstrCreated(FALSE)
{}




class _DllDecl SDP_BSTRING_LINE : public SDP_STRING_LINE
{
public:

    inline SDP_BSTRING_LINE(
        IN      const   DWORD       ErrorCode,
        IN      const   CHAR        *TypeString,
        IN              SDP_BSTRING &SdpBstring
        );

    virtual HRESULT     GetBstrCopy(IN BSTR *Bstr);

    virtual HRESULT     SetBstr(IN BSTR Bstr);

    inline SDP_BSTRING  &GetBstring();
};



inline 
SDP_BSTRING_LINE::SDP_BSTRING_LINE(
    IN      const   DWORD       ErrorCode,
    IN      const   CHAR        *TypeString,
    IN              SDP_BSTRING &SdpBstring
    )
    : SDP_STRING_LINE(ErrorCode, TypeString, SdpBstring)
{
}


inline SDP_BSTRING  &
SDP_BSTRING_LINE::GetBstring(
    )
{
    return (SDP_BSTRING &)m_ParseField;
}


class _DllDecl SDP_REQD_BSTRING_LINE : public SDP_BSTRING_LINE
{
public:

    inline SDP_REQD_BSTRING_LINE(
        IN      const   DWORD   ErrorCode,
        IN      const   CHAR    *TypeString
        );

private:

    SDP_BSTRING m_Bstring;

	virtual void InternalReset();
};



inline 
SDP_REQD_BSTRING_LINE::SDP_REQD_BSTRING_LINE(
    IN      const   DWORD   ErrorCode,
    IN      const   CHAR    *TypeString
    )
    : SDP_BSTRING_LINE(ErrorCode, TypeString, m_Bstring)
{
}





class _DllDecl SDP_CHAR_STRING_LINE : public SDP_BSTRING_LINE
{
public:

    inline SDP_CHAR_STRING_LINE(
        IN      const   DWORD   ErrorCode,
        IN      const   CHAR    *TypeString
        );

private:

    SDP_OPTIONAL_BSTRING m_SdpOptionalBstring;

	virtual void InternalReset();
};


inline 
SDP_CHAR_STRING_LINE::SDP_CHAR_STRING_LINE(
    IN      const   DWORD   ErrorCode,
    IN      const   CHAR    *TypeString
    )
    : SDP_BSTRING_LINE(ErrorCode, TypeString, m_SdpOptionalBstring)
{
}




class _DllDecl SDP_LIMITED_CHAR_STRING : public SDP_OPTIONAL_BSTRING
{
public:

    inline SDP_LIMITED_CHAR_STRING(
        IN      const   CHAR    **LegalStrings,
        IN              DWORD   NumStrings
        );

    HRESULT SetLimitedCharString(
        IN              CHAR    *String
        );

protected:

    const CHAR	**m_LegalStrings;
    const DWORD	m_NumStrings;
    
    virtual BOOL InternalParseToken(
        IN              CHAR    *Token
        );
};



inline 
SDP_LIMITED_CHAR_STRING::SDP_LIMITED_CHAR_STRING(
        IN      const   CHAR    **LegalStrings,
        IN              DWORD   NumStrings
        )
        : m_LegalStrings(LegalStrings),
          m_NumStrings(NumStrings)
{
}




class _DllDecl SDP_ADDRESS : public SDP_OPTIONAL_BSTRING
{
public:

    inline SDP_ADDRESS();

    inline  BOOL    IsMulticast() const;

    inline  void    SetMulticast(
        IN      BOOL    IsMulticastFlag
        );

    HRESULT SetAddress(
        IN      BSTR    Address
        );

    // calls SetAddress(Bstr)
    virtual HRESULT SetBstr(
        IN BSTR Bstr
        );

protected:

    BOOL   m_IsMulticastFlag;
    
    virtual BOOL InternalParseToken(
        IN      CHAR    *Token
        );

    BOOL IsValidIP4Address(
        IN  CHAR    *Address,
        OUT ULONG   &Ip4AddressValue
        );
};


inline SDP_ADDRESS::SDP_ADDRESS(
    )
    : m_IsMulticastFlag(FALSE)
{
}


inline  BOOL   
SDP_ADDRESS::IsMulticast(
    )   const
{
    return m_IsMulticastFlag;
}


inline  void 
SDP_ADDRESS::SetMulticast(
    IN BOOL IsMulticastFlag
    )
{
    m_IsMulticastFlag = IsMulticastFlag;
}



#endif // __SDP_BSTRING_LINE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpcset.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpcset.h

Abstract:


Author:

*/

#ifndef __SDP_CHARACTER_SET__
#define __SDP_CHARACTER_SET__

// for code pages etc.
#include <winnls.h>


const   CHAR    SDP_CHARACTER_SET_STRING[]  = "\na=charset:";
const   USHORT  SDP_CHARACTER_SET_STRLEN    = (USHORT) strlen(SDP_CHARACTER_SET_STRING);

const   CHAR    ASCII_STRING[]              = "ascii";
const   USHORT  ASCII_STRLEN                = (USHORT) strlen(ASCII_STRING);    

const   CHAR    UTF7_STRING[]               = "unicode-1-1-utf7";
const   USHORT  UTF7_STRLEN                 = (USHORT) strlen(UTF7_STRING);    

const   CHAR    UTF8_STRING[]               = "unicode-1-1-utf8";
const   USHORT  UTF8_STRLEN                 = (USHORT) strlen(UTF8_STRING);   


enum SDP_CHARACTER_SET
{
    CS_IMPLICIT,        // implicit from the sdp
    CS_ASCII,           // 8bit ISO 8859-1
    CS_UTF7,            // unicode, ISO 10646, UTF-7 encoding (rfc 1642)
    CS_UTF8,             // unicode, UTF-8 encoding
    CS_INVALID          // invalid character set
};





struct  SDP_CHARACTER_SET_ENTRY
{
    SDP_CHARACTER_SET   m_CharSetCode;
    const CHAR          *m_CharSetString;
    USHORT              m_Length;
};


const   SDP_CHARACTER_SET_ENTRY SDP_CHARACTER_SET_TABLE[] = {
    {CS_UTF7, UTF7_STRING, UTF7_STRLEN},
    {CS_UTF8, UTF8_STRING, UTF8_STRLEN}, 
    {CS_ASCII, ASCII_STRING, ASCII_STRLEN}
};

const USHORT    NUM_SDP_CHARACTER_SET_ENTRIES = sizeof(SDP_CHARACTER_SET_TABLE)/sizeof(SDP_CHARACTER_SET_ENTRY);




inline BOOL
IsLegalCharacterSet(
    IN      SDP_CHARACTER_SET   CharacterSet,
    IN  OUT UINT                *CodePage   = NULL
    )
{
    switch(CharacterSet)
    {
    case CS_ASCII:
        {
            if ( NULL != CodePage )
                *CodePage = CP_ACP;
        }

        break;

    case CS_UTF7:
        {
            if ( NULL != CodePage )
                *CodePage = CP_UTF7;
        }

        break;

    case CS_UTF8:
        {            
            if ( NULL != CodePage )
                *CodePage = CP_UTF8;
        }

        break;

    default:
        {
            return FALSE;
        }
    }

    return TRUE;
}


#endif // __SDP_CHARACTER_SET__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpcommo.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpcommo.h

Abstract:


Author:

*/
#ifndef __SDP_COMMON__
#define __SDP_COMMON__


#ifndef __SDP_LIB__
#define _DllDecl 
#else
#define _DllDecl 
#endif


#include <afx.h>
#include <afxtempl.h>

#include <windows.h>
#include <wtypes.h>


// Disable warning messages for using "this" in base member initializer list.
#pragma warning( disable : 4355 )  

// forward declaration for output stream from #include <strstrea.h>
class ostrstream;

class SDP;

class SDP_FIELD;
class SDP_SINGLE_FIELD;
class SDP_VALUE;

class SDP_BSTRING;
class SDP_OPTIONAL_BSTRING;
class SDP_BSTRING_LINE;
class SDP_REQD_BSTRING_LINE;

class SDP_CHAR_STRING;
class SDP_LIMITED_CHAR_STRING;
class SDP_CHAR_STRING_LINE;

class SDP_BYTE;
class SDP_LONG;
class SDP_ULONG;
class SDP_ADDRESS;

class SDP_ADDRESS_TEXT;
class SDP_ADDRESS_TEXT_LIST;

class SDP_TIME_PERIOD;
class SDP_TIME_PERIOD_LIST;

class SDP_VERSION;
class SDP_ORIGIN;
class SDP_EMAIL;
class SDP_EMAIL_LIST;
class SDP_PHONE;
class SDP_PHONE_LIST;
class SDP_CONNECTION;
class SDP_BANDWIDTH;
class SDP_TIME;
class SDP_TIME_LIST;
class SDP_REPEAT;
class SDP_REPEAT_LIST;
class SDP_ADJUSTMENT;
class SDP_ATTRIBUTE_LIST;
class SDP_MEDIA;
class SDP_MEDIA_LIST;

class SDP_LINE_TRANSITION;
struct LINE_TRANSITION_INFO;

class SDP_ADDRESS_TEXT_SAFEARRAY;
class SDP_ATTRIBUTE_SAFEARRAY;
class SDP_TIME_PERIOD_SAFEARRAY;
class SDP_ADJUSTMENT_SAFEARRAY;

#endif // __SDP_COMMON__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpconn.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpconn.h

Abstract:


Author:

*/

#ifndef __SDP_CONNECTION__
#define __SDP_CONNECTION__

#include "sdpcommo.h"
#include "sdpbstrl.h"
#include "sdpgen.h"




class _DllDecl SDP_CONNECTION : public SDP_VALUE
{
public:

    SDP_CONNECTION();

    inline SDP_LIMITED_CHAR_STRING &GetNetworkType();

    inline SDP_LIMITED_CHAR_STRING &GetAddressType();

    inline SDP_ADDRESS  &GetStartAddress();

    inline SDP_ULONG    &GetNumAddresses();

    inline SDP_BYTE     &GetTtl();

    HRESULT SetConnection(
        IN      BSTR    StartAddress,
        IN      ULONG   NumAddresses,
        IN      BYTE    Ttl
        );

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual void InternalReset();

private:

    SDP_LIMITED_CHAR_STRING     m_NetworkType;
    SDP_LIMITED_CHAR_STRING     m_AddressType;
    SDP_ADDRESS                 m_StartAddress;
    SDP_ULONG                   m_NumAddresses;
    SDP_BYTE                    m_Ttl;
};




inline SDP_LIMITED_CHAR_STRING &
SDP_CONNECTION::GetNetworkType(
    )
{
    return m_NetworkType;
}


inline SDP_LIMITED_CHAR_STRING &
SDP_CONNECTION::GetAddressType(
    )
{
    return m_AddressType;
}

inline SDP_ADDRESS  &
SDP_CONNECTION::GetStartAddress(
    )
{
    return m_StartAddress;
}


inline SDP_ULONG    &
SDP_CONNECTION::GetNumAddresses(
    )
{
    return m_NumAddresses;
}


inline SDP_BYTE     &
SDP_CONNECTION::GetTtl(
    )
{
    return m_Ttl;
}


#endif // __SDP_CONNECTION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpbw.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpbw.h

Abstract:


Author:

*/
#ifndef __SDP_BANDWIDTH__
#define __SDP_BANDWIDTH__

#include "sdpcommo.h"
#include "sdpval.h"
#include "sdpbstrl.h"
#include "sdpgen.h"



class _DllDecl SDP_BANDWIDTH : public SDP_VALUE
{
public:

    SDP_BANDWIDTH();

    inline SDP_OPTIONAL_BSTRING &GetModifier();

    inline SDP_ULONG            &GetBandwidthValue();

    HRESULT SetBandwidth(
        IN          BSTR    Modifier,
        IN          ULONG   Value
        );

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual void    InternalReset();

private:

    SDP_OPTIONAL_BSTRING    m_Modifier;
    SDP_ULONG               m_Bandwidth;
};



inline SDP_OPTIONAL_BSTRING &
SDP_BANDWIDTH::GetModifier(
    )
{
    return m_Modifier;
}

inline SDP_ULONG    &
SDP_BANDWIDTH::GetBandwidthValue(
    )
{
    return m_Bandwidth;
}


#endif // __SDP_BANDWIDTH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpcstrl.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpcstrl.h

Abstract:


Author:

*/

#ifndef __SDP_CHAR_STRING__
#define __SDP_CHAR_STRING__

#include "sdpcommo.h"
#include "sdpfld.h"
#include "sdpval.h"





class _DllDecl SDP_CHAR_STRING : public SDP_SINGLE_FIELD
{
public:

    inline          SDP_CHAR_STRING();

	virtual void	Reset();

    inline  BOOL    ByReference() const;

    inline  CHAR    *GetCharacterString() const;

    inline  CHAR    *GetModifiableCharString();

    inline	BOOL	SetCharacterStringByReference(
        IN			CHAR    *CharacterStringByReference,
		IN			DWORD	Length = 0
        );

	inline	BOOL	SetCharacterStringByCopy(
		IN	const	CHAR    *CharacterStringByCopy,
		IN			DWORD	Length = 0
		);

    inline  DWORD   GetLength() const;

    virtual         ~SDP_CHAR_STRING();

protected:
    
    virtual BOOL    InternalParseToken(
        IN          CHAR    *Token
        );

    inline BOOL     ReAllocCharacterString(
        IN          UINT    BufferSize
        );

    virtual BOOL	InternalSetCharStrByRef(
        IN          CHAR    *CharacterStringByReference,
		IN			DWORD	Length
        );

    virtual BOOL	InternalSetCharStrByCopy(
        IN	const	CHAR    *CharacterStringByCopy,
		IN			DWORD	Length
        );

    virtual DWORD   CalcCharacterStringSize();

    virtual BOOL    CopyField(
            OUT     ostrstream  &OutputStream
    );
    
    // this method should not be used
    virtual BOOL    PrintData(
            OUT     ostrstream  &OutputStream
        )
    {
        ASSERT(FALSE);
        return FALSE;
    }

private:

    DWORD   m_CharacterStringLength;
    CHAR    *m_CharacterString;

    DWORD   m_LengthByReference;
    CHAR    *m_CharacterStringByReference;

    DWORD   m_BytesAllocated;
};


inline 
SDP_CHAR_STRING::SDP_CHAR_STRING(
    )
    : SDP_SINGLE_FIELD(0, NULL),   // no buffer used (custom PrintField)
      m_CharacterString(NULL),
      m_CharacterStringLength(0),
      m_LengthByReference(0),
      m_CharacterStringByReference(NULL),
      m_BytesAllocated(0)
{}

      
inline  BOOL    
SDP_CHAR_STRING::ByReference(
    ) const
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    return (NULL == m_CharacterString);
}


inline CHAR *
SDP_CHAR_STRING::GetCharacterString(
    ) const
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    return ((TRUE == ByReference())? m_CharacterStringByReference : m_CharacterString);
}


inline  CHAR    *
SDP_CHAR_STRING::GetModifiableCharString(
    )
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    // the reference string is not modifiable
    ASSERT(FALSE == ByReference());
    
    return ((TRUE == ByReference())? NULL : m_CharacterString);
}
    
inline DWORD 
SDP_CHAR_STRING::GetLength(
    ) const
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    return ((TRUE == ByReference())? m_LengthByReference : m_CharacterStringLength);
}



inline BOOL    
SDP_CHAR_STRING::ReAllocCharacterString(
    IN      UINT    BufferSize
    )
{
    CHAR    *NewCharacterString;

    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    ASSERT(0 != BufferSize);

    // if the length of the token (not including the end of string) is not less than
    // the number of bytes allocated, release the bytes and allocate again
    if ( (BufferSize - 1) >= m_BytesAllocated )
    {
        try
        {
            NewCharacterString   = new CHAR[BufferSize];
        }
        catch(...)
        {
            NewCharacterString   = NULL;
        }

        if ( NULL == NewCharacterString )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        // If there is an old character string, delete it
        if ( NULL != m_CharacterString )
        {
            delete m_CharacterString;
        }

        m_BytesAllocated    = BufferSize;
        m_CharacterString   = NewCharacterString;
    }

    m_CharacterStringLength = BufferSize - 1;

    // If there was a reference to another string, remove it
    if ( ByReference() )
    {
        m_LengthByReference = 0;
        m_CharacterStringByReference = NULL;
    }

    return TRUE;
}


inline BOOL    
SDP_CHAR_STRING::SetCharacterStringByReference(
    IN          CHAR    *CharacterStringByReference,
	IN			DWORD	Length
    )
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    ASSERT(NULL != CharacterStringByReference);
    if ( NULL == CharacterStringByReference )
    {
        SetLastError(SDP_INVALID_VALUE);
        return FALSE;
    }

    if ( !InternalSetCharStrByRef(
			CharacterStringByReference, 
			(0==Length)? strlen(CharacterStringByReference): Length
			) )
    {
        return FALSE;
    }

    IsValid(TRUE);
    IsModified(TRUE);
    return TRUE;
}



inline BOOL    
SDP_CHAR_STRING::SetCharacterStringByCopy(
    IN	const	CHAR    *CharacterStringByCopy,
	IN			DWORD	Length
    )
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    ASSERT(NULL != CharacterStringByCopy);
    if ( NULL == CharacterStringByCopy )
    {
        SetLastError(SDP_INVALID_VALUE);
        return FALSE;
    }

    if ( !InternalSetCharStrByCopy(
			CharacterStringByCopy, 
			(0==Length)? strlen(CharacterStringByCopy): Length
			) )
    {
        return FALSE;
    }

    IsValid(TRUE);
    IsModified(TRUE);
    return TRUE;
}


class _DllDecl SDP_STRING_LINE : public SDP_VALUE
{
public:

    inline SDP_STRING_LINE(
        IN      const   DWORD       ErrorCode,
        IN      const   CHAR        *TypeString,
        IN              SDP_FIELD   &ParseField
        );

    virtual HRESULT     GetBstrCopy(IN BSTR *Bstr) = 0;

    virtual HRESULT     SetBstr(IN BSTR Bstr) = 0;

protected:

    SDP_FIELD   &m_ParseField;
    
    virtual BOOL        InternalParseLine(
        IN  OUT         CHAR    *&Line
        );

    inline  SDP_FIELD   &GetParseField();
};


inline 
SDP_STRING_LINE::SDP_STRING_LINE(
    IN      const   DWORD       ErrorCode,
    IN      const   CHAR        *TypeString,
    IN              SDP_FIELD   &ParseField
    )
    : SDP_VALUE(ErrorCode, TypeString),
      m_ParseField(ParseField)
{
}


inline SDP_FIELD &
SDP_STRING_LINE::GetParseField(
    )
{
    return m_ParseField;
}



#endif // __SDP_CHAR_STRING__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpfld.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_FIELD__
#define __SDP_FIELD__

#include <strstrea.h>
#include "sdpcommo.h"
#include "sdpdef.h"
#include "sdpgen.h"



class _DllDecl SDP_FIELD
{
public:

    virtual  void    Reset()            = 0;

    virtual  BOOL    IsValid() const    = 0;

    virtual  BOOL    IsModified() const = 0;

    virtual  void    IsModified(
        IN          BOOL    ModifiedFlag
        ) = 0;

    virtual  DWORD   GetCharacterStringSize() = 0;

    virtual  BOOL    PrintField(
            OUT     ostrstream  &OutputStream
        ) = 0;

    virtual BOOL      ParseToken(
        IN          CHAR        *Token
        ) = 0;

    virtual ~SDP_FIELD()
    {}
};


class _DllDecl SDP_SINGLE_FIELD : public SDP_FIELD
{
public:

    inline SDP_SINGLE_FIELD(
        IN          DWORD   BufferSize,
        IN          CHAR    *Buffer
        );

	// SDP_VALUE instances use an inline Reset method which calls a virtual InternalReset method.
	// this is possible because unlike the SDP_FIELD inheritance tree, SDP_VALUE and SDP_VALUE_LIST
	// do not share a common base class. This combined with the fact that the SDP_VALUE inheriance 
	// tree is quite shallow and has fewer instances (than SDP_FIELD) makes the scheme appropriate
	// it as it reduces the number of Reset related calls to 1 and the inline code is not repeated
	// to often.
	// For the SDP_FIELD inheritance tree, the appropriate Reset calling sequence is a series of
	// Reset calls starting with the top most virtual Reset body followed by the
	// base class Reset method (recursively). This is appropriate because, the number of calls
	// would not decrease if the InternalReset scheme is adopted (virtual Reset()) and that the
	// inheritance tree is much deeper
    virtual  void    Reset();

    // the IsValid and IsModified methods are virtual only because the base
    // class is virtual. It is required that none of the classes derived
    // from this class over-ride these methods.
    virtual  BOOL    IsValid() const;

    virtual  BOOL    IsModified() const;

    virtual  void    IsModified(
        IN          BOOL    ModifiedFlag
        );

    virtual  DWORD   GetCharacterStringSize();

    virtual  BOOL    PrintField(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL      ParseToken(
        IN          CHAR        *Token
        );

    virtual ~SDP_SINGLE_FIELD()
    {}

protected:

    // flag - tells whether the type value is valid (parsed in / added later etc.)
    BOOL    m_IsValid;

    BOOL    m_IsModified;
    
	// this should be const, but cannot be because ostrstream does not take 
	// const length for parameter
    DWORD   m_PrintBufferSize;
    CHAR    *m_PrintBuffer;
    DWORD   m_PrintLength;


    void    IsValid(
        IN          BOOL    ValidFlag
        );

    virtual DWORD   CalcCharacterStringSize();

    virtual BOOL    CopyField(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL    InternalParseToken(
        IN          CHAR        *Token
        ) = 0;

    inline void     RemoveWhiteSpaces(
        IN  OUT     CHAR    *&Token
        );

    inline BOOL     IsWhiteSpaces(
        IN          CHAR    *Token,
        IN          DWORD   ErrorCode
        );
    
    virtual BOOL    PrintData(
            OUT     ostrstream  &OutputStream
        ) = 0;
};



inline 
SDP_SINGLE_FIELD::SDP_SINGLE_FIELD(
    IN          DWORD   BufferSize,
    IN          CHAR    *Buffer
    )
    : m_IsValid(FALSE),
      m_IsModified(FALSE),
      m_PrintBufferSize(BufferSize),
      m_PrintBuffer(Buffer),
      m_PrintLength(0)
{
}



inline void 
SDP_SINGLE_FIELD::RemoveWhiteSpaces(
    IN  OUT     CHAR    *&Token
    )
{
    // use of line terminator ensures that the token ptr cannot be null
    ASSERT(NULL != Token);

    while ( EOS != *Token )
    {
        if ( (CHAR_BLANK == *Token) 
            || (CHAR_TAB == *Token)
            || (CHAR_RETURN == *Token) )
        {
            Token++;
        }
        else
        {
            return;
        }
    }
}


inline BOOL 
SDP_SINGLE_FIELD::IsWhiteSpaces(
    IN          CHAR    *Token,
    IN          DWORD   ErrorCode
    )
{
    while ( EOS != *Token )
    {
        if ( (CHAR_BLANK == *Token) 
            || (CHAR_TAB == *Token)
            || (CHAR_RETURN == *Token) )
        {
            Token++;
        }
        else
        {
            SetLastError(ErrorCode);
            return FALSE;
        }
    }

    return TRUE;
}



class _DllDecl SDP_FIELD_LIST : public SDP_POINTER_ARRAY<SDP_FIELD *>,
                                public SDP_FIELD
{
public:

    inline          SDP_FIELD_LIST(
        IN      CHAR    SeparatorChar = CHAR_BLANK
        );

    virtual void    Reset();

    virtual BOOL    IsValid() const;

    virtual BOOL    IsModified() const;

    virtual void    IsModified(
        IN      BOOL    ModifiedFlag
        );

    virtual DWORD   GetCharacterStringSize();

    virtual BOOL    PrintField(
            OUT ostrstream  &OutputStream
        );

    virtual BOOL    ParseToken(
        IN      CHAR    *Token
        );

protected:

    const   CHAR    m_SeparatorChar;

    virtual SDP_FIELD   *CreateElement() = 0;
};


inline 
SDP_FIELD_LIST::SDP_FIELD_LIST(
    IN      CHAR    SeparatorChar
    )
    : m_SeparatorChar(SeparatorChar)
{
}



// for reading unsigned integral base type values largest of which may
// be a ULONG
// no Reset method to set the value member to 0 again (as its not really required and it saves 
// one call per instance)
template <class T>
class _DllDecl SDP_UNSIGNED_INTEGRAL_BASE_TYPE : public SDP_SINGLE_FIELD
{
public:

    inline SDP_UNSIGNED_INTEGRAL_BASE_TYPE();

    inline  HRESULT GetValue(
        IN  T   &Value
        );

    inline  T       GetValue() const;

    inline  void    SetValue(
        IN  T   Value
        );

    inline  void    SetValueAndFlag(
        IN  T   Value
        );

protected:

    T       m_Value;

    CHAR    m_NumericalValueBuffer[25];
    
    virtual BOOL    InternalParseToken(
        IN   CHAR    *Token
        );

    
    virtual BOOL    PrintData(
            OUT ostrstream  &OutputStream
        );
};


template <class T>
inline 
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::SDP_UNSIGNED_INTEGRAL_BASE_TYPE(
    )
    : SDP_SINGLE_FIELD(sizeof(m_NumericalValueBuffer), m_NumericalValueBuffer),
      m_Value(0)
{
}


template <class T>
inline  HRESULT 
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::GetValue(
    IN  T   &Value
    )
{
    if ( !IsValid() )
    {
        return HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA);
    }

    Value = m_Value;
    return S_OK;
}


template <class T>
inline T   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::GetValue(
    ) const
{
    return m_Value;
}


template <class T>
inline void   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::SetValue(
    IN  T   Value
    )
{
    m_Value = Value;
}


template <class T>
inline void   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::SetValueAndFlag(
    IN  T   Value
    )
{
    m_Value = Value;
    IsValid(TRUE);
    IsModified(TRUE);
}



template <class T>
inline BOOL   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::InternalParseToken(
    IN   CHAR    *Token
    )
{
    CHAR    *Current = Token;

    // remove preceding white spaces
    RemoveWhiteSpaces(Current);

    // check that the first character is a digit (to weed out -ve values)
    if ( !isdigit(*Current) )
    {
        SetLastError(SDP_INVALID_NUMERICAL_VALUE);
        return FALSE;
    }
        
    // since T is UNSIGNED, max value will contain all 1's - the
    // maximum value it can store
    const T MaxValue = -1;

    // ensure that T is unsigned
    // since such an error will be detected during debugging, no need
    // for if ( ! ... ) code
    ASSERT(MaxValue > 0);

    CHAR    *RestOfToken = NULL;
    ULONG   TokenValue   = strtoul(Current, &RestOfToken, 10);

    if ( (ULONG_MAX == TokenValue) || (MaxValue < TokenValue) )
    {
        SetLastError(SDP_INVALID_NUMERICAL_VALUE);
        return FALSE;
    }

    // ensure that rest of the string is white spaces
    if ( !IsWhiteSpaces(RestOfToken, SDP_INVALID_NUMERICAL_VALUE) )
    {
        return FALSE;
    }

    m_Value = (T)TokenValue;
    return TRUE;
}       


template <class T>
inline BOOL   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::PrintData(
        OUT ostrstream  &OutputStream
    )
{
    OutputStream << (ULONG)m_Value;
    if ( OutputStream.fail() )
    {
        SetLastError(SDP_OUTPUT_ERROR);
        return FALSE;
    }

    return TRUE;
}


class _DllDecl SDP_ULONG : public SDP_UNSIGNED_INTEGRAL_BASE_TYPE<ULONG>
{
};


class _DllDecl SDP_USHORT : public SDP_UNSIGNED_INTEGRAL_BASE_TYPE<USHORT>
{
};


class _DllDecl SDP_BYTE : public SDP_UNSIGNED_INTEGRAL_BASE_TYPE<BYTE>
{
};



class SDP_BYTE_LIST : public SDP_FIELD_LIST
{
public:
    
    virtual SDP_FIELD   *CreateElement()
    {
        SDP_BYTE *SdpByte;

        try
        {
            SdpByte = new SDP_BYTE();
        }
        catch(...)
        {
            SdpByte = NULL;
        }

        return SdpByte;
    }
};



class SDP_ULONG_LIST : public SDP_FIELD_LIST
{
public:
    
    virtual SDP_FIELD   *CreateElement()
    {
        SDP_ULONG *SdpULong;

        try
        {
            SdpULong = new SDP_ULONG();
        }
        catch(...)
        {
            SdpULong = NULL;
        }

        return SdpULong;
    }
};


#endif // __SDP_FIELD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpmedia.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_MEDIA__
#define __SDP_MEDIA__

#include "sdpcommo.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"
#include "sdpconn.h"
#include "sdpbw.h"
#include "sdpenc.h"
#include "sdpatt.h"
#include "sdpval.h"

#include "sdpsobst.h"


class _DllDecl SDP_FORMAT_CODE_LIST :
    public SDP_OPT_BSTRING_LIST,
    public SDP_OPT_BSTRING_SAFEARRAY
{
public:

    inline SDP_FORMAT_CODE_LIST();
};


inline 
SDP_FORMAT_CODE_LIST::SDP_FORMAT_CODE_LIST(
    )
    : SDP_OPT_BSTRING_SAFEARRAY(*((SDP_OPT_BSTRING_LIST *)this))
{
}


class _DllDecl SDP_MEDIA : public SDP_VALUE
{
public:

    SDP_MEDIA();

    inline SDP_OPTIONAL_BSTRING     &GetName();

    inline SDP_REQD_BSTRING_LINE    &GetTitle();

    inline SDP_USHORT               &GetStartPort();

    inline SDP_USHORT               &GetNumPorts();

    inline SDP_OPTIONAL_BSTRING     &GetProtocol();

    inline SDP_FORMAT_CODE_LIST     &GetFormatCodeList();

    inline SDP_CONNECTION           &GetConnection();

    inline SDP_BANDWIDTH            &GetBandwidth();

    inline SDP_ENCRYPTION_KEY       &GetEncryptionKey();

    inline SDP_ATTRIBUTE_LIST       &GetAttributeList();

	HRESULT SetPortInfo(
		IN	USHORT	StartPort, 
		IN	USHORT	NumPorts
		);


protected:

    SDP_OPTIONAL_BSTRING    m_Name;
    SDP_USHORT              m_StartPort;
    SDP_USHORT              m_NumPorts;
    SDP_OPTIONAL_BSTRING    m_TransportProtocol;
    SDP_FORMAT_CODE_LIST    m_FormatCodeList;    
    SDP_REQD_BSTRING_LINE   m_Title;
    SDP_CONNECTION          m_Connection;
    SDP_BANDWIDTH           m_Bandwidth;
    SDP_ENCRYPTION_KEY      m_EncryptionKey;
    SDP_ATTRIBUTE_LIST      m_AttributeList;

    virtual void			InternalReset();

    virtual BOOL            CalcIsModified() const;

    virtual DWORD           CalcCharacterStringSize();

    virtual BOOL            CopyValue(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL            InternalParseLine(
        IN  OUT         CHAR    *&Line
        );

    virtual BOOL GetField(
            OUT     SDP_FIELD   *&Field,
            OUT     BOOL        &AddToArray
        );
};


inline SDP_OPTIONAL_BSTRING  &
SDP_MEDIA::GetName(
    )
{
    return m_Name;
}


inline SDP_REQD_BSTRING_LINE &
SDP_MEDIA::GetTitle(
    )
{
    return m_Title;
}


inline SDP_USHORT   &
SDP_MEDIA::GetStartPort(
    )
{
    return m_StartPort;
}


inline SDP_USHORT   &
SDP_MEDIA::GetNumPorts(
    )
{
    return m_NumPorts;
}


inline SDP_OPTIONAL_BSTRING  &
SDP_MEDIA::GetProtocol(
    )
{
    return m_TransportProtocol;
}


inline SDP_FORMAT_CODE_LIST    &
SDP_MEDIA::GetFormatCodeList(
    )
{
    return m_FormatCodeList;
}


inline SDP_CONNECTION   &
SDP_MEDIA::GetConnection(
    )
{
    return m_Connection;
}


inline SDP_BANDWIDTH    &
SDP_MEDIA::GetBandwidth(
    )
{
    return m_Bandwidth;
}


inline SDP_ENCRYPTION_KEY   &
SDP_MEDIA::GetEncryptionKey(
    )
{
    return m_EncryptionKey;
}


inline SDP_ATTRIBUTE_LIST &
SDP_MEDIA::GetAttributeList(
    )
{
    return m_AttributeList;
}



class _DllDecl SDP_MEDIA_LIST : public SDP_VALUE_LIST
{
public:

    inline SDP_MEDIA_LIST();

    inline void SetCharacterSet(
        IN  SDP_CHARACTER_SET CharacterSet
        );

protected:

    SDP_CHARACTER_SET   m_CharacterSet;

    virtual SDP_VALUE   *CreateElement();
};



inline
SDP_MEDIA_LIST::SDP_MEDIA_LIST(
    )
    : m_CharacterSet(CS_ASCII)  
{
}


inline void 
SDP_MEDIA_LIST::SetCharacterSet(
    IN  SDP_CHARACTER_SET CharacterSet
    )
{
    m_CharacterSet = CharacterSet;
}


#endif // __SDP_MEDIA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpenc.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpenc.h
    
Abstract:


Author:

*/

#ifndef __SDP_ENCRYPTION_KEY__
#define __SDP_ENCRYPTION_KEY__

#include "sdpcommo.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"


class _DllDecl SDP_ENCRYPTION_KEY : public SDP_VALUE
{
public:

    SDP_ENCRYPTION_KEY();

    inline SDP_OPTIONAL_BSTRING  &GetKeyType();

    inline SDP_OPTIONAL_BSTRING  &GetKeyData();

    HRESULT SetKey(
        IN      BSTR    KeyType,
        IN      BSTR    *KeyData
        );

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );
	
	virtual void InternalReset();

private:

    SDP_OPTIONAL_BSTRING m_KeyType;
    SDP_OPTIONAL_BSTRING m_KeyData;
};



inline SDP_OPTIONAL_BSTRING &
SDP_ENCRYPTION_KEY::GetKeyType(
    )
{
    return m_KeyType;
}


inline SDP_OPTIONAL_BSTRING &
SDP_ENCRYPTION_KEY::GetKeyData(
    )
{
    return m_KeyData;
}


#endif // __SDP_ENCRYPTION_KEY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpsadj.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_ADJUSTMENT_SAFEARRAY__
#define __SDP_ADJUSTMENT_SAFEARRAY__


#include "sdpcommo.h"

#include "sdpstp.h"
#include "sdpsuit.h"
#include "sdpfld.h"


class _DllDecl SDP_ULONG_SAFEARRAY : public SDP_UITYPE_SAFEARRAY<ULONG, SDP_ULONG, SDP_ULONG_LIST>
{
public:

    inline SDP_ULONG_SAFEARRAY(
        IN      SDP_ULONG_LIST  &SdpUlongList
        );
};



inline 
SDP_ULONG_SAFEARRAY::SDP_ULONG_SAFEARRAY(
    IN      SDP_ULONG_LIST  &SdpUlongList
    )
    : SDP_UITYPE_SAFEARRAY<ULONG, SDP_ULONG, SDP_ULONG_LIST>(SdpUlongList)
{
    m_VarType[0] = VT_UI4;
}



class _DllDecl SDP_ADJUSTMENT_SAFEARRAY : 
    protected SDP_TIME_PERIOD_SAFEARRAY,
    protected SDP_ULONG_SAFEARRAY
{
public:

    SDP_ADJUSTMENT_SAFEARRAY(
        IN      SDP_ADJUSTMENT  &SdpAdjustment
        );

    HRESULT GetSafeArray(
            OUT VARIANT   *AdjustmentTimesVariant,
            OUT VARIANT   *IsCompactVariant,
            OUT VARIANT   *UnitVariant,
            OUT VARIANT   *CompactValueVariant,
            OUT VARIANT   *PeriodValueVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT   &AdjustmentTimesVariant,
        IN      VARIANT   &IsCompactVariant,
        IN      VARIANT   &UnitVariant,
        IN      VARIANT   &CompactValueVariant,
        IN      VARIANT   &PeriodValueArray
        );

protected:

    VARTYPE         m_VarType[5];

    virtual BOOL GetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    **Element,
            OUT HRESULT &HResult
        );

    virtual BOOL SetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    ***Element,
            OUT HRESULT &HResult
        );

    virtual void RemoveExcessElements(
        IN      ULONG   StartIndex
        );
};



inline HRESULT 
SDP_ADJUSTMENT_SAFEARRAY::SetSafeArray(
	IN      VARIANT   &AdjustmentTimesVariant,
	IN      VARIANT   &IsCompactVariant,
	IN      VARIANT   &UnitVariant,
	IN      VARIANT   &CompactValueVariant,
	IN      VARIANT   &PeriodValueVariant
    )
{
    VARIANT   *VariantArray[] = {
            &IsCompactVariant, &UnitVariant, 
            &CompactValueVariant, &PeriodValueVariant
            };

    return SDP_ULONG_SAFEARRAY::SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


#endif // __SDP_ADJUSTMENT_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdporigi.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_ORIGIN__
#define __SDP_ORIGIN__

#include "sdpcommo.h"
#include "sdpgen.h"
#include "sdpfld.h"
#include "sdpval.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"


class _DllDecl SDP_ORIGIN : public SDP_VALUE
{
public:

    SDP_ORIGIN();

    inline SDP_BSTRING              &GetUserName();

    inline SDP_ULONG                &GetSessionId();

    inline SDP_ULONG                &GetSessionVersion();

    inline SDP_LIMITED_CHAR_STRING  &GetNetworkType();

    inline SDP_LIMITED_CHAR_STRING  &GetAddressType();

    inline SDP_BSTRING              &GetAddress();

protected:

    virtual BOOL GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    );

	virtual void InternalReset();

private:

    SDP_BSTRING             m_UserName;
    SDP_ULONG               m_SessionId;
    SDP_ULONG               m_SessionVersion;
    SDP_LIMITED_CHAR_STRING m_NetworkType;
    SDP_LIMITED_CHAR_STRING m_AddressType;
    SDP_BSTRING             m_Address;   
};





inline SDP_BSTRING  &
SDP_ORIGIN::GetUserName(
    )
{
    return m_UserName;
}

inline SDP_ULONG    &
SDP_ORIGIN::GetSessionId(
    )
{
    return m_SessionId;
}

inline SDP_ULONG    &
SDP_ORIGIN::GetSessionVersion(
    )
{
    return m_SessionVersion;
}

inline SDP_LIMITED_CHAR_STRING &
SDP_ORIGIN::GetNetworkType(
    )
{
    return m_NetworkType;
}


inline SDP_LIMITED_CHAR_STRING &
SDP_ORIGIN::GetAddressType(
    )
{
    return m_AddressType;
}


inline SDP_BSTRING      &
SDP_ORIGIN::GetAddress(
    )
{
    return m_Address;
}




#endif // __SDP_ORIGIN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpgen.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_GENERAL__
#define __SDP_GENERAL__

#include "sdpcommo.h"
#include <stdlib.h>     // for strtoul()
#include <ctype.h>      // for isdigit()

#include "sdpdef.h"


template <class T>
class _DllDecl SDP_ARRAY : public CArray<T, T>
{
public:

    virtual void Reset()
    {
        RemoveAll();
        return;
    }
};


class _DllDecl BSTR_ARRAY : public SDP_ARRAY<BSTR>
{
};


class _DllDecl CHAR_ARRAY : public SDP_ARRAY<CHAR>
{
};


class _DllDecl BYTE_ARRAY : public SDP_ARRAY<BYTE>
{
};


class _DllDecl LONG_ARRAY : public SDP_ARRAY<LONG>
{
};


class _DllDecl ULONG_ARRAY : public SDP_ARRAY<ULONG>
{
};



template <class T_PTR>
class _DllDecl SDP_POINTER_ARRAY : public SDP_ARRAY<T_PTR>
{
public:

    inline SDP_POINTER_ARRAY();

    inline void ClearDestroyMembersFlag(
        );

    virtual void Reset();

    virtual ~SDP_POINTER_ARRAY()
    {
        Reset();
    }

protected:

    BOOL    m_DestroyMembers;
};

template <class T_PTR>
inline
SDP_POINTER_ARRAY<T_PTR>::SDP_POINTER_ARRAY(
	)
    : m_DestroyMembers(TRUE)
{
}


template <class T_PTR>
inline void
SDP_POINTER_ARRAY<T_PTR>::ClearDestroyMembersFlag(
    )
{
    m_DestroyMembers = FALSE;
}


template <class T_PTR>
/* virtual */ void
SDP_POINTER_ARRAY<T_PTR>::Reset(
	)
{
    // if members must be destroyed on destruction, delete each of them
    if ( m_DestroyMembers )
    {
	    int Size = (int) GetSize();

	    if ( 0 < Size )
	    {
		    for ( int i=0; i < Size; i++ )
		    {
			    T_PTR Member = GetAt(i);

			    ASSERT(NULL != Member);
			    if ( NULL == Member )
			    {
				    SetLastError(SDP_INTERNAL_ERROR);
				    return;
			    }

			    delete Member;
		    }
	    }
    }

	SDP_ARRAY<T_PTR>::Reset();
	return;
}


class _DllDecl LINE_TERMINATOR
{
public:

    inline LINE_TERMINATOR(
        IN CHAR *Start,
        IN const CHAR Replacement
        );

    inline IsLegal() const;

    inline DWORD GetLength() const;

    inline ~LINE_TERMINATOR();

private:

    CHAR    *m_Start;
    DWORD   m_Length;

    CHAR    m_Replacement;
};



inline
LINE_TERMINATOR::LINE_TERMINATOR(
    IN          CHAR    *Start,
    IN  const   CHAR    Replacement
    )
    : m_Start(Start),
      m_Replacement(Replacement)
{
    if ( NULL != Start )
    {
        m_Length = strlen(m_Start);
    }
}



inline
LINE_TERMINATOR::IsLegal(
    ) const
{
    return (NULL == m_Start)? FALSE : TRUE;
}



inline DWORD
LINE_TERMINATOR::GetLength(
    ) const
{
    return m_Length;
}


inline
LINE_TERMINATOR::~LINE_TERMINATOR(
    )
{
    if ( IsLegal() )
    {
        m_Start[m_Length] = m_Replacement;
    }
}


// Isolates tokens by searching for one of the separators
// and returns the first separator thats found
CHAR    *
GetToken(
    IN              CHAR    *String,
    IN              BYTE    NumSeparators,
    IN      const   CHAR    *SeparatorChars,
        OUT         CHAR    &Separator
    );


#endif // __SDP_GENERAL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpsadt.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_ADDRESS_TEXT_SAFEARRAY__
#define __SDP_ADDRESS_TEXT_SAFEARRAY__

#include "sdpcommo.h"

#include "sdpsarr.h"


class _DllDecl SDP_ADDRESS_TEXT_SAFEARRAY : 
    protected SDP_SAFEARRAY_WRAP_EX<SDP_ADDRESS_TEXT, SDP_ADDRESS_TEXT_LIST>
{
public:

    inline SDP_ADDRESS_TEXT_SAFEARRAY(
        IN      SDP_ADDRESS_TEXT_LIST    &SdpAddressTextList
        );

    HRESULT GetSafeArray(
            OUT VARIANT	*AddressVariant,
            OUT VARIANT	*TextVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT	&AddressVariant,
        IN      VARIANT	&TextVariant
        );

protected:

    VARTYPE m_VarType[2];

    virtual BOOL Get(
        IN      SDP_ADDRESS_TEXT    &ListMember,
        IN      ULONG               NumEntries,
        IN      void                **Element,
            OUT HRESULT             &HResult
        );

    virtual BOOL Set(
        IN      SDP_ADDRESS_TEXT    &ListMember,
        IN      ULONG               NumEntries,
        IN      void                ***Element,
            OUT HRESULT             &HResult
        );
};



inline 
SDP_ADDRESS_TEXT_SAFEARRAY::SDP_ADDRESS_TEXT_SAFEARRAY(
        IN      SDP_ADDRESS_TEXT_LIST    &SdpAddressTextList
        )
    : SDP_SAFEARRAY_WRAP_EX<SDP_ADDRESS_TEXT, SDP_ADDRESS_TEXT_LIST>(SdpAddressTextList)
{
    m_VarType[0] = VT_BSTR;
    m_VarType[1] = VT_BSTR;
}




inline HRESULT 
SDP_ADDRESS_TEXT_SAFEARRAY::SetSafeArray(
    IN      VARIANT   &AddressVariant,
    IN      VARIANT   &TextVariant
    )
{
    VARIANT   *VariantArray[] = {&AddressVariant, &TextVariant};

    return SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


#endif   // __SDP_ADDRESS_TEXT_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpsatt.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_ATTRIBUTE_SAFEARRAY__
#define __SDP_ATTRIBUTE_SAFEARRAY__


#include "sdpcommo.h"

#include "sdpsarr.h"

class _DllDecl SDP_ATTRIBUTE_SAFEARRAY : 
    protected SDP_SAFEARRAY_WRAP_EX<SDP_CHAR_STRING_LINE, SDP_ATTRIBUTE_LIST>
{
public:

    inline SDP_ATTRIBUTE_SAFEARRAY(
        IN      SDP_ATTRIBUTE_LIST    &SdpAttributeList
        );

    HRESULT GetSafeArray(
            OUT VARIANT	*Variant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT	&Variant
        );

protected:

    VARTYPE m_VarType[1];

    virtual BOOL Get(
        IN      SDP_CHAR_STRING_LINE    &ListMember,
        IN      ULONG                   NumEntries,
        IN      void                    **Element,
            OUT HRESULT &HResult
        );

    virtual BOOL Set(
        IN      SDP_CHAR_STRING_LINE    &ListMember,
        IN      ULONG                   NumEntries,
        IN      void                    ***Element,
            OUT HRESULT                 &HResult
        );
};



inline 
SDP_ATTRIBUTE_SAFEARRAY::SDP_ATTRIBUTE_SAFEARRAY(
    IN      SDP_ATTRIBUTE_LIST    &SdpAttributeList
    )
    : SDP_SAFEARRAY_WRAP_EX<SDP_CHAR_STRING_LINE, SDP_ATTRIBUTE_LIST>(SdpAttributeList)
{
    m_VarType[0] = VT_BSTR;
}


inline HRESULT 
SDP_ATTRIBUTE_SAFEARRAY::SetSafeArray(
    IN      VARIANT   &Variant
    )
{
	VARIANT *VariantArray = &Variant;
    return SDP_SAFEARRAY_WRAP::SetSafeArrays(1, m_VarType, &VariantArray);
}

#endif  //  __SDP_ATTRIBUTE_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpstp.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_TIME_PERIOD_SAFEARRAY__
#define __SDP_TIME_PERIOD_SAFEARRAY__


#include "sdpcommo.h"

#include "sdpsarr.h"


class _DllDecl SDP_TIME_PERIOD_SAFEARRAY : 
    protected SDP_SAFEARRAY_WRAP_EX<SDP_TIME_PERIOD, SDP_TIME_PERIOD_LIST>

{
public:

    inline SDP_TIME_PERIOD_SAFEARRAY(
        IN      SDP_TIME_PERIOD_LIST    &SdpTimePeriodList
        );

    HRESULT GetSafeArray(
            OUT VARIANT	*IsCompactVariant,
            OUT VARIANT	*UnitVariant,
            OUT VARIANT	*CompactValueVariant,
            OUT VARIANT	*PeriodValueVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT	&IsCompactVariant,
        IN      VARIANT	&UnitVariant,
        IN      VARIANT	&CompactValueVariant,
        IN      VARIANT	&PeriodValueVariant
        );

protected:

    VARTYPE         m_VarType[4];
    VARIANT_BOOL    m_IsCompact;
    CHAR            m_Unit;
    LONG            m_CompactValue;
    LONG            m_PeriodValue;

    virtual BOOL Get(
        IN      SDP_TIME_PERIOD &ListMember,
        IN      ULONG           NumEntries,
        IN      void            **Element,
            OUT HRESULT         &HResult
        );

    virtual BOOL Set(
        IN      SDP_TIME_PERIOD &ListMember,
        IN      ULONG           NumEntries,
        IN      void            ***Element,
            OUT HRESULT         &HResult
        );
};



inline 
SDP_TIME_PERIOD_SAFEARRAY::SDP_TIME_PERIOD_SAFEARRAY(
        IN      SDP_TIME_PERIOD_LIST    &SdpTimePeriodList
        )
        : SDP_SAFEARRAY_WRAP_EX<SDP_TIME_PERIOD, SDP_TIME_PERIOD_LIST>(SdpTimePeriodList)
{
    m_VarType[0] = VT_BOOL;
    m_VarType[1] = VT_I1;
    m_VarType[2] = VT_I4;
    m_VarType[3] = VT_I4;
}




inline HRESULT 
SDP_TIME_PERIOD_SAFEARRAY::SetSafeArray(
	IN      VARIANT	&IsCompactVariant,
	IN      VARIANT	&UnitVariant,
	IN      VARIANT	&CompactValueVariant,
	IN      VARIANT	&PeriodValueVariant
    )
{
    VARIANT   *VariantArray[] = {
            &IsCompactVariant, &UnitVariant, 
            &CompactValueVariant, &PeriodValueVariant
            };

    return SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


#endif   // __SDP_TIME_PERIOD_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpsobst.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_OPT_BSTRING_SAFEARRAY__
#define __SDP_OPT_BSTRING_SAFEARRAY__

#include "sdpcommo.h"

#include "sdpsarr.h"


class SDP_OPT_BSTRING_LIST : public SDP_FIELD_LIST
{
public:
    
    virtual SDP_FIELD   *CreateElement();
};


class _DllDecl SDP_OPT_BSTRING_SAFEARRAY : 
    protected SDP_SAFEARRAY_WRAP_EX<SDP_OPTIONAL_BSTRING, SDP_OPT_BSTRING_LIST>
{
public:

    inline SDP_OPT_BSTRING_SAFEARRAY(
        IN      SDP_OPT_BSTRING_LIST    &SdpOptBstringList
        );

    HRESULT GetSafeArray(
            OUT VARIANT	*OptBstringVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT	&OptBstringVariant
        );

protected:

    VARTYPE m_VarType[1];

    virtual BOOL Get(
        IN      SDP_OPTIONAL_BSTRING    &ListMember,
        IN      ULONG                   NumEntries,
        IN      void                    **Element,
            OUT HRESULT                 &HResult
        );

    virtual BOOL Set(
        IN      SDP_OPTIONAL_BSTRING    &ListMember,
        IN      ULONG                   NumEntries,
        IN      void                    ***Element,
            OUT HRESULT                 &HResult
        );
};



inline 
SDP_OPT_BSTRING_SAFEARRAY::SDP_OPT_BSTRING_SAFEARRAY(
        IN      SDP_OPT_BSTRING_LIST    &SdpOptBstringList
        )
    : SDP_SAFEARRAY_WRAP_EX<SDP_OPTIONAL_BSTRING, SDP_OPT_BSTRING_LIST>(SdpOptBstringList)
{
    m_VarType[0] = VT_BSTR;
}




inline HRESULT 
SDP_OPT_BSTRING_SAFEARRAY::SetSafeArray(
    IN      VARIANT   &OptBstringVariant
    )
{
    VARIANT   *VariantArray[] = {&OptBstringVariant};

    return SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


#endif   // __SDP_OPT_BSTRING_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpsarr.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_SAFEARRAY__
#define __SDP_SAFEARRAY__

#include <afxdisp.h>

#include "sdpcommo.h"
#include "sdpdef.h"


inline BOOL
ValidateSafeArray(
    IN          VARTYPE VarType,
    IN          VARIANT *Variant
    )
{
    ASSERT(NULL != Variant);

    // check if its a safearray and the type of elements in the safe array is whats expected
    if ( !(V_VT(Variant) & (VT_ARRAY | VarType)) )
    {
        return FALSE;
    }

    // check number of dimensions, cannot handle more than one dimension
    if ( V_ARRAY(Variant)->cDims != 1 )
    {
        return FALSE;
    }

    return TRUE;
}



class _DllDecl SDP_SAFEARRAY : public COleSafeArray
{
public:

    inline  SDP_SAFEARRAY();

    BOOL CreateAndAttach(
        IN      ULONG       MinSize,
        IN      VARTYPE     VarType,
        IN  OUT VARIANT     &Variant,
            OUT HRESULT     &HResult
        );

    inline  void Attach(
        IN  VARIANT   &Variant
        );

    inline  void Detach();

    inline  BOOL Free(
            OUT HRESULT     &HResult
        );

    inline  BOOL IsAllocated() const;

    inline  ~SDP_SAFEARRAY();

protected:

    VARIANT   *m_Variant;
};


inline 
SDP_SAFEARRAY::SDP_SAFEARRAY(
    )
    : m_Variant(NULL)
{
}


inline void 
SDP_SAFEARRAY::Attach(
    IN  VARIANT &Variant
    )
{
    m_Variant = &Variant;

    // because of the way attach is implemented, the variant vt type field is set to VT_EMPTY
    // and the ptr is set to null
    // if the instance is destroyed without calling free, the vt type and the safe array are assigned
    // back to the member variant
    COleSafeArray::Attach(Variant);
}



inline void 
SDP_SAFEARRAY::Detach(
    )
{
    ASSERT(NULL != m_Variant);

    if ( NULL != m_Variant )
    {
        *m_Variant = COleSafeArray::Detach();
        m_Variant = NULL;
    }
}



inline  BOOL 
SDP_SAFEARRAY::Free(
        OUT HRESULT     &HResult
    )
{
    if (NULL == m_Variant)
    {
        HResult = S_OK;
        return TRUE;
    }
    
    // destroy the underlying safearray
    Clear();

    // set the member variant ptr to null so that we are no longer attached to it
    m_Variant = NULL;

    return TRUE;
}


inline BOOL 
SDP_SAFEARRAY::IsAllocated(
    ) const
{
    return (NULL != m_Variant) ? TRUE : FALSE;
}



inline 
SDP_SAFEARRAY::~SDP_SAFEARRAY(
    )
{
    if ( NULL != m_Variant )
    {
        *m_Variant = COleSafeArray::Detach();
    }
}



template <class T>
class DYNAMIC_ARRAY
{
public:

    inline DYNAMIC_ARRAY(
        IN      ULONG NumElements
        );

    inline T &operator[](
        IN      ULONG Index
        );

    inline T *operator()();

    virtual ~DYNAMIC_ARRAY();

protected:

    T   *m_Array;
};


template <class T>
inline 
DYNAMIC_ARRAY<T>::DYNAMIC_ARRAY(
    IN      ULONG NumElements
    )
{
    ASSERT(0 != NumElements);
    m_Array = new T[NumElements];
}


template <class T>
inline T &
DYNAMIC_ARRAY<T>::operator[](
    IN      ULONG Index
    )
{
    return m_Array[Index];
}


template <class T>
inline T *
DYNAMIC_ARRAY<T>::operator ()(
    )
{
    return m_Array;
}


template <class T>
DYNAMIC_ARRAY<T>::~DYNAMIC_ARRAY(
    )
{
    ASSERT( NULL != m_Array );
    
    delete[] m_Array;
}


template <class T>
class DYNAMIC_POINTER_ARRAY : public DYNAMIC_ARRAY<T *>
{
public:

    inline DYNAMIC_POINTER_ARRAY(
        IN      ULONG NumElements
        );

    inline T &operator[](
        IN      ULONG Index
        );

    virtual ~DYNAMIC_POINTER_ARRAY();

protected:

    ULONG   m_NumElements;

    // should not be called
    inline T *operator()()
    {
        ASSERT(FALSE);
        return NULL;
    }
};


template <class T>
inline 
DYNAMIC_POINTER_ARRAY<T>::DYNAMIC_POINTER_ARRAY(
    IN      ULONG NumElements
    )
    : DYNAMIC_ARRAY<T *>(NumElements),
      m_NumElements(NumElements)
{
    for (UINT i=0; i < NumElements; i++)
    {
        m_Array[i] = new T();
    }
}


template <class T>
inline T &
DYNAMIC_POINTER_ARRAY<T>::operator[](
    IN      ULONG Index
    )
{
    return *m_Array[Index];
}



template <class T>
DYNAMIC_POINTER_ARRAY<T>::~DYNAMIC_POINTER_ARRAY(
    )
{
    ASSERT( NULL != m_Array );
    
    for (UINT i=0; i < m_NumElements; i++)
    {
        delete m_Array[i];
    }
}



class _DllDecl SDP_SAFEARRAY_WRAP
{
public:

    HRESULT GetSafeArrays(
        IN      const   ULONG       NumElements,                                        
        IN      const   ULONG       NumSafeArrays,
        IN              VARTYPE     VarType[],
            OUT         VARIANT		*Variant[]
        );

    HRESULT SetSafeArrays(
        IN      const   ULONG       NumSafeArrays,
        IN              VARTYPE     VarType[],
        IN              VARIANT		*Variant[]
        );

protected:

    virtual BOOL GetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    **Element,
            OUT HRESULT &HResult
        ) = 0;

    virtual BOOL SetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    ***Element,
            OUT HRESULT &HResult
        ) = 0;

    virtual void RemoveExcessElements(
        IN      ULONG   StartIndex
        ) = 0;
};


template <class T, class TLIST>
class _DllDecl SDP_SAFEARRAY_WRAP_EX : public SDP_SAFEARRAY_WRAP
{
public:

    inline SDP_SAFEARRAY_WRAP_EX(
        IN      TLIST    &TList
        );

protected:

    TLIST   &m_TList;


    T   *GetListMember(
        IN      ULONG   Index,
            OUT HRESULT &HResult
    );


    virtual BOOL Get(
        IN      T       &ListMember,
        IN      ULONG   NumEntries,
        IN      void    **Element,
            OUT HRESULT &HResult
        ) = 0;

    virtual BOOL GetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    **Element,
            OUT HRESULT &HResult
        );


    T   *CreateListMemberIfRequired(
        IN      ULONG   Index,
            OUT HRESULT &HResult
    );


    virtual BOOL Set(
        IN      T       &ListMember,
        IN      ULONG   NumEntries,
        IN      void    ***Element,
            OUT HRESULT &HResult
        ) = 0;

    virtual BOOL SetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    ***Element,
            OUT HRESULT &HResult
        );

    virtual void RemoveExcessElements(
        IN      ULONG   StartIndex
        );
};


template <class T, class TLIST>
inline 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::SDP_SAFEARRAY_WRAP_EX(
        IN      TLIST    &TList
        )
        : m_TList(TList)
{}


template <class T, class TLIST>
T   * 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::GetListMember(
    IN      ULONG   Index,
        OUT HRESULT &HResult
    )
{
    T   *ToReturn = dynamic_cast<T *>(m_TList[Index]);

    if ( NULL == ToReturn )
    {
        HResult = HRESULT_FROM_ERROR_CODE(SDP_INTERNAL_ERROR);
    }

    return ToReturn;
}



template <class T, class TLIST>
BOOL 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::GetElement(
    IN      ULONG   Index,
    IN      ULONG   NumEntries,
    IN      void    **Element,
        OUT HRESULT &HResult
    )
{
    T   *ListMember = GetListMember(Index, HResult);
    if ( NULL == ListMember )
    {
        return FALSE;
    }

    ASSERT(ListMember->IsValid());
    if ( !Get(*ListMember, NumEntries, Element, HResult) )
    {
        return FALSE;
    }

    return TRUE;
}



template <class T, class TLIST>
T   * 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::CreateListMemberIfRequired(
    IN      ULONG   Index,
        OUT HRESULT &HResult
    )
{
    // assert that the index is atmost 1 more than the size of the list
    ASSERT(0 <= m_TList.GetSize());
    ASSERT(Index <= (ULONG)(m_TList.GetSize() + 1));

    if ( Index >= (ULONG)m_TList.GetSize() )
    {

        T   *NewElement = dynamic_cast<T *>(m_TList.CreateElement());
       
        if ( NULL == NewElement )
        {
            HResult = HRESULT_FROM_ERROR_CODE(SDP_INTERNAL_ERROR);
        }
        return NewElement;
    }
    else
    {
        return GetListMember(Index, HResult);
    }

    // should never reach here
    ASSERT(FALSE);
}

template <class T, class TLIST>
BOOL 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::SetElement(
    IN      ULONG   Index,
    IN      ULONG   NumEntries,
    IN      void    ***Element,
        OUT HRESULT &HResult
    )
{
    T   *ListMember = CreateListMemberIfRequired(Index, HResult);
    if ( NULL == ListMember )
    {
        return FALSE;
    }

    if ( !Set(*ListMember, NumEntries, Element, HResult) )
    {
        return FALSE;
    }
    
    ASSERT(ListMember->IsValid());

    // if its a newly created instance, make it valid and add it to the list at the appropriate
    // index
    if ( Index >= (ULONG)m_TList.GetSize() )
    {
        try
        {
            m_TList.SetAtGrow(Index, ListMember);
        }
        catch(...)
        {
            delete ListMember;

            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    return TRUE;
}


template <class T, class TLIST>
void 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::RemoveExcessElements(
    IN      ULONG   StartIndex
    )
{
    ASSERT(0 <= m_TList.GetSize());

    // for each list element that is in excess of the safearray members,
    // delete and remove them
    for ( ULONG i = StartIndex; i < (ULONG)m_TList.GetSize(); i++ )
    {
        delete m_TList[i];
        m_TList.RemoveAt(i);
        i++;
    }
}


#endif   // __SDP_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpsuit.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_UNSIGNED_INTEGRAL_TYPE_SAFEARRAY__
#define __SDP_UNSIGNED_INTEGRAL_TYPE_SAFEARRAY__


#include "sdpcommo.h"

template <class BASE, class T, class TLIST>
class _DllDecl SDP_UITYPE_SAFEARRAY :
    protected SDP_SAFEARRAY_WRAP_EX<T, TLIST>
{
public:

    inline SDP_UITYPE_SAFEARRAY(
        IN      TLIST    &SdpUitypeList
        );

    inline HRESULT GetSafeArray(
            OUT VARIANT   *UitypeVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT   &UitypeVariant
        );

protected:

    VARTYPE m_VarType[1];
    BASE    m_BaseValue;

    virtual BOOL Get(
        IN      T           &ListMember,
        IN      ULONG       NumEntries,
        IN      void        **Element,
            OUT HRESULT     &HResult
        );

    virtual BOOL Set(
        IN      T           &ListMember,
        IN      ULONG       NumEntries,
        IN      void        ***Element,
            OUT HRESULT     &HResult
        );
};


// the vartype is initialized in the deriving class
template <class BASE, class T, class TLIST>
inline
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::SDP_UITYPE_SAFEARRAY(
    IN      TLIST    &SdpUitypeList
    )
    : SDP_SAFEARRAY_WRAP_EX<T, TLIST>(SdpUitypeList)
{}



template <class BASE, class T, class TLIST>
inline HRESULT
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::GetSafeArray(
		OUT VARIANT   *UitypeVariant
    )
{
    VARIANT   *VariantArray[] = {UitypeVariant};

    return SDP_SAFEARRAY_WRAP::GetSafeArrays(
        m_TList.GetSize(), 
        sizeof(VariantArray)/sizeof(VARIANT	*),
        m_VarType,
        VariantArray
        );
}



template <class BASE, class T, class TLIST>
inline HRESULT
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::SetSafeArray(
    IN      VARIANT   &UitypeVariant
    )
{
    VARIANT   *VariantArray[] = {&UitypeVariant};

    return SDP_SAFEARRAY_WRAP::SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT	*), 
        m_VarType,
        VariantArray
        );
}



template <class BASE, class T, class TLIST>
BOOL
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::Get(
    IN      T           &ListMember,
    IN      ULONG       NumEntries,
    IN      void        **Element,
        OUT HRESULT     &HResult
    )
{
    ASSERT(1 == NumEntries);

    m_BaseValue = ListMember.GetValue();
    Element[0] = &m_BaseValue;

    return TRUE;
}



template <class BASE, class T, class TLIST>
BOOL
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::Set(
    IN      T           &ListMember,
    IN      ULONG       NumEntries,
    IN      void        ***Element,
        OUT HRESULT     &HResult
    )
{
    ASSERT(1 == NumEntries);

    ASSERT(NULL != Element[0]);

    ListMember.SetValueAndFlag(*((BASE *)Element[0]));

    return TRUE;
}



#endif // __SDP_UNSIGNED_INTEGRAL_TYPE_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdptime.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_TIME__
#define __SDP_TIME__

#include "sdpcommo.h"
#include "sdpgen.h"
#include "sdpfld.h"
#include "sdpval.h"

#include "sdpstp.h"
#include "sdpsadj.h"


// no Reset method to set the member values to 0 again (as its not really required and it saves 
// one call per instance)
class _DllDecl SDP_TIME_PERIOD : public SDP_SINGLE_FIELD
{
public:

    inline          SDP_TIME_PERIOD();

    inline BOOL     IsCompact() const;

    inline void     IsCompact(
        IN BOOL IsCompactFlag
        );

    inline CHAR     GetUnit() const;

    inline void     SetUnit(
        IN CHAR Unit
        );

    inline LONG     GetCompactValue() const;

    inline void     SetCompactValue(
        IN LONG CompactValue
        );

    inline LONG     GetPeriodValue() const;

    inline void     SetPeriodValue(
        IN LONG PeriodValue
        );

    inline void     Get(
            OUT     BOOL    &IsCompactFlag,
            OUT     CHAR    &Unit,
            OUT     LONG    &CompactValue,
            OUT     LONG    &PeriodValue
        ) const;

    inline void     Set(
        IN          BOOL    IsCompactFlag,
        IN          CHAR    Unit,
        IN          LONG    CompactValue,
        IN          LONG    PeriodValue
        );

protected:

    BOOL    m_IsCompact;
    CHAR    m_Unit;
    LONG    m_CompactValue;
    LONG    m_PeriodValue;

    CHAR    m_SdpTimePeriodBuffer[25];

    virtual BOOL    InternalParseToken(
        IN      CHAR        *Token
        );
    
    virtual BOOL    PrintData(
            OUT ostrstream  &OutputStream
        );
};


inline      
SDP_TIME_PERIOD::SDP_TIME_PERIOD(
    )
    : SDP_SINGLE_FIELD(sizeof(m_SdpTimePeriodBuffer), m_SdpTimePeriodBuffer)
{
}


inline BOOL 
SDP_TIME_PERIOD::IsCompact(
    ) const
{
    return m_IsCompact;
}


inline void     
SDP_TIME_PERIOD::IsCompact(
    IN BOOL IsCompactFlag
    )
{
    m_IsCompact = IsCompactFlag;
}

   
inline CHAR 
SDP_TIME_PERIOD::GetUnit(
    ) const
{
    return m_Unit;
}



inline void     
SDP_TIME_PERIOD::SetUnit(
    IN CHAR Unit
    )
{
    m_Unit = Unit;
}

    
inline LONG 
SDP_TIME_PERIOD::GetCompactValue(
    ) const
{
    return m_CompactValue;
}



inline void     
SDP_TIME_PERIOD::SetCompactValue(
    IN LONG CompactValue
    )
{
    m_CompactValue = CompactValue;
}

    
inline LONG 
SDP_TIME_PERIOD::GetPeriodValue(
    ) const
{
    return m_PeriodValue;
}



inline void 
SDP_TIME_PERIOD::SetPeriodValue(
    IN LONG PeriodValue
    )
{
    m_PeriodValue = PeriodValue;
}


inline void     
SDP_TIME_PERIOD::Get(
        OUT     BOOL    &IsCompactFlag,
        OUT     CHAR    &Unit,
        OUT     LONG    &CompactValue,
        OUT     LONG    &PeriodValue
    ) const
{
    IsCompactFlag   = IsCompact();
    Unit            = GetUnit();
    CompactValue    = GetCompactValue();
    PeriodValue     = GetPeriodValue();
}


inline void     
SDP_TIME_PERIOD::Set(
    IN          BOOL    IsCompactFlag,
    IN          CHAR    Unit,
    IN          LONG    CompactValue,
    IN          LONG    PeriodValue
    )
{
    IsCompact(IsCompactFlag);
    SetUnit(Unit);
    SetCompactValue(CompactValue);
    SetPeriodValue(PeriodValue);

    IsValid(TRUE);
    IsModified(TRUE);
}



class _DllDecl SDP_TIME_PERIOD_LIST :
    public SDP_FIELD_LIST,
    public SDP_TIME_PERIOD_SAFEARRAY
{
public:

    inline  SDP_TIME_PERIOD_LIST();

    virtual SDP_FIELD   *CreateElement();
};



inline  
SDP_TIME_PERIOD_LIST::SDP_TIME_PERIOD_LIST(
    )
    : SDP_FIELD_LIST(CHAR_BLANK),
      SDP_TIME_PERIOD_SAFEARRAY(*this)
{
}


class _DllDecl SDP_REPEAT : public SDP_VALUE
{
public:

    SDP_REPEAT();

    inline SDP_TIME_PERIOD  &GetInterval();

    inline SDP_TIME_PERIOD  &GetDuration();

    inline SDP_TIME_PERIOD_LIST  &GetOffsets();

protected:

    SDP_TIME_PERIOD         m_Interval;
    SDP_TIME_PERIOD         m_Duration;
    SDP_TIME_PERIOD_LIST    m_Offsets;   // array of SDP_TIME_PERIOD

    virtual BOOL    InternalParseLine(
        IN  OUT         CHAR    *&Line
        );

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual void InternalReset();
};


inline SDP_TIME_PERIOD  &
SDP_REPEAT::GetInterval(
    )
{
    return m_Interval;
}


inline SDP_TIME_PERIOD  &
SDP_REPEAT::GetDuration(
    )
{
    return m_Duration;
}


inline SDP_TIME_PERIOD_LIST  &
SDP_REPEAT::GetOffsets(
    )
{
    return m_Offsets;
}




class _DllDecl SDP_REPEAT_LIST : public SDP_VALUE_LIST
{
protected:

    virtual SDP_VALUE   *CreateElement();
};




class _DllDecl SDP_ADJUSTMENT : 
    public SDP_VALUE,
    public SDP_ADJUSTMENT_SAFEARRAY
{
public:

    SDP_ADJUSTMENT();

    inline SDP_ULONG_LIST       &GetAdjustmentTimes();

    inline SDP_TIME_PERIOD_LIST &GetOffsets();

protected:

    SDP_ULONG_LIST          m_AdjustmentTimes;   // array of SDP_ULONG 
    SDP_TIME_PERIOD_LIST    m_Offsets;           // array of SDP_TIME_PERIOD 
    
    CHAR    m_PrintBuffer[400];
    DWORD   m_PrintLength;

    virtual void InternalReset();

    BOOL    PrintData(
        OUT     ostrstream  &OutputStream
    );

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual BOOL    CalcIsModified() const;

    virtual DWORD   CalcCharacterStringSize();

    virtual BOOL    CopyValue(
            OUT         ostrstream  &OutputStream
        );

    BOOL    PrintElement(
        IN      DWORD       Index,
            OUT ostrstream  &OutputStream
        );
  };



inline SDP_ULONG_LIST &
SDP_ADJUSTMENT::GetAdjustmentTimes(
    )
{
    return m_AdjustmentTimes;
}



inline SDP_TIME_PERIOD_LIST &
SDP_ADJUSTMENT::GetOffsets(
    )
{
    return m_Offsets;
}




class _DllDecl SDP_TIME : public SDP_VALUE
{
public:

    SDP_TIME();

    inline HRESULT          SetTimes(
        IN          ULONG   StartTime,
        IN          ULONG   StopTime
        );

    inline HRESULT          SetStartTime(
        IN          ULONG   StartTime
        );

    inline HRESULT          SetStopTime(
        IN          ULONG   StopTime
        );

    inline HRESULT          GetStartTime(
        OUT         ULONG   &StartTime
        );

    inline HRESULT          GetStopTime(
        OUT         ULONG   &StopTime
        );

    inline SDP_REPEAT_LIST  &GetRepeatList();

protected:

    virtual BOOL            CalcIsModified() const;

    virtual DWORD           CalcCharacterStringSize();

    virtual BOOL            CopyValue(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL            GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual void InternalReset();

private:

    SDP_ULONG       m_StartTime;
    SDP_ULONG       m_StopTime;
    SDP_REPEAT_LIST m_RepeatList;
 
    inline HRESULT FillArrays();
};



inline HRESULT          
SDP_TIME::FillArrays(
    )
{
    // check if the field and separator char arrays have been filled properly
    if ( (2 != m_FieldArray.GetSize()) || (2 != m_SeparatorCharArray.GetSize()) )
    {
        // clear the field and separator arrays
        m_FieldArray.RemoveAll();
        m_SeparatorCharArray.RemoveAll();

        try
        {
            // insert the fields and the separator characters into respective arrays
            m_FieldArray.SetAtGrow(0, &m_StartTime);
            m_SeparatorCharArray.SetAtGrow(0, CHAR_BLANK);

            m_FieldArray.SetAtGrow(1, &m_StopTime);
            m_SeparatorCharArray.SetAtGrow(1, CHAR_NEWLINE);
        }
        catch(...)
        {
            m_FieldArray.RemoveAll();
            m_SeparatorCharArray.RemoveAll();

            return E_OUTOFMEMORY;
        }
    }

    ASSERT(&m_StartTime == m_FieldArray[0]);
    ASSERT(&m_StopTime == m_FieldArray[1]);

    return S_OK;
}


inline HRESULT          
SDP_TIME::SetTimes(
    IN      ULONG   StartTime,
    IN      ULONG   StopTime
    )
{
    HRESULT hr;

    // validate the start/stop times (either stop time == 0 or starttime <= stop time)
    if ( !( (0 == StopTime) || (StartTime <= StopTime) ) )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    m_StartTime.SetValueAndFlag(StartTime);
    m_StopTime.SetValueAndFlag(StopTime);

    hr = FillArrays();

    return hr;
}


inline HRESULT             
SDP_TIME::SetStartTime(
    IN      ULONG   StartTime
    )
{
    HRESULT hr;

    hr = FillArrays();

    if ( FAILED(hr) )
    {
        return hr;
    }

    // set the value and the valid, modified flag
    m_StartTime.SetValueAndFlag(StartTime);

    // if the stop time is invalid, there is nothing to compare against
    if ( !m_StopTime.IsValid() )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // check if the new start time is <= the current stop time,
    // special case for an unbounded start/stop time (value 0)
    if ( !((0 == m_StopTime.GetValue())         ||
           (0 == StartTime)                     ||
           (StartTime <= m_StopTime.GetValue())) )
    {
        // unbound the stop time
        m_StopTime.SetValueAndFlag(0);
    }

    return S_OK;
}

inline HRESULT             
SDP_TIME::SetStopTime(
    IN      ULONG   StopTime
    )
{
    HRESULT hr;

    hr = FillArrays();

    if ( FAILED(hr) )
    {
        return hr;
    }

    // set the value and the valid, modified flag
    m_StopTime.SetValueAndFlag(StopTime);

    // if the start time is invalid, there is nothing to compare against
    if ( !m_StartTime.IsValid() )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // check if the current start time is <= the new stop time,
    // special case for an unbounded start/stop time (value 0)
    if ( !((0 == m_StartTime.GetValue())        || 
           (0 == StopTime)                      || 
           (m_StartTime.GetValue() <= StopTime)) )
    {
        // unbound the start time
        m_StartTime.SetValueAndFlag(0);
    }

    return S_OK;
}

inline  HRESULT         
SDP_TIME::GetStartTime(
        OUT ULONG   &StartTime
    )
{
    // check if the value being asked for is valid
    if ( !m_StartTime.IsValid() )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    StartTime = m_StartTime.GetValue();
    return S_OK;
}

inline  HRESULT         
SDP_TIME::GetStopTime(
        OUT ULONG   &StopTime
    )
{
    // check if the value being asked for is valid
    if ( !m_StopTime.IsValid() )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    StopTime = m_StopTime.GetValue();
    return S_OK;
}


inline SDP_REPEAT_LIST  &
SDP_TIME::GetRepeatList(
    )
{
    return m_RepeatList;
}






class _DllDecl SDP_TIME_LIST : public SDP_VALUE_LIST
{
public:

	virtual void Reset();

    inline SDP_ADJUSTMENT   &GetAdjustment();

    virtual BOOL        IsModified() const;

    virtual DWORD       GetCharacterStringSize();

    virtual BOOL        PrintValue(
            OUT         ostrstream  &OutputStream
        );

protected:

    SDP_ADJUSTMENT      m_Adjustment;

    virtual SDP_VALUE   *CreateElement();
};



inline SDP_ADJUSTMENT   &
SDP_TIME_LIST::GetAdjustment(
    )
{
    return m_Adjustment;
}


#endif // __SDP_TIME__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpval.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_VALUE__
#define __SDP_VALUE__

#include "sdpcommo.h"
#include "sdpfld.h"


// this value indicates that line transitions must start
// this has to be a value of 0 that is same as the first (start) state for
// all line transitions
const DWORD LINE_START  = 0;


// Usage - Modifications involving change in the layout of the value
// line must also modify the CArrays m_FieldArray and m_SeparatorCharArray if they are used
class _DllDecl SDP_VALUE
{
public:

    inline SDP_VALUE(
        IN              DWORD                   ErrorCode,
        IN      const   CHAR                    *TypePrefixString,
        IN      const   SDP_LINE_TRANSITION     *SdpLineTransition = NULL
        );

	// SDP_VALUE instances use an inline Reset method which calls a virtual InternalReset method.
	// this is possible because unlike the SDP_FIELD inheritance tree, SDP_VALUE and SDP_VALUE_LIST
	// do not share a common base class. This combined with the fact that the SDP_VALUE inheriance 
	// tree is quite shallow and has fewer instances (than SDP_FIELD) makes the scheme appropriate
	// it as it reduces the number of Reset related calls to 1 and the inline code is not repeated
	// to often.
	// For the SDP_FIELD inheritance tree, the appropriate Reset calling sequence is a series of
	// Reset calls starting with the top most virtual Reset body followed by the
	// base class Reset method (recursively). This is appropriate because, the number of calls
	// would not decrease if the InternalReset scheme is adopted (virtual Reset()) and that the
	// inheritance tree is much deeper
    inline void    Reset();

    virtual BOOL    IsValid() const;

    inline  BOOL    IsModified() const;

    inline  DWORD   GetCharacterStringSize();

    inline  BOOL    PrintValue(
            OUT     ostrstream  &OutputStream
        );

    inline  BOOL    ParseLine(
        IN  OUT     CHAR    *&Line
        );

    virtual ~SDP_VALUE()
    {}


protected:

    // the line state is the initial state for parsing the line and must be
    // assigned by the deriving value class
    DWORD                               m_LineState;

    // the error code, type prefix string and the transition info (table) must be 
    // specified by the deriving class to this class's constructor
    const   DWORD                       m_ErrorCode;
    const   CHAR                * const m_TypePrefixString;
    const   SDP_LINE_TRANSITION * const m_SdpLineTransition;

    CArray<SDP_FIELD *, SDP_FIELD *>    m_FieldArray;
    CArray<CHAR, CHAR>                  m_SeparatorCharArray;

    virtual void    InternalReset() = 0;

    virtual BOOL    CalcIsModified() const;

    virtual DWORD   CalcCharacterStringSize();

    virtual BOOL    CopyValue(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL    InternalParseLine(
        IN  OUT     CHAR    *&Line
        );

    BOOL GetFieldToParse(
        IN      const   CHAR                    SeparatorChar,
        IN      const   LINE_TRANSITION_INFO    *LineTransitionInfo,
            OUT         SDP_FIELD               *&Field,
            OUT         BOOL                    &Finished,
            OUT         BOOL                    &AddToArray
        );

    
    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        )
    {
        // we should not reach here 
        // this method must be overridden to be used
        // to be done
        ASSERT(FALSE);
        return FALSE;
    }

};


inline
SDP_VALUE::SDP_VALUE(
    IN              DWORD                   ErrorCode,
    IN      const   CHAR                    *TypePrefixString,
    IN      const   SDP_LINE_TRANSITION     *SdpLineTransition
    )
    : m_ErrorCode(ErrorCode),
      m_TypePrefixString(TypePrefixString),
      m_SdpLineTransition(SdpLineTransition),
      m_LineState(LINE_START)
{
    ASSERT(NULL != TypePrefixString);
    ASSERT(strlen(TypePrefixString) == TYPE_STRING_LEN);
}



inline  void    
SDP_VALUE::Reset(
        )
{
    InternalReset();

	// empty the separator char / field arrays
	m_FieldArray.RemoveAll();
	m_SeparatorCharArray.RemoveAll();

	m_LineState = LINE_START; 
}


inline  BOOL    
SDP_VALUE::IsModified(
    ) const
{
    return ( IsValid() ? CalcIsModified() : FALSE );
}


inline  DWORD   
SDP_VALUE::GetCharacterStringSize(
    )
{
    return ( IsValid() ? CalcCharacterStringSize() : 0 );
}
   


inline  BOOL    
SDP_VALUE::PrintValue(
    OUT     ostrstream  &OutputStream
    )
{
    // should not be modified
    ASSERT(!IsModified());

    return ( IsValid() ? CopyValue(OutputStream) : TRUE );
}
    


inline BOOL    
SDP_VALUE::ParseLine(
    IN  OUT     CHAR    *&Line
    )
{
    // parse the line
    return InternalParseLine(Line);
}


class _DllDecl SDP_VALUE_LIST : public SDP_POINTER_ARRAY<SDP_VALUE *>
{
public:

    inline  BOOL        IsValid() const;

    inline BOOL         ParseLine(
        IN              CHAR        *&Line
        );

    inline SDP_VALUE    *GetCurrentElement();

    virtual BOOL        IsModified() const;

    virtual DWORD       GetCharacterStringSize();

    virtual BOOL        PrintValue(
            OUT         ostrstream  &OutputStream
        );

    virtual SDP_VALUE   *CreateElement() = 0;
};



inline  BOOL    
SDP_VALUE_LIST::IsValid(
    ) const
{
    // check each of the members in the list for validity
    for (int i=0; i < GetSize(); i++)
    {
        // if even one member is valid, return TRUE
        if ( GetAt(i)->IsValid() )
        {
            return TRUE;
        }
    }

    // all members are invalid
    return FALSE;
}


inline BOOL        
SDP_VALUE_LIST::ParseLine(
    IN CHAR *&Line
    )
{
    SDP_VALUE *SdpValue = CreateElement();
    if ( NULL == SdpValue )
    {
        return FALSE;
    }

    if ( !SdpValue->ParseLine(Line) )
    {
        delete SdpValue;
        return FALSE;
    }

    try
    {
        Add(SdpValue);
    }
    catch(...)
    {
        delete SdpValue;
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    return TRUE;
}



inline SDP_VALUE   *
SDP_VALUE_LIST::GetCurrentElement(
    )
{
    ASSERT(0 < GetSize());
    ASSERT(NULL != GetAt(GetSize()-1));

    return GetAt(GetSize()-1);
}



#endif // __SDP_VALUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\sdpver.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpver.h

Abstract:


Author:

*/
#ifndef __SDP_VERSION__
#define __SDP_VERSION__


#include "sdpcommo.h"
#include "sdpval.h"
#include "sdpfld.h"



const   ULONG   CURRENT_SDP_VERSION = 0;


class _DllDecl SDP_VERSION : public SDP_VALUE 
{
public:

    SDP_VERSION();

    inline USHORT   GetVersionValue() const;

private:

    SDP_USHORT    m_Version;
    
    virtual BOOL InternalParseLine(
        IN  OUT     CHAR    *&Line
        );

	virtual void InternalReset();
};



inline USHORT   
SDP_VERSION::GetVersionValue(
    ) const
{
    return m_Version.GetValue();
}


#endif // __SDP_VERSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\tapih26x.h ===
/****************************************************************************
 *  @doc INTERNAL TAPIH26X
 *
 *  @module TAPIH26X.h | Header file for the supported compressed input formats.
 ***************************************************************************/

#ifndef _TAPIH26X_H_
#define _TAPIH26X_H_

//#define USE_OLD_FORMAT_DEFINITION 1

// RTP-packetized video subtypes
#define STATIC_MEDIASUBTYPE_R263_V1 0x33363252L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
#define STATIC_MEDIASUBTYPE_R261 0x31363252L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71

// H.26x specific structures
/*****************************************************************************
 *  @doc INTERNAL TAPIH26XSTRUCTENUM
 *
 *  @struct BITMAPINFOHEADER_H263 | The <t BITMAPINFOHEADER_H263> structure
 *    is used to specify the details of the H.263 video format.
 *
 *  @field BITMAPINFOHEADER | bmi | Specifies a well-known GDI bitmap info
 *    header structure.
 *
 *  @field DWORD | dwMaxBitrate | Specifies the maximum bit rate in units of
 *    100 bits/s at which the receiver can receive video. This value is valid
 *    between 1 and 192400.
 *
 *  @field DWORD | dwBppMaxKb | Specifies the maximum number of bits for one
 *    coded picture that the receiver can receive and decode correctly, and is
 *    measured in units of 1024 bits. This value is valid between 0 and 65535.
 *
 *  @field DWORD | dwHRD_B | Specifies the Hypothetical Reference Decoder
 *    parameter B as described in Annex B of H.263. This value is valid
 *    between 0 and 524287.
 *
 *  @field DWORD | fUnrestrictedVector:1 | Specifies that the receiver can
 *    receive video data using the unrestricted motion vectors mode as defined
 *    in Annex D of H.263.
 *
 *  @field DWORD | fArithmeticCoding:1| Specifies that the receiver can receive
 *    video data using the syntax based arithmetic coding mode as defined in
 *    Annex E of H.263.
 *
 *  @field DWORD | fAdvancedPrediction:1 | Specifies that the receiver can
 *    receive video data using the advanced prediction mode as defined in Annex
 *    F of H.263.
 *
 *  @field DWORD | fPBFrames:1 | Specifies that the receiver can receive video
 *    data using the PB-frames mode as defined in Annex G of H.263.
 *
 *  @field DWORD | fErrorCompensation:1 | Specifies that the receiver can
 *    identify MBs received with transmission errors, treat them as not coded,
 *    and send appropriate videoNotDecodedMBs indications.
 *
 *  @field DWORD | fAdvancedIntraCodingMode:1 | Specifies that the receiver can
 *    receive video data using the advanced INTRA coding mode as defined in
 *    Annex I of H.263.
 *
 *  @field DWORD | fDeblockingFilterMode:1 | Specifies that the receiver can
 *    receive video data using the deblocking filter mode as defined in Annex J
 *    of H.263.
 *
 *  @field DWORD | fImprovedPBFrameMode:1 | Specifies that the receiver can
 *    receive video data using the improved PB-frames mode as defined in Annex
 *    M of H.263.
 *
 *  @field DWORD | fUnlimitedMotionVectors:1 | Specifies that the receiver can
 *    receive video data using the unrestricted motion vector range when
 *    unrestricted motion vector mode as defined in Annex D of H.263 is also
 *    indicated.
 *
 *  @field DWORD | fFullPictureFreeze:1 | Specifies that the receiver can receive
 *    Full Picture Freeze commands as described in Annex L of H.263.
 *
 *  @field DWORD | fPartialPictureFreezeAndRelease:1 | Specifies that the
 *    receiver can receive the Resizing Partial Picture Freeze and Release
 *    commands as described in Annex L of H.263.
 *
 *  @field DWORD | fResizingPartPicFreezeAndRelease:1 | Specifies that the
 *    receiver can receive the Resizing Partial Picture Freeze and Release
 *    commands as described in Annex L of H.263.
 *
 *  @field DWORD | fFullPictureSnapshot:1 | Specifies that the receiver can
 *    receive Full Picture snapshots of the video content as described in Annex L
 *    of H.263.
 *
 *  @field DWORD | fPartialPictureSnapshot:1 | Specifies that the receiver can
 *    receive Partial Picture Snapshots of the video content as described in
 *    Annex L of H.263.
 *
 *  @field DWORD | fVideoSegmentTagging:1 | Specifies that the receiver can
 *    receive Video Segment tagging for the video content as described in Annex L
 *    of H.263.
 *
 *  @field DWORD | fProgressiveRefinement:1 | Specifies that the receiver can
 *    receive Progressive Refinement tagging as described in Annex L of H.263. In
 *    addition, when true, the encoder shall respond to the progressive refinement
 *    miscellaneous commands doOneProgression, doContinuousProgressions,
 *    doOneIndependentProgression, doContinuousIndependentProgressions,
 *    progressiveRefinementAbortOne, and progressiveRefinementAbortContinuous. In
 *    addition, the encoder shall insert the Progressive Refinement Segment Start
 *    Tags and the Progressive Refinement Segment End Tags as defined in the
 *    Supplemental Enhancement Information Specification (Annex L) of
 *    Recommendation H.263. Note, Progressive Refinement tagging can be sent by an
 *    encoder and received by a decoder even when not commanded in a miscellaneous
 *    command.
 *
 *  @field DWORD | fDynamicPictureResizingByFour:1 | Specifies that the receiver
 *    supports the picture resizing-by-four (with clipping) submode of the
 *    implicit Reference Picture Resampling Mode (Annex P) of H.263.
 *
 *  @field DWORD | fDynamicPictureResizingSixteenthPel:1 | Specifies that the
 *    receiver supports resizing a reference picture to any width and height using
 *    the implicit Reference Picture Resampling mode (Annex P) of H.263 (with
 *    clipping). If DynamicPictureResizingSixteenthPel is true then
 *    DynamicPictureResizingByFour shall be true.
 *
 *  @field DWORD | fDynamicWarpingHalfPel:1 | Specifies that the receiver supports
 *    the arbitrary picture warping operation within the Reference Picture
 *    Resampling mode (Annex P) of H.263 (with any fill mode) using half-pixel
 *    accuracy warping.
 *
 *  @field DWORD | fDynamicWarpingSixteenthPel:1 | Specifies that the receiver
 *    supports the arbitrary picture warping operation within the Reference Picture
 *    Resampling mode (Annex P) of H.263 (with any fill mode) using either
 *    half-pixel or sixteenth pixel accuracy warping.
 *
 *  @field DWORD | fIndependentSegmentDecoding:1 | Specifies that the receiver
 *    supports the Independent Segment Decoding Mode (H.263 Annex R) of H.263.
 *
 *  @field DWORD | fSlicesInOrder_NonRect:1 | Specifies that the receiver supports
 *    the submode of Slice Structured Mode (H.263 Annex K) where slices are
 *    transmitted in order and contain macroblocks in scanning order of the
 *    picture.
 *
 *  @field DWORD | fSlicesInOrder_Rect:1 | Specifies that the receiver supports
 *    the submode of Slice Structured Mode (H.263 Annex K) where slices are
 *    transmitted in order and the slice occupies a rectangular region of the
 *    picture.
 *
 *  @field DWORD | fSlicesNoOrder_NonRect:1 | Specifies that the receiver
 *    supports the submode of Slice Structured Mode (H.263 Annex K) where
 *    slices contain macroblocks in scanning order of the picture and need
 *    not be transmitted in order.
 *
 *  @field DWORD | fSlicesNoOrder_Rect:1 | Specifies that the receiver
 *    supports the submode of Slice Structured Mode (H.263 Annex K) where
 *    slices occupy a rectangular region of the picture and need not be
 *    transmitted in order.
 *
 *  @field DWORD | fAlternateInterVLCMode:1 | Specifies that the receiver
 *    can receive video data using the alternate inter VLC mode as defined
 *    in Annex S of H.263.
 *
 *  @field DWORD | fModifiedQuantizationMode:1 | Specifies that the receiver
 *    can receive video data using the modified quantization mode as defined
 *    in Annex T of H.263.
 *
 *  @field DWORD | fReducedResolutionUpdate:1 | Specifies that the receiver
 *    can receive video data using the reduced resolution update mode as
 *    defined in Annex Q of H.263.
 *
 *  @field DWORD | fReserved:4 | Reserved. Shall be set to 0.
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/

#define MAX_BITRATE_H263 (192400)

typedef struct tagBITMAPINFOHEADER_H263
{
	// Generic bitmap info header fields
	BITMAPINFOHEADER   bmi;

#ifndef USE_OLD_FORMAT_DEFINITION
	// H.263 specific fields
	DWORD dwMaxBitrate;
	DWORD dwBppMaxKb;
	DWORD dwHRD_B;

	// Options
	DWORD fUnrestrictedVector:1;
	DWORD fArithmeticCoding:1;
	DWORD fAdvancedPrediction:1;
	DWORD fPBFrames:1;
	DWORD fErrorCompensation:1;
	DWORD fAdvancedIntraCodingMode:1;
	DWORD fDeblockingFilterMode:1;
	DWORD fImprovedPBFrameMode:1;
	DWORD fUnlimitedMotionVectors:1;
	DWORD fFullPictureFreeze:1;
	DWORD fPartialPictureFreezeAndRelease:1;
	DWORD fResizingPartPicFreezeAndRelease:1;
	DWORD fFullPictureSnapshot:1;
	DWORD fPartialPictureSnapshot:1;
	DWORD fVideoSegmentTagging:1;
	DWORD fProgressiveRefinement:1;
	DWORD fDynamicPictureResizingByFour:1;
	DWORD fDynamicPictureResizingSixteenthPel:1;
	DWORD fDynamicWarpingHalfPel:1;
	DWORD fDynamicWarpingSixteenthPel:1;
	DWORD fIndependentSegmentDecoding:1;
	DWORD fSlicesInOrder_NonRect:1;
	DWORD fSlicesInOrder_Rect:1;
	DWORD fSlicesNoOrder_NonRect:1;
	DWORD fSlicesNoOrder_Rect:1;
	DWORD fAlternateInterVLCMode:1;
	DWORD fModifiedQuantizationMode:1;
	DWORD fReducedResolutionUpdate:1;
	DWORD fReserved:4;

	// Reserved
	DWORD dwReserved[4];
#endif
} BITMAPINFOHEADER_H263, *PBITMAPINFOHEADER_H263;

/*****************************************************************************
 *  @doc INTERNAL TAPIH26XSTRUCTENUM
 *
 *  @struct VIDEOINFOHEADER_H263 | The <t VIDEOINFOHEADER_H263> structure
 *    is used to specify the details of the H.263 video format.
 *
 *  @field RECT | rcSource | Specifies a <t RECT> structure that defines the
 *    source video window.
 *
 *  @field RECT | rcTarget | Specifies a <t RECT> structure that defines the
 *    destination video window.
 *
 *  @field DWORD | dwBitRate | Specifies a <t DWORD> value that indicates
 *    the video stream's approximate data rate, in bits per second.
 *
 *  @field DWORD | dwBitErrorRate | Specifies a <t DWORD> value that
 *    indicates the video stream's data error rate, in bit errors per second.
 *
 *  @field REFERENCE_TIME | AvgTimePerFrame | Specifies a <t REFERENCE_TIME>
 *    value that indicates the video frame's average display time, in
 *    100-nanosecond units.
 *
 *  @field BITMAPINFOHEADER_H263 | bmiHeader | Specifies a
 *    <t BITMAPINFOHEADER_H263> structure that contains detailed format
 *    information for the H.263 video data.
 ***************************************************************************/
typedef struct tagVIDEOINFOHEADER_H263
{
    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)
    BITMAPINFOHEADER_H263 bmiHeader;
} VIDEOINFOHEADER_H263, *PVIDEOINFOHEADER_H263;

/*****************************************************************************
 *  @doc INTERNAL TAPIH26XSTRUCTENUM
 *
 *  @struct BITMAPINFOHEADER_H261 | The <t BITMAPINFOHEADER_H261> structure
 *    is used to specify the details of the H.261 video format.
 *
 *  @field BITMAPINFOHEADER | bmi | Specifies a well-known GDI bitmap info
 *    header structure.
 *
 *  @field DWORD | dwMaxBitrate | Specifies the maximum bit rate in units
 *    of 100 bits/s at which the receiver can receive video. This value is
 *    only valid between 1 and 19200.
 *
 *  @field BOOL | fStillImageTransmission | Specifies that the receiver can
 *    receive still images as defined in Annex D of H.261.
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/

#define MAX_BITRATE_H261 (19200)

typedef struct tagBITMAPINFOHEADER_H261
{
	// Generic bitmap info header fields
	BITMAPINFOHEADER   bmi;

#ifndef USE_OLD_FORMAT_DEFINITION
	// H.261 specific fields
	DWORD dwMaxBitrate;
	BOOL fStillImageTransmission;

	// Reserved
	DWORD dwReserved[4];
#endif
} BITMAPINFOHEADER_H261, *PBITMAPINFOHEADER_H261;

/*****************************************************************************
 *  @doc INTERNAL TAPIH26XSTRUCTENUM
 *
 *  @struct VIDEOINFOHEADER_H261 | The <t VIDEOINFOHEADER_H261> structure
 *    is used to specify the details of the H.261 video format.
 *
 *  @field RECT | rcSource | Specifies a <t RECT> structure that defines the
 *    source video window.
 *
 *  @field RECT | rcTarget | Specifies a <t RECT> structure that defines the
 *    destination video window.
 *
 *  @field DWORD | dwBitRate | Specifies a <t DWORD> value that indicates
 *    the video stream's approximate data rate, in bits per second.
 *
 *  @field DWORD | dwBitErrorRate | Specifies a <t DWORD> value that
 *    indicates the video stream's data error rate, in bit errors per second.
 *
 *  @field REFERENCE_TIME | AvgTimePerFrame | Specifies a <t REFERENCE_TIME>
 *    value that indicates the video frame's average display time, in
 *    100-nanosecond units.
 *
 *  @field BITMAPINFOHEADER_H261 | bmiHeader | Specifies a
 *    <t BITMAPINFOHEADER_H261> structure that contains detailed format
 *    information for the H.261 video data.
 ***************************************************************************/
typedef struct tagVIDEOINFOHEADER_H261
{
    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)
    BITMAPINFOHEADER_H261 bmiHeader;
} VIDEOINFOHEADER_H261, *PVIDEOINFOHEADER_H261;

#endif // _TAPIH26X_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\inc\tm.h ===
/////////////////////////////////////////////
//
// Copyright (c) 2000  Microsoft Corporation
//
// Module Name:
//
//    tm.h
//
//
// Abstract:
//
//  this file contains declarations used throughout modules that compose 
//  termmgr
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ___TM_DOT_H_INCLUDED___
#define ___TM_DOT_H_INCLUDED___


//
// safely load a resource string described by the specified resources id
//
// returns NULL on failure, or the string on success
//
// on success, the caller is responsible for freeing return memory by calling
// SysFreeString()
//

BSTR SafeLoadString( UINT uResourceID );


//
// returns TRUE if the two media types are the equal
//

bool IsEqualMediaType(AM_MEDIA_TYPE const & mt1, AM_MEDIA_TYPE const & mt2);

BOOL IsBadMediaType(IN const AM_MEDIA_TYPE *mt1);


//
// our own assert, so we don't have to use CRT's
//

#ifdef DBG

    #define TM_ASSERT(x) { if (!(x)) { DebugBreak(); } }

#else

    #define TM_ASSERT(x)

#endif



//
// helper function that dumps allocator properties preceeded by the argument
// string
//

void DumpAllocatorProperties(const char *szString, 
                             const ALLOCATOR_PROPERTIES *pAllocProps);


//
// only dump alloc properties in debug build
//

#ifdef DBG

 #define DUMP_ALLOC_PROPS(string, x) DumpAllocatorProperties(string, x);

#else 

 #define DUMP_ALLOC_PROPS(string, x) 

#endif


#endif // ___TM_DOT_H_INCLUDED___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgaudio.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgaudio.h

Abstract:

    Definitions for the audio bridge filters

Author:

    Mu Han (muhan) 11/12/1998

--*/

#ifndef _BGAUDIO_H_
#define _BGAUDIO_H_


class CTAPIAudioBridgeSinkFilter :
    public CTAPIBridgeSinkFilter
{
public:
    CTAPIAudioBridgeSinkFilter(
        IN LPUNKNOWN        pUnk, 
        IN IDataBridge *    pIDataBridge, 
        OUT HRESULT *       phr
        );

    static HRESULT CreateInstance(
        IN IDataBridge *    pIDataBridge, 
        OUT IBaseFilter ** ppIBaseFilter
        );

    // methods called by the input pin.
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);
};


class CTAPIAudioBridgeSourceFilter : 
    public CTAPIBridgeSourceFilter
    {
public:

    CTAPIAudioBridgeSourceFilter(
        IN LPUNKNOWN pUnk, 
        OUT HRESULT *phr
        );

    ~CTAPIAudioBridgeSourceFilter ();

    static HRESULT CreateInstance(
        OUT IBaseFilter ** ppIBaseFilter
        );

    // override the IDataBridge methods.
    STDMETHOD (SendSample) (
        IN  IMediaSample *pSample
        );

    // methods called by the output pin.
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);

    // overrides the base filter
    // IAMBufferNegotiation stuff
    STDMETHOD (SuggestAllocatorProperties) (IN const ALLOCATOR_PROPERTIES *pprop);
    STDMETHOD (GetAllocatorProperties) (OUT ALLOCATOR_PROPERTIES *pprop);

    // IAMStreamConfig stuff
    STDMETHOD (SetFormat) (IN AM_MEDIA_TYPE *pmt);
    STDMETHOD (GetFormat) (OUT AM_MEDIA_TYPE **ppmt);

protected:

    // following members were moved from CTAPIBridgeSourceOutputPin
    // because they are only need in audio part; we implement a derived filter class
    // for audio; same pin is shared by both audio and video
    ALLOCATOR_PROPERTIES m_prop;
    BOOL m_fPropSet;

    AM_MEDIA_TYPE m_mt;
    BOOL m_fMtSet;

    BOOL m_fClockStarted;
    BOOL m_fJustBurst;
    REFERENCE_TIME m_last_wall_time;
    REFERENCE_TIME m_last_stream_time;
    // assume output sample won't change size
    REFERENCE_TIME m_output_sample_time;

    // algorithm of SendSample can only deal with samples with fixed size
    LONG m_nInputSize, m_nOutputSize, m_nOutputFree;
    IMediaSample *m_pOutputSample;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgaudio.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgaudio.cpp

Abstract:

    Implementation of the audio bridge filters.

Author:

    Mu Han (muhan) 11/16/1998

--*/

#include "stdafx.h"

CTAPIAudioBridgeSinkFilter::CTAPIAudioBridgeSinkFilter(
    IN LPUNKNOWN        pUnk, 
    IN IDataBridge *    pIDataBridge, 
    OUT HRESULT *       phr
    ) 
    : CTAPIBridgeSinkFilter(pUnk, pIDataBridge, phr)
{
}

HRESULT CTAPIAudioBridgeSinkFilter::CreateInstance(
    IN IDataBridge *    pIDataBridge, 
    OUT IBaseFilter ** ppIBaseFilter
    )
/*++

Routine Description:

    This method create a instance of the bridge's sink filter.

Arguments:

    ppIBaseFilter - the returned filter interface pointer.

Return Value:

    E_OUTOFMEMORY - no memory for the new object.

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSinkFilter::CreateInstance");

    BGLOG((BG_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;
    CUnknown* pUnknown = new CTAPIAudioBridgeSinkFilter(NULL, pIDataBridge, &hr);
                
    if (pUnknown == NULL) 
    {
        hr = E_OUTOFMEMORY;
        BGLOG((BG_ERROR, 
            "%s, out of memory creating the filter", 
            __fxName));
    }
    else if (FAILED(hr))
    {
        BGLOG((BG_ERROR, 
            "%s, the filter's constructor failed, hr:%d", 
            __fxName, hr));

        delete pUnknown;
    }
    else
    {
        pUnknown->NonDelegatingAddRef();

        hr = pUnknown->NonDelegatingQueryInterface(
            __uuidof(IBaseFilter), (void **)ppIBaseFilter
            );

        pUnknown->NonDelegatingRelease();
    }

    BGLOG((BG_TRACE, 
        "%s, returning:%p, hr:%x", __fxName, *ppIBaseFilter, hr));

    return hr;
} 

HRESULT CTAPIAudioBridgeSinkFilter::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
/*++

Routine Description:

    Get the media type that this filter wants to support. Currently we
    only support PCM L16 8KHz samples.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based..
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSinkFilter::GetMediaType");

    BGLOG((BG_TRACE, 
        "%s, iPosition:%d, pMediaType:%p", 
        __fxName, iPosition, pMediaType));

    HRESULT hr = VFW_S_NO_MORE_ITEMS;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIAudioBridgeSinkFilter::CheckMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    Check the media type that this filter wants to support. Currently we
    only support PCM L16 8KHz samples.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    E_UNEXPECTED - internal media type not set
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSinkFilter::CheckMediaType");

    BGLOG((BG_TRACE, 
        "%s, pMediaType:%p", __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    // media type is only stored in source filter
    // return S_OK here
    // if error, the source filter will detect it anyway
    HRESULT hr = S_OK;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


CTAPIAudioBridgeSourceFilter::CTAPIAudioBridgeSourceFilter(
    IN LPUNKNOWN        pUnk, 
    OUT HRESULT *       phr
    ) 
    : CTAPIBridgeSourceFilter(pUnk, phr)
{
    m_fPropSet = FALSE; // allocator properties not set yet
    m_fMtSet = FALSE; // media type not set yet

    // m_last_wall_time, m_last_stream_time not initiated
    m_fClockStarted = FALSE;
    m_fJustBurst = FALSE;

    m_nInputSize = 0;
    m_nOutputSize = 0;
    m_nOutputFree = 0;
    m_pOutputSample = NULL;
}

CTAPIAudioBridgeSourceFilter::~CTAPIAudioBridgeSourceFilter ()
{
    if (m_fMtSet)
    {
        FreeMediaType (m_mt);
    }

    if (NULL != m_pOutputSample)
    {
        m_pOutputSample->Release ();
    }
}

HRESULT CTAPIAudioBridgeSourceFilter::CreateInstance(
    OUT IBaseFilter ** ppIBaseFilter
    )
/*++

Routine Description:

    This method create a instance of the bridge's sink filter.

Arguments:

    ppIBaseFilter - the returned filter interface pointer.

Return Value:

    E_OUTOFMEMORY - no memory for the new object.

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSourceFilter::CreateInstance");

    BGLOG((BG_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;
    CUnknown* pUnknown = new CTAPIAudioBridgeSourceFilter(NULL, &hr);
                
    if (pUnknown == NULL) 
    {
        hr = E_OUTOFMEMORY;
        BGLOG((BG_ERROR,  
            "%s, out of memory creating the filter", 
            __fxName));
    }
    else if (FAILED(hr))
    {
        BGLOG((BG_ERROR, 
            "%s, the filter's constructor failed, hr:%d", 
            __fxName, hr));

        delete pUnknown;
    }
    else
    {
        pUnknown->NonDelegatingAddRef();

        hr = pUnknown->NonDelegatingQueryInterface(
            __uuidof(IBaseFilter), (void **)ppIBaseFilter
            );

        pUnknown->NonDelegatingRelease();
    }

    BGLOG((BG_TRACE, 
        "%s, returning:%p, hr:%x", __fxName, *ppIBaseFilter, hr));

    return hr;
} 

HRESULT CTAPIAudioBridgeSourceFilter::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
/*++

Routine Description:

    Get the media type that this filter wants to support. Currently we
    only support PCM L16 8KHz samples.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based..
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSourceFilter::GetMediaType");

    BGLOG((BG_TRACE, 
        "%s, iPosition:%d, pMediaType:%p", 
        __fxName, iPosition, pMediaType));

    ASSERT(!IsBadWritePtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

   HRESULT hr;
   if (iPosition == 0)
   {
        AM_MEDIA_TYPE *pmt = NULL;
        hr = m_pOutputPin->GetFormat (&pmt);
        if (FAILED(hr))
            return hr;
        *pMediaType = *pmt;
        FreeMediaType (*pmt);
        free (pmt);
    }
    else
    {
        hr = VFW_S_NO_MORE_ITEMS;
    }
    // END

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIAudioBridgeSourceFilter::CheckMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    Check the media type that this filter wants to support. Currently we
    only support PCM L16 8KHz samples.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSourceFilter::CheckMediaType");

    BGLOG((BG_TRACE, 
        "%s, pMediaType:%p", __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (!m_fMtSet)
    {
        BGLOG ((BG_ERROR, "%s tries to check media type before setting", __fxName));
        return E_UNEXPECTED;
    }

    // create media type based on stored AM_MEDIA_TYPE
    CMediaType *pmediatype = new CMediaType (m_mt);
    if (NULL == pmediatype)
    {
        BGLOG ((BG_ERROR, "%s failed to new media type class", __fxName));
        return E_OUTOFMEMORY;
    }

    HRESULT hr;
    if (*pMediaType == *pmediatype)
        hr = S_OK;
    else
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        BGLOG ((BG_TRACE, "%s rejects media type class %p", __fxName, pMediaType));
    }

    delete pmediatype;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIAudioBridgeSourceFilter::SendSample(
    IN IMediaSample *pSample
    )
/*++

Routine Description:

    Process a sample from the bridge sink filter. Overides the base implementation

Arguments:

    pSample - The media sample object.

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    ENTER_FUNCTION ("CTAPIAudioBridgeSourceFilter::SendSample");

    CAutoLock Lock(m_pLock);

    _ASSERT(m_pOutputPin != NULL);

    // we don't deliver anything if the filter is not in running state.
    if (m_State != State_Running) 
    {
        return S_OK;
    }

    // if the sample is the 1st of the burst
    if (S_OK == pSample->IsDiscontinuity ())
    {
        LONGLONG start, end;

        m_fJustBurst = TRUE;
        if (S_OK != (hr = pSample->GetTime (&start, &end)))
        {
            BGLOG ((BG_TRACE, "%s, 1st sample in a burst, GetTime returns %x", __fxName, hr));

            // timestampes stored remain unchange
            return S_OK;
        }
        // else. in NT 5.1, 1st sample has valid timestamp.
    }

    // check if allocator properties is set
    if (!m_fPropSet)
    {
        BGLOG ((BG_ERROR, "%s tries to send sample before setting allocator property", __fxName));
        return E_UNEXPECTED;
    }

    // check if media type is set
    if (!m_fMtSet)
    {
        BGLOG ((BG_ERROR, "%s tries to send sample before setting media type", __fxName));
        return E_UNEXPECTED;
    }

    /*
    * get size info
    */
    // get input sample size and output allocator size
    HRESULT nInputSize, nOutputSize;

    nInputSize = pSample->GetActualDataLength ();
    nOutputSize = m_prop.cbBuffer;

    // 1st run, record size
    if (m_nInputSize == 0 || m_nOutputSize == 0)
    {
        m_nInputSize = nInputSize;
        m_nOutputSize = nOutputSize;
    }

    if (
        m_nInputSize != nInputSize ||
        m_nOutputSize != nOutputSize ||
        m_nInputSize == 0 ||
        m_nOutputSize == 0
        )
    {
        BGLOG ((BG_ERROR, "%s, sample size (%d => %d) or output size (%d => %d) is changed",
              __fxName, m_nInputSize, nInputSize, m_nOutputSize, nOutputSize));
        return E_UNEXPECTED;
    }

    /*
    * get time info
    */
    REFERENCE_TIME wall;

    // wall time
    if (FAILED (hr = m_pClock->GetTime (&wall)))
    {
        BGLOG ((BG_ERROR, "%s failed to get wall time", __fxName));
        return hr;
    }

    // if timestamp not initiated
    if (!m_fClockStarted)
    {
        m_last_stream_time = 0;
        m_last_wall_time = wall;
        m_fClockStarted = TRUE;

        // delta is the time of playing sample:
        m_output_sample_time = nOutputSize * 80000; // s->10000ns, bits->bytes
        m_output_sample_time /= ((WAVEFORMATEX*)m_mt.pbFormat)->wBitsPerSample *
                ((WAVEFORMATEX*)m_mt.pbFormat)->nSamplesPerSec;
        m_output_sample_time *= 1000; // bytes/100ns
    }

    /*
    * calculate new stream time
    */
    if (m_fJustBurst)
    {
        // 1st useful sample after burst
        m_last_stream_time += (wall - m_last_wall_time);
        m_last_wall_time = wall;

        m_fJustBurst = FALSE;

        // clear buffer
        if (NULL != m_pOutputSample)
        {
            m_pOutputSample->Release ();
            m_pOutputSample = NULL;
            m_nOutputFree = 0;
        }
    }

    REFERENCE_TIME end = m_last_stream_time + m_output_sample_time;

    /*
    * case 1: input size == output size
    */
    if (m_nInputSize == m_nOutputSize)
    {
        if (FAILED (pSample->SetTime (&m_last_stream_time, &end)))
        {
            BGLOG ((BG_ERROR, "%s failed to set time", __fxName));
        }

        // adjust time
        m_last_stream_time = end;
        m_last_wall_time += m_output_sample_time;

        // deliver directly
        return m_pOutputPin->Deliver(pSample);
    }

    /*
    * case 2: size differs
    */
    BYTE *pInputBuffer, *pOutputBuffer;

    if (FAILED (hr = pSample->GetPointer (&pInputBuffer)))
    {
        BGLOG ((BG_ERROR, "%s failed to get buffer pointer from input sample %p",
            __fxName, pSample));
        return hr;
    }
    
    LONG nNextPos = 0;

    // old fashion goto
DELIVERY_BUFFER:

    // get delivery buffer if it's null
    if (NULL == m_pOutputSample)
    {
        hr = m_pOutputPin->GetDeliveryBuffer (
            &m_pOutputSample, // media sample **
            NULL, // start time
            NULL, // end time
            AM_GBF_NOTASYNCPOINT // dynamic format changes are not allowed,
            );
        if (FAILED (hr))
        {
            BGLOG ((BG_ERROR, "%s, output pin failed to get delivery buffer. return %d",
                __fxName, hr));
            return hr;
        }

        if (m_pOutputSample->GetSize() < m_nOutputSize)
        {
            // oops, what happend, the size should be the same
            BGLOG ((BG_ERROR, "%s, delivery buffer size %d and output size %d are inconsistent",
                __fxName, m_pOutputSample->GetSize(), m_nOutputSize));
            return E_UNEXPECTED;
        }

        // set size
        if (FAILED (hr = m_pOutputSample->SetActualDataLength (m_nOutputSize)))
        {
            BGLOG ((BG_ERROR, "%s failed to set output sample size", __fxName));
            return hr;
        }
/*
        // set format
        if (FAILED (hr = m_pOutputSample->SetMediaType (&m_mt)))
        {
            BGLOG ((BG_ERROR, "%s failed to set media type for delivery buffer", __fxName));
            return hr;
        }
*/
        // set time
        if (FAILED (hr = m_pOutputSample->SetTime (&m_last_stream_time, &end)))
        {
            BGLOG ((BG_ERROR, "%s failed to set stream time for delivery buffer", __fxName));
            return hr;
        }

        // the whole buffer is free
        m_nOutputFree = m_nOutputSize;
    }

    // get buffer in output sample
    if (FAILED (hr = m_pOutputSample->GetPointer (&pOutputBuffer)))
    {
        BGLOG ((BG_ERROR, "%s failed to get buffer pointer from output sample %p",
            __fxName, m_pOutputSample));

        // release output sample
        m_pOutputSample->Release ();
        m_pOutputSample = NULL;
        m_nOutputFree = 0;

        return hr;
    }

    // if input buffer is smaller than free output buffer
    // copy input to output and return
    if (m_nInputSize-nNextPos < m_nOutputFree)
    {
        CopyMemory (
            (PVOID)(pOutputBuffer + (m_nOutputSize - m_nOutputFree)),
            (PVOID)(pInputBuffer + nNextPos),
            (DWORD)(m_nInputSize - nNextPos)
            );

        // reduce free buffer size
        m_nOutputFree -= m_nInputSize - nNextPos;

        return S_OK;
    }

    // else: input buffer is greater or equal to free output buffer
    CopyMemory (
        (PVOID)(pOutputBuffer + (m_nOutputSize - m_nOutputFree)),
        (PVOID)(pInputBuffer + nNextPos),
        (DWORD)(m_nOutputFree)
        );

    // now output sample is full, deliver it
    if (FAILED (hr = m_pOutputPin->Deliver (m_pOutputSample)))
    {
        BGLOG ((BG_ERROR, "%s failed to deliver copied sample. return %x", __fxName, hr));

        // clear sample
        m_pOutputSample->Release ();
        m_pOutputSample = NULL;
        m_nOutputFree = 0;

        return hr;
    }

    // adjust next position in input buffer
    nNextPos += m_nOutputFree;

    // clear output sample since it was deliverd
    m_pOutputSample->Release ();
    m_pOutputSample = NULL;
    m_nOutputFree = 0;

    // adjust time
    m_last_stream_time = end;
    m_last_wall_time += m_output_sample_time;

    // check if nothing left
    if (nNextPos == m_nInputSize)
        return S_OK;

    // there is more in input buffer
    goto DELIVERY_BUFFER;
}

HRESULT CTAPIAudioBridgeSourceFilter::GetAllocatorProperties (OUT ALLOCATOR_PROPERTIES *pprop)
/*++

Routine Description:

    Returns the allocator properties

Arguments:

    pprop -
        The pointer to an ALLOCATOR_PROPERTIES

Return Value:

    E_POINTER -
        if pprop is NULL

    S_OK

--*/
{
    ENTER_FUNCTION ("CTAPIAudioBridgeSourceFilter::GetAllocatorProperties");
    _ASSERT(pprop);

    if (!pprop)
        return E_POINTER;

    if (!m_fPropSet)
    {
        BGLOG ((BG_INFO, "%s retrieves allocator properties before setting", __fxName));
        // return default value anyway
        // buffer size = (16bits / 8bits) * 8khz * 30 ms = 480 bytes
        pprop->cBuffers = 1;
        pprop->cbBuffer = 480; // default
        pprop->cbAlign = 0;
        pprop->cbPrefix = 0;
        return S_OK;
    }

    // properties were set
    pprop->cBuffers = m_prop.cBuffers;
    pprop->cbBuffer = m_prop.cbBuffer;
    pprop->cbAlign = m_prop.cbAlign;
    pprop->cbPrefix = m_prop.cbPrefix;
    return S_OK;
}

HRESULT CTAPIAudioBridgeSourceFilter::SuggestAllocatorProperties (IN const ALLOCATOR_PROPERTIES *pprop)
/*++

Routine Description:

    Asks the pin to use the allocator buffer properties

Arguments:

    pprop -
        The pointer to an ALLOCATOR_PROPERTIES

Return Value:

    E_POINTER

    S_OK

--*/
{
    _ASSERT (pprop);

    if (!pprop)
        return E_POINTER;

    m_prop.cBuffers = pprop->cBuffers;
    m_prop.cbBuffer = pprop->cbBuffer;
    m_prop.cbAlign = pprop->cbAlign;
    m_prop.cbPrefix = pprop->cbPrefix;
    m_fPropSet = TRUE;

    return S_OK;
}

HRESULT CTAPIAudioBridgeSourceFilter::GetFormat (OUT AM_MEDIA_TYPE **ppmt)
/*++

Routine Description:

    Retrieves the stream format

Arguments:

    ppmt -
        Address of a pointer to an AM_MEDIA_TYPE structure

Return Value:

    E_PONTER

    E_OUTOFMEMORY

    HRESULT of SetFormat

    S_OK

--*/
{
    ENTER_FUNCTION ("CTAPIAudioBridgeSourceFilter::GetFormat");

    _ASSERT (ppmt);
    if (NULL == ppmt)
        return E_POINTER;

    if (NULL != *ppmt)
        BGLOG ((BG_INFO, "is media type structure freed when passed in %s?", __fxName));

    *ppmt = new AM_MEDIA_TYPE;
    if (NULL == *ppmt)
    {
        BGLOG ((BG_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    if (!m_fMtSet)
    {
        BGLOG ((BG_INFO, "%s retrieves media type before setting. Default is to set.", __fxName));

        // st format
        HRESULT hr;
        AM_MEDIA_TYPE mt;
        WAVEFORMATEX wfx;

        wfx.wFormatTag          = WAVE_FORMAT_PCM;
        wfx.wBitsPerSample      = 16;
        wfx.nChannels           = 1;
        wfx.nSamplesPerSec      = 8000;
        wfx.nBlockAlign         = wfx.wBitsPerSample * wfx.nChannels / 8;
        wfx.nAvgBytesPerSec     = ((DWORD) wfx.nBlockAlign * wfx.nSamplesPerSec);
        wfx.cbSize              = 0;

        mt.majortype            = MEDIATYPE_Audio;
        mt.subtype              = MEDIASUBTYPE_PCM;
        mt.bFixedSizeSamples    = TRUE;
        mt.bTemporalCompression = FALSE;
        mt.lSampleSize          = 0;
        mt.formattype           = FORMAT_WaveFormatEx;
        mt.pUnk                 = NULL;
        mt.cbFormat             = sizeof(WAVEFORMATEX);
        mt.pbFormat             = (BYTE*)&wfx;

        hr = SetFormat (&mt);
        if (FAILED (hr))
        {
            BGLOG ((BG_ERROR, "%s, failed to set default format", __fxName));
            return hr;
        }
    }

    CopyMediaType (*ppmt, &m_mt);

    return S_OK;
}

HRESULT CTAPIAudioBridgeSourceFilter::SetFormat (IN AM_MEDIA_TYPE *pmt)
/*++

Routine Description:

    Sets the stream format

Arguments:

    pmt -
        Pointer to an AM_MEDIA_TYPE structure

Return Value:

    E_POINTER

    S_OK

--*/
{
    _ASSERT (pmt);

    if (NULL == pmt)
        return E_POINTER;

    CopyMediaType (&m_mt, pmt);
    m_fMtSet = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgbase.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgbase.cpp

Abstract:

    Implementation of the base classes of the bridge filters.

Author:

    Mu Han (muhan) 11/16/1998

--*/

#include "stdafx.h"

CTAPIBridgeSinkInputPin::CTAPIBridgeSinkInputPin(
    IN CTAPIBridgeSinkFilter *pFilter,
    IN CCritSec *pLock,
    OUT HRESULT *phr
    ) 
    : CBaseInputPin(
        NAME("CTAPIBridgeSinkInputPin"),
        pFilter,                   // Filter
        pLock,                     // Locking
        phr,                       // Return code
        L"Input"                   // Pin name
        )
{
}

#define MTU_SIZE 1450

STDMETHODIMP CTAPIBridgeSinkInputPin::GetAllocatorRequirements(
    ALLOCATOR_PROPERTIES *pProperties
    )
/*++

Routine Description:

    This is a hint to the upstream RTP source filter about the buffers to 
    allocate.

Arguments:

    pProperties -
        Pointer to the allocator properties.

Return Value:

    S_OK - success.

    E_FAIL - the buffer size can't fulfill our requirements.
--*/
{
    _ASSERT(pProperties);

    if (!pProperties)
        return E_POINTER;

    pProperties->cBuffers = 8;
    pProperties->cbAlign = 0;
    pProperties->cbPrefix = 0;
    pProperties->cbBuffer = MTU_SIZE;

    return NOERROR;
}

inline STDMETHODIMP CTAPIBridgeSinkInputPin::Receive(IN IMediaSample *pSample) 
{
    return ((CTAPIBridgeSinkFilter*)m_pFilter)->ProcessSample(pSample);
}

inline HRESULT CTAPIBridgeSinkInputPin::GetMediaType(IN int iPosition, IN CMediaType *pMediaType)
{
    return ((CTAPIBridgeSinkFilter*)m_pFilter)->GetMediaType(iPosition, pMediaType);
}

inline HRESULT CTAPIBridgeSinkInputPin::CheckMediaType(IN const CMediaType *pMediaType)
{
    return ((CTAPIBridgeSinkFilter*)m_pFilter)->CheckMediaType(pMediaType);
}

CTAPIBridgeSourceOutputPin::CTAPIBridgeSourceOutputPin(
    IN CTAPIBridgeSourceFilter *pFilter,
    IN CCritSec *pLock,
    OUT HRESULT *phr
    )
    : CBaseOutputPin(
        NAME("CTAPIBridgeSourceOutputPin"),
        pFilter,                   // Filter
        pLock,                     // Locking
        phr,                       // Return code
        L"Output"                  // Pin name
        )
{
}

CTAPIBridgeSourceOutputPin::~CTAPIBridgeSourceOutputPin ()
{
}

STDMETHODIMP
CTAPIBridgeSourceOutputPin::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    Overrides CBaseOutputPin::NonDelegatingQueryInterface().
    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. 

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    HRESULT hr;

    if (riid == __uuidof(IAMBufferNegotiation)) {

        return GetInterface(static_cast<IAMBufferNegotiation*>(this), ppv);
    }
    else if (riid == __uuidof(IAMStreamConfig)) {

        return GetInterface(static_cast<IAMStreamConfig*>(this), ppv);
    }
    return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
} 

inline HRESULT CTAPIBridgeSourceOutputPin::GetMediaType(IN int iPosition, IN CMediaType *pMediaType)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->GetMediaType(iPosition, pMediaType);
}

inline HRESULT CTAPIBridgeSourceOutputPin::CheckMediaType(IN const CMediaType *pMediaType)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->CheckMediaType(pMediaType);
}

HRESULT CTAPIBridgeSourceOutputPin::DecideBufferSize(
    IMemAllocator *pAlloc,
    ALLOCATOR_PROPERTIES *pProperties
    )
/*++

Routine Description:

    This fuction is called during the process of deciding an allocator. We tell
    the allocator what we want. It is also a chance to find out what the 
    downstream pin wants when we don't have a preference.

Arguments:

    pAlloc -
        Pointer to a IMemAllocator interface.

    pProperties -
        Pointer to the allocator properties.

Return Value:

    S_OK - success.

    E_FAIL - the buffer size can't fulfill our requirements.
--*/
{
    ENTER_FUNCTION("CTAPIBridgeSourceOutputPin::DecideBufferSize");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    ALLOCATOR_PROPERTIES Actual;
    
    pProperties->cbBuffer = 1024;
    pProperties->cBuffers = 4;

    HRESULT hr = pAlloc->SetProperties(pProperties, &Actual);

    if (FAILED(hr))
    {
        return hr;
    }

    *pProperties = Actual;
    return S_OK;
}

HRESULT CTAPIBridgeSourceOutputPin::GetAllocatorProperties (OUT ALLOCATOR_PROPERTIES *pprop)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->GetAllocatorProperties (pprop);
}


HRESULT CTAPIBridgeSourceOutputPin::SuggestAllocatorProperties (IN const ALLOCATOR_PROPERTIES *pprop)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->SuggestAllocatorProperties (pprop);
}

HRESULT CTAPIBridgeSourceOutputPin::GetFormat (OUT AM_MEDIA_TYPE **ppmt)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->GetFormat (ppmt);
}

HRESULT CTAPIBridgeSourceOutputPin::SetFormat (IN AM_MEDIA_TYPE *pmt)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->SetFormat (pmt);
}

HRESULT CTAPIBridgeSourceOutputPin::GetNumberOfCapabilities (OUT int *piCount, OUT int *piSize)
/*++

Routine Description:

    Retrieves the number of stream capabilities structures for the compressor

Arguments:

    piCount -
        Pointer to the number of stream capabilites structures

    piSize -
        Pointer to the size of the configuration structure.

Return Value:

    TBD

--*/
{
    ENTER_FUNCTION ("CTAPIBridgeSourceOutputPin::GetNumberOfCapabilities");
    BGLOG ((BG_ERROR, "%s is not implemented", __fxName));

    return E_NOTIMPL;
}

HRESULT CTAPIBridgeSourceOutputPin::GetStreamCaps (IN int iIndex, OUT AM_MEDIA_TYPE **ppmt, BYTE *pSCC)
/*++

Routine Description:

    Obtains capabilites of a stream depending on which type of structure is
    pointed to in the pSCC parameter

Arguments:

    iIndex -
        Index to the desired media type and capablity pair

    ppmt -
        Address of a pointer to an AM_MEDIA_TYPE structure

    pSCC -
        Pointer to a stream configuration structure

Return Value:

    TBD

--*/
{
    ENTER_FUNCTION ("CTAPIBridgeSourceOutputPin::GetStreamCaps");
    BGLOG ((BG_ERROR, "%s is not implemented", __fxName));

    return E_NOTIMPL;
}

CTAPIBridgeSinkFilter::CTAPIBridgeSinkFilter(
    IN  LPUNKNOWN pUnk, 
    IN IDataBridge *    pIDataBridge, 
    OUT HRESULT *phr
    ) : 
    CBaseFilter(
        NAME("CTAPIBridgeSinkFilter"), 
        pUnk, 
        &m_Lock, 
        __uuidof(TAPIBridgeSinkFilter)
        ),
    m_pInputPin(NULL)
{
    _ASSERT(pIDataBridge != NULL);

    m_pIDataBridge = pIDataBridge;
    m_pIDataBridge->AddRef();
}

CTAPIBridgeSinkFilter::~CTAPIBridgeSinkFilter()
{
    _ASSERT(m_pIDataBridge != NULL);

    m_pIDataBridge->Release();

    if (m_pInputPin)
    {
        delete m_pInputPin;
    }
}


int CTAPIBridgeSinkFilter::GetPinCount()
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPinCount().
    Get the total number of pins on this filter. 

Arguments:

    Nothing.

Return Value:

    The number of pins.

--*/
{
    // There is only one pin on this filter.
    return 1;
}

CBasePin * CTAPIBridgeSinkFilter::GetPin(
    int n
    )
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPin().
    Get the pin object at position n. n is zero based.

Arguments:

    n -
        The index of the pin, zero based.

Return Value:

    Returns a pointer to the pin object if the index is valid. Otherwise,
    NULL is returned. Note: the pointer doesn't add refcount.

--*/
{
    ENTER_FUNCTION("CTAPIBridgeSinkFilter::GetPin");

    BGLOG((BG_TRACE, 
        "%s, pin number:%d", __fxName, n));

    if (n != 0)
    {
        // there is only one pin on this filter.
        return NULL;
    }

    HRESULT hr;

    CAutoLock Lock(m_pLock);

    if (m_pInputPin == NULL)
    {
        hr = S_OK; // hr may not be set in constructor
        m_pInputPin = new CTAPIBridgeSinkInputPin(this, &m_Lock, &hr);
    
        if (m_pInputPin == NULL) 
        {
            BGLOG((BG_ERROR, "%s, out of memory.", __fxName));
            return NULL;
        }

        // If there was anything failed during the creation of the pin, delete it.
        if (FAILED(hr))
        {
            delete m_pInputPin;
            m_pInputPin = NULL;

            BGLOG((BG_ERROR, "%s, create pin failed. hr=%x.", __fxName, hr));
            return NULL;
        }
    }

    return m_pInputPin;
}

HRESULT CTAPIBridgeSinkFilter::ProcessSample(
    IN IMediaSample *pSample
    )
/*++

Routine Description:

    Process a sample from the input pin. This method just pass it on to the
    bridge source filter's IDataBridge interface

Arguments:

    pSample - The media sample object.

Return Value:

    HRESULT.

--*/
{
    _ASSERT(m_pIDataBridge != NULL);

    return m_pIDataBridge->SendSample(pSample);
}



CTAPIBridgeSourceFilter::CTAPIBridgeSourceFilter(
    IN  LPUNKNOWN pUnk, 
    OUT HRESULT *phr
    ) : 
    CBaseFilter(
        NAME("CTAPIBridgeSourceFilter"), 
        pUnk, 
        &m_Lock, 
        __uuidof(TAPIBridgeSourceFilter)
        ),
    m_pOutputPin(NULL)
{
}

CTAPIBridgeSourceFilter::~CTAPIBridgeSourceFilter()
{
    if (m_pOutputPin)
    {
        delete m_pOutputPin;
    }
}

STDMETHODIMP
CTAPIBridgeSourceFilter::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    Overrides CBaseFilter::NonDelegatingQueryInterface().
    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. 

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IDataBridge)) {

        return GetInterface(static_cast<IDataBridge*>(this), ppv);
    }
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
} 

int CTAPIBridgeSourceFilter::GetPinCount()
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPinCount().
    Get the total number of pins on this filter. 

Arguments:

    Nothing.

Return Value:

    The number of pins.

--*/
{
    // There is only one pin on this filter.
    return 1;
}

CBasePin * CTAPIBridgeSourceFilter::GetPin(
    int n
    )
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPin().
    Get the pin object at position n. n is zero based.

Arguments:

    n - The index of the pin, zero based.

Return Value:

    Returns a pointer to the pin object if the index is valid. Otherwise,
    NULL is returned. Note: the pointer doesn't add refcount.

--*/
{
    ENTER_FUNCTION("CTAPIBridgeSourceFilter::GetPin");

    BGLOG((BG_TRACE, 
        "%s, pin number:%d", __fxName, n));

    if (n != 0)
    {
        // there is only one pin on this filter.
        return NULL;
    }

    HRESULT hr;

    CAutoLock Lock(m_pLock);

    if (m_pOutputPin == NULL)
    {
        hr = S_OK; // hr may not be set in constructor
        m_pOutputPin = new CTAPIBridgeSourceOutputPin(this, &m_Lock, &hr);
    
        if (m_pOutputPin == NULL) 
        {
            BGLOG((BG_ERROR, "%s, out of memory.", __fxName));
            return NULL;
        }

        // If there was anything failed during the creation of the pin, delete it.
        if (FAILED(hr))
        {
            delete m_pOutputPin;
            m_pOutputPin = NULL;

            BGLOG((BG_ERROR, "%s, create pin failed. hr=%x.", __fxName, hr));
            return NULL;
        }
    }

    return m_pOutputPin;
}

// override GetState to report that we don't send any data when paused, so
// renderers won't starve expecting that
//
STDMETHODIMP CTAPIBridgeSourceFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused)
        return VFW_S_CANT_CUE;
    else
        return S_OK;
}


HRESULT CTAPIBridgeSourceFilter::SendSample(
    IN IMediaSample *pSample
    )
/*++

Routine Description:

    Process a sample from the bridge sink filter. The base implementation just
    deliver it directly to the next filter.

Arguments:

    pSample - The media sample object.

Return Value:

    HRESULT.

--*/
{
    CAutoLock Lock(m_pLock);
    
    // we don't deliver anything if the filter is not in running state.
    if (m_State != State_Running) 
    {
        return S_OK;
    }

    _ASSERT(m_pOutputPin != NULL);

    return m_pOutputPin->Deliver(pSample);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgbase.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgbase.h

Abstract:

    Definitions of the base classes of the bridge filters.

Author:

    Mu Han (muhan) 11/12/1998

--*/

#ifndef _BGBASE_H_
#define _BGBASE_H_

class CTAPIBridgeSinkInputPin;
class CTAPIBridgeSourceOutputPin;
class CTAPIBridgeSinkFilter;
class CTAPIBridgeSourceFilter;

class CTAPIBridgeSinkInputPin : 
    public CBaseInputPin
{
public:
    DECLARE_IUNKNOWN

    CTAPIBridgeSinkInputPin(
        IN CTAPIBridgeSinkFilter *pFilter,
        IN CCritSec *pLock,
        OUT HRESULT *phr
        );
    
    // override CBaseInputPin methods.
    STDMETHOD (GetAllocatorRequirements)(OUT ALLOCATOR_PROPERTIES *pProperties);

    STDMETHOD (ReceiveCanBlock) () { return S_FALSE; }

    STDMETHOD (Receive) (IN IMediaSample *pSample);

    // CBasePin stuff
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);
};

    // the interface to pass dat from the sink filter to the source filter.
interface DECLSPEC_UUID("afb2050e-1ecf-4a97-8753-54e78b6c7bc4") DECLSPEC_NOVTABLE
IDataBridge : public IUnknown
{
    STDMETHOD (SendSample) (
        IN  IMediaSample *pSample
        ) PURE;
};

struct DECLSPEC_UUID("8cdf1491-b5ab-49fb-b51f-eda6043d11be") TAPIBridgeSinkFilter;

class DECLSPEC_NOVTABLE CTAPIBridgeSinkFilter : 
    public CBaseFilter
{
public:
    DECLARE_IUNKNOWN

    CTAPIBridgeSinkFilter(
        IN LPUNKNOWN        pUnk, 
        IN IDataBridge *    pIDataBridge, 
        OUT HRESULT *       phr
        );

    ~CTAPIBridgeSinkFilter();

    // Pin enumeration functions.
    CBasePin * GetPin(int n);
    int GetPinCount();
    
    // methods called by the input pin.
    virtual HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType) PURE;
    virtual HRESULT CheckMediaType(IN const CMediaType *pMediatype) PURE;
    virtual HRESULT ProcessSample(IN IMediaSample *pSample);

protected:

    // The lock for the filter and the pin.
    CCritSec                    m_Lock;

    // The filter's input pin.
    CTAPIBridgeSinkInputPin *   m_pInputPin;
    IDataBridge *               m_pIDataBridge;
};


class CTAPIBridgeSourceOutputPin : 
    public CBaseOutputPin,
    public IAMBufferNegotiation,
    public IAMStreamConfig
{
public:
    DECLARE_IUNKNOWN

    CTAPIBridgeSourceOutputPin(
        IN CTAPIBridgeSourceFilter *pFilter,
        IN CCritSec *pLock,
        OUT HRESULT *phr
        );

    ~CTAPIBridgeSourceOutputPin ();

    STDMETHOD (NonDelegatingQueryInterface) (
        IN REFIID  riid,
        OUT PVOID*  ppv
        );

    // CBasePin stuff
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediaType);

    // CBaseOutputPin stuff
    HRESULT DecideBufferSize(
        IMemAllocator * pAlloc,
        ALLOCATOR_PROPERTIES * ppropInputRequest
        );

    // IAMBufferNegotiation stuff
    STDMETHOD (SuggestAllocatorProperties) (IN const ALLOCATOR_PROPERTIES *pprop);
    STDMETHOD (GetAllocatorProperties) (OUT ALLOCATOR_PROPERTIES *pprop);

    // IAMStreamConfig stuff
    STDMETHOD (SetFormat) (IN AM_MEDIA_TYPE *pmt);
    STDMETHOD (GetFormat) (OUT AM_MEDIA_TYPE **ppmt);
    STDMETHOD (GetNumberOfCapabilities) (OUT int *piCount, OUT int *piSize);
    STDMETHOD (GetStreamCaps) (IN int iIndex, OUT AM_MEDIA_TYPE **ppmt, BYTE *pSCC);

};

struct DECLSPEC_UUID("9a712df9-50d0-4ca3-842e-6dc3d3b4b5a8") TAPIBridgeSourceFilter;

class DECLSPEC_NOVTABLE CTAPIBridgeSourceFilter : 
    public CBaseFilter,
    public IDataBridge
    {
public:
    DECLARE_IUNKNOWN

    CTAPIBridgeSourceFilter(
        IN LPUNKNOWN pUnk, 
        OUT HRESULT *phr
        );

    ~CTAPIBridgeSourceFilter();

    STDMETHOD (NonDelegatingQueryInterface) (
        IN REFIID  riid,
        OUT PVOID*  ppv
        );

    // Pin enumeration functions.
    CBasePin * GetPin(int n);
    int GetPinCount();

    // Overrides CBaseFilter methods.
    STDMETHOD (GetState) (DWORD dwMSecs, FILTER_STATE *State);

    // methods called by the output pins.
    virtual HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    virtual HRESULT CheckMediaType(IN const CMediaType *pMediatype);

    // method for IDataBridge
    STDMETHOD (SendSample) (
        IN  IMediaSample *pSample
        );

    // audio related methods are moved into CTAPIAudioBridgeSourceFilter
    // IAMBufferNegotiation stuff
    STDMETHOD (SuggestAllocatorProperties) (IN const ALLOCATOR_PROPERTIES *pprop) {return E_NOTIMPL;};
    STDMETHOD (GetAllocatorProperties) (OUT ALLOCATOR_PROPERTIES *pprop) {return E_NOTIMPL;};

    // IAMStreamConfig stuff
    STDMETHOD (SetFormat) (IN AM_MEDIA_TYPE *pmt) {return E_NOTIMPL;};
    STDMETHOD (GetFormat) (OUT AM_MEDIA_TYPE **ppmt) {return E_NOTIMPL;};

protected:

    // The lock for the filter and the pin.
    CCritSec                m_Lock;

    // The filter's output pin.
    CTAPIBridgeSourceOutputPin *   m_pOutputPin;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgdebug.cpp ===
/*++

Module Name

    bgdebug.cpp

Description

    Implements functions used for debugging

Note

    Revised based on msplog.cpp

--*/

#include "stdafx.h"
#include <stdio.h>

#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwDebuggerMask      = 0;


BOOL BGLogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
		DWORD      dwDataSize = sizeof (DWORD);
		DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

void BGLogDeRegister()
{
    sg_dwTracingToDebugger = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void BGLogPrint(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...)
/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    static char * message[24] = 
    {
        "ERROR", 
        "WARNING", 
        "INFO", 
        "TRACE", 
        "EVENT",
        "INVALID TRACE LEVEL"
    };

    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {
        switch(dwDbgLevel)
        {
        case BG_ERROR: dwIndex = 0; break;
        case BG_WARN:  dwIndex = 1; break;
        case BG_INFO:  dwIndex = 2; break;
        case BG_TRACE: dwIndex = 3; break;
        case BG_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  message[dwIndex]);

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        switch(dwDbgLevel)
        {
        case BG_ERROR: dwIndex = 0; break;
        case BG_WARN:  dwIndex = 1; break;
        case BG_INFO:  dwIndex = 2; break;
        case BG_TRACE: dwIndex = 3; break;
        case BG_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        wsprintfA(szTraceBuf, "[%s] %s", message[dwIndex], lpszFormat);

        va_list arglist;
        va_start(arglist, lpszFormat);
        TraceVprintfExA(sg_dwTraceID, dwDbgLevel, szTraceBuf, arglist);
        va_end(arglist);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgvideo.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgvideo.cpp

Abstract:

    Implementation of the Video bridge filters.

Author:

    Mu Han (muhan) 11/16/1998

--*/

#include "stdafx.h"

CTAPIVideoBridgeSinkFilter::CTAPIVideoBridgeSinkFilter(
    IN LPUNKNOWN        pUnk, 
    IN IDataBridge *    pIDataBridge, 
    OUT HRESULT *       phr
    ) 
    : CTAPIBridgeSinkFilter(pUnk, pIDataBridge, phr)
{
}

HRESULT CTAPIVideoBridgeSinkFilter::CreateInstance(
    IN IDataBridge *    pIDataBridge, 
    OUT IBaseFilter ** ppIBaseFilter
    )
/*++

Routine Description:

    This method create a instance of the bridge's sink filter.

Arguments:

    ppIBaseFilter - the returned filter interface pointer.

Return Value:

    E_OUTOFMEMORY - no memory for the new object.

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSinkFilter::CreateInstance");

    BGLOG((BG_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;
    CUnknown* pUnknown = new CTAPIVideoBridgeSinkFilter(NULL, pIDataBridge, &hr);
                
    if (pUnknown == NULL) 
    {
        hr = E_OUTOFMEMORY;
        DbgLog((LOG_ERROR, 0, 
            "%s, out of memory creating the filter", 
            __fxName));
    }
    else if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, 
            "%s, the filter's constructor failed, hr:%d", 
            __fxName, hr));

        delete pUnknown;
    }
    else
    {
        pUnknown->NonDelegatingAddRef();

        hr = pUnknown->NonDelegatingQueryInterface(
            __uuidof(IBaseFilter), (void **)ppIBaseFilter
            );

        pUnknown->NonDelegatingRelease();
    }

    BGLOG((BG_TRACE, 
        "%s, returning:%p, hr:%x", __fxName, *ppIBaseFilter, hr));

    return hr;
} 

HRESULT CTAPIVideoBridgeSinkFilter::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
/*++

Routine Description:

    Get the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based..
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSinkFilter::GetMediaType");

    BGLOG((BG_TRACE, 
        "%s, iPosition:%d, pMediaType:%p", 
        __fxName, iPosition, pMediaType));

    ASSERT(!IsBadWritePtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    HRESULT hr;

    if (iPosition == 0)
    {
        pMediaType->majortype = __uuidof(MEDIATYPE_RTP_Single_Stream);
        pMediaType->subtype = GUID_NULL;
        hr = S_OK;
    }
    else
    {
        hr = VFW_S_NO_MORE_ITEMS;
    }

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIVideoBridgeSinkFilter::CheckMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    Check the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSinkFilter::CheckMediaType");

    BGLOG((BG_TRACE, 
        "%s, pMediaType:%p", __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    // H.263 is not published, ignore checking here
    HRESULT hr = S_OK;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


CTAPIVideoBridgeSourceFilter::CTAPIVideoBridgeSourceFilter(
    IN LPUNKNOWN        pUnk, 
    OUT HRESULT *       phr
    ) 
    : CTAPIBridgeSourceFilter(pUnk, phr),
      m_dwSSRC(0),
      m_lWaitTimer(I_FRAME_TIMER),
      m_fWaitForIFrame(FALSE)
{
}

HRESULT CTAPIVideoBridgeSourceFilter::CreateInstance(
    OUT IBaseFilter ** ppIBaseFilter
    )
/*++

Routine Description:

    This method create a instance of the bridge's sink filter.

Arguments:

    ppIBaseFilter - the returned filter interface pointer.

Return Value:

    E_OUTOFMEMORY - no memory for the new object.

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSourceFilter::CreateInstance");

    BGLOG((BG_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;
    CUnknown* pUnknown = new CTAPIVideoBridgeSourceFilter(NULL, &hr);
                
    if (pUnknown == NULL) 
    {
        hr = E_OUTOFMEMORY;
        DbgLog((LOG_ERROR, 0, 
            "%s, out of memory creating the filter", 
            __fxName));
    }
    else if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, 
            "%s, the filter's constructor failed, hr:%d", 
            __fxName, hr));

        delete pUnknown;
    }
    else
    {
        pUnknown->NonDelegatingAddRef();

        hr = pUnknown->NonDelegatingQueryInterface(
            __uuidof(IBaseFilter), (void **)ppIBaseFilter
            );

        pUnknown->NonDelegatingRelease();
    }

    BGLOG((BG_TRACE, 
        "%s, returning:%p, hr:%x", __fxName, *ppIBaseFilter, hr));

    return hr;
} 

HRESULT CTAPIVideoBridgeSourceFilter::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
/*++

Routine Description:

    Get the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based..
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSourceFilter::GetMediaType");

    BGLOG((BG_TRACE, 
        "%s, iPosition:%d, pMediaType:%p", 
        __fxName, iPosition, pMediaType));

    ASSERT(!IsBadWritePtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    HRESULT hr;
    
    if (iPosition == 0)
    {
        pMediaType->majortype = __uuidof(MEDIATYPE_RTP_Single_Stream);
        pMediaType->subtype = GUID_NULL;
        hr = S_OK;
    }
    else
    {
        hr = VFW_S_NO_MORE_ITEMS;
    }

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIVideoBridgeSourceFilter::CheckMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    Check the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSourceFilter::CheckMediaType");

    BGLOG((BG_TRACE, 
        "%s, pMediaType:%p", __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    // media type H.263 is not published, ignore checking
    HRESULT hr = S_OK;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}

BOOL IsIFrame(IN const BYTE * pPacket, IN long lPacketLength)
{
    BYTE *pH263PayloadHeader = (BYTE*)(pPacket + sizeof(RTP_HEADER));

    // Header in mode A
    // 0                   1                   2                   3
    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //|F|P|SBIT |EBIT | SRC | R       |I|A|S|DBQ| TRB |    TR         |
    //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    // If I is 1, it is a key frame.

    return (BOOL)(pH263PayloadHeader[2] & 0x80);
}

STDMETHODIMP CTAPIVideoBridgeSourceFilter::Run(REFERENCE_TIME tStart)
/*++

Routine Description:

    start the filter 

Arguments:

    Nothing.

Return Value:

    S_OK.
--*/
{
    m_dwSSRC = 0;
    m_fWaitForIFrame = FALSE;
    m_lWaitTimer = 0;

    return CBaseFilter::Run(tStart);
}

HRESULT CTAPIVideoBridgeSourceFilter::SendSample(
    IN IMediaSample *pSample
    )
/*++

Routine Description:

    Process a sample from the bridge sink filter. We need to look for I-frames
    when the SSRC changes.

Arguments:

    pSample - The media sample object. Assumption: it has to contain an RTP
        packet that has H.263 data in it.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSourceFilter::SendSample");

    CAutoLock Lock(m_pLock);
    
    // we don't deliver anything if the filter is not in running state.
    if (m_State != State_Running) 
    {
        return S_OK;
    }

    ASSERT(pSample != NULL);

    BYTE *pPacket;
    HRESULT hr;

    if (FAILED (hr = pSample->GetPointer (&pPacket)))
    {
        BGLOG ((BG_ERROR, "%s failed to get buffer pointer from input sample %p",
            __fxName, pSample));
        return hr;
    }
   
    long lPacketSize = pSample->GetActualDataLength();
    const long H263PayloadHeaderLength = 4;

    if (lPacketSize < sizeof(RTP_HEADER) + H263PayloadHeaderLength)
    {
        BGLOG ((BG_ERROR, "%s get a bad RTP packet %p",
            __fxName, pSample));
        return E_UNEXPECTED;
    }

    RTP_HEADER *pRTPHeader = (RTP_HEADER *)pPacket;

    if (m_dwSSRC == 0)
    {
        m_dwSSRC = pRTPHeader->dwSSRC;
    }
    else if (m_dwSSRC != pRTPHeader->dwSSRC)
    {
        m_dwSSRC = pRTPHeader->dwSSRC;
        BGLOG ((BG_TRACE, "%s new SSRC detected", __fxName, m_dwSSRC));

        // the source changed, we need to wait for an I-frame
        if (IsIFrame(pPacket, lPacketSize))
        {
            // we got an I-Frame
            m_fWaitForIFrame = FALSE;
            BGLOG ((BG_TRACE, "%s switched to %x", __fxName, m_dwSSRC));
        }
        else
        {
            m_fWaitForIFrame = TRUE;
            m_lWaitTimer = I_FRAME_TIMER;

            // discard the frame.
            return S_FALSE;
        }

    }
    else if (m_fWaitForIFrame)
    {
        if (IsIFrame(pPacket, lPacketSize))
        {
            // we got an I-Frame
            m_fWaitForIFrame = FALSE;
            BGLOG ((BG_TRACE, "%s switched to %x", __fxName, m_dwSSRC));
        }
        else
        {
            // this is not an I frame,
            m_lWaitTimer --;
            if (m_lWaitTimer > 0)
            {
                // discard the frame.
                return S_FALSE;
            }
            BGLOG ((BG_TRACE, "%s switched to because of timeout %x", 
                __fxName, m_dwSSRC));
        }
    }


    _ASSERT(m_pOutputPin != NULL);
    return m_pOutputPin->Deliver(pSample);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgdebug.h ===
/*++

Module Name

    bgdebug.h

Description

    Defines functions used for debugging

Note

    Revised based on msplog.h

--*/

#ifndef _BGDEBUG_H
#define _BGDEBUG_H

    #include <rtutils.h>

    #define BG_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define BG_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define BG_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define BG_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define BG_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL BGLogRegister(LPCTSTR szName);
    void BGLogDeRegister();
    void BGLogPrint(DWORD dwDbgLevel, LPCSTR DbgMessage, ...);

#ifdef BGDEBUG

    #define BGLOGREGISTER(arg) BGLogRegister(arg)
    #define BGLOGDEREGISTER() BGLogDeRegister()
    #define BGLOG(arg) BGLogPrint arg

#else // BGDEBUG

    #define BGLOGREGISTER(arg)
    #define BGLOGDEREGISTER()
    #define BGLOG(arg)

#endif // BGDEBUG

#endif // _BGDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bridge.cpp ===
// bridge.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f bridgeps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
//#include "bridge.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

//#include "bridge_i.c"
#include "ConfBridge.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(ConfBridge), CConfBridge)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        BGLOGREGISTER(_T("bridge"));
        _Module.Init(ObjectMap, hInstance); //@@, &LIBID_BRIDGELib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        BGLOGDEREGISTER();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgvideo.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgvideo.h

Abstract:

    Definitions for the video bridge filters

Author:

    Mu Han (muhan) 11/12/1998

--*/

#ifndef _BGVIDEO_H_
#define _BGVIDEO_H_


class CTAPIVideoBridgeSinkFilter :
    public CTAPIBridgeSinkFilter 
{
public:

    CTAPIVideoBridgeSinkFilter(
        IN LPUNKNOWN        pUnk, 
        IN IDataBridge *    pIDataBridge, 
        OUT HRESULT *       phr
        );

    static HRESULT CreateInstance(
        IN IDataBridge *    pIDataBridge, 
        OUT IBaseFilter ** ppIBaseFilter
        );

    // methods called by the input pin.
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);
};


class CTAPIVideoBridgeSourceFilter : 
    public CTAPIBridgeSourceFilter
    {
public:
    CTAPIVideoBridgeSourceFilter(
        IN LPUNKNOWN pUnk, 
        OUT HRESULT *phr
        );

    static HRESULT CreateInstance(
        OUT IBaseFilter ** ppIBaseFilter
        );

    // Overrides CBaseFilter methods.
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // override the IDataBridge methods.
    STDMETHOD (SendSample) (
        IN  IMediaSample *pSample
        );

    // methods called by the output pin.
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);

private:
    DWORD   m_dwSSRC;
    long    m_lWaitTimer;
    BOOL    m_fWaitForIFrame;
};

// switch anyway if we don't have a I-Frame in 60 seconds.
const I_FRAME_TIMER = 60;

/*  This is the RTP header according to RFC 1889
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

typedef struct 
{                             
    WORD            CSRCCount:4;
    WORD            HeaderExtensionFlag:1;
    WORD            PaddingFlag:1;
    WORD            VersionType:2;
    WORD            PayLoadType:7;
    WORD            MarkerBit:1;

    WORD            wSequenceNumber;
    DWORD           dwTimeStamp;
    DWORD           dwSSRC;

} RTP_HEADER;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bridgetm.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bridgetm.h

Abstract:

    Definitions for the bridge terminals.

Author:

    Mu Han (muhan) 11/12/1998

--*/

#ifndef _BRIDGETERM_H_
#define _BRIDGETERM_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// CIPConfBaseTerminal                                                           
//                                                                         
//                                                                         
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CIPConfBaseTerminal : 
    virtual public CComObjectRootEx<CComMultiThreadModelNoCS>, // we have our own CS implementation
    public IDispatchImpl<ITTerminal, &IID_ITTerminal, &LIBID_TAPI3Lib>,
    public ITTerminalControl
{

BEGIN_COM_MAP(CIPConfBaseTerminal)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITTerminal)

    COM_INTERFACE_ENTRY(ITTerminalControl)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

public:

    CIPConfBaseTerminal(
        const GUID &        ClassID,
        TERMINAL_DIRECTION  TerminalDirection,
        TERMINAL_TYPE       TerminalType,
        DWORD               dwMediaType
        );

    HRESULT FinalConstruct();
    virtual ~CIPConfBaseTerminal();

public:
// ITTerminal -- COM interface for use by MSP or application
    STDMETHOD(get_TerminalClass)(OUT  BSTR *pVal);
    STDMETHOD(get_TerminalType) (OUT  TERMINAL_TYPE *pVal);
    STDMETHOD(get_State)        (OUT  TERMINAL_STATE *pVal);
    STDMETHOD(get_Name)         (OUT  BSTR *pVal);
    STDMETHOD(get_MediaType)    (OUT  long * plMediaType);
    STDMETHOD(get_Direction)    (OUT  TERMINAL_DIRECTION *pDirection);

// ITTerminalControl -- COM interface for use by MSP only

    STDMETHOD (get_AddressHandle) (
            OUT     MSP_HANDLE    * phtAddress
            );

    STDMETHOD (CompleteConnectTerminal) (void);

    STDMETHOD (RunRenderFilter) (void);

    STDMETHOD (StopRenderFilter) (void);

public:
    HRESULT Initialize(
            IN  WCHAR *             strName,
            IN  MSP_HANDLE          htAddress,
            IN  DWORD               dwMediaType
            );
protected:
    void Lock()     { EnterCriticalSection(&m_CritSec); }
    void Unlock()   { LeaveCriticalSection(&m_CritSec); }

protected:
    // The lock that protects the data members.
    CRITICAL_SECTION    m_CritSec;
    BOOL                m_fCritSecValid;

    // these five members need to be set by the derived class.
    GUID                m_TerminalClassID;
    TERMINAL_DIRECTION  m_TerminalDirection;
    TERMINAL_TYPE       m_TerminalType;
    TERMINAL_STATE      m_TerminalState;
    DWORD               m_dwMediaType;

    WCHAR               m_szName[MAX_PATH + 1];
    MSP_HANDLE          m_htAddress;

    // Pointer to the free threaded marshaler.
    IUnknown *          m_pFTM;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// CIPConfBridgeTerminal                                                           
//                                                                         
//                                                                         
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef enum
{
	SOURCE,
	SINK
} FILTER_TYPE;

class CIPConfBridgeTerminal : 
    public CIPConfBaseTerminal
{

public:
    CIPConfBridgeTerminal();

    virtual ~CIPConfBridgeTerminal();

    static HRESULT CreateTerminal(
        IN  DWORD           dwMediaType,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal    **ppTerm
        );

    HRESULT Initialize (
        IN  DWORD           dwMediaType,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHOD (ConnectTerminal) (
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved,
        IN OUT  DWORD          * pdwNumPins,
        OUT     IPin          ** ppPins
        );

    STDMETHOD (DisconnectTerminal) (
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        );

protected:
    HRESULT CreateFilters();

	HRESULT AddFilter(
		IN		FILTER_TYPE		 FilterType,
		IN      IGraphBuilder  * pGraph,
		OUT     IPin          ** ppPins
		);

protected:

    // The sink filter is the data sink for the upstream graph.
	IGraphBuilder *     m_pUpStreamGraph;
    IBaseFilter *       m_pSinkFilter;
    IPin*				m_pSinkInputPin;

    // The source filter is the data source for the upstream graph.
    IGraphBuilder *     m_pDownStreamGraph;
    IBaseFilter *       m_pSourceFilter;
    IPin*				m_pSourceOutputPin;
};


#endif // _IPConfTERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\confbridge.h ===
// ConfBridge.h : Declaration of the CConfBridge

#ifndef __CONFBRIDGE_H_
#define __CONFBRIDGE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CConfBridge
class ATL_NO_VTABLE CConfBridge : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CConfBridge, &__uuidof(ConfBridge)>,
	public IConfBridge
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_CONFBRIDGE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

public:

BEGIN_COM_MAP(CConfBridge)
	COM_INTERFACE_ENTRY(IConfBridge)
END_COM_MAP()

	CConfBridge()
	{
	}

    STDMETHOD (CreateBridgeTerminal) (
        long lMediaType,
        ITTerminal **ppTerminal
    );

};

#endif //__CONFBRIDGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bridgetm.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bridgetm.cpp

Abstract:

    Implementations for the bridge terminals.

Author:

    Mu Han (muhan) 11/12/99

--*/

#include "stdafx.h"

HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree = TRUE // param not used
    )
/*++

Routine Description:

    Find a input pin or output pin on a filter.

Arguments:
    
    pIFilter    - the filter that has pins.

    ppIPin      - the place to store the returned interface pointer.

    direction   - PINDIR_INPUT or PINDIR_OUTPUT.

    bFree       - look for a free pin or not.

Return Value:

    HRESULT

--*/
{
    _ASSERTE(ppIPin != NULL);

    HRESULT hr;
    DWORD dwFeched;

    // Get the enumerator of pins on the filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pIFilter->EnumPins(&pIEnumPins)))
    {
        BGLOG((BG_ERROR, "enumerate pins on the filter %x", hr));
        return hr;
    }

    IPin * pIPin = NULL;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &dwFeched) != S_OK)
        {
            BGLOG((BG_ERROR, "find pin on filter."));
            return E_FAIL;
        }
        if (0 == dwFeched)
        {
            BGLOG((BG_ERROR, "get 0 pin from filter."));
            return E_FAIL;
        }

        PIN_DIRECTION dir;
        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            BGLOG((BG_ERROR, "query pin direction. %x", hr));
            pIPin->Release();
            return hr;
        }
        if (direction == dir)
        {
            if (!bFree)
            {
                break;
            }

            // Check to see if the pin is free.
            CComPtr<IPin> pIPinConnected;
            hr = pIPin->ConnectedTo(&pIPinConnected);
            if (pIPinConnected == NULL)
            {
                break;
            }
        }
        pIPin->Release();
    }

    *ppIPin = pIPin;

    return S_OK;
}

CIPConfBaseTerminal::CIPConfBaseTerminal(
        const GUID &        ClassID,
        TERMINAL_DIRECTION  TerminalDirection,
        TERMINAL_TYPE       TerminalType,
        DWORD               dwMediaType
        )
    : m_fCritSecValid(FALSE)
    , m_TerminalClassID(ClassID)
    , m_TerminalDirection(TD_BIDIRECTIONAL)
    , m_TerminalType(TerminalType)
    , m_TerminalState(TS_NOTINUSE)
    , m_dwMediaType(dwMediaType)
    , m_pFTM(NULL)
    , m_htAddress(NULL)
{
    BGLOG((BG_TRACE, "CIPConfBaseTerminal::CIPConfBaseTerminal() called"));
    m_szName[0] = TEXT('\0');
}

HRESULT CIPConfBaseTerminal::FinalConstruct()
/*++

Routine Description:

    Finish the initialization of the object. If anything fails, this object
    will be deleted.

Arguments:
    
    nothing.

Return Value:

    S_OK
    E_OUTOFMEMORY
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::FinalConstruct");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    m_fCritSecValid = TRUE;

    __try
    {
        InitializeCriticalSection(&m_CritSec);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        m_fCritSecValid = FALSE;
    }

    if (!m_fCritSecValid)
    {
        BGLOG((BG_ERROR, "%s init critical section failed", __fxName));
        return E_OUTOFMEMORY;
    }

    HRESULT hr = CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pFTM
            );

    if ( FAILED(hr) )
    {
        BGLOG((BG_ERROR, "%s create ftm failed, hr=%x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

CIPConfBaseTerminal::~CIPConfBaseTerminal()
/*++

Routine Description:

    This is the destructor of the base terminal.

Arguments:
    
Return Value:

    S_OK
--*/
{

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    if (m_fCritSecValid)
    {
        DeleteCriticalSection(&m_CritSec);
    }
    
    BGLOG((BG_TRACE, 
        "CIPConfBaseTerminal::~CIPConfBaseTerminal() for %ws finished", m_szName));
}

HRESULT CIPConfBaseTerminal::Initialize(
    IN  WCHAR *             strName,
    IN  MSP_HANDLE          htAddress,
    IN  DWORD               dwMediaType
    )
/*++

Routine Description:

    This function sets the name and the address handle on the terminal.

Arguments:
    
    strName - The name of the terminal.

    htAddress - The handle that identifies the address object that this
                terminal belongs to.

Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::Initialize");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    m_htAddress         = htAddress;
    lstrcpynW(m_szName, strName, MAX_PATH);
    m_dwMediaType       = dwMediaType;

    BGLOG((BG_TRACE, "%s - exit S_OK", __fxName));
    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_Name(
    BSTR * pbsName
    )
/*++

Routine Description:

    This function return the name of the terminal.

Arguments:
    
    pbsName - A pointer to a BSTR to receive the terminal name.

Return Value:

    E_POINTER
    E_OUTOFMEMORY
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_Name");

    if ( IsBadWritePtr( pbsName, sizeof(BSTR) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pbsName = SysAllocString(m_szName);

    if ( *pbsName == NULL )
    {
        BGLOG((BG_ERROR, "%s, out of memory for name", __fxName)); 
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_State(
    TERMINAL_STATE * pVal
    )
/*++

Routine Description:

    This function return the state of the terminal.

Arguments:
    
    pVal - A pointer to a variable of type TERMINAL_STATE.

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_State");

    if ( IsBadWritePtr( pVal, sizeof(TERMINAL_STATE) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pVal = m_TerminalState;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_TerminalType(
    TERMINAL_TYPE * pVal
    )
/*++

Routine Description:

    This function return the type of the terminal.

Arguments:
    
    pVal - A pointer to a variable of type TERMINAL_TYPE.

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalType");
    
    if ( IsBadWritePtr( pVal, sizeof(TERMINAL_TYPE) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pVal = m_TerminalType;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_TerminalClass(
    BSTR * pbsClassID
    )
/*++

Routine Description:

    This function return the class of the terminal.

Arguments:
    
    pbsClassID - A pointer to a BSTR to receive the classID as a string.

Return Value:

    E_POINTER
    E_OUTOFMEMORY
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalClass");

    if ( IsBadWritePtr( pbsClassID, sizeof(BSTR) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    // Convert the CLSID to an string.
    WCHAR *pszName = NULL;
    
    HRESULT hr = ::StringFromCLSID(m_TerminalClassID, &pszName);

    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, "%s, failed to convert GUID, hr = %x", __fxName, hr));
        return hr;
    }

    // Put the string in a BSTR.
    BSTR bClassID = ::SysAllocString(pszName);

    // Free the OLE string.
    ::CoTaskMemFree(pszName);

    if (bClassID == NULL)
    {
        BGLOG((BG_ERROR, "%s, out of mem for class ID", __fxName));
        return E_OUTOFMEMORY;
    }

    *pbsClassID = bClassID;

    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::get_Direction(
    OUT  TERMINAL_DIRECTION *pDirection
    )
/*++

Routine Description:

    This function return the direction of the terminal.

Arguments:
    
    pDirection - A pointer to a variable of type TERMINAL_DIRECTION

Return Value:

    E_POINTER
    S_OK
--*/
{   
    ENTER_FUNCTION("CIPConfBaseTerminal::get_Direction");

    if ( IsBadWritePtr( pDirection, sizeof(TERMINAL_DIRECTION) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pDirection = m_TerminalDirection;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_MediaType(
    long * plMediaType
    )
/*++

Routine Description:

    This function return the media type of the terminal.

Arguments:
    
    plMediaType - A pointer to a variable of type long

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_MediaType");

    if ( IsBadWritePtr(plMediaType, sizeof(long) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }
    
    *plMediaType = (long) m_dwMediaType;

    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::get_AddressHandle(
        OUT     MSP_HANDLE    * phtAddress
        )
/*++

Routine Description:

    This function return the handle of the address that created this terminal.

Arguments:
    
    phtAddress - A pointer to a variable of type MSP_HANDLE

Return Value:

    E_POINTER
    S_OK
--*/
{
    // this function is only called from the MSP, so only assert here.    
    _ASSERT(!IsBadWritePtr(phtAddress, sizeof(MSP_HANDLE)));

    *phtAddress = m_htAddress;

    return S_OK;
}

STDMETHODIMP 
CIPConfBaseTerminal::CompleteConnectTerminal(void)
/*++

Routine Description:

    This function is called after a successful ConnectTerminal so that the 
    terminal can do post-connection intitialization. 

Arguments:

    nothing    

Return Value:

S_OK
--*/
{
    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::RunRenderFilter(void)
/*++

Routine Description:

    start the rightmost render filter in the terminal
    (needed for dynamic filter graphs)

Arguments:
    
Return Value:

    E_NOTIMPL
--*/
{
    return E_NOTIMPL;
}

STDMETHODIMP CIPConfBaseTerminal::StopRenderFilter(void)
/*++

Routine Description:

    stops the rightmost render filter in the terminal
    (needed for dynamic filter graphs)

Arguments:
    
Return Value:

    E_NOTIMPL
--*/
{
    return E_NOTIMPL;
}

 
CIPConfBridgeTerminal::CIPConfBridgeTerminal()
    : CIPConfBaseTerminal(
        __uuidof(IPConfBridgeTerminal),
        (TD_CAPTURE),
        TT_DYNAMIC,
        0)
    , m_pUpStreamGraph(NULL)
    , m_pSinkFilter(NULL)
    , m_pSinkInputPin(NULL)
    , m_pDownStreamGraph(NULL)
    , m_pSourceFilter(NULL)
    , m_pSourceOutputPin(NULL)
{
    BGLOG((BG_TRACE, "CIPConfBridgeTerminal::CIPConfBaseTerminal() called"));
}

CIPConfBridgeTerminal::~CIPConfBridgeTerminal()
/*++

Routine Description:

    This is the destructor of the bridge terminal.

Arguments:
    
Return Value:

    S_OK
--*/
{
    if (m_pUpStreamGraph)
    {
        m_pUpStreamGraph->Release();
    }
    
    if (m_pSinkFilter)
    {
        m_pSinkFilter->Release();
    }
  
    if (m_pSinkInputPin)
    {
        m_pSinkInputPin->Release();
    }
  
    if (m_pDownStreamGraph)
    {
        m_pDownStreamGraph->Release();
    }

    if (m_pSourceFilter)
    {
        m_pSourceFilter->Release();
    }

    if (m_pSourceOutputPin)
    {
        m_pSourceOutputPin->Release();
    }

    BGLOG((BG_TRACE, 
        "CIPConfBridgeTerminal::~CIPConfBridgeTerminal() for %ws finished", m_szName));
}

HRESULT CIPConfBridgeTerminal::CreateTerminal(
    IN  DWORD           dwMediaType,
    IN  MSP_HANDLE      htAddress,
    OUT ITTerminal      **ppTerm
    )
/*++

Routine Description:

    This method creates a bridge terminal

Arguments:

    dwMediaType - The media type of this terminal.

    htAddress - the handle to the address object.

    ppTerm - memory to store the returned terminal pointer.
    
Return Value:

    S_OK
    E_POINTER
--*/
{
    ENTER_FUNCTION("CIPConfBridgeTerminal::CreateTerminal");
    BGLOG((BG_TRACE, "%s, htAddress:%x", __fxName, htAddress));

    _ASSERT(!IsBadWritePtr(ppTerm, sizeof(ITTerminal *)));

    HRESULT hr;

    //
    // Create the terminal.
    //
    CMSPComObject<CIPConfBridgeTerminal> *pTerminal = NULL;

    hr = CMSPComObject<CIPConfBridgeTerminal>::CreateInstance(&pTerminal);
    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, 
            "%s can't create the terminal object hr = %8x", __fxName, hr));

        return hr;
    }


    // query for the ITTerminal interface
    ITTerminal *pITTerminal;
    hr = pTerminal->_InternalQueryInterface(__uuidof(ITTerminal), (void**)&pITTerminal);
    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, 
            "%s, query terminal interface failed, %x", __fxName, hr));
        delete pTerminal;

        return hr;
    }

    // initialize the terminal 
    hr = pTerminal->Initialize(
            dwMediaType,
            htAddress
            );

    if ( FAILED(hr) )
    {
        BGLOG((BG_ERROR, 
            "%s, Initialize failed; returning 0x%08x", __fxName, hr));

        pITTerminal->Release();
    
        return hr;
    }

    BGLOG((BG_TRACE, "%s, Bridge erminal %p created", __fxName, pITTerminal));

    *ppTerm = pITTerminal;

    return S_OK;
}

// max length of a bridge terminal name
#define MAX_BGTMNAME 80

HRESULT CIPConfBridgeTerminal::Initialize(
    IN  DWORD           dwMediaType,
    IN  MSP_HANDLE      htAddress
    )
{

    WCHAR pszTerminalName[MAX_BGTMNAME];
    int len;

    if (dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        len = LoadString (
            _Module.GetResourceInstance (),
            IDS_AUDBGNAME,
            pszTerminalName,
            MAX_BGTMNAME
            );
    }
    else if (dwMediaType == TAPIMEDIATYPE_VIDEO)
    {
        len = LoadString (
            _Module.GetResourceInstance (),
            IDS_VIDBGNAME,
            pszTerminalName,
            MAX_BGTMNAME
            );
    }
    else
    {
        LOG ((BG_ERROR, "CIPConfBridgeTerminal::Initialize receives unknown media type %d", dwMediaType));
        return E_INVALIDARG;
    }

    if (len == 0)
    {
        LOG ((BG_ERROR, "Failed to load bridge terminal name, media %d, err %d",
            dwMediaType, GetLastError ()));
        return E_UNEXPECTED;
    }

    return CIPConfBaseTerminal::Initialize(
        pszTerminalName, htAddress, dwMediaType
        );
}

HRESULT CIPConfBridgeTerminal::CreateFilters()
/*++

Routine Description:

    Create the two filters used in the terminal.

Arguments:
    
Return Value:

HRESULT
--*/
{
    ENTER_FUNCTION("CIPConfBridgeTerminal::CreateFilters");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    HRESULT hr;

    // Create the source filter.
    CComPtr <IBaseFilter> pSourceFilter;

    if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        hr = CTAPIAudioBridgeSourceFilter::CreateInstance(&pSourceFilter);
    }
    else
    {
        hr = CTAPIVideoBridgeSourceFilter::CreateInstance(&pSourceFilter);
    }

    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, "%s, Create source filter failed. hr=%x", __fxName, hr));
        return hr;
    }

    CComPtr <IDataBridge> pIDataBridge;
    hr = pSourceFilter->QueryInterface(&pIDataBridge);

    // this should never fail.
    _ASSERT(SUCCEEDED(hr));


    // Create the sink filter.
    CComPtr <IBaseFilter> pSinkFilter;

    if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        hr = CTAPIAudioBridgeSinkFilter::CreateInstance(pIDataBridge, &pSinkFilter);
    }
    else
    {
        hr = CTAPIVideoBridgeSinkFilter::CreateInstance(pIDataBridge, &pSinkFilter);
    }

    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, "%s, Create sink filter failed. hr=%x", __fxName, hr));
        return hr;
    }

    // Find the pins.
    CComPtr<IPin> pIPinOutput;
    if (FAILED(hr = ::FindPin(pSourceFilter, &pIPinOutput, PINDIR_OUTPUT)))
    {
        BGLOG((BG_ERROR, "%s, find output pin on sink filter. hr=%x", __fxName, hr));
        return hr;
    }

    CComPtr<IPin> pIPinInput;
    if (FAILED(hr = ::FindPin(pSinkFilter, &pIPinInput, PINDIR_INPUT)))
    {
        BGLOG((BG_ERROR, "%s, find input pin on sink filter. hr=%x", __fxName, hr));
        return hr;
    }

    // save the reference.
    m_pSinkFilter = pSinkFilter;
    m_pSinkFilter->AddRef();

    m_pSinkInputPin = pIPinInput;
    m_pSinkInputPin->AddRef();

    m_pSourceFilter = pSourceFilter;
    m_pSourceFilter->AddRef();

    m_pSourceOutputPin = pIPinOutput;
    m_pSourceOutputPin->AddRef();

    return S_OK;
}

HRESULT CIPConfBridgeTerminal::AddFilter(
        IN      FILTER_TYPE      FilterType,
        IN      IGraphBuilder  * pGraph,
        OUT     IPin          ** ppPins
        )
/*++

Routine Description:

    Add a filter into the graph provided by the stream and returning the pin
    that can be connected at the same time.

Arguments:
    
    FilterType - the type of the filter. Either the source or the sink.

    pGraph - The filter graph.

    ppPins  - A pointer to the buffer that can store the IPin pointer.

Return Value:

S_OK
TAPI_E_TERMINALINUSE - the terminal is in use.
--*/

{
    ENTER_FUNCTION("CIPConfBridgeTerminal::AddSourceFilter");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    // check to see if the terminal is already in use.
    if ((FilterType == SINK) && (m_pUpStreamGraph != NULL)
        || (FilterType == SOURCE) && (m_pDownStreamGraph != NULL))
    {
        BGLOG((BG_ERROR, "%s, terminal already in use", __fxName));

        return TAPI_E_TERMINALINUSE;
    }

    HRESULT hr;

    if (m_pSourceFilter == NULL)
    {
        // the filters have not been created, create them now.
        hr = CreateFilters();

        if (FAILED(hr))
        {
            BGLOG((BG_ERROR, "%s, can't Create filter, hr=%x", __fxName, hr));
            return hr;
        }
    }

    IBaseFilter *pFilter;
    IPin *pPin;

    if (FilterType == SINK)
    {
        pFilter = m_pSinkFilter;
        pPin = m_pSinkInputPin;
        m_pUpStreamGraph = pGraph;
        m_pUpStreamGraph->AddRef();
    }
    else
    {
        pFilter = m_pSourceFilter;
        pPin = m_pSourceOutputPin;
        m_pDownStreamGraph = pGraph;
        m_pDownStreamGraph->AddRef();
    }

    // add the filter to the graph.
    hr = pGraph->AddFilter(pFilter, NULL);
    if ( FAILED(hr) )
    {
        BGLOG((BG_ERROR, "%s, can't add filter to the graph hr=%x", __fxName, hr));
        return hr;
    }

    pPin->AddRef();
    *ppPins = pPin;

    return S_OK;
}

STDMETHODIMP CIPConfBridgeTerminal::ConnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved,
        IN OUT  DWORD          * pdwNumPins,
        OUT     IPin          ** ppPins
        )
/*++

Routine Description:

    This function is called by the MSP while trying to connect the filter in
    the terminal to the rest of the graph in the MSP. It adds the filter into
    the graph and returns the pins can be used by the MSP.

Arguments:
    
    pGraph - The filter graph.

    dwReserved - the direction for the connection.

    pdwNumPins - The maxinum number of pins the msp wants.

    ppPins  - A pointer to the buffer that can store the IPin pointers. If it
              is NULL, only the actual number of pins will be returned.

Return Value:

S_OK
TAPI_E_NOTENOUGHMEMORY - the buffer is too small.
TAPI_E_TERMINALINUSE - the terminal is in use.
--*/
{
    ENTER_FUNCTION("CIPConfBridgeTerminal::ConnectTerminal");
    BGLOG((BG_TRACE, 
        "%s entered, pGraph:%p, dwREserved:%p", __fxName, pGraph, dwReserved));

    // this function is only called from the MSP, so only assert here.    
    _ASSERT(!IsBadReadPtr(pGraph, sizeof(IGraphBuilder)));
    _ASSERT(!IsBadWritePtr(pdwNumPins, sizeof(DWORD)));

    // there is only one pin on each side of the bridge.
    const DWORD dwNumOfPins = 1;

    //
    // If ppPins is NULL, just return the number of pins and don't try to
    // connect the terminal.
    //
    if ( ppPins == NULL )
    {
        BGLOG((BG_TRACE, 
            "%s number of exposed pins:%d", __fxName, dwNumOfPins));
        *pdwNumPins = dwNumOfPins;
        return S_OK;
    }

    //
    // Otherwise, we have a pin return buffer. Check that the purported buffer
    // size is big enough and that the buffer is actually writable to the size
    // we need.
    //
    if ( *pdwNumPins < dwNumOfPins )
    {
        BGLOG((BG_ERROR, "%s not enough space to place pins.", __fxName));

        *pdwNumPins = dwNumOfPins;
        
        return TAPI_E_NOTENOUGHMEMORY;
    }

    _ASSERT(!IsBadWritePtr(ppPins, dwNumOfPins * sizeof(IPin *)));

    Lock();

    HRESULT hr;
    hr = AddFilter((dwReserved == TD_CAPTURE) ? SOURCE : SINK, pGraph, ppPins);

    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, "%s, AddFilter failed", __fxName));
    }
    else
    {
        m_TerminalState = TS_INUSE;
        *pdwNumPins = 1;
    }

    Unlock();

    BGLOG((BG_TRACE, "CIPConfBridgeTerminal::ConnectTerminal success"));
    return hr;
}

STDMETHODIMP 
CIPConfBridgeTerminal::DisconnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        )
/*++

Routine Description:

    This function is called by the MSP while trying to disconnect the filter in
    the terminal from the rest of the graph in the MSP. It adds the removes the
    filter from the graph and set the terminal free.

Arguments:
    
    pGraph - The filter graph. It is used for validation, to make sure the 
             terminal is disconnected from the same graph that it was 
             originally connected to.

    dwReserved - A reserved dword.

Return Value:

S_OK
E_INVALIDARG - wrong graph.

--*/
{
    ENTER_FUNCTION("CIPConfBridgeTerminal::DisconnectTerminal");
    BGLOG((BG_TRACE, 
        "%s entered, pGraph:%p, dwReserved:%d", __fxName, pGraph, dwReserved));

    if (pGraph == NULL)
    {
        BGLOG((BG_TRACE, "%s, bad graph pointer:%p", __fxName, pGraph));
        return E_INVALIDARG;
    }

    Lock();

    HRESULT hr;

    if (pGraph == m_pUpStreamGraph)
    {
        hr = pGraph->RemoveFilter(m_pSinkFilter);

        m_pUpStreamGraph->Release();
        m_pUpStreamGraph = NULL;
    }
    else if (pGraph == m_pDownStreamGraph)
    {
        hr = pGraph->RemoveFilter(m_pSourceFilter);

        m_pDownStreamGraph->Release();
        m_pDownStreamGraph = NULL;
    }
    else
    {
        BGLOG((BG_TRACE, "%s, wrong graph pointer:%p", __fxName, pGraph));

        Unlock();
        return E_INVALIDARG;
    }

    if ( FAILED(hr) )
    {
        BGLOG((BG_ERROR, 
            "%s, remove filter from graph failed; returning hr=%x", 
            __fxName, hr));
    }

    m_TerminalState = TS_NOTINUSE;

    Unlock();

    BGLOG((BG_TRACE, "%s succeeded", __fxName));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\inc\bridge.h ===
#ifndef __BRIDGE_H_
#define __BRIDGE_H_

struct DECLSPEC_UUID("D3672FA1-99F2-452B-B2BD-8CDCD9B84C3F") ConfBridge;
struct DECLSPEC_UUID("581d09e5-0b45-11d3-a565-00c04f8ef6e3") IPConfBridgeTerminal;

interface DECLSPEC_UUID("5d410fe1-3f6e-4e1a-8d6d-7caaa52d9e93") DECLSPEC_NOVTABLE 
IConfBridge : public IUnknown
{
    STDMETHOD (CreateBridgeTerminal) (
        IN  long lMediaType,
        OUT ITTerminal **ppTerminal
        ) PURE;
};

#define IID_IConfBridge (__uuidof(IConfBridge))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bridge.rc
//
#define IDS_PROJNAME                    100
#define IDR_CONFBRIDGE                  101
#define IDS_AUDBGNAME                   101
#define IDS_VIDBGNAME                   102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\confbridge.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ConfBridge.cpp

Abstract:

    Implementations for bridge terminal creation

Author:

    Qianbo Huai (qhuai) 1/21/2000

--*/

#include "stdafx.h"
#include <bridge.h>
#include "ConfBridge.h"

/*//////////////////////////////////////////////////////////////////////////////
    Creates bridge terminal
////*/
STDMETHODIMP
CConfBridge::CreateBridgeTerminal (
    long lMediaType,
    ITTerminal **ppTerminal
)
{
    ENTER_FUNCTION("CIPConfBridge::CreateBridgeTerminal");
    BGLOG((BG_TRACE, "%s entered", __fxName)); 

    if (IsBadWritePtr(ppTerminal, sizeof(void *)))
    {
        LOG ((BG_ERROR, "%x receives bad write pointer", __fxName));
        return E_POINTER;
    }

    HRESULT hr;

    // Make sure we support the requested media type.
    if ( ! IsValidSingleMediaType( (DWORD) lMediaType,
        TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO ) )
    {
        BGLOG((BG_ERROR, "%s, bad media type %d", __fxName, lMediaType));
        return E_INVALIDARG;
    }

    // create the bridge terminal with the desired media type.

    ITTerminal *pTerminal;
    hr = CIPConfBridgeTerminal::CreateTerminal(
        (DWORD)lMediaType,
        NULL, // msp address
        &pTerminal
        );

    if (FAILED (hr))
    {
        BGLOG ((BG_ERROR, "%s, Create bridge terminal failed. hr=%x", __fxName, hr));
        return E_INVALIDARG;
    }

    *ppTerminal = pTerminal;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__78E7EB26_CAE8_4888_BE56_540011CEB8F6__INCLUDED_)
#define AFX_STDAFX_H__78E7EB26_CAE8_4888_BE56_540011CEB8F6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <mspbase.h>
#include <streams.h>
#include <h323priv.h>
#include <bridge.h>
#include "bgdebug.h"
#include "bridgetm.h"
#include "bgbase.h"
#include "bgaudio.h"
#include "bgvideo.h"

#include "resource.h"

#ifdef BGDEBUG
#define ENTER_FUNCTION(s) \
    const CHAR __fxName[] = s
#else
#define ENTER_FUNCTION(s)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__78E7EB26_CAE8_4888_BE56_540011CEB8F6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test\bgcall.cpp ===
/*******************************************************************************

  Module: bgcall.cpp

  Author: Qianbo Huai

  Abstract:

    implements bridge call object

*******************************************************************************/

#include "stdafx.h"
#include "work.h"

#include <bridge.h>

// to change
const BSTR CLSID_String_BridgeTerminal = L"{581d09e5-0b45-11d3-a565-00c04f8ef6e3}";

/*//////////////////////////////////////////////////////////////////////////////
    constructor
////*/
CBridgeCall::CBridgeCall (CBridge *pBridge)
{
    m_pBridge = pBridge;
    m_pH323Call = NULL;
    m_pSDPCall = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
CBridgeCall::~CBridgeCall ()
{
    Clear ();
    m_pBridge = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
    select terminals and connect the call
////*/
HRESULT
CBridgeCall::BridgeCalls ()
{
    HRESULT hr;

    hr = SelectBridgeTerminals ();
    if (FAILED(hr))
        return hr;

    hr = SetupParticipantInfo ();
	if (FAILED(hr))
        return hr;

    hr = SetMulticastMode ();
	if (FAILED(hr))
        return hr;

    // connect h323 call
    hr = m_pH323Call->Answer ();
    if (FAILED(hr))
        return hr;

    // connect sdp call
    hr = m_pSDPCall->Connect (VARIANT_TRUE);
    if (FAILED(hr))
    {
        m_pH323Call->Disconnect (DC_NORMAL);
        return hr;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeCall::SelectBridgeTerminals ()
{
    HRESULT hr;
    ITAddress *pAddress = NULL;
    ITMSPAddress *pMSPAddress = NULL;
    ITTerminal *pH323ToSDPVideoBT = NULL;
    ITTerminal *pH323ToSDPAudioBT = NULL;
    ITTerminal *pSDPToH323VideoBT = NULL;
    ITTerminal *pSDPToH323AudioBT = NULL;

    ITStreamControl *pStreamControl = NULL;
    IEnumStream *pEnumStreams = NULL;
    ITStream *pStream = NULL;

    // get SDP address
    hr = m_pBridge->GetSDPAddress (&pAddress);
    if (FAILED(hr))
        return hr;

    // get MSP address
    hr = pAddress->QueryInterface (IID_ITMSPAddress, (void**)&pMSPAddress);
    if (FAILED(hr))
        return hr;

    IConfBridge *pBridge = NULL;
    // create CConfBridge
    hr = CoCreateInstance (
        __uuidof(ConfBridge),
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IConfBridge,
        (LPVOID *)&pBridge
        );
    if (FAILED(hr))
        return hr;

    // create terminal: video H323->SDP
    hr = pBridge->CreateBridgeTerminal (
//        (MSP_HANDLE)pMSPAddress,
//        CLSID_String_BridgeTerminal,
        TAPIMEDIATYPE_VIDEO,
//        TD_RENDER, // not used
        &pH323ToSDPVideoBT
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: audio H323->SDP
    hr = pBridge->CreateBridgeTerminal (
//        (MSP_HANDLE)pMSPAddress,
//        CLSID_String_BridgeTerminal,
        TAPIMEDIATYPE_AUDIO,
//        TD_RENDER, // not used
        &pH323ToSDPAudioBT
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: video SDP->H323
    hr = pBridge->CreateBridgeTerminal (
//        (MSP_HANDLE)pMSPAddress,
//        CLSID_String_BridgeTerminal,
        TAPIMEDIATYPE_VIDEO,
//        TD_RENDER, // not used
        &pSDPToH323VideoBT
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: audio SDP->H323
    hr = pBridge->CreateBridgeTerminal (
//        (MSP_HANDLE)pMSPAddress,
//        CLSID_String_BridgeTerminal,
        TAPIMEDIATYPE_AUDIO,
//        TD_RENDER, // not used
        &pSDPToH323AudioBT
        );
    if (FAILED(hr))
        goto Error;

    pMSPAddress->Release ();
    pMSPAddress = NULL;

    pAddress->Release ();
    pAddress = NULL;

    pBridge->Release ();
    pBridge = NULL;

    // get stream control on H323
    hr = m_pH323Call->QueryInterface (
        IID_ITStreamControl,
        (void **)&pStreamControl
        );
    if (FAILED(hr))
        goto Error;

    // get enum stream on H323
    hr = pStreamControl->EnumerateStreams (&pEnumStreams);
    if (FAILED(hr))
        goto Error;

    pStreamControl->Release ();
    pStreamControl = NULL;

    // iterate each stream on H323, select terminals
    while (S_OK == pEnumStreams->Next (1, &pStream, NULL))
    {
        if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_CAPTURE))
        {
            // video: h323 to sdp
            hr = pStream->SelectTerminal (pH323ToSDPVideoBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_RENDER))
        {
            // video: sdp to h323
            hr = pStream->SelectTerminal (pSDPToH323VideoBT);
            if (FAILED(hr))
                goto Error;

            IKeyFrameControl* pIKeyFrameControl;
            hr = pStream->QueryInterface(&pIKeyFrameControl);
            if (SUCCEEDED(hr))
            {
                hr = pIKeyFrameControl->PeriodicUpdatePicture(TRUE, 5);
                pIKeyFrameControl->Release();
            }


        }
        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_CAPTURE))
        {
            // audio: h323 to sdp
            hr = pStream->SelectTerminal (pH323ToSDPAudioBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_RENDER))
        {
            // video: sdp to h323
            hr = pStream->SelectTerminal (pSDPToH323AudioBT);
            if (FAILED(hr))
                goto Error;
        }
        pStream->Release ();
        pStream = NULL;
    }

    if (pStream)
    {
        pStream->Release ();
        pStream = NULL;
    }

    pEnumStreams->Release ();
    pEnumStreams = NULL;

    // get stream control on SDP
    hr = m_pSDPCall->QueryInterface (
        IID_ITStreamControl,
        (void **)&pStreamControl
        );
    if (FAILED(hr))
        goto Error;

    // get enum stream on SDP
    hr = pStreamControl->EnumerateStreams (&pEnumStreams);
    if (FAILED(hr))
        goto Error;

    pStreamControl->Release ();
    pStreamControl = NULL;

    // iterate each stream on SDP, select terminals
    while (S_OK == pEnumStreams->Next (1, &pStream, NULL))
    {
        if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_CAPTURE))
        {
            // video: sdp to h323
            hr = pStream->SelectTerminal (pSDPToH323VideoBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_RENDER))
        {
            // video: h323 to sdp
            hr = pStream->SelectTerminal (pH323ToSDPVideoBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_CAPTURE))
        {
            // audio: sdp to h323
            hr = pStream->SelectTerminal (pSDPToH323AudioBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_RENDER))
        {
            // video: h323 to sdp
            hr = pStream->SelectTerminal (pH323ToSDPAudioBT);
            if (FAILED(hr))
                goto Error;
        }
        pStream->Release ();
        pStream = NULL;
    }

Cleanup:
    // release streams
    if (pStream)
        pStream->Release ();
    if (pEnumStreams)
        pEnumStreams->Release ();
    if (pStreamControl)
        pStreamControl->Release ();
    
    // release terminals
    if (pH323ToSDPVideoBT)
        pH323ToSDPVideoBT->Release ();
    if (pH323ToSDPAudioBT)
        pH323ToSDPAudioBT->Release ();
    if (pSDPToH323VideoBT)
        pSDPToH323VideoBT->Release ();
    if (pSDPToH323AudioBT)
        pSDPToH323AudioBT->Release ();

    if (pBridge)
        pBridge->Release ();

    return hr;

Error:
    goto Cleanup;
}
        
HRESULT
CBridgeCall::SetupParticipantInfo ()
{
    HRESULT hr = S_OK;

    ITCallInfo *pCallInfo = NULL;
    BSTR CallerIDName = NULL;
    BSTR CallerIDNumber = NULL;
    
    ITLocalParticipant *pLocalParticipant = NULL;
    BSTR CName = NULL;

    // get the caller info from the H323 side.
    hr = m_pH323Call->QueryInterface(&pCallInfo);
    if (FAILED(hr)) goto cleanup;
    
    hr = pCallInfo->get_CallInfoString(CIS_CALLERIDNAME, &CallerIDName);
    if (FAILED(hr)) goto cleanup;

    hr = pCallInfo->get_CallInfoString(CIS_CALLERIDNUMBER, &CallerIDNumber);
    if (FAILED(hr)) goto cleanup;

    
    // construct the CName for the SDP side.
    CName = SysAllocStringLen(NULL, 
        SysStringLen(CallerIDName) + SysStringLen(CallerIDNumber) + 2);

    wsprintfW(CName, L"%ws@%ws", CallerIDName, CallerIDNumber);


    // set the CName on the SDP side.
    hr = m_pSDPCall->QueryInterface(&pLocalParticipant);
    if (FAILED(hr)) goto cleanup;

    hr = pLocalParticipant->put_LocalParticipantTypedInfo(
        PTI_CANONICALNAME, CName
        );
    if (FAILED(hr)) goto cleanup;

    hr = pLocalParticipant->put_LocalParticipantTypedInfo(
        PTI_NAME, CallerIDName
        );

    if (FAILED(hr)) goto cleanup;


cleanup:
    if (pCallInfo) pCallInfo->Release();
    if (CallerIDName) SysFreeString(CallerIDName);
    if (CallerIDNumber) SysFreeString(CallerIDNumber);
    
    if (pLocalParticipant) pLocalParticipant->Release();
    if (CName) SysFreeString(CName);

    return hr;
}

HRESULT
CBridgeCall::SetMulticastMode ()
{
    IMulticastControl * pIMulticastControl = NULL;
    
    HRESULT hr = m_pSDPCall->QueryInterface(&pIMulticastControl);
    if (FAILED(hr)) return hr;

    hr = pIMulticastControl->put_LoopbackMode(MM_SELECTIVE_LOOPBACK);

    pIMulticastControl->Release();

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    clear calls, return to initial state
////*/
void
CBridgeCall::Clear ()
{
    if (m_pH323Call)
    {
        m_pH323Call->Disconnect (DC_NORMAL);
        m_pH323Call->Release ();
        m_pH323Call = NULL;
    }
    if (m_pSDPCall)
    {
        m_pSDPCall->Disconnect (DC_NORMAL);
        m_pSDPCall->Release ();
        m_pSDPCall = NULL;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
BOOL CBridgeCall::IsStream (
    ITStream *pStream,
    long lMediaType,
    TERMINAL_DIRECTION tdDirection
    )
{
    long mediatype;
    TERMINAL_DIRECTION direction;

    if (FAILED (pStream->get_Direction(&direction)))
        return false;
    if (FAILED (pStream->get_MediaType(&mediatype)))
        return false;
    return ((direction == tdDirection) &&
           (mediatype == lMediaType));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test\bridge.cpp ===
/*******************************************************************************

  Module: bridge.cpp

  Author: Qianbo Huai

  Abstract:
  
    implements the class CBridge

*******************************************************************************/

#include "stdafx.h"
#include "work.h"

extern LPSTR glpCmdLine;

/*//////////////////////////////////////////////////////////////////////////////
    hard coded SDP
////*/
const WCHAR * const MySDP = L"\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=BridgeTestConf\n\
c=IN IP4 239.9.20.26/15\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
m=audio 20040 RTP/AVP 0 4\n\
";

const WCHAR * const MySDP2 = L"\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=BridgeTestConf2\n\
c=IN IP4 239.9.20.26/15\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
m=audio 20040 RTP/AVP 3\n\
";

/*//////////////////////////////////////////////////////////////////////////////
    initiates tapi and listens at h323 address
////*/
HRESULT
CBridge::InitTapi ()
{
    HRESULT hr;

    // init members
    m_pTapi = NULL;
    m_pH323Addr = NULL;
    m_pSDPAddr = NULL;
    m_pBridgeCall = new CBridgeCall (this);

    // create tapi
    hr = CoCreateInstance (
        CLSID_TAPI,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTAPI,
        (LPVOID *)&m_pTapi
        );
    if (FAILED(hr))
        return hr;

    // tapi initiate
    hr = m_pTapi->Initialize ();
    if (FAILED(hr))
        return hr;

    // associate event with listener
    CTAPIEventNotification *pEventNotif = NULL;
    IConnectionPointContainer *pContainer = NULL;
    IConnectionPoint *pPoint = NULL;
    IH323LineEx *pIH323LineEx = NULL;
    ULONG ulTapiEventAdvise;
    long lCallNotif;
    BSTR bstrAddrName = NULL;

    // create event notification
    pEventNotif = new CTAPIEventNotification;
    if (!pEventNotif)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    
    // get pointer container from tapi  
    hr = m_pTapi->QueryInterface (
        IID_IConnectionPointContainer,
        (void **)&pContainer
        );
    if (FAILED(hr))
        goto Error;

    // get connection point from container
    hr = pContainer->FindConnectionPoint (
        IID_ITTAPIEventNotification,
        &pPoint
        );
    if (FAILED(hr))
        goto Error;

    // advise event notification on connection pointer
    hr = pPoint->Advise (
        pEventNotif,
        &ulTapiEventAdvise
        );
    if (FAILED(hr))
        goto Error;

    // put event filter on tapi
    hr = m_pTapi->put_EventFilter (
        TE_CALLNOTIFICATION |
        TE_CALLSTATE |
        TE_CALLMEDIA |
        TE_PRIVATE
        );
    if (FAILED(hr))
        goto Error;

    // find h323 address
    bstrAddrName = SysAllocString (L"H323 Line");
    hr = FindAddress (
        0,
        bstrAddrName,
        TAPIMEDIATYPE_AUDIO,
        &m_pH323Addr
        );
    SysFreeString (bstrAddrName);
    if (FAILED(hr))
        goto Error;

    // check if it supports video
    BOOL fSupportsVideo;

    if (AddressSupportsMediaType (m_pH323Addr, TAPIMEDIATYPE_VIDEO))
        m_lH323MediaType = TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO;
    else
        m_lH323MediaType = TAPIMEDIATYPE_AUDIO;

    hr = m_pH323Addr->QueryInterface(&pIH323LineEx);
    if (SUCCEEDED(hr))
    {
        hr = pIH323LineEx->SetExternalT120Address(TRUE, INADDR_ANY, 1503);

        H245_CAPABILITY Capabilities[] = 
            {HC_G711, HC_G723, HC_H263QCIF, HC_H261QCIF};
        DWORD Weights[] = {200, 100, 100, 0};

        hr = pIH323LineEx->SetDefaultCapabilityPreferrence(
            4, Capabilities, Weights
            );
    }

    // register call notification
    hr = m_pTapi->RegisterCallNotifications (
        m_pH323Addr,
        VARIANT_TRUE,
        VARIANT_TRUE,
        m_lH323MediaType,
        ulTapiEventAdvise,
        &lCallNotif
        );
    if (FAILED(hr))
        goto Error;

    // find sdp address
    hr = FindAddress (
        LINEADDRESSTYPE_SDP,
        NULL,
        TAPIMEDIATYPE_AUDIO,
        &m_pSDPAddr
        );
    if (FAILED(hr))
        return hr;
    
    // check if it supports video
    if (AddressSupportsMediaType (m_pSDPAddr, TAPIMEDIATYPE_VIDEO))
        m_lSDPMediaType = TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO;
    else
        m_lSDPMediaType = TAPIMEDIATYPE_AUDIO;

Cleanup:
    if (pEventNotif)
        pEventNotif->Release ();
    if (pPoint)
        pPoint->Release ();
    if (pContainer)
        pContainer->Release ();
    if (pIH323LineEx)
        pIH323LineEx->Release ();

    return hr;

Error:
    if (m_pH323Addr)
    {
        m_pH323Addr->Release ();
        m_pH323Addr = NULL;
    }
    if (m_pSDPAddr)
    {
        m_pSDPAddr->Release ();
        m_pSDPAddr = NULL;
    }
    if (m_pTapi)
    {
        m_pTapi->Release ();
        m_pTapi = NULL;
    }
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
void
CBridge::ShutdownTapi ()
{
    if (m_pBridgeCall)
    {
        delete m_pBridgeCall;
        m_pBridgeCall = NULL;
    }

    if (m_pSDPAddr)
    {
        m_pSDPAddr->Release ();
        m_pSDPAddr = NULL;
    }
    if (m_pH323Addr)
    {
        m_pH323Addr->Release ();
        m_pH323Addr = NULL;
    }
    if (m_pTapi)
    {
        m_pTapi->Release ();
        m_pTapi = NULL;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    create h323 call from event
////*/
HRESULT
CBridge::CreateH323Call (IDispatch *pEvent)
{
    HRESULT hr;

    ITCallNotificationEvent *pNotify = NULL;
    CALL_PRIVILEGE privilege;
    ITCallInfo *pCallInfo = NULL;
    ITBasicCallControl *pCall = NULL;

    // get call event interface
    hr = pEvent->QueryInterface (
        IID_ITCallNotificationEvent,
        (void **)&pNotify
        );
    if (FAILED(hr))
        return hr;

    // get call info
    hr = pNotify->get_Call (&pCallInfo);
    if (FAILED(hr))
        goto Error;

    // if we own the call
    hr = pCallInfo->get_Privilege (&privilege);
    if (FAILED(hr))
        goto Error;

    if (CP_OWNER!=privilege)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // get basic call control
    hr = pCallInfo->QueryInterface (
        IID_ITBasicCallControl,
        (void **)&pCall
        );
    if (FAILED(hr))
        goto Error;

    m_pBridgeCall->SetH323Call (pCall);

Cleanup:
    if (pCall)
    {
        pCall->Release ();
        pCall = NULL;
    }
    if (pCallInfo)
    {
        pCallInfo->Release ();
        pCallInfo = NULL;
    }
    if (pNotify)
    {
        pNotify->Release ();
        pNotify = NULL;
    }
    return hr;

Error:
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridge::HasH323Call ()
{
    return m_pBridgeCall->HasH323Call ();
}

/*//////////////////////////////////////////////////////////////////////////////
    iterates through tapi, find an address and create a sdp call
////*/
HRESULT
CBridge::CreateSDPCall ()
{
    HRESULT hr;

    // create call, ignore bstrDestAddr, hardcode it here
    ITBasicCallControl *pCall = NULL;
    BSTR bstrFixedDest;
    
    if (glpCmdLine[0] == '\0')
        bstrFixedDest = SysAllocString (MySDP);
    else
        bstrFixedDest = SysAllocString (MySDP2);

    hr = m_pSDPAddr->CreateCall (
        bstrFixedDest, // bstrDestAddr,
        LINEADDRESSTYPE_SDP,
        m_lSDPMediaType,
        &pCall
        );
    SysFreeString (bstrFixedDest);

    if (FAILED(hr))
        return hr;

    m_pBridgeCall->SetSDPCall (pCall);
    pCall->Release ();

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    bridges h323 and sdp calls
////*/
HRESULT
CBridge::BridgeCalls ()
{
    HRESULT hr;

    return m_pBridgeCall->BridgeCalls ();
}

/*//////////////////////////////////////////////////////////////////////////////
    returns to same state as just initializing tapi
////*/
void
CBridge::Clear ()
{
    m_pBridgeCall->Clear ();
}

/*//////////////////////////////////////////////////////////////////////////////
    if the address type is given, find an address based on
        address type and media type
    else if address name is given, find an address based on
        address name and media type
    else
        return E_FAIL
////*/
HRESULT
CBridge::FindAddress (
    long dwAddrType,
    BSTR bstrAddrName,
    long lMediaType,
    ITAddress **ppAddr
    )
{
    HRESULT hr;
    IEnumAddress *pEnumAddr = NULL;
    ITAddress *pAddr = NULL;
    ITAddressCapabilities *pAddrCaps = NULL;

    BOOL fFound = false;
    long lTypeFound;
    BSTR bstrAddrNameFound = NULL;

    // clear output address
    if ((*ppAddr))
    {
        (*ppAddr)->Release ();
        (*ppAddr) = NULL;
    }
    
    // enumerate the address
    hr = m_pTapi->EnumerateAddresses (&pEnumAddr);
    if (FAILED(hr))
    {
        DoMessage (L"Failed to enumerate address");
        goto Error;
    }
    // loop to find the right address
    while (!fFound)
    {
        // next address
        if (pAddr)
        {
            pAddr->Release ();
            pAddr = NULL;
        }
        hr = pEnumAddr->Next (1, &pAddr, NULL);
        if (S_OK != hr)
            break;

        if (dwAddrType != 0) 
        {
            // addr type is valid, ignore addr name
            if (pAddrCaps)
            {
                pAddrCaps->Release ();
                pAddrCaps = NULL;
            }
            hr = pAddr->QueryInterface (
                IID_ITAddressCapabilities,
                (void **)&pAddrCaps
                );
            if (FAILED(hr))
            {
                DoMessage (L"Failed to retrieve address capabilities");
                goto Error;
            }

            // find address type supported
            hr = pAddrCaps->get_AddressCapability (AC_ADDRESSTYPES, &lTypeFound);
            if (FAILED(hr))
            {
                DoMessage (L"Failed to get address type");
                goto Error;
            }

            // check if the type we wanted
            if (dwAddrType != lTypeFound)
                continue;
        }
        else if (bstrAddrName != NULL)
        {
            hr = pAddr->get_AddressName (&bstrAddrNameFound);
            if (FAILED(hr))
            {
                DoMessage (L"Failed to get address name");
                goto Error;
            }
            if (wcscmp(bstrAddrName, bstrAddrNameFound) != 0)
                continue;
        }
        else
        {
            DoMessage (L"Both address type and name are null. Internal error");
            hr = E_UNEXPECTED;
            goto Error;
        }

        // now check media type
        if (AddressSupportsMediaType (pAddr, lMediaType))
            fFound = true;
    } // end of while (!fFound)

    if (fFound)
    {
        (*ppAddr) = pAddr;
        (*ppAddr)->AddRef ();
    }

Cleanup:
    if (pAddrCaps)
        pAddrCaps->Release ();
    if (pAddr)
        pAddr->Release ();
    if (pEnumAddr)
        pEnumAddr->Release ();
    return hr;

Error:
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
    checks if the address supports the media type
////*/
BOOL
CBridge::AddressSupportsMediaType (ITAddress *pAddr, long lMediaType)
{
    VARIANT_BOOL vbSupport = VARIANT_FALSE;
    ITMediaSupport * pMediaSupport;

    if (SUCCEEDED(pAddr->QueryInterface (IID_ITMediaSupport, (void**)&pMediaSupport)))
    {
        pMediaSupport->QueryMediaType (lMediaType, &vbSupport);
        pMediaSupport->Release ();
    }
    return (vbSupport==VARIANT_TRUE);
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridge::GetSDPAddress (ITAddress **ppAddress)
{
    HRESULT hr;

    if (*ppAddress)
    {
        (*ppAddress)->Release ();
        *ppAddress = NULL;
    }

    *ppAddress = m_pSDPAddr;
    m_pSDPAddr->AddRef ();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test\event.cpp ===
/*******************************************************************************

  Module: event.cpp

  Author: Qianbo Huai

  Abstract:

    implements methods for class CTAPIEventNotification

*******************************************************************************/

#include "stdafx.h"
#include "work.h"

extern HWND ghDlg;

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::QueryInterface (
    REFIID iid,
    void **ppvObj
    )
{
    if (iid==IID_ITTAPIEventNotification)
    {
        AddRef ();
        *ppvObj = (void *)this;
        return S_OK;
    }
    if (iid==IID_IUnknown)
    {
        AddRef ();
        *ppvObj = (void *)this;
    }
    return E_NOINTERFACE;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
ULONG
STDMETHODCALLTYPE
CTAPIEventNotification::AddRef ()
{
    ULONG l = InterlockedIncrement (&m_dwRefCount);
    return l;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
ULONG
STDMETHODCALLTYPE
CTAPIEventNotification::Release ()
{
    ULONG l = InterlockedDecrement (&m_dwRefCount);
    if (0 == l)
    {
        delete this;
    }
    return l;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event (
    TAPI_EVENT TapiEvent,
    IDispatch * pEvent
    )
{
    // Addref the event so it doesn't go away.
    pEvent->AddRef();

    // Post a message to our own UI thread.
    PostMessage(
        ghDlg,
        WM_PRIVATETAPIEVENT,
        (WPARAM) TapiEvent,
        (LPARAM) pEvent
        );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Work.rc
//
#define IDD_MAINDLG                     101
#define IDC_DISCONNECT                  1000
#define IDC_EXIT                        1001
#define IDC_STATUS                      1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test\work.h ===
/*******************************************************************************

  Module: work.h

  Author: Qianbo Huai

  Abstract:

    defines all the classes for the bridge test application

*******************************************************************************/

#ifndef _WORK_H
#define _WORK_H

#include "resource.h"

// H323 call listener sends event to dialog box
#define WM_PRIVATETAPIEVENT   WM_USER+101

// helper
void DoMessage (LPWSTR pszMessage);

class CBridge;
class CBridgeCall;
class CTAPIEventNotification;

class CBridge
/*//////////////////////////////////////////////////////////////////////////////
  encapsulates methods operated on ITTAPI, ITAddress.
  contains the bridge call object
////*/
{
public:
    CBridge () {};
    ~CBridge () {};

    // helper
    HRESULT FindAddress (long dwAddrType, BSTR bstrAddrName, long lMediaType, ITAddress **ppAddr);
    BOOL AddressSupportsMediaType (ITAddress *pAddr, long lMediaType);

    // methods related with tapi
    HRESULT InitTapi ();
    void ShutdownTapi ();

    // methods related with terminal support
    HRESULT GetSDPAddress (ITAddress **ppAddress);

    // methods related with calls
    HRESULT CreateH323Call (IDispatch *pEvent);
    HRESULT CreateSDPCall ();
    HRESULT BridgeCalls ();

    void Clear ();

    BOOL HasH323Call ();

private:
    ITTAPI *m_pTapi;

    ITAddress *m_pH323Addr;
    ITAddress *m_pSDPAddr;
    
    long m_lH323MediaType;
    long m_lSDPMediaType;

    CBridgeCall *m_pBridgeCall;
};

/*//////////////////////////////////////////////////////////////////////////////
  encapsulates methods operated on ITBasicCallControl
////*/
class CBridgeCall
{
public:
    CBridgeCall (CBridge *pBridge);
    ~CBridgeCall ();

    void SetH323Call (ITBasicCallControl *pCall)
    {
        pCall->AddRef ();
        m_pH323Call = pCall;
    }
    void SetSDPCall (ITBasicCallControl *pCall)
    {
        pCall->AddRef ();
        m_pSDPCall = pCall;
    }
    BOOL HasH323Call ()
    {
        return (m_pH323Call!=NULL);
    }

    HRESULT SelectBridgeTerminals ();
    HRESULT SetupParticipantInfo ();
    HRESULT SetMulticastMode ();
    HRESULT BridgeCalls ();

    void Clear ();

private:
    BOOL IsStream (ITStream *pStream, long lMediaType, TERMINAL_DIRECTION tdDirection);

private:
    CBridge *m_pBridge;

    ITBasicCallControl *m_pH323Call;
    ITBasicCallControl *m_pSDPCall;
};

/*//////////////////////////////////////////////////////////////////////////////
  used by ITTAPI to notify event coming
////*/
class CTAPIEventNotification
:public ITTAPIEventNotification
{
public:
    CTAPIEventNotification ()
    {
        m_dwRefCount = 1;
    }
    ~CTAPIEventNotification () {}

    // IUnknow stuff
    HRESULT STDMETHODCALLTYPE QueryInterface (REFIID iid, void **ppvObj);

    ULONG STDMETHODCALLTYPE AddRef ();

    ULONG STDMETHODCALLTYPE Release ();

    HRESULT STDMETHODCALLTYPE Event (TAPI_EVENT TapiEvent, IDispatch *pEvent);

private:
    long m_dwRefCount;
};

#endif // _WORK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include <objbase.h>
#include <winsock2.h>
#include <tapi3.h>
#include <control.h>
#include <strmif.h>
#include <confpriv.h>
#include <h323priv.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test\work.cpp ===
/*******************************************************************************

  Module: work.cpp

  Author: Qianbo Huai

  Abstract:

    implements the main function of the bridge test application

*******************************************************************************/

#include "stdafx.h"
#include <stdio.h>
#include "work.h"

// command line
LPSTR glpCmdLine = NULL;

// dialog
HWND ghDlg = NULL;

// true: exit button on dialog was clicked
bool gfExitButton = false;

// bridge
CBridge *gpBridge = NULL;

// callback func in dialog
BOOL
CALLBACK
MainDialogProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

// func to deal with TAPI events
HRESULT
OnTapiEvent (
    TAPI_EVENT TapiEvent,
    IDispatch *pEvent,
    LPWSTR *ppszMessage
    );

// set status message on dialog
void
SetStatusMessage (LPWSTR pszMessage);

/*//////////////////////////////////////////////////////////////////////////////
    WinMain
////*/
int
WINAPI
WinMain (
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpCmdLine,
    int nShowCmd
    )
{
    // init com
    if (FAILED (CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        return 0;
    }

    // keep command line which determines which SDP to join
    glpCmdLine = lpCmdLine;

    // init CBridge
    gpBridge = new CBridge ();
    if (gpBridge==NULL)
    {
        printf ("Failed to init CBridge\n");
        return 0;
    }

    // init TAPI and H323 call listen
    if (FAILED(gpBridge->InitTapi()))
    {
        printf ("Failed to init TAPI\n");
        return 0;
    }
    
    // start dialog box
    if (!DialogBox (hInst, MAKEINTRESOURCE(IDD_MAINDLG), NULL, MainDialogProc))
    {
        printf ("Failed to init dialog\n");
    }

    // dialog finished
    gpBridge->ShutdownTapi ();
    delete gpBridge;

    CoUninitialize ();

    return 1;
}

/*//////////////////////////////////////////////////////////////////////////////
    Callback for dialog
////*/
BOOL
CALLBACK
MainDialogProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPWSTR pszMessage;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            ghDlg = hDlg;
            SetStatusMessage (L"Waiting for incoming H323 call");

            // disable disconnect button
            SendDlgItemMessage (
                ghDlg,
                IDC_DISCONNECT,
                BM_SETSTYLE,
                BS_PUSHBUTTON,
                0
                );
            EnableWindow (
                GetDlgItem (ghDlg, IDC_DISCONNECT),
                FALSE
                );

            return 0;
        }
    case WM_PRIVATETAPIEVENT:
        {
            if (FAILED(OnTapiEvent ((TAPI_EVENT)wParam, (IDispatch *)lParam, &pszMessage)))
            {
                DoMessage (pszMessage);
            }
            return 0;
        }
    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDC_EXIT:
                {
                    gpBridge->Clear ();

                    gfExitButton = true;

                    // check if in connection
                    if (!IsWindowEnabled (GetDlgItem (ghDlg, IDC_DISCONNECT)))
                    {
                        // not in connection
                        EndDialog (ghDlg, 0);
                    }
                    // else
                        // remember exit button is clicked
                        // do not call EndDialog because a disconnect event is to come

                    return 1;
                }
            case IDC_DISCONNECT:
                {
                    gpBridge->Clear ();

                    SetStatusMessage (L"Waiting for incoming H323 call");

                    // disable disconnect button
                    SendDlgItemMessage (
                        ghDlg,
                        IDC_DISCONNECT,
                        BM_SETSTYLE,
                        BS_PUSHBUTTON,
                        0
                        );
                    EnableWindow (
                        GetDlgItem (ghDlg, IDC_DISCONNECT),
                        FALSE
                        );

                    // check if exit button is clicked
                    if (gfExitButton)
                        EndDialog (ghDlg, 0);

                    return 1;
                }
            }
            return 0;
        }
    default:
        return 0;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    Popup message box
////*/
WCHAR gMsgBoxTitle[] = L"TAPI 3.0 Bridge Test Application";

void
DoMessage (LPWSTR pszMessage)
{
    MessageBox (
        ghDlg,
        pszMessage,
        gMsgBoxTitle,
        MB_OK
        );
}

/*//////////////////////////////////////////////////////////////////////////////
    Status message
////*/
void
SetStatusMessage (LPWSTR pszMessage)
{
    SetDlgItemText (ghDlg, IDC_STATUS, pszMessage);
}

/*//////////////////////////////////////////////////////////////////////////////
    Deals with TAPI events
////*/
HRESULT OnTapiEvent (
    TAPI_EVENT TapiEvent,
    IDispatch *pEvent,
    LPWSTR *ppszMessage
    )
{
    HRESULT hr = S_OK;

    switch (TapiEvent)
    {
    case TE_CALLNOTIFICATION:
        {
            // if h323 call and to us, init h323 call
            hr = gpBridge->CreateH323Call (pEvent);
            if (FAILED(hr))
                *ppszMessage = L"H323 not created";
            break;
        }
    case TE_CALLSTATE:
        {
            CALL_STATE cs;
            ITCallStateEvent *pCallStateEvent = NULL;

            *ppszMessage = L"Call state failed";

            // get call state event
            hr = pEvent->QueryInterface (
                IID_ITCallStateEvent,
                (void **)&pCallStateEvent
                );
            if (FAILED(hr)) break;

            // get call state
            hr = pCallStateEvent->get_State (&cs);
            pCallStateEvent->Release ();
            if (FAILED(hr)) break;

            // if offering, connect
            if (CS_OFFERING == cs)
            {
                // check if h323 call created successful
                if (!gpBridge->HasH323Call ())
                {
                    hr = S_OK;
                    break;
                }
                // create sdp call
                hr = gpBridge->CreateSDPCall ();
                if (FAILED(hr)) {
                    gpBridge->Clear ();
                    *ppszMessage = L"Failed to create SDP call";
                    break;
                }

                // bridge call
                hr = gpBridge->BridgeCalls ();
                if (FAILED(hr)) {
                    gpBridge->Clear ();
                    *ppszMessage = L"Failed to bridge calls";
                    break;
                }

                SetStatusMessage (L"In call ...");

                // enable disconnect button
                SendDlgItemMessage (
                    ghDlg,
                    IDC_DISCONNECT,
                    BM_SETSTYLE,
                    BS_DEFPUSHBUTTON,
                    0
                    );
                EnableWindow (
                    GetDlgItem (ghDlg, IDC_DISCONNECT),
                    TRUE
                    );
                SetFocus (GetDlgItem (ghDlg, IDC_DISCONNECT));
            }
            // if disconnect
            else if (CS_DISCONNECTED == cs)
            {
                PostMessage (ghDlg, WM_COMMAND, IDC_DISCONNECT, 0);
                hr = S_OK;
            }
            break;
        }
    case TE_CALLMEDIA:
        {
            CALL_MEDIA_EVENT cme;
            ITCallMediaEvent *pCallMediaEvent;

            // get call media event
            hr = pEvent->QueryInterface (
                IID_ITCallMediaEvent,
                (void **)&pCallMediaEvent
                );
            if (FAILED(hr)) break;

            // get the event
            hr = pCallMediaEvent->get_Event (&cme);
            if (FAILED(hr)) break;

            // check media event
            switch (cme)
            {
                case CME_STREAM_FAIL:
                    hr = E_FAIL;
                    DoMessage( L"Stream failed");
                    break; 
                case CME_TERMINAL_FAIL:
                    hr = E_FAIL;
                    DoMessage( L"Terminal failed");
                    break;
                default:
                    break;
            }

            // we no longer need this interface.
            pCallMediaEvent->Release();
            break;
        }
    default:
        break;
    }

    pEvent->Release(); // we addrefed it CTAPIEventNotification::Event()
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\bgapp.h ===
/*******************************************************************************

Module Name:

    bgapp.h

Abstract:

    Defines CBridgeApp class

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#ifndef _BGAPP_H
#define _BGAPP_H

/*//////////////////////////////////////////////////////////////////////////////
////*/
class CBridgeApp
{
public:
    // init tapi objects
    CBridgeApp (HRESULT *phr);
    // release tapi objects
    ~CBridgeApp ();

    // create h323 call
    HRESULT CreateH323Call (IDispatch *pEvent);
    // create sdp call
    HRESULT CreateSDPCall (CBridgeItem *pItem);
    // bridge calls
    HRESULT BridgeCalls (CBridgeItem *pItem);

    // get h323 call if exists
    HRESULT HasH323Call (IDispatch *pEvent, CBridgeItem **ppItem);
    HRESULT HasCalls ();

    // disconnect one call
    HRESULT DisconnectCall (CBridgeItem *pItem, DISCONNECT_CODE);
    // disconnect all calls
    HRESULT DisconnectAllCalls (DISCONNECT_CODE);
    HRESULT RemoveCall (CBridgeItem *pItem);

    // alter a substream to display
    HRESULT NextSubStream ();
    // show specified participant
    HRESULT ShowParticipant (ITBasicCallControl *pSDPCall, ITParticipant *pPartcipant);

private:
    // create bridge terminals
    HRESULT CreateBridgeTerminals (CBridgeItem *pItem);
    // get streams from call
    HRESULT GetStreams (CBridgeItem *pItem);
    // select bridge terminals
    HRESULT SelectBridgeTerminals (CBridgeItem *pItem);

    HRESULT SetupParticipantInfo (CBridgeItem *pItem);
    HRESULT SetMulticastMode (CBridgeItem *pItem);

    // helper
    HRESULT FindAddress (
        long dwAddrType,
        BSTR bstrAddrName,
        long lMediaType,
        ITAddress **ppAddr
        );
    BOOL AddressSupportsMediaType (ITAddress *pAddr, long lMediaType);
    BOOL IsStream (
        ITStream *pStream,
        long lMediaType,
        TERMINAL_DIRECTION tdDirection
        );

private:
    ITTAPI *m_pTapi;

    ITAddress *m_pH323Addr;
    ITAddress *m_pSDPAddr;
    
    long m_lH323MediaType;
    long m_lSDPMediaType;

    CBridgeItemList *m_pList;
};

#endif // _BGAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\bgapp.cpp ===
/*******************************************************************************

Module Name:

    bgapp.cpp

Abstract:
  
    Implements class CBridgeApp

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#include "stdafx.h"
#include <bridge.h>

extern LPSTR glpCmdLine;

/*//////////////////////////////////////////////////////////////////////////////
    hard coded SDP
////*/
const WCHAR * const MySDP = L"\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=BridgeTestConf\n\
c=IN IP4 239.9.20.26/15\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
m=audio 20040 RTP/AVP 0 4\n\
";

const WCHAR * const MySDP2 = L"\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=BridgeTestConf2\n\
c=IN IP4 239.9.20.26/15\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
m=audio 20040 RTP/AVP 3\n\
";

WCHAR *SelfAlias = L"Conference";

/*//////////////////////////////////////////////////////////////////////////////
    initiates tapi and listens at h323 address
////*/
CBridgeApp::CBridgeApp (HRESULT *phr)
{
    ENTER_FUNCTION ("CBridgeApp::CBridgeApp");
    LOG ((BG_TRACE, "%s entered", __fxName));

    *phr = S_OK;

    // init members
    m_pTapi = NULL;
    m_pH323Addr = NULL;
    m_pSDPAddr = NULL;
    m_pList = new CBridgeItemList ();
    if (NULL == m_pList)
    {
        *phr = E_FAIL;
        return;
    }

    // create tapi
    *phr = CoCreateInstance (
        CLSID_TAPI,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTAPI,
        (LPVOID *)&m_pTapi
        );
    if (FAILED(*phr))
        return;

    // tapi initiate
    *phr = m_pTapi->Initialize ();
    if (FAILED(*phr))
        return;

    // associate event with listener
    CTAPIEventNotification *pEventNotif = NULL;
    IConnectionPointContainer *pContainer = NULL;
    IConnectionPoint *pPoint = NULL;
    IH323LineEx *pIH323LineEx = NULL;
    ULONG ulTapiEventAdvise;
    long lCallNotif;
    BSTR bstrAddrName = NULL;

    // create event notification
    pEventNotif = new CTAPIEventNotification;
    if (!pEventNotif)
    {
        *phr = E_OUTOFMEMORY;
        goto Error;
    }
    
    // get pointer container from tapi  
    *phr = m_pTapi->QueryInterface (
        IID_IConnectionPointContainer,
        (void **)&pContainer
        );
    if (FAILED(*phr))
        goto Error;

    // get connection point from container
    *phr = pContainer->FindConnectionPoint (
        IID_ITTAPIEventNotification,
        &pPoint
        );
    if (FAILED(*phr))
        goto Error;

    // advise event notification on connection pointer
    *phr = pPoint->Advise (
        pEventNotif,
        &ulTapiEventAdvise
        );
    if (FAILED(*phr))
        goto Error;

    // put event filter on tapi
    *phr = m_pTapi->put_EventFilter (
        TE_CALLNOTIFICATION |
        TE_CALLSTATE |
        TE_CALLMEDIA |
        TE_PRIVATE
        );
    if (FAILED(*phr))
        goto Error;

    // find h323 address
    bstrAddrName = SysAllocString (L"H323 Line");
    *phr = FindAddress (
        0,
        bstrAddrName,
        TAPIMEDIATYPE_AUDIO,
        &m_pH323Addr
        );
    SysFreeString (bstrAddrName);
    if (FAILED(*phr))
        goto Error;

    // check if it supports video
    BOOL fSupportsVideo;

    if (AddressSupportsMediaType (m_pH323Addr, TAPIMEDIATYPE_VIDEO))
        m_lH323MediaType = TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO;
    else
        m_lH323MediaType = TAPIMEDIATYPE_AUDIO;

    *phr = m_pH323Addr->QueryInterface(&pIH323LineEx);
    if (SUCCEEDED(*phr))
    {
        *phr = pIH323LineEx->SetExternalT120Address(TRUE, INADDR_ANY, 1503);

        H245_CAPABILITY Capabilities[] = 
            {HC_G711, HC_G723, HC_H263QCIF, HC_H261QCIF};
        DWORD Weights[] = {200, 100, 100, 0};

        *phr = pIH323LineEx->SetDefaultCapabilityPreferrence(
            4, Capabilities, Weights
            );

        *phr = pIH323LineEx->SetAlias (SelfAlias, wcslen (SelfAlias));
    }

    // register call notification
    *phr = m_pTapi->RegisterCallNotifications (
        m_pH323Addr,
        VARIANT_TRUE,
        VARIANT_TRUE,
        m_lH323MediaType,
        ulTapiEventAdvise,
        &lCallNotif
        );
    if (FAILED(*phr))
        goto Error;

    // find sdp address
    *phr = FindAddress (
        LINEADDRESSTYPE_SDP,
        NULL,
        TAPIMEDIATYPE_AUDIO,
        &m_pSDPAddr
        );
    if (FAILED(*phr))
        goto Error;
    
    // check if it supports video
    if (AddressSupportsMediaType (m_pSDPAddr, TAPIMEDIATYPE_VIDEO))
        m_lSDPMediaType = TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO;
    else
        m_lSDPMediaType = TAPIMEDIATYPE_AUDIO;

Cleanup:
    if (pEventNotif)
        pEventNotif->Release ();
    if (pPoint)
        pPoint->Release ();
    if (pContainer)
        pContainer->Release ();
    if (pIH323LineEx)
        pIH323LineEx->Release ();

    LOG ((BG_TRACE, "%s returns", __fxName));
    return;

Error:
    if (m_pH323Addr)
    {
        m_pH323Addr->Release ();
        m_pH323Addr = NULL;
    }
    if (m_pSDPAddr)
    {
        m_pSDPAddr->Release ();
        m_pSDPAddr = NULL;
    }
    if (m_pTapi)
    {
        m_pTapi->Release ();
        m_pTapi = NULL;
    }
    if (m_pList)
    {
        delete m_pList;
    }

    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
CBridgeApp::~CBridgeApp ()
{
    if (m_pList)
    {
        // all calls should already been disconnected
        delete m_pList;
    }
    if (m_pSDPAddr)
    {
        m_pSDPAddr->Release ();
    }
    if (m_pH323Addr)
    {
        m_pH323Addr->Release ();
    }
    if (m_pTapi)
    {
        m_pTapi->Release ();
    }
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::CreateH323Call (IDispatch *pEvent)
{
    ENTER_FUNCTION ("CBridgeApp::CreateH323Call");
    LOG ((BG_TRACE, "%s entered", __fxName));

    HRESULT hr;
    BSTR bstrID = NULL;
    BSTR bstrName = NULL;
    BSTR CallerIDNumber = NULL;

    ITCallNotificationEvent *pNotify = NULL;
    ITCallInfo *pCallInfo = NULL;
    ITBasicCallControl *pCallControl = NULL;
    IUnknown *pIUnknown = NULL;

    CBridgeItem *pItem = NULL;

    // check privilege
    CALL_PRIVILEGE privilege;

    // get call event interface
    hr = pEvent->QueryInterface (
        IID_ITCallNotificationEvent,
        (void **)&pNotify
        );
    if (FAILED(hr))
        return hr;

    // get call info
    hr = pNotify->get_Call (&pCallInfo);
    if (FAILED(hr))
        goto Error;

    // if we own the call
    hr = pCallInfo->get_Privilege (&privilege);
    if (FAILED(hr))
        goto Error;

    if (CP_OWNER != privilege)
    {
        hr = E_UNEXPECTED;
        goto Error;
    }

    // get call info string
    hr = pCallInfo->get_CallInfoString(CIS_CALLERIDNAME, &bstrName);
    if (FAILED (hr))
        goto Error;

    hr = pCallInfo->get_CallInfoString(CIS_CALLERIDNUMBER, &CallerIDNumber);
    if (FAILED(hr))
        goto Error;

    // construct the caller id
    bstrID = SysAllocStringLen(NULL, 
        SysStringLen(bstrName) + SysStringLen(CallerIDNumber) + 2);

    wsprintfW(bstrID, L"%ws@%ws", bstrName, CallerIDNumber);

    hr = pCallInfo->QueryInterface (
        IID_ITBasicCallControl,
        (void **)&pCallControl
        );
    if (FAILED(hr))
        goto Error;

    // check if there is an item with same id
    if (FAILED (hr = pCallInfo->QueryInterface (IID_IUnknown, (void**)&pIUnknown)))
        goto Error;
    pItem = m_pList->FindByH323 (pIUnknown);
    pIUnknown->Release ();
    pIUnknown = NULL;

    if (NULL != pItem)
    {
        // @@ we are already in a call from the same ID
        // @@ should have some debug info and feedback?
        hr = pCallControl->Disconnect (DC_REJECTED);
        // don't care the return value of diconnect

        hr = E_ABORT;
        goto Error;
    }

    // everything is right, store the call
    pItem = new CBridgeItem;
    if (NULL == pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pItem->bstrID = bstrID;
    pItem->bstrName = bstrName;
    pItem->pCallH323 = pCallControl;

    m_pList->Append (pItem);

Cleanup:
    if (pNotify) pNotify->Release ();
    if (pCallInfo) pCallInfo->Release();
    if (CallerIDNumber) SysFreeString(CallerIDNumber);

    LOG ((BG_TRACE, "%s returns, %x", __fxName, hr));
    return hr;

Error:
    if (bstrID) SysFreeString (bstrID);
    if (bstrName) SysFreeString (bstrName);
    if (pCallControl) pCallControl->Release ();

    goto Cleanup;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::CreateSDPCall (CBridgeItem *pItem)
{
    ENTER_FUNCTION ("CBridgeApp::CreateSDPCall");
    LOG ((BG_TRACE, "%s entered", __fxName));

    HRESULT hr;

    // create call, ignore bstrDestAddr, hardcode it here
    ITBasicCallControl *pCall = NULL;
    BSTR bstrFixedDest;
    
    if (glpCmdLine[0] == '\0')
        bstrFixedDest = SysAllocString (MySDP);
    else
        bstrFixedDest = SysAllocString (MySDP2);

    hr = m_pSDPAddr->CreateCall (
        bstrFixedDest, // bstrDestAddr,
        LINEADDRESSTYPE_SDP,
        m_lSDPMediaType,
        &pCall
        );
    SysFreeString (bstrFixedDest);

    if (FAILED(hr))
        return hr;

    // store the call
    pItem->pCallSDP = pCall;

    LOG ((BG_TRACE, "%s returns", __fxName));
    return hr;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::BridgeCalls (CBridgeItem *pItem)
{
    ENTER_FUNCTION ("CBridgeApp::BridgeCalls");
    LOG ((BG_TRACE, "%s entered", __fxName));

    HRESULT hr;

    hr = SetupParticipantInfo (pItem);
	if (FAILED(hr))
        return hr;

    hr = SetMulticastMode (pItem);
	if (FAILED(hr))
        return hr;

    if (FAILED (hr = CreateBridgeTerminals (pItem)))
        return hr;

    if (FAILED (hr = GetStreams (pItem)))
        return hr;

    if (FAILED (hr = SelectBridgeTerminals (pItem)))
        return hr;

    // connect h323 call
    if (FAILED (hr = pItem->pCallH323->Answer ()))
        return hr;

    // connect sdp call
    if (FAILED (hr = pItem->pCallSDP->Connect (VARIANT_TRUE)))
    {
        pItem->pCallH323->Disconnect (DC_NORMAL);
        return hr;
    }

    LOG ((BG_TRACE, "%s returns", __fxName));
    return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::DisconnectCall (CBridgeItem *pItem, DISCONNECT_CODE dc)
{
    // disconnect
    if (pItem->pCallH323)
        pItem->pCallH323->Disconnect (dc);
    if (pItem->pCallSDP)
        pItem->pCallSDP->Disconnect (dc);

    return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::DisconnectAllCalls (DISCONNECT_CODE dc)
{
    // i should have a better way to traverse each call
    CBridgeItem ** pItemArray;
    int num, i;

    // out of memory
    if (!m_pList->GetAllItems (&pItemArray, &num))
        return E_OUTOFMEMORY;

    // no calls
    if (num == 0)
        return S_OK;

    for (i=0; i<num; i++)
    {
        // disconnect each call
        if (pItemArray[i]->pCallH323)
            pItemArray[i]->pCallH323->Disconnect (dc);
        if (pItemArray[i]->pCallSDP)
            pItemArray[i]->pCallSDP->Disconnect (dc);
        // do not delete item
    }

    free (pItemArray);

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::RemoveCall (CBridgeItem *pItem)
{
    m_pList->TakeOut (pItem);
    return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::HasH323Call (IDispatch *pEvent, CBridgeItem **ppItem)
{
    HRESULT hr;

    ITCallStateEvent *pState = NULL;
    ITCallInfo *pCallInfo = NULL;

    IUnknown * pIUnknown = NULL;

    // ignore null checking
    if (*ppItem)
    {
        delete *ppItem;
        *ppItem = NULL;
    }

    // get call state event
    hr = pEvent->QueryInterface (
        IID_ITCallStateEvent,
        (void **)&pState
        );
    if (FAILED(hr))
        return hr;

    // check privilege
    CALL_PRIVILEGE privilege;

    // get call event interface
    hr = pState->get_Call (&pCallInfo);
    if (FAILED(hr))
        return hr;

    // if we own the call
    hr = pCallInfo->get_Privilege (&privilege);
    if (FAILED(hr))
        goto Error;

    if (CP_OWNER != privilege)
    {
        hr = E_UNEXPECTED;
        goto Error;
    }

    // get IUnknown
    if (FAILED (hr = pCallInfo->QueryInterface (IID_IUnknown, (void **)&pIUnknown)))
        goto Error;
    *ppItem = m_pList->FindByH323 (pIUnknown);

Cleanup:
    if (pCallInfo) pCallInfo->Release ();
    if (pIUnknown) pIUnknown->Release ();
    if (pState) pState->Release ();

    return hr;

Error:
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::HasCalls ()
{
    if (m_pList->IsEmpty ())
        return S_FALSE;
    else
        return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::CreateBridgeTerminals (CBridgeItem *pItem)
{
    HRESULT hr;
    IConfBridge *pConfBridge = NULL;

    // create CConfBridge
    hr = CoCreateInstance (
        __uuidof(ConfBridge),
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IConfBridge,
        (LPVOID *)&pConfBridge
        );
    if (FAILED(hr))
        return hr;

    // create terminal: video H323->SDP
    hr = pConfBridge->CreateBridgeTerminal (
        TAPIMEDIATYPE_VIDEO,
        &(pItem->pTermHSVid)
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: audio H323->SDP
    hr = pConfBridge->CreateBridgeTerminal (
        TAPIMEDIATYPE_AUDIO,
        &(pItem->pTermHSAud)
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: video SDP->H323
    hr = pConfBridge->CreateBridgeTerminal (
        TAPIMEDIATYPE_VIDEO,
        &(pItem->pTermSHVid)
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: audio SDP->H323
    hr = pConfBridge->CreateBridgeTerminal (
        TAPIMEDIATYPE_AUDIO,
        &(pItem->pTermSHAud)
        );
    if (FAILED(hr))
        goto Error;

Cleanup:
    pConfBridge->Release ();
    pConfBridge = NULL;

    return hr;

Error:
    goto Cleanup;
}


/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::GetStreams (CBridgeItem *pItem)
{
    ITStreamControl *pStreamControl = NULL;
    IEnumStream *pEnumStreams = NULL;
    ITStream *pStream = NULL;

    // get stream control on H323
    HRESULT hr = pItem->pCallH323->QueryInterface (
        IID_ITStreamControl,
        (void **)&pStreamControl
        );
    if (FAILED(hr))
        return hr;

    // get enum stream on H323
    hr = pStreamControl->EnumerateStreams (&pEnumStreams);
    pStreamControl->Release ();
    pStreamControl = NULL;

    if (FAILED(hr))
        return hr;

    // iterate each stream on H323
    while (S_OK == pEnumStreams->Next (1, &pStream, NULL))
    {
        if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_CAPTURE))
            pItem->pStreamHVidCap = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_RENDER))
        {
            pItem->pStreamHVidRen = pStream;

            IKeyFrameControl* pIKeyFrameControl = NULL;
            hr = pStream->QueryInterface(&pIKeyFrameControl);
            if (SUCCEEDED(hr))
            {
                hr = pIKeyFrameControl->PeriodicUpdatePicture(TRUE, 5);
                pIKeyFrameControl->Release();
            }
        }

        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_CAPTURE))
            pItem->pStreamHAudCap = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_RENDER))
            pItem->pStreamHAudRen = pStream;

        else
        {
            pEnumStreams->Release ();
            // @@ IsStream doesn't return hresult
            return E_FAIL;
        }
    }

    // don't release pStream, it's stored in pItem
    pEnumStreams->Release ();
    pEnumStreams = NULL;

    //========================================

    // get stream control on SDP
    hr = pItem->pCallSDP->QueryInterface (
        IID_ITStreamControl,
        (void **)&pStreamControl
        );
    if (FAILED(hr))
        return hr;

    // get enum stream on SDP
    hr = pStreamControl->EnumerateStreams (&pEnumStreams);
    pStreamControl->Release ();
    pStreamControl = NULL;

    if (FAILED(hr))
        return hr;

    // iterate each stream on SDP
    while (S_OK == pEnumStreams->Next (1, &pStream, NULL))
    {
        if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_CAPTURE))
            pItem->pStreamSVidCap = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_RENDER))
            pItem->pStreamSVidRen = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_CAPTURE))
            pItem->pStreamSAudCap = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_RENDER))
            pItem->pStreamSAudRen = pStream;

        else
        {
            pEnumStreams->Release ();
            // @@ IsStream doesn't return hresult
            return E_FAIL;
        }
    }

    // don't release pStream, it's stored in pItem
    pEnumStreams->Release ();
    pEnumStreams = NULL;

    return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::SelectBridgeTerminals (CBridgeItem *pItem)
{
    HRESULT hr;

    // sdp->h323 audio pair
    if (FAILED (hr = pItem->pStreamHAudCap->SelectTerminal (pItem->pTermSHAud)))
        return hr;
    if (FAILED (hr = pItem->pStreamSAudRen->SelectTerminal (pItem->pTermSHAud)))
        return hr;

    // h323->sdp audio pair
    if (FAILED (hr = pItem->pStreamSAudCap->SelectTerminal (pItem->pTermHSAud)))
        return hr;
    if (FAILED (hr = pItem->pStreamHAudRen->SelectTerminal (pItem->pTermHSAud)))
        return hr;

    // sdp->h323 video pair
    if (FAILED (hr = pItem->pStreamHVidCap->SelectTerminal (pItem->pTermSHVid)))
        return hr;
    if (FAILED (hr = pItem->pStreamSVidRen->SelectTerminal (pItem->pTermSHVid)))
        return hr;

    // h323->sdp video pair
    if (FAILED (hr = pItem->pStreamSVidCap->SelectTerminal (pItem->pTermHSVid)))
        return hr;
    if (FAILED (hr = pItem->pStreamHVidRen->SelectTerminal (pItem->pTermHSVid)))
        return hr;

    return S_OK;
}


/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::SetupParticipantInfo (CBridgeItem *pItem)
{
    HRESULT hr = S_OK;
    ITLocalParticipant *pLocalParticipant = NULL;

    // set the CName on the SDP side.
    hr = pItem->pCallSDP->QueryInterface(&pLocalParticipant);
    if (FAILED(hr)) goto Cleanup;

    hr = pLocalParticipant->put_LocalParticipantTypedInfo(
        PTI_CANONICALNAME, pItem->bstrID
        );
    if (FAILED(hr)) goto Cleanup;

    hr = pLocalParticipant->put_LocalParticipantTypedInfo(
        PTI_NAME, pItem->bstrName
        );

    if (FAILED(hr)) goto Cleanup;

Cleanup:
    if (pLocalParticipant) pLocalParticipant->Release();

    return hr;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::SetMulticastMode (CBridgeItem *pItem)
{
    IMulticastControl * pIMulticastControl = NULL;
    
    HRESULT hr = pItem->pCallSDP->QueryInterface(&pIMulticastControl);
    if (FAILED(hr)) return hr;

    hr = pIMulticastControl->put_LoopbackMode(MM_SELECTIVE_LOOPBACK);

    pIMulticastControl->Release();

    return hr;
}


/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::FindAddress (long dwAddrType, BSTR bstrAddrName, long lMediaType, ITAddress **ppAddr)
{
    HRESULT hr;
    IEnumAddress *pEnumAddr = NULL;
    ITAddress *pAddr = NULL;
    ITAddressCapabilities *pAddrCaps = NULL;

    BOOL fFound = false;
    long lTypeFound;
    BSTR bstrAddrNameFound = NULL;

    // clear output address
    if ((*ppAddr))
    {
        (*ppAddr)->Release ();
        (*ppAddr) = NULL;
    }
    
    // enumerate the address
    hr = m_pTapi->EnumerateAddresses (&pEnumAddr);
    if (FAILED(hr))
    {
        // @@ should have some debug info here
        goto Error;
    }
    // loop to find the right address
    while (!fFound)
    {
        // next address
        if (pAddr)
        {
            pAddr->Release ();
            pAddr = NULL;
        }
        hr = pEnumAddr->Next (1, &pAddr, NULL);
        if (S_OK != hr)
            break;

        if (dwAddrType != 0) 
        {
            // addr type is valid, ignore addr name
            if (pAddrCaps)
            {
                pAddrCaps->Release ();
                pAddrCaps = NULL;
            }
            hr = pAddr->QueryInterface (
                IID_ITAddressCapabilities,
                (void **)&pAddrCaps
                );
            if (FAILED(hr))
            {
                // @@ debug info here
                // DoMessage (L"Failed to retrieve address capabilities");
                goto Error;
            }

            // find address type supported
            hr = pAddrCaps->get_AddressCapability (AC_ADDRESSTYPES, &lTypeFound);
            if (FAILED(hr))
            {
                // DoMessage (L"Failed to get address type");
                goto Error;
            }

            // check if the type we wanted
            if (dwAddrType != lTypeFound)
                continue;
        }
        else if (bstrAddrName != NULL)
        {
            hr = pAddr->get_AddressName (&bstrAddrNameFound);
            if (FAILED(hr))
            {
                // DoMessage (L"Failed to get address name");
                goto Error;
            }
            if (wcscmp(bstrAddrName, bstrAddrNameFound) != 0)
                continue;
        }
        else
        {
            // DoMessage (L"Both address type and name are null. Internal error");
            hr = E_UNEXPECTED;
            goto Error;
        }

        // now check media type
        if (AddressSupportsMediaType (pAddr, lMediaType))
            fFound = true;
    } // end of while (!fFound)

    if (fFound)
    {
        (*ppAddr) = pAddr;
        (*ppAddr)->AddRef ();
    }

Cleanup:
    if (pAddrCaps)
        pAddrCaps->Release ();
    if (pAddr)
        pAddr->Release ();
    if (pEnumAddr)
        pEnumAddr->Release ();
    return hr;

Error:
    goto Cleanup;
}


/*///////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridgeApp::AddressSupportsMediaType (ITAddress *pAddr, long lMediaType)
{
    VARIANT_BOOL vbSupport = VARIANT_FALSE;
    ITMediaSupport * pMediaSupport;

    if (SUCCEEDED(pAddr->QueryInterface (IID_ITMediaSupport, (void**)&pMediaSupport)))
    {
        pMediaSupport->QueryMediaType (lMediaType, &vbSupport);
        pMediaSupport->Release ();
    }
    return (vbSupport==VARIANT_TRUE);
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridgeApp::IsStream (ITStream *pStream, long lMediaType, TERMINAL_DIRECTION tdDirection)
{
    long mediatype;
    TERMINAL_DIRECTION direction;

    if (FAILED (pStream->get_Direction(&direction)))
        return false;
    if (FAILED (pStream->get_MediaType(&mediatype)))
        return false;
    return ((direction == tdDirection) &&
           (mediatype == lMediaType));
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::NextSubStream ()
{
    HRESULT hr = S_OK;

    CBridgeItem **ItemArray = NULL;
    int num, i;

    ITSubStreamControl *pSubControl = NULL;
    IEnumSubStream *pEnumSub = NULL;
    ULONG fetched;
    ITSubStream *pSubStream = NULL;
    BOOL fActive = FALSE; // if active stream found
    ITSubStream *pSubInactive = NULL;
    ITSubStream *pSubFirstInactive = NULL;

    IEnumTerminal *pEnumTerminal = NULL;
    ITParticipantSubStreamControl *pSwitcher = NULL;

    // get all stored call items
    if (FAILED (hr = m_pList->GetAllItems (&ItemArray, &num)))
        return hr;

    if (num == 0)
        return S_OK;

    // for each call item
    for (i=0; i<num; i++)
    {
        // get substream control
        if (NULL == ItemArray[i]->pStreamSVidRen)
            continue;
        if (FAILED (hr = ItemArray[i]->pStreamSVidRen->QueryInterface (&pSubControl)))
            goto Error;

        // get substreams on sdp video render
        if (FAILED (hr = pSubControl->EnumerateSubStreams (&pEnumSub)))
            goto Error;

        pSubControl->Release ();
        pSubControl = NULL;

        // for each substream, if !(both active & inactive substream stored)
        // the algo tries to be as fair as possible in switching.
        // it switches the inactive substream just after the active one
        // if the active one is the last in the enum, the first inactive one is chosen
        while (!pSubInactive &&
               (S_OK == (hr = pEnumSub->Next (1, &pSubStream, &fetched)))
              )
        {
            // get terminal enumerator
            if (FAILED (hr = pSubStream->EnumerateTerminals (&pEnumTerminal)))
                goto Error;

            // if the substream active, store the substream
            if (S_OK == pEnumTerminal->Skip (1))
            {
                if (fActive)
                    ;
                //    printf ("oops, another active substream on SDP video render stream");
                else
                    fActive = TRUE;
            }
            else
            {
                // if inactive, store the substream
                if (!pSubFirstInactive)
                {
                    // the first inactive substream
                    pSubFirstInactive = pSubStream;
                    pSubFirstInactive->AddRef ();
                }
                else
                {
                    // store the inactive only if the active was found
                    if (fActive)
                    {
                        pSubInactive = pSubStream;
                        pSubInactive->AddRef ();
                    }
                }
            }

            // release
            pEnumTerminal->Release ();
            pEnumTerminal = NULL;

            pSubStream->Release ();
            pSubStream = NULL;
        }

        pEnumSub->Release ();
        pEnumSub = NULL;

        // if only first inactive is found
        if (pSubFirstInactive && !pSubInactive)
        {
            pSubInactive = pSubFirstInactive;
            pSubFirstInactive = NULL;
        }

        // if not found two substreams, do nothing
        if (pSubInactive && ItemArray[i]->pStreamSVidRen && ItemArray[i]->pTermSHVid)
        {
            if (FAILED (hr = ItemArray[i]->pStreamSVidRen->QueryInterface (&pSwitcher)))
                goto Error;

            // switch terminal on substream
            if (FAILED (hr = pSwitcher->SwitchTerminalToSubStream
                                 (ItemArray[i]->pTermSHVid, pSubInactive)))
                goto Error;

            pSwitcher->Release ();
            pSwitcher = NULL;
        }

        if (pSubFirstInactive)
        {
            pSubFirstInactive->Release ();
            pSubFirstInactive = NULL;
        }
        if (pSubInactive)
        {
            pSubInactive->Release ();
            pSubInactive = NULL;
        }
    }

Cleanup:
    if (ItemArray) free (ItemArray);
    return hr;

Error:
    if (pSubControl) pSubControl->Release ();
    if (pEnumSub) pEnumSub->Release ();

    if (pSubStream) pSubStream->Release ();
    if (pSubInactive) pSubInactive->Release ();
    if (pSubFirstInactive) pSubFirstInactive->Release ();

    if (pEnumTerminal) pEnumTerminal->Release ();
    if (pSwitcher) pSwitcher->Release ();

    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::ShowParticipant (ITBasicCallControl *pSDPCall, ITParticipant *pParticipant)
{
    ENTER_FUNCTION ("CBridgeApp::ShowParticipant");

    HRESULT hr;
    IUnknown *pIUnknown = NULL;
    CBridgeItem *pItem = NULL;
    ITParticipantSubStreamControl *pSwitcher = NULL;
    ITSubStream *pSubStream = NULL;

    // get IUnknown
    if (FAILED (hr = pSDPCall->QueryInterface (IID_IUnknown, (void**)&pIUnknown)))
    {
        LOG ((BG_ERROR, "%s failed to query interface IUnknown, %x", __fxName, hr));
        return hr;
    }

    // find the item matches pSDPCall
    pItem = m_pList->FindBySDP (pIUnknown);
    pIUnknown->Release ();
    pIUnknown = NULL;

    // oops, no match
    if (NULL == pItem)
        return S_FALSE;

    // get participant substream control interface
    if (NULL == pItem->pStreamSVidRen)
        return S_OK;
    if (FAILED (hr = pItem->pStreamSVidRen->QueryInterface (&pSwitcher)))
    {
        LOG ((BG_ERROR, "%s failed to query interface ITParticipantSubStreamControl, %x", __fxName, hr));
        return hr;
    }

    // get substream from participant
    if (FAILED (hr = pSwitcher->get_SubStreamFromParticipant (pParticipant, &pSubStream)))
    {
        pSwitcher->Release ();
        pSwitcher = NULL;
        LOG ((BG_WARN, "%s failed to get substream from participant, %x", __fxName, hr));
        // stream from h323 side does not have substream, report false
        return S_FALSE;
    }

    // switch
    if (pItem->pTermSHVid)
        hr = pSwitcher->SwitchTerminalToSubStream (pItem->pTermSHVid, pSubStream);
    
    pSubStream->Release ();
    pSubStream = NULL;

    pSwitcher->Release ();
    pSwitcher = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\bgdebug.h ===
/*++

Module Name

    bgdebug.h

Description

    Defines functions used for debugging

Note

    Revised based on msplog.h which is not available to bridge test app

--*/

#ifndef _BGDEBUG_H
#define _BGDEBUG_H

    typedef enum EVENT_TYPE
    {
        BG_TE,
        BG_CS,
        BG_CME,
        BG_PE
    }EVENT_TYPE;

    #define BG_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define BG_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define BG_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define BG_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define BG_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL BGLogRegister(LPCTSTR szName);
    void BGLogDeRegister();
    void BGLogPrint(DWORD dwDbgLevel, LPCSTR DbgMessage, ...);
    void BGLogEvent (EVENT_TYPE EventType, int event);

#ifdef BGDEBUG

    #define BGLOGREGISTER(arg) BGLogRegister(arg)
    #define BGLOGDEREGISTER() BGLogDeRegister()
    #define LOG(arg) BGLogPrint arg
    #define LOGEvent(arg) BGLogEvent arg

#else // BGDEBUG

    #define BGLOGREGISTER(arg)
    #define BGLOGDEREGISTER()
    #define LOG(arg)
    #define LOGEvent(arg)

#endif // BGDEBUG

#endif // _BGDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\bgevent.h ===
/*******************************************************************************

Module Name:

    bgevent.h

Abstract:

    Defines event class used by TAPI to notify event coming.

Author:

    Qianbo Huai (qhuai) Jan 27 2000
*******************************************************************************/

#ifndef _BGEVENT_H
#define _BGEVENT_H

class CTAPIEventNotification
:public ITTAPIEventNotification
{
public:
    CTAPIEventNotification ()
    {
        m_dwRefCount = 1;
    }
    ~CTAPIEventNotification () {}

    HRESULT STDMETHODCALLTYPE QueryInterface (REFIID iid, void **ppvObj);

    ULONG STDMETHODCALLTYPE AddRef ();

    ULONG STDMETHODCALLTYPE Release ();

    HRESULT STDMETHODCALLTYPE Event (TAPI_EVENT TapiEvent, IDispatch *pEvent);

private:
    long m_dwRefCount;
};

#endif // _BGEVENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\bgevent.cpp ===
/*******************************************************************************

Module:

    bgevent.cpp

Abstract:

    Class implementing TAPI event

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#include "stdafx.h"

extern HWND ghDlg;

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::QueryInterface (
    REFIID iid,
    void **ppvObj
    )
{
    if (iid==IID_ITTAPIEventNotification)
    {
        AddRef ();
        *ppvObj = (void *)this;
        return S_OK;
    }
    if (iid==IID_IUnknown)
    {
        AddRef ();
        *ppvObj = (void *)this;
    }
    return E_NOINTERFACE;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
ULONG
STDMETHODCALLTYPE
CTAPIEventNotification::AddRef ()
{
    ULONG l = InterlockedIncrement (&m_dwRefCount);
    return l;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
ULONG
STDMETHODCALLTYPE
CTAPIEventNotification::Release ()
{
    ULONG l = InterlockedDecrement (&m_dwRefCount);
    if (0 == l)
    {
        delete this;
    }
    return l;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event (
    TAPI_EVENT TapiEvent,
    IDispatch * pEvent
    )
{
    // Addref the event so it doesn't go away.
    pEvent->AddRef();

    // Post a message to our own UI thread.
    PostMessage(
        ghDlg,
        WM_PRIVATETAPIEVENT,
        (WPARAM) TapiEvent,
        (LPARAM) pEvent
        );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\bgdebug.cpp ===
/*++

Module Name

    bgdebug.cpp

Description

    Implements functions used for debugging

Note

    Revised based on msplog.cpp which is not available to bridge test app

--*/

#include "stdafx.h"
#include <stdio.h>

#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwDebuggerMask      = 0;


BOOL BGLogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
		DWORD      dwDataSize = sizeof (DWORD);
		DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

void BGLogDeRegister()
{
    sg_dwTracingToDebugger = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void BGLogPrint(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...)
/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    static char * message[24] = 
    {
        "ERROR", 
        "WARNING", 
        "INFO", 
        "TRACE", 
        "EVENT",
        "INVALID TRACE LEVEL"
    };

    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {
        switch(dwDbgLevel)
        {
        case BG_ERROR: dwIndex = 0; break;
        case BG_WARN:  dwIndex = 1; break;
        case BG_INFO:  dwIndex = 2; break;
        case BG_TRACE: dwIndex = 3; break;
        case BG_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  message[dwIndex]);

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        switch(dwDbgLevel)
        {
        case BG_ERROR: dwIndex = 0; break;
        case BG_WARN:  dwIndex = 1; break;
        case BG_INFO:  dwIndex = 2; break;
        case BG_TRACE: dwIndex = 3; break;
        case BG_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        wsprintfA(szTraceBuf, "[%s] %s", message[dwIndex], lpszFormat);

        va_list arglist;
        va_start(arglist, lpszFormat);
        TraceVprintfExA(sg_dwTraceID, dwDbgLevel, szTraceBuf, arglist);
        va_end(arglist);
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    don't assume enum value doesn't change
////*/
// the order should be the same as event type enum
char* gsaType[] =
{
    "Tapi Event",
    "Call State",
    "Call Media",
    "Participant Event"
};

typedef struct
{
    int id;
    char *str;
}EVENT_ITEM;

//========================================
EVENT_ITEM gaTE[]=
{
    TE_TAPIOBJECT,          "Tapi Object",
    TE_ADDRESS,             "Address",
    TE_CALLNOTIFICATION,    "Call Notification",
    TE_CALLSTATE,           "Call State",
    TE_CALLMEDIA,           "Call Media",
    TE_CALLHUB,             "Call Hub",
    TE_CALLINFOCHANGE,      "Call Info Change",
    TE_PRIVATE,             "Private",
    TE_REQUEST,             "Request",
    TE_AGENT,               "Agent",
    TE_AGENTSESSION,        "Agent Session",
    TE_QOSEVENT,            "QoS Event",
    TE_AGENTHANDLER,        "Agent Handler",
    TE_ACDGROUP,            "ACD Group",
    TE_QUEUE,               "Queue",
    TE_DIGITEVENT,          "Digit Event",
    TE_GENERATEEVENT,       "Generate Event"
};

int giaTENum = sizeof (gaTE) / sizeof (EVENT_ITEM);

//========================================
EVENT_ITEM gaCS[] =
{
    CS_IDLE,            "IDLE",
    CS_INPROGRESS,      "In Progress",
    CS_CONNECTED,       "Connected",
    CS_DISCONNECTED,    "Disconnected",
    CS_OFFERING,        "Offering",
    CS_HOLD,            "Hold",
    CS_QUEUED,          "Queued"
};

int giaCSNum = sizeof (gaCS) / sizeof (EVENT_ITEM);

//========================================
EVENT_ITEM gaCME[] =
{
    CME_NEW_STREAM,         "New Stream",
    CME_STREAM_FAIL,        "Stream Fail",
    CME_TERMINAL_FAIL,      "Terminal Fail",
    CME_STREAM_NOT_USED,    "Stream Not Used",
    CME_STREAM_ACTIVE,      "Stream Active",
    CME_STREAM_INACTIVE,    "Stream Inactive"
};

int giaCMENum = sizeof (gaCME) / sizeof (EVENT_ITEM);

//========================================
EVENT_ITEM gaPE[] =
{
    PE_NEW_PARTICIPANT,         "New Participant",
    PE_INFO_CHANGE,             "Info Change",
    PE_PARTICIPANT_LEAVE,       "Participant Leave",

    PE_NEW_SUBSTREAM,           "New Substream",
    PE_SUBSTREAM_REMOVED,       "Substream Removed",

    PE_SUBSTREAM_MAPPED,        "Substream Mapped",
    PE_SUBSTREAM_UNMAPPED,      "SubStream Unmapped",

    PE_PARTICIPANT_TIMEOUT,     "Participant Timeout",
    PE_PARTICIPANT_RECOVERED,   "Participant Recovered",

    PE_PARTICIPANT_ACTIVE,      "Participant Active",
    PE_PARTICIPANT_INACTIVE,    "Participant Inactive",

    PE_LOCAL_TALKING,           "Local Talking",
    PE_LOCAL_SILENT,            "Local Silent"
};

int giaPENum = sizeof (gaPE) / sizeof (EVENT_ITEM);

/*//////////////////////////////////////////////////////////////////////////////
////*/
void BGLogEvent (EVENT_TYPE EventType, int event)
{
    EVENT_ITEM *aEvent;
    int i, num;

    switch (EventType)
    {
    case BG_TE:
        aEvent = gaTE;
        num = giaTENum;
        break;
    case BG_CS:
        aEvent = gaCS;
        num = giaCSNum;
        break;
    case BG_CME:
        aEvent = gaCME;
        num = giaCMENum;
        break;
    case BG_PE:
        aEvent = gaPE;
        num = giaPENum;
        break;
    default:
        LOG ((BG_ERROR, "Unsupported event type (%d, %d)", EventType, event));
        return;
        break;
    }

    // search the event index string
    for (i=0; i<num; i++)
    {
        if (event != aEvent[i].id)
            continue;

        // match
        LOG ((BG_EVENT, "%s: %s (%d, %d)",
            gsaType[EventType], aEvent[i].str, EventType, event));
        return;
    }

    // not found
    LOG ((BG_ERROR, "Event string not found (%d, %d)", EventType, event));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by work.rc
//
#define IDD_MAINDLG                     101
#define IDC_DISCONNECT                  1000
#define IDC_EXIT                        1001
#define IDC_STATUS                      1002
#define IDC_NEXTSUBSTREAM               1006
#define IDC_REJECT                      1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\bgitem.cpp ===
/*******************************************************************************

Module Name:

    bgitem.cpp

Abstract:

    Implements CBridgeItem and CBridgeItemList

Author:

    Qianbo Huai (qhuai) Jan 28 2000

*******************************************************************************/

#include "stdafx.h"

/*///////////////////////////////////////////////////////////////////////////////
    constructs CBridgeItem
////*/
CBridgeItem::CBridgeItem ()
    :next (NULL)
    ,prev (NULL)

    ,bstrID (NULL)
    ,bstrName (NULL)

    ,pCallH323 (NULL)
    ,pCallSDP (NULL)

    ,pTermHSAud (NULL)
    ,pTermHSVid (NULL)
    ,pTermSHAud (NULL)
    ,pTermSHVid (NULL)

    ,pStreamHAudCap (NULL)
    ,pStreamHAudRen (NULL)
    ,pStreamHVidCap (NULL)
    ,pStreamHVidRen (NULL)

    ,pStreamSAudCap (NULL)
    ,pStreamSAudRen (NULL)
    ,pStreamSVidCap (NULL)
    ,pStreamSVidRen (NULL)
{
}

/*//////////////////////////////////////////////////////////////////////////////
    destructs CBridgeItem
////*/
CBridgeItem::~CBridgeItem ()
{
    // free BSTR
    if (bstrID)
    {
        SysFreeString (bstrID);
        bstrID = NULL;
    }
    if (bstrName)
    {
        SysFreeString (bstrName);
        bstrName = NULL;
    }

    // free terminals
    if (pTermHSAud)
    {
        pTermHSAud->Release ();
        pTermHSAud = NULL;
    }
    if (pTermHSVid)
    {
        pTermHSVid->Release ();
        pTermHSVid = NULL;
    }
    if (pTermSHAud)
    {
        pTermSHAud->Release ();
        pTermSHAud = NULL;
    }
    if (pTermSHVid)
    {
        pTermSHVid->Release ();
        pTermSHVid = NULL;
    }

    // free streams on H323
    if (pStreamHAudCap)
    {
        pStreamHAudCap->Release ();
        pStreamHAudCap = NULL;
    }
    if (pStreamHAudRen)
    {
        pStreamHAudRen->Release ();
        pStreamHAudRen = NULL;
    }
    if (pStreamHVidCap)
    {
        pStreamHVidCap->Release ();
        pStreamHVidCap = NULL;
    }
    if (pStreamHVidRen)
    {
        pStreamHVidRen->Release ();
        pStreamHVidRen = NULL;
    }

    // free streams on SDP
    if (pStreamSAudCap)
    {
        pStreamSAudCap->Release ();
        pStreamSAudCap = NULL;
    }
    if (pStreamSAudRen)
    {
        pStreamSAudRen->Release ();
        pStreamSAudRen = NULL;
    }
    if (pStreamSVidCap)
    {
        pStreamSVidCap->Release ();
        pStreamSVidCap = NULL;
    }
    if (pStreamSVidRen)
    {
        pStreamSVidRen->Release ();
        pStreamSVidRen = NULL;
    }

    // free calls
    if (pCallH323)
    {
        pCallH323->Release ();
        pCallH323 = NULL;
    }
    if (pCallSDP)
    {
        pCallSDP->Release ();
        pCallSDP = NULL;
    }

}

/*//////////////////////////////////////////////////////////////////////////////
    constructs CBridgeItemList
////*/
CBridgeItemList::CBridgeItemList ()
{
    // create a head for the double linked list
    m_pHead = new CBridgeItem;
    if (NULL == m_pHead)
    {
        // @@ severe error, outof memory? put some debug info here?
        return;
    }

    m_pHead->next = m_pHead;
    m_pHead->prev = m_pHead;
}

/*//////////////////////////////////////////////////////////////////////////////
    destructs CBridgeItemList
////*/
CBridgeItemList::~CBridgeItemList ()
{
    // app should already disconnected all calls
    // i just release the com objects here
    CBridgeItem *pItem = NULL;

    while (NULL != (pItem = DeleteFirst ()))
    {
        delete pItem;
        pItem = NULL;
    }

    delete m_pHead;
    m_pHead = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
#define FIND_BY_H323 1
#define FIND_BY_SDP 2

CBridgeItem *
CBridgeItemList::Find (int flag, IUnknown *pIUnknown)
{
    // transfer through the list, stop at the first matches
    HRESULT hr;
    IUnknown *pStore = NULL;
    CBridgeItem *pItem = m_pHead;

    while (m_pHead != (pItem = pItem->next))
    {
        // @@ should report error info if failed
        if (flag == FIND_BY_H323)
            hr = pItem->pCallH323->QueryInterface (IID_IUnknown, (void**)&pStore);
        else
            hr = pItem->pCallSDP->QueryInterface (IID_IUnknown, (void**)&pStore);

        if (FAILED (hr))
            return NULL;

        if (pIUnknown == pStore)
        {
            pStore->Release ();
            return pItem;
        }
        if (pStore)
        {
            pStore->Release ();
            pStore = NULL;
        }
    }

    return NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
    finds a bridge item based on IUnknown of H323 call
////*/
CBridgeItem *
CBridgeItemList::FindByH323 (IUnknown *pIUnknown)
{
    return Find (FIND_BY_H323, pIUnknown);
}

/*//////////////////////////////////////////////////////////////////////////////
    finds a bridge item based on IUnknown of sdp call
////*/
CBridgeItem *
CBridgeItemList::FindBySDP (IUnknown *pIUnknown)
{
    return Find (FIND_BY_SDP, pIUnknown);
}

/*//////////////////////////////////////////////////////////////////////////////
    takes the item out of the list
////*/
void
CBridgeItemList::TakeOut (CBridgeItem *pItem)
{
    // ignore to check if pItem is really in the list
    pItem->next->prev = pItem->prev;
    pItem->prev->next = pItem->next;

    pItem->next = NULL;
    pItem->prev = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
    deletes from the list and returns the first item if the list is not empty
////*/
CBridgeItem *
CBridgeItemList::DeleteFirst ()
{
    CBridgeItem *pItem = m_pHead->next;
    
    // if list empty
    if (pItem == m_pHead)
        return NULL;

    // adjust list
    TakeOut (pItem);

    return pItem;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridgeItemList::GetAllItems (CBridgeItem ***pItemArray, int *pNum)
{
    // ignore checking pointers
    int num = 0;
    CBridgeItem *pItem = m_pHead;

    while (m_pHead != (pItem = pItem->next))
        num ++;

    // no call found
    if (num == 0)
    {
        *pItemArray == NULL;
        *pNum = 0;
        return true;
    }

    *pItemArray = (CBridgeItem**)malloc (num * sizeof (CBridgeItem*));
    *pNum = num;

    if (NULL == *pItemArray)
    {
        return false;
    }

    // copy items pointers
    pItem = m_pHead;
    num = 0;
    while (m_pHead != (pItem = pItem->next))
        (*pItemArray)[num++] = pItem;

    return true;
}

/*//////////////////////////////////////////////////////////////////////////////
    appends an item to the end of the list
////*/
void
CBridgeItemList::Append (CBridgeItem *pItem)
{
    pItem->next = m_pHead;
    pItem->prev = m_pHead->prev;
    pItem->next->prev = pItem;
    pItem->prev->next = pItem;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridgeItemList::IsEmpty ()
{
    if (m_pHead->next == m_pHead)
        return true;
    else
        return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\bgitem.h ===
/*******************************************************************************

Module Name:

    bgitem.h

Abstract:

    Defines CBridgeItem and CBridgeItemList for storing info for bridge objects

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#ifndef _BGITEM_H
#define _BGITEM_H

class CBridgeItem
{
public:
    CBridgeItem ();
    ~CBridgeItem ();

    // forward link
    CBridgeItem *next;
    // backward link
    CBridgeItem *prev;

    // caller identity
    BSTR bstrID;
    BSTR bstrName;

    // call controls
    ITBasicCallControl *pCallH323;
    ITBasicCallControl *pCallSDP;

    // terminals
    ITTerminal *pTermHSAud;
    ITTerminal *pTermHSVid;
    ITTerminal *pTermSHAud;
    ITTerminal *pTermSHVid;

    // h323 side streams
    ITStream *pStreamHAudCap;
    ITStream *pStreamHAudRen;
    ITStream *pStreamHVidCap;
    ITStream *pStreamHVidRen;

    // sdp side streams
    ITStream *pStreamSAudCap;
    ITStream *pStreamSAudRen;
    ITStream *pStreamSVidCap;
    ITStream *pStreamSVidRen;
};

class CBridgeItemList
{
public:
    CBridgeItemList ();
    ~CBridgeItemList ();

    CBridgeItem *FindByH323 (IUnknown *pIUnknown);
    CBridgeItem *FindBySDP (IUnknown *pIUnknown);
    void TakeOut (CBridgeItem *pItem);
    CBridgeItem *DeleteFirst ();
    void Append (CBridgeItem *pItem);
    BOOL GetAllItems (CBridgeItem ***pItemArray, int *pNum);
    BOOL IsEmpty ();

private:
    CBridgeItem *Find (int flag, IUnknown *pIUnknown);
    CBridgeItem *m_pHead;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\inc\confpdu.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    confpdu.h

Abstract:

    Declaration of the data structures used in the communication between
    the IPconf tsp and the ipconf msp.

Author:
    
    Mu Han (muhan) 5-September-1998

--*/

#ifndef __CONFPDU_H_
#define __CONFPDU_H_

typedef enum 
{
    // sent from TSP to MSP to start a call
    CALL_START,
             
    // sent from TSP to MSP to stop a call
    CALL_STOP,
     
    // sent from MSP to TSP to notify that the call is connected.
    CALL_CONNECTED,    

    // sent from MSP to TSP to notify that the call is disconnected.
    CALL_DISCONNECTED,

    // sent from MSP to TSP to notify that the call is disconnected.
    CALL_QOS_EVENT

} TSP_MSP_COMMAND;

typedef struct _MSG_CALL_START 
{
    DWORD dwAudioQOSLevel;
    DWORD dwVideoQOSLevel;
    
    DWORD dwSDPLen;    // number of wchars in the string.
    WCHAR szSDP[1];

} MSG_CALL_START, *PMSG_CALL_START;

typedef struct _MSG_CALL_DISCONNECTED 
{
    DWORD dwReason;

} MSG_CALL_DISCONNECTED, *PMSG_CALL_DISCONNECTED;

typedef struct _MSG_QOSEVENT
{
    DWORD dwEvent;
    DWORD dwMediaMode;

} MSG_QOS_EVENT, *PMSG_QOS_EVENT;

typedef struct _TSPMSPDATA 
{
    TSP_MSP_COMMAND command;

    union 
    {
        MSG_CALL_START          CallStart;
        MSG_CALL_DISCONNECTED   CallDisconnected;
        MSG_QOS_EVENT           QosEvent;
    };

} MSG_TSPMSPDATA, *PMSG_TSPMSPDATA;
      

#endif //__CONFPDU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include <objbase.h>
#include <winsock2.h>
#include <tapi3.h>
#include <control.h>
#include <strmif.h>
#include <confpriv.h>
#include <h323priv.h>
#include <rtutils.h>

#include "bgdebug.h"
#include "resource.h"
#include "bgevent.h"
#include "bgitem.h"
#include "bgapp.h"

// H323 call listener sends event to dialog box
#define WM_PRIVATETAPIEVENT   WM_USER+101

// use log functions by msp
#ifdef BGDEBUG
    #define ENTER_FUNCTION(s) \
        const CHAR __fxName[] = s
#else
    #define ENTER_FUNCTION(s)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\bridge\test2\work.cpp ===
/*******************************************************************************

Module Name:

    work.cpp

Abstract:

    Implements main function of the bridge test application

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#include "stdafx.h"

// command line
LPSTR glpCmdLine = NULL;

// dialog
HWND ghDlg = NULL;

// true: exit button on dialog was clicked
bool gfExitButton = false;

// bridge
CBridgeApp *gpBridgeApp = NULL;

// callback func in dialog
BOOL
CALLBACK
MainDialogProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

// func to deal with TAPI events
HRESULT
OnTapiEvent (
    TAPI_EVENT TapiEvent,
    IDispatch *pEvent
    );

HRESULT
OnPrivateEvent (IDispatch *pEvent);

// set status message on dialog
void SetStatusMessage (LPWSTR pszMessage);
void DoMessage (LPWSTR pszMessage);
void EnableDisconnectButton (BOOL fYes);

/*//////////////////////////////////////////////////////////////////////////////
    WinMain
////*/
int
WINAPI
WinMain (
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpCmdLine,
    int nShowCmd
    )
{
    // init com
    if (FAILED (CoInitializeEx(NULL, COINIT_MULTITHREADED)))
        return 0;

    // init debug
    BGLOGREGISTER (L"work");

    // keep command line which determines which SDP to join
    glpCmdLine = lpCmdLine;

    // init CBridgeApp
    HRESULT hr;
    gpBridgeApp = new CBridgeApp (&hr);
    if (gpBridgeApp==NULL || FAILED (hr))
    {
        LOG ((BG_ERROR, "Failed to init CBridgeApp"));
        return 0;
    }
    
    // start dialog box
    if (!DialogBox (hInst, MAKEINTRESOURCE(IDD_MAINDLG), NULL, MainDialogProc))
    {
        LOG ((BG_TRACE, "Dialog ends"));
    }

    // dialog finished
    delete gpBridgeApp;

    BGLOGDEREGISTER ();
    CoUninitialize ();

    return 1;
}

/*//////////////////////////////////////////////////////////////////////////////
    Callback for dialog
////*/
BOOL
CALLBACK
MainDialogProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            ghDlg = hDlg;
            EnableDisconnectButton (false);
            return 0;
        }
    case WM_PRIVATETAPIEVENT:
        {
            OnTapiEvent ((TAPI_EVENT)wParam, (IDispatch *)lParam);
            return 0;
        }
    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDC_EXIT:
                {
                    gfExitButton = true;
                    gpBridgeApp->DisconnectAllCalls (DC_NORMAL);

                    // check if in connection
                    if (!IsWindowEnabled (GetDlgItem (ghDlg, IDC_DISCONNECT)))
                    {
                        // not in connection
                        EndDialog (ghDlg, 0);
                    }
                    // else
                        // remember exit button is clicked
                        // do not call EndDialog because a disconnected event is to come

                    return 1;
                }
            case IDC_DISCONNECT:
                {
                    gpBridgeApp->DisconnectAllCalls (DC_NORMAL);

                    // disable disconnect button
                    EnableDisconnectButton (false);
                    return 1;
                }
            }
            case IDC_NEXTSUBSTREAM:
                {
                    gpBridgeApp->NextSubStream ();
                    return 1;
                }

            return 0;
        }
    default:
        return 0;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    Deals with TAPI events
////*/
HRESULT OnTapiEvent (
    TAPI_EVENT TapiEvent,
    IDispatch *pEvent
    )
{
    HRESULT hr = S_OK;

//    LOGEvent ((BG_TE, TapiEvent));

    switch (TapiEvent)
    {
    case TE_CALLNOTIFICATION:
        {
            if (BST_CHECKED != IsDlgButtonChecked (ghDlg, IDC_REJECT))
            {
                // if h323 call and to us, init h323 call
                if (FAILED (hr = gpBridgeApp->CreateH323Call (pEvent)));
                    LOG ((BG_ERROR, "Failed to create h323 call, %x", hr));
            }
            break;
        }
    case TE_CALLSTATE:
        {
            CALL_STATE cs;
            ITCallStateEvent *pCallStateEvent = NULL;

            // get call state event
            hr = pEvent->QueryInterface (
                IID_ITCallStateEvent,
                (void **)&pCallStateEvent
                );
            if (FAILED(hr)) break;

            // get call state
            hr = pCallStateEvent->get_State (&cs);
            pCallStateEvent->Release ();
            if (FAILED(hr)) break;

//            LOGEvent ((BG_CS, cs));

            // if offering, connect
            if (CS_OFFERING == cs)
            {
                CBridgeItem *pItem = NULL;

                // check if h323 call created successful
                hr = gpBridgeApp->HasH323Call (pEvent, &pItem);
                if (S_OK != hr || NULL == pItem)
                {
                    LOG ((BG_ERROR, "Failed to check h323 call, %x", hr));
                    hr = S_OK;
                    break;
                }

                // create sdp call
                if (FAILED (hr = gpBridgeApp->CreateSDPCall (pItem)))
                {
                    gpBridgeApp->DisconnectCall (pItem, DC_REJECTED);

                    // delete pItem;
                    LOG ((BG_ERROR, "Failed to create SDP call, %x", hr));
                    break;
                }

                // bridge call
                if (FAILED (hr = gpBridgeApp->BridgeCalls (pItem)))
                {
                    gpBridgeApp->DisconnectCall (pItem, DC_REJECTED);

                    // delete pItem;
                    LOG ((BG_ERROR, "Failed to bridge calls, %x", hr));
                    break;
                }

                // enable disconnect button
                EnableDisconnectButton (true);
            }
            // if disconnect
            else if (CS_DISCONNECTED == cs)
            {
                CBridgeItem *pItem = NULL;

                // check if h323 call created successful
                hr = gpBridgeApp->HasH323Call (pEvent, &pItem);
                if (S_OK == hr && NULL != pItem)
                {
                    // the call already disconnected
                    // call disconnect here only to remove pItem from the list
                    gpBridgeApp->RemoveCall (pItem);
                    delete pItem;
                }

                // if exit button is clicked and all call disconnected
                if (gfExitButton)
                {
                    if (S_OK != gpBridgeApp->HasCalls ())
                        EndDialog (ghDlg, 0);
                }
                else
                {
                    if (S_OK != gpBridgeApp->HasCalls ())
                        EnableDisconnectButton (false);
                }                
            }
            break;
        }
    case TE_CALLMEDIA:
        {
            CALL_MEDIA_EVENT cme;
            ITCallMediaEvent *pCallMediaEvent;

            // get call media event
            hr = pEvent->QueryInterface (
                IID_ITCallMediaEvent,
                (void **)&pCallMediaEvent
                );
            if (FAILED(hr)) break;

            // get the event
            hr = pCallMediaEvent->get_Event (&cme);
            if (FAILED(hr)) break;

//            LOGEvent ((BG_CME, cme));

            // check media event
            switch (cme)
            {
                case CME_STREAM_FAIL:
                    hr = E_FAIL;
                    LOG ((BG_ERROR, "Stream failed"));
                    break; 
                case CME_TERMINAL_FAIL:
                    hr = E_FAIL;
                    LOG ((BG_ERROR, "Terminal failed"));
                    break;
                default:
                    break;
            }

            // we no longer need this interface.
            pCallMediaEvent->Release();
            break;
        }
    case TE_PRIVATE:
        hr = OnPrivateEvent (pEvent);
        break;
    default:
        break;
    }

    pEvent->Release(); // we addrefed it CTAPIEventNotification::Event()
    
    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT OnPrivateEvent (
    IDispatch *pEvent
    )
{
    ENTER_FUNCTION ("OnPrivateEvent");
//    LOG ((BG_TRACE, "%s entered", __fxName));

    HRESULT hr = S_OK;

    ITPrivateEvent *pPrivateEvent = NULL;
    IDispatch *pDispatch = NULL;
    ITParticipantEvent *pPartEvent = NULL;
    ITParticipant *pParticipant = NULL;
    PARTICIPANT_EVENT event;

    ITCallInfo *pCallInfo = NULL;
    ITBasicCallControl *pCallControl = NULL;

    // get private event interface
    if (FAILED (hr = pEvent->QueryInterface (&pPrivateEvent)))
    {
        LOG ((BG_ERROR, "%s failed to query ITPrivateEvent", __fxName));
        return hr;
    }

    // get event interface
    if (FAILED (hr = pPrivateEvent->get_EventInterface (&pDispatch)))
    {
        LOG ((BG_ERROR, "%s failed to query event interface", __fxName));
        goto Error;
    }

    // get participant event interface
    hr = pDispatch->QueryInterface (&pPartEvent);
    pDispatch->Release ();
    pDispatch = NULL;

    if (FAILED (hr))
    {
        LOG ((BG_ERROR, "%s failed to query participant interface", __fxName));
        goto Error;
    }

    // get event
    if (FAILED (hr = pPartEvent->get_Event (&event)))
    {
        LOG ((BG_ERROR, "%s failed to get event", __fxName));
        goto Error;
    }

//    LOGEvent ((BG_PE, event));

    // check the event
    switch (event)
    {
        case PE_PARTICIPANT_ACTIVE:
            {
                // get call info
                if (FAILED (hr = pPrivateEvent->get_Call (&pCallInfo)))
                {
                    LOG ((BG_ERROR, "%s failed to get call info", __fxName));
                    goto Error;
                }

                // get call control
                if (FAILED (hr = pCallInfo->QueryInterface (&pCallControl)))
                {
                    LOG ((BG_ERROR, "%s failed to get call control", __fxName));
                    goto Error;
                }

                // get participant interface
                if (FAILED (hr = pPartEvent->get_Participant (&pParticipant)))
                {
                    LOG ((BG_ERROR, "%s failed to get participant", __fxName));
                    goto Error;
                }

                // show participant
                hr = gpBridgeApp->ShowParticipant (pCallControl, pParticipant);
                if (FAILED (hr))
                {
                    LOG ((BG_ERROR, "%s failed to show participant, %x", __fxName, hr));
                }

                if (S_FALSE == hr)
                {
                    hr = S_OK;
                    // *ppszMessage = L"Participant active but call not found in list";
                    // or no substream found on the stream
                }
            }
            break;
        default:
            break;

    }
Cleanup:
    if (pCallInfo) pCallInfo->Release ();
    if (pCallControl) pCallControl->Release ();
    if (pPrivateEvent) pPrivateEvent->Release ();
    if (pPartEvent) pPartEvent->Release ();
    if (pParticipant) pParticipant->Release ();

//    LOG ((BG_TRACE, "%s exits", __fxName));
    return hr;

Error:
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
    Popup message box
////*/
WCHAR gMsgBoxTitle[] = L"TAPI 3.0 Bridge Test Application";

void
DoMessage (LPWSTR pszMessage)
{
#if POPUP_MESSAGE
    MessageBox (
        ghDlg,
        pszMessage,
        gMsgBoxTitle,
        MB_OK
        );
#endif
}

/*//////////////////////////////////////////////////////////////////////////////
    Status message
////*/
void
SetStatusMessage (LPWSTR pszMessage)
{
    SetDlgItemText (ghDlg, IDC_STATUS, pszMessage);
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
void
EnableDisconnectButton (BOOL fYes)
{
    if (fYes)
    {
        // enable
        SetStatusMessage (L"Bridging calls ...");

        SendDlgItemMessage (
            ghDlg,
            IDC_NEXTSUBSTREAM,
            BM_SETSTYLE,
            BS_DEFPUSHBUTTON,
            0
            );
        SendDlgItemMessage (
            ghDlg,
            IDC_DISCONNECT,
            BM_SETSTYLE,
            BS_DEFPUSHBUTTON,
            0
            );
        EnableWindow (
            GetDlgItem (ghDlg, IDC_NEXTSUBSTREAM),
            TRUE
            );
        EnableWindow (
            GetDlgItem (ghDlg, IDC_DISCONNECT),
            TRUE
            );
        SetFocus (GetDlgItem (ghDlg, IDC_DISCONNECT));
    }
    else
    {
        // disable
        SetStatusMessage (L"Waiting for calls ...");

        SendDlgItemMessage (
            ghDlg,
            IDC_NEXTSUBSTREAM,
            BM_SETSTYLE,
            BS_PUSHBUTTON,
            0
            );
        SendDlgItemMessage (
            ghDlg,
            IDC_DISCONNECT,
            BM_SETSTYLE,
            BS_PUSHBUTTON,
            0
            );
        EnableWindow (
            GetDlgItem (ghDlg, IDC_NEXTSUBSTREAM),
            FALSE
            );
        EnableWindow (
            GetDlgItem (ghDlg, IDC_DISCONNECT),
            FALSE
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confaddr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confaddr.cpp 

Abstract:

    This module contains implementation of CIPConfMSP.

Author:
    
    Mu Han (muhan)   5-September-1997

--*/
#include "stdafx.h"

#include <initguid.h>
DEFINE_GUID(CLSID_IPConfMSP, 0x0F1BE7F7, 0x45CA, 0x11d2,
            0x83, 0x1F, 0x0, 0xA0, 0x24, 0x4D, 0x22, 0x98);

#ifdef USEIPADDRTABLE

#include <iprtrmib.h>

typedef DWORD (WINAPI * PFNGETIPADDRTABLE)(
                OUT    PMIB_IPADDRTABLE pIPAddrTable,
                IN OUT PDWORD           pdwSize,
                IN     BOOL             bOrder
                );

#define IPHLPAPI_DLL        L"IPHLPAPI.DLL"

#define GETIPADDRTABLE      "GetIpAddrTable"    

#define IsValidInterface(_dwAddr_) \
    (((_dwAddr_) != 0) && \
     ((_dwAddr_) != htonl(INADDR_LOOPBACK)))

#endif

#define IPCONF_WINSOCKVERSION     MAKEWORD(2,0)

HRESULT CIPConfMSP::FinalConstruct()
{
    // initialize winsock stack
    WSADATA wsaData;
    if (WSAStartup(IPCONF_WINSOCKVERSION, &wsaData) != 0)
    {
        LOG((MSP_ERROR, "WSAStartup failed with:%x", WSAGetLastError()));
        return E_FAIL;
    }

    // allocate control socket
    m_hSocket = WSASocket(
        AF_INET,            // af
        SOCK_DGRAM,         // type
        IPPROTO_IP,         // protocol
        NULL,               // lpProtocolInfo
        0,                  // g
        0                   // dwFlags
        );

    // validate handle
    if (m_hSocket == INVALID_SOCKET) {

        LOG((
            MSP_ERROR,
            "error %d creating control socket.\n",
            WSAGetLastError()
            ));

        // failure
		WSACleanup();
     
        return E_FAIL;
    }

    HRESULT hr = CMSPAddress::FinalConstruct();

	if (hr != S_OK)
	{
		// close socket
		closesocket(m_hSocket);

		// shutdown
		WSACleanup();
	}
	
	return hr;
}

void CIPConfMSP::FinalRelease()
{
    CMSPAddress::FinalRelease();

    if (m_hDxmrtp)
    {
        FreeLibrary(m_hDxmrtp);
        m_hDxmrtp = NULL;
    }

    if (m_hSocket != INVALID_SOCKET)
    {
        // close socket
        closesocket(m_hSocket);
    }

    // shutdown
    WSACleanup();
}

DWORD CIPConfMSP::FindLocalInterface(DWORD dwIP)
{

    SOCKADDR_IN DestAddr;
    DestAddr.sin_family         = AF_INET;
    DestAddr.sin_port           = 0;
    DestAddr.sin_addr.s_addr    = htonl(dwIP);

    SOCKADDR_IN LocAddr;

    // query for default address based on destination

    DWORD dwStatus;
    DWORD dwLocAddrSize = sizeof(SOCKADDR_IN);
    DWORD dwNumBytesReturned = 0;

    if ((dwStatus = WSAIoctl(
		    m_hSocket, // SOCKET s
		    SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
		    &DestAddr,           // LPVOID lpvInBuffer
		    sizeof(SOCKADDR_IN), // DWORD cbInBuffer
		    &LocAddr,            // LPVOID lpvOUTBuffer
		    dwLocAddrSize,       // DWORD cbOUTBuffer
		    &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
		    NULL, // LPWSAOVERLAPPED lpOverlapped
		    NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
	    )) == SOCKET_ERROR) 
    {

	    dwStatus = WSAGetLastError();

	    LOG((MSP_ERROR, "WSAIoctl failed: %d (0x%X)", dwStatus, dwStatus));

        return INADDR_NONE;
    } 

    DWORD dwAddr = ntohl(LocAddr.sin_addr.s_addr);

    if (dwAddr == 0x7f000001)
    {
        // it is loopback address, just return none.
        return INADDR_NONE;
    }

    return dwAddr;
}

HRESULT LoadTapiAudioFilterDLL(
    IN  const TCHAR * const strDllName,
    IN OUT HMODULE * phModule,
    IN  const char * const strAudioGetDeviceInfo,
    IN  const char * const strAudioReleaseDeviceInfo,
    OUT PFNAudioGetDeviceInfo * ppfnAudioGetDeviceInfo,
    OUT PFNAudioReleaseDeviceInfo * ppfnAudioReleaseDeviceInfo
    )
/*++

Routine Description:

    This method enumerate loads the tapi video capture dll.

Arguments:

    str DllName - The name of the dll.

    phModule - memory to store returned module handle.

    ppfnAudioGetDeviceInfo - memory to store the address of AudioGetDeviceInfo
        function.

    ppfnAudioReleaseDeviceInfo - memory to store the address of 
        AudioReleaseDeviceInfo function.
    
Return Value:

    S_OK    - success.
    E_FAIL  - failure.

--*/
{
    ENTER_FUNCTION("CIPConfMSP::LoadTapiAudioFilterDLL");

    // dynamically load the video capture filter dll.
    if (*phModule == NULL)
    {
        *phModule = LoadLibrary(strDllName);
    }

    // validate handle
    if (*phModule == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not load %s., error:%d", 
            __fxName, strDllName, GetLastError()));

        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNAudioGetDeviceInfo pfnAudioGetDeviceInfo 
        = (PFNAudioGetDeviceInfo)GetProcAddress(
                *phModule, strAudioGetDeviceInfo
                );

    // validate function pointer
    if (pfnAudioGetDeviceInfo == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not resolve %s, error:%d", 
            __fxName, strAudioGetDeviceInfo, GetLastError()));

        // failure
        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNAudioReleaseDeviceInfo pfnAudioReleaseDeviceInfo 
        = (PFNAudioReleaseDeviceInfo)GetProcAddress(
                *phModule, strAudioReleaseDeviceInfo
                );

    // validate function pointer
    if (pfnAudioReleaseDeviceInfo == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not resolve %s, error:%d", 
            __fxName, strAudioReleaseDeviceInfo, GetLastError()));

        // failure
        return E_FAIL;
    }

    *ppfnAudioGetDeviceInfo = pfnAudioGetDeviceInfo;
    *ppfnAudioReleaseDeviceInfo = pfnAudioReleaseDeviceInfo;
    
    return S_OK;
}

HRESULT CIPConfMSP::CreateAudioCaptureTerminals()
/*++

Routine Description:

    This method creates audio capture terminals. It uses DShow devenum to 
    enumerate all the wavein capture devices first. Then it will enumerate
    all the DSound capture devices and match them up by name.

Arguments:

    nothing
    
Return Value:

S_OK

--*/
{
    const TCHAR * const strAudioCaptureDll = TEXT("DXMRTP");

    ENTER_FUNCTION("CIPConfMSP::CreateAudioCaptureTerminals");

    // dynamically load the audio capture filter dll.
    PFNAudioGetDeviceInfo pfnAudioGetDeviceInfo;
    PFNAudioReleaseDeviceInfo pfnAudioReleaseDeviceInfo;

    HRESULT hr = LoadTapiAudioFilterDLL(
        strAudioCaptureDll,
        &m_hDxmrtp,
        "AudioGetCaptureDeviceInfo",
        "AudioReleaseCaptureDeviceInfo", 
        &pfnAudioGetDeviceInfo,
        &pfnAudioReleaseDeviceInfo
        );

    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwNumDevices;
    AudioDeviceInfo *pDeviceInfo;

    hr = (*pfnAudioGetDeviceInfo)(&dwNumDevices, &pDeviceInfo);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, AudioGetDeviceInfo failed. hr=%x", __fxName, hr));

        return hr;
    }

    // for each devie, create a terminal.
    for (DWORD i = 0; i < dwNumDevices; i ++)
    {
        ITTerminal *pTerminal;

        hr = CIPConfAudioCaptureTerminal::CreateTerminal(
            &pDeviceInfo[i],
            (MSP_HANDLE) this,
            &pTerminal
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, CreateTerminal for device %d failed. hr=%x",
                __fxName, i, hr));
            break;
        }

        if (!m_Terminals.Add(pTerminal))
        {
            hr = E_OUTOFMEMORY;
            LOG((MSP_ERROR, "%s, out of mem in adding a terminal", __fxName));
            break;
        }
    }

    // release the device info
    (*pfnAudioReleaseDeviceInfo)(pDeviceInfo);

    return hr;
}


HRESULT CIPConfMSP::CreateAudioRenderTerminals()
/*++

Routine Description:

    This method enumerate all the audio render devices and creates a 
    terminal for each of them.

Arguments:

    nothing
    
Return Value:

S_OK

--*/
{
    ENTER_FUNCTION("CIPConfMSP::CreateAudioRenderTerminals");
    const TCHAR * const strAudioRenderDll = TEXT("DXMRTP");

    // dynamically load the audio render filter dll.
    PFNAudioGetDeviceInfo pfnAudioGetDeviceInfo;
    PFNAudioReleaseDeviceInfo pfnAudioReleaseDeviceInfo;

    HRESULT hr = LoadTapiAudioFilterDLL(
        strAudioRenderDll,
        &m_hDxmrtp,
        "AudioGetRenderDeviceInfo",
        "AudioReleaseRenderDeviceInfo",
        &pfnAudioGetDeviceInfo,
        &pfnAudioReleaseDeviceInfo
        );

    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwNumDevices;
    AudioDeviceInfo *pDeviceInfo;

    hr = (*pfnAudioGetDeviceInfo)(&dwNumDevices, &pDeviceInfo);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, AudioGetDeviceInfo failed. hr=%x", __fxName, hr));

        return hr;
    }

    // for each devie, create a terminal.
    for (DWORD i = 0; i < dwNumDevices; i ++)
    {
        ITTerminal *pTerminal;

        hr = CIPConfAudioRenderTerminal::CreateTerminal(
            &pDeviceInfo[i],
            (MSP_HANDLE) this,
            &pTerminal
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, CreateTerminal for device %d failed. hr=%x",
                __fxName, i, hr));
            break;
        }

        if (!m_Terminals.Add(pTerminal))
        {
            hr = E_OUTOFMEMORY;
            LOG((MSP_ERROR, "%s, out of mem in adding a terminal", __fxName));
            break;
        }
    }

    // release the device info
    (*pfnAudioReleaseDeviceInfo)(pDeviceInfo);

    return hr;
}

HRESULT LoadTapiVideoCaptureDLL(
    IN OUT HMODULE * phModule,
    OUT PFNGetNumCapDevices * ppfnGetNumCapDevices,
    OUT PFNGetCapDeviceInfo * ppfnGetCapDeviceInfo
    )
/*++

Routine Description:

    This method enumerate loads the tapi video capture dll.

Arguments:

    phModule - memory to store returned module handle.

    ppfnGetNumCapDevices - memory to store the address of GetNumCapDevices
        function.

    ppfnGetCapDeviceInfo - memory to store the address of GetCapDeviceInfo 
        function.
    
Return Value:

    S_OK    - success.
    E_FAIL  - failure.

--*/
{
    const TCHAR * const strVideoCaptureDll = TEXT("DXMRTP");
    const char * const strGetNumCapDevices = "GetNumVideoCapDevices";
    const char * const strGetCapDeviceInfo = "GetVideoCapDeviceInfo";

    ENTER_FUNCTION("CIPConfMSP::LoadTapiVideoCaptureDLL");

    // dynamically load the video capture filter dll.
    if (*phModule == NULL)
    {
        *phModule = LoadLibrary(strVideoCaptureDll);
    }

    // validate handle
    if (*phModule == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not load %s., error:%d", 
            __fxName, strVideoCaptureDll, GetLastError()));

        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNGetNumCapDevices pfnGetNumCapDevices 
        = (PFNGetNumCapDevices)GetProcAddress(*phModule, strGetNumCapDevices);

    // validate function pointer
    if (pfnGetNumCapDevices == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not resolve %s, error:%d", 
            __fxName, strGetNumCapDevices, GetLastError()));

        // failure
        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNGetCapDeviceInfo pfnGetCapDeviceInfo 
        = (PFNGetCapDeviceInfo)GetProcAddress(*phModule, strGetCapDeviceInfo);

    // validate function pointer
    if (pfnGetCapDeviceInfo == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not resolve %s, error:%d", 
            __fxName, strGetCapDeviceInfo, GetLastError()));

        // failure
        return E_FAIL;
    }

    *ppfnGetNumCapDevices = pfnGetNumCapDevices;
    *ppfnGetCapDeviceInfo = pfnGetCapDeviceInfo;
    
    return S_OK;
}

HRESULT CIPConfMSP::CreateVideoCaptureTerminals()
/*++

Routine Description:

    This method is called by UpdateTerminalList to create all the video
    capture terminals. It loads the video capture dll and calls its device
    enumeration code to enumerate the devices.

Arguments:

    nothing
    
Return Value:

S_OK

--*/
{
    ENTER_FUNCTION("CIPConfMSP::CreateVideoCaptureTerminals");

    // dynamically load the video capture filter dll.
    PFNGetNumCapDevices pfnGetNumCapDevices;
    PFNGetCapDeviceInfo pfnGetCapDeviceInfo;

    HRESULT hr = LoadTapiVideoCaptureDLL(
        &m_hDxmrtp,
        &pfnGetNumCapDevices,
        &pfnGetCapDeviceInfo
        );

    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwNumDevices = 0;
    hr = (*pfnGetNumCapDevices)(&dwNumDevices);

    // we have to check against S_OK because the function returns S_FALSE when
    // there is no device.
    if (hr != S_OK)  
    {
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, GetNumCapDevices failed. hr=%x", __fxName, hr));
        }
        else 
        {
            LOG((MSP_WARN, "%s, There is no video device. hr=%x", __fxName, hr));
        }

        return hr;
    }

    for (DWORD i = 0; i < dwNumDevices; i ++)
    {
        VIDEOCAPTUREDEVICEINFO DeviceInfo;
        hr = (*pfnGetCapDeviceInfo)(i, &DeviceInfo);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, GetNumCapDevices for device %d failed. hr=%x",
                __fxName, i, hr));
            break;
        }

        ITTerminal * pTerminal;

        hr = CIPConfVideoCaptureTerminal::CreateTerminal(
            DeviceInfo.szDeviceDescription,
            i, 
            (MSP_HANDLE) this,
            &pTerminal
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, CreateTerminal for device %d failed. hr=%x",
                __fxName, i, hr));
            break;
        }

        if (!m_Terminals.Add(pTerminal))
        {
            hr = E_OUTOFMEMORY;
            LOG((MSP_ERROR, "%s, out of mem in adding a terminal", __fxName));
            break;
        }
    }

    return hr;
}

HRESULT CIPConfMSP::UpdateTerminalList(void)
/*++

Routine Description:

    This method is called by the base class when it first tries to enumerate
    all the static terminals. We override this function to create our own
    terminals that use our own filters.

Arguments:

    nothing
    
Return Value:

S_OK

--*/
{
    ENTER_FUNCTION("CIPConfMSP::UpdateTerminalList");

    // the failure of one category of terminals doesn't prevent the enumeration
    // of other categories. So we ignore the return code here. If all 
    // categories fail, the app will get an empty list.

    CreateAudioCaptureTerminals();
    CreateAudioRenderTerminals();
    CreateVideoCaptureTerminals();

    //
    // Our list is now complete.
    //
    m_fTerminalsUpToDate = TRUE;
    
    LOG((MSP_TRACE, "%s, exit S_OK", __fxName));

    return S_OK;
}

HRESULT CIPConfMSP::UpdateTerminalListForPnp(IN BOOL bDeviceArrival)
/*++

Routine Description:

    This method is called by the base class when it receives pnp event
    and needs to recreate static terminal list. We override this function
    to create our own terminals that use our own filters. terminal list
    locks was acquired when calling this method.
    
Return Value:

S_OK

--*/
{
    ENTER_FUNCTION ("CIPConfMSP::UpdateTerminalListForPnp");

    LOG ((MSP_TRACE, "%s (%d) entered", __fxName, bDeviceArrival));

    HRESULT hr;
    
    // variables for keeping old terminal info
    INT i, iout, iin, count;
    TERMINAL_DIRECTION *ptd = NULL, td;
    LONG *pmedia = NULL, media;
    BSTR *pbstr = NULL, bstr=NULL;
    ITTerminal **ppterminal = NULL;

    BOOL bmatch;
    MSPEVENTITEM *pevent = NULL;

    count = m_Terminals.GetSize ();
    
    if (count > 0)
    {
        ptd = new TERMINAL_DIRECTION[count];
        pmedia = new LONG[count];
        pbstr = new BSTR[count];
        ppterminal = new ITTerminal* [count];

        if (ptd == NULL || pmedia == NULL || pbstr == NULL || ppterminal == NULL)
        {
            LOG ((MSP_ERROR, "%s out of memory", __fxName));
            hr = E_OUTOFMEMORY;

            if (ptd) delete [] ptd;
            if (pmedia) delete [] pmedia;
            if (pbstr) delete [] pbstr;
            if (ppterminal) delete [] ppterminal;

            return hr;
        }

        memset (pbstr, 0, count * sizeof(BSTR));
        memset (ppterminal, 0, count * sizeof(ITTerminal*));
        
    }

    // for each old terminal, record
    for (i = 0; i < count; i++)
    {
        if (FAILED (hr = m_Terminals[i]->get_Direction (&ptd[i])))
        {
            LOG ((MSP_ERROR, "%s failed to get terminal direction. %x", __fxName, hr));
            goto Cleanup;
        }

        if (FAILED (hr = m_Terminals[i]->get_MediaType (&pmedia[i])))
        {
            LOG ((MSP_ERROR, "%s failed to get terminal mediatype. %x", __fxName, hr));
            goto Cleanup;
        }

        if (FAILED (hr = m_Terminals[i]->get_Name (&pbstr[i])))
        {
            LOG ((MSP_ERROR, "%s failed to get terminal name. %x", __fxName, hr));
            goto Cleanup;
        }

        m_Terminals[i]->AddRef ();
        ppterminal[i] = m_Terminals[i];
    }

    // if we release terminal inside previous loop: recording info
    // we would only release some terminals if there is an error
    for (i = 0; i < count; i++)
    {
        m_Terminals[i]->Release ();
    }
    m_Terminals.RemoveAll ();

    // update terminal list
    /*
    if (FAILED (hr = UpdateTerminalList ()))
    {
        LOG ((MSP_ERROR, "%s failed to update terminal list. %x", __fxName, hr));
        goto Cleanup;
    }
    */

    // copy UpdateTerminalList () here
    CreateAudioCaptureTerminals();
    CreateAudioRenderTerminals();
    CreateVideoCaptureTerminals();

    m_fTerminalsUpToDate = TRUE;

    // fire event to tapi app
    if (bDeviceArrival)
    {
        // outer loop each new terminal
        for (iout = 0; iout < m_Terminals.GetSize (); iout++)
        {
            if (FAILED (hr = m_Terminals[iout]->get_Direction (&td)))
            {
                LOG ((MSP_ERROR, "%s failed to get terminal direction. %x", __fxName, hr));
                goto Cleanup;
            }

            if (FAILED (hr = m_Terminals[iout]->get_MediaType (&media)))
            {
                LOG ((MSP_ERROR, "%s failed to get terminal type. %x", __fxName, hr));
                goto Cleanup;
            }

            if (FAILED (hr = m_Terminals[iout]->get_Name (&bstr)))
            {
                LOG ((MSP_ERROR, "%s failed to get terminal name. %x", __fxName, hr));
                goto Cleanup;
            }

            // inner loop check if the terminal is new
            for (iin = 0, bmatch = FALSE; iin < count; iin ++)
            {
                if (td == ptd[iin] && 
                    media == pmedia[iin] &&
                    0 == wcscmp (bstr, pbstr[iin]))
                {
                    bmatch = TRUE;
                    break;
                }
            }
            
            // fire event if not match
            if (!bmatch)
            {
                LOG ((MSP_TRACE, "%s: new device found. name %ws, td %d, media %d",
                      __fxName, bstr, td, media));

                pevent = AllocateEventItem();
                if (pevent == NULL)
                {
                    LOG ((MSP_ERROR, "%s failed to new msp event item", __fxName));
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                m_Terminals[iout]->AddRef ();
                
                pevent->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
                pevent->MSPEventInfo.Event = ME_ADDRESS_EVENT;
                pevent->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.Type = ADDRESS_TERMINAL_AVAILABLE;
                pevent->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.pTerminal = m_Terminals[iout];

                if (FAILED (hr = PostEvent (pevent)))
                {
                    LOG ((MSP_ERROR, "%s failed to post event. %x", __fxName, hr));
                    
                    m_Terminals[iout]->Release ();
                    FreeEventItem(pevent);
                    pevent = NULL;

                    // we don't return, try next device
                }                
            } // outer loop
            
            SysFreeString (bstr);
            bstr = NULL;
        }
    }
    else // if (bDeviceArrival)
    {
        // outer loop each old device
        for (iout = 0; iout < count; iout++)
        {
            // inner loop check if the device was removed
            for (iin = 0, bmatch = FALSE; iin < m_Terminals.GetSize (); iin++)
            {
                if (FAILED (hr = m_Terminals[iin]->get_Direction (&td)))
                {
                    LOG ((MSP_ERROR, "%s failed to get terminal direction. %x", __fxName, hr));
                    goto Cleanup;
                }
                
                if (FAILED (hr = m_Terminals[iin]->get_MediaType (&media)))
                {
                    LOG ((MSP_ERROR, "%s failed to get terminal type. %x", __fxName, hr));
                    goto Cleanup;
                }

                if (FAILED (hr = m_Terminals[iin]->get_Name (&bstr)))
                {
                    LOG ((MSP_ERROR, "%s failed to get terminal name. %x", __fxName, hr));
                    goto Cleanup;
                }
                    
                if (td == ptd[iout] && 
                    media == pmedia[iout] &&
                    0 == wcscmp (bstr, pbstr[iout]))
                {
                    SysFreeString (bstr);
                    bstr = NULL;
                        
                    bmatch = TRUE;
                    break;
                }
                    
                SysFreeString (bstr);
                bstr = NULL;
            }                
            
            // fire event if not match
            if (!bmatch)
            {
                LOG ((MSP_TRACE, "%s: device removed. name %ws, td %d, media %d",
                  __fxName, pbstr[iout], ptd[iout], pmedia[iout]));

                pevent = AllocateEventItem();
                if (pevent == NULL)
                {
                    LOG ((MSP_ERROR, "%s failed to new msp event item", __fxName));
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                ppterminal[iout]->AddRef ();
                
                pevent->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
                pevent->MSPEventInfo.Event = ME_ADDRESS_EVENT;
                pevent->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.Type = ADDRESS_TERMINAL_UNAVAILABLE;
                pevent->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.pTerminal = ppterminal[iout];

                if (FAILED (hr = PostEvent (pevent)))
                {
                    LOG ((MSP_ERROR, "%s failed to post event. %x", __fxName, hr));
                    
                    ppterminal[iout]->Release ();
                    FreeEventItem(pevent);
                    pevent = NULL;

                    // we don't return, try next device
                }
            }
        } // outer loop
    }

Cleanup:
    if (bstr) SysFreeString (bstr);

    if (count > 0)
    {
        delete [] ptd;
        delete [] pmedia;
        
        for (i = 0; i < count; i++)
        {
            if (pbstr[i]) SysFreeString (pbstr[i]);
            if (ppterminal[i]) ppterminal[i]->Release ();
        }

        delete [] pbstr;
        delete [] ppterminal;
     }

    LOG ((MSP_TRACE, "%s returns", __fxName));

    return hr;
}

STDMETHODIMP CIPConfMSP::CreateTerminal(
    IN      BSTR                pTerminalClass,
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    OUT     ITTerminal **       ppTerminal
    )
/*++

Routine Description:

This method is called by TAPI3 to create a dynamic terminal. It asks the 
terminal manager to create a dynamic terminal. 

Arguments:

iidTerminalClass
    IID of the terminal class to be created.

dwMediaType
    TAPI media type of the terminal to be created.

Direction
    Terminal direction of the terminal to be created.

ppTerminal
    Returned created terminal object
    
Return Value:

S_OK

E_OUTOFMEMORY
TAPI_E_INVALIDMEDIATYPE
TAPI_E_INVALIDTERMINALDIRECTION
TAPI_E_INVALIDTERMINALCLASS

--*/
{
    ENTER_FUNCTION("CIPConfMSP::CreateTerminal");
    LOG((MSP_TRACE, "%s - enter", __fxName));

    //
    // Check if initialized.
    //

    // lock the event related data
    m_EventDataLock.Lock();

    if ( m_htEvent == NULL )
    {
        // unlock the event related data
        m_EventDataLock.Unlock();

        LOG((MSP_ERROR,
            "%s, not initialized - returning E_UNEXPECTED", __fxName));
        return E_UNEXPECTED;
    }

    // unlock the event related data
    m_EventDataLock.Unlock();

    //
    // Get the IID from the BSTR representation.
    //

    HRESULT hr;
    IID     iidTerminalClass;

    hr = CLSIDFromString(pTerminalClass, &iidTerminalClass);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "%s, bad CLSID string", __fxName));
        return E_INVALIDARG;
    }

    //
    // Make sure we support the requested media type.
    // The terminal manager checks the terminal class, terminal direction, 
    // and return pointer.
    //

    //
    // we don't have any specific req's to terminal's media type. 
    // termmgr will check if the media type is valid at all.
    //

    //
    // Use the terminal manager to create the dynamic terminal.
    //

    _ASSERTE( m_pITTerminalManager != NULL );

    hr = m_pITTerminalManager->CreateDynamicTerminal(NULL,
                                                     iidTerminalClass,
                                                     (DWORD) lMediaType,
                                                     Direction,
                                                     (MSP_HANDLE) this,
                                                     ppTerminal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "%s create dynamic terminal failed. hr=%x", __fxName, hr));

        return hr;
    }

    const DWORD dwAudioCaptureBitPerSample    = 16;  
    const DWORD dwAudioSampleRate             = 8000;  

    if ((iidTerminalClass == CLSID_MediaStreamTerminal)
        && (lMediaType == TAPIMEDIATYPE_AUDIO))
    {
        // Set the format of the audio to 8KHZ, 16Bit/Sample, MONO.
        hr = ::SetAudioFormat(
            *ppTerminal, 
            dwAudioCaptureBitPerSample, 
            dwAudioSampleRate
            );

        if (FAILED(hr))
        {
            LOG((MSP_WARN, "%s, can't set audio format, %x", __fxName, hr));
        }
    }

    LOG((MSP_TRACE, "%s - exit S_OK", __fxName));

    return S_OK;
}

STDMETHODIMP CIPConfMSP::CreateMSPCall(
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType,
    IN      IUnknown *          pOuterUnknown,
    OUT     IUnknown **         ppMSPCall
    )
/*++

Routine Description:

This method is called by TAPI3 before a call is made or answered. It creates 
a aggregated MSPCall object and returns the IUnknown pointer. It calls the
helper template function defined in mspaddress.h to handle the real creation.

Arguments:

htCall
    TAPI 3.0's identifier for this call.  Returned in events passed back 
    to TAPI.

dwReserved
    Reserved parameter.  Not currently used.

dwMediaType
    Media type of the call being created.  These are TAPIMEDIATYPES and more 
    than one mediatype can be selected (bitwise).

pOuterUnknown
    pointer to the IUnknown interface of the containing object.

ppMSPCall
    Returned MSP call that the MSP fills on on success.
    
Return Value:

    S_OK
    E_OUTOFMEMORY
    E_POINTER
    TAPI_E_INVALIDMEDIATYPE


--*/
{
    LOG((MSP_TRACE, 
        "CreateMSPCall entered. htCall:%x, dwMediaType:%x, ppMSPCall:%x",
        htCall, dwMediaType, ppMSPCall
        ));

    CIPConfMSPCall * pMSPCall = NULL;

    HRESULT hr = ::CreateMSPCallHelper(
        this, 
        htCall, 
        dwReserved, 
        dwMediaType, 
        pOuterUnknown, 
        ppMSPCall,
        &pMSPCall
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPCallHelper failed:%x", hr));
        return hr;
    }

    // this function doesn't return anything.
    pMSPCall->SetIPInterface(m_dwIPInterface);

    return hr;
}

STDMETHODIMP CIPConfMSP::ShutdownMSPCall(
    IN      IUnknown *   pUnknown
    )
/*++

Routine Description:

This method is called by TAPI3 to shutdown a MSPCall. It calls the helper
function defined in MSPAddress to to the real job.

Arguments:

pUnknown
    pointer to the IUnknown interface of the contained object. It is a
    CComAggObject that contains our call object.
    
Return Value:

    S_OK
    E_POINTER
    TAPI_E_INVALIDMEDIATYPE


--*/
{
    LOG((MSP_TRACE, "ShutDownMSPCall entered. pUnknown:%x", pUnknown));

    if (IsBadReadPtr(pUnknown, sizeof(VOID *) * 3))
    {
        LOG((MSP_ERROR, "ERROR:pUnknow is a bad pointer"));
        return E_POINTER;
    }

    
    CIPConfMSPCall * pMSPCall = NULL;
    HRESULT hr = ::ShutdownMSPCallHelper(pUnknown, &pMSPCall);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "ShutDownMSPCallhelper failed:: %x", hr));
        return hr;
    }

    return hr;
}

DWORD CIPConfMSP::GetCallMediaTypes(void)
{
    return IPCONFCALLMEDIATYPES;
}

ULONG CIPConfMSP::MSPAddressAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CIPConfMSP::MSPAddressRelease(void)
{
    return MSPReleaseHelper(this);
}

#ifdef USEIPADDRTABLE
PMIB_IPADDRTABLE GetIPTable()
/*++

Routine Description:

This method is used to get the table of local IP interfaces.

Arguments:

Return Value:

    NULL - failed.
    Pointer - a memory buffer that contains the IP interface table.


--*/
{
    // dynamically load iphlpapi.dll
    HMODULE hIPHLPAPI = LoadLibraryW(IPHLPAPI_DLL);

    // validate handle
    if (hIPHLPAPI == NULL) 
    {
        LOG((MSP_ERROR, "could not load %s.\n", IPHLPAPI_DLL));
        // failure
        return NULL;
    }

    PFNGETIPADDRTABLE pfnGetIpAddrTable = NULL;

    // retrieve function pointer to retrieve addresses
    pfnGetIpAddrTable = (PFNGETIPADDRTABLE)GetProcAddress(
                                                hIPHLPAPI, 
                                                GETIPADDRTABLE
                                                );

    // validate function pointer
    if (pfnGetIpAddrTable == NULL) 
    {
        LOG((MSP_ERROR, "could not resolve GetIpAddrTable.\n"));
        // release
        FreeLibrary(hIPHLPAPI);
        // failure
        return NULL;
    }

    PMIB_IPADDRTABLE pIPAddrTable = NULL;
    DWORD dwBytesRequired = 0;
    DWORD dwStatus;

    // determine amount of memory needed for table
    dwStatus = (*pfnGetIpAddrTable)(pIPAddrTable, &dwBytesRequired, FALSE);

    // validate status is what we expect
    if (dwStatus != ERROR_INSUFFICIENT_BUFFER) 
    {
        LOG((MSP_ERROR, "error 0x%08lx calling GetIpAddrTable.\n", dwStatus));
        // release
        FreeLibrary(hIPHLPAPI);
        // failure, but we need to return true to load.
        return NULL;
    }
        
    // attempt to allocate memory for table
    pIPAddrTable = (PMIB_IPADDRTABLE)malloc(dwBytesRequired);

    // validate pointer
    if (pIPAddrTable == NULL) 
    {
        LOG((MSP_ERROR, "could not allocate address table.\n"));
        // release
        FreeLibrary(hIPHLPAPI);
        // failure, but we need to return true to load.
        return NULL;
    }

    // retrieve ip address table from tcp/ip stack via utitity library
    dwStatus = (*pfnGetIpAddrTable)(pIPAddrTable, &dwBytesRequired, FALSE);    

    // validate status
    if (dwStatus != NOERROR) 
    {
        LOG((MSP_ERROR, "error 0x%08lx calling GetIpAddrTable.\n", dwStatus));
        // release table
        free(pIPAddrTable);
        // release
        FreeLibrary(hIPHLPAPI);
        // failure, but we need to return true to load. 
        return NULL;
    }
        
    // release library
    FreeLibrary(hIPHLPAPI);

    return pIPAddrTable;
}

BSTR IPToBstr(
    DWORD dwIP
    )
{
    struct in_addr Addr;
    Addr.s_addr = dwIP;
    
    // convert the interface to a string.
    CHAR *pChar = inet_ntoa(Addr);
    if (pChar == NULL)
    {
        LOG((MSP_ERROR, "bad IP address:%x", dwIP));
        return NULL;
    }

    // convert the ascii string to WCHAR.
    WCHAR szAddressName[MAXIPADDRLEN + 1];
    wsprintfW(szAddressName, L"%hs", pChar);

    // create a BSTR.
    BSTR bAddress = SysAllocString(szAddressName);
    if (bAddress == NULL)
    {
        LOG((MSP_ERROR, "out of mem in allocation address name"));
        return NULL;
    }

    return bAddress;
}

STDMETHODIMP CIPConfMSP::get_DefaultIPInterface(
    OUT     BSTR *         ppIPAddress
    )
{
    LOG((MSP_TRACE, "get_DefaultIPInterface, ppIPAddress:%p", ppIPAddress));

    if (IsBadWritePtr(ppIPAddress, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, 
            "get_DefaultIPInterface, ppIPAddress is bad:%p", ppIPAddress));
        return E_POINTER;
    }

    // get the current local interface.
    m_Lock.Lock();
    DWORD dwIP= m_dwIPInterface;
    m_Lock.Unlock();

    BSTR bAddress = IPToBstr(dwIP);

    if (bAddress == NULL)
    {
        return E_OUTOFMEMORY;
    }

    *ppIPAddress = bAddress;

    LOG((MSP_TRACE, "get_DefaultIPInterface, returning %ws", bAddress));

    return S_OK;
}

STDMETHODIMP CIPConfMSP::put_DefaultIPInterface(
    IN      BSTR            pIPAddress
    )
{
    LOG((MSP_TRACE, "put_DefaultIPInterface, pIPAddress:%p", pIPAddress));

    if (IsBadStringPtrW(pIPAddress, MAXIPADDRLEN))
    {
        LOG((MSP_ERROR, 
            "put_DefaultIPInterface, invalid pointer:%p", pIPAddress));
        return E_POINTER;
    }

    char buffer[MAXIPADDRLEN + 1];

    if (WideCharToMultiByte(
        GetACP(),
        0,
        pIPAddress,
        -1,
        buffer,
        MAXIPADDRLEN,
        NULL,
        NULL
        ) == 0)
    {
        LOG((MSP_ERROR, "put_DefaultIPInterface, can't covert:%ws", pIPAddress));
        return E_INVALIDARG;
    }

    DWORD dwAddr;
    if ((dwAddr = inet_addr(buffer)) == INADDR_NONE)
    {
        LOG((MSP_ERROR, "put_DefaultIPInterface, bad address:%s", buffer));
        return E_INVALIDARG;
    }

    // set the current local interface.
    m_Lock.Lock();
    m_dwIPInterface = dwAddr;
    m_Lock.Unlock();


    LOG((MSP_TRACE, "put_DefaultIPInterface, set to %s", buffer));

    return S_OK;
}

HRESULT CreateBstrCollection(
    IN  BSTR  *     pBstr,
    IN  DWORD       dwCount,
    OUT VARIANT *   pVariant
    )
{
    //
    // create the collection object - see mspcoll.h
    //

    CComObject<CTapiBstrCollection> * pCollection;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "get_IPInterfaces - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "get_IPInterfaces - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( dwCount,
                                  pBstr,
                                  pBstr + dwCount);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "get_IPInterfaces - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();

        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_ERROR, "get_IPInterfaces - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "get_IPInterfaces - exit S_OK"));
 
    return S_OK;
}


STDMETHODIMP CIPConfMSP::get_IPInterfaces(
    OUT     VARIANT *       pVariant
    )
{
    PMIB_IPADDRTABLE pIPAddrTable = GetIPTable();

    if (pIPAddrTable == NULL)
    {
        return E_FAIL;
    }

    BSTR *Addresses = 
        (BSTR *)malloc(sizeof(BSTR *) * pIPAddrTable->dwNumEntries);
    
    if (Addresses == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    DWORD dwCount = 0;

    // loop through the interfaces and find the valid ones.
    for (DWORD i = 0; i < pIPAddrTable->dwNumEntries; i++) 
    {
        if (IsValidInterface(pIPAddrTable->table[i].dwAddr))
        {
            DWORD dwIPAddr   = ntohl(pIPAddrTable->table[i].dwAddr);
            Addresses[i] = IPToBstr(dwIPAddr);
            if (Addresses[i] == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            dwCount ++;
        }
    }

    // release table memory 
    free(pIPAddrTable);

    if (FAILED(hr))
    {
        // release all the BSTRs and the array.
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
        free(Addresses);
        return hr;
    }

    hr = CreateBstrCollection(Addresses, dwCount, pVariant);

    // if the collection is not created, release all the BSTRs.
    if (FAILED(hr))
    {
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
    }

    // delete the pointer array.
    free(Addresses);

    return hr;
}

HRESULT CreateBstrEnumerator(
    IN  BSTR *                  begin,
    IN  BSTR *                  end,
    OUT IEnumBstr **           ppIEnum
    )
{
typedef CSafeComEnum<IEnumBstr, &__uuidof(IEnumBstr), BSTR, _CopyBSTR>> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = ::CreateCComObjectInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "Could not create enumerator object, %x", hr));
        return hr;
    }

    IEnumBstr * pIEnum;

    // query for the __uuidof(IEnumDirectory) i/f
    hr = pEnum->_InternalQueryInterface(
        __uuidof(IEnumBstr),
        (void**)&pIEnum
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "query enum interface failed, %x", hr));
        delete pEnum;
        return hr;
    }

    hr = pEnum->Init(begin, end, NULL, AtlFlagTakeOwnership);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "init enumerator object failed, %x", hr));
        pIEnum->Release();
        return hr;
    }

    *ppIEnum = pIEnum;

    return hr;
}

STDMETHODIMP CIPConfMSP::EnumerateIPInterfaces(
    OUT     IEnumBstr **   ppIEnumBstr
    )
{
    PMIB_IPADDRTABLE pIPAddrTable = GetIPTable();

    if (pIPAddrTable == NULL)
    {
        return E_FAIL;
    }

    BSTR *Addresses = 
        (BSTR *)malloc(sizeof(BSTR *) * pIPAddrTable->dwNumEntries);
    
    if (Addresses == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    DWORD dwCount = 0;

    // loop through the interfaces and find the valid ones.
    for (DWORD i = 0; i < pIPAddrTable->dwNumEntries; i++) 
    {
        if (IsValidInterface(pIPAddrTable->table[i].dwAddr))
        {
            DWORD dwIPAddr   = ntohl(pIPAddrTable->table[i].dwAddr);
            Addresses[i] = IPToBstr(dwIPAddr);
            if (Addresses[i] == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            dwCount ++;
        }
    }

    // release table memory 
    free(pIPAddrTable);

    if (FAILED(hr))
    {
        // release all the BSTRs and the array.
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
        free(Addresses);
        return hr;
    }

    hr = CreateBstrEnumerator(Addresses, Addresses + dwCount, ppIEnumBstr);

    // if the collection is not created, release all the BSTRs.
    if (FAILED(hr))
    {
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
        free(Addresses);
        return hr;
    }

    // the enumerator will destroy the bstr array eventually,
    // so no need to free anything here. Even if we tell it to hand
    // out zero objects, it will delete the array on destruction.

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confaud.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confaud.cpp

Abstract:

    This module contains implementation of the audio send and receive
    stream implementations.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
//  Helper functions
//
/////////////////////////////////////////////////////////////////////////////
HRESULT ConfigureFullduplexControl(
    IN IPin * pIPin,
    IN IAudioDuplexController *pIAudioDuplexController
    )
/*++

Routine Description:
    
    This method sets the AudioDuplexController on the filter.

Arguments:
    
    pIPin - the pin that belongs to the filter.

    pIAudioDuplexController - the IAudioDuplexController interface.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("::ConfigureFullduplexControl");
    LOG((MSP_TRACE, "%s enters", __fxName));

    if (pIAudioDuplexController == NULL)
    {
        // we don't need to configure anything.
        return S_OK;
    }

    HRESULT hr;

    // find the filter behind the pin.
    PIN_INFO PinInfo;
    if (FAILED(hr = pIPin->QueryPinInfo(&PinInfo)))
    {
        LOG((MSP_ERROR, 
            "%s:can't get the capture filter, hr=%x", 
            __fxName, hr));

        return hr;
    }

    IAudioDeviceConfig *pIAudioDeviceConfig;

    // get the IAudioDeviceConfig interface.
    hr = PinInfo.pFilter->QueryInterface(&pIAudioDeviceConfig);

    PinInfo.pFilter->Release();
    
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture filter's pIAudioDeviceConfig failed, hr=%x", 
            __fxName, hr));

        return hr;
    }
    
    // tell the filter about the full-duplex controller.
    hr = pIAudioDeviceConfig->SetDuplexController(pIAudioDuplexController);

    pIAudioDeviceConfig->Release();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s:set IAudioDuplexController failed, hr=%x", 
            __fxName, hr));

        return hr;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamAudioRecv
//
/////////////////////////////////////////////////////////////////////////////

CStreamAudioRecv::CStreamAudioRecv()
    : CIPConfMSPStream(),
    m_pIAudioDuplexController(NULL)
{
    m_szName = L"AudioRecv";
}

CStreamAudioRecv::~CStreamAudioRecv()
{
    if (m_pIAudioDuplexController)
    {
        m_pIAudioDuplexController->Release();
    }
}

// this method is called by the call object at init time.
void CStreamAudioRecv::SetFullDuplexController(
    IN IAudioDuplexController *pIAudioDuplexController
    )
{
    _ASSERT(pIAudioDuplexController);
    _ASSERT(m_pIAudioDuplexController == NULL);

    pIAudioDuplexController->AddRef();
    m_pIAudioDuplexController = pIAudioDuplexController;
}


STDMETHODIMP CStreamAudioRecv::GetRange(
    IN  AudioSettingsProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a audio setting property. Delegated to the renderfilter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioRecv::GetRange(AudioSettings)");

    if (IsBadWritePtr (plMin, sizeof (long)) ||
        IsBadWritePtr (plMax, sizeof (long)) ||
        IsBadWritePtr (plSteppingDelta, sizeof (long)) ||
        IsBadWritePtr (plDefault, sizeof (long)) ||
        IsBadWritePtr (plFlags, sizeof (TAPIControlFlags)))
    {
        LOG ((MSP_ERROR, "%s: bad write pointer", __fxName));
        return E_POINTER;
    }
    
    HRESULT hr;

    switch (Property)
    {
    case AudioSettings_SignalLevel:
        break;

    case AudioSettings_SilenceThreshold:
        break;

    case AudioSettings_Volume:
        break;

    case AudioSettings_Balance:
        break;

    case AudioSettings_Loudness:
        break;

    case AudioSettings_Treble:
        break;

    case AudioSettings_Bass:
        break;

    case AudioSettings_Mono:
        break;

    default:
        hr = E_INVALIDARG;

    }

    return E_NOTIMPL;
}

STDMETHODIMP CStreamAudioRecv::Get(
    IN  AudioSettingsProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a audio setting property. Delegated to the renderfilter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioRecv::Get(AudioSettings)");

    if (IsBadWritePtr (plValue, sizeof(long)) ||
        IsBadWritePtr (plFlags, sizeof(TAPIControlFlags)))
    {
        LOG ((MSP_ERROR, "%s received bad pointer.", __fxName));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

STDMETHODIMP CStreamAudioRecv::Set(
    IN  AudioSettingsProperty Property, 
    IN  long lValue, 
    IN  TAPIControlFlags lFlags
    )
/*++

Routine Description:
    
    Set the value for a audio setting property. Delegated to the renderfilter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioRecv::Set(AudioSettings)");

    return E_NOTIMPL;
}

//
// ITStreamQualityControl methods
//
STDMETHODIMP CStreamAudioRecv::Set (
    IN   StreamQualityProperty Property, 
    IN   long lValue, 
    IN   TAPIControlFlags lFlags
    )
{
    return E_NOTIMPL;
}

HRESULT CStreamAudioRecv::ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    )
/*++

Routine Description:

    Configure the RTP filter with RTP<-->AM media type mappings.

Arguments:
    
    pIRTPFilter - The source RTP Filter.

    pIStreamConfig - The stream config interface that has the media info.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("AudioRecv::ConfigureRTPFormats");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    CComPtr<IRtpMediaControl> pIRtpMediaControl;
    hr = pIRTPFilter->QueryInterface(&pIRtpMediaControl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
        return hr;
    }

    // find the number of capabilities supported.
    DWORD dwCount;
    hr = pIStreamConfig->GetNumberOfCapabilities(&dwCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s GetNumberOfCapabilities. %x", __fxName, hr));
        return hr;
    }

    BOOL bFound = FALSE;
    for (DWORD dw = 0; dw < dwCount; dw ++)
    {
        // TODO, a new interface is needed to resolve RTP to MediaType.
        AM_MEDIA_TYPE *pMediaType;
        DWORD dwPayloadType;

        hr = pIStreamConfig->GetStreamCaps(
            dw, &pMediaType, NULL, &dwPayloadType
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s GetStreamCaps. %x", __fxName, hr));
            return hr;
        }

        for (DWORD dw2 = 0; dw2 < m_Settings.dwNumPayloadTypes; dw2 ++)
        {
            if (dwPayloadType == m_Settings.PayloadTypes[dw2])
            {
                hr = pIRtpMediaControl->SetFormatMapping(
                    dwPayloadType,
                    FindSampleRate(pMediaType),
                    pMediaType
                    );

                if (FAILED(hr))
                {
                    MSPDeleteMediaType(pMediaType);

                    LOG((MSP_ERROR, "%s SetFormatMapping. %x", __fxName, hr));
                    return hr;
                }
                else
                {
                    LOG((MSP_INFO, "%s Configured payload:%d", __fxName, dwPayloadType));
                }
            }
        }
        MSPDeleteMediaType(pMediaType);
    }

    return S_OK;
}


HRESULT CStreamAudioRecv::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the mixer to the audio render terminal.

Arguments:
    
    pITTerminal - The terminal to be connected.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv.ConnectTerminal, pITTerminal %p", pITTerminal));

    HRESULT hr;

    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            E_NOINTERFACE, 
            pITTerminal
            );
        
        return E_NOINTERFACE;
    }

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    // Get the pins.
    hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_RENDER, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            hr, 
            pITTerminal
            );
        
        return hr;
    }

    // the pin count should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            hr, 
            pITTerminal
            );
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_UNEXPECTED;
    }

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_POINTER;
    }

    for (DWORD i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));

            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            return E_POINTER;
        }
    }

    // create filters and connect to the audio render terminal.
    hr = SetUpInternalFilters(Pins, dwNumPins);

    // release the refcounts on the pins.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Set up internal filter failed, %x", hr));
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        CleanUpFilters();

        return hr;
    }
    
    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamAudioRecv::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

    If it is the capture terminal being disconnected, all the pins that the 
    stream cached need to be released too. 

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioRecv::DisconnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    HRESULT hr = CIPConfMSPStream::DisconnectTerminal(pITTerminal);

    CleanUpFilters();

    return hr;
}

HRESULT CStreamAudioRecv::AddOneMixChannel(
    IN  IBaseFilter* pSourceFilter,
    IN  IPin *pPin,
    IN  DWORD dwChannelNumber
    )
{
    ENTER_FUNCTION("AudioRecv::AddDecoder");
    LOG((MSP_TRACE, "%s enters", __fxName));

    CComPtr<IBaseFilter> pDecoderFilter;

    HRESULT hr;
    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        __uuidof(TAPIAudioDecoder), 
        L"Decoder", 
        &pDecoderFilter
        )))
    {
        LOG((MSP_ERROR, "%s add Codec filter. %x", __fxName, hr));
        return hr;
    }

#ifdef DYNGRAPH
	CComPtr <IGraphConfig> pIGraphConfig;

    hr = m_pIGraphBuilder->QueryInterface(
        __uuidof(IGraphConfig), 
        (void**)&pIGraphConfig
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s query IGraphConfig failed. hr=%x", __fxName, hr));
        return hr;
    }
    
    // this tell the graph that the filter can be removed during reconnect.
    hr = pIGraphConfig->SetFilterFlags(pDecoderFilter, AM_FILTER_FLAGS_REMOVABLE);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s set filter flag failed. hr=%x", __fxName, hr));
        return hr;
    }

/*  // if there is a plugin codec,this method can be use to add it.
	hr = pIGraphConfig->AddFilterToCache(pDecoderFilter);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, AddFilterToCache failed", __fxName));
        return hr;
    }
*/
#endif

    if (dwChannelNumber == 0)
    {
        // configure the formats for the RTP filter.

        CComPtr<IPin> pIPinInput;
        if (FAILED(hr = ::FindPin(pDecoderFilter, &pIPinInput, PINDIR_INPUT, TRUE)))
        {
            LOG((MSP_ERROR,
                "find input pin on pCodecFilter failed. hr=%x", hr));
            return hr;
        }

        CComPtr<IStreamConfig> pIStreamConfig;

        hr = pIPinInput->QueryInterface(&pIStreamConfig);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, query IStreamConfig failed", __fxName));
            return hr;
        }


        // configure the format info on the RTP filter
        if (FAILED(hr = ConfigureRTPFormats(pSourceFilter, pIStreamConfig)))
        {
            LOG((MSP_ERROR, "%s configure RTP formats. %x", __fxName, hr));
            return hr;
        }

        // give the render filter the full-duplex controller.
        ::ConfigureFullduplexControl(pPin, m_pIAudioDuplexController);

    }

    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        pSourceFilter, 
        pDecoderFilter
        )))
    {
        LOG((MSP_ERROR, "%s connect source and decoder filter. %x", __fxName, hr));
        return hr;
    }

    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        pDecoderFilter, 
        pPin
        )))
    {
        LOG((MSP_ERROR, "%s connect decoder filter and pin. %x", __fxName, hr));
        return hr;
    }

    return hr;
}

HRESULT CStreamAudioRecv::SetUpInternalFilters(
    IN  IPin **ppPins,
    IN  DWORD dwNumPins
    )
/*++

Routine Description:

    set up the filters used in the stream.

    RTP->Demux->RPH(->DECODER)->Mixer

Arguments:

    ppPin - the input pins of the audio render terminal.

    dwNumPins - the number of pins in the array.
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("AudioRecv::SetUpInternalFilters");
    LOG((MSP_TRACE, "%s enters", __fxName));

    CComPtr<IBaseFilter> pSourceFilter;

    HRESULT hr;
    DWORD dw;

    if (m_pIRTPSession == NULL)
    {
        // create and add the source fitler.
        if (FAILED(hr = ::AddFilter(
                m_pIGraphBuilder,
                __uuidof(MSRTPSourceFilter), 
                L"RtpSource", 
                &pSourceFilter)))
        {
            LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
            return hr;
        }

        // configure the address info on the RTP filter.
        if (FAILED(hr = ConfigureRTPFilter(pSourceFilter)))
        {
            LOG((MSP_ERROR, "%s configure RTP source filter. %x", __fxName, hr));
            return hr;
        }
    }
    else
    {
        if (FAILED (hr = m_pIRTPSession->QueryInterface (&pSourceFilter)))
        {
            LOG ((MSP_ERROR, "%s failed to get filter from rtp session. %x", __fxName, hr));
            return hr;
        }

        if (FAILED (hr = m_pIGraphBuilder->AddFilter ((IBaseFilter *)pSourceFilter, L"RtpSource")))
        {
            LOG ((MSP_ERROR, "%s failed to add filter to graph. %x", __fxName, hr));
            return hr;
        }
    }

    // get the Demux interface pointer.
    CComPtr<IRtpDemux> pIRtpDemux;
    hr = pSourceFilter->QueryInterface(&pIRtpDemux);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s query IRtpDemux failed. %x", __fxName, hr));
        return hr;
    }

    // set the number of output pins we need.
    hr = pIRtpDemux->SetPinCount(MAX_MIX_CHANNELS, RTPDMXMODE_AUTO);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s SetPinCount failed. %x", __fxName, hr));
        return hr;
    }

    // if the render handles multichannel, use it.
    if (dwNumPins > 1)
    {
        for (dw = 0; dw < min(dwNumPins, MAX_MIX_CHANNELS); dw ++)
        {
            hr = AddOneMixChannel(pSourceFilter, ppPins[dw], dw);
            if (FAILED(hr))
            {
                break;
            }
        }
        return hr;
    }

    //if the render filter can't handle multichannel, insert a mixer;
    CComPtr<IBaseFilter> pMixer;
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            __uuidof(TAPIAudioMixer), 
            L"AudioMixer", 
            &pMixer)))
    {
        LOG((MSP_ERROR, "%s, adding audio Mixer filter. %x", __fxName, hr));
        return hr;
    }

    // Get the enumerator of pins on the mixer filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pMixer->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, "%s, enum pins on the Mixer filter. %x", __fxName, hr));
        return hr;
    }

    DWORD dwFetched;
    IPin * MixerPins[MAX_MIX_CHANNELS];
    hr = pIEnumPins->Next(MAX_MIX_CHANNELS, MixerPins, &dwFetched);
    
    if (FAILED(hr) || dwFetched == 0)
    {
        LOG((MSP_ERROR, "%s, find pin on filter. %x", __fxName, hr));
        return E_FAIL;
    }

    // add the decoding channels.
    for (dw = 0; dw < dwFetched; dw ++)
    {
        hr = AddOneMixChannel(pSourceFilter, MixerPins[dw], dw);

        if (FAILED(hr))
        {
            break;
        }
    }
    
    // release the refcounts on the pins.
    for (dw = 0; dw < dwFetched; dw ++)
    {
        MixerPins[dw]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, add mix channel failed %x", __fxName, hr));
        return hr;
    }

    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        pMixer, 
        ppPins[0]
        )))
    {
        LOG((MSP_ERROR, "%s connect mixer filter and pin. %x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamAudioRecv::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv SetupFilters entered."));
    HRESULT hr;

    // we only support one terminal for this stream.
    if (m_Terminals.GetSize() != 1)
    {
        return E_UNEXPECTED;
    }

    // Connect the mixer to the terminal.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[0]
        )))
    {
        LOG((MSP_ERROR, "connect the mixer filter to terminal. %x", hr));

        return hr;
    }
    return hr;
}

HRESULT CStreamAudioRecv::ProcessTalkingEvent(
    IN  DWORD dwSSRC
    )
/*++

Routine Description:

    a SSRC is active, file a participant active event.

Arguments:

    dwSSRC - the SSRC of the participant.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Processes pin mapped event, pIPin: %p", m_szName, dwSSRC));
    
    CLock lock(m_lock);

    ITParticipant * pITParticipant = NULL;

    // find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
        }
    }

    // if the participant is not there yet, put the event in a queue and it
    // will be fired when we have the CName fo the participant.
    if (!pITParticipant)
    {
        LOG((MSP_INFO, "can't find a participant that has SSRC %x", dwSSRC));

        m_PendingSSRCs.Add(dwSSRC);
        
        LOG((MSP_INFO, "added the event to pending list, new list size:%d", 
            m_PendingSSRCs.GetSize()));

        return S_OK;
    }
   
    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_PARTICIPANT_ACTIVE, 
        pITParticipant
        );

    return S_OK;
}

HRESULT CStreamAudioRecv::NewParticipantPostProcess(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
/*++

Routine Description:

    A mapped event happended when we didn't have the participant's name so
    it was queued in a list. Now that we have a new participant, let's check
    if this is the same participant. If it is, we complete the mapped event
    by sending the app an notification.

Arguments:

    dwSSRC - the SSRC of the participant.

    pITParticipant - the participant object.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Check pending mapped event, dwSSRC: %x", m_szName, dwSSRC));
    
    // look at the pending SSRC list and find out if this report
    // fits in the list.
    int i = m_PendingSSRCs.Find(dwSSRC);

    if (i < 0)
    {
        // the SSRC is not in the list of pending PinMappedEvents.
        LOG((MSP_TRACE, "the SSRC %x is not in the pending list", dwSSRC));
        return S_OK;
    }
    
    // get rid of the peding SSRC.
    m_PendingSSRCs.RemoveAt(i);

    // complete the event.
    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_PARTICIPANT_ACTIVE, 
        pITParticipant
        );

    return S_OK;
}

HRESULT CStreamAudioRecv::ProcessWasTalkingEvent(
    IN  DWORD dwSSRC
    )
/*++

Routine Description:

    A SSRC just got unmapped by the demux. Notify the app that a participant
    becomes inactive.

Arguments:

    dwSSRC - the SSRC of the participant.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Processes SSRC unmapped event, pIPin: %p", m_szName, dwSSRC));
    
    CLock lock(m_lock);

    // look at the pending SSRC list and find out if it is in the pending list.
    int i = m_PendingSSRCs.Find(dwSSRC);

    // if the SSRC is in the pending list, just remove it.
    if (i >= 0)
    {
        m_PendingSSRCs.RemoveAt(i);
        return S_OK;
    }

    ITParticipant *pITParticipant = NULL;

    // find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
        }
    }

    if (pITParticipant)
    {
        // fire an event to tell the app that the participant is inactive.
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_PARTICIPANT_INACTIVE, 
            pITParticipant
            );
    }
    return S_OK;
}

HRESULT CStreamAudioRecv::ProcessParticipantLeave(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "%ls ProcessParticipantLeave, SSRC: %x", m_szName, dwSSRC));
    
    CLock lock(m_lock);
    
    // look at the pending SSRC list and find out if it is in the pending list.
    int i = m_PendingSSRCs.Find(dwSSRC);

    // if the SSRC is in the pending list, remove it.
    if (i >= 0)
    {
        m_PendingSSRCs.RemoveAt(i);
    }

    CParticipant *pParticipant;
    BOOL fLast = FALSE;

    HRESULT hr = E_FAIL;

    // first try to find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        pParticipant = (CParticipant *)m_Participants[i];
        hr = pParticipant->RemoveStream(
                (ITStream *)this,
                dwSSRC,
                &fLast
                );
        
        if (SUCCEEDED(hr))
        {
            break;
        }
    }

    // if the participant is not found
    if (FAILED(hr))
    {
        LOG((MSP_WARN, "%ws, can't find the SSRC %x", m_szName, dwSSRC));

        return hr;
    }

    ITParticipant *pITParticipant = m_Participants[i];

    // fire an event to tell the app that the participant is in active.
    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_PARTICIPANT_INACTIVE, 
        pITParticipant
        );

    m_Participants.RemoveAt(i);

    // if this stream is the last stream that the participant is on,
    // tell the call object to remove it from its list.
    if (fLast)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->ParticipantLeft(pITParticipant);
    }

    pITParticipant->Release();

    return S_OK;
}

HRESULT CStreamAudioRecv::ShutDown()
/*++

Routine Description:

    Shut down the stream. Release our members and then calls the base class's
    ShutDown method.

Arguments:
    

Return Value:

S_OK
--*/
{
    CLock lock(m_lock);

    // if there are terminals
    BOOL fHasTerminal = FALSE;
    if (m_Terminals.GetSize() > 0)
    {
        fHasTerminal = TRUE;
    }

    // if graph is running
    HRESULT hr;
    OAFilterState FilterState = State_Stopped;
    if (m_pIMediaControl)
    {
        if (FAILED (hr = m_pIMediaControl->GetState(0, &FilterState)))
        {
            LOG ((MSP_ERROR, "CStreamAudioRecv::ShutDown failed to query filter state. %d", hr));
            FilterState = State_Stopped;
        }
    }

    // fire event
    if (fHasTerminal && FilterState == State_Running)
    {
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    }

    return CIPConfMSPStream::ShutDown();
}


/////////////////////////////////////////////////////////////////////////////
//
//  CStreamAudioSend
//
/////////////////////////////////////////////////////////////////////////////

CStreamAudioSend::CStreamAudioSend()
    : CIPConfMSPStream(),
    m_pIStreamConfig(NULL),
    m_pAudioInputMixer(NULL),
    m_pSilenceControl(NULL),
    m_pAudioDeviceControl(NULL),
    m_pCaptureBitrateControl(NULL),
    m_pEncoder(NULL),
    m_pIAudioDuplexController(NULL),
    m_lAutomaticGainControl(DEFUAT_AGC_STATUS),
    m_lAcousticEchoCancellation(DEFUAT_AEC_STATUS)
{
      m_szName = L"AudioSend";
}

CStreamAudioSend::~CStreamAudioSend()
{
    CleanupCachedInterface();
}

// this method is called by the call object at init time.
void CStreamAudioSend::SetFullDuplexController(
    IN IAudioDuplexController *pIAudioDuplexController
    )
{
    _ASSERT(pIAudioDuplexController);
    _ASSERT(m_pIAudioDuplexController == NULL);

    pIAudioDuplexController->AddRef();
    m_pIAudioDuplexController = pIAudioDuplexController;
}

void CStreamAudioSend::CleanupCachedInterface()
{
    if (m_pIStreamConfig)
    {
        m_pIStreamConfig->Release();
        m_pIStreamConfig = NULL;
    }

    if (m_pSilenceControl) 
    {
        m_pSilenceControl->Release();
        m_pSilenceControl = NULL;
    }

    if (m_pCaptureBitrateControl) 
    {
        m_pCaptureBitrateControl->Release();
        m_pCaptureBitrateControl = NULL;
    }

    if (m_pAudioInputMixer) 
    {
        m_pAudioInputMixer->Release();
        m_pAudioInputMixer = NULL;
    }

    if (m_pAudioDeviceControl) 
    {
        m_pAudioDeviceControl->Release();
        m_pAudioDeviceControl = NULL;
    }

    if (m_pEncoder) 
    {
        m_pEncoder->Release();
        m_pEncoder = NULL;
    }

    if (m_pIAudioDuplexController)
    {
        m_pIAudioDuplexController->Release();
        m_pIAudioDuplexController = NULL;
    }
}


HRESULT CStreamAudioSend::ShutDown()
/*++

Routine Description:

    Shut down the stream. Release our members and then calls the base class's
    ShutDown method.

Arguments:
    

Return Value:

S_OK
--*/
{
    CLock lock(m_lock);

    // if there are terminals
    BOOL fHasTerminal = FALSE;
    if (m_Terminals.GetSize() > 0)
    {
        fHasTerminal = TRUE;
    }

    // if graph is running
    HRESULT hr;
    OAFilterState FilterState = State_Stopped;
    if (m_pIMediaControl)
    {
        if (FAILED (hr = m_pIMediaControl->GetState(0, &FilterState)))
        {
            LOG ((MSP_ERROR, "CStreamAudioSend::ShutDown failed to query filter state. %d", hr));
            FilterState = State_Stopped;
        }
    }

    CleanupCachedInterface();

    // fire event
    if (fHasTerminal && FilterState == State_Running)
    {
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    }

    return CIPConfMSPStream::ShutDown();
}

HRESULT CStreamAudioSend::CacheAdditionalInterfaces(
    IN  IPin *                 pIPin
    )
{
    ENTER_FUNCTION("CStreamAudioSend::CacheAdditionalInterfaces");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    _ASSERT(m_pIStreamConfig == NULL);
    hr = pIPin->QueryInterface(&m_pIStreamConfig);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, "%s, query IStreamConfig failed", __fxName));

        // this is a required interface.
        return hr;
    }

    // get the SilenceControl interface from the pin.
    _ASSERT(m_pSilenceControl == NULL);
    hr = pIPin->QueryInterface(&m_pSilenceControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture pin's ISilenceControl failed, hr=%x", 
            __fxName, hr));

        // this is a required interface.
        return hr;
    }

    // get the BitrateControl interface.
    _ASSERT(m_pCaptureBitrateControl == NULL);
    hr = pIPin->QueryInterface(&m_pCaptureBitrateControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture pin's BitrateControl failed, hr=%x", 
            __fxName, hr));
    }

    // find the filter behind the pin.
    PIN_INFO PinInfo;
    if (SUCCEEDED(hr = pIPin->QueryPinInfo(&PinInfo)))
    {
        // get the AudioInputMixer interface.
        _ASSERT(m_pAudioInputMixer == NULL);
        hr = PinInfo.pFilter->QueryInterface(&m_pAudioInputMixer);
        if (FAILED(hr))
        {
            LOG((MSP_WARN, 
                "%s:query capture filter's IAMAudioInputMixer failed, hr=%x", 
                __fxName, hr));

        }

        // get the AudioDeviceControl interface.
        _ASSERT(m_pAudioDeviceControl == NULL);
        hr = PinInfo.pFilter->QueryInterface(&m_pAudioDeviceControl);
        PinInfo.pFilter->Release();

        if (FAILED(hr))
        {
            LOG((MSP_WARN, 
                "%s:query capture filter's AudioDeviceControl failed, hr=%x", 
                __fxName, hr));
        }
        else
        {
            hr = m_pAudioDeviceControl->Set(
                AudioDevice_AutomaticGainControl, 
                m_lAutomaticGainControl, 
                TAPIControl_Flags_None
                );
        
            if (FAILED(hr))
            {
                LOG((MSP_WARN, 
                    "%s:set AGC failed, hr=%x", 
                    __fxName, hr));
            }

            hr = m_pAudioDeviceControl->Set(
                AudioDevice_AcousticEchoCancellation, 
                m_lAcousticEchoCancellation, 
                TAPIControl_Flags_None
                );

            if (FAILED(hr))
            {
                LOG((MSP_WARN, 
                    "%s:set AEC failed, hr=%x", 
                    __fxName, hr));
            }
        }

    }
    else
    {
        LOG((MSP_ERROR, 
            "%s:can't get the capture filter, hr=%x", 
            __fxName, hr));
    }

    return S_OK;
}

HRESULT CStreamAudioSend::GetAudioCapturePin(
    IN      ITTerminalControl *     pTerminal,
    OUT     IPin **                 ppIPin
    )
/*++

Routine Description:

    This function gets a output pin from the capture terminal.

Arguments:
    
    pTerminal - An audio capture terminal.

    ppIPin - the address to hold the returned pointer to IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "AudioSend configure audio capture terminal."));

    DWORD       dwNumPins   = 1;
    IPin *      Pins[1];

    // Get the pins from the terminal
    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_CAPTURE, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    // This stream needs only one pin from the terminal.
    _ASSERT(dwNumPins == 1);

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));
        return E_POINTER;
    }

    for (DWORD i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));
            return E_POINTER;
        }
    }

    // this pin carries a refcount
    *ppIPin = Pins[0];

    return hr;
}

HRESULT CStreamAudioSend::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the audio capture terminal to the stream.

Arguments:

    pITTerminal - The terminal to be connected.
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("AudioSend::ConnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "%s, can't get Terminal Control interface", __fxName));
        
        SendStreamEvent(
            CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE,
            E_NOINTERFACE, 
            pITTerminal
            );

        return E_NOINTERFACE;
    }

    // find the output pin of the terminal.
    CComPtr<IPin>   pCaptureOutputPin;
    HRESULT hr = GetAudioCapturePin(pTerminal, &pCaptureOutputPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, configure audio capture termianl failed. %x", __fxName, hr));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            hr, 
            pITTerminal
            );
        
        return hr;
    }

    CComPtr<IPin> PinToUse;

    hr = CacheAdditionalInterfaces(pCaptureOutputPin);

    if (SUCCEEDED(hr))
    {
        PinToUse = pCaptureOutputPin;

        // give the filter the full-duplex controller.
        ::ConfigureFullduplexControl(pCaptureOutputPin, m_pIAudioDuplexController);
    }
    else if (hr == E_NOINTERFACE)
    {
        // the capture filter doesn't support the needed interfaces.
        // we need to add our encoder here.
        
        if (FAILED(hr = ::AddFilter(
                m_pIGraphBuilder,
                __uuidof(TAPIAudioEncoder), 
                L"AudioEncoder", 
                &m_pEncoder)))
        {
            LOG((MSP_ERROR, "%s, adding Encoder filter. %x", __fxName, hr));
            goto cleanup;
        }

        // This is a hack for legacy terminals. We have to tell the terminal what
        // format to use
        const WORD wBitsPerSample = 16;   // 16 bits samples.
        const DWORD dwSampleRate = 8000;  // 8KHz.
        hr = ::SetAudioFormat(
            pCaptureOutputPin, 
            wBitsPerSample, 
            dwSampleRate
            );

        if (FAILED(hr))
        {
            LOG((MSP_WARN, "%s, can't set format. %x", __fxName, hr));
        }
           

        // This is a hack for legacy terminals. We have to tell the terminal what
        // buffer size to allocate.
        const DWORD dwNumBuffers = 4;    // 4 buffers in the allocator.
        const DWORD dwBufferSize = 480;  // 30ms samples in each buffer.
        hr = ::SetAudioBufferSize(pCaptureOutputPin, dwNumBuffers, dwBufferSize);

        if (FAILED(hr))
        {
            LOG((MSP_WARN, 
                "%s, can't suggest allocator properties. %x", __fxName, hr));
        }
           
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IPin *)pCaptureOutputPin, 
            (IBaseFilter *)m_pEncoder
            )))
        {
            LOG((MSP_ERROR, 
                "%s, connect audio capture filter and encoder filter. %x", 
                __fxName, hr));
            goto cleanup;
        }

        CComPtr<IPin> pEncoderOutputPin;
        if (FAILED(hr = ::FindPin(
            m_pEncoder, &pEncoderOutputPin, PINDIR_OUTPUT, TRUE)))
        {
            LOG((MSP_ERROR,
                "%s, find input pin on pCodecFilter failed. hr=%x", 
                __fxName, hr));
            goto cleanup;
        }

        PinToUse = pEncoderOutputPin;

        hr = CacheAdditionalInterfaces(pEncoderOutputPin);

        _ASSERT(SUCCEEDED(hr));
    }
    else
    {
        LOG((MSP_ERROR, "%s, can't add codec to table. %x", __fxName, hr));
        
        goto cleanup;
    }

        // Create other filters to be use in the stream.
    hr = CreateSendFilters(PinToUse);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create audio send filters failed. %x", hr));

        goto cleanup;
    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;

cleanup:

    CleanupCachedInterface();

    // clean up internal filters as well.
    CleanUpFilters();

    SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);

    pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

    if (m_pEncoder) 
    {
        m_pIGraphBuilder->RemoveFilter(m_pEncoder);

        m_pEncoder->Release();
        m_pEncoder = NULL;
    }

    return hr;
}

HRESULT CStreamAudioSend::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

    If it is the capture terminal being disconnected, all the pins that the 
    stream cached need to be released too. 

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::DisconnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    HRESULT hr = CIPConfMSPStream::DisconnectTerminal(pITTerminal);

    // release all the capture pins we cached.
    CleanupCachedInterface();

    CleanUpFilters();

    if (m_pEncoder) 
    {
        m_pIGraphBuilder->RemoveFilter(m_pEncoder);

        m_pEncoder->Release();
        m_pEncoder = NULL;
    }

    return hr;
}
HRESULT CStreamAudioSend::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend SetUpFilters"));

    // only support one terminal for this stream.
    if (m_Terminals.GetSize() != 1)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr;

    // Connect the terminal to the rest of the stream.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[0]
        )))
    {
        LOG((MSP_ERROR, "connect the terminal to the filters. %x", hr));

        return hr;
    }
    return hr;
}

HRESULT ConfigurePacketSize(
    IN const AM_MEDIA_TYPE *pMediaType, 
    IN DWORD dwMSPerPacket
    )
{
    WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pMediaType->pbFormat;
    ASSERT(pWaveFormatEx != NULL);

    switch (pWaveFormatEx->wFormatTag)
    {
    case WAVE_FORMAT_ALAW:
    case WAVE_FORMAT_MULAW:
        _ASSERT(pMediaType->cbFormat >= sizeof(WAVEFORMATEX_RTPG711));
        
        ((WAVEFORMATEX_RTPG711 *)pWaveFormatEx)->wPacketDuration = (WORD)dwMSPerPacket;
        
        break;

    case WAVE_FORMAT_DVI_ADPCM:
        _ASSERT(pMediaType->cbFormat >= sizeof(WAVEFORMATEX_RTPDVI4));

        ((WAVEFORMATEX_RTPDVI4 *)pWaveFormatEx)->wPacketDuration = (WORD)dwMSPerPacket;

        break;

    case WAVE_FORMAT_GSM610:
        _ASSERT(pMediaType->cbFormat >= sizeof(WAVEFORMATEX_RTPGSM));

        ((WAVEFORMATEX_RTPGSM *)pWaveFormatEx)->wPacketDuration = (WORD)dwMSPerPacket;

        break;
    }

    return S_OK;
}

HRESULT CStreamAudioSend::ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    )
/*++

Routine Description:

    Configure the RTP filter with RTP<-->AM media type mappings.

Arguments:
    
    pIRTPFilter - The source RTP Filter.

    pIStreamConfig - The stream config interface that has the media info.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("AudioSend::ConfigureRTPFormats");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    CComPtr<IRtpMediaControl> pIRtpMediaControl;
    hr = pIRTPFilter->QueryInterface(&pIRtpMediaControl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
        return hr;
    }

    // find the number of capabilities supported.
    DWORD dwCount;
    hr = pIStreamConfig->GetNumberOfCapabilities(&dwCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s GetNumberOfCapabilities. %x", __fxName, hr));
        return hr;
    }

    BOOL bFound = FALSE;
    for (DWORD dw = 0; dw < dwCount; dw ++)
    {
        AM_MEDIA_TYPE *pMediaType;
        DWORD dwPayloadType;

        hr = pIStreamConfig->GetStreamCaps(
            dw, &pMediaType, NULL, &dwPayloadType
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s GetStreamCaps. %x", __fxName, hr));
            return hr;
        }

        for (DWORD dw2 = 0; dw2 < m_Settings.dwNumPayloadTypes; dw2 ++)
        {
            if (dwPayloadType == m_Settings.PayloadTypes[dw2])
            {
                if (dw2 == 0)
                {
                // tell the encoder to use this format.
                // TODO, cache all the allowed mediatypes in the conference for
                // future enumerations. It would be nice that we can get the SDP blob
                // when the call object is created.

                    if (m_Settings.dwMSPerPacket)
                    {
                        hr = ConfigurePacketSize(pMediaType, m_Settings.dwMSPerPacket);
                        if (FAILED(hr))
                        {
                            MSPDeleteMediaType(pMediaType);

                            LOG((MSP_ERROR, "%s ConfigurePacketSize. hr=%x", __fxName, hr));
                            return hr;
                        }
                    }
                }

                hr = pIRtpMediaControl->SetFormatMapping(
                    dwPayloadType,
                    FindSampleRate(pMediaType),
                    pMediaType
                    );

                if (FAILED(hr))
                {
                    MSPDeleteMediaType(pMediaType);

                    LOG((MSP_ERROR, "%s SetFormatMapping. %x", __fxName, hr));
                    return hr;
                }
                else
                {
                    LOG((MSP_INFO, "%s Configured payload:%d", __fxName, dwPayloadType));
                }

                if (dw2 == 0)
                {
                    hr = pIStreamConfig->SetFormat(dwPayloadType, pMediaType);
                    if (FAILED(hr))
                    {
                        MSPDeleteMediaType(pMediaType);

                        LOG((MSP_ERROR, "%s SetFormat. %x", __fxName, hr));
                        return hr;
                    }
                }
            }
        }
        MSPDeleteMediaType(pMediaType);
    }

    return S_OK;
}

HRESULT CStreamAudioSend::CreateSendFilters(
    IN    IPin          *pPin
    )
/*++

Routine Description:

    Insert filters into the graph and connect to the capture pin.

    Capturepin->RTPRender

Arguments:
    
    pPin - The output pin on the capture filter.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::CreateSendFilters");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    // Create the RTP render filter and add it into the graph.
    CComPtr<IBaseFilter> pRenderFilter;

    if (m_pIRTPSession == NULL)
    {
        if (FAILED(hr = ::AddFilter(
                m_pIGraphBuilder,
                __uuidof(MSRTPRenderFilter), 
                L"RtpRender", 
                &pRenderFilter)))
        {
            LOG((MSP_ERROR, "%s, adding render filter. %x", __fxName, hr));
            return hr;
        }

        // Set the address for the render fitler.
        if (FAILED(hr = ConfigureRTPFilter(pRenderFilter)))
        {
            LOG((MSP_ERROR, "%s, set destination address. %x", __fxName, hr));
            return hr;
        }
    }
    else
    {
        if (FAILED (hr = m_pIRTPSession->QueryInterface (&pRenderFilter)))
        {
            LOG ((MSP_ERROR, "%s failed to get filter from rtp session. %x", __fxName, hr));
            return hr;
        }

        if (FAILED (hr = m_pIGraphBuilder->AddFilter ((IBaseFilter *)pRenderFilter, L"RtpRender")))
        {
            LOG ((MSP_ERROR, "%s failed to add filter to graph. %x", __fxName, hr));
            return hr;
        }
    }

    _ASSERT(m_pIStreamConfig != NULL);

    // configure the format info on the RTP filter
    if (FAILED(hr = ConfigureRTPFormats(pRenderFilter, m_pIStreamConfig)))
    {
        LOG((MSP_ERROR, "%s, configure RTP formats. %x", __fxName, hr));
        return hr;
    }

        // Connect the capture filter with the RTP Render filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IPin *)pPin, 
        (IBaseFilter *)pRenderFilter
        )))
    {
        LOG((MSP_ERROR, 
            "%s, connect audio capture filter and RTP Render filter. %x",
            __fxName, hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamAudioSend::ProcessGraphEvent(
    IN  long lEventCode,
    IN  LONG_PTR lParam1,
    IN  LONG_PTR lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d", m_szName, lEventCode));

    switch (lEventCode)
    {
    case VAD_EVENTBASE + VAD_SILENCE:
        m_lock.Lock ();
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent (PE_LOCAL_SILENT, NULL);
        m_lock.Unlock ();
        break;

    case VAD_EVENTBASE + VAD_TALKING:
        m_lock.Lock ();
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent (PE_LOCAL_TALKING, NULL);
        m_lock.Unlock ();
        break;

    default:
        return CIPConfMSPStream::ProcessGraphEvent(
            lEventCode, lParam1, lParam2
            );
    }

    return S_OK;
}

STDMETHODIMP CStreamAudioSend::GetRange(
    IN  AudioDeviceProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::GetRange(AudioDeviceProperty)");

    if (IsBadWritePtr(plMin, sizeof(long)) || 
        IsBadWritePtr(plMax, sizeof(long)) ||
        IsBadWritePtr(plSteppingDelta, sizeof(long)) ||
        IsBadWritePtr(plDefault, sizeof(long)) ||
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    HRESULT hr = E_NOTIMPL;
    switch (Property)
    {
    case AudioDevice_DuplexMode:
        break;

    case AudioDevice_AutomaticGainControl:
        *plMin = 0;
        *plMax = 1;
        *plSteppingDelta = 1;
        *plDefault = DEFUAT_AGC_STATUS;
        *plFlags = TAPIControl_Flags_Auto;
        hr = S_OK;
        break;

    case AudioDevice_AcousticEchoCancellation:
        *plMin = 0;
        *plMax = 1;
        *plSteppingDelta = 1;
        *plDefault = DEFUAT_AEC_STATUS;
        *plFlags = TAPIControl_Flags_Auto;
        hr = S_OK;
        break;

    default:
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CStreamAudioSend::Get(
    IN  AudioDeviceProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Get(AudioDeviceProperty)");

    if (IsBadWritePtr(plValue, sizeof(long)) || 
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    CLock lock(m_lock);

    HRESULT hr = E_NOTIMPL;
    switch (Property)
    {
    case AudioDevice_DuplexMode:
        break;

    case AudioDevice_AutomaticGainControl:
        *plValue = m_lAutomaticGainControl;
        *plFlags = TAPIControl_Flags_Auto;
        hr = S_OK;
        break;

    case AudioDevice_AcousticEchoCancellation:
        *plValue = m_lAcousticEchoCancellation;
        *plFlags = TAPIControl_Flags_Auto;
        hr = S_OK;
        break;

    default:
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CStreamAudioSend::Set(
    IN  AudioDeviceProperty Property, 
    IN  long lValue, 
    IN  TAPIControlFlags lFlags
    )
/*++

Routine Description:
    
    Set the value for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Set(AudioDeviceProperty)");

    CLock lock(m_lock);

    HRESULT hr;
    switch (Property)
    {
    case AudioDevice_DuplexMode:
        return E_NOTIMPL;

    case AudioDevice_AutomaticGainControl:
        if (lValue !=0 && lValue != 1)
        {
            return E_INVALIDARG;
        }

        // check if we have the interface to delegate to.
        if (m_pAudioDeviceControl)
        {
            // set the value on the filter.
            hr = m_pAudioDeviceControl->Set(Property, lValue, lFlags);
            if (FAILED(hr))
            {
                return hr;
            }
        }

        m_lAutomaticGainControl = lValue;
        return S_OK;

    case AudioDevice_AcousticEchoCancellation:
        if (lValue !=0 && lValue != 1)
        {
            return E_INVALIDARG;
        }

        // check if we have the interface to delegate to.
        if (m_pAudioDeviceControl)
        {
            // set the value on the filter.
            hr = m_pAudioDeviceControl->Set(Property, lValue, lFlags);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        m_lAcousticEchoCancellation = lValue;
        return S_OK;
    }

    return E_INVALIDARG;
}

STDMETHODIMP CStreamAudioSend::GetRange(
    IN  AudioSettingsProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::GetRange(AudioSettings)");

    if (IsBadWritePtr(plMin, sizeof(long)) || 
        IsBadWritePtr(plMax, sizeof(long)) ||
        IsBadWritePtr(plSteppingDelta, sizeof(long)) ||
        IsBadWritePtr(plDefault, sizeof(long)) ||
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    CLock lock(m_lock);

    HRESULT hr = E_NOINTERFACE;

    switch (Property)
    {
    case AudioSettings_SignalLevel:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the range from the filter.
            hr = m_pSilenceControl->GetAudioLevelRange(plMin, plMax, plSteppingDelta);

            if (SUCCEEDED(hr))
            {
                *plDefault = *plMin;
                *plFlags = TAPIControl_Flags_None;
            }
        }

        break;

    case AudioSettings_SilenceThreshold:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the range from the filter.
            hr = m_pSilenceControl->GetSilenceLevelRange(
                plMin, 
                plMax, 
                plSteppingDelta, 
                plDefault, 
                plFlags
                );
        }
        break;

    case AudioSettings_Volume:

        *plMin = MIN_VOLUME;
        *plMax = MAX_VOLUME;
        *plSteppingDelta = 1;
        *plDefault = *plMin;
        *plFlags = TAPIControl_Flags_Manual;
        hr = S_OK;

        break;

    case AudioSettings_Balance:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Loudness:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Treble:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Bass:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Mono:

        *plMin = 1;
        *plMax = 1;
        *plSteppingDelta = 1;
        *plDefault = 1;
        *plFlags = TAPIControl_Flags_Manual;
        hr = S_OK;

        break;

    default:
        hr = E_INVALIDARG;

    }

    return hr;
}

STDMETHODIMP CStreamAudioSend::Get(
    IN  AudioSettingsProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Get(AudioSettings)");

    if (IsBadWritePtr(plValue, sizeof(long)) || 
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    CLock lock(m_lock);

    HRESULT hr = E_NOINTERFACE;

    switch (Property)
    {
    case AudioSettings_SignalLevel:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the level from the filter.
            hr = m_pSilenceControl->GetAudioLevel(plValue);

            if (SUCCEEDED(hr))
            {
                *plFlags = TAPIControl_Flags_None;
            }
        }

        break;

    case AudioSettings_SilenceThreshold:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the level from the filter.
            hr = m_pSilenceControl->GetSilenceLevel(
                plValue, 
                plFlags
                );
        }
        break;

    case AudioSettings_Volume:

        if (m_pAudioInputMixer)
        {
            double dVolume;
            hr = m_pAudioInputMixer->get_MixLevel(&dVolume);
            
            if (SUCCEEDED(hr))
            {
                // Convert the volume from the range 0 - 1 to the API's range.
                *plValue = MIN_VOLUME + (long) (( MAX_VOLUME - MIN_VOLUME ) * dVolume);
                *plFlags = TAPIControl_Flags_Manual;
            }
        }

        break;

    case AudioSettings_Balance:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Loudness:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Treble:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Bass:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Mono:

        // we only support MONO for now.
        *plValue = 1;
        *plFlags = TAPIControl_Flags_Manual;
        hr = S_OK;

        break;

    default:
        hr = E_INVALIDARG;

    }

    return hr;
}

STDMETHODIMP CStreamAudioSend::Set(
    IN  AudioSettingsProperty Property, 
    IN  long lValue, 
    IN  TAPIControlFlags lFlags
    )
/*++

Routine Description:
    
    Set the value for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Set(AudioSettings)");

    CLock lock(m_lock);

    HRESULT hr = E_NOINTERFACE;

    switch (Property)
    {
    case AudioSettings_SignalLevel:

        // this is a read only property.
        hr = E_FAIL;

        break;

    case AudioSettings_SilenceThreshold:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the range from the filter.
            hr = m_pSilenceControl->SetSilenceLevel(
                lValue, 
                lFlags
                );
        }
        break;

    case AudioSettings_Volume:

        if (m_pAudioInputMixer)
        {
            // Convert to the range 0 to 1.
            double dVolume = (lValue - MIN_VOLUME ) 
                    / ((double)(MAX_VOLUME - MIN_VOLUME));

            hr = m_pAudioInputMixer->put_MixLevel(dVolume);
        }
        
        break;

    case AudioSettings_Balance:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Loudness:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Treble:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Bass:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Mono:

        // we only support MONO for now.
        if (lValue == 1)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }

        break;

    default:
        hr = E_INVALIDARG;

    }

    return hr;
}

//
// ITStreamQualityControl methods
//
STDMETHODIMP CStreamAudioSend::Set (
    IN   StreamQualityProperty Property, 
    IN   long lValue, 
    IN   TAPIControlFlags lFlags
    )
{
    return E_NOTIMPL;
}

//    
// IInnerStreamQualityControl methods.
//
STDMETHODIMP CStreamAudioSend::GetRange(
    IN  InnerStreamQualityProperty property, 
    OUT LONG *plMin, 
    OUT LONG *plMax, 
    OUT LONG *plSteppingDelta, 
    OUT LONG *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a quality control property. Delegated to capture filter
    for now.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::GetRange (InnerStreamQualityControl)");

    HRESULT hr;
    static BOOL fReported = FALSE;

    CLock lock(m_lock);

    switch (property)
    {
    case InnerStreamQuality_MaxBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->GetRange(
                BitrateControl_Maximum, plMin, plMax, plSteppingDelta, plDefault, plFlags, LAYERID
                );
        }

        break;

    case InnerStreamQuality_CurrBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->GetRange(
                BitrateControl_Current, plMin, plMax, plSteppingDelta, plDefault, plFlags, LAYERID
                );
        }

        break;

    default:
        hr = CIPConfMSPStream::GetRange (property, plMin, plMax, plSteppingDelta, plDefault, plFlags);
        break;
    }

    return hr;
}

STDMETHODIMP CStreamAudioSend::Get(
    IN  InnerStreamQualityProperty property, 
    OUT LONG *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a quality control property. Delegated to the quality 
    controller.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Get(QualityControl)");

    HRESULT hr;
    static BOOL fReported = FALSE;

    CLock lock(m_lock);

    switch (property)
    {
    case InnerStreamQuality_MaxBitrate:

        if( m_pCaptureBitrateControl == NULL )
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->Get(BitrateControl_Maximum, plValue, plFlags, LAYERID);
        }

        break;

    case InnerStreamQuality_CurrBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->Get(BitrateControl_Current, plValue, plFlags, LAYERID);
        }
        break;

    default:
        hr = CIPConfMSPStream::Get (property, plValue, plFlags);
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confaddr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    confaddr.h

Abstract:

    Declaration of the CIPConfMSP

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __CONFADDR_H_
#define __CONFADDR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

const DWORD IPCONFCALLMEDIATYPES = (TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO);
const DWORD MAXIPADDRLEN = 255;

extern const GUID CLSID_IPConfMSP;

/////////////////////////////////////////////////////////////////////////////
// CIPConfMSP
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CIPConfMSP : 
    public CMSPAddress,
    public CComCoClass<CIPConfMSP, &CLSID_IPConfMSP>,
    public CMSPObjectSafetyImpl
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_IPCONFMSP)
DECLARE_POLY_AGGREGATABLE(CIPConfMSP)

public:

    BEGIN_COM_MAP(CIPConfMSP)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_CHAIN(CMSPAddress)
    END_COM_MAP()

    CIPConfMSP() 
        : m_dwIPInterface(INADDR_ANY),
          m_hSocket(NULL),
          m_hDxmrtp(NULL)
    {}

    HRESULT FinalConstruct();
    void    FinalRelease();
    DWORD FindLocalInterface(DWORD dwIP);

    STDMETHOD (CreateTerminal) (
        IN      BSTR                pTerminalClass,
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        OUT     ITTerminal **       ppTerminal
        );

    STDMETHOD (CreateMSPCall) (
        IN      MSP_HANDLE      htCall,
        IN      DWORD           dwReserved,
        IN      DWORD           dwMediaType,
        IN      IUnknown *      pOuterUnknown,
        OUT     IUnknown **     ppMSPCall
        );

    STDMETHOD (ShutdownMSPCall) (
        IN      IUnknown *      pMSPCall
        );

    ULONG MSPAddressAddRef(void);

    ULONG MSPAddressRelease(void);

#ifdef USEIPADDRTABLE
    STDMETHOD (get_DefaultIPInterface) (
        OUT     BSTR *          ppIPAddress
        );
    
    STDMETHOD (put_DefaultIPInterface) (
        IN      BSTR            pIPAddress
        );

    STDMETHOD (get_IPInterfaces) (
        OUT     VARIANT *       pVariant
        );
    
    STDMETHOD (EnumerateIPInterfaces) (
        OUT     IEnumBstr **   ppIEnumBstr
        );
#endif

protected:

    DWORD GetCallMediaTypes(void);

    HRESULT CreateAudioCaptureTerminals();
    HRESULT CreateAudioRenderTerminals();
    HRESULT CreateVideoCaptureTerminals();

    HRESULT UpdateTerminalList(void);
    HRESULT UpdateTerminalListForPnp(IN BOOL bDeviceArrival);

protected:

    // the default interface to join the conference.
    DWORD   m_dwIPInterface;

    // the critical section to protect the local data.
    CMSPCritSection     m_Lock;

    SOCKET              m_hSocket;

    HMODULE             m_hDxmrtp;
};

#ifdef USEIPADDRTABLE
/////////////////////////////////////////////////////////////////////////////
// _CopyBSTR is used in creating BSTR enumerators.
/////////////////////////////////////////////////////////////////////////////
class _CopyBSTR
{
public:
    static void copy(BSTR *p1, BSTR *p2)
    {
            (*p1) = SysAllocString(*p2);
    }
    static void init(BSTR* p) {*p = NULL;}
    static void destroy(BSTR* p) { SysFreeString(*p);}
};
#endif

#endif //__CONFADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confaud.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confaud.h

Abstract:

    Definitions for audio streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFAUD_H_
#define __CONFAUD_H_

const DWORD MAX_MIX_CHANNELS = 5;

const long DEFUAT_AEC_STATUS = 0;
const long DEFUAT_AGC_STATUS = 1;

class ATL_NO_VTABLE CStreamAudioRecv : 
    public CIPConfMSPStream,
    public ITAudioSettings
{
BEGIN_COM_MAP(CStreamAudioRecv)
    COM_INTERFACE_ENTRY(ITAudioSettings)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfMSPStream)
END_COM_MAP()

public:

    CStreamAudioRecv();
    ~CStreamAudioRecv();

    // this method is called by the call object at init time.
    void SetFullDuplexController(
        IN IAudioDuplexController * pIAudioDuplexController
        );

    HRESULT ShutDown();

    //
    // ITAudioSettings methods
    //
    STDMETHOD (GetRange) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioSettingsProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

//
    //IInnerStreamQualityControl methods
    //
#if 0
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );
#endif

protected:
    HRESULT SetUpFilters();

    HRESULT ConfigureRTPFormats(
        IN  IBaseFilter *       pIRTPFilter,
        IN  IStreamConfig *     pIStreamConfig
        );

    HRESULT AddOneMixChannel(
        IN  IBaseFilter* pSourceFilter,
        IN  IPin *pPin,
        IN  DWORD dwChannelNumber
        );

    HRESULT SetUpInternalFilters(
        IN  IPin **ppPins,
        IN  DWORD dwNumPins
        );

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ProcessTalkingEvent(
        IN  DWORD   dwSSRC
        );

    HRESULT ProcessWasTalkingEvent(
        IN  DWORD   dwSSRC
        );

    HRESULT ProcessParticipantLeave(
        IN  DWORD   dwSSRC
        );

    HRESULT NewParticipantPostProcess(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

protected:

    // a small buffer to queue up pin mapped events.
    CMSPArray <DWORD>       m_PendingSSRCs;

protected:
    IAudioDuplexController *m_pIAudioDuplexController;
    
    // need an array of IBitrateControl pointer for all the decoders.
    //IBitrateControl *       m_pRenderBitrateControl;
};

class ATL_NO_VTABLE CStreamAudioSend : 
    public CIPConfMSPStream,
    public ITAudioSettings,
    public ITAudioDeviceControl
{

BEGIN_COM_MAP(CStreamAudioSend)
    COM_INTERFACE_ENTRY(ITAudioSettings)
    COM_INTERFACE_ENTRY(ITAudioDeviceControl)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfMSPStream)
END_COM_MAP()

public:
    CStreamAudioSend();
    ~CStreamAudioSend();

    HRESULT ShutDown();

    // this method is called by the call object at init time.
    void SetFullDuplexController(
        IN IAudioDuplexController *pIAudioDuplexController
        );

    //
    // ITAudioDeviceControl methods
    //
    STDMETHOD (GetRange) (
        IN   AudioDeviceProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioDeviceProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioDeviceProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITAudioSettings methods
    //
    STDMETHOD (GetRange) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioSettingsProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

protected:

    HRESULT SetUpFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CreateSendFilters(
        IN    IPin          *pPin
        );

    HRESULT ConfigureRTPFormats(
        IN  IBaseFilter *       pIRTPFilter,
        IN  IStreamConfig *     pIStreamConfig
        );

    HRESULT GetAudioCapturePin(
        IN   ITTerminalControl *    pTerminal,
        OUT  IPin **                ppIPin
        );

    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  LONG_PTR lParam1,
        IN  LONG_PTR lParam2
        );

    void CleanupCachedInterface();

    HRESULT CacheAdditionalInterfaces(
        IN  IPin *                 pIPin
        );

protected:

    IPin *      m_pCapturePin;
    IStreamConfig*          m_pIStreamConfig;
    ISilenceControl *       m_pSilenceControl;
    IAMAudioInputMixer  *   m_pAudioInputMixer;
    IAudioDeviceControl *   m_pAudioDeviceControl;
    IAudioDuplexController *m_pIAudioDuplexController;
    IBitrateControl *       m_pCaptureBitrateControl;
    IBaseFilter *           m_pEncoder;
    long                    m_lAutomaticGainControl;
    long                    m_lAcousticEchoCancellation;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confaudt.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    IPConfaudt.cpp

Abstract:

    IPConfMSP implementation of audio capture terminal and render terminal

Author:

    Zoltan Szilagyi (zoltans) September 6,1998
    Mu Han (muhan) June 6, 1999
--*/

#include "stdafx.h"

#define MAX_LONG 0xefffffff

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CIPConfAudioCaptureTerminal::CIPConfAudioCaptureTerminal()
    : m_WaveID(0),
      m_DSoundGuid(GUID_NULL),
      m_pIAMAudioInputMixer(NULL)
{
    LOG((MSP_TRACE, "CIPConfAudioCaptureTerminal::CIPConfAudioCaptureTerminal"));
    m_TerminalClassID   = CLSID_MicrophoneTerminal;
    m_TerminalDirection = TD_CAPTURE;
    m_TerminalType      = TT_STATIC;
    m_TerminalState     = TS_NOTINUSE;
    m_dwMediaType       = TAPIMEDIATYPE_AUDIO;
}

CIPConfAudioCaptureTerminal::~CIPConfAudioCaptureTerminal()
{
    LOG((MSP_TRACE, "CIPConfAudioCaptureTerminal::~CIPConfAudioCaptureTerminal"));
    if (m_pIAMAudioInputMixer)
    {
        m_pIAMAudioInputMixer->Release();
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


HRESULT CIPConfAudioCaptureTerminal::CreateTerminal(
    IN  AudioDeviceInfo *pAudioDevieInfo,
    IN  MSP_HANDLE      htAddress,
    OUT ITTerminal      **ppTerm
    )
/*++

Routine Description:

    This method creates a terminal object base on the device info.

Arguments:

    pAudioDevieInfo - a pointer to an AudioDevieInfo data structure.

    htAddress - the handle to the address object.

    ppTerm - memory to store the returned terminal pointer.
    
Return Value:

    S_OK
    E_POINTER
--*/
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::CreateTerminal");
    LOG((MSP_TRACE, "%s, htAddress:%x", __fxName, htAddress));

    _ASSERT(!IsBadWritePtr(ppTerm, sizeof(ITTerminal *)));

    HRESULT hr;

    //
    // Create the terminal.
    //
    CMSPComObject<CIPConfAudioCaptureTerminal> *pTerminal = NULL;

    hr = ::CreateCComObjectInstance(&pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s can't create the terminal object hr = %8x", __fxName, hr));

        return hr;
    }


    // query for the ITTerminal interface
    ITTerminal *pITTerminal;
    hr = pTerminal->_InternalQueryInterface(__uuidof(ITTerminal), (void**)&pITTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, query terminal interface failed, %x", __fxName, hr));
        delete pTerminal;

        return hr;
    }

    // initialize the terminal 
    hr = pTerminal->Initialize(
            pAudioDevieInfo,
            htAddress
            );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "%s, Initialize failed; returning 0x%08x", __fxName, hr));

        pITTerminal->Release();
    
        return hr;
    }

    LOG((MSP_TRACE, "%s, Terminal %p(%ws) created", 
        __fxName, pITTerminal, pAudioDevieInfo->szDeviceDescription));

    *ppTerm = pITTerminal;

    return S_OK;
}

HRESULT CIPConfAudioCaptureTerminal::Initialize(
    IN  AudioDeviceInfo *pAudioDevieInfo,
    IN  MSP_HANDLE      htAddress
    )
{
    m_DSoundGuid = pAudioDevieInfo->DSoundGUID;
    m_WaveID = pAudioDevieInfo->WaveID;

    return CIPConfBaseTerminal::Initialize(
        pAudioDevieInfo->szDeviceDescription, htAddress
        );
}

HRESULT CIPConfAudioCaptureTerminal::CreateFilter(void)
/*++

Routine Description:

    This method creates the filter in this terminal. It creates the tapi audio
    capture filter and configures the device it uses.

Arguments:

    nothing.
   
Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::CreateFilter");
    LOG((MSP_TRACE, "%s, entered", __fxName));

    // This should only be called atmost once in the lifetime of this instance
    _ASSERT(m_pFilter == NULL);
    _ASSERT(m_pIAMAudioInputMixer == NULL);

    IBaseFilter *pICaptureFilter;

    // Create the filter.
    HRESULT hr = CoCreateInstance(
        __uuidof(TAPIAudioCapture),
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(IBaseFilter),
        (void **)&pICaptureFilter
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, CoCreate filter failed, %x", __fxName, hr));
        return hr;
    }
    
    // get the config interface.
    IAudioDeviceConfig *pIAudioDeviceConfig;
    hr = pICaptureFilter->QueryInterface(
        __uuidof(IAudioDeviceConfig), 
        (void **)&pIAudioDeviceConfig
        );

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, can't get the IAudioDeviceConfig interface, %x", 
            __fxName, hr));
        return hr;
    }

    // tell the filter the device IDs.
    hr = pIAudioDeviceConfig->SetDeviceID(m_DSoundGuid, m_WaveID);
    pIAudioDeviceConfig->Release();

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, set device ID failed, %x", __fxName, hr));
        return hr;
    }

    // remember the filter, keep the refcount as well.
    m_pFilter = pICaptureFilter;

    // Get the basic audio (mixer) interface for the filter.
    IAMAudioInputMixer *pIAMAudioInputMixer;
    hr = m_pFilter->QueryInterface(
            __uuidof(IAMAudioInputMixer),
            (void **) &pIAMAudioInputMixer
            );

    if (FAILED(hr))
    {
        // The filter doesn't support the mixer interface. This is not catastrophic;
        // all it means is that subsequent mixer operations on the terminal will fail.
        LOG((MSP_WARN, "%s, mixer QI failed %x", __fxName, hr));  
        m_pIAMAudioInputMixer = NULL;
    }
    else
    {
        m_pIAMAudioInputMixer = pIAMAudioInputMixer;
    }

    LOG((MSP_TRACE, "%s succeeded", __fxName));
    return S_OK;
}

HRESULT CIPConfAudioCaptureTerminal::GetExposedPins(
    IN  IPin ** ppPins, 
    IN  DWORD dwNumPins
    )
/*++

Routine Description:

    This method returns the output pins of the audio capture filter.

Arguments:

    ppPins - memory buffer to store the returned pins.

    dwNumPins - the number pins asked.
   
Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::GetExposedPins");
    LOG((MSP_TRACE, "%s entered, dwNumPins:%d", __fxName, dwNumPins));

    _ASSERT(m_pFilter != NULL);
    _ASSERT(dwNumPins != 0);
    _ASSERT(!IsBadWritePtr(ppPins, sizeof (IPin*) * dwNumPins));

    // Get the enumerator of pins on the filter.
    IEnumPins * pIEnumPins;
    HRESULT hr = m_pFilter->EnumPins(&pIEnumPins);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s enumerate pins on the filter failed. hr=%x", __fxName, hr));
        return hr;
    }

    // TODO: get only the outptu pins.
    // get the pins.
    DWORD dwFetched;
    hr = pIEnumPins->Next(dwNumPins, ppPins, &dwFetched);

    pIEnumPins->Release();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s IEnumPins->Next failed. hr=%x", __fxName, hr));
        return hr;
    }

    _ASSERT(dwFetched == dwNumPins);

    return S_OK;
}


STDMETHODIMP 
CIPConfAudioCaptureTerminal::DisconnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        )
/*++

Routine Description:

    This function is called by the MSP while trying to disconnect the filter in
    the terminal from the rest of the graph in the MSP. It adds the removes the
    filter from the graph and set the terminal free.

Arguments:
    
    pGraph - The filter graph. It is used for validation, to make sure the 
             terminal is disconnected from the same graph that it was 
             originally connected to.

    dwReserved - A reserved dword.

Return Value:

S_OK
E_INVALIDARG - wrong graph.

--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::DisconnectTerminal");
    LOG((MSP_TRACE, 
        "%s entered, pGraph:%p, dwReserved:%d", __fxName, pGraph, dwReserved));

    Lock();

    HRESULT hr;
    hr = CIPConfBaseTerminal::DisconnectTerminal(pGraph, dwReserved);

    if (SUCCEEDED(hr))
    {
        if (m_pIAMAudioInputMixer)
        {
            m_pIAMAudioInputMixer->Release();
            m_pIAMAudioInputMixer = NULL;
        }
    }

    Unlock();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//*                                                                         *//
//* NOTE: The input filter does not support IBasicAudio so we need to masage*//
//*       the parameters for the basic audio methods so that the will work  *//
//*       for IAMAudioInputMixer.                                           *//
//*                                                                         *//    
//*****************************************************************************
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIPConfAudioCaptureTerminal::get_Volume(long * plVolume)
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::get_Volume");
    LOG((MSP_TRACE, "%s entered", __fxName));

    // Check parameters.
    if ( IsBadWritePtr(plVolume, sizeof(long)) )
    {
        LOG((MSP_ERROR, "%s bad pointer, plVolume:%p", __fxName, plVolume));
        return E_POINTER;
    }

    Lock();
    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    double dVolume;
    hr = m_pIAMAudioInputMixer->get_MixLevel(&dVolume);
    
    Unlock();

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "%s (get_MixLevel) failed, hr=%x", __fxName, hr));
        return hr;
    }

    //
    // Massage ranges to convert between disparate semantics.
    //
    _ASSERT(dVolume >= MIXER_MIN_VOLUME);
    _ASSERT(dVolume <= MIXER_MAX_VOLUME);
    
    // Convert the volume from whatever range of doubles the filter uses
    // to the range 0 - 1. Right now this does nothing but makes the code
    // more general.
    dVolume = ( dVolume                 - MIXER_MIN_VOLUME )
            / ( MIXER_MAX_VOLUME - MIXER_MIN_VOLUME );

    // Convert the volume from the range 0 - 1 to the API's range.
    *plVolume = MIN_VOLUME +
        (long) (( MAX_VOLUME - MIN_VOLUME ) * dVolume);

    LOG((MSP_TRACE, "%s exits S_OK", __fxName));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioCaptureTerminal::put_Volume(long lVolume)
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::put_Volume");
    LOG((MSP_TRACE, "%s entered, lVolume:%d", __fxName, lVolume));

    // Our argument is a long in the range 0 - 0xFFFF. We need to convert it
    // to a double ranging from 0.0 to 1.0.
    if (lVolume < MIN_VOLUME)
    {
        LOG((MSP_ERROR, 
            "%s volume %d < %d; returning E_INVALIDARG",
            __fxName, lVolume, MIN_VOLUME));

        return E_INVALIDARG;
    }

    if (lVolume > MAX_VOLUME)
    {
        LOG((MSP_ERROR, 
            "%s volume %d > %d; returning E_INVALIDARG",
            __fxName, lVolume, MAX_VOLUME));

        return E_INVALIDARG;
    }

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    // Convert to the range 0 to 1.
    double dVolume =
               ( (double) ( lVolume             - MIN_VOLUME ) )
             / ( (double) ( MAX_VOLUME - MIN_VOLUME ) );

    // Convert the volume to whatever range of doubles the filter uses
    // from the range 0 - 1. Right now this does nothing but makes the code
    // more general.

    dVolume = MIXER_MIN_VOLUME +
        ( MIXER_MAX_VOLUME - MIXER_MIN_VOLUME ) * dVolume;

    hr = m_pIAMAudioInputMixer->put_MixLevel(dVolume);

    Unlock();

    LOG((MSP_TRACE, "%s exits. hr=%x", __fxName, hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioCaptureTerminal::get_Balance(long * plBalance)
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::get_Balance");
    LOG((MSP_TRACE, "%s entered, plBalance:%p", __fxName, plBalance));

    if ( IsBadWritePtr(plBalance, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    double dBalance;
    hr = m_pIAMAudioInputMixer->get_Pan(&dBalance);

    Unlock();

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "%s (get_Pan) failed, hr=%x", __fxName, hr));
        return hr;
    }

    *plBalance = (LONG) (dBalance * MAX_LONG);

    LOG((MSP_TRACE, "%s exits S_OK", __fxName));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioCaptureTerminal::put_Balance(long lBalance)
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::put_Balance");
    LOG((MSP_TRACE, "%s entered, lBalance:%d", __fxName, lBalance));

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIAMAudioInputMixer->put_Pan(lBalance / MAX_LONG);

    Unlock();

    LOG((MSP_TRACE, "%s exits. hr=%x", __fxName, hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioCaptureTerminal::get_WaveId(
    OUT long * plWaveId
    )
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::get_WaveId");
    LOG((MSP_TRACE, "%s, plWaveId:%p", __fxName, plWaveId));

    if ( IsBadWritePtr(plWaveId, sizeof(long)) )
    {
        LOG((MSP_ERROR, "%s, bad pointer argument", __fxName));

        return E_POINTER;
    }

    *plWaveId = (LONG)m_WaveID;

    LOG((MSP_TRACE, "%s, returning wave id:%d", __fxName, m_WaveID));
    return S_OK;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Audio Render Terminal
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CIPConfAudioRenderTerminal::CIPConfAudioRenderTerminal()
    : m_WaveID(0),
      m_DSoundGuid(GUID_NULL),
      m_pIBasicAudio(NULL)
{
    LOG((MSP_TRACE, "CIPConfAudioRenderTerminal::CIPConfAudioRenderTerminal"));
    m_TerminalClassID   = CLSID_SpeakersTerminal;
    m_TerminalDirection = TD_RENDER;
    m_TerminalType      = TT_STATIC;
    m_TerminalState     = TS_NOTINUSE;
    m_dwMediaType       = TAPIMEDIATYPE_AUDIO;
}

CIPConfAudioRenderTerminal::~CIPConfAudioRenderTerminal()
{
    LOG((MSP_TRACE, "CIPConfAudioRenderTerminal::~CIPConfAudioRenderTerminal"));
    if (m_pIBasicAudio)
    {
        m_pIBasicAudio->Release();
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


HRESULT CIPConfAudioRenderTerminal::CreateTerminal(
    IN  AudioDeviceInfo *pAudioDevieInfo,
    IN  MSP_HANDLE      htAddress,
    OUT ITTerminal      **ppTerm
    )
/*++

Routine Description:

    This method creates a terminal object base on the info in the moniker.

Arguments:

    pAudioDevieInfo - a pointer to an AudioDevieInfo data structure.

    htAddress - the handle to the address object.

    ppTerm - memory to store the returned terminal pointer.
    
Return Value:

    S_OK
    E_POINTER
--*/
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::CreateTerminal");
    LOG((MSP_TRACE, "%s, htAddress:%x", __fxName, htAddress));

    _ASSERT(!IsBadWritePtr(ppTerm, sizeof(ITTerminal *)));

    HRESULT hr;

    //
    // Create the filter.
    //
    CMSPComObject<CIPConfAudioRenderTerminal> *pTerminal = NULL;

    hr = ::CreateCComObjectInstance(&pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s can't create the terminal object hr = %8x", __fxName, hr));

        return hr;
    }

    // query for the ITTerminal interface
    ITTerminal *pITTerminal;
    hr = pTerminal->_InternalQueryInterface(__uuidof(ITTerminal), (void**)&pITTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, query terminal interface failed, %x", __fxName, hr));
        delete pTerminal;

        return hr;
    }

    // initialize the terminal 
    hr = pTerminal->Initialize(
            pAudioDevieInfo,
            htAddress
            );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "%s, Initialize failed; returning 0x%08x", __fxName, hr));

        pITTerminal->Release();
    
        return hr;
    }

    LOG((MSP_TRACE, "%s, Terminal %p(%ws) created", 
        __fxName, pITTerminal, pAudioDevieInfo->szDeviceDescription));

    *ppTerm = pITTerminal;

    return S_OK;
}

HRESULT CIPConfAudioRenderTerminal::Initialize(
    IN  AudioDeviceInfo *pAudioDevieInfo,
    IN  MSP_HANDLE      htAddress
    )
{
    m_DSoundGuid = pAudioDevieInfo->DSoundGUID;
    m_WaveID = pAudioDevieInfo->WaveID;

    return CIPConfBaseTerminal::Initialize(
        pAudioDevieInfo->szDeviceDescription, htAddress
        );
}

HRESULT CIPConfAudioRenderTerminal::CreateFilter(void)
/*++

Routine Description:

    This method creates the filter in this terminal. It creates the tapi audio
    render filter and configures the device it uses.

Arguments:

    nothing.
   
Return Value:

    S_OK
    E_POINTER
--*/
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::CreateFilters");
    LOG((MSP_TRACE, "%s, entered", __fxName));

    // This should only be called atmost once in the lifetime of this instance
    _ASSERT(m_pFilter == NULL);

    IBaseFilter *pICaptureFilter;

    // Create the filter.
    HRESULT hr = CoCreateInstance(
        __uuidof(TAPIAudioRender),
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(IBaseFilter),
        (void **)&pICaptureFilter
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, CoCreate filter failed, %x", __fxName, hr));
        return hr;
    }

    // get the config interface.
    IAudioDeviceConfig *pIAudioDeviceConfig;
    hr = pICaptureFilter->QueryInterface(
        __uuidof(IAudioDeviceConfig), 
        (void **)&pIAudioDeviceConfig
        );

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, can't get the IAudioDeviceConfig interface, %x", 
            __fxName, hr));
        return hr;
    }

    // tell the filter the device IDs.
    hr = pIAudioDeviceConfig->SetDeviceID(m_DSoundGuid, m_WaveID);
    pIAudioDeviceConfig->Release();

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, set device ID failed, %x", __fxName, hr));
        return hr;
    }

    // remember the filter, keep the refcount as well.
    m_pFilter = pICaptureFilter;

    // Get the basic audio interface for the filter.
    IBasicAudio *pIBasicAudio;
    hr = m_pFilter->QueryInterface(
            __uuidof(IBasicAudio),
            (void **) &pIBasicAudio
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, IBasicAudio QI failed 0x%08x", __fxName, hr));  
        m_pIBasicAudio = NULL;
    }
    else
    {
        m_pIBasicAudio = pIBasicAudio;
    }

    LOG((MSP_TRACE, "%s succeeded", __fxName));
    return S_OK;
}

HRESULT CIPConfAudioRenderTerminal::GetExposedPins(
    IN  IPin ** ppPins, 
    IN  DWORD dwNumPins
    )
/*++

Routine Description:

    This method returns the input pins of the audio render filter.

Arguments:

    ppPins - memory buffer to store the returned pins.

    dwNumPins - the number pins asked.
   
Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::GetExposedPins");
    LOG((MSP_TRACE, "%s entered, dwNumPins:%d", __fxName, dwNumPins));

    _ASSERT(m_pFilter != NULL);
    _ASSERT(dwNumPins != 0);
    _ASSERT(!IsBadWritePtr(ppPins, sizeof (IPin*) * dwNumPins));

    // Get the enumerator of pins on the filter.
    IEnumPins * pIEnumPins;
    HRESULT hr = m_pFilter->EnumPins(&pIEnumPins);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s enumerate pins on the filter failed. hr=%x", __fxName, hr));
        return hr;
    }

    // get the pins.
    DWORD dwFetched;
    hr = pIEnumPins->Next(dwNumPins, ppPins, &dwFetched);

    pIEnumPins->Release();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s IEnumPins->Next failed. hr=%x", __fxName, hr));
        return hr;
    }

    _ASSERT(dwFetched == dwNumPins);

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// TODO: Fix the range
STDMETHODIMP CIPConfAudioRenderTerminal::get_Volume(long * plVolume)
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::get_Volume");
    LOG((MSP_TRACE, "%s entered", __fxName));

    if ( IsBadWritePtr(plVolume, sizeof(long)) )
    {
        LOG((MSP_ERROR, "%s bad pointer, plVolume:%p", __fxName, plVolume));
        return E_POINTER;
    }

    Lock();
    
    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIBasicAudio->get_Volume(plVolume);
    
    Unlock();

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "%s (get_Volume) failed, hr=%x", __fxName, hr));
        return hr;
    }

    LOG((MSP_TRACE, "%s exits S_OK", __fxName));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioRenderTerminal::put_Volume(long lVolume)
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::put_Volume");
    LOG((MSP_TRACE, "%s entered, lVolume:%d", __fxName, lVolume));

    // Our argument is a long in the range 0 - 0xFFFF. We need to convert it
    // to a double ranging from 0.0 to 1.0.
    if (lVolume < MIN_VOLUME)
    {
        LOG((MSP_ERROR, 
            "%s volume %d < %d; returning E_INVALIDARG",
            __fxName, lVolume, MIN_VOLUME));

        return E_INVALIDARG;
    }

    if (lVolume > MAX_VOLUME)
    {
        LOG((MSP_ERROR, 
            "%s volume %d > %d; returning E_INVALIDARG",
            __fxName, lVolume, MAX_VOLUME));

        return E_INVALIDARG;
    }

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIBasicAudio->put_Volume(lVolume);

    Unlock();

    LOG((MSP_TRACE, "%s exits. hr=%x", __fxName, hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioRenderTerminal::get_Balance(long * plBalance)
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::get_Balance");
    LOG((MSP_TRACE, "%s entered, plBalance:%p", __fxName, plBalance));

    if ( IsBadWritePtr(plBalance, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIBasicAudio->get_Balance(plBalance);

    Unlock();

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "%s (get_Balance) failed, hr=%x", __fxName, hr));
        return hr;
    }

    LOG((MSP_TRACE, "%s exits S_OK", __fxName));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioRenderTerminal::put_Balance(long lBalance)
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::put_Balance");
    LOG((MSP_TRACE, "%s entered, lBalance:%d", __fxName, lBalance));

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIBasicAudio->put_Balance(lBalance);

    Unlock();

    LOG((MSP_TRACE, "%s exits. hr=%x", __fxName, hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioRenderTerminal::get_WaveId(
    OUT long * plWaveId
    )
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::get_WaveId");
    LOG((MSP_TRACE, "%s, plWaveId:%p", __fxName, plWaveId));

    if ( IsBadWritePtr(plWaveId, sizeof(long)) )
    {
        LOG((MSP_ERROR, "%s, bad pointer argument", __fxName));
        return E_POINTER;
    }

    *plWaveId = (LONG)m_WaveID;

    LOG((MSP_TRACE, "%s, returning wave id:%d", __fxName, m_WaveID));
    return S_OK;
}


STDMETHODIMP 
CIPConfAudioRenderTerminal::DisconnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        )
/*++

Routine Description:

    This function is called by the MSP while trying to disconnect the filter in
    the terminal from the rest of the graph in the MSP. It adds the removes the
    filter from the graph and set the terminal free.

Arguments:
    
    pGraph - The filter graph. It is used for validation, to make sure the 
             terminal is disconnected from the same graph that it was 
             originally connected to.

    dwReserved - A reserved dword.

Return Value:

S_OK
E_INVALIDARG - wrong graph.

--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::DisconnectTerminal");
    LOG((MSP_TRACE, 
        "%s entered, pGraph:%p, dwReserved:%d", __fxName, pGraph, dwReserved));

    Lock();

    HRESULT hr;
    hr = CIPConfBaseTerminal::DisconnectTerminal(pGraph, dwReserved);

    if (SUCCEEDED(hr))
    {
        if (m_pIBasicAudio)
        {
            m_pIBasicAudio->Release();
            m_pIBasicAudio = NULL;
        }
    }

    Unlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confaudt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//        Name: IPConfaudt.h
//
// Description: Definition of the CIPConfAudioCaptureTerminal class and 
//     CIPConfAudioRenderTerminal class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IPConfAUDT_H_
#define _IPConfAUDT_H_

// the volume range for the API.
const long  MIN_VOLUME    = 0;      
const long  MAX_VOLUME    = 0xFFFF;

const long  BALANCE_LEFT  = -100;
const long  BALANCE_RIGHT = 100;

const long  BOOST_FACTOR = 100;

// the volume range of the IAMInputMixer
const double MIXER_MIN_VOLUME = 0.0;
const double MIXER_MAX_VOLUME = 1.0;


/////////////////////////////////////////////////////////////////////////////
// CIPConfAudioCaptureTerminal
/////////////////////////////////////////////////////////////////////////////
const DWORD AUDIO_CAPTURE_FILTER_NUMPINS = 1;

class CIPConfAudioCaptureTerminal : 
    public IDispatchImpl<ITBasicAudioTerminal, &__uuidof(ITBasicAudioTerminal), &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITStaticAudioTerminal, &__uuidof(ITStaticAudioTerminal), &LIBID_TAPI3Lib>, 
    public CIPConfBaseTerminal
{

BEGIN_COM_MAP(CIPConfAudioCaptureTerminal)
    COM_INTERFACE_ENTRY(ITBasicAudioTerminal)
    COM_INTERFACE_ENTRY(ITStaticAudioTerminal)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfBaseTerminal)
END_COM_MAP()

public:
    CIPConfAudioCaptureTerminal();

    virtual ~CIPConfAudioCaptureTerminal();

    static HRESULT CreateTerminal(
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHODIMP DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

    // ITBasicAudioTerminal
    STDMETHOD(get_Balance)(OUT  long *pVal);
    STDMETHOD(put_Balance)(IN   long newVal);
    STDMETHOD(get_Volume) (OUT  long *pVal);
    STDMETHOD(put_Volume) (IN   long newVal);

    // ITStaticAudioTerminal
    STDMETHOD(get_WaveId) (OUT  long * plWaveId);

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return AUDIO_CAPTURE_FILTER_NUMPINS;
    }
    
    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );

protected:
    UINT                    m_WaveID;
    GUID                    m_DSoundGuid;

    IAMAudioInputMixer *    m_pIAMAudioInputMixer;
};

/////////////////////////////////////////////////////////////////////////////
// CIPConfAudioRenderTerminal
/////////////////////////////////////////////////////////////////////////////

const DWORD AUDIO_RENDER_FILTER_NUMPINS = 5;

class CIPConfAudioRenderTerminal : 
    public IDispatchImpl<ITBasicAudioTerminal, &__uuidof(ITBasicAudioTerminal), &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITStaticAudioTerminal, &__uuidof(ITStaticAudioTerminal), &LIBID_TAPI3Lib>, 
    public CIPConfBaseTerminal
{

BEGIN_COM_MAP(CIPConfAudioRenderTerminal)
    COM_INTERFACE_ENTRY(ITBasicAudioTerminal)
    COM_INTERFACE_ENTRY(ITStaticAudioTerminal)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfBaseTerminal)
END_COM_MAP()

public:
    CIPConfAudioRenderTerminal();

    virtual ~CIPConfAudioRenderTerminal();

    static HRESULT CreateTerminal(
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHODIMP DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

    // ITBasicAudioTerminal
    STDMETHOD(get_Balance)(OUT  long *pVal);
    STDMETHOD(put_Balance)(IN   long newVal);
    STDMETHOD(get_Volume) (OUT  long *pVal);
    STDMETHOD(put_Volume) (IN   long newVal);

    // ITStaticAudioTerminal
    STDMETHOD(get_WaveId) (OUT  long * plWaveId);

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return AUDIO_RENDER_FILTER_NUMPINS;
    }

    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );
protected:
    UINT                    m_WaveID;
    GUID                    m_DSoundGuid;

    IBasicAudio *           m_pIBasicAudio;
};

#endif // _IPConfAUDT_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confcall.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    confcall.h

Abstract:

    Declaration of the CIPConfMSPCall

Author:
    
    Mu Han (muhan) 5-September-1998

--*/

#ifndef __CONFCALL_H_
#define __CONFCALL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <confpdu.h>

const DWORD MAX_PAYLOAD_TYPES = 10;

typedef struct _STREAMSETTINGS
{
    DWORD   dwNumPayloadTypes;
    DWORD   PayloadTypes[MAX_PAYLOAD_TYPES];

    DWORD   dwMSPerPacket;    // milliseconds per packet.

    DWORD   dwQOSLevel;
    DWORD   dwTTL;
    DWORD   dwIPLocal;        // local interface to bind to.
    DWORD   dwIPRemote;       // remote IP address in host byte order.
    WORD    wRTPPortRemote;   // remote port number in host byte order.
    HANDLE *phRTPSession;     // the shared RTP session cookie

    BOOL    fCIF;             // if CIF is used for video.
    MULTICAST_LOOPBACK_MODE LoopbackMode;

    LONG    lBandwidth;

    WCHAR   *pApplicationID;
    WCHAR   *pApplicationGUID;
    WCHAR   *pSubIDs;

} STREAMSETTINGS, *PSTREAMSETTINGS;


/////////////////////////////////////////////////////////////////////////////
// CIPConfMSPCall
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CIPConfMSPCall : 
    public CMSPCallMultiGraph,
    public IDispatchImpl<ITParticipantControl, &__uuidof(ITParticipantControl), 
                            &LIBID_IPConfMSPLib>,
    public IDispatchImpl<ITLocalParticipant, &__uuidof(ITLocalParticipant), 
                            &LIBID_IPConfMSPLib>,
    public IDispatchImpl<IMulticastControl, &__uuidof(IMulticastControl), 
                            &LIBID_IPConfMSPLib>,
    public IDispatchImpl<ITQOSApplicationID, &__uuidof(ITQOSApplicationID), 
                            &LIBID_IPConfMSPLib>,
    public ITCallQualityControl,
    public IInnerCallQualityControl,
    public CMSPObjectSafetyImpl
{

public:

BEGIN_COM_MAP(CIPConfMSPCall)
    COM_INTERFACE_ENTRY(ITParticipantControl)
    COM_INTERFACE_ENTRY(ITLocalParticipant)
    COM_INTERFACE_ENTRY(IMulticastControl)
    COM_INTERFACE_ENTRY(ITQOSApplicationID)
    COM_INTERFACE_ENTRY2(IDispatch, ITStreamControl)
    COM_INTERFACE_ENTRY(ITCallQualityControl)
    COM_INTERFACE_ENTRY(IInnerCallQualityControl)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPCallMultiGraph)
END_COM_MAP()

    CIPConfMSPCall();
    ~CIPConfMSPCall();

// ITStreamControl methods, called by the app.
    STDMETHOD (CreateStream) (
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN OUT  ITStream **         ppStream
        );
    
    STDMETHOD (RemoveStream) (
        IN      ITStream *          pStream
        );                      

// ITParticipantControl methods, called by the app.
    STDMETHOD (EnumerateParticipants) (
        OUT     IEnumParticipant ** ppEnumParticipants
        );

    STDMETHOD (get_Participants) (
        OUT     VARIANT * pVariant
        );

// IMulticastControl methods, called by the app.
    STDMETHOD (get_LoopbackMode) (
        OUT MULTICAST_LOOPBACK_MODE * pMode
        );
    
    STDMETHOD (put_LoopbackMode) (
        IN MULTICAST_LOOPBACK_MODE mode
        );

// ITLocalParticipant methods, called by the app.
    STDMETHOD (get_LocalParticipantTypedInfo) (
        IN  PARTICIPANT_TYPED_INFO  InfoType,
        OUT BSTR *                  ppInfo
        );

    STDMETHOD (put_LocalParticipantTypedInfo) (
        IN  PARTICIPANT_TYPED_INFO  InfoType,
        IN  BSTR                    pInfo
        );

//ITQOSApplicationID methods, called by the app.
    STDMETHOD (SetQOSApplicationID) (
        IN  BSTR pApplicationID,
        IN  BSTR pApplicationGUID,
        IN  BSTR pSubIDs
        );

// methods called by the MSPAddress object.
    HRESULT Init(
        IN      CMSPAddress *       pMSPAddress,
        IN      MSP_HANDLE          htCall,
        IN      DWORD               dwReserved,
        IN      DWORD               dwMediaType
        );

    HRESULT ShutDown();

    HRESULT ReceiveTSPCallData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

// medthod called by the worker thread.
    static DWORD WINAPI WorkerCallbackDispatcher(VOID *pContext);

    virtual VOID HandleGraphEvent(
        IN      MSPSTREAMCONTEXT *  pContext
        );

    DWORD ProcessWorkerCallBack(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

    HRESULT InternalShutDown();
    
    DWORD MSPCallAddRef()
    {
        return MSPAddRefHelper(this);
    }

    DWORD MSPCallRelease()
    {
        return MSPReleaseHelper(this);
    }

// medthod called by the streams for participants
    HRESULT NewParticipant(
        IN  ITStream *              pITStream,
        IN  DWORD                   dwSSRC,
        IN  DWORD                   dwSendRecv,
        IN  DWORD                   dwMediaType,
        IN  WCHAR *                  szCName,
        OUT ITParticipant **        pITParticipant
        );

    HRESULT ParticipantLeft(
        IN ITParticipant *          pITParticipant
        );

    void SendParticipantEvent(
        IN  PARTICIPANT_EVENT       Event,
        IN  ITParticipant *         pITParticipant,
        IN  ITSubStream *           pITSubStream = NULL
        ) const;                          

    HRESULT SendTSPMessage(
        IN      TSP_MSP_COMMAND     command,
        IN      DWORD               dwParam1 = 0,
        IN      DWORD               dwParam2 = 0
        ) const;

    // this function is called at the call init time.
    void SetIPInterface(DWORD dwIPInterface)
    { m_dwIPInterface = dwIPInterface; }

    // ITCallQualityControl methods
    STDMETHOD (GetRange) (
        IN CallQualityProperty Property, 
        OUT long *plMin, 
        OUT long *plMax, 
        OUT long *plSteppingDelta, 
        OUT long *plDefault, 
        OUT TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN CallQualityProperty Property, 
        OUT long *plValue, 
        OUT TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN CallQualityProperty Property, 
        IN long lValue, 
        IN TAPIControlFlags lFlags
        );

    // IInnerCallQualityControl methods
    STDMETHOD_(ULONG, InnerCallAddRef) (VOID);

    STDMETHOD_(ULONG, InnerCallRelease) (VOID);

    STDMETHOD (RegisterInnerStreamQC) (
        IN  IInnerStreamQualityControl *pIInnerStreamQC
        );

    STDMETHOD (DeRegisterInnerStreamQC) (
        IN  IInnerStreamQualityControl *pIInnerStreamQC
        );

    STDMETHOD (ProcessQCEvent) (
        IN  QCEvent event,
        IN  DWORD dwParam
        );

protected:

    HRESULT InitializeLocalParticipant();
    
    virtual HRESULT CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        );

    HRESULT ProcessMediaItem(
        IN      ITMedia *           pITMedia,
        IN      DWORD               dwMediaTypeMask,
        OUT     DWORD *             pdwMediaType,
        OUT     WORD *              pwPort,
        OUT     DWORD *             pdwPayloadTypes,
        IN OUT  DWORD *             pdwNumPayLoadType
        );

    DWORD FindInterfaceByName(
        IN      WCHAR *             pMachineName
        );

    HRESULT CheckOrigin(
        IN      ITSdp *             pITSdp, 
        OUT     BOOL *              pFlag,
        OUT     DWORD *             pdwIP
        );

    HRESULT ConfigStreamsBasedOnSDP(
        IN      ITSdp *             pITSdp,
        IN      DWORD               dwAudioQOSLevel,
        IN      DWORD               dwVideoQOSLevel
        );

    HRESULT ParseSDP(
        IN      WCHAR *             pSDP,
        IN      DWORD               dwAudioQOSLevel,
        IN      DWORD               dwVideoQOSLevel
        );                          

    HRESULT CheckUnusedStreams();

    HRESULT InitFullDuplexControler();

protected:

    // The list of participant in the call.
    CParticipantList    m_Participants;

    // call quality control relay
    CCallQualityControlRelay *m_pCallQCRelay;

    // the information items for local participant. The index is the 
    // value of RTP_SDES_* - 1, see MSRTP.h.
    WCHAR *             m_InfoItems[NUM_SDES_ITEMS];
    BOOL                m_fLocalInfoRetrieved;

    // The critical section to protect the participant list.
    CMSPCritSection     m_ParticipantLock;

    BOOL                m_fShutDown;

    DWORD               m_dwIPInterface;

    HANDLE              m_hAudioRTPSession;
    HANDLE              m_hVideoRTPSession;
    IAudioDuplexController *    m_pIAudioDuplexController;
    MULTICAST_LOOPBACK_MODE     m_LoopbackMode;

    BOOL                m_fCallStarted;
    BSTR                m_pApplicationID;
    BSTR                m_pApplicationGUID;
    BSTR                m_pSubIDs;
    BOOL                m_fEnableAEC;
};

typedef struct _CALLWORKITEM
{
    CIPConfMSPCall  *pCall;
    DWORD           dwLen;
    BYTE            Buffer[1];

} CALLWORKITEM, *PCALLWORKITEM;

// some debug support
const char * const ParticipantEventString[] = 
{
    "NEW_PARTICIPANT",
    "INFO_CHANGE",
    "PARTICIPANT_LEAVE",
    "NEW_SUBSTREAM",
    "SUBSTREAM_REMOVED",
    "SUBSTREAM_MAPPED",
    "SUBSTREAM_UNMAPPED",
    "PARTICIPANT_TIMEOUT",
    "PARTICIPANT_RECOVERED",
    "PARTICIPANT_ACTIVE",
    "PARTICIPANT_INACTIVE",
    "LOCAL_TALKING",
    "LOCAL_SILENT"
};

#endif //__CONFCALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confmsp.cpp ===
// ipconf.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f ipconfps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "confmsp_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_IPConfMSP, CIPConfMSP)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        MSPLogRegister(_T("confmsp"));
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    { 
        _Module.Term();
        MSPLogDeRegister();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confcall.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confcall.cpp 

Abstract:

    This module contains implementation of CIPConfMSPCall.

Author:
    
    Mu Han (muhan)   5-September-1998

--*/
#include "stdafx.h"
#include <confpdu.h>

CIPConfMSPCall::CIPConfMSPCall()
    : m_fLocalInfoRetrieved(FALSE),
    m_fShutDown(FALSE),
    m_dwIPInterface(INADDR_ANY),
    m_LoopbackMode(MM_NO_LOOPBACK),
    m_hAudioRTPSession(NULL),
    m_hVideoRTPSession(NULL),
    m_pIAudioDuplexController(NULL),
    m_fCallStarted(FALSE),
    m_pApplicationID(NULL),
    m_pApplicationGUID(NULL),
    m_pSubIDs(NULL),
    m_pCallQCRelay(NULL)
{
    ZeroMemory(m_InfoItems, sizeof(m_InfoItems));
}

CIPConfMSPCall::~CIPConfMSPCall()
{
    if (m_pApplicationID)
    {
        SysFreeString(m_pApplicationID);
    }

    if (m_pApplicationGUID)
    {
        SysFreeString(m_pApplicationGUID);
    }

    if (m_pSubIDs)
    {
        SysFreeString(m_pSubIDs);
    }

    if (m_pCallQCRelay)
    {
        delete m_pCallQCRelay;
    }
}

STDMETHODIMP CIPConfMSPCall::CreateStream(
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN OUT  ITStream **         ppStream
    )
{
    // This MSP doesn't support creating new streams on the fly.
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CIPConfMSPCall::RemoveStream(
    IN      ITStream *          pStream
    )
{
    // This MSP doesn't support removing streams either.
    return TAPI_E_NOTSUPPORTED;
}

HRESULT CIPConfMSPCall::InitializeLocalParticipant()
/*++

Routine Description:

    This function uses the RTP filter to find out the local information that
    will be used in the call. The infomation is stored in a local participant 
    object.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    m_fLocalInfoRetrieved = FALSE;

    // Create the RTP fitler.
    IRtpSession *pIRtpSession;

    HRESULT hr = CoCreateInstance(
            __uuidof(MSRTPSourceFilter),
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            __uuidof(IRtpSession),
            (void **) &pIRtpSession
            );
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't create RTP filter for local info. %x", hr));
        return hr;
    }

    // Get the available local SDES info from the filter.
    WCHAR Buffer[MAX_PARTICIPANT_TYPED_INFO_LENGTH + 1];

    for (int i = 0; i < NUM_SDES_ITEMS; i ++)
    {
        DWORD dwLen = MAX_PARTICIPANT_TYPED_INFO_LENGTH;
        
        hr = pIRtpSession->GetSdesInfo(
            RTPSDES_CNAME + i,
            Buffer,
            &dwLen,
            0           // local participant
            );
        
        if (SUCCEEDED(hr) && dwLen > 0)
        {
            _ASSERT(dwLen <= MAX_PARTICIPANT_TYPED_INFO_LENGTH);

            // allocate memory to store the string.
            m_InfoItems[i] = (WCHAR *)malloc((dwLen) * sizeof(WCHAR));
            if (m_InfoItems[i] == NULL)
            {
                LOG((MSP_ERROR, "out of mem for local info"));

                pIRtpSession->Release();
                return E_OUTOFMEMORY;
            }
    
            lstrcpynW(m_InfoItems[i], Buffer, dwLen);
        }
    }

    pIRtpSession->Release();

    m_fLocalInfoRetrieved = TRUE;

    return S_OK;
}


HRESULT CIPConfMSPCall::Init(
    IN      CMSPAddress *       pMSPAddress,
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType
    )
/*++

Routine Description:

    This method is called when the call is first created. It sets
    up the streams based on the mediatype specified.

Arguments:
    
    pMSPAddress - The pointer to the address object.

    htCall      - The handle to the Call in TAPI's space. 
                    Used in sending events.

    dwReserved  - Reserved.

    dwMediaType - The media type of this call.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, 
        "IPConfMSP call %x initialize entered,"
        " pMSPAddress:%x, htCall %x, dwMediaType %x",
        this, pMSPAddress, htCall, dwMediaType
        ));

#ifdef DEBUG_REFCOUNT
    if (g_lStreamObjects != 0)
    {
        LOG((MSP_ERROR, "Number of Streams alive: %d", g_lStreamObjects));
//        DebugBreak();
    }
#endif

    // initialize the participant array so that the array is not NULL.
    if (!m_Participants.Grow())
    {
        LOG((MSP_ERROR, "out of mem for participant list"));
        return E_OUTOFMEMORY;
    }

    // Call the base class's init.
    HRESULT hr= CMSPCallMultiGraph::Init(
        pMSPAddress, 
        htCall, 
        dwReserved, 
        dwMediaType
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "MSPCallMultiGraph init failed:%x", hr));
        return hr;
    }

    // create the quality control relay for this call.
    m_pCallQCRelay = new CCallQualityControlRelay ();
    if (NULL == m_pCallQCRelay)
    {
        LOG((MSP_ERROR, "call init: failed to create call quality control relay:%x", hr));
        return E_OUTOFMEMORY;
    }

    // initialize qc relay, a thread will be started
    if (FAILED (hr = m_pCallQCRelay->Initialize (this)))
    {
        LOG ((MSP_ERROR, "call init: failed to initialize qc relay. %x", hr));
        return hr;
    }

    // create streams based on the media types.
    if (dwMediaType & TAPIMEDIATYPE_AUDIO)
    {
        ITStream * pStream;

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_AUDIO, TD_RENDER, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create audio render stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_AUDIO, TD_CAPTURE, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create audio capture stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();
    }

    if (dwMediaType & TAPIMEDIATYPE_VIDEO)
    {
        ITStream * pStream;

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_VIDEO, TD_RENDER, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create video render stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_VIDEO, TD_CAPTURE, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create video capture stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();
    }
    
    DWORD dwLoopback = 0;
    if (TRUE == ::GetRegValue(gszMSPLoopback, &dwLoopback) && dwLoopback != 0)
    {
        m_LoopbackMode = MULTICAST_LOOPBACK_MODE(dwLoopback);
    }

    m_fShutDown = FALSE;
    
    return S_OK;
}

HRESULT CIPConfMSPCall::ShutDown()
/*++

Routine Description:

    Shutdown the call. 

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    InternalShutDown();

    // acquire the lock on call.
    m_lock.Lock();

    for (int i = 0; i < NUM_SDES_ITEMS; i ++)
    {
        if (m_InfoItems[i])
        {
            free(m_InfoItems[i]);
            m_InfoItems[i] = NULL;
        }
    }

    m_lock.Unlock();

    return S_OK;
}

HRESULT CIPConfMSPCall::InternalShutDown()
/*++

Routine Description:

    First call the base class's shutdown and then release all the participant
    objects.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "ConfMSPCall.InternalShutdown, entered"));

    // acquire the lock on the call.
    m_lock.Lock();

    if (m_fShutDown)
    {
        LOG((MSP_TRACE, "ConfMSPCall::InterShutdown, already shutdown"));
        m_lock.Unlock ();
        return S_OK;
    }

    m_fShutDown = TRUE;

    if (m_pCallQCRelay)    
    {
        m_pCallQCRelay->Shutdown ();
    }

	int i;

    // Shutdown all the streams
    for (i = m_Streams.GetSize() - 1; i >= 0; i --)
    {
        UnregisterWaitEvent(i);
        ((CMSPStream*)m_Streams[i])->ShutDown();
    }
    m_ThreadPoolWaitBlocks.RemoveAll();

    // release all the streams
    for (i = m_Streams.GetSize() - 1; i >= 0; i --)
    {
        m_Streams[i]->Release();
    }
    m_Streams.RemoveAll();

    if (m_pIAudioDuplexController)
    {
        m_pIAudioDuplexController->Release();
        m_pIAudioDuplexController = NULL;	
    }

    m_lock.Unlock();

    // release all the participants
    m_ParticipantLock.Lock();

    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        m_Participants[i]->Release();
    }
    m_Participants.RemoveAll();

    m_ParticipantLock.Unlock();

    return S_OK;
}

template <class T>
HRESULT CreateStreamHelper(
    IN      T *                     pT,
    IN      HANDLE                  hAddress,
    IN      CIPConfMSPCall*         pMSPCall,
    IN      IMediaEvent *           pGraph,
    IN      DWORD                   dwMediaType,
    IN      TERMINAL_DIRECTION      Direction,
    OUT     ITStream **             ppITStream
    )
/*++

Routine Description:

    Create a stream object and initialize it. This method is called internally
    to create a stream object of different class.

Arguments:
    
    hAddress    - the handle to the address object.

    pCall       - the call object.

    pGraph      - the filter graph for this stream.

    dwMediaType - the media type of the stream. 

    Direction   - the direction of the steam.
    
    ppITStream  - the interface on this stream object.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION ("CreateStreamHelper");

    CComObject<T> * pCOMMSPStream;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCOMMSPStream);

    if (NULL == pCOMMSPStream)
    {
        LOG((MSP_ERROR, "CreateMSPStream:could not create stream:%x", hr));
        return hr;
    }

    // get the interface pointer.
    hr = pCOMMSPStream->_InternalQueryInterface(
        __uuidof(ITStream), 
        (void **)ppITStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPStream:QueryInterface failed: %x", hr));
        delete pCOMMSPStream;
        return hr;
    }

    // Initialize the object.
    hr = pCOMMSPStream->Init(
        hAddress,
        pMSPCall, 
        pGraph,
        dwMediaType,
        Direction
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPStream:call init failed: %x", hr));
        (*ppITStream)->Release();
        return hr;
    }

    // retrieve inner call quality control
    IInnerCallQualityControl * pIInnerCallQC;

    if (FAILED (hr = pMSPCall->_InternalQueryInterface (
        __uuidof (IInnerCallQualityControl),
        (void **)&pIInnerCallQC
        )))
    {
        LOG ((MSP_ERROR, "%s failed to retrieve inner call qc relay: %x", __fxName, hr));
        (*ppITStream)->Release ();
        return hr;
    }

    // retrieve inner stream quality control
    IInnerStreamQualityControl *pIInnerStreamQC;

    if (FAILED (hr = (*ppITStream)->QueryInterface (
        __uuidof (IInnerStreamQualityControl),
        (void **)&pIInnerStreamQC
        )))
    {
        LOG ((MSP_ERROR, "%s failed to retrieve inner stream qc relay: %x", __fxName, hr));
        pIInnerCallQC->Release ();
        (*ppITStream)->Release ();
        return hr;
    }

    // store inner call qc
    if (FAILED (hr = pIInnerStreamQC->LinkInnerCallQC (pIInnerCallQC)))
    {
        LOG ((MSP_ERROR, "%s failed to setup inner call qc on stream, %x", __fxName, hr));

        pIInnerCallQC->Release ();
        pIInnerStreamQC->Release ();
        (*ppITStream)->Release ();
        return hr;
    }

    // register inner stream qc on the call
    hr = pIInnerCallQC->RegisterInnerStreamQC (pIInnerStreamQC);
    pIInnerStreamQC->Release ();
    pIInnerCallQC->Release ();
    if (FAILED (hr))
    {
        LOG ((MSP_ERROR, "%s failed to register inner stream qc relay: %x", __fxName, hr));
        (*ppITStream)->Release ();
        return hr;
    }

    return S_OK;
}


HRESULT CIPConfMSPCall::CreateStreamObject(
    IN      DWORD               dwMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN      IMediaEvent *       pGraph,
    IN      ITStream **         ppStream
    )
/*++

Routine Description:

    Create a media stream object based on the mediatype and direction.

Arguments:
    
    pMediaType  - TAPI3 media type.

    Direction   - direction of this stream.

    IMediaEvent - The filter graph used in this stream.

    ppStream    - the return pointer of the stream interface

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CreateStreamObject, entered"));

    HRESULT      hr = S_OK;
    ITStream   * pIMSPStream = NULL;

    // Create a stream object based on the media type.
    if (dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        if (Direction == TD_RENDER)
        {
            CStreamAudioRecv *pAudioRecv = NULL;
            hr = ::CreateStreamHelper(
                pAudioRecv,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_AUDIO,
                TD_RENDER,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create audio receive:%x, hr:%x", pIMSPStream,hr));

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "create stream failed. %x", hr));
                return hr;
            }
            
            if (FAILED(hr = InitFullDuplexControler()))
            {
                LOG((MSP_ERROR, "Create full duplex controller failed. %x", hr));
            }
            else
            {
                ((CStreamAudioRecv *)pIMSPStream)->
                    SetFullDuplexController(m_pIAudioDuplexController);
            }
        }
        else if (Direction == TD_CAPTURE)
        {
            CStreamAudioSend *pAudioSend = NULL;
            hr = ::CreateStreamHelper(
                pAudioSend,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_AUDIO,
                TD_CAPTURE,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create audio send:%x, hr:%x", pIMSPStream,hr));

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "create stream failed. %x", hr));
                return hr;
            }

            if (FAILED(hr = InitFullDuplexControler()))
            {
                LOG((MSP_ERROR, "Create full duplex controller failed. %x", hr));
            }
            else
            {
                ((CStreamAudioSend *)pIMSPStream)->
                    SetFullDuplexController(m_pIAudioDuplexController);
            }
        }
        else
        {
            return TAPI_E_INVALIDDIRECTION;
        }
    }
    else if (dwMediaType == TAPIMEDIATYPE_VIDEO)
    {
        if (Direction == TD_RENDER)
        {
            CStreamVideoRecv *pVideoRecv = NULL;
            hr = ::CreateStreamHelper(
                pVideoRecv,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_VIDEO,
                TD_RENDER,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create video Recv:%x, hr:%x", pIMSPStream,hr));

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "create stream failed. %x", hr));
                return hr;
            }
        }
        else if (Direction == TD_CAPTURE)
        {
            CStreamVideoSend *pVideoSend = NULL;
            hr = ::CreateStreamHelper(
                pVideoSend,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_VIDEO,
                TD_CAPTURE,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create video send:%x, hr:%x", pIMSPStream,hr));

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "create stream failed. %x", hr));
                return hr;
            }
        }
        else
        {
            return TAPI_E_INVALIDDIRECTION;
        }
    }
    else
    {
        return TAPI_E_INVALIDMEDIATYPE;
    }

    *ppStream = pIMSPStream;

    return S_OK;
}

DWORD CIPConfMSPCall::FindInterfaceByName(IN WCHAR *pMachineName)
/*++

Routine Description:

    Given the machine name of the originator, find out which local interface
    can be used to reach that machine.

Arguments:
    
    pMachineName - The machine name of the originator.
    
Return Value:

    INADDR_NONE - nothing can be found.
    valid IP - succeeded.

--*/
{
    char buffer[MAXIPADDRLEN + 1];

    if (WideCharToMultiByte(
        GetACP(),
        0,
        pMachineName,
        -1,
        buffer,
        MAXIPADDRLEN,
        NULL,
        NULL
        ) == 0)
    {
        LOG((MSP_ERROR, "can't convert originator's address:%ws", pMachineName));

        return INADDR_NONE;
    }

    DWORD dwAddr;
    if ((dwAddr = inet_addr(buffer)) != INADDR_NONE)
    {
        dwAddr = ntohl(dwAddr);

        LOG((MSP_INFO, "originator's IP:%x", dwAddr));
        
        return ((CIPConfMSP *)m_pMSPAddress)->FindLocalInterface(dwAddr);
    }

    struct hostent * pHost;

    // attempt to lookup hostname
    pHost = gethostbyname(buffer);

    // validate pointer
    if (pHost == NULL) 
    {
        LOG((MSP_WARN, "can't resolve address:%s", buffer));
        return INADDR_NONE;

    }

    // for each of the addresses returned, find the local interface.
    for (DWORD i = 0; TRUE; i ++)
    {
        if (pHost->h_addr_list[i] == NULL)
        {
            break;
        }

        // retrieve host address from structure
        dwAddr = ntohl(*(unsigned long *)pHost->h_addr_list[i]);

        LOG((MSP_INFO, "originator's IP:%x", dwAddr));
        
        DWORD dwInterface = 
            ((CIPConfMSP *)m_pMSPAddress)->FindLocalInterface(dwAddr);

        if (dwInterface != INADDR_NONE)
        {
            return dwInterface;
        }
    }

    return INADDR_NONE;
}

HRESULT CIPConfMSPCall::CheckOrigin(
    IN      ITSdp *     pITSdp, 
    OUT     BOOL *      pFlag,
    OUT     DWORD *     pdwIP
    )
/*++

Routine Description:

    Check to see if the current user is the originator of the conference.
    If he is, he can send to a receive only conference.

Arguments:
    
    pITSdp  - a pointer to the ITSdp interface.

    pFlag   - The result.

    pdwIP   - The local IP interface that should be used to reach the originator.
    
Return Value:

    HRESULT.

--*/
{
    const DWORD MAXUSERNAMELEN = 127;
    DWORD dwUserNameLen = MAXUSERNAMELEN;
    WCHAR szUserName[MAXUSERNAMELEN+1];

    // determine the name of the current user
    if (!GetUserNameW(szUserName, &dwUserNameLen))
    {
        LOG((MSP_ERROR, "cant' get user name. %x", GetLastError()));
        return E_UNEXPECTED;
    }

    LOG((MSP_INFO, "current user: %ws", szUserName));

    // find out if the current user is the originator of the conference.
    BSTR Originator = NULL;
    HRESULT hr = pITSdp->get_Originator(&Originator);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "cant' get originator. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "originator: %ws", Originator));

    *pFlag = (_wcsnicmp(szUserName, Originator, lstrlenW(szUserName)) == 0);
    
    SysFreeString(Originator);
    
    // Get the machine IP address of the originator.
    BSTR MachineAddress = NULL;
    hr = pITSdp->get_MachineAddress(&MachineAddress);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "cant' get MachineAddress. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "MachineAddress: %ws", MachineAddress));

    DWORD dwIP = FindInterfaceByName(MachineAddress);

    SysFreeString(MachineAddress);

    *pdwIP = dwIP;

    LOG((MSP_INFO, "Interface to use:%x", *pdwIP));
    
    return S_OK;
}


HRESULT GetAddress(
    IN      IUnknown *          pIUnknown, 
    OUT     DWORD *             pdwAddress, 
    OUT     DWORD *             pdwTTL,
    OUT     BSTR *              ppKey,
    OUT     LONG *              plBandwidth,
    OUT     LONG *              plConfBandwidth = NULL
    )
/*++

Routine Description:

    Get the IP address and TTL value from a connection. It is a "c=" line
    in the SDP blob.

Arguments:
    
    pIUnknow    - an object that might contain connection information.

    pdwAddress  - the mem address to store the IP address.

    pdwTTL      - the mem address to store the TTL value.

    plBandwidth - maximum bandwidth
Return Value:

    HRESULT.

--*/
{
    // query for the ITConnection i/f
    CComPtr<ITConnection> pITConnection;
    HRESULT hr = pIUnknown->QueryInterface(__uuidof(ITConnection), (void **)&pITConnection);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get connection interface. %x", hr));
        return hr;
    }

    // clear 
    if (plConfBandwidth != NULL) *plConfBandwidth = QCDEFAULT_QUALITY_UNSET;

    // get bandwidth
    const WCHAR * const AS = L"AS";
    const WCHAR * const CT = L"CT";
    BSTR pModifier = NULL;
    DOUBLE bandwidth;

    if (FAILED (hr = pITConnection->get_BandwidthModifier (&pModifier)))
    {
        *plBandwidth = QCDEFAULT_QUALITY_UNSET;
        // bandwidth modifier may not be presented
        // LOG ((MSP_TRACE, "get bandwidth modifiler. %x", hr));
    }
    else if (_wcsnicmp (AS, pModifier, lstrlenW (AS)) != 0)
    {
        // if not application specific
        *plBandwidth = QCDEFAULT_QUALITY_UNSET;

        // check conference-wide bandwidth limit
        if (_wcsnicmp (CT, pModifier, lstrlenW (CT)) == 0)
        {
            if (plConfBandwidth)
            {
                if (FAILED (hr = pITConnection->get_Bandwidth (&bandwidth)))
                {
                    *plConfBandwidth = QCDEFAULT_QUALITY_UNSET;
                    LOG ((MSP_ERROR, "get conf bandwidth. %x", hr));
                }
                else
                    *plConfBandwidth = (LONG)(bandwidth * 1000);
            }
        }

    }
    else if (FAILED (hr = pITConnection->get_Bandwidth (&bandwidth)))
    {
        *plBandwidth = QCDEFAULT_QUALITY_UNSET;
        LOG ((MSP_ERROR, "get bandwidth. %x", hr));
    }
    else
        *plBandwidth = (LONG)(bandwidth * 1000);

    if (pModifier)
    {
        SysFreeString (pModifier);
        pModifier = NULL;
    }

    // get the start address,
    BSTR StartAddress = NULL;
    hr = pITConnection->get_StartAddress(&StartAddress);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, "get start address. %x", hr));
        return hr;
    }
    
    // Get the IP address from the string.
    const DWORD MAXIPADDRLEN = 20;
    char Buffer[MAXIPADDRLEN+1];

    // first convert the string to ascii.
    Buffer[0] = '\0';
    if (!WideCharToMultiByte(
        CP_ACP, 
        0, 
        StartAddress, 
        -1, 
        Buffer, 
        MAXIPADDRLEN, 
        NULL, 
        NULL
        ))
    {
        LOG((MSP_ERROR, "converting address. %ws", StartAddress));
        SysFreeString(StartAddress);
        return E_UNEXPECTED;
    }

    SysFreeString(StartAddress);

    // convert the string to DWORD IP address.
    DWORD dwIP = ntohl(inet_addr(Buffer));
    if (dwIP == INADDR_NONE)
    {
        LOG((MSP_ERROR, "invalid IP address. %s", Buffer));
        return E_UNEXPECTED;
    }

    // get the TTL value.
    BYTE Ttl;
    hr = pITConnection->get_Ttl(&Ttl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get TTL."));
        return hr;
    }

    // get the Encryption key.
    const WCHAR * const CLEAR = L"clear";
    VARIANT_BOOL fKeyValid;
    BSTR bstrKeyType = NULL;

    if (*ppKey)
        SysFreeString (*ppKey);

    *ppKey = NULL;

    if (FAILED (hr = pITConnection->GetEncryptionKey (&bstrKeyType, &fKeyValid, ppKey)))
    {
        LOG((MSP_WARN, "can't get EncryptionKey. %x", hr));
    }
    else if (_wcsnicmp (CLEAR, bstrKeyType, lstrlenW (CLEAR)) != 0)
    {
        if (*ppKey)
        {
            SysFreeString (*ppKey);
            *ppKey = NULL;
        }
    }

    if (bstrKeyType)
        SysFreeString (bstrKeyType);

    *pdwAddress = dwIP;
    *pdwTTL     = Ttl;

    return S_OK;
}

HRESULT CheckAttributes(
    IN      IUnknown *  pIUnknown,
    OUT     BOOL *      pbSendOnly,
    OUT     BOOL *      pbRecvOnly,
    OUT     DWORD *     pdwMSPerPacket,
    OUT     BOOL *      pbCIF
    )
/*++

Routine Description:

    Check the direction of the media, find out if it is send only or 
    receive only.

Arguments:
    
    pIUnknow    - an object that might have a attribute list.

    pbSendOnly   - the mem address to store the returned BOOL.

    pbRecvOnly   - the mem address to store the returned BOOL.

    pbCIF        - if CIF is used for video. 
    
Return Value:

    HRESULT.

--*/
{
    // query for the ITAttributeList i/f
    CComPtr<ITAttributeList> pIAttList;
    HRESULT hr = pIUnknown->QueryInterface(__uuidof(ITAttributeList), (void **)&pIAttList);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get attribute interface. %x", hr));
        return hr;
    }

    // get the number of attributes
    long lCount;
    hr = pIAttList->get_Count(&lCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get attribute count. %x", hr));
        return hr;
    }

    *pbRecvOnly = FALSE;
    *pbSendOnly = FALSE;
    *pdwMSPerPacket = 0;
    *pbCIF      = FALSE;

    const WCHAR * const SENDONLY = L"sendonly";
    const WCHAR * const RECVONLY = L"recvonly";
    const WCHAR * const FORMAT  = L"fmtp";
    const WCHAR * const PTIME  = L"ptime:";
    const WCHAR * const CIF  = L" CIF=";

    for (long i = 1; i <= lCount; i ++)
    {

        // get the attributes and check if sendonly of recvonly is specified.
        BSTR Attribute = NULL;
        hr = pIAttList->get_Item(i, &Attribute);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get attribute item. %x", hr));
            return hr;
        }
        
        if (_wcsnicmp(SENDONLY, Attribute, lstrlen(SENDONLY)) == 0)
        {
            *pbSendOnly = TRUE;
        }
        else if (_wcsnicmp(RECVONLY, Attribute, lstrlen(RECVONLY)) == 0)
        {
            *pbRecvOnly = TRUE;
        }
        else if (_wcsnicmp(PTIME, Attribute, lstrlen(PTIME)) == 0)
        {
            // read the number of milliseconds per packet.
            *pdwMSPerPacket = (DWORD)_wtol(Attribute + lstrlen(PTIME));

            // RFC 1890 only requires an app to support 200ms packets.
            if (*pdwMSPerPacket > 200)
            {
                // invalid tag, we just use our default.
                *pdwMSPerPacket = 0;
            }

        }
        else if (_wcsnicmp(FORMAT, Attribute, lstrlen(FORMAT)) == 0)
        {
            if (wcsstr(Attribute, CIF))
            {
                *pbCIF = TRUE;
            }
        }

        SysFreeString(Attribute);
    }
    
    return S_OK;
}

HRESULT CIPConfMSPCall::ProcessMediaItem(
    IN      ITMedia *           pITMedia,
    IN      DWORD               dwMediaTypeMask,
    OUT     DWORD *             pdwMediaType,
    OUT     WORD *              pwPort,
    OUT     DWORD *             pdwPayloadTypes,
    IN OUT  DWORD *             pdwNumPayLoadType
    )
/*++

Routine Description:

    Process a "m=" line, find out the media type, port, and payload type.

Arguments:

    dwMediaTypeMask - the media type of this call.

    pdwMediaType    - return the media type of this media item.

    pwPort          - return the port number used for this media.

    pdwPayloadType  - an array to store the RTP payload types. 
    
    pdwNumPayLoadType -  The size of the above array. When return, it is the
        number of payload types read.

Return Value:

    HRESULT.

    S_FALSE - everything is all right but the media type is not needed.

--*/
{
    // get the name of the media.
    BSTR MediaName = NULL;
    HRESULT hr = pITMedia->get_MediaName(&MediaName);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get media name. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "media name: %ws", MediaName));

    // check if the media is audio or video.
    const WCHAR * const AUDIO = L"audio";
    const WCHAR * const VIDEO = L"video";
    const DWORD NAMELEN = 5;

    DWORD dwMediaType = 0;
    if (_wcsnicmp(AUDIO, MediaName, NAMELEN) == 0)
    {
        dwMediaType = TAPIMEDIATYPE_AUDIO;
    }
    else if (_wcsnicmp(VIDEO, MediaName, NAMELEN) == 0)
    {
        dwMediaType = TAPIMEDIATYPE_VIDEO;
    }

    SysFreeString(MediaName);

    // check if the call wants this media type.
    if ((dwMediaType & dwMediaTypeMask) == 0)
    {
        // We don't need this media type in this call.
        LOG((MSP_INFO, "media skipped."));
        return S_FALSE;
    }

    // get start port
    long  lStartPort;
    hr = pITMedia->get_StartPort(&lStartPort);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get start port. %x", hr));
        return hr;
    }

    // get the transport Protocol
    BSTR TransportProtocol = NULL;
    hr = pITMedia->get_TransportProtocol(&TransportProtocol);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get transport Protocol. %x", hr));
        return hr;
    }

    // varify that the protocol is RTP.
    const WCHAR * const RTP = L"RTP";
    const DWORD PROTOCOLLEN = 3;

    if (_wcsnicmp(RTP, TransportProtocol, PROTOCOLLEN) != 0)
    {
        LOG((MSP_ERROR, "wrong transport Protocol:%ws", TransportProtocol));
        SysFreeString(TransportProtocol);
        return S_FALSE;
    }

    SysFreeString(TransportProtocol);

    // get the format code list
    VARIANT Variant;
    VariantInit(&Variant);

    hr = pITMedia->get_FormatCodes(&Variant);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get format codes. %x", hr));
        return hr;
    }

    // Verify that the SafeArray is in proper shape.
    if(SafeArrayGetDim(V_ARRAY(&Variant)) != 1)
    {
        LOG((MSP_ERROR, "wrong dimension for the format code. %x", hr));
	    VariantClear(&Variant);
        return E_UNEXPECTED;
    }

    long lLowerBound;
    long lUpperBound;
    if (FAILED(hr = SafeArrayGetLBound(V_ARRAY(&Variant), 1, &lLowerBound))
     || FAILED(hr = SafeArrayGetUBound(V_ARRAY(&Variant), 1, &lUpperBound)))
    {
        LOG((MSP_ERROR, "Can't get the array bounds. %x", hr));
	    VariantClear(&Variant);
        return E_UNEXPECTED;
    }

    DWORD dwNumFormats = 0;
    for (long l = lLowerBound; l <= lUpperBound && dwNumFormats < *pdwNumPayLoadType; l ++)
    {
        BSTR Format = NULL;
        hr = SafeArrayGetElement(V_ARRAY(&Variant), &l, &Format);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get format code. %x", hr));
            continue;
        }

        LOG((MSP_INFO, "format code: %ws", Format));
        
        pdwPayloadTypes[dwNumFormats ++] = (DWORD)_wtoi(Format);

        SysFreeString(Format);
    }

    // clear the variant because we don't need it any more
    VariantClear(&Variant);


    *pdwMediaType   = dwMediaType;
    *pwPort         = (WORD)lStartPort;
    *pdwNumPayLoadType = dwNumFormats;

    return S_OK;
}

HRESULT CIPConfMSPCall::ConfigStreamsBasedOnSDP(
    IN  ITSdp *     pITSdp,
    IN  DWORD       dwAudioQOSLevel,
    IN  DWORD       dwVideoQOSLevel
    )
/*++

Routine Description:

    Configure the streams based on the information in the SDP blob.

Arguments:

    pITSdp  - the SDP object. It contains parsed information.

Return Value:

    HRESULT.

--*/
{
    // find out if the current user is the originator of the conference.
    BOOL fIsOriginator;
    DWORD dwLocalInterface = INADDR_NONE;

    HRESULT hr = CheckOrigin(pITSdp, &fIsOriginator, &dwLocalInterface);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "check origin. %x", hr));
        return hr;
    }
    
    LOG((MSP_INFO, "Local interface: %x", dwLocalInterface));

    // get the start IP address and TTL value from the connection.
    DWORD dwIPGlobal, dwTTLGlobal;
    BSTR bstrKeyGlobal = NULL;
    LONG lbandwidth, lConfBandwidth;
    hr = GetAddress(pITSdp, &dwIPGlobal, &dwTTLGlobal, &bstrKeyGlobal, &lbandwidth, &lConfBandwidth);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get global address. %x", hr));
        return hr;
    }

    CLock lock(m_lock);

    // store conference bandwidth
    if (FAILED (m_pCallQCRelay->SetConfBitrate (lConfBandwidth)))
    {
        LOG ((MSP_ERROR, "bandwidth is out of range %d", lConfBandwidth));
    }

    // find out if this conference is sendonly or recvonly.
    BOOL fSendOnlyGlobal = FALSE, fRecvOnlyGlobal = FALSE, fCIF = FALSE;
    DWORD dwMSPerPacket;
    hr = CheckAttributes(
        pITSdp, &fSendOnlyGlobal, &fRecvOnlyGlobal, &dwMSPerPacket, &fCIF);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "check global attributes. %x", hr));
        return hr;
    }

    // get the media information
    CComPtr<ITMediaCollection> pICollection;
    hr = pITSdp->get_MediaCollection(&pICollection);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get the media collection. %x", hr));
        return hr;
    }

    // find out how many media sessions are in the blobl.
    long lCount;
    hr = pICollection->get_Count(&lCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get number of media items. %x", hr));
        return hr;
    }

    if (lCount > 0)
    {
        // change the call into connected state since the SDP is OK.
        // We are going to set up each every streams next.
        SendTSPMessage(CALL_CONNECTED, 0);
    }

    DWORD dwNumSucceeded = 0;

    // for each media session, get info configure a stream.
    for(long i=1; i <= lCount; i++)
    {
        // get the media item first.
        ITMedia *pITMedia;
        hr = pICollection->get_Item(i, &pITMedia);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get media item. %x", hr));
            continue;
        }

        DWORD dwMediaType;
        STREAMSETTINGS Setting;

        ZeroMemory(&Setting, sizeof(STREAMSETTINGS));

        // find out the information about the media. Here we pass in the media
        // type of call so that we won't wasting time reading the attributes
        // for a media type we don't need.
        DWORD dwNumPayloadTypes = sizeof(Setting.PayloadTypes) 
            / sizeof(Setting.PayloadTypes[0]);

        hr = ProcessMediaItem(
            pITMedia,
            m_dwMediaType,
            &dwMediaType,
            &Setting.wRTPPortRemote,
            Setting.PayloadTypes,
            &dwNumPayloadTypes
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "process media. %x", hr));
            continue;
        }
        
        Setting.dwNumPayloadTypes = dwNumPayloadTypes;

        // if the return value is S_FALSE from the previous call, this media
        // type is not needed for the call.
        if (hr != S_OK)
        {
            // the media is not needed.
            continue;
        }
        
        if (dwMediaType == TAPIMEDIATYPE_AUDIO)
        {
            Setting.dwQOSLevel = dwAudioQOSLevel;
            Setting.phRTPSession = &m_hAudioRTPSession;
        }
        else
        {
            Setting.dwQOSLevel = dwVideoQOSLevel;
            Setting.phRTPSession = &m_hVideoRTPSession;
        }

        // Get the local connect information.
        DWORD dwIP, dwTTL;
        BSTR bstrKey = NULL;

        hr = GetAddress(pITMedia, &dwIP, &dwTTL, &bstrKey, &lbandwidth);
        if (FAILED(hr))
        {
            LOG((MSP_WARN, "no local address, use global one", hr));
            Setting.dwIPRemote  = dwIPGlobal;
            Setting.dwTTL       = dwTTLGlobal;
            Setting.lBandwidth = QCDEFAULT_QUALITY_UNSET;
        }
        else
        {
            Setting.dwIPRemote  = dwIP;
            Setting.dwTTL       = dwTTL;
            Setting.lBandwidth = lbandwidth;
        }

        // find out if this media is sendonly or recvonly.
        BOOL fSendOnly = FALSE, fRecvOnly = FALSE, fCIF = FALSE;
        hr = CheckAttributes(
            pITMedia, &fSendOnly, &fRecvOnly, &dwMSPerPacket, &fCIF);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "check local attributes. %x", hr));
        }
        
        fSendOnly = fSendOnly || fSendOnlyGlobal;
        fRecvOnly = (fRecvOnly || fRecvOnlyGlobal) && (!fIsOriginator);
        Setting.dwMSPerPacket = dwMSPerPacket;
        Setting.fCIF = fCIF;

        // The media item is not needed after this point.
        pITMedia->Release();

        // Go through the existing streams and find out if any stream
        // can be configured.

        // Note: we are not creating any new streams now. We might want to 
        // do it in the future if we want to support two sessions of the
        // same media type.

        m_fCallStarted = TRUE;

        for (long j = 0; j < m_Streams.GetSize(); j ++)
        {
            CIPConfMSPStream* pStream = (CIPConfMSPStream*)m_Streams[j];
        
            if ((pStream->MediaType() != dwMediaType)
                || pStream->IsConfigured()
                || (fSendOnly && pStream->Direction() == TD_RENDER)
                || (fRecvOnly && pStream->Direction() == TD_CAPTURE)
                )
            {
                // this stream should not be configured.
                continue;
            }

            // set the local interface that the call should bind to.
            Setting.dwIPLocal = m_dwIPInterface;

            if ((m_dwIPInterface == INADDR_ANY)
                && (dwLocalInterface != INADDR_NONE))
            {
                Setting.dwIPLocal = dwLocalInterface;
            }

            // set the loopback mode of the stream.
            Setting.LoopbackMode = m_LoopbackMode;

            // set the qos application IDS.
            Setting.pApplicationID = m_pApplicationID;
            Setting.pApplicationGUID = m_pApplicationGUID;
            Setting.pSubIDs = m_pSubIDs;

            // configure the stream, it will not be started.
            hr = pStream->Configure(Setting, (bstrKey) ? bstrKey : bstrKeyGlobal);
            if (FAILED(hr))
            {
               LOG((MSP_ERROR, "configure stream failed. %x", hr));
            }
        }

        SysFreeString(bstrKey);
    }

    SysFreeString(bstrKeyGlobal);

    // after configuring the streams, start them.
    for (int j = 0; j < m_Streams.GetSize(); j ++)
    {
        CIPConfMSPStream* pStream = (CIPConfMSPStream*)m_Streams[j];

        // start the stream.
        hr = pStream->FinishConfigure();
        if (SUCCEEDED(hr))
        {
            dwNumSucceeded ++;
        }
    }

    if (dwNumSucceeded == 0)
    {
        LOG((MSP_ERROR, "No media succeeded."));
        return E_FAIL;
    }

    return S_OK;        
}

HRESULT CIPConfMSPCall::ParseSDP(
    IN  WCHAR * pSDP,
    IN  DWORD dwAudioQOSLevel,
    IN  DWORD dwVideoQOSLevel
    )
/*++

Routine Description:

    Parse the SDP string. The function uses the SdpConferenceBlob object
    to parse the string.

Arguments:

    pSDP  - the SDP string.
    dwAudioQOSLevel - the QOS requirement for audio.
    dwVideoQOSLevel - the QOS requirement for video.

Return Value:

    HRESULT.

--*/
{
    // co-create an sdp conference blob component
    // query for the ITConferenceBlob interface
    CComPtr<ITConferenceBlob>   pIConfBlob;   

    HRESULT hr = ::CoCreateInstance(
        CLSID_SdpConferenceBlob,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(ITConferenceBlob),
        (void **)&pIConfBlob
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "creating a SDPBlob object. %x", hr));
        return hr;
    }
    
    // conver the sdp into a BSTR to use the interface.
    BSTR bstrSDP = SysAllocString(pSDP);
    if (bstrSDP == NULL)
    {
        LOG((MSP_ERROR, "out of mem converting SDP to a BSTR."));
        return E_OUTOFMEMORY;
    }

    // Parse the SDP string.
    hr = pIConfBlob->Init(NULL, BCS_ASCII, bstrSDP);
    
    // the string is not needed any more.
    SysFreeString(bstrSDP);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "parse the SDPBlob object. %x", hr));
        return hr;
    }
    
    // Get the ITSdp interface.
    CComPtr<ITSdp>  pITSdp;
    hr = pIConfBlob->QueryInterface(__uuidof(ITSdp), (void **)&pITSdp);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get the ITSdp interface. %x", hr));
        return hr;
    }

    // check main sdp validity
    VARIANT_BOOL IsValid;
    hr = pITSdp->get_IsValid(&IsValid);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get the valid flag on the SDP %x", hr));
        return hr;
    }

    if (!IsValid)
    {
        LOG((MSP_ERROR, "the SDP is not valid %x", hr));
        return E_FAIL;
    }

    return ConfigStreamsBasedOnSDP(
        pITSdp,
        dwAudioQOSLevel,
        dwVideoQOSLevel
        );
}

HRESULT CIPConfMSPCall::SendTSPMessage(
    IN  TSP_MSP_COMMAND command,
    IN  DWORD           dwParam1,
    IN  DWORD           dwParam2
    ) const
/*++

Routine Description:

    Send the TSP a message from the MSP. 

Arguments:

    command     - the command to be sent.

    dwParam1    - the first DWORD used in the command.

    dwParam2    - the second DWORD used in the command.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "SendTSPMessage, command %d, dwParam1 %d, dwParam2", 
        command, dwParam1, dwParam2));

    // first allocate the memory.

    MSPEVENTITEM* pEventItem = AllocateEventItem(sizeof(MSG_TSPMSPDATA));

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data"));
        return E_OUTOFMEMORY;
    }
    
    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = 
        sizeof(MSP_EVENT_INFO) + sizeof(MSG_TSPMSPDATA);
    pEventItem->MSPEventInfo.Event  = ME_TSP_DATA;
    pEventItem->MSPEventInfo.hCall  = m_htCall;

    // Fill in the data for the TSP.
    pEventItem->MSPEventInfo.MSP_TSP_DATA.dwBufferSize = sizeof(MSG_TSPMSPDATA);

    MSG_TSPMSPDATA *pData = (MSG_TSPMSPDATA *)
        pEventItem->MSPEventInfo.MSP_TSP_DATA.pBuffer;

    pData->command = command;
    switch (command)
    {

    case CALL_DISCONNECTED:
        pData->CallDisconnected.dwReason = dwParam1;
        break;

    case CALL_QOS_EVENT:
        pData->QosEvent.dwEvent = dwParam1;
        pData->QosEvent.dwMediaMode = dwParam2;
        break;

    case CALL_CONNECTED:
        break;

	default:
		
		LOG((MSP_ERROR, "Wrong command type for TSP"));

        FreeEventItem(pEventItem);
		return E_UNEXPECTED;
    }

    HRESULT hr = m_pMSPAddress->PostEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));

        FreeEventItem(pEventItem);

        return hr;
    }
    return S_OK;
}

HRESULT CIPConfMSPCall::CheckUnusedStreams()
/*++

Routine Description:

    Find out which streams are not used and send tapi events about them.

Arguments:

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CheckUnusedStreams"));

    CLock lock(m_lock);
    for (long j = 0; j < m_Streams.GetSize(); j ++)
    {
        CIPConfMSPStream* pStream = (CIPConfMSPStream*)m_Streams[j];
    
        if (pStream->IsConfigured())
        {
            // find the next.
            continue;
        }
        
        MSPEVENTITEM* pEventItem = AllocateEventItem();

        if (pEventItem == NULL)
        {
            LOG((MSP_ERROR, "No memory for the TSPMSP data"));

            return E_OUTOFMEMORY;
        }
    
        // Fill in the necessary fields for the event structure.
        pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);;
        pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;
        pEventItem->MSPEventInfo.hCall  = m_htCall;
    
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type = CALL_STREAM_NOT_USED;
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause = CALL_CAUSE_REMOTE_REQUEST;
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream = m_Streams[j];
        
        // Addref to prevent it from going away.
        m_Streams[j]->AddRef();

        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = NULL;
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError= 0;

        // send the event to tapi.
        HRESULT hr = m_pMSPAddress->PostEvent(pEventItem);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Post event failed %x", hr));
        
            FreeEventItem(pEventItem);
            return hr;
        }
    }
    return S_OK;
}

DWORD WINAPI CIPConfMSPCall::WorkerCallbackDispatcher(VOID *pContext)
/*++

Routine Description:

    Because Parsing the SDP and configure the streams uses a lot of COM
    stuff, we can't rely on the RPC thread the calls into the MSP to 
    receive the TSP data. So, we let our own working thread do the work.
    This method is the callback function for the queued work item. It 
    just gets the call object from the context structure and calls a method
    on the call object to handle the work item.

Arguments:

    pContext - A pointer to a CALLWORKITEM structure.

Return Value:

    HRESULT.

--*/
{
    _ASSERTE(!IsBadReadPtr(pContext, sizeof CALLWORKITEM));

    CALLWORKITEM *pItem = (CALLWORKITEM *)pContext;
    
    pItem->pCall->ProcessWorkerCallBack(pItem->Buffer, pItem->dwLen);
    pItem->pCall->MSPCallRelease();

    free(pItem);

    return NOERROR;
}

DWORD CIPConfMSPCall::ProcessWorkerCallBack(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
/*++

Routine Description:

    This function handles the work item given by the TSP. 

Arguments:

    pBuffer - a buffer that contains a TSP_MSP command block.

    dwSize  - the size of the buffer.

Return Value:

    NOERROR.

--*/
{
    LOG((MSP_TRACE, "PreocessWorkerCallBAck"));

    _ASSERTE(!IsBadReadPtr(pBuffer, dwSize));

    MSG_TSPMSPDATA * pData = (MSG_TSPMSPDATA *)pBuffer;

    HRESULT hr;

    switch (pData->command)
    {
    case CALL_START:

        // Parse the SDP contained in the command block.
        hr = ParseSDP(pData->CallStart.szSDP, 
            pData->CallStart.dwAudioQOSLevel,
            pData->CallStart.dwVideoQOSLevel
            );

        if (FAILED(hr))
        {
            // disconnect the call if someting terrible happend.
            SendTSPMessage(CALL_DISCONNECTED, 0);

            LOG((MSP_ERROR, "parsing theSDPBlob object. %x", hr));
            return NOERROR;
        }

        // go through the streams and send events if they are not used.
        hr = CheckUnusedStreams();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "start the streams failed. %x", hr));
        }
        break;

    case CALL_STOP:
        InternalShutDown();
        break;
    }

    return NOERROR;
}

HRESULT CIPConfMSPCall::ReceiveTSPCallData(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
/*++

Routine Description:

    This function handles the work item given by the TSP. 

Arguments:

    pBuffer - a buffer that contains a TSP_MSP command block.

    dwSize  - the size of the buffer.

Return Value:

    NOERROR.

--*/
{
    LOG((MSP_TRACE, 
        "ReceiveTSPCallData, pBuffer %x, dwSize %d", pBuffer, dwSize));

    MSG_TSPMSPDATA * pData = (MSG_TSPMSPDATA *)pBuffer;
    switch (pData->command)
    {
    case CALL_START:

        // make sure the string is valid.
        if ((IsBadReadPtr(pData->CallStart.szSDP, 
            (pData->CallStart.dwSDPLen + 1) * sizeof (WCHAR)))
            || (pData->CallStart.szSDP[pData->CallStart.dwSDPLen] != 0))
        {
            LOG((MSP_ERROR, "the TSP data is invalid."));
            return E_UNEXPECTED;
        }

        LOG((MSP_INFO, "SDP string\n%ws", pData->CallStart.szSDP));

        break;

    case CALL_STOP:
        break;

    default:
        LOG((MSP_ERROR, 
            "wrong command received from the TSP:%x", pData->command));
        return E_UNEXPECTED; 
    }

    // allocate a work item structure for our worker thread.
    CALLWORKITEM *pItem = (CALLWORKITEM *)malloc(sizeof(CALLWORKITEM) + dwSize);

    if (pItem == NULL)
    {
        // Disconnect the call because of out of memory.
        SendTSPMessage(CALL_DISCONNECTED, 0);

        LOG((MSP_ERROR, "out of memory for work item."));
        return E_OUTOFMEMORY;
    }

    this->MSPCallAddRef();
    pItem->pCall = this;
    pItem->dwLen = dwSize;
    CopyMemory(pItem->Buffer, pBuffer, dwSize);
    
    // post a work item to our worker thread.
    HRESULT hr = g_Thread.QueueWorkItem(
        WorkerCallbackDispatcher,           // the callback
        pItem,                              // the context.
        FALSE                               // sync (FALSE means asyn)
        );

    if (FAILED(hr))
    {
        if (pData->command == CALL_START)
        {
            // Disconnect the call because we can't handle the work.
            SendTSPMessage(CALL_DISCONNECTED, 0);
        }

        this->MSPCallRelease();
        free(pItem);

        LOG((MSP_ERROR, "queue work item failed."));
    }

    return hr;
}


STDMETHODIMP CIPConfMSPCall::EnumerateParticipants(
    OUT     IEnumParticipant **      ppEnumParticipant
    )
/*++

Routine Description:

    This method returns an enumerator to the participants. 

Arguments:
    ppEnumParticipant - the memory location to store the returned pointer.
  
Return Value:

S_OK
E_POINTER
E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, 
        "EnumerateParticipants entered. ppEnumParticipant:%p", ppEnumParticipant));

    //
    // Check parameters.
    //

    if (IsBadWritePtr(ppEnumParticipant, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::EnumerateParticipants - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the Participant object list.
    //

    CLock lock(m_ParticipantLock);

    if (m_Participants.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::EnumerateParticipants - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //
    HRESULT hr = CreateParticipantEnumerator(
        m_Participants.GetData(),                        // the begin itor
        m_Participants.GetData() + m_Participants.GetSize(),  // the end itor,
        ppEnumParticipant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::EnumerateParticipants - "
            "create enumerator object failed, %x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CIPConfMSPCall::EnumerateParticipants - exit S_OK"));

    return hr;
}

STDMETHODIMP CIPConfMSPCall::get_Participants(
    OUT     VARIANT *              pVariant
    )
{
    LOG((MSP_TRACE, "CIPConfMSPCall::get_Participants - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::get_Participants - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the Participant object list.
    //

    CLock lock(m_ParticipantLock);

    if (m_Participants.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::get_Participants - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //
    HRESULT hr = CreateParticipantCollection(
        m_Participants.GetData(),                        // the begin itor
        m_Participants.GetData() + m_Participants.GetSize(),  // the end itor,
        m_Participants.GetSize(),                        // the size
        pVariant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::get_Participants - "
            "create collection failed - exit 0x%08x", hr));
        
        return hr;
    }

    LOG((MSP_TRACE, "CIPConfMSPCall::get_Participants - exit S_OK"));
 
    return S_OK;
}

// IMulticastControl methods
STDMETHODIMP CIPConfMSPCall::get_LoopbackMode (
    OUT MULTICAST_LOOPBACK_MODE * pMode
    )
{
    if (pMode == NULL)
    {
        return E_INVALIDARG;
    }

    *pMode = m_LoopbackMode;

    return S_OK;
}
    
STDMETHODIMP CIPConfMSPCall::put_LoopbackMode (
    IN MULTICAST_LOOPBACK_MODE mode
    )
{
    if (mode < MM_NO_LOOPBACK || mode > MM_SELECTIVE_LOOPBACK)
    {
        return E_INVALIDARG;
    }

    m_LoopbackMode = mode;

    return S_OK;
}

// ITLocalParticipant methods, called by the app.
STDMETHODIMP CIPConfMSPCall::get_LocalParticipantTypedInfo(
    IN  PARTICIPANT_TYPED_INFO  InfoType,
    OUT BSTR *                  ppInfo
    )
/*++

Routine Description:

    Get a information item for the local participant. This information is
    sent out to other participants in the conference.

Arguments:
    
    InfoType - The type of the information asked.

    ppInfo  - the mem address to store a BSTR.

Return Value:

    S_OK,
    E_INVALIDARG,
    E_POINTER,
    E_OUTOFMEMORY,
    TAPI_E_NOITEMS
*/
{
    LOG((MSP_TRACE, "CParticipant get info, type:%d", InfoType));
    
    if (InfoType > PTI_PRIVATE || InfoType < PTI_CANONICALNAME)
    {
        LOG((MSP_ERROR, "CParticipant get info - invalid type:%d", InfoType));
        return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppInfo, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CParticipant get info - exit E_POINTER"));
        return E_POINTER;
    }

    // check if we have that info.
    CLock lock(m_lock);
    
    if (!m_fLocalInfoRetrieved)
    {
        HRESULT hr = InitializeLocalParticipant();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    int index = (int)InfoType; 
    if (m_InfoItems[index] == NULL)
    {
        LOG((MSP_INFO, "no local participant info item for %d", InfoType));
        return TAPI_E_NOITEMS;
    }

    // make a BSTR out of it.
    BSTR pName = SysAllocString(m_InfoItems[index]);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CParticipant get info - exit out of mem"));
        return E_POINTER;
    }

    // return the BSTR.
    *ppInfo = pName;

    return S_OK; 
}

// ITLocalParticipant methods, called by the app.
STDMETHODIMP CIPConfMSPCall::put_LocalParticipantTypedInfo(
    IN  PARTICIPANT_TYPED_INFO  InfoType,
    IN  BSTR                    pInfo
    )
/*++

Routine Description:

    Set a information item for the local participant. This information is
    sent out to other participants in the conference.

Arguments:
    
    InfoType - The type of the information item.

    pInfo  - the information item.

Return Value:

    S_OK,
    E_INVALIDARG,
    E_POINTER,
    E_OUTOFMEMORY,
    TAPI_E_NOITEMS
*/
{
    LOG((MSP_TRACE, "set local info, type:%d", InfoType));
    
    if (InfoType > PTI_PRIVATE || InfoType < PTI_CANONICALNAME)
    {
        LOG((MSP_ERROR, "set local info - invalid type:%d", InfoType));
        return E_INVALIDARG;
    }

    if (IsBadStringPtr(pInfo, MAX_PARTICIPANT_TYPED_INFO_LENGTH))
    {
        LOG((MSP_ERROR, "set local info, bad ptr:%p", pInfo));
        return E_POINTER;
    }

    DWORD dwStringLen = lstrlenW(pInfo);
    if (dwStringLen > MAX_PARTICIPANT_TYPED_INFO_LENGTH)
    {
        LOG((MSP_ERROR, "local info too long"));
        return E_INVALIDARG;
    }

    // check if we have that info.
    CLock lock(m_lock);

    if (m_fCallStarted)
    {
        return TAPI_E_INVALCALLSTATE;
    }
    
    if (!m_fLocalInfoRetrieved)
    {
        HRESULT hr = InitializeLocalParticipant();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    int index = (int)InfoType; 
    if (m_InfoItems[index] != NULL)
    {
        if (lstrcmpW(m_InfoItems[index], pInfo) == 0)
        {
            // The info is the same as what we are using.
            return S_OK;
        }

		// the infomation is different, release the old info.
		free(m_InfoItems[index]);
		m_InfoItems[index] = NULL;
    }

	// save the info.
    m_InfoItems[index] = (WCHAR *)malloc((dwStringLen + 1)* sizeof(WCHAR));
    if (m_InfoItems[index] == NULL)
    {
        LOG((MSP_ERROR, "out of mem for local info"));

        return E_OUTOFMEMORY;
    }

    lstrcpynW(m_InfoItems[index], pInfo, dwStringLen + 1);

    //
    // The info is new, we need to set it on the streams.
    //

    for (int i = 0; i < m_Streams.GetSize(); i ++)
    {
        ((CIPConfMSPStream*)m_Streams[i])->SetLocalParticipantInfo(
            InfoType,
            m_InfoItems[index],
            dwStringLen
            );
    }

    return S_OK; 
}

STDMETHODIMP CIPConfMSPCall::SetQOSApplicationID (
    IN  BSTR pApplicationID,
    IN  BSTR pApplicationGUID,
    IN  BSTR pSubIDs
    )
/*++

Routine Description:
    
    This method is called by the App to set the QOS specific application ID.
    It can only be called before the call is connected.

Arguments:

    pApplicationID - the Application ID.

    pSubIDs - the SubIDs that will be appended to the end of policy locator.

Return Value:

S_OK
E_OUTOFMEMORY

--*/
{
    CLock lock(m_lock);

    if (m_fCallStarted)
    {
        return TAPI_E_INVALCALLSTATE;
    }

    if (pSubIDs!=NULL && lstrlenW(pSubIDs)>MAX_QOS_ID_LEN)
    {
        return E_INVALIDARG;
    }

    if (pApplicationID!=NULL && lstrlenW(pApplicationID)>MAX_QOS_ID_LEN)
    {
        return E_INVALIDARG;
    }

    try
    {
        if (m_pApplicationID) SysFreeString(m_pApplicationID);
        m_pApplicationID = SysAllocString(pApplicationID);
    }
    catch(...)
    {
        return E_POINTER;
    }
    
    if (m_pApplicationID == NULL)
    {
        return E_OUTOFMEMORY;
    }

    try
    {
        if (m_pApplicationGUID)
        {
            SysFreeString(m_pApplicationGUID);
            m_pApplicationGUID = NULL;
        }

        if (m_pSubIDs)
        {
            SysFreeString(m_pSubIDs);
            m_pSubIDs = NULL;
        }

        if (pApplicationGUID)
        {
            m_pApplicationGUID = SysAllocString(pApplicationGUID);
        }

        if (pSubIDs)
        {
            m_pSubIDs = SysAllocString(pSubIDs);
        }
    }
    catch(...)
    {
        SysFreeString(m_pApplicationID);
        m_pApplicationID = NULL;

        if (m_pApplicationGUID)
        {
            SysFreeString(m_pApplicationGUID);
        }
        m_pApplicationGUID = NULL;

        if (m_pSubIDs)
        {
            SysFreeString(m_pSubIDs);
        }
        m_pSubIDs = NULL;

        return E_POINTER;
    }

    if ((pApplicationGUID!=NULL && m_pApplicationGUID==NULL) ||
        (pSubIDs!=NULL && m_pSubIDs==NULL))
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CIPConfMSPCall::NewParticipant(
    IN  ITStream *          pITStream,
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv,
    IN  DWORD               dwMediaType,
    IN  WCHAR *              szCName,
    OUT ITParticipant **    ppITParticipant
    )
/*++

Routine Description:
    
    This method is called by a stream object when a new participant appears.
    It looks throught the call's participant list, if the partcipant is 
    already in the list, it returns the pointer to the object. If it is not
    found, a new object will be created and added into the list.

Arguments:

    pITStream - the stream object.

    dwSSRC - the SSRC of the participant in the stream.

    dwSendRecv - a sender or a receiver.
    
    dwMediaType - the media type of the stream.

    szCName - the canonical name of the participant.

    ppITParticipant - the address to store the returned pointer.

Return Value:

S_OK
E_OUTOFMEMORY

--*/
{
    CLock lock(m_ParticipantLock);

    HRESULT hr;

    // First check to see if the participant is in our list. If he is already
    // in the list, just return the object.
    int index;
    if (m_Participants.FindByCName(szCName, &index))
    {
        hr = ((CParticipant *)m_Participants[index])->
                AddStream(pITStream, dwSSRC, dwSendRecv, dwMediaType);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can not add a stream to a participant:%x", hr));
            return hr;
        }

        *ppITParticipant = m_Participants[index];
        (*ppITParticipant)->AddRef();

        return S_OK;
    }

    // create a new participant object.
    CComObject<CParticipant> * pCOMParticipant;

    hr = ::CreateCComObjectInstance(&pCOMParticipant);

    if (NULL == pCOMParticipant)
    {
        LOG((MSP_ERROR, "can not create a new participant:%x", hr));
        return hr;
    }

    ITParticipant* pITParticipant;

    // get the interface pointer.
    hr = pCOMParticipant->_InternalQueryInterface(
        __uuidof(ITParticipant), 
        (void **)&pITParticipant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Participant QueryInterface failed: %x", hr));
        delete pCOMParticipant;
        return hr;
    }

    // Initialize the object.
    hr = pCOMParticipant->Init(
        szCName, pITStream, dwSSRC, dwSendRecv, dwMediaType
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create participant:call init failed: %x", hr));
        pITParticipant->Release();

        return hr;
    }

    // Add the Participant into our list of Participants.
    if (!m_Participants.InsertAt(index, pITParticipant))
    {
        pITParticipant->Release();

        LOG((MSP_ERROR, "out of memory in adding a Participant."));
        return E_OUTOFMEMORY;
    }

    // AddRef the interface pointer and return it.
    pITParticipant->AddRef(); 
    *ppITParticipant = pITParticipant;

    SendParticipantEvent(PE_NEW_PARTICIPANT, pITParticipant);

    return S_OK;
}

HRESULT CIPConfMSPCall::ParticipantLeft(
    IN  ITParticipant *     pITParticipant
    )
/*++

Routine Description:
    
    This method is called by a stream object when a participant left the
    conference.

Arguments:

    pITParticipant - the participant that left.

Return Value:

S_OK

--*/
{
    m_ParticipantLock.Lock();

    BOOL fRemoved = m_Participants.Remove(pITParticipant);

    m_ParticipantLock.Unlock();
    
    if (fRemoved)
    {
        SendParticipantEvent(PE_PARTICIPANT_LEAVE, pITParticipant);
        pITParticipant->Release();
    }
    else
    {
        LOG((MSP_ERROR, "can't remove Participant %p", pITParticipant));
    }

    return S_OK;
}

void CIPConfMSPCall::SendParticipantEvent(
    IN  PARTICIPANT_EVENT   Event,
    IN  ITParticipant *     pITParticipant,
    IN  ITSubStream *       pITSubStream
    ) const
/*++

Routine Description:
    
    This method is called by a stream object to send a participant related
    event to the app.

Arguments:

    Event - the event code.

    pITParticipant - the participant object.

    pITSubStream - the substream object, if any.

Return Value:

nothing.

--*/
{
    if (pITParticipant)
    {
        LOG((MSP_TRACE, "SendParticipantEvent, event %s, participant:%ws",
            ParticipantEventString[Event], 
            ((CParticipant*)pITParticipant)->Name()
            ));
    }
    else
    {
        LOG((MSP_TRACE, "SendParticipantEvent, event %s, participant: null (local)",
            ParticipantEventString[Event]
            ));
    }

    // Create a private event object.
    CComPtr<IDispatch> pEvent;
    HRESULT hr = CreateParticipantEvent(
        Event, 
        pITParticipant, 
        pITSubStream, 
        &pEvent
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create event returned: %x", hr));
        return;
    }


    MSPEVENTITEM* pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data"));

        return;
    }

    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);;
    pEventItem->MSPEventInfo.Event  = ME_PRIVATE_EVENT;
    pEventItem->MSPEventInfo.hCall  = m_htCall;
    
    pEventItem->MSPEventInfo.MSP_PRIVATE_EVENT_INFO.pEvent = pEvent;
    pEventItem->MSPEventInfo.MSP_PRIVATE_EVENT_INFO.lEventCode = Event;
    pEvent->AddRef();

    // send the event to tapi.
    hr = m_pMSPAddress->PostEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));
    
        pEvent->Release();
        FreeEventItem(pEventItem);
    }
}

VOID CIPConfMSPCall::HandleGraphEvent(
    IN  MSPSTREAMCONTEXT * pContext
    )
{
    long     lEventCode;
    LONG_PTR lParam1, lParam2; // win64 fix

    HRESULT hr = pContext->pIMediaEvent->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Can not get the actual event. %x", hr));
        return;
    }

    LOG((MSP_EVENT, "ProcessGraphEvent, code:%d param1:%x param2:%x",
        lEventCode, lParam1, lParam2));

    if (lEventCode == EC_PALETTE_CHANGED 
        || lEventCode == EC_VIDEO_SIZE_CHANGED)
    {
        LOG((MSP_EVENT, "event %d ignored", lEventCode));
        return;
    }

    //
    // Create an event data structure that we will pass to the worker thread.
    //

    MULTI_GRAPH_EVENT_DATA * pData;
    pData = new MULTI_GRAPH_EVENT_DATA;
    
    if (pData == NULL)
    {
        LOG((MSP_ERROR, "Out of memory for event data."));
        return;
    }
    
    pData->pCall      = this;
    pData->pITStream  = pContext->pITStream;
    pData->lEventCode = lEventCode;
    pData->lParam1    = lParam1;
    pData->lParam2    = lParam2;
 
     //
    // also pass an addref'ed pointer to IMediaEvent, so that whoever processes
    // the message has the opportunity to free event parameters
    //

    pData->pIMediaEvent = pContext->pIMediaEvent;
    pData->pIMediaEvent->AddRef();

   //
    // Make sure the call and stream don't go away while we handle the event.
    // but use our special inner object addref for the call
    //

    pData->pCall->MSPCallAddRef();
    pData->pITStream->AddRef();

    //
    // Queue an async work item to call ProcessGraphEvent.
    //

    hr = g_Thread.QueueWorkItem(AsyncMultiGraphEvent,
                                (void *) pData,
                                FALSE);  // asynchronous

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "QueueWorkItem failed, return code:%x", hr));

        pData->pCall->MSPCallRelease();
        pData->pITStream->Release();


        //
        // no one is going to free event params and release the IMediaEvent
        // pointer, so do it here
        //

        pContext->pIMediaEvent->FreeEventParams(lEventCode, lParam1, lParam2);
        pData->pIMediaEvent->Release();

        delete pData;
    }
}


HRESULT CIPConfMSPCall::InitFullDuplexControler()
/*++

Routine Description:

    This method creates the full-duplex controller object used to control
    audio devices.

Arguments:
    
    NONE

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPCall::InitFullDuplexControler");
    LOG((MSP_TRACE, "%s entered", __fxName));

    CLock lock(m_lock);

    if (m_pIAudioDuplexController != NULL)
    {
        return S_OK;
    }

    HRESULT hr;
    IAudioDuplexController *pIAudioDuplexController;

    if (FAILED(hr = CoCreateInstance(
            __uuidof(TAPIAudioDuplexController),
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            __uuidof(IAudioDuplexController),
            (void **) &pIAudioDuplexController
            )))
    {
        LOG((MSP_ERROR, "%s, create AudioDuplexController failed. hr=%x", 
            __fxName, hr));
        return hr;
    }
    
    m_pIAudioDuplexController = pIAudioDuplexController;

    return S_OK;
}

/*++

Routine Description:

    ITCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::GetRange (
    IN CallQualityProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
{
    return m_pCallQCRelay->GetRange (Property, plMin, plMax, plSteppingDelta, plDefault, plFlags);
}

/*++

Routine Description:

    ITCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::Get (
    IN CallQualityProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
{
    return m_pCallQCRelay->Get (Property, plValue, plFlags);
}

/*++

Routine Description:

    ITCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::Set (
    IN CallQualityProperty Property, 
    IN long lValue, 
    IN TAPIControlFlags lFlags
    )
{
    return m_pCallQCRelay->Set (Property, lValue, lFlags);
}

/*++

Routine Description:

    IInnerCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP_(ULONG)
CIPConfMSPCall::InnerCallAddRef (VOID)
{
    return this->MSPCallAddRef ();
}

STDMETHODIMP_(ULONG)
CIPConfMSPCall::InnerCallRelease (VOID)
{
    return this->MSPCallRelease ();
}

STDMETHODIMP
CIPConfMSPCall::RegisterInnerStreamQC (
    IN  IInnerStreamQualityControl *pIInnerStreamQC
    )
{
    return m_pCallQCRelay->RegisterInnerStreamQC (
        pIInnerStreamQC
        );
}

/*++

Routine Description:

    IInnerCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::DeRegisterInnerStreamQC (
    IN  IInnerStreamQualityControl *pIInnerStreamQC
    )
{
    return m_pCallQCRelay->DeRegisterInnerStreamQC (
        pIInnerStreamQC
        );
}

/*++

Routine Description:

    IInnerCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::ProcessQCEvent (
    IN  QCEvent event,
    IN  DWORD dwParam
    )
{
    return m_pCallQCRelay->ProcessQCEvent (event, dwParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confpart.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confpart.cpp

Abstract:

    This module contains implementation of the participant classes.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"
#include "confpart.h"

#ifdef DEBUG_REFCOUNT

ULONG CParticipant::InternalAddRef()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalAddRef();

    LOG((MSP_TRACE, "%p, %ws Addref, ref = %d", 
        this, (m_InfoItems[0]) ? m_InfoItems[0] : L"new participant", lRef));

    return lRef;
}

ULONG CParticipant::InternalRelease()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalRelease();
    
    LOG((MSP_TRACE, "%p, %ws Release, ref = %d", 
        this, (m_InfoItems[0]) ? m_InfoItems[0] : L"new participant", lRef));

    return lRef;
}
#endif

CParticipant::CParticipant()
    : m_pFTM(NULL),
      m_dwSendingMediaTypes(0),
      m_dwReceivingMediaTypes(0)
{
    // initialize the info item array.
    ZeroMemory(m_InfoItems, sizeof(WCHAR *) * (NUM_SDES_ITEMS));
}

// methods called by the call object.
HRESULT CParticipant::Init(
    IN  WCHAR *             szCName,
    IN  ITStream *          pITStream, 
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv,
    IN  DWORD               dwMediaType
    )
/*++

Routine Description:

    Initialize the participant object.

Arguments:
    
    szCName - the canonical name of the participant.

    pITStream - the stream that has the participant.

    dwSSRC - the SSRC of the participant in that stream.

    dwSendRecv - a sender or a receiver.

    dwMediaType - the media type of the participant.

Return Value:

    S_OK,
    E_OUTOFMEMORY.

--*/
{
    LOG((MSP_TRACE, "CParticipant::Init, name:%ws", szCName));

    // create the marshaler.
    HRESULT hr;
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pFTM);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create marshaler failed, %x", hr));
        return hr;
    }

    m_InfoItems[0] = (WCHAR *)malloc((lstrlenW(szCName) + 1) * sizeof(WCHAR));
    if (m_InfoItems[0] == NULL)
    {
        LOG((MSP_ERROR, "out of mem for CName"));
        return E_OUTOFMEMORY;
    }

    lstrcpyW(m_InfoItems[0], szCName);

    // add the stream into out list.
    hr = AddStream(pITStream, dwSSRC, dwSendRecv, dwMediaType);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "failed to add stream %x", hr));
        return hr;
    }

    LOG((MSP_TRACE, "CParticipant: %ws, Init returns S_OK", szCName));
    return S_OK;
}

BOOL CParticipant::UpdateInfo(
    IN  int                 Type,
    IN  DWORD               dwLen,
    IN  WCHAR *             szInfo
    )
/*++

Routine Description:

    Update one item of the participant info.

Arguments:
    
    Type - the type of the INFO, 
    
    dwLen - the length of the information.

    szInfo - the information.

Return Value:

    TRUE - information changed.

    FALSE - the information is the same, no change was made.

--*/
{
    int index = Type - 1;

    // if we have an item already, find out if it is the same.
    if (m_InfoItems[index] != NULL)
    {
        if (lstrcmpW(m_InfoItems[index], szInfo) == 0)
        {
            return FALSE;
        }

        // if the item is new, free the old one
        free(m_InfoItems[index]);
    }

    // allocate memory and store it.
    m_InfoItems[index] = (WCHAR *)malloc((dwLen + 1) * sizeof(WCHAR));
    if (m_InfoItems[index] == NULL)
    {
        return FALSE;
    }

    lstrcpynW(m_InfoItems[index], szInfo, dwLen);

    return TRUE;
}

BOOL CParticipant::UpdateSSRC(
    IN  ITStream *      pITStream, 
    IN  DWORD           dwSSRC,
    IN  DWORD           dwSendRecv
    )
/*++

Routine Description:

    Update the SSRC for a stream.

Arguments:
    
    pITStream - the stream that the participant is on.

    dwSSRC - the SSRC of the participant.

    dwSendRecv - the participant is a sender or a receiver.

Return Value:

    TRUE - information changed.

    FALSE - the stream is not found.

--*/
{
    CLock lock(m_lock);

    // if the stream is already there, update the SSRC and return.
    int index = m_Streams.Find(pITStream);
    if ( index >= 0)
    {
        m_StreamInfo[index].dwSSRC  = dwSSRC;
        m_StreamInfo[index].dwSendRecv |= dwSendRecv;
        return TRUE;
    }

    return FALSE;
}

BOOL CParticipant::HasSSRC(
    IN  ITStream *      pITStream, 
    IN  DWORD           dwSSRC
    )
/*++

Routine Description:

    find out if the participant has the SSRC for a stream.

Arguments:
    
    pITStream - the stream that the participant is on.

    dwSSRC - the SSRC of the participant.

Return Value:

    TRUE - the SSRC exists.

    FALSE - the SSRC does not exist.

--*/
{
    CLock lock(m_lock);

    int index = m_Streams.Find(pITStream);
    if (index >= 0)
    {
        return (m_StreamInfo[index].dwSSRC == dwSSRC);
    }

    return FALSE;
}

BOOL CParticipant::GetSSRC(
    IN  ITStream *      pITStream, 
    OUT DWORD  *        pdwSSRC
    )
/*++

Routine Description:

    Update the SSRC for a stream.

Arguments:
    
    pITStream - the stream that the participant is on.

    pdwSSRC - the address to store the SSRC of the participant.

Return Value:

    TRUE - the SSRC is found.

    FALSE - the SSRC is not found.

--*/
{
    CLock lock(m_lock);

    // if the stream is already there, update the SSRC and return.
    int index = m_Streams.Find(pITStream);
    if ( index >= 0)
    {
        *pdwSSRC = m_StreamInfo[index].dwSSRC;
        return TRUE;
    }

    return FALSE;
}

DWORD CParticipant::GetSendRecvStatus(
    IN  ITStream *      pITStream
    )
/*++

Routine Description:

    find out the current send and recv status on a given stream.

Arguments:
    
    pITStream - the stream that the participant is on.

Return Value:

    A bit mask of send and receive status

--*/
{
    CLock lock(m_lock);

    int index = m_Streams.Find(pITStream);
    if (index >= 0)
    {
        return m_StreamInfo[index].dwSendRecv;
    }

    return 0;
}

void CParticipant::FinalRelease()
/*++

Routine Description:

    release everything before being deleted. 

Arguments:
    
Return Value:

--*/
{
    LOG((MSP_TRACE, "CParticipant::FinalRelease, name %ws", m_InfoItems[0]));

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    for (int i = 0; i < NUM_SDES_ITEMS; i ++)
    {
        if (m_InfoItems[i])
        {
            free(m_InfoItems[i]);
        }
    }

    for (i = 0; i < m_Streams.GetSize(); i ++)
    {
        m_Streams[i]->Release();
    }
    m_Streams.RemoveAll();

    LOG((MSP_TRACE, "CParticipant::FinalRelease - exit"));
}


// ITParticipant methods, called by the app.
STDMETHODIMP CParticipant::get_ParticipantTypedInfo(
    IN  PARTICIPANT_TYPED_INFO  InfoType,
    OUT BSTR *                  ppInfo
    )
/*++

Routine Description:

    Get a information item for this participant.

Arguments:
    
    InfoType - The type of the information asked.

    ppInfo  - the mem address to store a BSTR.

Return Value:

    S_OK,
    E_INVALIDARG,
    E_POINTER,
    E_OUTOFMEMORY,
    TAPI_E_NOITEMS
*/
{
    LOG((MSP_TRACE, "CParticipant get info, type:%d", InfoType));
    
    if (InfoType > PTI_PRIVATE || InfoType < PTI_CANONICALNAME)
    {
        LOG((MSP_ERROR, "CParticipant get info - exit invalid arg"));
        return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppInfo, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CParticipant get info - exit E_POINTER"));
        return E_POINTER;
    }

    // check if we have that info.
    CLock lock(m_lock);
    
    int index = (int)InfoType; 
    if (m_InfoItems[index] == NULL)
    {
        LOG((MSP_INFO, "CParticipant get info - no item for %d", InfoType));
        return TAPI_E_NOITEMS;
    }

   // make a BSTR out of it.
    BSTR pName = SysAllocString(m_InfoItems[index]);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CParticipant get info - exit out of mem"));
        return E_OUTOFMEMORY;
    }

    // return the BSTR.
    *ppInfo = pName;

    return S_OK; 
}

STDMETHODIMP CParticipant::get_MediaTypes(
//    IN  TERMINAL_DIRECTION  Direction,
    OUT long *  plMediaTypes
    )
/*++

Routine Description:

    Get the media type of the participant

Arguments:
    
    plMediaType - the mem address to store a long.

Return Value:

    S_OK,
    E_POINTER,
*/
{
    LOG((MSP_TRACE, "CParticipant::get_MediaTypes - enter"));

    if (IsBadWritePtr(plMediaTypes, sizeof (long)))
    {
        LOG((MSP_ERROR, "CParticipant::get_MediaType - exit E_POINTER"));

        return E_POINTER;
    }

    CLock lock(m_lock);

#if 0
    if (Direction == TD_RENDER)
    {
        *plMediaTypes = (long)m_dwReceivingMediaTypes;
    }
    else
    {
        *plMediaTypes = (long)m_dwSendingMediaTypes;
    }
#endif

    *plMediaTypes = (long)(m_dwSendingMediaTypes | m_dwReceivingMediaTypes);

    LOG((MSP_TRACE, "CParticipant::get_MediaType:%x - exit S_OK", *plMediaTypes));

    return S_OK;
}


STDMETHODIMP CParticipant::put_Status(
    IN  ITStream *      pITStream,
    IN  VARIANT_BOOL    fEnable
    )
{
    ENTER_FUNCTION("CParticipant::put_Status");
    LOG((MSP_TRACE, "%s entered. %hs %ws for %p", 
        __fxName, fEnable ? "Enable" : "Disable", m_InfoItems[0], pITStream));

    HRESULT hr;

    // if the caller specified a stream, find the stream and use it.
    if (pITStream != NULL)
    {
        m_lock.Lock();

        int index;
        if ((index = m_Streams.Find(pITStream)) < 0)
        {
            m_lock.Unlock();
            
            LOG((MSP_ERROR, "%s stream %p not found", __fxName, pITStream));

            return E_INVALIDARG;
        }
        DWORD dwSSRC = m_StreamInfo[index].dwSSRC;

        // add ref so that it won't go away.
        pITStream->AddRef();

        m_lock.Unlock();

        hr = ((CIPConfMSPStream *)pITStream)->EnableParticipant(
            dwSSRC,
            fEnable
            );

        pITStream->Release();

        return hr;
    }

    // if the caller didn't specify a stream, set the status on all streams.
    m_lock.Lock();
    int nSize = m_Streams.GetSize();
    ITStream ** Streams = (ITStream **)malloc(sizeof(ITStream*) * nSize);

    if (Streams == NULL)
    {
        m_lock.Unlock();
        LOG((MSP_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    DWORD * pdwSSRCList = (DWORD *)malloc(sizeof(DWORD) * nSize);

    if (pdwSSRCList == NULL)
    {
        m_lock.Unlock();
        
        free(Streams);

        LOG((MSP_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    for (int i = 0; i < nSize; i ++)
    {
        Streams[i] = m_Streams[i];
        Streams[i]->AddRef();
        pdwSSRCList[i] = m_StreamInfo[i].dwSSRC;
    }
    m_lock.Unlock();

    for (i = 0; i < nSize; i ++)
    {
        hr = ((CIPConfMSPStream *)Streams[i])->
            EnableParticipant(pdwSSRCList[i], fEnable);

        if (FAILED(hr))
        {
            break;
        }
    }

    for (i = 0; i < nSize; i ++)
    {
        Streams[i]->Release();
    }

    free(Streams);
    free(pdwSSRCList);

    return hr;
}

STDMETHODIMP CParticipant::get_Status(
    IN  ITStream *      pITStream,
    OUT VARIANT_BOOL *  pfEnable
    )
{
    ENTER_FUNCTION("CParticipant::get_Status");
    LOG((MSP_TRACE, "%s entered. %ws %p", 
        __fxName, m_InfoItems[0], pITStream));

    if (IsBadWritePtr(pfEnable, sizeof(VARIANT_BOOL)))
    {
        LOG((MSP_ERROR, "%s bad pointer argument - exit E_POINTER", __fxName));

        return E_POINTER;
    }

    HRESULT hr;
    BOOL fEnable;

    // if the caller specified a stream, find the stream and use it.
    if (pITStream != NULL)
    {
        m_lock.Lock();

        int index;
        if ((index = m_Streams.Find(pITStream)) < 0)
        {
            m_lock.Unlock();
            
            LOG((MSP_ERROR, "%s stream %p not found", __fxName, pITStream));

            return E_INVALIDARG;
        }
        DWORD dwSSRC = m_StreamInfo[index].dwSSRC;

        // add ref so that it won't go away.
        pITStream->AddRef();

        m_lock.Unlock();

        hr = ((CIPConfMSPStream *)pITStream)->GetParticipantStatus(
            dwSSRC,
            &fEnable
            );

        pITStream->Release();

        *pfEnable = (fEnable) ? VARIANT_TRUE : VARIANT_FALSE;

        return hr;
    }

    // if the caller didn't specify a stream, get the status from all streams.
    m_lock.Lock();
    int nSize = m_Streams.GetSize();
    ITStream ** Streams = (ITStream **)malloc(sizeof(ITStream*) * nSize);

    if (Streams == NULL)
    {
        m_lock.Unlock();
        LOG((MSP_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    DWORD * pdwSSRCList = (DWORD *)malloc(sizeof(DWORD) * nSize);

    if (pdwSSRCList == NULL)
    {
        m_lock.Unlock();
        
        free(Streams);

        LOG((MSP_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    for (int i = 0; i < nSize; i ++)
    {
        Streams[i] = m_Streams[i];
        Streams[i]->AddRef();
        pdwSSRCList[i] = m_StreamInfo[i].dwSSRC;
    }
    m_lock.Unlock();

    fEnable = FALSE;

    for (i = 0; i < nSize; i ++)
    {
        BOOL fEnabledOnStream;
        hr = ((CIPConfMSPStream *)Streams[i])->
            GetParticipantStatus(pdwSSRCList[i], &fEnabledOnStream);

        if (FAILED(hr))
        {
            break;
        }

        // as long as it is enabled on one stream, it is enabled.
        fEnable = fEnable || fEnabledOnStream;
    }

    for (i = 0; i < nSize; i ++)
    {
        Streams[i]->Release();
    }

    free(Streams);
    free(pdwSSRCList);

    *pfEnable = (fEnable) ? VARIANT_TRUE : VARIANT_FALSE;
    return hr;
}

STDMETHODIMP CParticipant::EnumerateStreams(
    OUT     IEnumStream **      ppEnumStream
    )
{
    LOG((MSP_TRACE, 
        "EnumerateStreams entered. ppEnumStream:%x", ppEnumStream));

    //
    // Check parameters.
    //

    if (IsBadWritePtr(ppEnumStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the stream object list.
    //

    CLock lock(m_lock);

    if (m_Streams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //
    typedef _CopyInterface<ITStream> CCopy;
    typedef CSafeComEnum<IEnumStream, &__uuidof(IEnumStream), 
                ITStream *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = ::CreateCComObjectInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the __uuidof(IEnumStream) i/f
    //

    hr = pEnum->_InternalQueryInterface(__uuidof(IEnumStream), (void**)ppEnumStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized array.
    //

    hr = pEnum->Init(
        m_Streams.GetData(),                        // the begin itor
        m_Streams.GetData() + m_Streams.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "init enumerator object failed, %x", hr));

        (*ppEnumStream)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CParticipant::EnumerateStreams - exit S_OK"));

    return hr;
}

STDMETHODIMP CParticipant::get_Streams(
    OUT     VARIANT *           pVariant
    )
{
    LOG((MSP_TRACE, "CParticipant::get_Streams - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the stream object list.
    //

    CLock lock(m_lock);

    if (m_Streams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //
    typedef CTapiIfCollection< ITStream * > StreamCollection;
    CComObject<StreamCollection> * pCollection;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_Streams.GetSize(),
                                  m_Streams.GetData(),
                                  m_Streams.GetData() + m_Streams.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_INFO, "CParticipant::get_Streams - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CParticipant::get_Streams - exit S_OK"));
    return S_OK;
}

HRESULT CParticipant::AddStream(
    IN  ITStream *      pITStream, 
    IN  DWORD           dwSSRC,
    IN  DWORD           dwSendRecv,
    IN  DWORD           dwMediaType
    )
/*++

Routine Description:

    A participant might appear on more than one streams. This function adds
    a new stream and the SSRC into the participant's list.

Arguments:
    
    pITStream - the stream that has the participant.

    dwSSRC - the SSRC of the participant in that stream.

    dwSendRecv - the participant is a sender or receiver in the stream.

    dwMediaType - the media type of the stream.

Return Value:

    S_OK,
    E_OUTOFMEMORY,
*/
{
    CLock lock(m_lock);

    // if the stream is already there, update the SSRC and return.
    int index = m_Streams.Find(pITStream);
    if ( index >= 0)
    {
        m_StreamInfo[index].dwSSRC = dwSSRC;
        m_StreamInfo[index].dwSendRecv |= dwSendRecv;
        return S_OK;
    }

    // add the stream.
    if (!m_Streams.Add(pITStream))
    {
        return E_OUTOFMEMORY;
    }
    
    // add the SSRC and sender flag.
    STREAM_INFO Info;
    Info.dwSSRC = dwSSRC;
    Info.dwSendRecv = dwSendRecv;
    Info.dwState = PESTREAM_RECOVER;

    if (!m_StreamInfo.Add(Info))
    {
        m_Streams.Remove(pITStream);

        return E_OUTOFMEMORY;
    }

    pITStream->AddRef();

    // update the mediatype.
    if (dwSendRecv & PART_SEND)
    {
        m_dwSendingMediaTypes |= dwMediaType;
    }
    if (dwSendRecv & PART_RECV)
    {
        m_dwReceivingMediaTypes |= dwMediaType;
    }

    return S_OK;
}

HRESULT CParticipant::RemoveStream(
    IN  ITStream *  pITStream,
    IN  DWORD       dwSSRC,
    OUT BOOL *      pbLast
    )
/*++

Routine Description:

    A participant might appear on more than one streams. This function remove
    a stream from the participant's list.

Arguments:
    
    pITStream - the stream that has the participant.

    dwSSRC - the SSRC of the participant in that stream.

    pbLast - the memory space to store a boolean value, specifying if the 
             stream removed was the last one in the list.

Return Value:

    S_OK,
    E_POINTER,
*/
{
    CLock lock(m_lock);
    
    // first find the stream.
    int index = m_Streams.Find(pITStream);

    if (index < 0)
    {
        return E_FAIL;
    }
    
    if (m_Streams.GetSize()  != m_StreamInfo.GetSize())
    {
        return E_UNEXPECTED;
    }

    // then check the SSRC.
    if (m_StreamInfo[index].dwSSRC != dwSSRC)
    {
        // this is not the participant being looking for.
        return E_FAIL;
    }

    // SSRC match, we found the participant. remove the stream and info.
    m_Streams.RemoveAt(index);
    m_StreamInfo.RemoveAt(index);

    // release the refcount we had in the list.
    pITStream->Release();

    // recalculate the media types.
    m_dwSendingMediaTypes = 0;
    m_dwReceivingMediaTypes = 0;
    
    for (int i = 0; i < m_Streams.GetSize(); i ++)
    {
        if (m_StreamInfo[i].dwSendRecv & PART_SEND)
        {
            m_dwSendingMediaTypes |= ((CIPConfMSPStream *)m_Streams[i])->MediaType();
        }

        if (m_StreamInfo[i].dwSendRecv & PART_RECV)
        {
            m_dwReceivingMediaTypes |= ((CIPConfMSPStream *)m_Streams[i])->MediaType();
        }
    }

    *pbLast = (m_Streams.GetSize() == 0);

    return S_OK;
}

HRESULT CParticipant::SetStreamState (
    IN ITStream *       pITStream,
    IN PESTREAM_STATE   state
    )
/*++

Routine Description:

    Sets the state on stream.

--*/
{
    CLock lock(m_lock);

    // first find the stream.
    int index = m_Streams.Find(pITStream);
    if (index < 0)
        return E_FAIL;
    
    if (m_Streams.GetSize()  != m_StreamInfo.GetSize())
        return E_UNEXPECTED;

    DWORD dw = m_StreamInfo[index].dwState;

    switch (state)
    {
    case PESTREAM_RECOVER:
        // set recover
        dw |= PESTREAM_RECOVER;
        // clear timeout bit
        dw |= PESTREAM_TIMEOUT;
        dw &= (PESTREAM_TIMEOUT ^ PESTREAM_FULLBITS);
        break;

    case PESTREAM_TIMEOUT:
        // set timeout
        dw |= PESTREAM_TIMEOUT;
        // clear recover bit
        dw |= PESTREAM_RECOVER;
        dw &= (PESTREAM_RECOVER ^ PESTREAM_FULLBITS);
        break;

    default:
        LOG ((MSP_ERROR, "unknown stream state. %x", state));
        return E_INVALIDARG;
    }

    m_StreamInfo[index].dwState = dw;
    return S_OK;
}

HRESULT CParticipant::GetStreamState (
    IN ITStream *       pITStream,
    OUT DWORD *         pdwState
    )
/*++

Routine Description:

    Gets the state on stream.

--*/
{
    CLock lock(m_lock);

    // first find the stream.
    int index = m_Streams.Find(pITStream);
    if (index < 0)
        return E_FAIL;
    
    if (m_Streams.GetSize()  != m_StreamInfo.GetSize())
        return E_UNEXPECTED;

    *pdwState = m_StreamInfo[index].dwState;

    return S_OK;
}

INT CParticipant::GetStreamCount (DWORD dwSendRecv)
{
    // this is called by ourself
    _ASSERTE ((dwSendRecv & PART_SEND) || (dwSendRecv & PART_RECV));

    CLock lock(m_lock);

    int i, count = 0;

    for (i=0; i<m_StreamInfo.GetSize (); i++)
    {
        if (m_StreamInfo[i].dwSendRecv & dwSendRecv)
            count ++;
    }

    return count;
}

INT CParticipant::GetStreamTimeOutCount (DWORD dwSendRecv)
{
    // this is called by ourself
    _ASSERTE ((dwSendRecv & PART_SEND) || (dwSendRecv & PART_RECV));

    CLock lock(m_lock);

    int i, count = 0;

    for (i=0; i<m_StreamInfo.GetSize (); i++)
    {
        if ((m_StreamInfo[i].dwSendRecv & dwSendRecv) &&
            (m_StreamInfo[i].dwState & PESTREAM_TIMEOUT))
            count ++;
    }

    return count;
}

BOOL CParticipantList::FindByCName(WCHAR *szCName, int *pIndex) const
/*++

Routine Description:

    Find a participant by its canonical name. If the function returns true,
    *pIndex contains the index of the participant. If the function returns
    false, *pIndex contains the index where the new participant should be
    inserted.

Arguments:
    
    szCName - the canonical name of the participant.

    pIndex - the memory address to store an integer.

Return Value:

    TRUE - the participant is found.

    FALSE - the participant is not in the list.
*/
{
    for(int i = 0; i < m_nSize; i++)
    {
        // This list is an ordered list based on dictionary order. We are using
        // a linear search here, it could be changed to a binary search.

        // CompareCName will return 0 if the name is the same, <0 if the szCName
        // is bigger, >0 if the szCName is smaller.
        int res = ((CParticipant *)m_aT[i])->CompareCName(szCName);
        if(res >= 0) 
        {
            *pIndex = i;
            return (res == 0);
        }
    }
    *pIndex = m_nSize;
    return FALSE;   // not found
}

BOOL CParticipantList::InsertAt(int nIndex, ITParticipant *pITParticipant)
/*++

Routine Description:

    Insert a participant into the list at a given index.

Arguments:
    
    nIndex - the location where the new object is inserted.

    pITParticipant - the object to be inserted.

Return Value:

    TRUE - the participant is inserted.

    FALSE - out of memory.
*/
{
    _ASSERTE(nIndex >= 0 && nIndex <= m_nSize);
    if(m_nSize == m_nAllocSize)
    {
        if (!Grow()) return FALSE;
    }

    memmove((void*)&m_aT[nIndex+1], (void*)&m_aT[nIndex], 
        (m_nSize - nIndex) * sizeof(ITParticipant *));

    m_nSize++;

    SetAtIndex(nIndex, pITParticipant);

    return TRUE;
}

CParticipantEvent::CParticipantEvent()
    : m_pFTM(NULL),
      m_pITParticipant(NULL),
      m_pITSubStream(NULL),
      m_Event(PE_NEW_PARTICIPANT)
{}

// methods called by the call object.
HRESULT CParticipantEvent::Init(
    IN  PARTICIPANT_EVENT   Event,
    IN  ITParticipant *     pITParticipant,
    IN  ITSubStream *       pITSubStream
    )
/*++

Routine Description:

    Initialize the ParticipantEvent object.

Arguments:
    
    Event - the event.

    pITParticipant - the participant.

    pITSubStream - the substream, can be NULL.

Return Value:

    S_OK,

--*/
{
    LOG((MSP_TRACE, "CParticipantEvent::Init"));

    // create the marshaler.
    HRESULT hr;
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pFTM);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create marshaler failed, %x", hr));
        return hr;
    }

    m_Event             = Event;
    
    m_pITParticipant    = pITParticipant;
    if (m_pITParticipant) m_pITParticipant->AddRef();

    m_pITSubStream      = pITSubStream;
    if (m_pITSubStream) m_pITSubStream->AddRef();

    LOG((MSP_TRACE, "CParticipantEvent Init returns S_OK"));
    return S_OK;
}

void CParticipantEvent::FinalRelease()
/*++

Routine Description:

    release everything before being deleted. 

Arguments:
    
Return Value:

--*/
{
    LOG((MSP_TRACE, "CParticipantEvent::FinalRelease - enter"));

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    if (m_pITParticipant) m_pITParticipant->Release();

    if (m_pITSubStream) m_pITSubStream->Release();

    LOG((MSP_TRACE, "CParticipantEvent::FinalRelease - exit"));
}

STDMETHODIMP CParticipantEvent::get_Event(
    OUT PARTICIPANT_EVENT * pParticipantEvent
    )
{
    if (IsBadWritePtr(pParticipantEvent, sizeof (PARTICIPANT_EVENT)))
    {
        LOG((MSP_ERROR, "CParticipantEvent::get_Event - exit E_POINTER"));

        return E_POINTER;
    }

    *pParticipantEvent = m_Event;

    return S_OK;
}

STDMETHODIMP CParticipantEvent::get_Participant(
    OUT ITParticipant ** ppITParticipant
    )
{
    if (IsBadWritePtr(ppITParticipant, sizeof (void *)))
    {
        LOG((MSP_ERROR, "CParticipantEvent::get_participant - exit E_POINTER"));

        return E_POINTER;
    }

    if (!m_pITParticipant)
    {
        // LOG((MSP_ERROR, "CParticipantevnt::get_Participant - exit no item"));
        return TAPI_E_NOITEMS;
    }

    m_pITParticipant->AddRef();
    *ppITParticipant = m_pITParticipant;

    return S_OK;
}

STDMETHODIMP CParticipantEvent::get_SubStream(
    OUT ITSubStream** ppSubStream
    )
{
    if (IsBadWritePtr(ppSubStream, sizeof (void *)))
    {
        LOG((MSP_ERROR, "CParticipantEvent::get_SubStream - exit E_POINTER"));

        return E_POINTER;
    }

    if (!m_pITSubStream)
    {
        LOG((MSP_WARN, "CParticipantevnt::get_SubStream - exit no item"));
        return TAPI_E_NOITEMS;
    }

    m_pITSubStream->AddRef();
    *ppSubStream = m_pITSubStream;

    return S_OK;
}

HRESULT CreateParticipantEvent(
    IN  PARTICIPANT_EVENT       Event,
    IN  ITParticipant *         pITParticipant,
    IN  ITSubStream *           pITSubStream,
    OUT IDispatch **            ppIDispatch
    )
{
    // create the object.
    CComObject<CParticipantEvent> * pCOMParticipantEvent;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCOMParticipantEvent);

    if (NULL == pCOMParticipantEvent)
    {
        LOG((MSP_ERROR, "could not create participant event:%x", hr));
        return hr;
    }

    IDispatch * pIDispatch;

    // get the interface pointer.
    hr = pCOMParticipantEvent->_InternalQueryInterface(
        __uuidof(IDispatch), 
        (void **)&pIDispatch
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create ParticipantEvent QueryInterface failed: %x", hr));
        delete pCOMParticipantEvent;
        return hr;
    }

    // Initialize the object.
    hr = pCOMParticipantEvent->Init(
        Event,
        pITParticipant,
        pITSubStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPParticipantEvent:call init failed: %x", hr));
        pIDispatch->Release();

        return hr;
    }

    *ppIDispatch = pIDispatch;
    
    return S_OK;
}

HRESULT CreateParticipantEnumerator(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    OUT IEnumParticipant ** ppEnumParticipant
    )
{
    //
    // Create an enumerator object.
    //

    typedef _CopyInterface<ITParticipant> CCopy;
    typedef CSafeComEnum<IEnumParticipant, &__uuidof(IEnumParticipant), 
                ITParticipant *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = ::CreateCComObjectInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CreateParticipantEnumerator - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the __uuidof(IEnumParticipant) i/f
    //

    hr = pEnum->_InternalQueryInterface(
        __uuidof(IEnumParticipant), 
        (void**)ppEnumParticipant
        );
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateParticipantEnumerator - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized array.
    //

    hr = pEnum->Init(
        begin,                        // the begin itor
        end,  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateParticipantEnumerator - "
            "init enumerator object failed, %x", hr));

        (*ppEnumParticipant)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CreateParticipantEnumerator - exit S_OK"));

    return hr;
}

HRESULT CreateParticipantCollection(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    IN  int                 nSize,
    OUT VARIANT *           pVariant
    )
{
    //
    // create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITParticipant * > ParticipantCollection;
    CComObject<ParticipantCollection> * pCollection;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CreateParticipantCollection - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CreateParticipantCollection - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize(nSize, begin, end);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateParticipantCollection- "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CreateParticipantCollection - exit S_OK"));
 
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confstrm.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ConfStrm.h

Abstract:

    Definitions for CIPConfMSPStream class.

Author:

    Mu Han (muhan) 1-November-1997

--*/
#ifndef __CONFSTRM_H
#define __CONFSTRM_H

/////////////////////////////////////////////////////////////////////////////
// CIPConfMSPStream
/////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG_REFCOUNT
extern LONG g_lStreamObjects;
#endif

class ATL_NO_VTABLE CIPConfMSPStream :
    public CMSPStream,
    public ITStreamQualityControl,
    public IInnerStreamQualityControl,
    public CMSPObjectSafetyImpl
{

BEGIN_COM_MAP(CIPConfMSPStream)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ITStreamQualityControl)
    COM_INTERFACE_ENTRY(IInnerStreamQualityControl)
    COM_INTERFACE_ENTRY_CHAIN(CMSPStream)
END_COM_MAP()

public:

    CIPConfMSPStream();

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    DWORD   MediaType() const               { return m_dwMediaType; }
    TERMINAL_DIRECTION  Direction() const   { return m_Direction;   }
    
    BOOL IsConfigured();

    virtual HRESULT Configure(
        IN  STREAMSETTINGS &StreamSettings,
        IN  WCHAR *pszKey
        );

    HRESULT FinishConfigure();

    // CMSPStream methods.
    HRESULT ShutDown ();

     // ITStream
    STDMETHOD (get_Name) (
        OUT     BSTR *      ppName
        );

    STDMETHOD (StartStream) ();
    STDMETHOD (PauseStream) ();
    STDMETHOD (StopStream) ();

    STDMETHOD (SelectTerminal)(
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal)(
        IN      ITTerminal *            pTerminal
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   StreamQualityProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   StreamQualityProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // IInnerStreamQualityControl
    //
    STDMETHOD (LinkInnerCallQC) (
        IN  IInnerCallQualityControl *pIInnerCallQC
        );

    STDMETHOD (UnlinkInnerCallQC) (
        IN  BOOL fByStream
        );

    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN  InnerStreamQualityProperty property,
        IN  LONG  lValue1,
        IN  TAPIControlFlags lFlags
        );

    STDMETHOD (Get) (
        IN  InnerStreamQualityProperty property,
        OUT LONG *plValue,
        OUT TAPIControlFlags *plFlags
        );

    STDMETHOD (TryLockStream)() { return m_lock.TryLock()?S_OK:S_FALSE; }

    STDMETHOD (UnlockStream)() { m_lock.Unlock(); return S_OK; }

    STDMETHOD (IsAccessingQC)() { return m_fAccessingQC?S_OK:S_FALSE; }

    // methods called by the MSPCall object.
    HRESULT Init(
        IN     HANDLE                   hAddress,
        IN     CMSPCallBase *           pMSPCall,
        IN     IMediaEvent *            pGraph,
        IN     DWORD                    dwMediaType,
        IN     TERMINAL_DIRECTION       Direction
        );

    HRESULT SetLocalParticipantInfo(
        IN      PARTICIPANT_TYPED_INFO  InfoType,
        IN      WCHAR *                 pInfo,
        IN      DWORD                   dwLen
        );

    // Called by stream and substream to send event to tapi.
    virtual HRESULT SendStreamEvent(
        IN      MSP_CALL_EVENT          Event,
        IN      MSP_CALL_EVENT_CAUSE    Cause,
        IN      HRESULT                 hrError,
        IN      ITTerminal *            pTerminal
        );

    // Called by the participant object.
    virtual HRESULT EnableParticipant(
        IN  DWORD   dwSSRC,
        IN  BOOL    fEnable
        );

    virtual HRESULT GetParticipantStatus(
        IN  DWORD   dwSSRC,
        IN  BOOL *  pfEnable
        );

protected:
    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  LONG_PTR lParam1,
        IN  LONG_PTR lParam2
        );

    virtual HRESULT CheckTerminalTypeAndDirection(
        IN      ITTerminal *    pTerminal
        );

    virtual HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        ) = 0;

    virtual HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    virtual HRESULT SetUpFilters() = 0;
    virtual HRESULT CleanUpFilters();

    HRESULT EnableParticipantEvents(
        IN IRtpSession * pRtpSession
        );

    HRESULT EnableQOS(
        IN IRtpSession * pRtpSession
        );

    HRESULT EnableEncryption(
        IN IRtpSession * pRtpSession,
        IN WCHAR *pPassPhrase
        );

    HRESULT ConfigureRTPFilter(
        IN  IBaseFilter *   pIBaseFilter
        );

    virtual HRESULT ProcessParticipantTimeOutOrRecovered(
        IN  BOOL    fTimeOutOrRecovered,
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessSDESUpdate(
        IN  DWORD   dwInfoItem,
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessParticipantLeave(
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessQOSEvent(
        IN  long    lEventCode
        );

    virtual HRESULT ProcessTalkingEvent(
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessWasTalkingEvent(
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessSilentEvent(
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessPinMappedEvent(
        IN  DWORD   dwSSRC,
        IN  IPin *  pIPin
        );

    virtual HRESULT ProcessPinUnmapEvent(
        IN  DWORD   dwSSRC,
        IN  IPin *  pIPin
        );

    virtual HRESULT ProcessNewParticipant(
        IN  int                 index,
        IN  DWORD               dwSSRC,
        IN  DWORD               dwSendRecv,
        IN  WCHAR *              szCName,
        OUT ITParticipant **    ppITParticipant
        );

    virtual HRESULT NewParticipantPostProcess(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

    virtual HRESULT SetLocalInfoOnRTPFilter(
        IN  IBaseFilter *   pRTPFilter
        );

protected:
    const WCHAR *       m_szName;

    BOOL                m_fIsConfigured;
    STREAMSETTINGS      m_Settings;

    IRtpDemux *         m_pIRTPDemux;
    IRtpSession *       m_pIRTPSession;
    IStreamConfig *     m_pIStreamConfig;

    // The list of participant in the stream.
    CParticipantList    m_Participants;

    // Callback interface to the quality controller.
    CStreamQualityControlRelay * m_pStreamQCRelay;

    // the local info needed to be set on the RTP filter.
    WCHAR *             m_InfoItems[NUM_SDES_ITEMS];
    WCHAR *             m_szKey;

    // flag will be set when stream is accessing quality control methods
    // that will in turn lock the stream list lock inside quality control.
    BOOL                m_fAccessingQC;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confterm.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    IPConfterm.h

Abstract:

    Definitions for the CIPConfBaseTerminal

Author:

    Zoltan Szilagyi (zoltans) September 6,1998

--*/

#ifndef _IPConfTERM_H_
#define _IPConfTERM_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// CIPConfBaseTerminal                                                           
//                                                                         
//                                                                         
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CIPConfBaseTerminal : 
    virtual public CComObjectRootEx<CComMultiThreadModelNoCS>, // we have our own CS implementation
    public IDispatchImpl<ITTerminal, &__uuidof(ITTerminal), &LIBID_TAPI3Lib>,
    public ITTerminalControl,
    public CMSPObjectSafetyImpl
{

BEGIN_COM_MAP(CIPConfBaseTerminal)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITTerminal)
    COM_INTERFACE_ENTRY(ITTerminalControl)
    COM_INTERFACE_ENTRY2(IDispatch, ITTerminal)
    COM_INTERFACE_ENTRY_AGGREGATE(__uuidof(IMarshal), m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

public:

    CIPConfBaseTerminal();
    HRESULT FinalConstruct();
    virtual ~CIPConfBaseTerminal();

public:
// ITTerminal -- COM interface for use by MSP or application
    STDMETHOD(get_TerminalClass)(OUT  BSTR *pVal);
    STDMETHOD(get_TerminalType) (OUT  TERMINAL_TYPE *pVal);
    STDMETHOD(get_State)        (OUT  TERMINAL_STATE *pVal);
    STDMETHOD(get_Name)         (OUT  BSTR *pVal);
    STDMETHOD(get_MediaType)    (OUT  long * plMediaType);
    STDMETHOD(get_Direction)    (OUT  TERMINAL_DIRECTION *pDirection);

// ITTerminalControl -- COM interface for use by MSP only

    STDMETHOD (get_AddressHandle) (
            OUT     MSP_HANDLE    * phtAddress
            );

    STDMETHOD (ConnectTerminal) (
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved,
            IN OUT  DWORD          * pdwNumPins,
            OUT     IPin          ** ppPins
            );

    STDMETHOD (CompleteConnectTerminal) (void);

    STDMETHOD (DisconnectTerminal) (
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

    STDMETHOD (RunRenderFilter) (void);

    STDMETHOD (StopRenderFilter) (void);

public:
    HRESULT Initialize(
            IN  WCHAR *             strName,
            IN  MSP_HANDLE          htAddress
            );

    HRESULT Initialize(
            IN  char *              strName,
            IN  MSP_HANDLE          htAddress
            );

protected:
    void Lock()     { EnterCriticalSection(&m_CritSec); }
    void Unlock()   { LeaveCriticalSection(&m_CritSec); }

    virtual DWORD GetNumExposedPins() const = 0;

    virtual HRESULT CreateFilter() = 0;

    virtual HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        ) = 0;

    virtual HRESULT AddFilterToGraph(
        IN  IGraphBuilder *pGraph
        );

    virtual HRESULT RemoveFilterFromGraph(
        IN  IGraphBuilder *pGraph
        );

protected:
    // The lock that protects the data members.
    CRITICAL_SECTION    m_CritSec;
    BOOL                m_fCritSecValid;

    // these five numbers need to be set by the derived class.
    GUID                m_TerminalClassID;
    TERMINAL_DIRECTION  m_TerminalDirection;
    TERMINAL_TYPE       m_TerminalType;
    TERMINAL_STATE      m_TerminalState;
    DWORD               m_dwMediaType;

    WCHAR               m_szName[MAX_PATH + 1];
    MSP_HANDLE          m_htAddress;

    // Pointer to the free threaded marshaler.
    IUnknown *          m_pFTM;

    // stores the filter graph builder (derives from IFilterGraph)
    IGraphBuilder *     m_pGraph;
    IBaseFilter *       m_pFilter;
};


#endif // _IPConfTERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confstrm.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confstrm.cpp

Abstract:

    This module contains implementation of CMSPStream. The object represents
    one stream in the filter graph.

Author:

    Mu Han (muhan)   1-November-1997

--*/

#include "stdafx.h"

/*  State Transition Table


States:

RO   - Running whithout terminal. This is the initial state.
PO   - Paused without terminal
SO   - Stopped without terminal.
RT   - Runing with terminal.
PT   - Paused with termianl.
ST   - Stopped with terminal.

Actions:
S   - Stop graph.
P   - Pause graph.
C   - Change graph.
D   - Disonnect terminals.
F   - Free extra references to filters and terminals.
R   - Run Graph.
NIU - Not in use.

Note: the same graph operation can be called multiple times, the graph
just returns S_OK if it is already in desired state.

NOTE: if the stream is not configured, the transition will happen without
really doing anything to the graph.

CONFIG will only be called for NC streams.

        CONFIG  Select  Unselect    Run     Pause   Stop    ShutDown

RO      OK      C/R     FAIL        OK      OK      OK      F
        RO       RT      RO         RO      PO      SO      -

PO      OK      C/P     FAIL        OK      OK      OK      F
        PO       PT      PO         RO      PO      SO      -

SO      OK      C       FAIL        OK      OK      OK      F
        SO       ST      SO         RO      PO      SO      -

RT      C/R     S/C/R   S/C/(R)     R       P       S       S/D/F
        RT       RT     RT,RO       RT      PT      ST      -

PT      C/P     S/C/P   S/C/(P)     R       P       S       S/D/F
        PT       PT     PT,PO       RT      PT      ST      -

ST      C       C       C           R       P       S       D/F
        ST       ST     ST,SO       RT      PT      ST      -

*/

CIPConfMSPStream::CIPConfMSPStream()
    : CMSPStream(),
    m_szName(L""),
    m_fIsConfigured(FALSE),
    m_pIRTPSession(NULL),
    m_pIRTPDemux(NULL),
    m_pIStreamConfig(NULL),
    m_szKey(NULL),
    m_pStreamQCRelay(NULL),
    m_fAccessingQC(FALSE)
{
    // The default state is always running.
    m_dwState   = STRM_RUNNING;
    ZeroMemory(m_InfoItems, sizeof(m_InfoItems));
    ZeroMemory(&m_Settings, sizeof(m_Settings));
}

#ifdef DEBUG_REFCOUNT
LONG g_lStreamObjects = 0;

ULONG CIPConfMSPStream::InternalAddRef()
{
    InterlockedIncrement(&g_lStreamObjects);
    
    ULONG lRef = CMSPStream::InternalAddRef();
    
    LOG((MSP_TRACE, "%ws Addref, ref = %d", m_szName, lRef));

    return lRef;
}

ULONG CIPConfMSPStream::InternalRelease()
{
    InterlockedDecrement(&g_lStreamObjects);

    ULONG lRef = CMSPStream::InternalRelease();
    
    LOG((MSP_TRACE, "%ws Release, ref = %d", m_szName, lRef));

    return lRef;
}
#endif

BOOL CIPConfMSPStream::IsConfigured()
{
    CLock lock(m_lock);
    return m_fIsConfigured;
}

// methods called by the MSPCall object.
HRESULT CIPConfMSPStream::Init(
    IN     HANDLE                   hAddress,
    IN     CMSPCallBase *           pMSPCall,
    IN     IMediaEvent *            pGraph,
    IN     DWORD                    dwMediaType,
    IN     TERMINAL_DIRECTION       Direction
    )
/*++

Routine Description:
    Initialize the stream object.

Arguments:

    hAddress    - a handle to the address, used in identify terminals.

    pMSPCall    - the call object that owns the stream.

    pIGraphBuilder - the filter graph object.

    dwMediaType - the mediatype of this stream.

    Direction  - the direction of this stream.

Return Value:
    
    S_OK,
    E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream::Init - enter"));

    // initialize the participant array so that the array is not NULL.
    if (!m_Participants.Grow())
    {
        LOG((MSP_ERROR, "out of mem for participant list"));
        return E_OUTOFMEMORY;
    }

    return CMSPStream::Init(
        hAddress, pMSPCall, pGraph, dwMediaType, Direction
        );
}

HRESULT CIPConfMSPStream::SetLocalParticipantInfo(
    IN      PARTICIPANT_TYPED_INFO  InfoType,
    IN      WCHAR *                 pInfo,
    IN      DWORD                   dwStringLen
    )
/*++

Routine Description:

    Get the name of this stream.

Arguments:
    
    InfoType    - the type of the information item.

    pInfo       - the string containing the info.

    dwStringLen - the length of the string(not including EOS).

Return Value:

    HRESULT.
*/
{
    CLock lock(m_lock);

    //
    // Save the information localy first.
    //
    int index = (int)InfoType; 
    if (m_InfoItems[index] != NULL)
    {
        free(m_InfoItems[index]);
    }

    m_InfoItems[index] = (WCHAR *)malloc((dwStringLen + 1)* sizeof(WCHAR));

    if (m_InfoItems[index] == NULL)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpynW(m_InfoItems[index], pInfo, dwStringLen + 1);

    if (!m_pIRTPSession)
    {
        return S_OK;
    }

    //
    // if the RTP filter has been created, apply the change to the fitler.
    //

    HRESULT hr = m_pIRTPSession->SetSdesInfo(
            RTPSDES_CNAME + index,
            pInfo
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't set item:%s", m_szName, pInfo));
    }

    return hr;
}

STDMETHODIMP CIPConfMSPStream::get_Name(
    OUT     BSTR *                  ppName
    )
/*++

Routine Description:

    Get the name of this stream.

Arguments:
    
    ppName  - the mem address to store a BSTR.

Return Value:

    HRESULT.

*/
{
    LOG((MSP_TRACE, "CIPconfMSPStream::get_Name - enter"));
    
    if (IsBadWritePtr(ppName, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CMSPStream::get_Name - exit E_POINTER"));
        return E_POINTER;
    }

    DWORD dwID;

    if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        if (m_Direction == TD_CAPTURE)
        {
            dwID = IDS_AUDIO_CAPTURE_STREAM;
        }
        else
        {
            dwID = IDS_AUDIO_RENDER_STREAM;
        }
    }
    else
    {
        if (m_Direction == TD_CAPTURE)
        {
            dwID = IDS_VIDEO_CAPTURE_STREAM;
        }
        else
        {
            dwID = IDS_VIDEO_RENDER_STREAM;
        }
    }

    const int   BUFSIZE = 1024;
    WCHAR       wszName[BUFSIZE];

    if (LoadStringW( 
            _Module.GetModuleInstance(),
            dwID,
            wszName,
            BUFSIZE - 1 ) == 0)
    {
        *ppName = NULL;

        LOG((MSP_ERROR, "CMSPStream::get_Name - "
            "LoadString failed - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Convert to a BSTR and return the BSTR.
    //

    BSTR pName = SysAllocString(wszName);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CMSPStream::get_Name - exit out of mem"));
        return E_OUTOFMEMORY;
    }

    *ppName = pName;

    return S_OK; 
}

HRESULT CIPConfMSPStream::SendStreamEvent(
    IN      MSP_CALL_EVENT          Event,
    IN      MSP_CALL_EVENT_CAUSE    Cause,
    IN      HRESULT                 hrError = 0,
    IN      ITTerminal *            pTerminal = NULL
    )
/*++

Routine Description:

    Send a event to the app.
*/
{
    CLock lock(m_lock);

    LOG((MSP_TRACE, "SendStreamEvent entered: stream %p, event %d, cause %d", this, Event, Cause));
    
    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    ITStream *  pITStream;
    HRESULT hr = this->_InternalQueryInterface(
        __uuidof(ITStream), 
        (void **)&pITStream
    );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "SendStreamEvent:QueryInterface failed: %x", hr));
        return hr;
    }

    MSPEVENTITEM* pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data"));
        pITStream->Release();

        return E_OUTOFMEMORY;
    }
    
    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
    pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;
    
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type = Event;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause = Cause;

    // pITStream has a refcount becaust it was from QI.
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream = pITStream;

    // the terminal needs to be addrefed.
    if (pTerminal) pTerminal->AddRef();
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = pTerminal;

    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError= hrError;

    hr = m_pMSPCall->HandleStreamEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));
        
        pITStream->Release();
        FreeEventItem(pEventItem);

        return hr;
    }
    return S_OK;
}

HRESULT CIPConfMSPStream::CleanUpFilters()
/*++

Routine Description:

    remove all the filters in the graph.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CleanUpFilters for %ws %p", m_szName, this));
   
    if (m_pIRTPDemux)
    {
        m_pIRTPDemux->Release();
        m_pIRTPDemux = NULL;
    }
/*
    if (m_pIRTPSession)
    {
        m_pIRTPSession->Release();
        m_pIRTPSession = NULL;
    }
*/
    if (m_pIStreamConfig)
    {
        m_pIStreamConfig->Release();
        m_pIStreamConfig = NULL;
    }

    for(;;)
    {
        // Because the enumerator is invalid after removing a filter from
        // the graph, we have to try to get all the filters in one shot.
        // If there are still more, we loop again.

        // Enumerate the filters in the graph.
        CComPtr<IEnumFilters>pEnum;
        HRESULT hr = m_pIGraphBuilder->EnumFilters(&pEnum);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "cleanup filters, enumfilters failed: %x", hr));
            return hr;
        }

        const DWORD MAXFILTERS = 40;
        IBaseFilter * Filters[MAXFILTERS];
        DWORD dwFetched;
    
        hr = pEnum->Next(MAXFILTERS, Filters, &dwFetched);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get next filter failed: %x", hr));
            return hr;
        }

        for (DWORD i = 0; i< dwFetched; i ++)
        {
            m_pIGraphBuilder->RemoveFilter(Filters[i]);
            Filters[i]->Release();
        }

        if (hr != S_OK)
        {
            break;
        }
    }
    return S_OK;
}

HRESULT SetGraphClock(
    IGraphBuilder *pIGraphBuilder
    )
{
    HRESULT hr;

    // create the clock object first.
    CComObject<CMSPStreamClock> *pClock = NULL;

    hr = ::CreateCComObjectInstance(&pClock);

    if (pClock == NULL)
    {
        LOG((MSP_ERROR, 
            "SetGraphClock Could not create clock object, %x", hr));

        return hr;
    }

    IReferenceClock* pIReferenceClock = NULL;

    hr = pClock->_InternalQueryInterface(
        __uuidof(IReferenceClock), 
        (void**)&pIReferenceClock
        );
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "SetGraphClock query pIReferenceClock interface failed, %x", hr));

        delete pClock;
        return hr;
    }

    // Get the graph builder interface on the graph.
    IMediaFilter *pFilter;
    hr = pIGraphBuilder->QueryInterface(
            IID_IMediaFilter, (void **) &pFilter);

    if(FAILED(hr))
    {
        LOG((MSP_ERROR, "get IFilter interface, %x", hr));
        pIReferenceClock->Release();
        return hr;
    }

    hr = pFilter->SetSyncSource(pIReferenceClock);

    pIReferenceClock->Release();
    pFilter->Release();

    LOG((MSP_TRACE, "SetSyncSource returned, %x", hr));
    
    return hr;
}

HRESULT CIPConfMSPStream::Configure(
    IN STREAMSETTINGS &StreamSettings,
    IN  WCHAR *pszKey
    )
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream configure entered."));

    CLock lock(m_lock);
    
    _ASSERTE(m_fIsConfigured == FALSE);

    // configure the graph with our own clock.
    SetGraphClock(m_pIGraphBuilder);

    if (pszKey != NULL)
    {
        m_szKey = (WCHAR *)malloc(sizeof(WCHAR) * (lstrlenW(pszKey) + 1));
        if (m_szKey == NULL)
        {
            LOG((MSP_ERROR, "stream %ws %p out of memeroy", m_szName, this));
            return E_OUTOFMEMORY;
        }

        lstrcpyW(m_szKey, pszKey);
    }

    m_Settings      = StreamSettings;
    m_fIsConfigured = TRUE;

    // setup maximum bandwidth
    HRESULT hr;
    if (m_Settings.lBandwidth != QCDEFAULT_QUALITY_UNSET)
    {
        if (FAILED (hr = Set (StreamQuality_MaxBitrate, m_Settings.lBandwidth, TAPIControl_Flags_None)))
        {
            LOG((MSP_ERROR, "stream %ws %p failed to set maximum bitrate %d. %x", m_szName, this, m_Settings.lBandwidth, hr));
        }
    }

    // if there is no terminal selected, just return.
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        return S_OK;
    }

    // set up the filters and the terminals.
    hr = SetUpFilters();

    if (FAILED(hr))
    {
        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_CONNECT_FAIL, hr);

        LOG((MSP_ERROR, "stream %ws %p set up filters failed, %x", 
            m_szName, this, hr));
        return hr;
    }

    LOG((MSP_INFO, "stream %ws %p configure exit S_OK", m_szName, this));

    return S_OK;
}

HRESULT CIPConfMSPStream::FinishConfigure()
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream FinishConfigure entered."));

    CLock lock(m_lock);
    
    if (m_fIsConfigured == FALSE)
    {
        // this stream hasn't been configured.
        return E_FAIL;
    }

    HRESULT hr;

    switch (m_dwState)
    {
    case STRM_RUNNING:
        // start the graph.
        hr = CMSPStream::StartStream();
        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
            return hr;
        }

        if (m_Terminals.GetSize() > 0)
        {
            SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_REMOTE_REQUEST);
        }

        LOG((MSP_INFO, "stream %ws %p started", m_szName, this));
        break;

    case STRM_PAUSED:
        // pause the graph.
        hr = CMSPStream::PauseStream();
        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
            return hr;
        }

        LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));
        break;

    case STRM_STOPPED:
        break;
    }

    LOG((MSP_INFO, "stream %ws %p configure exit S_OK", m_szName, this));

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::StartStream()
/*++

Routine Description:

    Start the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter Runing state. (RO)
        m_dwState = STRM_RUNNING; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter Runing state. (RO, RT)
        m_dwState = STRM_RUNNING; 

        return S_OK;
    }

    // Start the stream.
    HRESULT hr = CMSPStream::StartStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
        return hr;
    }

    SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
    LOG((MSP_INFO, "stream %ws %p started", m_szName, this));

    // Enter Runing state.(RT)
    m_dwState = STRM_RUNNING;

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::PauseStream()
/*++

Routine Description:

    Pause the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter paused state. (PO)
        m_dwState = STRM_PAUSED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter paused state. (PO, PT)
        m_dwState = STRM_PAUSED; 
        
        return S_OK;
    }

    // Start the stream.
    HRESULT hr = CMSPStream::PauseStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
        return hr;
    }

    LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));

    // Enter paused state.(PT)
    m_dwState = STRM_PAUSED;

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::StopStream()
/*++

Routine Description:

    Stop the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter stopped state. (SO)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter stopped state. (SO, ST)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    // Stop the graph.
    HRESULT hr = CMSPStream::StopStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));
        return hr;
    }

    SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);
    LOG((MSP_INFO, "stream %ws %p stopped", m_szName, this));

    // Enter stopped state.(ST)
    m_dwState = STRM_STOPPED; 

    return S_OK;
}

HRESULT CIPConfMSPStream::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    The implementation in this class checks to see if the terminal
    is th right type and direction and it only allows on terminal per
    stream.

Arguments:
    
    pTerminal - the terminal object.

*/
{
    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (Direction != TD_BIDIRECTIONAL && Direction != m_Direction)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // By default, only one terminal is supported per stream.
    if (m_Terminals.GetSize() > 0)
    {
        return TAPI_E_MAXTERMINALS;
    }

    return S_OK;
}

HRESULT CIPConfMSPStream::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    Select a terminal on the stream. The stream will start itself if it
    was in running state. See the state transition table at the beginning
    of this file.

Arguments:
    
    pTerminal - the terminal object.

Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_MAXTERMINALS
TAPI_E_INVALIDTERMINAL

--*/
{
    LOG((MSP_TRACE, "CMSPStream::SelectTerminal, %p", pTerminal));

    //
    // Check parameter.
    //
    if ( IsBadReadPtr(pTerminal, sizeof(ITTerminal) ) )
    {
        LOG((MSP_ERROR, "CIPconfMSPStream.SelectTerminal - exit E_POINTER"));

        return E_POINTER;
    }

    CLock lock(m_lock);

    // validate the terminal.
    HRESULT hr = CheckTerminalTypeAndDirection(pTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "wrong terminal. %x", hr));
        return hr;
    }

    // put the terminal into our list.
    hr = CMSPStream::SelectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "SelectTerminal on CMSPStream failed, %x", hr));
        return hr;
    }

    // At this point, the select terminal opration succeeded. All the 
    // failure cases are handled by sending events after this.

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));
        return S_OK;
    }

    //  Query IFilterChain
    CComPtr<IFilterChain> pIFilterChain;
    hr = m_pIMediaControl->QueryInterface(
        __uuidof(IFilterChain), 
        (void**)&pIFilterChain
        );

    if (FAILED (hr) && (hr != E_NOINTERFACE))
    {
        LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
        return hr;
    }
    
//#ifdef DYNGRAPH
    OAFilterState FilterState;
    hr = m_pIMediaControl->GetState(0, &FilterState);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p GetState failed, %x", m_szName, this, hr));
        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
        return S_OK;
    }
//#endif

// #ifndef DYNGRAPH
    if (!(m_dwMediaType == TAPIMEDIATYPE_VIDEO &&
          m_Direction == TD_RENDER &&
          pIFilterChain != NULL))
    {
        // stop the graph before making changes.
        hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));

            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            return S_OK;
        }

        // do not duplicate stream inactive if it is inactive
        //if (FilterState == State_Running)
        //{
            // no need to send stream inactive at all

            // SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        //}
    }        
// #endif

    // connect the new terminal into the graph. 
    // this method will send events if the terminal failed.
    hr = ConnectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p connect to terminal failed, %x", 
            m_szName, this, hr));

        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_CONNECT_FAIL, hr);

        return S_OK;
    }

    // if not video receive or no dynamic graph
    // after connecting the termanal, go back to the original state.
    switch  (m_dwState)
    {
    case STRM_RUNNING:
        {
            // if dynamic graph and was running, then do nothing
            if (m_dwMediaType == TAPIMEDIATYPE_VIDEO &&
                m_Direction == TD_RENDER &&
                pIFilterChain != NULL &&
                FilterState == State_Running)
                break;

            // start the stream.
            hr = CMSPStream::StartStream();
    
            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "stream %ws %p failed, %x", m_szName, this, hr));
                SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
                break;
            }

            SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        }
        break;

    case STRM_PAUSED:
        {
            // pause the stream.
            hr = CMSPStream::PauseStream();
            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "stream %ws %p failed, %x", m_szName, this, hr));
                SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            }

        }    
        break;
    }

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::UnselectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

  Unselect a terminal from the stream. It handles changing the graph and
  going back to the original state.

Arguments:
    

Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_MAXTERMINALS
TAPI_E_INVALIDTERMINAL

--*/
{
    LOG((MSP_TRACE, 
        "CIPConfMSPStream::UnselectTerminal, pTerminal %p", pTerminal));

    CLock lock(m_lock);
    int index;

    if ((index = m_Terminals.Find(pTerminal)) < 0)
    {
        LOG((MSP_ERROR, "UnselectTerminal - exit TAPI_E_INVALIDTERMINAL"));
    
        return TAPI_E_INVALIDTERMINAL;
    }

    HRESULT hr;

    //
    // Unregister the PTEventSink object
    //

    hr = UnregisterPluggableTerminalEventSink( pTerminal );

    if( FAILED(hr) )
    {
        LOG((MSP_TRACE, "stream %ws %p something wrong in UnregisterPluggableTerminalEventSink, %x",
             m_szName, this, hr));
    }

    // if the stream is not configured, just remove it and return.
    if (!m_fIsConfigured)
    {
        if (!m_Terminals.RemoveAt(index))
        {
            LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
                "exit E_UNEXPECTED"));
    
            return E_UNEXPECTED;
        }

        // release the refcount that was in our list.
        pTerminal->Release();

        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));
        return S_OK;
    }
    
//#ifdef DYNGRAPH
    OAFilterState FilterState;
    hr = m_pIMediaControl->GetState(0, &FilterState);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p GetState failed, %x", m_szName, this, hr));
        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
        return S_OK;
    }
//#endif

    CComPtr <IFilterChain> pIFilterChain;

    hr = m_pIMediaControl->QueryInterface(
        __uuidof(IFilterChain), 
        (void**)&pIFilterChain
        );

    if (FAILED (hr) && (hr != E_NOINTERFACE))
    {
        LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
        return hr;
    }

// #ifndef DYNGRAPH
    if (!(m_dwMediaType == TAPIMEDIATYPE_VIDEO &&
          m_Direction == TD_RENDER &&
          pIFilterChain != NULL))
    {
        // stop the graph before making changes.
        hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));

            return hr;
        }

        if (FilterState == State_Running)
        {
            SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        }
    }    
// #endif
       
    // disconnect the terminal from the graph. 
    // this method will send events if the terminal failed.
    hr = DisconnectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p disconnectTerminal failed, %x", 
            m_szName, this, hr));

        return hr;
    }

    if (!m_Terminals.RemoveAt(index))
    {
        LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
            "exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    // release the refcount that was in our list.
    pTerminal->Release();

    // if there is no terminal selected, just return and wait for terminals.
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));
        return S_OK;
    }

    // At this point, the Unselect terminal opration succeeded. All the 
    // failure cases are handled by sending events after this.

    // after disconnecting the termanal, go back to the original state.

    if (!(m_dwMediaType == TAPIMEDIATYPE_VIDEO &&
          m_Direction == TD_RENDER &&
          pIFilterChain != NULL))
    {
        switch  (FilterState)
        {
        case State_Running:
            {
                // start the stream.
                hr = CMSPStream::StartStream();
                if (FAILED(hr))
                {
                    LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
                    SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
                    break;
                }

                SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
            }

            break;

        case State_Paused:
            {
                // pause the stream.
                hr = CMSPStream::PauseStream();
                if (FAILED(hr))
                {
                    LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
                    SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
                }
            }
            break;
        }
    }

    return S_OK;
}

HRESULT CIPConfMSPStream::ShutDown()
/*++

Routine Description:

    Shut down the stream. It release the filters and terminals.

Arguments:
    

Return Value:

S_OK

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream::Shutdown %ws - enter", m_szName));

    CLock lock(m_lock);

    for (int j = 0; j < NUM_SDES_ITEMS; j ++)
    {
        if (m_InfoItems[j])
        {
            free(m_InfoItems[j]);
            m_InfoItems[j] = NULL;
        }
    }

    // unlink by stream
    HRESULT hr;
    if (FAILED (hr = UnlinkInnerCallQC (TRUE)))
        LOG ((MSP_ERROR, "CH323MSPStream::ShutDown failed to unlink on call qc, %x", hr));

    if (m_pMSPCall)
    {
        m_pMSPCall->MSPCallRelease();
        m_pMSPCall  = NULL;
    }

    // free the extra filter reference.
    if (m_pIRTPDemux)
    {
        m_pIRTPDemux->Release();
        m_pIRTPDemux = NULL;
    }

    if (m_pIRTPSession)
    {
        m_pIRTPSession->Release();
        m_pIRTPSession = NULL;
    }

    if (m_pIStreamConfig)
    {
        m_pIStreamConfig->Release();
        m_pIStreamConfig = NULL;
    }

    if (m_szKey)
    {
        free(m_szKey);
        m_szKey = NULL;
    }

    // If the stream is not configured, just free the terminals.
    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
        {
            m_Terminals[i]->Release();
        }
        m_Terminals.RemoveAll();

        return S_OK;
    }

    // if there are terminals and configured, we need to disconnect 
    // the terminals.
    if (m_Terminals.GetSize() > 0)
    {
        // Stop the graph before disconnecting the terminals.
        HRESULT hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "stream %ws %p failed to stop, %x", m_szName, this, hr));
            return hr;
        }

        for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
        {
            hr = DisconnectTerminal(m_Terminals[i]);
            LOG((MSP_TRACE, "Disconnect terminal returned %x", hr));

            m_Terminals[i]->Release();
        }
        m_Terminals.RemoveAll();
    }

    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        m_Participants[i]->Release();
    }
    m_Participants.RemoveAll();

    LOG((MSP_TRACE, "CIPConfMSPStream::Shutdown - exit S_OK"));

    return S_OK;
}

HRESULT CIPConfMSPStream::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminalControl(pITTerminal);
    if (pTerminalControl == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));
        return E_NOINTERFACE;
    }

    HRESULT hr = pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

    LOG((MSP_TRACE, "terminal %p is disonnected. hr:%x", pITTerminal, hr));

    return hr;
}

HRESULT CIPConfMSPStream::EnableParticipantEvents(
    IN IRtpSession * pRtpSession
    )
/*++

Routine Description:

    Enable participant information, such as join, leave, info change,
    talking, silence, etc.

Arguments:
    
    pRtpSession - The RTP sesion pointer.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableParticipantEvents");
    LOG((MSP_TRACE, "%s entered for %ws", __fxName, m_szName));

    HRESULT hr;
    DWORD dwEnabledMask;   

    if (m_Direction == TD_RENDER)
    {
        // enable participant state events.
        DWORD dwParticipantInfoMask = 
            RTPPARINFO_MASK_STALL |
            RTPPARINFO_MASK_BYE |
            RTPPARINFO_MASK_DEL;

        if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
        {
            // watch for active talkers
            dwParticipantInfoMask |= 
                RTPPARINFO_MASK_TALKING |
                RTPPARINFO_MASK_WAS_TALKING;
        }
        else
        {
            // watch for video Senders
            dwParticipantInfoMask |= 
                RTPPARINFO_MASK_TALKING |
                RTPPARINFO_MASK_SILENT |
                RTPPARINFO_MASK_MAPPED |
                RTPPARINFO_MASK_UNMAPPED;
        }

        hr = pRtpSession->ModifySessionMask(
            RTPMASK_PINFOR_EVENTS,
            dwParticipantInfoMask,
            1,
            &dwEnabledMask
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, modify pinfo failed. %x", __fxName, hr));
            return hr;
        }

        // enable participant information events.
        DWORD dwSDESMask = 
            RTPSDES_MASK_CNAME |
            RTPSDES_MASK_NAME |
            RTPSDES_MASK_EMAIL |
            RTPSDES_MASK_PHONE |
            RTPSDES_MASK_LOC |
            RTPSDES_MASK_TOOL |
            RTPSDES_MASK_NOTE |
            RTPSDES_MASK_PRIV;

        // tell RTP to save these items for retrieval 
        hr = pRtpSession->ModifySessionMask(
            RTPMASK_SDES_REMMASK,
            dwSDESMask,
            1,
            &dwEnabledMask
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, modify sdes mask for receiver failed. %x",
                __fxName, hr));
            return hr;
        }

        // tell RTP to fire events when it gets these items.
        hr = pRtpSession->ModifySessionMask(
            RTPMASK_SDESRECV_EVENTS,
            dwSDESMask,
            1,
            &dwEnabledMask
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, modify sdes mask for receiver failed. %x",
                __fxName, hr));
            return hr;
        }
    }
    else
    {
        // enable the sending of local SDES information.
        DWORD dwLocalSDESMask = 
            RTPSDES_LOCMASK_CNAME |
            RTPSDES_LOCMASK_NAME |
            RTPSDES_LOCMASK_EMAIL |
            RTPSDES_LOCMASK_PHONE |
            RTPSDES_LOCMASK_LOC |
            RTPSDES_LOCMASK_TOOL |
            RTPSDES_LOCMASK_NOTE |
            RTPSDES_LOCMASK_PRIV;

        hr = pRtpSession->ModifySessionMask(
            RTPMASK_SDES_LOCMASK,
            dwLocalSDESMask,
            1,
            &dwEnabledMask
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, modify sdes mask for local SDES failed. %x", 
                __fxName, hr));
            return hr;
        }
    }

    return hr;
}

HRESULT CIPConfMSPStream::EnableQOS(
    IN IRtpSession * pRtpSession
    )
/*++

Routine Description:

    Enable qos reservation and qos events

Arguments:
    
    pRtpSession - The RTP sesion pointer.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableQOS");
    LOG((MSP_TRACE, "%s entered for %ws", __fxName, m_szName));

    HRESULT hr;

    // set the QOS application IDs.
    if (m_Settings.pApplicationID ||
        m_Settings.pSubIDs ||
        m_Settings.pApplicationGUID)
    {
        if (FAILED(hr = pRtpSession->SetQosAppId(
            m_Settings.pApplicationID,
            m_Settings.pApplicationGUID,    
            m_Settings.pSubIDs
            )))
        {
            LOG((MSP_ERROR, "%s, set qos application id. %x", __fxName, hr));
            return hr;
        }
    }
    
    TCHAR * szQOSName;
    DWORD dwMaxParticipant = 5; // default to 5

    switch (m_Settings.PayloadTypes[0])
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        szQOSName       = RTPQOSNAME_G711;
        break;

    case PAYLOAD_GSM:
        szQOSName       = RTPQOSNAME_GSM6_10;
        break;

    case PAYLOAD_DVI4_8:
        szQOSName       = RTPQOSNAME_DVI4_8;
        break;

    case PAYLOAD_DVI4_16:
        szQOSName       = RTPQOSNAME_DVI4_16;
        break;

    case PAYLOAD_MSAUDIO:
        szQOSName       = RTPQOSNAME_MSAUDIO;
        break;

    case PAYLOAD_H261:
        szQOSName = (m_Settings.fCIF) ? RTPQOSNAME_H261CIF : RTPQOSNAME_H261QCIF;
        dwMaxParticipant = 40; // 40 for video
        break;

    case PAYLOAD_H263:
        szQOSName = (m_Settings.fCIF) ? RTPQOSNAME_H263CIF : RTPQOSNAME_H263QCIF;
        dwMaxParticipant = 40; // 40 for video
        break;

    default:
        LOG((MSP_WARN, "Don't know the QOS name for payload type: %d", 
            m_Settings.PayloadTypes[0]));
        return E_FAIL;
    }

    // use shared explicit for video. 
    DWORD dwStyle = (m_dwMediaType == TAPIMEDIATYPE_VIDEO)
        ? RTPQOS_STYLE_SE : RTPQOS_STYLE_DEFAULT;

    hr = pRtpSession->SetQosByName(
        szQOSName,
        dwStyle,
        dwMaxParticipant,           // start from 40 participant reservation.
        RTPQOSSENDMODE_REDUCED_RATE,
        m_Settings.dwMSPerPacket? m_Settings.dwMSPerPacket:~0
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetQosByName failed. %x", __fxName, hr));
        return hr;
    }

    // enable qos events.
    DWORD dwQOSEventMask = 
        RTPQOS_MASK_ADMISSION_FAILURE |
        RTPQOS_MASK_POLICY_FAILURE |
        RTPQOS_MASK_BAD_STYLE |
        RTPQOS_MASK_BAD_OBJECT |
        RTPQOS_MASK_TRAFFIC_CTRL_ERROR |
        RTPQOS_MASK_GENERIC_ERROR |
        RTPQOS_MASK_NOT_ALLOWEDTOSEND |
        RTPQOS_MASK_ALLOWEDTOSEND;

    DWORD dwEnabledMask;   
    hr = pRtpSession->ModifySessionMask(
        (m_Direction == TD_RENDER) ? RTPMASK_QOSRECV_EVENTS : RTPMASK_QOSSEND_EVENTS,
        dwQOSEventMask,
        1,
        &dwEnabledMask
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, modify qos event mask failed. %x", __fxName, hr));
        return hr;
    }

    return hr;
}

HRESULT CIPConfMSPStream::EnableEncryption(
    IN IRtpSession * pRtpSession,
    IN WCHAR *pPassPhrase
    )
/*++

Routine Description:

    Enable RTP encryption.

Arguments:
    
    pRtpSession - The RTP sesion pointer.

    pPassPhrase - the pass phrase to generate the key.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableEncryption");
    LOG((MSP_TRACE, "%s entered for %ws", __fxName, m_szName));

    // enable RTP payload encryption.
    HRESULT hr = pRtpSession->SetEncryptionMode(
        RTPCRYPTMODE_RTP,
        RTPCRYPT_SAMEKEY
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetEncryptionMode failed. %x", __fxName, hr));
        return hr;
    }

    // set the key
    hr = pRtpSession->SetEncryptionKey(
        pPassPhrase,
        NULL,   // default hash algorithm, MD5
        NULL,   // default encrypt algorithm, DES
        FALSE   // RTCP?
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetEncryptionKey. %x", __fxName, hr));
        return hr;
    }

    return hr;
}

HRESULT CIPConfMSPStream::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clcokrate, etc.

Arguments:
    
    pIBaseFilter - The RTP Filter.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::ConfigureRTPFilter");
    LOG((MSP_TRACE, "%s entered for %ws", __fxName, m_szName));

    _ASSERT (m_pIRTPSession == NULL);

    // get the session interface pointer.
    HRESULT hr = pIBaseFilter->QueryInterface(&m_pIRTPSession);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, query IRtpSession failed. hr=%x", __fxName, hr));
        return hr;
    }

    // Initialize the RTP session.
    DWORD dwFlags;
    
    switch(m_dwMediaType)
    {
    case TAPIMEDIATYPE_AUDIO:
        dwFlags = RTPINIT_CLASS_AUDIO;
        break;
    case TAPIMEDIATYPE_VIDEO:
        dwFlags = RTPINIT_CLASS_VIDEO;
        break;
    default:
        dwFlags = RTPINIT_CLASS_DEFAULT;
    }

    dwFlags |= RTPINIT_ENABLE_QOS;
    
    hr = m_pIRTPSession->Init(m_Settings.phRTPSession, dwFlags);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, Init RTP session failed. hr=%x", __fxName, hr));
        return hr;
    }

    // set the RTP/RTCP ports.
    hr = m_pIRTPSession->SetPorts(
        htons(m_Settings.wRTPPortRemote),   // local RTP port.
        htons(m_Settings.wRTPPortRemote),   // remote RTP port.
        htons(m_Settings.wRTPPortRemote + 1),   // local RTCP port.
        htons(m_Settings.wRTPPortRemote + 1)    // remote RTCP port.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, Set ports failed. hr=%x", __fxName, hr));
        return hr;
    }

    // set the destination address.
    hr = m_pIRTPSession->SetAddress(
        htonl(m_Settings.dwIPLocal),        // local IP.
        htonl(m_Settings.dwIPRemote)        // remote IP.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, Set Address failed. hr=%x", __fxName, hr));
        return hr;
    }

    // Set the TTL used in the filter.
    if (FAILED(hr = m_pIRTPSession->SetScope(m_Settings.dwTTL, 3)))
    {
        LOG((MSP_ERROR, "%s, SetScope failed. %x", __fxName, hr));
        return hr;
    }

    // Set the loopback mode used in the filter.
    DWORD dwRTPLoopbackMode;
    switch (m_Settings.LoopbackMode)
    {
    case MM_NO_LOOPBACK:
        dwRTPLoopbackMode = RTPMCAST_LOOPBACKMODE_NONE;
        break;
    case MM_FULL_LOOPBACK:
        dwRTPLoopbackMode = RTPMCAST_LOOPBACKMODE_FULL;
        break;
    case MM_SELECTIVE_LOOPBACK:
        dwRTPLoopbackMode = RTPMCAST_LOOPBACKMODE_PARTIAL;
        break;
    default:
        dwRTPLoopbackMode = RTPMCAST_LOOPBACKMODE_NONE;
        break;
    }

    if (FAILED(hr = m_pIRTPSession->SetMcastLoopback(dwRTPLoopbackMode, 0)))
    {
        LOG((MSP_ERROR, "set loopback mode failed. %x", hr));
        return hr;
    }

    // enable participant events
    if (FAILED(hr = EnableParticipantEvents(m_pIRTPSession)))
    {
        LOG((MSP_ERROR, "%s, EnableParticipantEvents failed. %x", __fxName, hr));
        return hr;
    }


    // Enable QOS.
    if (m_Settings.dwQOSLevel != QSL_BEST_EFFORT)
    {
        if (FAILED(hr = EnableQOS(m_pIRTPSession)))
        {
            LOG((MSP_ERROR, "%s, EnableQOS failed. %x", __fxName, hr));
            return hr;
        }
    }

    // Enable Encryption.
    if (m_szKey)
    {
        if (FAILED(hr = EnableEncryption(m_pIRTPSession, m_szKey)))
        {
            LOG((MSP_ERROR, "%s, EnableEncryption failed. %x", __fxName, hr));
            return hr;
        }
    }
    
    // Set local SDES info
    if (FAILED(hr = SetLocalInfoOnRTPFilter(NULL)))
    {
        LOG((MSP_ERROR, "%s, SetLocalInfoOnRTPFilter failed. %x", __fxName, hr));
        return hr;
    }
    
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessNewParticipant(
    IN  int                 index,
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv,
    IN  WCHAR *             szCName,
    OUT ITParticipant **    ppITParticipant
    )
{
    if (!m_Participants.HasSpace())
    {
        if (!m_Participants.Grow())
        {
            LOG((MSP_ERROR, "Out of mem for participant list"));
    
            return E_OUTOFMEMORY;
        }
    }

    // create a new participant if it is not in the list.
    HRESULT hr = ((CIPConfMSPCall *)m_pMSPCall)->NewParticipant(
        (ITStream *)this,
        dwSSRC,
        dwSendRecv,
        m_dwMediaType,
        szCName,
        ppITParticipant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "new participant returns %x", hr));
        
        return hr;
    }

    // insert the new participant at the index where the search
    // stopped. The list is ordered by CName. We know the list has
    // space, this function will not fail.
    m_Participants.InsertAt(index, *ppITParticipant);

    LOG((MSP_INFO, "%ws new participant %s", m_szName, szCName));

    (*ppITParticipant)->AddRef();

    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessSDESUpdate(
    IN  DWORD               dwInfoItem,
    IN  DWORD               dwSSRC
    )
/*++

Routine Description:

    Process SDES info updates, create a participant if necessary. If a new
    participant is created, a new participant event will be fired. If the
    participant already exists, the new report is compared with the current
    information, if anything changes, a info change event will be fired. 

Arguments:
    
    dwInfoItem - the info type. of this participant.

    dwSSRC - the SSRC of this participant.

    dwSendRecv - a sender report or a receiver report.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::ProcessSDESUpdate");
    LOG((MSP_TRACE, "%s entered for %ws, SSRC:%x", __fxName, m_szName, dwSSRC));

    if (dwInfoItem < RTPSDES_CNAME || RTPSDES_CNAME > RTPSDES_PRIV)
    {
        return E_INVALIDARG;
    }

    CLock Lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));

        return S_OK;
    }
    
    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "ProcessSDESUpdate RTP filter is NULL"));
        return E_UNEXPECTED;
    }

    // first get the CName of the participant.
    WCHAR Buffer[MAX_PARTICIPANT_TYPED_INFO_LENGTH + 1];
    DWORD dwLen = MAX_PARTICIPANT_TYPED_INFO_LENGTH; 

    HRESULT hr = m_pIRTPSession->GetSdesInfo(
        RTPSDES_CNAME,
        Buffer,
        &dwLen,
        dwSSRC
        );

    if (FAILED(hr) || dwLen == 0)
    {
        LOG((MSP_ERROR, "can't get CName for ssrc:%x. %x", dwSSRC, hr));
        return hr;
    }

    ITParticipant * pITParticipant;
    BOOL fChanged = FALSE;
    BOOL fNewParticipant = FALSE;
    
    CParticipant * pParticipant;
        
    // find out if the participant is in our list.
    int index;
    if (m_Participants.FindByCName(Buffer, &index))
    {
        pITParticipant = m_Participants[index];

        // addref to keep it after unlock;
        pITParticipant->AddRef();

        pParticipant = (CParticipant *)pITParticipant;
    }
    else
    {
        hr = ProcessNewParticipant(
            index,
            dwSSRC,
            PART_RECV,
            Buffer,
            &pITParticipant
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "new participant returns %x", hr));
            return hr;
        }

        pParticipant = (CParticipant *)pITParticipant;
    
        // There might be things the stream needs to do with the new participant
        NewParticipantPostProcess(dwSSRC, pITParticipant);

        // a new stream is added into the participant's list
        // fire a info changed event.
        fChanged = TRUE;

        fNewParticipant = TRUE;
    }

    // update the information of the participant.

    // just in case the SSRC changed.
    pParticipant->UpdateSSRC(
        (ITStream *)this,
        dwSSRC,
        PART_RECV
        );

    if (dwInfoItem > RTPSDES_CNAME && dwInfoItem < RTPSDES_ANY)
    {
        dwLen = MAX_PARTICIPANT_TYPED_INFO_LENGTH;

        hr = m_pIRTPSession->GetSdesInfo(
            dwInfoItem,
            Buffer,
            &dwLen,
            dwSSRC
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get sdes data for ssrc:%x. %x", dwSSRC, hr));
            return hr;
        }

        fChanged = fChanged || pParticipant->UpdateInfo(
            dwInfoItem,
            dwLen,
            Buffer
            );
    }

    if(fChanged)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->
            SendParticipantEvent(PE_INFO_CHANGE, pITParticipant);
    }

    if (fNewParticipant &&
        (m_dwMediaType & TAPIMEDIATYPE_VIDEO))
    {
        // check if participant is talking
        DWORD dwState = 0;

        hr = m_pIRTPSession->GetParticipantState(dwSSRC, &dwState);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Get participant state. %x", hr));
        }
        else
        {
            if (dwState == (DWORD)RTPPARINFO_TALKING)
            {
                // was talking
                ProcessTalkingEvent(dwSSRC);
            }
        }
    }

    pITParticipant->Release();
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessParticipantLeave(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    return E_NOTIMPL;
#if 0
    LOG((MSP_TRACE, "ProcessParticipantLeave, SSRC: %x", dwSSRC));
    
    m_lock.Lock();
    
    CParticipant *pParticipant;
    BOOL fLast = FALSE;

    HRESULT hr = E_FAIL;

    // first try to find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        pParticipant = (CParticipant *)m_Participants[i];
        hr = pParticipant->RemoveStream(
                (ITStream *)this,
                dwSSRC,
                &fLast
                );
        
        if (SUCCEEDED(hr))
        {
            break;
        }
    }

    // if the participant is not found
    if (FAILED(hr))
    {
        LOG((MSP_TRACE, "SSRC:%x had been removed.", dwSSRC));

        m_lock.Unlock();
        
        return hr;
    }

    ITParticipant *pITParticipant = m_Participants[i];

    m_Participants.RemoveAt(i);

    // if this stream is the last stream that the participant is on,
    // tell the call object to remove it from its list.
    if (fLast)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->ParticipantLeft(pITParticipant);
    }

    m_lock.Unlock();

    pITParticipant->Release();

    return S_OK;
#endif
}

HRESULT CIPConfMSPStream::ProcessParticipantTimeOutOrRecovered(
    IN  BOOL    fTimeOutOrRecovered,
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When RTP detects a timeout for a certain participant, the msp needs to
    notify the app about it.

Arguments:
    
    dwSSRC - the SSRC of the participant that times out.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "ProcessParticipantTimeOutOrRecovered, SSRC: %x", dwSSRC));
    
    ITParticipant *pITParticipant = NULL;

    CLock Lock(m_lock);
    
    // find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            pITParticipant->AddRef();
            break;
        }
    }

    // if the participant is not found
    if (pITParticipant == NULL)
    {
        LOG((MSP_ERROR, "can't find the SSRC", dwSSRC));

        return S_OK;
    }

    // get stream state
    HRESULT hr;
    DWORD prevState;
    if (FAILED (hr = ((CParticipant *)m_Participants[i])->GetStreamState (
        (ITStream *)this, &prevState)))
    {
        LOG ((MSP_ERROR, "failed to get stream state. %x", hr));
        pITParticipant->Release ();
        return S_OK;
    }

    // check if we need to change state
    if (prevState & (fTimeOutOrRecovered ? PESTREAM_TIMEOUT : PESTREAM_RECOVER))
    {
        pITParticipant->Release ();
        return S_OK;
    }

    // set stream state
    hr = ((CParticipant *)m_Participants[i])->SetStreamState (
        (ITStream *)this,
        fTimeOutOrRecovered ? PESTREAM_TIMEOUT : PESTREAM_RECOVER);

    if (FAILED (hr))
    {
        LOG ((MSP_ERROR, "failed to set stream state, %x", hr));
        pITParticipant->Release ();
        return S_OK;
    }

    // check if we need to report to app
    INT iStreamCount = ((CParticipant *)m_Participants[i])->GetStreamCount (PART_SEND);

    INT iTimeOutCount = ((CParticipant *)m_Participants[i])->GetStreamTimeOutCount (PART_SEND);

    if ((fTimeOutOrRecovered && (iStreamCount == iTimeOutCount)) ||       // fire timeout event
        (!fTimeOutOrRecovered && (iStreamCount == iTimeOutCount + 1)))    // fire recover event
    {
        ((CIPConfMSPCall *)m_pMSPCall)->
            SendParticipantEvent(
                fTimeOutOrRecovered ? PE_PARTICIPANT_TIMEOUT : PE_PARTICIPANT_RECOVERED, 
                pITParticipant
                );
    }

    pITParticipant->Release();

    return S_OK;
}

HRESULT CIPConfMSPStream::NewParticipantPostProcess(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
{
    // This function does nothing. The derived class will do the work.
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessQOSEvent(
    IN  long lEventCode
    )
{
    CLock lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    switch (lEventCode)
    {
    case RTPQOS_EVENT_NOQOS:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_NOQOS, 
            m_dwMediaType
            );
        break;

    case RTPQOS_EVENT_RECEIVERS:
    case RTPQOS_EVENT_SENDERS:
    case RTPQOS_EVENT_NO_SENDERS:
    case RTPQOS_EVENT_NO_RECEIVERS:
        break;
    
    case RTPQOS_EVENT_REQUEST_CONFIRMED:
        break;
    
    case RTPQOS_EVENT_ADMISSION_FAILURE:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_ADMISSIONFAILURE, 
            m_dwMediaType
            );
        break;
    
    case RTPQOS_EVENT_POLICY_FAILURE:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_POLICYFAILURE, 
            m_dwMediaType
            );
        break;

    case RTPQOS_EVENT_BAD_STYLE:
    case RTPQOS_EVENT_BAD_OBJECT:
    case RTPQOS_EVENT_TRAFFIC_CTRL_ERROR:
    case RTPQOS_EVENT_GENERIC_ERROR:
   
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_GENERICERROR, 
            m_dwMediaType
            );
        break;
    
    case RTPQOS_EVENT_NOT_ALLOWEDTOSEND:
        m_pStreamQCRelay->m_fQOSAllowedToSend = FALSE;
        break;
    
    case RTPQOS_EVENT_ALLOWEDTOSEND:
        m_pStreamQCRelay->m_fQOSAllowedToSend = TRUE;
        break;
    }
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessTalkingEvent(
    IN  DWORD   dwSSRC
    )
{
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessWasTalkingEvent(
    IN  DWORD   dwSSRC
    )
{
    return S_OK;
}


HRESULT CIPConfMSPStream::ProcessSilentEvent(
    IN  DWORD   dwSSRC
    )
{
    return S_OK;
}


HRESULT CIPConfMSPStream::ProcessPinMappedEvent(
    IN  DWORD   dwSSRC,
    IN  IPin *  pIPin
    )
{
    return S_OK;
}


HRESULT CIPConfMSPStream::ProcessPinUnmapEvent(
    IN  DWORD   dwSSRC,
    IN  IPin *  pIPin
    )
{
    return S_OK;
}


HRESULT CIPConfMSPStream::ProcessGraphEvent(
    IN  long lEventCode,
    IN  LONG_PTR lParam1,
    IN  LONG_PTR lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d 0x%x 0x%x", m_szName, lEventCode, lParam1, lParam2));

    switch (lEventCode)
    {

    // These events are designed to solve the problem of mapping video 
    // windows to incoming streams. The app needs to know which window 
    // should be painted. Whenever the rtp outpin maps an SSRC  to a pin to 
    // stream data, it sends a MAPPED event. The first parameter is the 
    // SSRC and the second parameter is the output pin of the demux.
    // When the demux stops using a pin, it sends a UNMAPPED event.

    case RTPPARINFO_EVENT_TALKING:

        ProcessParticipantTimeOutOrRecovered(FALSE, (DWORD)lParam1);
        ProcessTalkingEvent((DWORD)lParam1);

        break;

    case RTPPARINFO_EVENT_WAS_TALKING:
        
        ProcessWasTalkingEvent((DWORD)lParam1);

        break;

    case RTPPARINFO_EVENT_SILENT:

        ProcessSilentEvent((DWORD)lParam1);

        break;

    case RTPPARINFO_EVENT_MAPPED:
        
        ProcessPinMappedEvent((DWORD)lParam1, (IPin *)lParam2);

        break;

    case RTPPARINFO_EVENT_UNMAPPED:

        ProcessPinUnmapEvent((DWORD)lParam1, (IPin *)lParam2);

        break;

    case RTPPARINFO_EVENT_STALL:

        ProcessParticipantTimeOutOrRecovered(TRUE, (DWORD)lParam1);
        
        break;

    case RTPPARINFO_EVENT_BYE:
    case RTPPARINFO_EVENT_DEL:

        // lparam1 is the SSRC
        ProcessParticipantLeave((DWORD)lParam1);
        
        break;

    case EC_COMPLETE:
    case EC_USERABORT:

        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_UNKNOWN);
        
        break;

    case EC_ERRORABORT:
    case EC_STREAM_ERROR_STOPPED:
    case EC_STREAM_ERROR_STILLPLAYING:
    case EC_ERROR_STILLPLAYING:

        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, (HRESULT) lParam1);
        break;
    
    case RTPSDES_EVENT_CNAME:
    case RTPSDES_EVENT_NAME:
    case RTPSDES_EVENT_EMAIL:
    case RTPSDES_EVENT_PHONE:
    case RTPSDES_EVENT_LOC:
    case RTPSDES_EVENT_TOOL:
    case RTPSDES_EVENT_NOTE:
    case RTPSDES_EVENT_PRIV:
    case RTPSDES_EVENT_ANY:
    
        ProcessSDESUpdate(lEventCode - RTPSDES_EVENTBASE, (DWORD)lParam1);
        break;

    case RTPQOS_EVENT_ALLOWEDTOSEND:

        m_lock.Lock();

        if (m_Terminals.GetSize() > 0)
        {
            SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_QUALITY_OF_SERVICE);
        }

        m_lock.Unlock();

        ProcessQOSEvent (lEventCode);

        break;

    case RTPQOS_EVENT_NOT_ALLOWEDTOSEND:

        m_lock.Lock();

        if (m_Terminals.GetSize() > 0)
        {
            SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_QUALITY_OF_SERVICE);
        }

        m_lock.Unlock();

        ProcessQOSEvent (lEventCode);

        break;

    default:
        if ((lEventCode >= RTPQOS_EVENT_NOQOS)
            && (lEventCode <= RTPQOS_EVENT_ALLOWEDTOSEND))
        {
            ProcessQOSEvent(lEventCode);
        }

        break;
    }

    LOG((MSP_TRACE, "TRACE:CIPConfMSPStream::ProcessGraphEvent - exit S_OK"));
    return S_OK;
}

HRESULT CIPConfMSPStream::SetLocalInfoOnRTPFilter(
    IN  IBaseFilter *   pRTPFilter
    )
{
    _ASSERT(m_pIRTPSession != NULL);

    HRESULT hr = S_OK;
    for (int i = 0; i < NUM_SDES_ITEMS; i ++)
    {
        if (m_InfoItems[i] != NULL)
        {
            hr = m_pIRTPSession->SetSdesInfo(
                    RTPSDES_CNAME + i,
                    m_InfoItems[i]
                    );

            if (FAILED(hr))
            {
                LOG((MSP_WARN, "%ls can't set item:%s", m_szName, m_InfoItems[i]));
            }
        }
    }

    return hr;
}

HRESULT CIPConfMSPStream::EnableParticipant(
    IN  DWORD   dwSSRC,
    IN  BOOL    fEnable
    )
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableParticipantEvents");
    LOG((MSP_TRACE, "%s entered, ssrc:%x", __fxName, dwSSRC));

    CLock Lock(m_lock);

    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "%s RTP filter is NULL", __fxName));
        return E_UNEXPECTED;
    }

    HRESULT hr = m_pIRTPSession->SetMuteState(
            dwSSRC,
            fEnable
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetMuteState failed, hr=%x", __fxName, hr));
    }

    return hr;
}

HRESULT CIPConfMSPStream::GetParticipantStatus(
    IN  DWORD   dwSSRC,
    IN  BOOL *  pfEnable
    )
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableParticipantEvents");
    LOG((MSP_TRACE, "%s entered, ssrc:%x", __fxName, dwSSRC));

    CLock Lock(m_lock);

    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "%s RTP filter is NULL", __fxName));
        return E_UNEXPECTED;
    }

    HRESULT hr = m_pIRTPSession->GetMuteState(
            dwSSRC,
            pfEnable
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetMuteState failed, hr=%x", __fxName, hr));
    }

    return hr;
}

//    
// ITStreamQualityControl methods.
//
STDMETHODIMP CIPConfMSPStream::GetRange(
    IN  StreamQualityProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a quality control peroperty. Delegated to inner
    stream quality control

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION ("CIPConfMSPStream::GetRange (StreamQualityProperty)");

    CLock lock(m_lock);

    if (IsBadWritePtr (plMin, sizeof (long)) ||
        IsBadWritePtr (plMax, sizeof (long)) ||
        IsBadWritePtr (plSteppingDelta, sizeof (long)) ||
        IsBadWritePtr (plDefault, sizeof (long)) ||
        IsBadWritePtr (plFlags, sizeof (TAPIControlFlags)))
    {
        LOG ((MSP_ERROR, "%s: bad write pointer", __fxName));
        return E_POINTER;
    }

    *plMin = *plMax = *plSteppingDelta = *plDefault = 0;
    *plFlags = TAPIControl_Flags_None;

    // pointers is to be check by inner stream qc
    InnerStreamQualityProperty prop;

    switch (Property)
    {
    case StreamQuality_MaxBitrate:
        prop = InnerStreamQuality_MaxBitrate;
        break;

    case StreamQuality_CurrBitrate:
        prop = InnerStreamQuality_CurrBitrate;
        break;

    case StreamQuality_MinFrameInterval:
        prop = InnerStreamQuality_MinFrameInterval;
        break;

    case StreamQuality_AvgFrameInterval:
        prop = InnerStreamQuality_AvgFrameInterval;
        break;

    default:
        LOG ((MSP_ERROR, "%s (%ws) received invalid property %d", __fxName, m_szName, Property));
        return E_INVALIDARG;
    }

    return (GetRange (prop, plMin, plMax, plSteppingDelta, plDefault, plFlags));
}

STDMETHODIMP CIPConfMSPStream::Get(
    IN  StreamQualityProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a quality control peroperty. Delegated to the inner quality 
    control.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION ("CIPConfMSPStream::Get (StreamQualityProperty)");

    CLock lock(m_lock);

    if (IsBadWritePtr (plValue, sizeof (long)) ||
        IsBadWritePtr (plFlags, sizeof (TAPIControlFlags)))
    {
        LOG ((MSP_ERROR, "%s: bad write pointer", __fxName));
        return E_POINTER;
    }

    *plValue = 0;
    *plFlags = TAPIControl_Flags_None;

    // pointers is to be check by inner stream qc
    InnerStreamQualityProperty prop;

    switch (Property)
    {
    case StreamQuality_MaxBitrate:
        prop = InnerStreamQuality_MaxBitrate;
        break;

    case StreamQuality_CurrBitrate:
        prop = InnerStreamQuality_CurrBitrate;
        break;

    case StreamQuality_MinFrameInterval:
        prop = InnerStreamQuality_MinFrameInterval;
        break;

    case StreamQuality_AvgFrameInterval:
        prop = InnerStreamQuality_AvgFrameInterval;
        break;

    default:
        LOG ((MSP_ERROR, "%s (%ws) received invalid property %d", __fxName, m_szName, Property));
        return E_INVALIDARG;
    }

    return (Get (prop, plValue, plFlags));
}

STDMETHODIMP CIPConfMSPStream::Set(
    IN  StreamQualityProperty Property, 
    IN  long lValue, 
    IN  TAPIControlFlags lFlags
    )
/*++

Routine Description:
    
    Set the value for a quality control peroperty. Delegated to the quality
    controller.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION ("CIPConfMSPStream::Set (StreamQualityProperty)");

    CLock lock(m_lock);

    // pointers is to be check by inner stream qc
    InnerStreamQualityProperty prop;

    switch (Property)
    {
    case StreamQuality_MaxBitrate:
        // request a prefered value
        prop = InnerStreamQuality_PrefMaxBitrate;
        break;

    case StreamQuality_MinFrameInterval:
        prop = InnerStreamQuality_PrefMinFrameInterval;
        break;

    default:
        LOG ((MSP_ERROR, "%s (%ws) received invalid property %d", __fxName, m_szName, Property));
        return E_NOTIMPL;
    }

    return (Set (prop, lValue, lFlags));
}

/*++

Routine Description:

    This method is called by the create stream helper. It creates stream qc
    relay, stores inner call qc in the relay if this method fails, the stream
    creation should also fail.

--*/
STDMETHODIMP
CIPConfMSPStream::LinkInnerCallQC (
    IN IInnerCallQualityControl *pIInnerCallQC
    )
{
    ENTER_FUNCTION ("CIPConfMSPStream::LinkInnerCallQC");

    CLock lock(m_lock);

    if (IsBadReadPtr (pIInnerCallQC, sizeof (IInnerCallQualityControl)))
    {
        LOG ((MSP_ERROR, "%s received bad read pointer", __fxName));
        return E_POINTER;
    }

    // m_pStreamQCRelay is created here.

    if (NULL != m_pStreamQCRelay)
    {
        LOG ((MSP_ERROR, "%s was called more than once", __fxName));
        return E_UNEXPECTED;
    }

    m_pStreamQCRelay = new CStreamQualityControlRelay ();
    
    if (NULL == m_pStreamQCRelay)
    {
        LOG ((MSP_ERROR, "%s failed to create qc relay", __fxName));
        return E_OUTOFMEMORY;
    }

    // store inner call qc in stream relay
    HRESULT hr = m_pStreamQCRelay->LinkInnerCallQC (pIInnerCallQC);
    if (FAILED (hr))
    {
        LOG ((MSP_ERROR, "%s failed to call setup on qc relay. %x", __fxName, hr));
        delete m_pStreamQCRelay;
        return hr;
    }

    return S_OK;
}

/*++

Routine Description:

    This method is called when the stream is shutdown. It destroys stream
    quality control relay.

--*/
STDMETHODIMP
CIPConfMSPStream::UnlinkInnerCallQC (
    IN BOOL fByStream
    )
{
    ENTER_FUNCTION ("CIPConfMSPStream::UnlinkInnerCallQC");

    CLock lock(m_lock);

    if (NULL == m_pStreamQCRelay)
    {
        LOG ((MSP_WARN, "%s: stream qc relay is null", __fxName));
        return S_OK; // ignore
    }

    HRESULT hr;

    if (!fByStream)
    {
        // if initiated by call
        m_fAccessingQC = TRUE;

        if (FAILED (hr = m_pStreamQCRelay->UnlinkInnerCallQC (NULL)))
            LOG ((MSP_ERROR, "%s failed to unlink by call. %x", __fxName, hr));

        m_fAccessingQC = FALSE;
    }
    else
    {
        // initiated by stream
        IInnerStreamQualityControl *pIInnerStreamQC;
        hr = this->_InternalQueryInterface (
            __uuidof (IInnerStreamQualityControl),
            (void **) &pIInnerStreamQC
            );
        if (FAILED (hr))
        {
            LOG ((MSP_ERROR, "%s failed to query inner stream qc interface, %d", __fxName, hr));
            return hr;
        }

        m_fAccessingQC = TRUE;

        if (FAILED (hr = m_pStreamQCRelay->UnlinkInnerCallQC (pIInnerStreamQC)))
            LOG ((MSP_ERROR, "%s failed to unlink by stream. %x", __fxName, hr));

        m_fAccessingQC = FALSE;

        pIInnerStreamQC->Release ();
    }

    delete m_pStreamQCRelay;
    m_pStreamQCRelay = NULL;

    return hr;
}

/*++

Routine Description:

    This method is implemented by each specific stream class

--*/
STDMETHODIMP
CIPConfMSPStream::GetRange (
    IN  InnerStreamQualityProperty property,
    OUT LONG *plMin,
    OUT LONG *plMax,
    OUT LONG *plSteppingDelta,
    OUT LONG *plDefault,
    OUT TAPIControlFlags *plFlags
    )
{
    return E_NOTIMPL;
}

/*++

Routine Description:

    This method is implemented by each specific stream class

--*/
STDMETHODIMP
CIPConfMSPStream::Get(
    IN  InnerStreamQualityProperty property,
    OUT LONG *plValue,
    OUT TAPIControlFlags *plFlags
    )
{
    if (m_pStreamQCRelay)
        return m_pStreamQCRelay->Get (property, plValue, plFlags);

    return E_NOTIMPL;
}

/*++

Routine Description:

    This method is implemented by each specific stream class

--*/
STDMETHODIMP
CIPConfMSPStream::Set(
    IN  InnerStreamQualityProperty property,
    IN  LONG lValue,
    IN TAPIControlFlags lFlags
    )
{
    if (m_pStreamQCRelay)
        return m_pStreamQCRelay->Set (property, lValue, lFlags);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confpart.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confpart.h

Abstract:

    Definitions for participant related classes..

Author:

    Mu Han (muhan) 30-September-1998

--*/
#ifndef __CONFPART_H
#define __CONFPART_H

const DWORD PART_SEND = 0x0001;
const DWORD PART_RECV = 0x0002;

#define PESTREAM_FULLBITS 0xffffffff

typedef enum PESTREAM_STATE
{
    PESTREAM_RECOVER = 0x00000001,
    PESTREAM_TIMEOUT = 0x00000002

} PESTREAM_STATE;

typedef struct _STREAM_INFO
{
    DWORD       dwSSRC;
    DWORD       dwSendRecv;
    DWORD       dwState;

} STREAM_INFO;

#define NUM_SDES_ITEMS (RTPSDES_PRIV - RTPSDES_FIRST)

class ATL_NO_VTABLE CParticipant : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IDispatchImpl<ITParticipant, &__uuidof(ITParticipant), &LIBID_IPConfMSPLib>,
    public CMSPObjectSafetyImpl
{
public:

BEGIN_COM_MAP(CParticipant)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITParticipant)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(__uuidof(IMarshal), m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    CParticipant(); 

// methods of the CComObject
    virtual void FinalRelease();

// ITParticipant methods, called by the app.
    STDMETHOD (get_ParticipantTypedInfo) (
        IN  PARTICIPANT_TYPED_INFO  InfoType,
        OUT BSTR *                  ppInfo
        );

    STDMETHOD (get_MediaTypes) (
//        IN  TERMINAL_DIRECTION  Direction,
        OUT long *              plMediaTypes
        );

    STDMETHOD (put_Status) (
        IN  ITStream *          pITStream,
        IN  VARIANT_BOOL        fEnable
        );

    STDMETHOD (get_Status) (
        IN  ITStream *          pITStream,
        OUT VARIANT_BOOL *      pStatus
        );

    STDMETHOD (get_Streams) (
        OUT VARIANT * pVariant
        );

    STDMETHOD (EnumerateStreams) (
        OUT IEnumStream ** ppEnumStream
        );

// methods called by the call object.
    HRESULT Init(
        IN  WCHAR *             szCName,
        IN  ITStream *          pITStream, 
        IN  DWORD               dwSSRC,
        IN  DWORD               dwSendRecv,
        IN  DWORD               dwMediaType
        );

    BOOL UpdateInfo(
        IN  int                 Type,
        IN  DWORD               dwLen,
        IN  WCHAR *             szInfo
        );

    BOOL UpdateSSRC(
        IN  ITStream *      pITStream, 
        IN  DWORD           dwSSRC,
        IN  DWORD           dwSendRecv
        );

    BOOL HasSSRC(
        IN  ITStream *      pITStream, 
        IN  DWORD           dwSSRC
        );

    BOOL GetSSRC(
        IN  ITStream *      pITStream, 
        OUT DWORD  *        pdwSSRC
        );

    HRESULT AddStream(
        IN  ITStream *          pITStream, 
        IN  DWORD               dwSSRC,
        IN  DWORD               dwSendRecv,
        IN  DWORD               dwMediaType
        );

    HRESULT RemoveStream(
        IN  ITStream *          pITStream,
        IN  DWORD               dwSSRC,
        OUT BOOL *              pbLast
        );

    DWORD GetSendRecvStatus(
        IN  ITStream *          pITStream
        );

    HRESULT SetStreamState (
        IN ITStream *       pITStream,
        IN PESTREAM_STATE   state
        );

    HRESULT GetStreamState (
        IN ITStream *       pITStream,
        OUT DWORD *         pdwState
        );

    INT GetStreamCount (DWORD dwSendRecv);

    INT GetStreamTimeOutCount (DWORD dwSendRecv);

    int CompareCName(IN  const WCHAR *   szCName) const
    { return lstrcmpW(m_InfoItems[RTPSDES_CNAME - 1], szCName); }

    const WCHAR * Name() const
    { return m_InfoItems[RTPSDES_CNAME - 1]; }

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *                  m_pFTM;

    // The lock that protects the participant object. 
    CMSPCritSection             m_lock;

    // The list of streams that the participant is rendering on.
    CMSPArray <ITStream *>      m_Streams;

    // The list of SSRC for the partcipant in each stream.
    CMSPArray <STREAM_INFO>     m_StreamInfo;

    // the information items for this participant. The index is the 
    // value of RTP_SDES_* - 1, see MSRTP.h.
    WCHAR *                     m_InfoItems[NUM_SDES_ITEMS];

    // The media types that this participant is sending.
    DWORD                       m_dwSendingMediaTypes;

    // The media types that this participant is receiving.
    DWORD                       m_dwReceivingMediaTypes;
};

class CParticipantList : public CMSPArray<ITParticipant *>
{
public:
    BOOL HasSpace() const { return m_nSize < m_nAllocSize; }

    BOOL FindByCName(WCHAR *szCName, int *pIndex) const;

    BOOL InsertAt(int index, ITParticipant *pITParticipant);
};

class ATL_NO_VTABLE CParticipantEvent : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ITParticipantEvent, &__uuidof(ITParticipantEvent), &LIBID_IPConfMSPLib>,
    public CMSPObjectSafetyImpl
{
public:

BEGIN_COM_MAP(CParticipantEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITParticipantEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(__uuidof(IMarshal), m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

    CParticipantEvent(); 

// methods of the CComObject
    virtual void FinalRelease();
    
    STDMETHOD (get_Event) (
        OUT PARTICIPANT_EVENT * pParticipantEvent
        );
    
    STDMETHOD (get_Participant) (
        OUT ITParticipant ** ppITParticipant
        );
    
    STDMETHOD (get_SubStream) (
        OUT ITSubStream** ppSubStream
        );

// methods called by the call object.
    HRESULT Init(
        IN  PARTICIPANT_EVENT   Event,
        IN  ITParticipant *     pITParticipant,
        IN  ITSubStream *       pITSubStream
        );

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *          m_pFTM;

    PARTICIPANT_EVENT   m_Event;

    ITParticipant *     m_pITParticipant;

    ITSubStream *       m_pITSubStream;
};


class CIPConfMSPCall;

HRESULT CreateParticipantEvent(
    IN  PARTICIPANT_EVENT       Event,
    IN  ITParticipant *         pITParticipant,
    IN  ITSubStream *           pITSubStream,
    OUT IDispatch **            pIDispatch
    );

HRESULT CreateParticipantEnumerator(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    OUT IEnumParticipant ** ppEnumParticipant
    );

HRESULT CreateParticipantCollection(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    IN  int                 nSize,
    OUT VARIANT *           pVariant
    );

#endif // __CONFPART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confutil.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    MSPutil.cpp 

Abstract:

    This module contains implementation of msp utility functions.

Author:
    
    Mu Han (muhan)   1-November-1997

--*/
#include "stdafx.h"

HRESULT
AddFilter(
    IN IGraphBuilder *      pIGraph,
    IN const CLSID &        Clsid,
    IN LPCWSTR              pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    )
/*++

Routine Description:

    Create a filter and add it into the filtergraph.

Arguments:
    
    pIGraph         - the filter graph.

    Clsid           - reference to the CLSID of the filter

    pwstrName       - The name of ther filter added.

    ppIBaseFilter   - pointer to a pointer that stores the returned IBaseFilter
                      interface pointer to the newly created filter.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "AddFilter %ws", pwstrName));

    _ASSERTE(ppIBaseFilter != NULL);

    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(
            Clsid,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            __uuidof(IBaseFilter),
            (void **) ppIBaseFilter
            )))
    {
        LOG((MSP_ERROR, "create filter %x", hr));
        return hr;
    }

    if (FAILED(hr = pIGraph->AddFilter(*ppIBaseFilter, pwstrName)))
    {
        LOG((MSP_ERROR, "add filter. %x", hr));
        (*ppIBaseFilter)->Release();
        *ppIBaseFilter = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT
PinSupportsMediaType (
    IN IPin *pIPin,
    IN const GUID & MediaType
    )
/*++

Return Value:

    S_OK - media type supported
    S_FALSE - no
    other HRESULT value - error code

--*/
{
    LOG ((MSP_TRACE, "Check if the media subtype supported on pin"));

    HRESULT hr;

    // get IEnumMediaTypes on pin
    IEnumMediaTypes *pEnum = NULL;
    if (FAILED (hr = pIPin->EnumMediaTypes (&pEnum)))
    {
        LOG ((MSP_ERROR, "Failed to get IEnumMediaTypes on pin"));
        return hr;
    }

    // retrieve one media type each time
    AM_MEDIA_TYPE *pMediaType = NULL;
    ULONG cFetched;
    while (S_OK == (hr = pEnum->Next (1, &pMediaType, &cFetched)))
    {
        if (IsEqualGUID(pMediaType->majortype, MediaType))
        {
            // media subtype matched
            MSPDeleteMediaType (pMediaType);
            pEnum->Release ();
            return S_OK;
        }

        MSPDeleteMediaType (pMediaType);
    }

    pEnum->Release ();
    return hr;
}

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter
    )
/*++

Routine Description:

    Set the address of a rtp stream

Arguments:
    
    pIBaseFilter    - an rtp source filters.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "EnableRTCPEvents"));

/*
    HRESULT hr;

    // Get the IRTCPStream interface pointer on the filter.
    CComQIPtr<IRTCPStream, 
        &__uuidof(IRTCPStream)> pIRTCPStream(pIBaseFilter);
    if (pIRTCPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTCP Stream interface"));
        return E_NOINTERFACE;
    }

    // enable events.
    if (FAILED(hr = pIRTCPStream->ModifyRTCPEventMask(  
            (1 << DXMRTP_NEW_SOURCE_EVENT) |
            (1 << DXMRTP_RECV_RTCP_SNDR_REPORT_EVENT) |
            (1 << DXMRTP_RECV_RTCP_RECV_REPORT_EVENT) |
            (1 << DXMRTP_TIMEOUT_EVENT) |
            (1 << DXMRTP_BYE_EVENT)   
            , 1
            )))
    {
        LOG((MSP_ERROR, "set Address. %x", hr));
        return hr;
    }

*/    return S_OK;
}


HRESULT
SetLoopbackOption(
    IN IBaseFilter *pIBaseFilter,
    IN MULTICAST_LOOPBACK_MODE  LoopbackMode
    )
/*++

Routine Description:

    Enable of disable loopback based on registry settings.

Arguments:
    
    pIBaseFilter    - rtp source filter.

    bLoopback       - enable loopback or not.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetLoopbackOption"));

    HRESULT hr;

/*
    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, 
        &__uuidof(IRTPStream)> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    _ASSERT(MM_NO_LOOPBACK == DXMRTP_NO_MULTICAST_LOOPBACK);
    _ASSERT(MM_FULL_LOOPBACK == DXMRTP_FULL_MULTICAST_LOOPBACK);
    _ASSERT(MM_SELECTIVE_LOOPBACK == DXMRTP_SELECTIVE_MULTICAST_LOOPBACK);

    // Set the loopback mode used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastLoopBack(
            (DXMRTP_MULTICAST_LOOPBACK_MODE)LoopbackMode)))
    {
        LOG((MSP_ERROR, "set loopback. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "loopback enabled."));
    return hr;
*/
    return E_NOTIMPL;
}

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBitRate,
    IN BOOL             bFailIfNoQOS,
    IN BOOL             bReceive,
    IN DWORD            dwNumStreams,
    IN BOOL             bCIF
    )
/*++

Routine Description:

    Enable QOS.

Arguments:
    
    pIBaseFilter    - rtp source filter.

    dwPayloadType   - the rtp payload type of this stream.

    bFailIfNoQOS    - fail the stream is QOS is not available.

    bReceive        - if this stream is a receiving stream.

    dwNumStreams    - the number of streams reserved.

    bCIF            - CIF or QCIF.

Return Value:

    HRESULT

--*/
{
/*
    LOG((MSP_TRACE, "SetQOSOption"));

    char * szQOSName;
    DWORD fSharedStyle = DXMRTP_RESERVE_EXPLICIT;

    switch (dwPayloadType)
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        szQOSName       = "G711";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;

        break;

    case PAYLOAD_GSM:
        
        szQOSName       = "GSM6.10";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;
        
        break;

    case PAYLOAD_G723:
        
        szQOSName       = "G723";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;

        break;

    case PAYLOAD_H261:
        szQOSName = (bCIF) ? "H261CIF" : "H261QCIF";
        break;

    case PAYLOAD_H263:
        szQOSName = (bCIF) ? "H263CIF" : "H263QCIF";
        break;

    default:
        LOG((MSP_WARN, "Don't know the QOS name for payload type: %d", 
            dwPayloadType));
        return S_FALSE;
    }

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, 
        &__uuidof(IRTPStream)> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    HRESULT hr;

    // Enable QOS, 
    if (FAILED(hr = pIRTPStream->SetQOSByName(szQOSName, bFailIfNoQOS)))
    {
        LOG((MSP_ERROR, "set QOS by name. %x", hr));
        return hr;
    }

    // Get the IRTPParticipant interface pointer on the filter.
    CComQIPtr<IRTPParticipant,
        &__uuidof(IRTPParticipant)> pIRTPParticipant(pIBaseFilter);
    if (pIRTPParticipant == NULL)
    {
        LOG((MSP_ERROR, "get RTP participant interface"));
        return E_NOINTERFACE;
    }

    if (FAILED(hr = pIRTPParticipant->SetMaxQOSEnabledParticipants(
            (bReceive) ? dwNumStreams : 1,
            dwMaxBitRate,
            fSharedStyle 
        )))
    {
        LOG((MSP_ERROR, "SetMaxQOSEnabledParticipants. %x", hr));
        return hr;
    }

    DWORD dwQOSEventMask = 
            (1 << DXMRTP_QOSEVENT_NOQOS) |
            (1 << DXMRTP_QOSEVENT_REQUEST_CONFIRMED) |
            (1 << DXMRTP_QOSEVENT_ADMISSION_FAILURE) |
            (1 << DXMRTP_QOSEVENT_POLICY_FAILURE) |
            (1 << DXMRTP_QOSEVENT_BAD_STYLE) |
            (1 << DXMRTP_QOSEVENT_BAD_OBJECT) |
            (1 << DXMRTP_QOSEVENT_TRAFFIC_CTRL_ERROR) |
            (1 << DXMRTP_QOSEVENT_GENERIC_ERROR);

    if (bReceive)
    {
        dwQOSEventMask |= 
            (1 << DXMRTP_QOSEVENT_SENDERS) |
            (1 << DXMRTP_QOSEVENT_NO_SENDERS);
    }
    else
    {
        dwQOSEventMask |= 
            (1 << DXMRTP_QOSEVENT_RECEIVERS) |
            (1 << DXMRTP_QOSEVENT_NO_RECEIVERS) |
            (1 << DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND) |
            (1 << DXMRTP_QOSEVENT_ALLOWEDTOSEND);
    }

    // enable events.
    if (FAILED(hr = pIRTPStream->ModifyQOSEventMask(dwQOSEventMask, 1)))
    {
        LOG((MSP_ERROR, "set QOSEventMask. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "enabled qos for %s.", szQOSName));
    return hr;
*/
    return E_NOTIMPL;
}

HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree
    )
/*++

Routine Description:

    Find a input pin or output pin on a filter.

Arguments:
    
    pIFilter    - the filter that has pins.

    ppIPin      - the place to store the returned interface pointer.

    direction   - PINDIR_INPUT or PINDIR_OUTPUT.

    bFree       - look for a free pin or not.

Return Value:

    HRESULT

--*/
{
    _ASSERTE(ppIPin != NULL);

    HRESULT hr;
    DWORD dwFeched;

    // Get the enumerator of pins on the filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pIFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, "enumerate pins on the filter %x", hr));
        return hr;
    }

    IPin * pIPin = NULL;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &dwFeched) != S_OK)
        {
            LOG((MSP_ERROR, "find pin on filter."));
            return E_FAIL;
        }
        if (0 == dwFeched)
        {
            LOG((MSP_ERROR, "get 0 pin from filter."));
            return E_FAIL;
        }

        PIN_DIRECTION dir;
        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            LOG((MSP_ERROR, "query pin direction. %x", hr));
            pIPin->Release();
            return hr;
        }
        if (direction == dir)
        {
            if (!bFree)
            {
                break;
            }

            // Check to see if the pin is free.
            CComPtr<IPin> pIPinConnected;
            hr = pIPin->ConnectedTo(&pIPinConnected);
            if (pIPinConnected == NULL)
            {
                break;
            }
        }
        pIPin->Release();
    }

    *ppIPin = pIPin;

    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter1, 
    IN IBaseFilter *    pIFilter2,
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect the output pin of the first filter to the input pin of the
    second filter.

Arguments:

    pIGraph     - the filter graph.

    pIFilter1   - the filter that has the output pin.

    pIFilter2   - the filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;

    CComPtr<IPin> pIPinOutput;
    if (FAILED(hr = ::FindPin(pIFilter1, &pIPinOutput, PINDIR_OUTPUT)))
    {
        LOG((MSP_ERROR, "find output pin on filter1. %x", hr));
        return hr;
    }

    CComPtr<IPin> pIPinInput;
    if (FAILED(hr = ::FindPin(pIFilter2, &pIPinInput, PINDIR_INPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter2. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }
 
    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pIFilter,
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect an output pin to the input pin of a filter.

Arguments:
    
    pIGraph     - the filter graph.

    pIPinOutput - an output pin.

    pIFilter    - a filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;
    CComPtr<IPin> pIPinInput;

    if (FAILED(hr = ::FindPin(pIFilter, &pIPinInput, PINDIR_INPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }
    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect an filter to the input pin of a filter.

Arguments:
    
    pIGraph     - the filter graph.

    pIPinOutput - an output pin.

    pIFilter    - a filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;
    CComPtr<IPin> pIPinOutput;

    if (FAILED(hr = ::FindPin(pIFilter, &pIPinOutput, PINDIR_OUTPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }

    return S_OK;
}


void WINAPI MSPDeleteMediaType(AM_MEDIA_TYPE *pmt)
/*++

Routine Description:
    
    Delete a AM media type returned by the filters.

Arguments:

    pmt     - a pointer to a AM_MEDIA_TYPE structure.

Return Value:

    HRESULT

--*/
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    if (pmt->cbFormat != 0) {
        CoTaskMemFree((PVOID)pmt->pbFormat);

        // Strictly unnecessary but tidier
        pmt->cbFormat = 0;
        pmt->pbFormat = NULL;
    }
    if (pmt->pUnk != NULL) {
        pmt->pUnk->Release();
        pmt->pUnk = NULL;
    }

    CoTaskMemFree((PVOID)pmt);
}


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    )
/*++

Routine Description:

    Get a dword from the registry in the ipconfmsp key.

Arguments:
    
    szName  - The name of the value.

    pdwValue  - a pointer to the dword returned.

Return Value:

    TURE    - SUCCEED.

    FALSE   - MSP_ERROR

--*/
{
    HKEY  hKey;
    DWORD dwDataSize, dwDataType, dwValue;

    if (::RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszSDPMSPKey,
        0,
        KEY_READ,
        &hKey) != NOERROR)
    {
        return FALSE;
    }

    dwDataSize = sizeof(DWORD);
    if (::RegQueryValueExW(
        hKey,
        szName,
        0,
        &dwDataType,
        (LPBYTE) &dwValue,
        &dwDataSize) != NOERROR)
    {
        RegCloseKey (hKey);
        return FALSE;
    }

    *pdwValue = dwValue;

    RegCloseKey (hKey);
    
    return TRUE;
}


HRESULT
FindACMAudioCodec(
    IN DWORD dwPayloadType,
    OUT IBaseFilter **ppIBaseFilter
    )
/*++

Routine Description:

    Find the audio codec filter based on the payload type.

Arguments:
    
    dwPayloadType   - The rtp payload type.

    ppIBaseFilter   - The returned interface pointer.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "Find audio codec Called."));

    _ASSERTE(ppIBaseFilter != NULL);

    HRESULT hr;

    int AcmId;

    switch (dwPayloadType)
    {
    case PAYLOAD_G711A:
        AcmId = WAVE_FORMAT_ALAW;
        break;

    case PAYLOAD_G711U:
        AcmId = WAVE_FORMAT_MULAW;
        break;

    case PAYLOAD_GSM:
        AcmId = WAVE_FORMAT_GSM610;
        break;

    case PAYLOAD_MSAUDIO:
        AcmId = WAVE_FORMAT_MSAUDIO1;
        break;

    case PAYLOAD_G721:
        AcmId = WAVE_FORMAT_ADPCM;
        break;
    
    case PAYLOAD_DVI4_8:
        AcmId = WAVE_FORMAT_DVI_ADPCM;
        break;
    
    default:
        return E_FAIL;
    }

    //
    // Create the DirectShow Category enumerator Creator
    //
    CComPtr<ICreateDevEnum> pCreateDevEnum;
    CComPtr<IEnumMoniker> pCatEnum;

    hr = CoCreateInstance(
        CLSID_SystemDeviceEnum, 
        NULL, 
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(ICreateDevEnum), 
        (void**)&pCreateDevEnum);

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "Create system device enum - hr: %8x", hr));
        return hr;
    }

    hr = pCreateDevEnum->CreateClassEnumerator(
        CLSID_CAcmCoClassManager, 
        &pCatEnum, 
        0
        );

    if (hr != S_OK) 
    {
        LOG((MSP_ERROR, "CreateClassEnumerator - hr: %8x", hr));
        return hr;
    }

    // find the acm wrapper we want to use.
    for (;;)
    {
        ULONG cFetched;
        CComPtr<IMoniker> pMoniker;

        if (S_OK != (hr = pCatEnum->Next(1, &pMoniker, &cFetched)))
        {
            break;
        }

        // Get the ACMid for this filter out of the property bag.
        CComPtr<IPropertyBag> pBag;
        hr = pMoniker->BindToStorage(0, 0, __uuidof(IPropertyBag), (void **)&pBag);
        if (FAILED(hr)) 
        {
            LOG((MSP_ERROR, "get property bag - hr: %8x", hr));
            continue;
        }

        VARIANT var;
        var.vt = VT_I4;
        hr = pBag->Read(L"AcmId", &var, 0);
        if (FAILED(hr)) 
        {
            LOG((MSP_ERROR, "read acmid - hr: %8x", hr));
            continue;
        }

        if (AcmId == V_I4(&var))
        {
            // Now make the filter for this.
            hr = pMoniker->BindToObject(
                0, 
                0, 
                __uuidof(IBaseFilter), 
                (void**)ppIBaseFilter
                );

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "BindToObject - hr: %8x", hr));
            }
            break;
        }
    }

    return hr;
}

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    )
/*++

Routine Description:

    Get the IAMStreamConfig interface on the pin and config the
    audio format by using WAVEFORMATEX.

Arguments:
    
    pIUnknown - an object to configure.

    wBitPerSample  - the number of bits in each sample.

    dwSampleRate    - number of samples per second.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetAudioFormat entered"));

    HRESULT hr;

    CComPtr<IAMStreamConfig> pIAMStreamConfig;

    if (FAILED(hr = pIUnknown->QueryInterface(
        __uuidof(IAMStreamConfig),
        (void **)&pIAMStreamConfig
        )))
    {
        LOG((MSP_ERROR, "Can't get IAMStreamConfig interface.%8x", hr));
        return hr;
    }

    AM_MEDIA_TYPE mt;
    WAVEFORMATEX wfx;

    wfx.wFormatTag          = WAVE_FORMAT_PCM;
    wfx.wBitsPerSample      = wBitPerSample;
    wfx.nChannels           = 1;
    wfx.nSamplesPerSec      = dwSampleRate;
    wfx.nBlockAlign         = wfx.wBitsPerSample * wfx.nChannels / 8;
    wfx.nAvgBytesPerSec     = ((DWORD) wfx.nBlockAlign * wfx.nSamplesPerSec);
    wfx.cbSize              = 0;

    mt.majortype            = MEDIATYPE_Audio;
    mt.subtype              = MEDIASUBTYPE_PCM;
    mt.bFixedSizeSamples    = TRUE;
    mt.bTemporalCompression = FALSE;
    mt.lSampleSize          = 0;
    mt.formattype           = FORMAT_WaveFormatEx;
    mt.pUnk                 = NULL;
    mt.cbFormat             = sizeof(WAVEFORMATEX);
    mt.pbFormat             = (BYTE*)&wfx;

    // set the format of the audio capture terminal.
    if (FAILED(hr = pIAMStreamConfig->SetFormat(&mt)))
    {
        LOG((MSP_ERROR, "SetFormat returns error: %8x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    )
/*++

Routine Description:

    Set the audio capture output pin's buffer size. The buffer size
    determins how many milliseconds worth of samples are contained 
    in a buffer.

Arguments:
    
    pIUnknown - an object to configure.

    dwNumBuffers - the number of buffers to be allocated. Too few buffers
    might cause starvation on the capture device.

    dwBufferSize - The size of each buffer.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetAudioBufferSize, dwNumBuffers %d, dwBuffersize %d",
        dwNumBuffers, dwBufferSize));

    _ASSERTE(dwNumBuffers != 0 && dwBufferSize != 0);

    HRESULT hr;

    CComPtr<IAMBufferNegotiation> pBN;
    if (FAILED(hr = pIUnknown->QueryInterface(
            __uuidof(IAMBufferNegotiation),
            (void **)&pBN
            )))
    {
        LOG((MSP_ERROR, "Can't get buffer negotiation.%8x", hr));
        return hr;
    }

    ALLOCATOR_PROPERTIES prop;

    // Set the number of buffers.
    prop.cBuffers = dwNumBuffers;
    prop.cbBuffer = dwBufferSize;

    prop.cbAlign  = -1;
    prop.cbPrefix = -1;

    if (FAILED(hr = pBN->SuggestAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "SuggestAllocatorProperties returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "SetAudioBuffersize"
            " buffers: %d, buffersize: %d, align: %d, Prefix: %d",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
            ));
    }
    return hr;
}

/* Init reference time */
void CMSPStreamClock::InitReferenceTime(void)
{
    m_lPerfFrequency = 0;

    /* NOTE The fact that having multiprocessor makes the
     * performance counter to be unreliable (in some machines)
     * unless I set the processor affinity, which I can not
     * because any thread can request the time, so use it only on
     * uniprocessor machines */
    /* MAYDO Would be nice to enable this also in multiprocessor
     * machines, if I could specify what procesor's performance
     * counter to read or if I had a processor independent
     * performance counter */

    /* Actually the error should be quite smaller than 1ms, making
     * this bug irrelevant for my porpuses, so alway use performance
     * counter if available */
    QueryPerformanceFrequency((LARGE_INTEGER *)&m_lPerfFrequency);

    if (m_lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&m_lRtpRefTime);
        /* Arbitrarily start time not at zero but at 100ms */
        m_lRtpRefTime -= m_lPerfFrequency/10;
    }
    else
    {
        m_dwRtpRefTime = timeGetTime();
        /* Arbitrarily start time not at zero but at 100ms */
        m_dwRtpRefTime -= 100;
    }
}

/* Return time in 100's of nanoseconds since the object was
 * initialized */
HRESULT CMSPStreamClock::GetTimeOfDay(OUT REFERENCE_TIME *pTime)
{
    union {
        DWORD            dwCurTime;
        LONGLONG         lCurTime;
    };
    LONGLONG         lTime;

    if (m_lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&lTime);

        lCurTime = lTime - m_lRtpRefTime;

        *pTime = (REFERENCE_TIME)(lCurTime * 10000000 / m_lPerfFrequency);
    }
    else
    {
        dwCurTime = timeGetTime() - m_dwRtpRefTime;
        
        *pTime = (REFERENCE_TIME)(dwCurTime * 10000);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confterm.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mspterm.cpp

Abstract:

    Implementations for the CIPConfBaseTerminal, CSingleFilterTerminal, and various
    work item / worker thread classes.

Author:

    Zoltan Szilagyi (zoltans) September 6,1998

--*/

#include "stdafx.h"

CIPConfBaseTerminal::CIPConfBaseTerminal()
    : m_fCritSecValid(FALSE)
    , m_TerminalClassID(GUID_NULL)
    , m_TerminalDirection(TD_CAPTURE)
    , m_TerminalType(TT_STATIC)
    , m_TerminalState(TS_NOTINUSE)
    , m_dwMediaType(0)
    , m_pFTM(NULL)
    , m_htAddress(NULL)
    , m_pGraph(NULL)
    , m_pFilter(NULL)
{
    LOG((MSP_TRACE, "CIPConfBaseTerminal::CIPConfBaseTerminal() called"));
    m_szName[0] = '\0';
}

HRESULT CIPConfBaseTerminal::FinalConstruct()
/*++

Routine Description:

    Finish the initialization of the object. If anything fails, this object
    will be deleted.

Arguments:
    
    nothing.

Return Value:

    S_OK
    E_OUTOFMEMORY
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::FinalConstruct");
    LOG((MSP_TRACE, "%s entered", __fxName));

    m_fCritSecValid = TRUE;

    __try
    {
        InitializeCriticalSection(&m_CritSec);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        m_fCritSecValid = FALSE;
    }

    if (!m_fCritSecValid)
    {
        LOG((MSP_ERROR, "%s init critical section failed", __fxName));
        return E_OUTOFMEMORY;
    }

    HRESULT hr = CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pFTM
            );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "%s create ftm failed, hr=%x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

CIPConfBaseTerminal::~CIPConfBaseTerminal()
/*++

Routine Description:

    This is the destructor of the base terminal.

Arguments:
    
Return Value:

    S_OK
--*/
{
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    
    if (m_pFilter)
    {
        m_pFilter->Release();
    }

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    if (m_fCritSecValid)
    {
        DeleteCriticalSection(&m_CritSec);
    }
    
    LOG((MSP_TRACE, 
        "CIPConfBaseTerminal::~CIPConfBaseTerminal() for %ws finished", m_szName));
}

HRESULT CIPConfBaseTerminal::Initialize(
    IN  WCHAR *             strName,
    IN  MSP_HANDLE          htAddress
    )
/*++

Routine Description:

    This function sets the name and the address handle on the terminal.

Arguments:
    
    strName - The name of the terminal.

    htAddress - The handle that identifies the address object that this
                terminal belongs to.

Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::Initialize");
    LOG((MSP_TRACE, "%s entered", __fxName));

    m_htAddress         = htAddress;
    lstrcpynW(m_szName, strName, MAX_PATH);

    LOG((MSP_TRACE, "%s - exit S_OK", __fxName));
    return S_OK;
}

HRESULT CIPConfBaseTerminal::Initialize(
    IN  char *              strName,
    IN  MSP_HANDLE          htAddress
    )
/*++

Routine Description:

    This function sets the name and the address handle on the terminal. This
    function takes ascii string name.

Arguments:
    
    strName - The name of the terminal.

    htAddress - The handle that identifies the address object that this
                terminal belongs to.

Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::Initialize");
    LOG((MSP_TRACE, "%s entered", __fxName));

    m_htAddress         = htAddress;
    MultiByteToWideChar(
              GetACP(),
              0,
              strName,
              lstrlenA(strName)+1,
              m_szName,
              MAX_PATH
              );

    LOG((MSP_TRACE, "%s - exit S_OK", __fxName));
    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_Name(
    BSTR * pbsName
    )
/*++

Routine Description:

    This function return the name of the terminal.

Arguments:
    
    pbsName - A pointer to a BSTR to receive the terminal name.

Return Value:

    E_POINTER
    E_OUTOFMEMORY
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_Name");

    if ( IsBadWritePtr( pbsName, sizeof(BSTR) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pbsName = SysAllocString(m_szName);

    if ( *pbsName == NULL )
    {
        LOG((MSP_ERROR, "%s, out of memory for name", __fxName)); 
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_State(
    TERMINAL_STATE * pVal
    )
/*++

Routine Description:

    This function return the state of the terminal.

Arguments:
    
    pVal - A pointer to a variable of type TERMINAL_STATE.

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_State");

    if ( IsBadWritePtr( pVal, sizeof(TERMINAL_STATE) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pVal = m_TerminalState;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_TerminalType(
    TERMINAL_TYPE * pVal
    )
/*++

Routine Description:

    This function return the type of the terminal.

Arguments:
    
    pVal - A pointer to a variable of type TERMINAL_TYPE.

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalType");
    
    if ( IsBadWritePtr( pVal, sizeof(TERMINAL_TYPE) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pVal = m_TerminalType;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_TerminalClass(
    BSTR * pbsClassID
    )
/*++

Routine Description:

    This function return the class of the terminal.

Arguments:
    
    pbsClassID - A pointer to a BSTR to receive the classID as a string.

Return Value:

    E_POINTER
    E_OUTOFMEMORY
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalClass");

    if ( IsBadWritePtr( pbsClassID, sizeof(BSTR) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    // Convert the CLSID to an string.
    WCHAR *pszName = NULL;
    
    HRESULT hr = ::StringFromCLSID(m_TerminalClassID, &pszName);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, failed to convert GUID, hr = %x", __fxName, hr));
        return hr;
    }

    // Put the string in a BSTR.
    BSTR bClassID = ::SysAllocString(pszName);

    // Free the OLE string.
    ::CoTaskMemFree(pszName);

    if (bClassID == NULL)
    {
        LOG((MSP_ERROR, "%s, out of mem for class ID", __fxName));
        return E_OUTOFMEMORY;
    }

    *pbsClassID = bClassID;

    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::get_Direction(
    OUT  TERMINAL_DIRECTION *pDirection
    )
/*++

Routine Description:

    This function return the direction of the terminal.

Arguments:
    
    pDirection - A pointer to a variable of type TERMINAL_DIRECTION

Return Value:

    E_POINTER
    S_OK
--*/
{   
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalClass");

    if ( IsBadWritePtr( pDirection, sizeof(TERMINAL_DIRECTION) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pDirection = m_TerminalDirection;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_MediaType(
    long * plMediaType
    )
/*++

Routine Description:

    This function return the media type of the terminal.

Arguments:
    
    plMediaType - A pointer to a variable of type long

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_MediaType");

    if ( IsBadWritePtr(plMediaType, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }
    
    *plMediaType = (long) m_dwMediaType;

    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::get_AddressHandle(
        OUT     MSP_HANDLE    * phtAddress
        )
/*++

Routine Description:

    This function return the handle of the address that created this terminal.

Arguments:
    
    phtAddress - A pointer to a variable of type MSP_HANDLE

Return Value:

    E_POINTER
    S_OK
--*/
{
    // this function is only called from the MSP, so only assert here.    
    _ASSERT(!IsBadWritePtr(phtAddress, sizeof(MSP_HANDLE)));

    *phtAddress = m_htAddress;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::ConnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved,
        IN OUT  DWORD          * pdwNumPins,
        OUT     IPin          ** ppPins
        )
/*++

Routine Description:

    This function is called by the MSP while trying to connect the filter in
    the terminal to the rest of the graph in the MSP. It adds the filter into
    the graph and returns the pins can be used by the MSP.

Arguments:
    
    pGraph - The filter graph.

    dwReserved - A reserved dword.

    pdwNumPins - The maxinum number of pins the msp wants.

    ppPins  - A pointer to the buffer that can store the IPin pointers. If it
              is NULL, only the actual number of pins will be returned.

Return Value:

S_OK
TAPI_E_NOTENOUGHMEMORY - the buffer is too small.
TAPI_E_TERMINALINUSE - the terminal is in use.
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::ConnectTerminal");
    LOG((MSP_TRACE, 
        "%s entered, pGraph:%p, dwREserved:%p", __fxName, pGraph, dwReserved));

    // this function is only called from the MSP, so only assert here.    
    _ASSERT(!IsBadReadPtr(pGraph, sizeof(IGraphBuilder)));
    _ASSERT(!IsBadWritePtr(pdwNumPins, sizeof(DWORD)));

    // find the number of exposed pins on the filter. 
    // This function doesn't fail.
    DWORD dwActualNumPins = GetNumExposedPins();

    //
    // If ppPins is NULL, just return the number of pins and don't try to
    // connect the terminal.
    //
    if ( ppPins == NULL )
    {
        LOG((MSP_TRACE, 
            "%s number of exposed pins:%d", __fxName, dwActualNumPins));
        *pdwNumPins = dwActualNumPins;
        return S_OK;
    }

    //
    // Otherwise, we have a pin return buffer. Check that the purported buffer
    // size is big enough and that the buffer is actually writable to the size
    // we need.
    //
    if ( *pdwNumPins < dwActualNumPins )
    {
        LOG((MSP_ERROR, 
            "%s not enough space to place pins.", __fxName));

        *pdwNumPins = dwActualNumPins;
        
        return TAPI_E_NOTENOUGHMEMORY;
    }

    if ( IsBadWritePtr(ppPins, dwActualNumPins * sizeof(IPin *) ) )
    {
        LOG((MSP_ERROR, 
            "%s, bad pins array pointer; exit E_POINTER", __fxName));

        return E_POINTER;
    }

    //
    // Check if we're already connected, and if so, change our state to
    // connected. Note that this makes sense for both core static terminals
    // and dynamic terminals. Also note that we need to protect this with
    // a critical section, but after this we can let go of the lock because
    // anyone who subsequently enters the critical section will bail at this
    // point.
    //

    Lock();

    //
    // check if already connected
    //

    if (TS_INUSE == m_TerminalState)
    {
        LOG((MSP_ERROR, 
            "%s, terminal already in use", __fxName));

        Unlock();
        return TAPI_E_TERMINALINUSE;
    }

    IPin * pTerminalPin;

    // add filter to the filter graph
    HRESULT hr = AddFilterToGraph(pGraph);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, can't add filters to graph", __fxName));

        Unlock();
        return hr;
    }

    //
    // Get the pins that our filter exposes. 
    //
    *pdwNumPins = dwActualNumPins;
    hr = GetExposedPins(ppPins, dwActualNumPins);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "%s, GetExposedPins returned hr=%x", __fxName, hr));

        // best effort attempt to disconnect - ignore error code
        RemoveFilterFromGraph(pGraph);
        
        Unlock();
        return hr;
    }

    m_pGraph        = pGraph;
    m_pGraph->AddRef();

    m_TerminalState = TS_INUSE;

    Unlock();

    LOG((MSP_TRACE, "CIPConfBaseTerminal::ConnectTerminal success"));
    return hr;
}

STDMETHODIMP 
CIPConfBaseTerminal::CompleteConnectTerminal(void)
/*++

Routine Description:

    This function is called after a successful ConnectTerminal so that the 
    terminal can do post-connection intitialization. 

Arguments:

    nothing    

Return Value:

S_OK
--*/
{
    return S_OK;
}


STDMETHODIMP 
CIPConfBaseTerminal::DisconnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        )
/*++

Routine Description:

    This function is called by the MSP while trying to disconnect the filter in
    the terminal from the rest of the graph in the MSP. It adds the removes the
    filter from the graph and set the terminal free.

Arguments:
    
    pGraph - The filter graph. It is used for validation, to make sure the 
             terminal is disconnected from the same graph that it was 
             originally connected to.

    dwReserved - A reserved dword.

Return Value:

S_OK
E_INVALIDARG - wrong graph.

--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::DisconnectTerminal");
    LOG((MSP_TRACE, 
        "%s entered, pGraph:%p, dwReserved:%d", __fxName, pGraph, dwReserved));

    Lock();

    //
    // If not in use, then there is nothing to be done.
    //
    if ( TS_INUSE != m_TerminalState ) 
    {
        _ASSERTE(m_pGraph == NULL);
        LOG((MSP_TRACE, "%s, success; not in use", __fxName));

        Unlock();
        return S_OK;
    }

    //
    // Check that we are being disconnected from the correct graph.
    //
    if (pGraph == NULL || m_pGraph != pGraph )
    {
        LOG((MSP_TRACE, "%s, wrong graph:%p", __fxName, pGraph));
        
        Unlock();
        return E_INVALIDARG;
    }


    HRESULT hr = S_OK;

    //
    // Remove filter from the graph, release our reference to the graph,
    // and set ourselves to notinuse state
    //
    hr = RemoveFilterFromGraph(m_pGraph);
    
    m_pGraph->Release();
    m_pGraph = NULL;
    
    m_TerminalState = TS_NOTINUSE;

    Unlock();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "%s, remove filters from graph failed; returning 0x%08x", 
            __fxName, hr));
    }
    else
    {
        LOG((MSP_TRACE, "%s succeeded", __fxName));
    }

    return hr;
}

STDMETHODIMP CIPConfBaseTerminal::RunRenderFilter(void)
/*++

Routine Description:

    start the rightmost render filter in the terminal
    (needed for dynamic filter graphs)

Arguments:
    
Return Value:

    E_NOTIMPL
--*/
{
    return E_NOTIMPL;
}

STDMETHODIMP CIPConfBaseTerminal::StopRenderFilter(void)
/*++

Routine Description:

    stops the rightmost render filter in the terminal
    (needed for dynamic filter graphs)

Arguments:
    
Return Value:

    E_NOTIMPL
--*/
{
    return E_NOTIMPL;
}

HRESULT CIPConfBaseTerminal::AddFilterToGraph(
    IN  IGraphBuilder *pGraph
    )
/*++

Routine Description:

    Add the internal filter into a graph.

Arguments:
    
    pGraph - the filter graph to add the filter to.

Return Value:

    HRESULT
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::AddFilterToGraph");
    LOG((MSP_TRACE, "%s entered, pGraph:%p", __fxName, pGraph));

    HRESULT hr;

    if (m_pFilter == NULL)
    {
        hr = CreateFilter();

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, Create filter failed. hr=%x", __fxName, hr));
            return hr;
        }
    }

    _ASSERT(pGraph != NULL);
    _ASSERT(m_pFilter != NULL);

    hr = pGraph->AddFilter(m_pFilter, NULL);

    return hr;
}


HRESULT CIPConfBaseTerminal::RemoveFilterFromGraph(
    IN  IGraphBuilder *pGraph
    )
/*++

Routine Description:

    Remove the internal filter from the graph it was added.

Arguments:
    
    pGraph - the filter graph to remove the filter from.

Return Value:

    S_FALSE - the internal filter doesn't exist.
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::RemoveFilterFromGraph");
    LOG((MSP_TRACE, "%s entered, pGraph:%p", __fxName, pGraph));

    if (m_pFilter == NULL)
    {
        LOG((MSP_TRACE, "%s, no filter to remove", __fxName));
        return S_FALSE;
    }

    // remove the filter from the graph
    _ASSERT(pGraph != NULL);
    HRESULT hr = pGraph->RemoveFilter(m_pFilter);

    m_pFilter->Release();
    m_pFilter = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confvidt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//        Name: IPConfvidt.h
//
// Description: Definition of the CIPConfVideoCaptureTerminal class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IPConfVIDT_H_
#define _IPConfVIDT_H_

/////////////////////////////////////////////////////////////////////////////
// CIPConfVideoCaptureTerminal
/////////////////////////////////////////////////////////////////////////////
const DWORD VIDEO_CAPTURE_FILTER_NUMPINS = 3;

interface DECLSPEC_UUID("4eb8cf35-0015-4260-83ee-1a179b05717c") DECLSPEC_NOVTABLE
IConfVideoDummy : public IUnknown
{
};

#define IID_IConfVideoDummy __uuidof(IConfVideoDummy)

class CIPConfVideoCaptureTerminal :
    public IConfVideoDummy,
    public CIPConfBaseTerminal
{

    // COM_INTERFACE_ENTRY_CHAIN is not allowed to the 1st one is a MAP
    // entry IConfVideoDummy is to make BEGIN_COM_MAP happy
BEGIN_COM_MAP(CIPConfVideoCaptureTerminal)
    COM_INTERFACE_ENTRY(IConfVideoDummy)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfBaseTerminal)
END_COM_MAP()

public:
    CIPConfVideoCaptureTerminal();

    virtual ~CIPConfVideoCaptureTerminal();

    static HRESULT CreateTerminal(
        IN  char *          strDeviceName,
        IN  UINT            VideoCaptureID,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  char *          strName,
        IN  UINT            VideoCaptureID,
        IN  MSP_HANDLE      htAddress
        );

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return VIDEO_CAPTURE_FILTER_NUMPINS;
    }
    
    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );

protected:
    UINT    m_VideoCaptureID;
};


#endif // _IPConfVIDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confutil.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    MSPCall.h

Abstract:

    Definitions for MSP utililty functions. There are all related to 
    active movie filter manipulation.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __MSPUTIL_H
#define __MSPUTIL_H

const DWORD PAYLOAD_G711U   = 0;
const DWORD PAYLOAD_G721    = 2;
const DWORD PAYLOAD_GSM     = 3;
const DWORD PAYLOAD_G723    = 4;
const DWORD PAYLOAD_DVI4_8  = 5;
const DWORD PAYLOAD_DVI4_16 = 6;
const DWORD PAYLOAD_G711A   = 8;
const DWORD PAYLOAD_MSAUDIO = 66;
const DWORD PAYLOAD_H261    = 31;
const DWORD PAYLOAD_H263    = 34;

const WCHAR gszMSPLoopback[] = L"Loopback";
const WCHAR gszAEC[] = L"AEC";
const WCHAR gszNumVideoCaptureBuffers[] = L"NumVideoCaptureBuffers";

const TCHAR gszSDPMSPKey[]   =
   _T("Software\\Microsoft\\Windows\\CurrentVersion\\IPConfMSP\\");


HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree = TRUE
    );

HRESULT
PinSupportsMediaType(
    IN IPin *           pIPin,
    IN const GUID &     MediaType
    );

HRESULT
AddFilter(
    IN  IGraphBuilder *     pIGraph,
    IN  const CLSID &       Clsid,
    IN  LPCWSTR             pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    );

HRESULT
SetLoopbackOption(
    IN IBaseFilter *pIBaseFilter,
    IN MULTICAST_LOOPBACK_MODE  LoopbackMode
    );

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBitRate,
    IN BOOL             bFailIfNoQOS,
    IN BOOL             bReceive = FALSE,
    IN DWORD            dwNumStreams = 1,
    IN BOOL             bCIF = FALSE
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter1, 
    IN IBaseFilter *    pIFilter2,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pIFilter,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter
    );

void WINAPI MSPDeleteMediaType(AM_MEDIA_TYPE *pmt);


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    );

HRESULT
FindACMAudioCodec(
    IN DWORD dwPayloadType,
    OUT IBaseFilter **ppIBaseFilter
    );

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    );

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    );

template <class T>
HRESULT CreateCComObjectInstance (
    CComObject<T> **ppObject
    )
/*++

Create a new CComObject instance. Use try/except to catch exception.

--*/
{
    HRESULT hr;

    __try
    {
        hr = CComObject<T>::CreateInstance(ppObject);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        *ppObject = NULL;
        return E_OUTOFMEMORY;
    }

    return hr;
}

inline DWORD FindSampleRate(AM_MEDIA_TYPE *pMediaType)
{
    _ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (pMediaType->majortype == MEDIATYPE_Audio &&
            pMediaType->formattype == FORMAT_WaveFormatEx &&
            pMediaType->pbFormat != NULL &&
            pMediaType->cbFormat != 0)
    {
        WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pMediaType->pbFormat;
        return pWaveFormatEx->nSamplesPerSec;
    }

    return 90000;      // default media clock rate, including video.
}

class ATL_NO_VTABLE CMSPStreamClock : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IReferenceClock
{
private:
    LONGLONG         m_lPerfFrequency;
    union {
        LONGLONG         m_lRtpRefTime;
        DWORD            m_dwRtpRefTime;
    };

public:

BEGIN_COM_MAP(CMSPStreamClock)
    COM_INTERFACE_ENTRY(IReferenceClock)
END_COM_MAP()

    void InitReferenceTime(void);

    HRESULT GetTimeOfDay(OUT REFERENCE_TIME *pTime);

    CMSPStreamClock()
    {
        InitReferenceTime();
    }

    STDMETHOD (GetTime) (
            OUT REFERENCE_TIME *pTime
        )
    {
        return(GetTimeOfDay(pTime));
    }

    STDMETHOD (AdviseTime) (
        IN REFERENCE_TIME baseTime,        // base reference time
        IN REFERENCE_TIME streamTime,      // stream offset time
        IN HEVENT hEvent,                  // advise via this event
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdviseTime is called");
        return E_NOTIMPL;
    }

    STDMETHOD (AdvisePeriodic) (
        IN REFERENCE_TIME StartTime,       // starting at this time
        IN REFERENCE_TIME PeriodTime,      // time between notifications
        IN HSEMAPHORE hSemaphore,          // advise via a semaphore
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdvisePeriodic is called");
        return E_NOTIMPL;
    }

    STDMETHOD (Unadvise) (
        IN DWORD_PTR dwAdviseCookie
        )
    {
        _ASSERT(!"Unadvise is called");
        return E_NOTIMPL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\skywalker\ipconf\msp\confvid.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confvid.cpp

Abstract:

    This module contains implementation of the video send and receive
    stream implementations.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamVideoRecv
//
/////////////////////////////////////////////////////////////////////////////

CStreamVideoRecv::CStreamVideoRecv()
    : CIPConfMSPStream()
{
      m_szName = L"VideoRecv";
}

HRESULT CStreamVideoRecv::Init(
    IN     HANDLE                   hAddress,
    IN     CMSPCallBase *           pMSPCall,
    IN     IMediaEvent *            pIGraphBuilder,
    IN     DWORD                    dwMediaType,
    IN     TERMINAL_DIRECTION       Direction
    )
/*++

Routine Description:
    Init our substream array and then call the base class' Init.

Arguments:

    hAddress    - a handle to the address, used in identify terminals.

    pMSPCall    - the call object that owns the stream.

    pIGraphBuilder - the filter graph object.

    dwMediaType - the mediatype of this stream.

    Direction  - the direction of this stream.

Return Value:
    
    S_OK,
    E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, "CStreamVideoRecvVideoSend::Init - enter"));

    // initialize the stream array so that the array is not NULL.
    if (!m_SubStreams.Grow())
    {
        LOG((MSP_TRACE, "CStreamVideoRecvVideoSend::Init - return out of memory"));
        return E_OUTOFMEMORY;
    }

    return CIPConfMSPStream::Init(
        hAddress, pMSPCall, pIGraphBuilder,dwMediaType, Direction
        );
}

HRESULT CStreamVideoRecv::ShutDown()
/*++

Routine Description:

    Shut down the stream. 

Arguments:
    

Return Value:

S_OK

--*/
{
    CLock lock(m_lock);

    // if there are terminals
    BOOL fHasTerminal = FALSE;
    if (m_Terminals.GetSize() > 0)
    {
        fHasTerminal = TRUE;
    }

    // if graph is running
    HRESULT hr;
    OAFilterState FilterState = State_Stopped;
    if (m_pIMediaControl)
    {
        if (FAILED (hr = m_pIMediaControl->GetState(0, &FilterState)))
        {
            LOG ((MSP_ERROR, "CStreamAudioRecv::ShutDown failed to query filter state. %d", hr));
            FilterState = State_Stopped;
        }
    }

    // if there are branches and configured, we need to disconnect 
    // the terminals and remove the branches.
    if (m_Branches.GetSize() > 0)
    {
        // Stop the graph before disconnecting the terminals.
        hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "stream %ws %p failed to stop, %x", m_szName, this, hr));
            return hr;
        }

        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            RemoveOneBranch(&m_Branches[i]);
        }
        m_Branches.RemoveAll();
    }

    // release all the substream objects.
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        m_SubStreams[i]->Release();
    }
    m_SubStreams.RemoveAll();

    // fire event
    if (fHasTerminal && FilterState == State_Running)
    {
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    }

    return CIPConfMSPStream::ShutDown();
}

HRESULT CStreamVideoRecv::InternalCreateSubStream(
    OUT ITSubStream ** ppSubStream
    )
/*++

Routine Description:
    This method creat a substream object and add it into out list.
    
Arguments:
    ppSubStream - the memory location that will store the returned SubStream.
  
Return Value:

S_OK
E_OUTOFMEMORY
E_NOINTERFACE

--*/
{
    CComObject<CSubStreamVideoRecv> * pCOMSubStream;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCOMSubStream);

    if (NULL == pCOMSubStream)
    {
        LOG((MSP_ERROR, "could not create video recv sub stream:%x", hr));
        return hr;
    }

    ITSubStream* pSubStream;

    // get the interface pointer.
    hr = pCOMSubStream->_InternalQueryInterface(
        __uuidof(ITSubStream), 
        (void **)&pSubStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create VideoRecv Substream QueryInterface failed: %x", hr));
        delete pCOMSubStream;
        return hr;
    }

    // Initialize the object.
    hr = pCOMSubStream->Init(this);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPSubStream:call init failed: %x", hr));
        pSubStream->Release();

        return hr;
    }

    // Add the SubStream into our list of SubStreams. This takes a refcount.
    if (!m_SubStreams.Add(pSubStream))
    {
        pSubStream->Release();

        LOG((MSP_ERROR, "out of memory in adding a SubStream."));
        return E_OUTOFMEMORY;
    }
    
    // AddRef the interface pointer and return it.
    pSubStream->AddRef(); 
    *ppSubStream = pSubStream;

    return S_OK;
}

// ITStream method
STDMETHODIMP CStreamVideoRecv::StopStream ()
{
    ENTER_FUNCTION ("CStreamVideoRecv::StopStream");

    HRESULT hr;

    CLock lock (m_lock);

    // copy stopstream from ipconfmsp because 
    // we want to generate unmap event before stream inactive event

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter stopped state. (SO)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter stopped state. (SO, ST)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    // Stop the graph.
    if (FAILED (hr = CMSPStream::StopStream()))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));
        return hr;
    }

    // check if we have filter chain
    CComPtr <IFilterChain> pIFilterChain;

    //  Query IFilterChain
    hr = m_pIMediaControl->QueryInterface(
        __uuidof(IFilterChain), 
        (void**)&pIFilterChain
        );

    if (FAILED (hr) && (hr != E_NOINTERFACE))
    {
        LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
        return hr;
    }

    if (pIFilterChain)
    {
        DWORD dwSSRC = 0;
        ITParticipant *pParticipant = NULL;
        INT count, next;

        next = m_SubStreams.GetSize ();
        // generate participant leave
        while ((count = next) > 0)
        {
            if (!((CSubStreamVideoRecv*)m_SubStreams[0])->GetCurrentParticipant (&dwSSRC, &pParticipant))
            {
                LOG ((MSP_ERROR, "%s failed to get current participant on %p", __fxName, m_SubStreams[0]));
                
                return E_UNEXPECTED;
            }

            pParticipant->Release ();

            if (FAILED (hr = ProcessParticipantLeave (dwSSRC)))
            {
                LOG ((MSP_ERROR, "%s failed to process participant leave. ssrc=%x, hr=%x", __fxName, dwSSRC, hr));

                return hr;
            }

            next = m_SubStreams.GetSize ();
            if (next >= count)
            {
                // no substream was removed. we have big trouble
                LOG ((MSP_ERROR, "%s: not substream was removed", __fxName));

                return E_UNEXPECTED;
            }
        }

        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (!m_Branches[i].pITSubStream) continue;

            if (FAILED (hr = ProcessPinUnmapEvent (
                m_Branches[i].dwSSRC, m_Branches[i].pIPin)))
            {
                LOG ((MSP_ERROR, "%s (%ws) failed to process pin unmap event. %x", __fxName, m_szName, hr));
            }
        }
    }

    SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    LOG((MSP_INFO, "stream %ws %p stopped", m_szName, this));

    // Enter stopped state.(ST)
    m_dwState = STRM_STOPPED; 

    return S_OK;
}

// ITSubStreamControl methods, called by the app.
STDMETHODIMP CStreamVideoRecv::CreateSubStream(
    IN OUT  ITSubStream **         ppSubStream
    )
/*++

Routine Description:
    This method creates a new substream on this video receive stream. Since
    the substreams are created based on the participants, this function
    returns only TAPI_E_NOTSUPPORTED.

Arguments:
    ppSubStream - the memory location that will store the returned SubStream.
  
Return Value:

TAPI_E_NOTSUPPORTED

--*/
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CStreamVideoRecv::RemoveSubStream(
    IN      ITSubStream *          pSubStream
    )
/*++

Routine Description:
    This method remove substream on this video receive stream. Since
    the substreams are created based on the participants, this function
    returns only TAPI_E_NOTSUPPORTED.

Arguments:
    pSubStream - the SubStream to be removed.
  
Return Value:

TAPI_E_NOTSUPPORTED
--*/
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CStreamVideoRecv::EnumerateSubStreams(
    OUT     IEnumSubStream **      ppEnumSubStream
    )
/*++

Routine Description:
    This method returns an enumerator of the substreams. 

Arguments:
    ppEnumSubStream - the memory location to store the returned pointer.
  
Return Value:

S_OK
E_POINTER
E_UNEXPECTED
E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, 
        "EnumerateSubStreams entered. ppEnumSubStream:%x", ppEnumSubStream));

    //
    // Check parameters.
    //

    if (IsBadWritePtr(ppEnumSubStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the SubStream object list.
    //

    CLock lock(m_lock);

    if (m_SubStreams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //
    HRESULT hr;

    typedef _CopyInterface<ITSubStream> CCopy;
    typedef CSafeComEnum<IEnumSubStream, &__uuidof(IEnumSubStream), 
                ITSubStream *, CCopy> CEnumerator;
    CComObject<CEnumerator> *pEnum = NULL;

    hr = ::CreateCComObjectInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the __uuidof(IEnumSubStream) i/f
    //


    IEnumSubStream *      pEnumSubStream;
    hr = pEnum->_InternalQueryInterface(__uuidof(IEnumSubStream), (void**)&pEnumSubStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized array.
    //

    hr = pEnum->Init(
        m_SubStreams.GetData(),                        // the begin itor
        m_SubStreams.GetData() + m_SubStreams.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "init enumerator object failed, %x", hr));

        pEnumSubStream->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CMSPCallBase::EnumerateSubStreams - exit S_OK"));

    *ppEnumSubStream = pEnumSubStream;

    return hr;
}

STDMETHODIMP CStreamVideoRecv::get_SubStreams(
    OUT     VARIANT *              pVariant
    )
/*++

Routine Description:
    This method returns a collection of the substreams. 

Arguments:
    pVariant - a variant structure.
  
Return Value:

S_OK
E_POINTER
E_UNEXPECTED
E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, "CStreamVideoRecv::get_SubStreams - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the SubStream object list.
    //

    CLock lock(m_lock);

    if (m_SubStreams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITSubStream * > SubStreamCollection;
    CComObject<SubStreamCollection> * pCollection;
    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_SubStreams.GetSize(),
                                  m_SubStreams.GetData(),
                                  m_SubStreams.GetData() + m_SubStreams.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CStreamVideoRecv::get_SubStreams - exit S_OK"));
 
    return S_OK;
}

HRESULT CStreamVideoRecv::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:
    
    Check to see if the terminal is allowed on this stream. Only video 
    render terminal is allowed.

Arguments:

    pTerminal   - the terminal.

Return value:

    S_OK 
    TAPI_E_INVALIDTERMINAL
*/
{
    LOG((MSP_TRACE, "VideoRecv.CheckTerminalTypeAndDirection"));

    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (Direction != TD_BIDIRECTIONAL && Direction != m_Direction)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::SubStreamSelectTerminal(
    IN  ITSubStream * pITSubStream, 
    IN  ITTerminal * pITTerminal
    )
/*++

Routine Description:

    handle terminals being selected on the sub streams. It gives the terminal
    to one free branch and then sets up a mapping between the branch and the
    substream, so that the participant in the substream is displayed on the
    terminal selected.

Arguments:
    
    pITSubStream - the Substream that got a terminal selected.

    pITTerminal - the terminal object.

Return Value:

S_OK

--*/
{
    LOG((MSP_TRACE, "VideoRecv SubStreamSelectTerminal"));

    HRESULT hr;

    CLock lock(m_lock);
    
    // Call the base class's select terminal first. The terminal will be put
    // into the terminal pool and a branch of filters will be created for it.
    hr = CIPConfMSPStream::SelectTerminal(pITTerminal);

    if (FAILED(hr))
    {
        return hr;
    }

    // Find out which branch got the terminal.
    int i;
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pITTerminal == pITTerminal)
        {
            break;
        }
    }

    _ASSERTE(i < m_Branches.GetSize());

    if (i >= m_Branches.GetSize())
    {
        return E_UNEXPECTED;
    }

    // Find out the participant on the SubStream.
    ITParticipant *pITParticipant = NULL;
    DWORD dwSSRC;

    if ((static_cast<CSubStreamVideoRecv*>(pITSubStream))->GetCurrentParticipant(
        &dwSSRC,
        &pITParticipant
        ) == FALSE)
    {
        return E_UNEXPECTED;
    }

    pITParticipant->Release();

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "no demux filter"));
        return E_UNEXPECTED;
    }

    // map the pin to this SSRC only.
    hr = m_pIRTPDemux->SetMappingState(-1, m_Branches[i].pIPin, dwSSRC, TRUE);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "map SSRC %x to pin %p returned %x", 
            dwSSRC, m_Branches[i].pIPin, hr));
        return hr;
    }    

    _ASSERTE(m_Branches[i].pITSubStream == NULL);

    pITSubStream->AddRef();
    m_Branches[i].pITSubStream = pITSubStream;
    m_Branches[i].dwSSRC = dwSSRC;
    
    return hr;
}

HRESULT CStreamVideoRecv::ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    )
/*++

Routine Description:

    Configure the RTP filter with RTP<-->AM media type mappings.

Arguments:
    
    pIRTPFilter - The source RTP Filter.

    pIStreamConfig - The stream config interface that has the media info.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("VideoRecv::ConfigureRTPFormats");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    CComPtr<IRtpMediaControl> pIRtpMediaControl;
    hr = pIRTPFilter->QueryInterface(&pIRtpMediaControl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
        return hr;
    }

    // find the number of capabilities supported.
    DWORD dwCount;
    hr = pIStreamConfig->GetNumberOfCapabilities(&dwCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s GetNumberOfCapabilities. %x", __fxName, hr));
        return hr;
    }

    BOOL fFound = FALSE;
    for (int i = dwCount - 1; i >= 0; i --)
    {
        // TODO, a new interface is needed to resolve RTP to MediaType.
        AM_MEDIA_TYPE *pMediaType;
        DWORD dwPayloadType;

        hr = pIStreamConfig->GetStreamCaps(
            i, &pMediaType, NULL, &dwPayloadType
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s GetStreamCaps. %x", __fxName, hr));
            return hr;
        }

        BITMAPINFOHEADER *pHeader = HEADER(pMediaType->pbFormat);
        if (pHeader == NULL)
        {
            MSPDeleteMediaType(pMediaType);
            continue;
        }

        // check the image size
        if (m_Settings.fCIF)
        {
            if (pHeader->biWidth != CIFWIDTH)
            {
                MSPDeleteMediaType(pMediaType);
                continue;
            }
        }
        else
        {
            if (pHeader->biWidth != QCIFWIDTH)
            {
                MSPDeleteMediaType(pMediaType);
                continue;
            }
        }
        
        for (DWORD dw2 = 0; dw2 < m_Settings.dwNumPayloadTypes; dw2 ++)
        {
            if (dwPayloadType == m_Settings.PayloadTypes[dw2])
            {
                hr = pIRtpMediaControl->SetFormatMapping(
                    dwPayloadType,
                    90000,      // default video clock rate.
                    pMediaType
                    );

                if (FAILED(hr))
                {
                    MSPDeleteMediaType(pMediaType);

                    LOG((MSP_ERROR, "%s SetFormatMapping. %x", __fxName, hr));
                    return hr;
                }
                else
                {
                    LOG((MSP_INFO, "%s Configured payload:%d", __fxName, dwPayloadType));
                }
            }
        }
        MSPDeleteMediaType(pMediaType);
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::SetUpInternalFilters()
/*++

Routine Description:

    set up the filters used in the stream.

    RTP->DECODER->Render terminal

    This function only creates the RTP and demux filter and the rest of the
    graph is connected in ConnectTerminal.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoRecv::SetUpInternalFilters");
    LOG((MSP_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;

    if (m_pIRTPDemux == NULL)
    {
        CComPtr<IBaseFilter> pSourceFilter;

        if (m_pIRTPSession == NULL)
        {
            // create and add the source fitler.
            if (FAILED(hr = ::AddFilter(
                    m_pIGraphBuilder,
                    __uuidof(MSRTPSourceFilter), 
                    L"RtpSource", 
                    &pSourceFilter)))
            {
                LOG((MSP_ERROR, "%s, adding source filter. %x", __fxName, hr));
                return hr;
            }

            if (FAILED(hr = ConfigureRTPFilter(pSourceFilter)))
            {
                LOG((MSP_ERROR, "%s, configure RTP source filter. %x", __fxName, hr));
                return hr;
            }

        }
        else
        {
            if (FAILED (hr = m_pIRTPSession->QueryInterface (&pSourceFilter)))
            {
                LOG ((MSP_ERROR, "%s failed to get filter from rtp session. %x", __fxName, hr));
                return hr;
            }

            if (FAILED (hr = m_pIGraphBuilder->AddFilter ((IBaseFilter *)pSourceFilter, L"RtpSource")))
            {
                LOG ((MSP_ERROR, "%s failed to add filter to graph. %x", __fxName, hr));
                return hr;
            }
        }

        // get the Demux interface pointer.
        hr = pSourceFilter->QueryInterface(&m_pIRTPDemux);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s query IRtpDemux failed. %x", __fxName, hr));
            return hr;
        }
    }

//  hr = m_pIRTPDemux->SetPinCount(m_Terminals.GetSize(), RTPDMXMODE_AUTO);

#define DEFAULT_PIN_SIZE 4

    int isize = m_Terminals.GetSize();
    if (isize < DEFAULT_PIN_SIZE)
    {
        isize = DEFAULT_PIN_SIZE;
    }

    hr = m_pIRTPDemux->SetPinCount(isize, RTPDMXMODE_AUTO);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s query IRtpDemux failed. %x", __fxName, hr));
        return hr;
    }

    return hr;
}

HRESULT CStreamVideoRecv::AddOneBranch(
    BRANCH * pBranch,
    BOOL fFirstBranch,
    BOOL fDirectRTP
    )
/*++

Routine Description:

    Create a new branch of filters off the demux.

Arguments:
    
    pBranch - a pointer to a structure that remembers the info about the branch.

    fFirstBranch - whether this is the first branch.

    fDirectRTP - whether to output RTP directly.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoRecv::AddOneBranch");
    LOG((MSP_TRACE, "%s entered.", __fxName));

    HRESULT hr;

    _ASSERT(m_pIRTPDemux != NULL);

    CComPtr<IBaseFilter> pRTPFilter;
    hr = m_pIRTPDemux->QueryInterface(
            __uuidof(IBaseFilter), (void**)&pRTPFilter);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, query IBaseFilter failed, %x", __fxName, hr));
        return hr;
    }

    // Find the next output pin on the demux fitler.
    CComPtr<IPin> pIPinOutput;
    
    if (FAILED(hr = ::FindPin(
            (IBaseFilter *)pRTPFilter,
            (IPin**)&pIPinOutput, 
            PINDIR_OUTPUT
            )))
    {
        LOG((MSP_ERROR, "%s, find free pin on demux, %x", __fxName, hr));
        return hr;
    }

    // create and add the video decoder filter.
    CComPtr<IBaseFilter> pCodecFilter;

    if (fDirectRTP)
    {
        // only create the decoder and ask questions
        if (FAILED(hr = CoCreateInstance(
                __uuidof(TAPIVideoDecoder),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                __uuidof(IBaseFilter),
                (void **) &pCodecFilter
                )))
        {
            LOG((MSP_ERROR, "%s, create filter %x", __fxName, hr));
            return hr;
        }
    }
    else
    {
        // create the decoder and add it into the graph.
        if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            __uuidof(TAPIVideoDecoder),
            L"codec", 
            &pCodecFilter
            )))
        {
            LOG((MSP_ERROR, "%s, add Codec filter. %x", __fxName, hr));
            return hr;
        }
    }

    CComPtr<IPin> pIPinInput;
    if (FAILED(hr = ::FindPin(pCodecFilter, &pIPinInput, PINDIR_INPUT, TRUE)))
    {
        LOG((MSP_ERROR,
            "%s, find input pin on pCodecFilter failed. hr=%x", __fxName, hr));
        return hr;
    }

    if (fFirstBranch)
    {
        CComPtr<IStreamConfig> pIStreamConfig;

        hr = pIPinInput->QueryInterface(&pIStreamConfig);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, query IStreamConfig failed", __fxName));
            return hr;
        }

        // configure the format info on the RTP filter
        if (FAILED(hr = ConfigureRTPFormats(pRTPFilter, pIStreamConfig)))
        {
            LOG((MSP_ERROR, "%s configure RTP formats. %x", __fxName, hr));
            return hr;
        }
    }

    if (!fDirectRTP)
    {
        // Connect the decoder to the output pin of the source filter.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IPin *)pIPinOutput, 
            (IBaseFilter *)pCodecFilter
            )))
        {
            LOG((MSP_ERROR, "%s, connect RTP filter and codec. %x", __fxName, hr));
    
            m_pIGraphBuilder->RemoveFilter(pCodecFilter);

            return hr;
        }
        pBranch->pCodecFilter    = pCodecFilter;
        pBranch->pCodecFilter->AddRef();
    }

    pBranch->pIPin = pIPinOutput;
    pBranch->pIPin->AddRef();

    // retrieve IBitrateControl
    if (FAILED (hr = pIPinInput->QueryInterface (&(pBranch->pBitrateControl))))
    {
        LOG((MSP_ERROR, "%, query IBitrateControl failed. %x", __fxName, hr));
        pBranch->pBitrateControl = NULL;
        // return hr;
    }

    LOG((MSP_TRACE, "%s, AddOneBranch exits ok.", __fxName));
    return S_OK;
}

HRESULT CStreamVideoRecv::RemoveOneBranch(
    BRANCH * pBranch
    )
/*++

Routine Description:

    Remove all the filters in a branch and release all the pointers.
    the caller of this function should not use any member of this branch
    after this function call. 

Arguments:
    
    pBranch - a pointer to a structure that has the info about the branch.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("VideoRecv::RemoveOneBranch");
    LOG((MSP_TRACE, "%s entered", __fxName));

    if (pBranch->pBitrateControl)
    {
        pBranch->pBitrateControl->Release();
    }

    if (pBranch->pIPin)
    {
        pBranch->pIPin->Release();
    }

    if (pBranch->pCodecFilter)
    {

    // #ifdef DYNGRAPH
        HRESULT hr;
        OAFilterState FilterState;
        CComPtr <IFilterChain> pIFilterChain;

        //  Query IFilterChain
        hr = m_pIMediaControl->QueryInterface(
            __uuidof(IFilterChain), 
            (void**)&pIFilterChain
            );

        if (FAILED (hr) && (hr != E_NOINTERFACE))
        {
            LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
            // return hr;
        }

        if (pIFilterChain)
        {
            hr = m_pIMediaControl->GetState(0, &FilterState);

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "%s get filter graph state failed, %x", __fxName, hr));
            }
            else 
            {
                // stop the chain before removing filters.
                if (FilterState == State_Running)
                {
                    // stop the chain if the graph is in running state.
                    hr = pIFilterChain->StopChain(pBranch->pCodecFilter, NULL);
                    if (FAILED(hr))
                    {
                        LOG((MSP_ERROR, "%s stop chain failed. hr=%x", __fxName, hr));
                    }
                }
            }
        }
    // #endif

        m_pIGraphBuilder->RemoveFilter(pBranch->pCodecFilter);
        pBranch->pCodecFilter->Release();
    }

    if (pBranch->pITTerminal)
    {
        // get the terminal control interface.
        CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
            pTerminal(pBranch->pITTerminal);
        
        _ASSERTE(pTerminal != NULL);

        if (pTerminal != NULL)
        {
            HRESULT hr = pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
            LOG((MSP_TRACE, 
                "%s, terminal %p is disonnected. hr:%x", 
                __fxName, pBranch->pITTerminal, hr));
        }
        pBranch->pITTerminal->Release();
    }

    if (pBranch->pITSubStream)
    {
        ((CSubStreamVideoRecv*)pBranch->pITSubStream)->
            ClearCurrentTerminal();
        pBranch->pITSubStream->Release();
    }

    LOG((MSP_TRACE, "%s, RemoveOneBranch exits ok.", __fxName));
    return S_OK;
}

HRESULT CStreamVideoRecv::ConnectPinToTerminal(
    IN  IPin *  pOutputPin,
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Connect the codec filter to the render filter inside the terminal.

Arguments:
    
    pOutputPin - The last pin before the terminal.

    pITTerminal - the terminal object.

Return Value:

    HRESULT.

--*/
{
    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);
        
        return E_NOINTERFACE;
    }


    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_RENDER, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_CONNECT_FAIL, hr, pITTerminal);
        
        return hr;
    }

    // the number of pins should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_UNEXPECTED;
    }

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_POINTER;
    }

    for (DWORD i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));

            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            return E_POINTER;
        }
    }

    // Connect the codec filter to the video render terminal.
    hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pOutputPin, 
        (IPin *)Pins[0],
        FALSE               // use Connect instead of ConnectDirect.
        );

    // release the refcounts on the pins.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "connect the pin to the terminal. %x", hr));

        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
	
        return hr;

    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamVideoRecv::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect video render terminal.

Arguments:
    
    pITTerminal - The terminal to be connected.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("VideoRecv::ConnectTerminal");
    LOG((MSP_TRACE, "%s enters, pTerminal %p", __fxName, pITTerminal));

    HRESULT hr;

    // #ifdef DYNGRAPH
    OAFilterState FilterState;
    CComPtr <IFilterChain> pIFilterChain;

    //  Query IFilterChain
    hr = m_pIMediaControl->QueryInterface(
        __uuidof(IFilterChain), 
        (void**)&pIFilterChain
        );

    if (FAILED (hr) && (hr != E_NOINTERFACE))
    {
        LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
        return hr;
    }

    hr = m_pIMediaControl->GetState(0, &FilterState);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s get filter graph state failed, %x", __fxName, hr));
        return hr;
    }
    // #endif

    hr = SetUpInternalFilters();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s Set up internal filter failed, %x", __fxName, hr));
        
        CleanUpFilters();

        return hr;
    }

    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);
        
        return E_NOINTERFACE;
    }

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_RENDER, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_CONNECT_FAIL, hr, pITTerminal);
        
        return hr;
    }

    // the number of pins should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_UNEXPECTED;
    }

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_POINTER;
    }

    DWORD i;
    for (i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));

            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            return E_POINTER;
        }
    }

    // check the media type supported by input pin on terminal
    BOOL fDirectRTP = FALSE;
    if (S_OK == ::PinSupportsMediaType (
        Pins[0], __uuidof(MEDIATYPE_RTP_Single_Stream)
        ))
    {
        fDirectRTP = TRUE;
    }

    // first create the branch structure needed before the terminal.
    BRANCH aBranch;
    ZeroMemory(&aBranch, sizeof BRANCH);

    hr = AddOneBranch(&aBranch, (m_Branches.GetSize() == 0), fDirectRTP);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s Set up a new decode branch failed, %x", __fxName, hr));
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
        return hr;
    }

    CComPtr <IPin> pOutputPin;

    if (fDirectRTP)
    {
        // connect the RTP output pin to the terminal's input pin.
        hr = m_pIGraphBuilder->ConnectDirect(aBranch.pIPin, Pins[0], NULL);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s connecting codec to terminal failed, %x", __fxName, hr));
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
	
            goto cleanup;
        }
    }
    else
    {
        // connect the codec to the terminal
        hr = ConnectFilters(m_pIGraphBuilder, aBranch.pCodecFilter, Pins[0]);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s connecting codec to terminal failed, %x", __fxName, hr));
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
            goto cleanup;
        }
    }

    // #ifdef DYNGRAPH
    if (pIFilterChain)
    {
        if (FilterState == State_Running)
        {
            if (fDirectRTP)
            {
                hr = E_UNEXPECTED;
                LOG((MSP_ERROR, "%s can't support this. %x", __fxName, hr));
                goto cleanup;
            }

            hr = pIFilterChain->StartChain(aBranch.pCodecFilter, NULL);
            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "%s start chain failed. hr=%x", __fxName, hr));
                goto cleanup;
            }
        }
    }
    // #endif

    pITTerminal->AddRef();
    aBranch.pITTerminal = pITTerminal;

    if (!m_Branches.Add(aBranch))
    {
        LOG((MSP_ERROR, "%s out of mem.", __fxName));
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // release the refcounts on the pins.
    for (i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return S_OK;

cleanup:
    
    // release the refcounts on the pins.
    for (i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    // remove the added filters from the graph and disconnect the terminal.
    RemoveOneBranch(&aBranch);

    return hr;
}

HRESULT CStreamVideoRecv::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph. A branch of filters is also
    released.

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    for (int i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pITTerminal == pITTerminal)
        {
            break;
        }
    }

    if (i < m_Branches.GetSize())
    {
        RemoveOneBranch(&m_Branches[i]);
        m_Branches.RemoveAt(i);
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv.SetUpFilters"));

    HRESULT hr = SetUpInternalFilters();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Set up internal filter failed, %x", hr));
        
        CleanUpFilters();

        return hr;
    }

    for (int i = 0; i < m_Terminals.GetSize(); i ++)
    {
        HRESULT hr = ConnectTerminal(m_Terminals[i]);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    return S_OK;
}

// ITParticipantSubStreamControl methods, called by the app.
STDMETHODIMP CStreamVideoRecv::get_SubStreamFromParticipant(
    IN  ITParticipant * pITParticipant,
    OUT ITSubStream ** ppITSubStream
    )
/*++

Routine Description:

    Find out which substream is rendering the participant. 

Arguments:

    pITParticipant - the participant.

    ppITSubStream - the returned sub stream.
    
Return Value:

    S_OK,
    TAPI_E_NOITEMS,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "get substream from participant:%p", pITParticipant));
    
    if (IsBadWritePtr(ppITSubStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "ppITSubStream is a bad pointer"));
        return E_POINTER;
    }

    CLock lock(m_lock);

    ITSubStream * pITSubStream = NULL;

    // find out which substream has the participant.
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        ITParticipant *pTempParticipant = NULL;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pITParticipant == pTempParticipant)
        {
            pITSubStream = m_SubStreams[i];
            pITSubStream->AddRef();

            break;
        }
    }
    
    if (pITSubStream == NULL)
    {
        return TAPI_E_NOITEMS;
    }

    *ppITSubStream = pITSubStream;
    return S_OK;
}

STDMETHODIMP CStreamVideoRecv::get_ParticipantFromSubStream(
    IN  ITSubStream * pITSubStream,
    OUT ITParticipant ** ppITParticipant 
    )
/*++

Routine Description:

    Find out which participant the substream is rendering.

Arguments:

    pITSubStream - the sub stream.

    ppITParticipant - the returned participant
    
Return Value:

    S_OK,
    TAPI_E_NOITEMS,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "get participant from substream:%p", pITSubStream));
    
    if (IsBadWritePtr(ppITParticipant, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "ppITParticipant is a bad pointer"));
        return E_POINTER;
    }

    CLock lock(m_lock);

    int i;

    // check to see if the substream is in our list.
    if ((i = m_SubStreams.Find(pITSubStream)) < 0)
    {
        LOG((MSP_ERROR, "wrong SubStream handle %p", pITSubStream));
        return E_INVALIDARG;
    }

    ITParticipant *pITParticipant;
    DWORD dwSSRC;

    if (((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
        &dwSSRC, &pITParticipant
        ) == FALSE)
    {
        return TAPI_E_NOITEMS;
    }

    *ppITParticipant = pITParticipant;
    
    return S_OK;
}

STDMETHODIMP CStreamVideoRecv::SwitchTerminalToSubStream(
    IN  ITTerminal * pITTerminal,
    IN  ITSubStream * pITSubStream
    )
/*++

Routine Description:

    Switch terminal to a substream to display the participant that is on the
    substream.

Arguments:

    pITTerminal - the terminal.

    pITSubStream - the sub stream.
    
Return Value:

    S_OK,
    E_INVALIDARG,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "switch terminal %p to substream:%p", 
        pITTerminal, pITSubStream));
    
    CLock lock(m_lock);

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "the demux filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // first, find out which branch has the terminal now.
    for (int i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pITTerminal == pITTerminal)
        {
            break;
        }
    }

    if (i >= m_Branches.GetSize())
    {
        LOG((MSP_TRACE, "terminal %p doesn't exist", pITTerminal));
        return E_INVALIDARG;
    }

    // second, find out if the substream exists.
    if (m_SubStreams.Find(pITSubStream) < 0)
    {
        LOG((MSP_TRACE, "SubStream %p doesn't exist", pITSubStream));
        return E_INVALIDARG;
    }


    // thrid, find the participant on the substream and configure the demux
    // filter to render the participant on the chosen branch.
    ITParticipant *pITParticipant = NULL;
    DWORD dwSSRC;

    ((CSubStreamVideoRecv*)pITSubStream)->GetCurrentParticipant(
        &dwSSRC, &pITParticipant
        ) ;

    _ASSERTE(pITParticipant != NULL);

    // we don't need the reference here.
    pITParticipant->Release();

    // map the pin to this SSRC only.
    HRESULT hr = m_pIRTPDemux->SetMappingState(
        -1, m_Branches[i].pIPin, dwSSRC, TRUE
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "map SSRC %x to pin %p returned %x", 
            dwSSRC, m_Branches[i].pIPin, hr));
        return hr;
    }    

    DWORD dwOldSSRC = 0;

    // Finally, set up the mappings among the branch, the substream and 
    // the terminal
    
    // release the refcount on the old branch that the substream was on.
    for (int j = 0; j < m_Branches.GetSize(); j ++)
    {
        if (m_Branches[j].pITSubStream == pITSubStream)
        {
            m_Branches[j].pITSubStream->Release();
            m_Branches[j].pITSubStream = NULL;
            break;
        }
    }

    if (m_Branches[i].pITSubStream != NULL)
    {
        ((CSubStreamVideoRecv*)m_Branches[i].pITSubStream)->
            ClearCurrentTerminal();

        m_Branches[i].pITSubStream->Release();
        dwOldSSRC = m_Branches[i].dwSSRC;
    }

    pITSubStream->AddRef();
    m_Branches[i].pITSubStream = pITSubStream;
    m_Branches[i].dwSSRC = dwSSRC;

    ((CSubStreamVideoRecv*)pITSubStream)->ClearCurrentTerminal();
    ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentTerminal(
        m_Branches[i].pITTerminal
        );


    // After all the steps, we still have to change QOS reservation.
    if (dwOldSSRC != 0)
    {
        // cancel QOS for the old participant.
        if (FAILED(hr = m_pIRTPSession->SetQosState(dwOldSSRC, FALSE)))
        {
            LOG((MSP_ERROR, "disabling QOS for %x. hr:%x", dwOldSSRC, hr));
        }
        else
        {
            LOG((MSP_INFO, "disabled video QOS for %x.", dwOldSSRC));
        }
    }
    
    // reserve QOS for the new participant.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, TRUE)))
    {
        LOG((MSP_ERROR, "enabling video QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }

    return S_OK;
}


HRESULT CStreamVideoRecv::ProcessTalkingEvent(
    IN  DWORD dwSSRC
    )
/*++

Routine Description:

    A sender has just joined. A substream needs to be created for the
    participant. 
    
    A pin mapped event might have happended when we didn't have the 
    participant's name so it was queued in a list. Now that we have a new 
    participant, let's check if this is the same participant. If it is, 
    we complete the pin mapped event by sending the app an notification.

Arguments:

    dwSSRC - the SSRC of the participant.

    pITParticipant - the participant object.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    ENTER_FUNCTION("CStreamVideoRecv::ProcessTalkingEvent");

    LOG((MSP_TRACE, "%s entered. %x", __fxName, dwSSRC));

    CLock lock(m_lock);

    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "the network filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // first find out if this participant object exists.
    ITParticipant * pITParticipant = NULL;
    
    int i;
    // find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            break;
        }
    }

    // if the participant is not there yet, just return. It will be checked
    // later when CName is available.
    if (!pITParticipant)
    {
        LOG((MSP_TRACE, "%s participant not exist", __fxName));
    
        return S_OK;
    }

    // Find out if a substream has been created for this participant when we
    // processed PinMapped event and receiver reports.
    for (i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pITParticipant == pTempParticipant)
        {
            // the participant has been created.
            return S_OK;
        }
    }

    ITSubStream * pITSubStream;
    HRESULT hr = InternalCreateSubStream(&pITSubStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't create a SubStream, %x", m_szName, hr));
        return hr;
    }

    ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentParticipant(
        dwSSRC, pITParticipant
        );

    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_NEW_SUBSTREAM, 
        pITParticipant,
        pITSubStream
        );

    // look at the pending SSRC list and find out if this report
    // fits in the list.
    IPin *pIPin = NULL;

    for (i = 0; i < m_PinMappedEvents.GetSize(); i ++)
    {
        if (m_PinMappedEvents[i].dwSSRC == dwSSRC)
        {
            pIPin = m_PinMappedEvents[i].pIPin;
            break;
        }
    }
    
    if (!pIPin)
    {
        // the SSRC is not in the list of pending PinMappedEvents.
        LOG((MSP_TRACE, "the SSRC %x is not in the pending list", dwSSRC));

        pITSubStream->Release();
    
        return S_OK;;
    }

    // get rid of the peding event.
    m_PinMappedEvents.RemoveAt(i);

    // reserve QOS since we are rendering this sender.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, TRUE)))
    {
        LOG((MSP_ERROR, "enabling video QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }

    // tell the app about the newly mapped sender.
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pIPin == pIPin)
        {
            if (m_Branches[i].pITSubStream != NULL)
            {
                ((CSubStreamVideoRecv*)m_Branches[i].pITSubStream)
                    ->ClearCurrentTerminal();

                m_Branches[i].pITSubStream->Release();
            }

            m_Branches[i].dwSSRC = dwSSRC;
            m_Branches[i].pITSubStream = pITSubStream;
            pITSubStream->AddRef();

            ((CSubStreamVideoRecv*)pITSubStream)->
                SetCurrentTerminal(m_Branches[i].pITTerminal);

            ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                PE_SUBSTREAM_MAPPED, 
                pITParticipant,
                pITSubStream
                );

            break;
        }
    }

    pITSubStream->Release();
    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessSilentEvent(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "%ls ProcessSilentEvent, SSRC: %x", m_szName, dwSSRC));
    
    CLock lock(m_lock);
    
    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "the network filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // first find out if this participant object exists.
    ITParticipant * pITParticipant = NULL;

    int i;
    // find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            break;
        }
    }

    // if the participant is not there, just return.
    if (!pITParticipant)
    {
        return S_OK;
    }

  
    HRESULT hr;
    // cancel QOS for this participant.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, FALSE)))
    {
        LOG((MSP_ERROR, "disabling QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "disabled video QOS for %x.", dwSSRC));
    }
    
    // find out which substream is going away.
    ITSubStream * pITSubStream = NULL;
    for (i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        // Find out the participant on the SubStream.
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pTempParticipant == pITParticipant)
        {
            pITSubStream = m_SubStreams[i];
            break;
        }
    }

    if (pITSubStream)
    {
        // remove the mapping if the substream was mapped to a branch.
        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pITSubStream == pITSubStream)
            {
                m_Branches[i].pITSubStream->Release();
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;

                // fire an event to tell the app that the substream is not used.
                ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                    PE_SUBSTREAM_UNMAPPED, 
                    pITParticipant,
                    pITSubStream
                    );

                break;
            }

        }
    
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_SUBSTREAM_REMOVED, 
            pITParticipant,
            pITSubStream
            );

        if (m_SubStreams.Remove(pITSubStream))
        {
            pITSubStream->Release();
        }
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::NewParticipantPostProcess(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
/*++

Routine Description:

    A pin mapped event might have happended when we didn't have the 
    participant's name so it was queued in a list. Now that we have a new 
    participant, let's check if this is the same participant. If it is, 
    we complete the pin mapped event by creating a substream and send
    the app a notification.

Arguments:

    dwSSRC - the SSRC of the participant.

    pITParticipant - the participant object.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Check pending mapped event, dwSSRC: %x", m_szName, dwSSRC));
    
    // look at the pending SSRC list and find out if this report
    // fits in the list.
    IPin *pIPin = NULL;

    for (int i = 0; i < m_PinMappedEvents.GetSize(); i ++)
    {
        if (m_PinMappedEvents[i].dwSSRC == dwSSRC)
        {
            pIPin = m_PinMappedEvents[i].pIPin;
            break;
        }
    }
    
    if (!pIPin)
    {
        // the SSRC is not in the list of pending PinMappedEvents.
        LOG((MSP_TRACE, "the SSRC %x is not in the pending list", dwSSRC));

        // Find out if the participant is talking.
        // if (ParticipantIsNotTalking)
        {
            return S_OK;;
        }
    }

    ITSubStream * pITSubStream;
    HRESULT hr = InternalCreateSubStream(&pITSubStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't create a SubStream, %x", m_szName, hr));
        return hr;
    }

    ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentParticipant(
        dwSSRC, pITParticipant
        );

    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_NEW_SUBSTREAM, 
        pITParticipant,
        pITSubStream
        );

    if (pIPin)
    {
        // we got here because we had a pending mapped event.

        // get rid of the peding event.
        m_PinMappedEvents.RemoveAt(i);

        if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, TRUE)))
        {
            LOG((MSP_ERROR, "enabling video QOS for %x. hr:%x", dwSSRC, hr));
        }
        else
        {
            LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
        }
    
        // Now we get the participant, the substream, and the pin. Establish a mapping
        // between the decoding branch and the substream.
        for (i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pIPin == pIPin)
            {
                if (m_Branches[i].pITSubStream != NULL)
                {
                    ((CSubStreamVideoRecv*)m_Branches[i].pITSubStream)
                        ->ClearCurrentTerminal();

                    m_Branches[i].pITSubStream->Release();
                }

                m_Branches[i].dwSSRC = dwSSRC;
                m_Branches[i].pITSubStream = pITSubStream;
                pITSubStream->AddRef();

                ((CSubStreamVideoRecv*)pITSubStream)->
                    SetCurrentTerminal(m_Branches[i].pITTerminal);

                ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                    PE_SUBSTREAM_MAPPED, 
                    pITParticipant,
                    pITSubStream
                    );

                break;
            }
        }
        _ASSERT(i < m_Branches.GetSize());
    }

    pITSubStream->Release();
   
    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessPinMappedEvent(
    IN  DWORD   dwSSRC,
    IN  IPin *  pIPin
    )
/*++

Routine Description:

    A pin just got a new SSRC mapped to it. If the participant doesn't exist, 
    put the event in a pending queue and wait for a RTCP report that has the
    participant's name. If the participant exists, check to see if a SubStream
    has been created for the stream. If not, a SubStream is created. Then a
    Particiapnt substream event is fired.

Arguments:

    dwSSRC - the SSRC of the participant.

    pIPin - the output pin of the demux filter that just got a new SSRC.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Process pin mapped event, pIPin: %p", m_szName, pIPin));
    
    CLock lock(m_lock);

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "the demux filter doesn't exist."));
        return E_UNEXPECTED;
    }

    for (int iBranch = 0; iBranch < m_Branches.GetSize(); iBranch ++)
    {
        if (m_Branches[iBranch].pIPin == pIPin)
        {
            break;
        }
    }

    LOG((MSP_INFO, "Branch %d has the pin", iBranch));

    if (iBranch >= m_Branches.GetSize())
    {
        LOG((MSP_ERROR, "Wrong pin is mapped. %p", pIPin));
        return E_UNEXPECTED;
    }

    // sometimes we might get a mapped event for branches that are still 
    // in use.
    if (m_Branches[iBranch].pITSubStream != NULL)
    {
        LOG((MSP_ERROR, "ProcessPinMappedEvent: Branch still in use"));

        // sometimes we might get duplicated map events
        if (m_Branches[iBranch].dwSSRC == dwSSRC)
        {
            // LOG((MSP_WARNING, "ProcessPinMappedEvent: Branch still in use"));

            LOG((MSP_ERROR, "The same pin mapped twice. %p", pIPin));
            return E_UNEXPECTED;
        }
        else
        {
            LOG((MSP_ERROR, "The branch is in use. Cleaning up."));

            ((CSubStreamVideoRecv*)m_Branches[iBranch].pITSubStream)->
                ClearCurrentTerminal();

            // cancel QOS for the old participant.
            m_pIRTPSession->SetQosState(m_Branches[iBranch].dwSSRC, FALSE);

            m_Branches[iBranch].pITSubStream->Release();
            m_Branches[iBranch].pITSubStream = NULL;
            m_Branches[iBranch].dwSSRC = 0;
        }
    }

    ITParticipant * pITParticipant = NULL;

    // find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            break;
        }
    }

    // if the participant is not there yet, put the event in a queue and it
    // will be fired when we have the CName for the participant.
    if (!pITParticipant)
    {
        LOG((MSP_INFO, "can't find a participant that has SSRC %x", dwSSRC));

        PINMAPEVENT Event;
        Event.pIPin = pIPin;
        Event.dwSSRC = dwSSRC;

        m_PinMappedEvents.Add(Event);
        
        LOG((MSP_INFO, "added the event to pending list, new list size:%d", 
            m_PinMappedEvents.GetSize()));

        return S_OK;
    }

    HRESULT hr;

    // Enable QOS for the participant since it is being rendered.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, TRUE)))
    {
        LOG((MSP_ERROR, "enabling vidoe QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }
    
    // Find out if a substream has been created for this participant who might
    // have been a receiver only and hasn't got a substream.
    ITSubStream *   pITSubStream = NULL;
    for (i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pITParticipant == pTempParticipant)
        {
            pITSubStream = m_SubStreams[i];
            pITSubStream->AddRef();

            break;
        }
    }

    if (pITSubStream == NULL)
    {
        // we need to create a substream for this participant since he has 
        // started sending.
        hr = InternalCreateSubStream(&pITSubStream);
    
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%ls can't create a SubStream, %x", m_szName, hr));
            return hr;
        }

        ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentParticipant(
            dwSSRC, pITParticipant
            );

        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_NEW_SUBSTREAM, 
            pITParticipant,
            pITSubStream
            );
    }

    if (((CSubStreamVideoRecv*)pITSubStream)->ClearCurrentTerminal())
    {
        // The substrem has a terminal before. This is an error.
        // _ASSERT(!"SubStream has a terminal already");

        LOG((MSP_ERROR, "SubStream %p has already got a terminal", pITSubStream));

        // remove the mapping if the substream was mapped to a branch.
        for (i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pITSubStream == pITSubStream)
            {
                // cancel QOS for the old participant.
                m_pIRTPSession->SetQosState(m_Branches[i].dwSSRC, FALSE);

                m_Branches[i].pITSubStream->Release();
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;

                LOG((MSP_ERROR, "SubStream %p was mapped to branch %d", i));
                break;
            }
        }
    }

    // Now we get the participant, the substream, and the pin. Establish a mapping
    // between the decoding branch and the substream.
    m_Branches[iBranch].dwSSRC = dwSSRC;
    m_Branches[iBranch].pITSubStream = pITSubStream;
    pITSubStream->AddRef();

    ((CSubStreamVideoRecv*)pITSubStream)->
        SetCurrentTerminal(m_Branches[iBranch].pITTerminal);

    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_SUBSTREAM_MAPPED, 
        pITParticipant,
        pITSubStream
        );

    pITSubStream->Release();
   
    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessPinUnmapEvent(
    IN  DWORD   dwSSRCOnPin,
    IN  IPin *  pIPin
    )
/*++

Routine Description:

    A pin just got unmapped by the demux. Notify the app which substream
    is not going to have any data.

Arguments:

    dwSSRCOnPin - the SSRC of the participant.

    pIPin - the output pin of the demux filter

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Proces pin unmapped event, pIPin: %p", m_szName, pIPin));
    
    CLock lock(m_lock);

    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "the demux filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // look at the pending SSRC list and find out if the pin is in the 
    // pending list.
    for (int i = 0; i < m_PinMappedEvents.GetSize(); i ++)
    {
        if (m_PinMappedEvents[i].pIPin == pIPin)
        {
            break;
        }
    }

    // if the pin is in the pending list, just remove it.
    if (i < m_PinMappedEvents.GetSize())
    {
        m_PinMappedEvents.RemoveAt(i);
        return S_OK;
    }

    // find out which substream got unmapped.
    ITSubStream * pITSubStream = NULL;
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pIPin == pIPin)
        {
            pITSubStream = m_Branches[i].pITSubStream;

            if (pITSubStream)
            {
                // Don't release the ref until the end of this function.
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;
            }
            break;
        }
    }

    if (!pITSubStream)
    {
        LOG((MSP_ERROR, "can't find a substream that got unmapped."));
        return TAPI_E_NOITEMS;
    }

    ((CSubStreamVideoRecv*)pITSubStream)->ClearCurrentTerminal();

    ITParticipant *pITParticipant = NULL;
    DWORD dwSSRC;

    ((CSubStreamVideoRecv*)pITSubStream)->GetCurrentParticipant(
        &dwSSRC, &pITParticipant
        ) ;

    _ASSERTE(pITParticipant != NULL);

    if (dwSSRCOnPin != dwSSRC)
    {
        LOG((MSP_ERROR, "SSRCs don't match, pin's SSRC:%x, mine:%x", 
            dwSSRCOnPin, dwSSRC));
    }

    if (pITParticipant != NULL)
    {
        // fire an event to tell the app that the substream is not used.
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_SUBSTREAM_UNMAPPED, 
            pITParticipant,
            pITSubStream
            );

        pITParticipant->Release();

        // cancel QOS for this participant.
        HRESULT hr = m_pIRTPSession->SetQosState(dwSSRC, FALSE);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "disabling QOS for %x. hr:%x", dwSSRC, hr));
        }
        else
        {
            LOG((MSP_INFO, "disabled video QOS for %x.", dwSSRC));
        }
    }

    pITSubStream->Release();

    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessParticipantLeave(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "%ls ProcessParticipantLeave, SSRC: %x", m_szName, dwSSRC));
    
    CLock lock(m_lock);
    
    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "the network filter doesn't exist."));
        return E_UNEXPECTED;
    }

    CParticipant *pParticipant;
    BOOL fLast = FALSE;

    HRESULT hr = E_FAIL;

    // first try to find the SSRC in our participant list.
    for (int iParticipant = 0; 
        iParticipant < m_Participants.GetSize(); iParticipant ++)
    {
        pParticipant = (CParticipant *)m_Participants[iParticipant];
        hr = pParticipant->RemoveStream(
                (ITStream *)this,
                dwSSRC,
                &fLast
                );
        
        if (SUCCEEDED(hr))
        {
            break;
        }
    }

    // if the participant is not found
    if (FAILED(hr))
    {
        LOG((MSP_TRACE, "SSRC:%x had been removed.", dwSSRC));
        return hr;
    }

    ITParticipant *pITParticipant = m_Participants[iParticipant];

    // cancel QOS for this participant.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, FALSE)))
    {
        // the stream might already been stopped
        // so we just put a warning here
        LOG((MSP_WARN, "disabling QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "disabled video QOS for %x.", dwSSRC));
    }
    
    // find out which substream is going away.
    ITSubStream * pITSubStream = NULL;
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        // Find out the participant on the SubStream.
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pTempParticipant == pITParticipant)
        {
            pITSubStream = m_SubStreams[i];
            break;
        }
    }

    if (pITSubStream)
    {
        // remove the mapping if the substream was mapped to a branch.
        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pITSubStream == pITSubStream)
            {
                m_Branches[i].pITSubStream->Release();
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;

                // fire an event to tell the app that the substream is not used.
                ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                    PE_SUBSTREAM_UNMAPPED, 
                    pITParticipant,
                    pITSubStream
                    );

                break;
            }

        }
    
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_SUBSTREAM_REMOVED, 
            pITParticipant,
            pITSubStream
            );

        if (m_SubStreams.Remove(pITSubStream))
        {
            pITSubStream->Release();
        }
    }

    
    m_Participants.RemoveAt(iParticipant);

    // if this stream is the last stream that the participant is on,
    // tell the call object to remove it from its list.
    if (fLast)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->ParticipantLeft(pITParticipant);
    }

    pITParticipant->Release();

    return S_OK;
}

//
// ITStreamQualityControl methods
//
STDMETHODIMP CStreamVideoRecv::Set (
    IN   StreamQualityProperty Property, 
    IN   long lValue, 
    IN   TAPIControlFlags lFlags
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamVideoRecv::Get(
    IN  InnerStreamQualityProperty property, 
    OUT LONG *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a quality control property. Delegated to the quality 
    controller.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoRecv::Get(QualityControl)");

    HRESULT hr;
    int i;
    LONG totalbps, bps;

    CLock lock(m_lock);

    switch (property)
    {
    case InnerStreamQuality_MaxBitrate:

        bps = 0;
        totalbps = 0;

        for (i=0; i<m_Branches.GetSize (); i++)
        {
            if (NULL == m_Branches[i].pBitrateControl)
                continue;

            if (FAILED (hr = m_Branches[i].pBitrateControl->Get (BitrateControl_Maximum, &bps, plFlags, LAYERID)))
                LOG ((MSP_ERROR, "%s failed to get maximum bitrate, %x", __fxName, hr));
            else
                totalbps += bps;
        }

        *plValue = totalbps;

        hr = S_OK;
        break;

    case InnerStreamQuality_CurrBitrate:

        bps = 0;
        totalbps = 0;

        for (i=0; i<m_Branches.GetSize (); i++)
        {
            if (NULL == m_Branches[i].pBitrateControl)
                continue;

            if (FAILED (hr = m_Branches[i].pBitrateControl->Get (BitrateControl_Current, &bps, plFlags, LAYERID)))
                LOG ((MSP_ERROR, "%s failed to get current bitrate, %x", __fxName, hr));
            else
                totalbps += bps;
        }

        *plValue = totalbps;

        hr = S_OK;
        break;

    default:
        hr = CIPConfMSPStream::Get (property, plValue, plFlags);
        break;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamVideoSend
//
/////////////////////////////////////////////////////////////////////////////
CStreamVideoSend::CStreamVideoSend()
    : CIPConfMSPStream(),
    m_pCaptureTerminal(NULL),
    m_pPreviewTerminal(NULL),
    m_pCaptureFilter(NULL),
    m_pCapturePin(NULL),
    m_pPreviewPin(NULL),
    m_pRTPPin(NULL),
    m_pCaptureBitrateControl(NULL),
    m_pCaptureFrameRateControl(NULL),
    m_pPreviewFrameRateControl(NULL)
{
      m_szName = L"VideoSend";
}

CStreamVideoSend::~CStreamVideoSend()
{
    CleanupCachedInterface();
}

void CStreamVideoSend::CleanupCachedInterface()
{
    if (m_pCaptureFilter) 
    {
        m_pCaptureFilter->Release();
        m_pCaptureFilter = NULL;
    }

    if (m_pCapturePin)
    {
        m_pCapturePin->Release();
        m_pCapturePin = NULL;
    }

    if (m_pIStreamConfig)
    {
        m_pIStreamConfig->Release();
        m_pIStreamConfig = NULL;
    }

    if (m_pPreviewPin) 
    {
        m_pPreviewPin->Release();
        m_pPreviewPin = NULL;
    }

    if (m_pRTPPin)
    {
        m_pRTPPin->Release();
        m_pRTPPin = NULL;
    }

    if (m_pCaptureFrameRateControl)
    {
        m_pCaptureFrameRateControl->Release();
        m_pCaptureFrameRateControl = NULL;
    }

    if (m_pCaptureBitrateControl)
    {
        m_pCaptureBitrateControl->Release();
        m_pCaptureBitrateControl = NULL;
    }

    if (m_pPreviewFrameRateControl)
    {
        m_pPreviewFrameRateControl->Release();
        m_pPreviewFrameRateControl = NULL;
    }
}

HRESULT CStreamVideoSend::ShutDown()
/*++

Routine Description:

    Shut down the stream. Release our members and then calls the base class's
    ShutDown method.

Arguments:
    

Return Value:

S_OK
--*/
{
    CLock lock(m_lock);

    // if there are terminals
    BOOL fHasTerminal = FALSE;
    if (m_Terminals.GetSize() > 0)
    {
        fHasTerminal = TRUE;
    }

    // if graph is running
    HRESULT hr;
    OAFilterState FilterState = State_Stopped;
    if (m_pIMediaControl)
    {
        if (FAILED (hr = m_pIMediaControl->GetState(0, &FilterState)))
        {
            LOG ((MSP_ERROR, "CStreamAudioRecv::ShutDown failed to query filter state. %d", hr));
            FilterState = State_Stopped;
        }
    }

    if (m_pCaptureTerminal) 
    {
        m_pCaptureTerminal->Release();
        m_pCaptureTerminal = NULL;
    }

    if (m_pPreviewTerminal) 
    {
        m_pPreviewTerminal->Release();
        m_pPreviewTerminal = NULL;
    }

    CleanupCachedInterface();

    // fire event
    if (fHasTerminal && FilterState == State_Running)
    {
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    }

    return CIPConfMSPStream::ShutDown();
}

HRESULT 
SetVideoFormat(
    IN      IUnknown *  pIUnknown,
    IN      BOOL        bCIF,
    IN      DWORD       dwFramesPerSecond
    )
/*++

Routine Description:

    Set the video format to be CIF or QCIF and also set the frames per second.

Arguments:
    
    pIUnknown - a capture terminal.

    bCIF                - CIF or QCIF.

    dwFramesPerSecond   - Frames per second.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetVideoFormat"));

    HRESULT hr;

    // first get eht IAMStreamConfig interface.
    CComPtr<IAMStreamConfig> pIAMStreamConfig;

    if (FAILED(hr = pIUnknown->QueryInterface(
        __uuidof(IAMStreamConfig),
        (void **)&pIAMStreamConfig
        )))
    {
        LOG((MSP_ERROR, "Can't get IAMStreamConfig interface.%8x", hr));
        return hr;
    }
    
    // get the current format of the video capture terminal.
    AM_MEDIA_TYPE *pmt;
    if (FAILED(hr = pIAMStreamConfig->GetFormat(&pmt)))
    {
        LOG((MSP_ERROR, "GetFormat returns error: %8x", hr));
        return hr;
    }

    VIDEOINFO *pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
    if (pVideoInfo == NULL)
    {
        MSPDeleteMediaType(pmt);
        return E_UNEXPECTED;
    }

    BITMAPINFOHEADER *pHeader = HEADER(pmt->pbFormat);
    if (pHeader == NULL)
    {
        MSPDeleteMediaType(pmt);
        return E_UNEXPECTED;
    }

    LOG((MSP_INFO,
        "Video capture: Format BitRate: %d, TimePerFrame: %d",
        pVideoInfo->dwBitRate,
        pVideoInfo->AvgTimePerFrame));

    LOG((MSP_INFO, "Video capture: Format Compression:%c%c%c%c %dbit %dx%d",
        (DWORD)pHeader->biCompression & 0xff,
        ((DWORD)pHeader->biCompression >> 8) & 0xff,
        ((DWORD)pHeader->biCompression >> 16) & 0xff,
        ((DWORD)pHeader->biCompression >> 24) & 0xff,
        pHeader->biBitCount,
        pHeader->biWidth,
        pHeader->biHeight));

    // The time is in 100ns unit.
    pVideoInfo->AvgTimePerFrame = (DWORD) 1e7 / dwFramesPerSecond;
    
    if (bCIF)
    {
        pHeader->biWidth = CIFWIDTH;
        pHeader->biHeight = CIFHEIGHT;
    }
    else
    {
        pHeader->biWidth = QCIFWIDTH;
        pHeader->biHeight = QCIFHEIGHT;
    }

#if defined(ALPHA)
    // update bmiSize with new Width/Height
    pHeader->biSizeImage = DIBSIZE( ((VIDEOINFOHEADER *)pmt->pbFormat)->bmiHeader );
#endif

    if (FAILED(hr = pIAMStreamConfig->SetFormat(pmt)))
    {
        LOG((MSP_ERROR, "putMediaFormat returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO,
            "Video capture: Format BitRate: %d, TimePerFrame: %d",
            pVideoInfo->dwBitRate,
            pVideoInfo->AvgTimePerFrame));

        LOG((MSP_INFO, "Video capture: Format Compression:%c%c%c%c %dbit %dx%d",
            (DWORD)pHeader->biCompression & 0xff,
            ((DWORD)pHeader->biCompression >> 8) & 0xff,
            ((DWORD)pHeader->biCompression >> 16) & 0xff,
            ((DWORD)pHeader->biCompression >> 24) & 0xff,
            pHeader->biBitCount,
            pHeader->biWidth,
            pHeader->biHeight));
    }

    MSPDeleteMediaType(pmt);

    return hr;
}

HRESULT 
SetVideoBufferSize(
    IN IUnknown *pIUnknown
    )
/*++

Routine Description:

    Set the video capture terminal's buffersize.

Arguments:
    
    pIUnknown - a capture terminal.

Return Value:

    HRESULT

--*/
{
// The number of capture buffers is four for now.
#define NUMCAPTUREBUFFER 4

    LOG((MSP_TRACE, "SetVideoBufferSize"));

    HRESULT hr;

    CComPtr<IAMBufferNegotiation> pBN;
    if (FAILED(hr = pIUnknown->QueryInterface(
            __uuidof(IAMBufferNegotiation),
            (void **)&pBN
            )))
    {
        LOG((MSP_ERROR, "Can't get buffer negotiation interface.%8x", hr));
        return hr;
    }

    ALLOCATOR_PROPERTIES prop;

#if 0   // Get allocator property is not working.
    if (FAILED(hr = pBN->GetAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "GetAllocatorProperties returns error: %8x", hr));
        return hr;
    }

    // Set the number of buffers.
    if (prop.cBuffers > NUMCAPTUREBUFFER)
    {
        prop.cBuffers = NUMCAPTUREBUFFER;
    }
#endif
    
    DWORD dwBuffers = NUMCAPTUREBUFFER;
    GetRegValue(gszNumVideoCaptureBuffers, &dwBuffers);

    prop.cBuffers = dwBuffers;
    prop.cbBuffer = -1;
    prop.cbAlign  = -1;
    prop.cbPrefix = -1;

    if (FAILED(hr = pBN->SuggestAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "SuggestAllocatorProperties returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "SetVidedobuffersize"
            " buffers: %d, buffersize: %d, align: %d, Prefix: %d",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
            ));
    }
    return hr;
}

HRESULT CStreamVideoSend::FindPreviewInputPin(
    IN  ITTerminalControl*  pTerminal,
    OUT IPin **             ppIPin
    )
/*++

Routine Description:

    Find the input pin on a preview terminal.

Arguments:
    
    pTerminal - a video render terminal.

    ppIPin  - the address to store a pointer to a IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "VideoSend.FindPreviewInputPin, pTerminal %x", pTerminal));

/*
    // try to disable DDraw because we want to use DDraw for receive stream.
    HRESULT hr2; 
    IDrawVideoImage *pIDrawVideoImage;
    hr2 = pTerminal->QueryInterface(__uuidof(IDrawVideoImage), (void **)&pIDrawVideoImage); 
    if (SUCCEEDED(hr2))
    {
        hr2 = pIDrawVideoImage->DrawVideoImageBegin();
        if (FAILED(hr2))
        {
            LOG((MSP_WARN, "Can't disable DDraw. %x", hr2));
        }
        else
        {
            LOG((MSP_INFO, "DDraw disabled."));
        }
        
        pIDrawVideoImage->Release();
    }
    else
    {
        LOG((MSP_WARN, "Can't get IDrawVideoImage. %x", hr2));
    }
*/

    // Get the pins from the first terminal because we only use on terminal
    // on this stream.
    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_RENDER, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));
        return hr;
    }

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));
        return E_POINTER;
    }

    for (DWORD i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));
            return E_POINTER;
        }
    }

    // Save the first pin and release the others.
    CComPtr <IPin> pIPin = Pins[0];
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    pIPin->AddRef();
    *ppIPin = pIPin;

    return hr;
}

HRESULT CStreamVideoSend::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:
    
    Check if the terminal is allowed on this stream.
    VideoSend allows both a capture terminal and a preivew terminal.

Arguments:

    pTerminal   - the terminal.

Return value:

    HRESULT.
    S_OK means the terminal is OK.
*/
{
    LOG((MSP_TRACE, "VideoSend.CheckTerminalTypeAndDirection"));

    // This stream only support one capture + one preview terminal
    if (m_Terminals.GetSize() > 1)
    {
        return TAPI_E_MAXTERMINALS;
    }

    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (m_Terminals.GetSize() > 0)
    {
        // check the direction of this terminal.
        TERMINAL_DIRECTION Direction2;
        hr = m_Terminals[0]->get_Direction(&Direction2);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
            return TAPI_E_INVALIDTERMINAL;
        }
        if (Direction == Direction2)
        {
            LOG((MSP_ERROR, 
                "can't have two terminals with the same direction. %x", hr));
            return TAPI_E_MAXTERMINALS;
        }
    }
    return S_OK;
}

HRESULT CStreamVideoSend::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.SetUpFilters"));

    // we only support one capture terminal and one preview 
    // window on this stream.
    if (m_Terminals.GetSize() > 2)
    {
        return E_UNEXPECTED;
    }

    int iCaptureIndex = -1, iPreviewIndex = -1;

    // Find out which terminal is capture and which is preview.
    HRESULT hr;
    for (int i = 0; i < m_Terminals.GetSize(); i ++)
    {
        TERMINAL_DIRECTION Direction;
        hr = m_Terminals[i]->get_Direction(&Direction);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, m_Terminals[i]);
        
            return hr;
        }

        if (Direction == TD_CAPTURE || Direction == TD_BIDIRECTIONAL)
        {
            iCaptureIndex = i;
        }
        else
        {
            iPreviewIndex = i;
        }
    }

    // the stream will not work without a capture terminal.
    if (iCaptureIndex == -1)
    {
        LOG((MSP_ERROR, "no capture terminal selected."));
        return E_UNEXPECTED;
    }

    // Connect the capture filter to the terminal.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[iCaptureIndex]
        )))
    {
        LOG((MSP_ERROR, "connect the codec filter to terminal. %x", hr));

        return hr;
    }

    if (iPreviewIndex != -1)
    {
        // Connect the preview filter to the terminal.
        if (FAILED(hr = ConnectTerminal(
            m_Terminals[iPreviewIndex]
            )))
        {
            LOG((MSP_ERROR, "connect the codec filter to terminal. %x", hr));

            return hr;
        }
    }

    return hr;
}

HRESULT CStreamVideoSend::GetVideoCapturePins(
    IN  ITTerminalControl*  pTerminal,
    OUT BOOL *pfDirectRTP
    )
/*++

Routine Description:

    Given a video capture terminal, find all the pins we need, which will be
    the capture pin, preview pin, and the RTP packetization pin.

    Side effect: It changes the m_pCapturePin, m_pPreviewPin, m_pRTPPin
    members, which needs to be cleaned up if the terminal is disconnected.

Arguments:
    
    pTerminal - a pointer to the ITTerminalControl interface.

    pfDirectRTP - whether this terminal support RTP directly.

Return Value:

    HRESULT

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::GetVideoCapturePins");
    LOG((MSP_TRACE, "%s enters", __fxName));

    const DWORD MAXPINS     = 4;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_CAPTURE, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, can't connect to terminal, hr=%x", __fxName, hr));
        return hr;
    }

    _ASSERT(m_pCapturePin == NULL && m_pPreviewPin == NULL && m_pRTPPin == NULL);
    
    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));
        return E_POINTER;
    }


    // find the pins we need.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));
            hr = E_POINTER;
            break;
        }

        PIN_INFO PinInfo;
        hr = Pins[i]->QueryPinInfo(&PinInfo);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, can't get pin info, hr=%x", __fxName, hr));
            break;
        }
        
        if (lstrcmpW(PinInfo.achName, PNAME_CAPTURE) == 0)
        {
            m_pCapturePin = Pins[i];
            
            // remember the capture filter as well.
            m_pCaptureFilter = PinInfo.pFilter;
            m_pCaptureFilter->AddRef();

        }
        else if (lstrcmpW(PinInfo.achName, PNAME_PREVIEW) == 0)
        {
            m_pPreviewPin = Pins[i];
        }
        else if (lstrcmpW(PinInfo.achName, PNAME_RTPPD) == 0)
        {
            m_pRTPPin = Pins[i];
        }
        else if (PinInfo.dir == PINDIR_OUTPUT)
        {
            // this must be the capture filter of some third party terminal.
            m_pCapturePin = Pins[i];
            
            // remember the capture filter as well.
            m_pCaptureFilter = PinInfo.pFilter;
            m_pCaptureFilter->AddRef();

        }
        else
        {
            Pins[i]->Release();
        }

        // we don't need the filter here.
        PinInfo.pFilter->Release();
    }


    // check if we have got all the pins we need.
    if (m_pCapturePin == NULL || 
        m_pPreviewPin == NULL || 
        m_pRTPPin == NULL)
    {
        if ((m_pCapturePin != NULL) 
            && (hr = ::PinSupportsMediaType(
                m_pCapturePin, __uuidof(MEDIATYPE_RTP_Single_Stream))) == S_OK)
        {
            // This terminal generates RTP directly.
            *pfDirectRTP = TRUE;
            return S_OK;
        }

        LOG((MSP_ERROR, 
            "%s, can't find all the pins, Capture:%p, Preview:%p, RTP:%P", 
            __fxName, m_pCapturePin, m_pPreviewPin, m_pRTPPin));

        hr = E_UNEXPECTED;
    }

    if (hr != S_OK)
    {
        // something is wrong, clean up
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
        
        CleanupCachedInterface();

        return hr;
    }

    // now get the optional video interfaces.
    _ASSERT(m_pIStreamConfig == NULL);

    hr = m_pCapturePin->QueryInterface(&m_pIStreamConfig);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, "%s, queryinterface failed", __fxName));
    }

    hr = m_pCapturePin->QueryInterface(&m_pCaptureFrameRateControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture pin's IFrameRateControl failed, hr=%x", 
            __fxName, hr));
    }

    hr = m_pCapturePin->QueryInterface(&m_pCaptureBitrateControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture pin's IBitRateControl failed, hr=%x", 
            __fxName, hr));
    }

    hr = m_pPreviewPin->QueryInterface(&m_pPreviewFrameRateControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query preview pin's IFrameRateControl failed, hr=%x", 
            __fxName, hr));
    }

    return S_OK;
}

HRESULT CStreamVideoSend::ConnectCaptureTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:
    
    The stream needs its capture pin, preview pin,  and RTP packetization pin. 
    
    The capture pin and the preview pin are connected to the RTP sink filter 
    and the preview pin is connected to the preivew terminal. If the preview 
    terminal doesn't exist yet, the preview pin is remembered and used later
    when the preview terminal is selected.

Arguments:
    
    pITTerminal - the terminal being connected.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::ConnectCaptureTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    // Get the TerminalControl interface on the terminal
    CComPtr<ITTerminalControl> pTerminal;
    HRESULT hr = pITTerminal->QueryInterface(&pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, can't get Terminal Control interface", __fxName));
        
        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);

        return E_NOINTERFACE;
    }

    // Find the pins on the capture terminal. The pins will be stored in 
    // m_pCapturePin, m_pPreviewPin, m_pRTPPin
    BOOL fDirectRTP = FALSE;
    hr = GetVideoCapturePins(pTerminal, &fDirectRTP);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, Get capture pins failed. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
    
        return hr;
    }

    hr = CreateSendFilters(m_pCapturePin, m_pRTPPin, fDirectRTP);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, Create video send filters failed. hr=%x", __fxName, hr));

        goto cleanup;
    }

    //
    // Now we are actually connected. Update our state and perform 
    // postconnection.
    //
    hr = pTerminal->CompleteConnectTerminal();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, Create video send filters failed. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);

        goto cleanup;

    }

    if (m_pPreviewTerminal != NULL)
    {
        // errors will be fired as events.
        ConnectPreviewTerminal(m_pPreviewTerminal);
    }

    return S_OK;

cleanup:
    // disconnect the terminal.
    pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

    CleanupCachedInterface();
    
    // clean up internal filters as well.
    CleanUpFilters();

    return hr;
}

HRESULT CStreamVideoSend::ConnectPreviewTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:
    
    If the capture terminal has been connected, this function connects the
    capture terminal's preview pin with the preview terminal. Otherwise, the
    preview terminal is just remembered and wait for the capture terminal.

Arguments:
    
    pITTerminal - the terminal being connected.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::ConnectPreviewTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    if (!m_pCapturePin)
    {
        LOG ((MSP_TRACE, "%s capture pin is null.", __fxName));
        return E_FAIL;
    }

    if (!m_pPreviewPin)
    {
        // the capture terminal is not selected yet. We will just wait.
        LOG((MSP_TRACE, "%s, capture is not ready yet.", __fxName));
        return S_OK;
    }

    // Get the TerminalControl interface on the terminal
    CComPtr<ITTerminalControl> pTerminal;
    HRESULT hr = pITTerminal->QueryInterface(&pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, can't get Terminal Control interface", __fxName));
        
        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);

        return E_NOINTERFACE;
    }

    // find the input pin on the preview window.
    CComPtr<IPin>   pPreviewInputPin;

    hr = FindPreviewInputPin(pTerminal, &pPreviewInputPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, find preview input pin failed. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);

        return hr;
    }

    // connect the pins together.
    hr = m_pIGraphBuilder->Connect(m_pPreviewPin, pPreviewInputPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, connect preview pins failed. hr=%x", __fxName, hr));
        return hr;
    }

    //
    // Now we are actually connected, perform postconnection.
    //
    hr = pTerminal->CompleteConnectTerminal();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, complete connect terminal failed. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);

        // disconnect the terminal.
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return hr;
    }

    return S_OK;
}

HRESULT CStreamVideoSend::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the video terminals to the stream.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::ConnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    // Find out the direction of the terminal.
    TERMINAL_DIRECTION Direction;
    HRESULT hr = pITTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, can't get terminal direction. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
    
        return hr;
    }

    if (Direction != TD_RENDER)
    {
        hr = ConnectCaptureTerminal(pITTerminal);

        if (SUCCEEDED(hr))
        {
            // save the capture terminal.
            _ASSERT(m_pCaptureTerminal == NULL);

            m_pCaptureTerminal = pITTerminal;
            m_pCaptureTerminal->AddRef();
        }
    }
    else
    {
        hr = ConnectPreviewTerminal(pITTerminal);

        if (SUCCEEDED(hr))
        {
            // save the preview terminal.
            _ASSERT(m_pPreviewTerminal == NULL);

            m_pPreviewTerminal = pITTerminal;
            m_pPreviewTerminal->AddRef();
        }
    }

    return hr;
}

HRESULT CStreamVideoSend::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

    If it is the capture terminal being disconnected, all the pins that the 
    stream cached need to be released too. 

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::DisconnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    HRESULT hr = CIPConfMSPStream::DisconnectTerminal(pITTerminal);

    if (pITTerminal == m_pCaptureTerminal)
    {
        // release all the capture pins we cached.
        CleanupCachedInterface();
    
        m_pCaptureTerminal->Release();
        m_pCaptureTerminal = NULL;

        CleanUpFilters ();

        // disconnect preview term as well
        // when we connect capture,
        // we always try to connect preview if one is available

        if (m_pPreviewTerminal)
        {
            CIPConfMSPStream::DisconnectTerminal(m_pPreviewTerminal);
        }
    }
    else if (pITTerminal == m_pPreviewTerminal)
    {
        m_pPreviewTerminal->Release();
        m_pPreviewTerminal = NULL;
    }


    return hr;
}

HRESULT CStreamVideoSend::ConnectRTPFilter(
    IN  IGraphBuilder *pIGraphBuilder,
    IN  IPin          *pCapturePin,
    IN  IPin          *pRTPPin,
    IN  IBaseFilter   *pRTPFilter
    )
{
    ENTER_FUNCTION("CStreamVideoSend::ConnectRTPFilters");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    // find the capture pin on the RTP filter.
    CComPtr <IPin> pRTPCapturePin; 
    hr = pRTPFilter->FindPin(PNAME_CAPTURE, &pRTPCapturePin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, find capture pin on rtp filter. %x", __fxName, hr));
        return hr;
    }

    // Connect the capture pin of the video capture filter with the capture pin
    // of the rTP filter.
    hr = pIGraphBuilder->ConnectDirect(pCapturePin, pRTPCapturePin, NULL);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, can't connect capture pins. %x", __fxName, hr));
        return hr;
    }

    if (pRTPPin)
    {
        // find the packetization pin on the RTP filter.
        CComPtr <IPin> pRTPRTPPin; 
        hr = pRTPFilter->FindPin(PNAME_RTPPD, &pRTPRTPPin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "%s, find capture pin on rtp filter. %x", __fxName, hr));

            pIGraphBuilder->Disconnect(pRTPPin);

            return hr;
        }

        // Connect the RTP pin of the video capture filter with the RTP pin
        // of the rTP filter.
        hr = pIGraphBuilder->ConnectDirect(pRTPPin, pRTPRTPPin, NULL);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "%s, can't connect capture pins. %x", __fxName, hr));

            pIGraphBuilder->Disconnect(pRTPPin);

            return hr;
        }
    }

    return hr;
}

HRESULT CStreamVideoSend::ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    )
/*++

Routine Description:

    Configure the RTP filter with RTP<-->AM media type mappings.

Arguments:
    
    pIRTPFilter - The source RTP Filter.

    pIStreamConfig - The stream config interface that has the media info.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("VideoSend::ConfigureRTPFormats");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    CComPtr<IRtpMediaControl> pIRtpMediaControl;
    hr = pIRTPFilter->QueryInterface(&pIRtpMediaControl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
        return hr;
    }

    // find the number of capabilities supported.
    DWORD dwCount;
    hr = pIStreamConfig->GetNumberOfCapabilities(&dwCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s GetNumberOfCapabilities. %x", __fxName, hr));
        return hr;
    }

    BOOL fFound = FALSE;
    BOOL fFormatSet = FALSE;

    for (DWORD dw = 0; dw < dwCount; dw ++)
    {
        // TODO, a new interface is needed to resolve RTP to MediaType.
        AM_MEDIA_TYPE *pMediaType;
        DWORD dwPayloadType;

        hr = pIStreamConfig->GetStreamCaps(
            dw, &pMediaType, NULL, &dwPayloadType
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s GetStreamCaps. %x", __fxName, hr));
            return hr;
        }

        BITMAPINFOHEADER *pHeader = HEADER(pMediaType->pbFormat);
        if (pHeader == NULL)
        {
            MSPDeleteMediaType(pMediaType);
            continue;
        }

        // check the image size
        if (m_Settings.fCIF)
        {
            if (pHeader->biWidth != CIFWIDTH)
            {
                MSPDeleteMediaType(pMediaType);
                continue;
            }
        }
        else
        {
            if (pHeader->biWidth != QCIFWIDTH)
            {
                MSPDeleteMediaType(pMediaType);
                continue;
            }
        }
        
        for (DWORD dw2 = 0; dw2 < m_Settings.dwNumPayloadTypes; dw2 ++)
        {
            if (dwPayloadType == m_Settings.PayloadTypes[dw2])
            {
                hr = pIRtpMediaControl->SetFormatMapping(
                    dwPayloadType,
                    90000,      // default video clock rate.
                    pMediaType
                    );

                if (FAILED(hr))
                {
                    MSPDeleteMediaType(pMediaType);

                    LOG((MSP_ERROR, "%s SetFormatMapping. %x", __fxName, hr));
                    return hr;
                }
                else
                {
                    LOG((MSP_INFO, "%s Configured payload:%d", __fxName, dwPayloadType));
                }

                if (dw2 == 0 && !fFormatSet)
                {